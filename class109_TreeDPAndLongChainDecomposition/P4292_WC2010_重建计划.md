# P4292 [WC2010]重建计划 题解

## 题目描述

给出一棵n个节点的树，每条边有一个权值。要求找一条简单路径，使得路径上的边数在[L,R]之间，并且路径上所有边的权值平均值最大。

## 解题思路

这是一个经典的01分数规划问题，结合长链剖分和线段树进行优化。

### 01分数规划
首先，我们使用01分数规划来解决这个问题。假设答案为ans，那么对于任意一条路径，有：
$$\frac{\sum w_i}{\sum 1} \geq ans$$
即：
$$\sum (w_i - ans) \geq 0$$

因此，我们可以二分答案ans，然后验证是否存在一条满足条件的路径使得$\sum (w_i - ans) \geq 0$。

### 树形DP验证
对于二分的每个ans，我们需要验证是否存在满足条件的路径。可以使用树形DP来解决：

设f[u][d]表示以u为端点，长度为d的路径的最大权值和（这里的权值是w_i - ans）。

在转移过程中，对于节点u和其子节点v，我们需要：
1. 更新答案：ans = max(ans, f[u][i] + f[v][j] + w)，其中L ≤ i + j + 1 ≤ R
2. 更新DP值：f[u][i+1] = max(f[u][i+1], f[v][i] + w)

### 长链剖分优化
由于DP状态只与深度有关，我们可以用长链剖分优化。但这里与前两题不同的是，我们需要维护区间最值，所以要用线段树来维护DP数组。

## 代码实现

### Java实现

```java
// P4292 [WC2010]重建计划 - Java实现
import java.io.*;
import java.util.*;

public class P4292_WC2010_重建计划 {
    static final int MAXN = 100005;
    static final double EPS = 1e-4;
    
    // 链式前向星存储树
    static int[] head = new int[MAXN];
    static int[] next = new int[MAXN << 1];
    static int[] to = new int[MAXN << 1];
    static double[] val = new double[MAXN << 1];
    static int cnt = 0;
    
    // 长链剖分相关数组
    static int[] dep = new int[MAXN];     // 每个节点的深度
    static int[] son = new int[MAXN];     // 每个节点的重儿子
    static int[] maxlen = new int[MAXN];  // 每个节点子树中的最大深度
    static int[] dfn = new int[MAXN];     // dfs序
    static int dfntot = 0;
    
    // 线段树相关
    static class SegmentTree {
        double[] maxVal;
        double[] addTag;
        int n;
        
        SegmentTree(int size) {
            n = size;
            maxVal = new double[size << 2];
            addTag = new double[size << 2];
            Arrays.fill(maxVal, -1e9);
        }
        
        void pushUp(int i) {
            maxVal[i] = Math.max(maxVal[i << 1], maxVal[i << 1 | 1]);
        }
        
        void pushDown(int i) {
            if (Math.abs(addTag[i]) > EPS) {
                maxVal[i << 1] += addTag[i];
                maxVal[i << 1 | 1] += addTag[i];
                addTag[i << 1] += addTag[i];
                addTag[i << 1 | 1] += addTag[i];
                addTag[i] = 0;
            }
        }
        
        void update(int jobl, int jobr, double jobv, int l, int r, int i) {
            if (jobl <= l && r <= jobr) {
                maxVal[i] += jobv;
                addTag[i] += jobv;
                return;
            }
            pushDown(i);
            int mid = (l + r) >> 1;
            if (jobl <= mid) update(jobl, jobr, jobv, l, mid, i << 1);
            if (jobr > mid) update(jobl, jobr, jobv, mid + 1, r, i << 1 | 1);
            pushUp(i);
        }
        
        void update(int pos, double val, int l, int r, int i) {
            if (l == r) {
                maxVal[i] = val;
                return;
            }
            pushDown(i);
            int mid = (l + r) >> 1;
            if (pos <= mid) update(pos, val, l, mid, i << 1);
            else update(pos, val, mid + 1, r, i << 1 | 1);
            pushUp(i);
        }
        
        double query(int jobl, int jobr, int l, int r, int i) {
            if (jobl <= l && r <= jobr) {
                return maxVal[i];
            }
            pushDown(i);
            int mid = (l + r) >> 1;
            double ans = -1e9;
            if (jobl <= mid) ans = Math.max(ans, query(jobl, jobr, l, mid, i << 1));
            if (jobr > mid) ans = Math.max(ans, query(jobl, jobr, mid + 1, r, i << 1 | 1));
            return ans;
        }
    }
    
    // DP相关数组
    static double ans;                    // 答案
    static int L, R;                      // 路径长度限制
    static SegmentTree[] seg = new SegmentTree[MAXN];  // 每个节点的线段树
    static int[] ptr = new int[MAXN];     // 每个节点在线段树中的位置
    
    // 添加边
    static void addEdge(int u, int v, double w) {
        next[++cnt] = head[u];
        to[cnt] = v;
        val[cnt] = w;
        head[u] = cnt;
    }
    
    // 第一次DFS：计算每个节点的深度和重儿子
    static void dfs1(int u, int fa) {
        dep[u] = dep[fa] + 1;
        maxlen[u] = 0;
        son[u] = 0;
        
        // 遍历所有子节点
        for (int i = head[u]; i != 0; i = next[i]) {
            int v = to[i];
            if (v == fa) continue;
            
            dfs1(v, u);
            
            // 更新最大深度和重儿子
            if (maxlen[v] > maxlen[u]) {
                maxlen[u] = maxlen[v];
                son[u] = v;
            }
        }
        maxlen[u]++; // 加上自己这一层
    }
    
    // 检查二分答案
    static boolean check(double mid) {
        ans = -1e9;
        dfs2(1, 0, mid);
        return ans >= 0;
    }
    
    // 第二次DFS：长链剖分和DP计算
    static void dfs2(int u, int fa, double mid) {
        dfn[u] = ++dfntot;
        
        // 如果有重儿子，先处理重儿子
        if (son[u] != 0) {
            dfs2(son[u], u, mid);
            // 继承重儿子的线段树
            seg[u] = seg[son[u]];
            ptr[u] = ptr[son[u]] - 1;
        } else {
            // 叶子节点，创建新的线段树
            seg[u] = new SegmentTree(maxlen[u] + 1);
            ptr[u] = maxlen[u];
        }
        
        // 自己这一层的贡献
        seg[u].update(ptr[u], 0, 1, seg[u].n, 1);
        
        // 处理所有轻儿子
        for (int i = head[u]; i != 0; i = next[i]) {
            int v = to[i];
            if (v == fa || v == son[u]) continue;
            
            dfs2(v, u, mid);
            
            // 计算轻儿子对答案的贡献
            for (int j = 0; j < maxlen[v]; j++) {
                double fv = seg[v].query(ptr[v] + j, ptr[v] + j, 1, seg[v].n, 1);
                if (fv <= -1e9) continue;
                
                // 计算合法的i范围
                int l = Math.max(0, L - 1 - j);
                int r = Math.min(maxlen[u] - 1, R - 1 - j);
                if (l <= r) {
                    double fu = seg[u].query(ptr[u] + l, ptr[u] + r, 1, seg[u].n, 1);
                    ans = Math.max(ans, fu + fv + val[i] - mid);
                }
            }
            
            // 合并轻儿子的信息到当前节点
            for (int j = 0; j < maxlen[v]; j++) {
                double fv = seg[v].query(ptr[v] + j, ptr[v] + j, 1, seg[v].n, 1);
                if (fv <= -1e9) continue;
                seg[u].update(ptr[u] + j + 1, fv + val[i] - mid, 1, seg[u].n, 1);
            }
        }
        
        // 更新父节点到当前节点的边
        if (fa != 0) {
            seg[u].update(ptr[u], seg[u].query(ptr[u], ptr[u], 1, seg[u].n, 1) + mid, 1, seg[u].n, 1);
        }
    }
    
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        PrintWriter out = new PrintWriter(new OutputStreamWriter(System.out));
        
        int n = Integer.parseInt(br.readLine());
        String[] parts = br.readLine().split(" ");
        L = Integer.parseInt(parts[0]);
        R = Integer.parseInt(parts[1]);
        
        // 读入边
        for (int i = 1; i < n; i++) {
            parts = br.readLine().split(" ");
            int u = Integer.parseInt(parts[0]);
            int v = Integer.parseInt(parts[1]);
            double w = Double.parseDouble(parts[2]);
            addEdge(u, v, w);
            addEdge(v, u, w);
        }
        
        // 进行长链剖分
        dfs1(1, 0);
        
        // 二分答案
        double left = 0, right = 1e6;
        while (right - left > EPS) {
            double mid = (left + right) / 2;
            if (check(mid)) {
                left = mid;
            } else {
                right = mid;
            }
        }
        
        // 输出答案
        out.printf("%.3f\n", left);
        
        out.flush();
        out.close();
    }
}
```

### C++实现

```cpp
// P4292 [WC2010]重建计划 - C++实现
#include <bits/stdc++.h>
using namespace std;

const int MAXN = 100005;
const double EPS = 1e-4;

// 链式前向星存储树
int head[MAXN], next[MAXN << 1], to[MAXN << 1], cnt = 0;
double val[MAXN << 1];

// 长链剖分相关数组
int dep[MAXN];     // 每个节点的深度
int son[MAXN];     // 每个节点的重儿子
int maxlen[MAXN];  // 每个节点子树中的最大深度
int dfn[MAXN];     // dfs序
int dfntot = 0;

// 线段树相关
struct SegmentTree {
    vector<double> maxVal, addTag;
    int n;
    
    SegmentTree(int size) {
        n = size;
        maxVal.assign(size << 2, -1e9);
        addTag.assign(size << 2, 0);
    }
    
    void pushUp(int i) {
        maxVal[i] = max(maxVal[i << 1], maxVal[i << 1 | 1]);
    }
    
    void pushDown(int i) {
        if (fabs(addTag[i]) > EPS) {
            maxVal[i << 1] += addTag[i];
            maxVal[i << 1 | 1] += addTag[i];
            addTag[i << 1] += addTag[i];
            addTag[i << 1 | 1] += addTag[i];
            addTag[i] = 0;
        }
    }
    
    void update(int jobl, int jobr, double jobv, int l, int r, int i) {
        if (jobl <= l && r <= jobr) {
            maxVal[i] += jobv;
            addTag[i] += jobv;
            return;
        }
        pushDown(i);
        int mid = (l + r) >> 1;
        if (jobl <= mid) update(jobl, jobr, jobv, l, mid, i << 1);
        if (jobr > mid) update(jobl, jobr, jobv, mid + 1, r, i << 1 | 1);
        pushUp(i);
    }
    
    void update(int pos, double val, int l, int r, int i) {
        if (l == r) {
            maxVal[i] = val;
            return;
        }
        pushDown(i);
        int mid = (l + r) >> 1;
        if (pos <= mid) update(pos, val, l, mid, i << 1);
        else update(pos, val, mid + 1, r, i << 1 | 1);
        pushUp(i);
    }
    
    double query(int jobl, int jobr, int l, int r, int i) {
        if (jobl <= l && r <= jobr) {
            return maxVal[i];
        }
        pushDown(i);
        int mid = (l + r) >> 1;
        double ans = -1e9;
        if (jobl <= mid) ans = max(ans, query(jobl, jobr, l, mid, i << 1));
        if (jobr > mid) ans = max(ans, query(jobl, jobr, mid + 1, r, i << 1 | 1));
        return ans;
    }
};

// DP相关数组
double ans;                    // 答案
int L, R;                      // 路径长度限制
SegmentTree* seg[MAXN];        // 每个节点的线段树
int ptr[MAXN];                 // 每个节点在线段树中的位置

// 添加边
void addEdge(int u, int v, double w) {
    next[++cnt] = head[u];
    to[cnt] = v;
    val[cnt] = w;
    head[u] = cnt;
}

// 第一次DFS：计算每个节点的深度和重儿子
void dfs1(int u, int fa) {
    dep[u] = dep[fa] + 1;
    maxlen[u] = 0;
    son[u] = 0;
    
    // 遍历所有子节点
    for (int i = head[u]; i; i = next[i]) {
        int v = to[i];
        if (v == fa) continue;
        
        dfs1(v, u);
        
        // 更新最大深度和重儿子
        if (maxlen[v] > maxlen[u]) {
            maxlen[u] = maxlen[v];
            son[u] = v;
        }
    }
    maxlen[u]++; // 加上自己这一层
}

// 检查二分答案
bool check(double mid) {
    ans = -1e9;
    dfs2(1, 0, mid);
    return ans >= 0;
}

// 第二次DFS：长链剖分和DP计算
void dfs2(int u, int fa, double mid) {
    dfn[u] = ++dfntot;
    
    // 如果有重儿子，先处理重儿子
    if (son[u]) {
        dfs2(son[u], u, mid);
        // 继承重儿子的线段树
        seg[u] = seg[son[u]];
        ptr[u] = ptr[son[u]] - 1;
    } else {
        // 叶子节点，创建新的线段树
        seg[u] = new SegmentTree(maxlen[u] + 1);
        ptr[u] = maxlen[u];
    }
    
    // 自己这一层的贡献
    seg[u]->update(ptr[u], 0, 1, seg[u]->n, 1);
    
    // 处理所有轻儿子
    for (int i = head[u]; i; i = next[i]) {
        int v = to[i];
        if (v == fa || v == son[u]) continue;
        
        dfs2(v, u, mid);
        
        // 计算轻儿子对答案的贡献
        for (int j = 0; j < maxlen[v]; j++) {
            double fv = seg[v]->query(ptr[v] + j, ptr[v] + j, 1, seg[v]->n, 1);
            if (fv <= -1e9 + EPS) continue;
            
            // 计算合法的i范围
            int l = max(0, L - 1 - j);
            int r = min(maxlen[u] - 1, R - 1 - j);
            if (l <= r) {
                double fu = seg[u]->query(ptr[u] + l, ptr[u] + r, 1, seg[u]->n, 1);
                ans = max(ans, fu + fv + val[i] - mid);
            }
        }
        
        // 合并轻儿子的信息到当前节点
        for (int j = 0; j < maxlen[v]; j++) {
            double fv = seg[v]->query(ptr[v] + j, ptr[v] + j, 1, seg[v]->n, 1);
            if (fv <= -1e9 + EPS) continue;
            seg[u]->update(ptr[u] + j + 1, fv + val[i] - mid, 1, seg[u]->n, 1);
        }
    }
    
    // 更新父节点到当前节点的边
    if (fa) {
        seg[u]->update(ptr[u], seg[u]->query(ptr[u], ptr[u], 1, seg[u]->n, 1) + mid, 1, seg[u]->n, 1);
    }
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    
    int n;
    cin >> n >> L >> R;
    
    // 读入边
    for (int i = 1; i < n; i++) {
        int u, v;
        double w;
        cin >> u >> v >> w;
        addEdge(u, v, w);
        addEdge(v, u, w);
    }
    
    // 进行长链剖分
    dfs1(1, 0);
    
    // 二分答案
    double left = 0, right = 1e6;
    while (right - left > EPS) {
        double mid = (left + right) / 2;
        if (check(mid)) {
            left = mid;
        } else {
            right = mid;
        }
    }
    
    // 输出答案
    printf("%.3f\n", left);
    
    return 0;
}
```

## 复杂度分析

### 时间复杂度
- 二分答案：O(log(1e6/EPS)) = O(log(1e10)) ≈ O(34)
- 每次check：O(n)
- 总时间复杂度：O(n * log(1e10)) = O(34n)

### 空间复杂度
- 链式前向星：O(n)
- 线段树：O(n)
- 其他辅助数组：O(n)
- 总空间复杂度：O(n)

## 总结

这道题是长链剖分结合线段树维护DP数组的经典例题，主要考察点包括：

1. **01分数规划**：
   - 将平均值最大化问题转化为二分答案验证问题
   - 通过移项将除法转化为加法判断

2. **线段树维护DP数组**：
   - 由于需要维护区间最值，不能简单使用指针偏移
   - 使用线段树来维护每个节点的DP信息

3. **长链剖分优化技巧**：
   - 重儿子信息继承：通过继承线段树实现O(1)继承
   - 轻儿子信息合并：暴力合并，但每条链只合并一次

4. **状态转移处理**：
   - 在合并子节点信息时，需要考虑路径长度限制
   - 正确计算合法的查询区间

这道题相比前两题更加复杂，结合了多个算法思想：
- 01分数规划处理最优化问题
- 长链剖分优化树形DP
- 线段树维护区间信息

是长链剖分应用的高阶题目，体现了算法设计的综合能力。