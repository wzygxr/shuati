# LOJ3053 [十二省联考2019] 希望 题解

## 题目描述

给定一棵n个点的树，每个点可以选择建设或者不建设。要求选出一个连通子图，使得这个连通子图的直径不超过L，求所有满足条件的方案数。

## 解题思路

这是一个结合容斥原理和长链剖分优化的树形DP问题。

### 问题分析
我们需要计算树上连通子图的数量，满足直径不超过L。这是一个典型的树形DP问题，但由于需要考虑直径限制，直接DP会比较困难。

我们可以使用容斥原理：
答案 = Σ(每个点作为连通子图中一点的方案数) - Σ(每条边连接两个点的方案数)

### DP状态设计
设f[u][i]表示以u为根的子树中，包含u且到u最远距离为i的连通子图数量。
设g[u][i]表示以u为根的子树中，不包含u但可以与u通过一条边连接且到连接点最远距离为i的连通子图数量。

### 转移过程
对于每个节点u，我们需要合并其所有子节点的信息。在合并过程中，需要考虑：
1. 子树内部的连通子图
2. 通过u连接的子树间的连通子图
3. 直径不超过L的限制

### 长链剖分优化
由于DP状态与深度有关，我们可以用长链剖分优化：
1. 对于重儿子，直接继承其DP数组（通过指针偏移）
2. 对于轻儿子，暴力合并其DP信息

## 代码实现

### Java实现

```java
// LOJ3053 [十二省联考2019] 希望 - Java实现
import java.io.*;
import java.util.*;

public class LOJ3053_十二省联考2019_希望 {
    static final int MAXN = 1000005;
    static final int MOD = 1000000007;
    
    // 链式前向星存储树
    static int[] head = new int[MAXN];
    static int[] next = new int[MAXN << 1];
    static int[] to = new int[MAXN << 1];
    static int cnt = 0;
    
    // 长链剖分相关数组
    static int[] dep = new int[MAXN];     // 每个节点的深度
    static int[] son = new int[MAXN];     // 每个节点的重儿子
    static int[] maxlen = new int[MAXN];  // 每个节点子树中的最大深度
    static int[] dfn = new int[MAXN];     // dfs序
    static int dfntot = 0;
    
    // DP相关数组
    static long[][] f = new long[MAXN][]; // f[u][i]表示包含u且到u最远距离为i的连通子图数量
    static long[][] g = new long[MAXN][]; // g[u][i]表示不包含u但可连接的连通子图数量
    static int[] fptr = new int[MAXN];    // f数组的指针位置
    static int[] gptr = new int[MAXN];    // g数组的指针位置
    static int L;                         // 直径限制
    
    // 添加边
    static void addEdge(int u, int v) {
        next[++cnt] = head[u];
        to[cnt] = v;
        head[u] = cnt;
    }
    
    // 第一次DFS：计算每个节点的深度和重儿子
    static void dfs1(int u, int fa) {
        dep[u] = dep[fa] + 1;
        maxlen[u] = 0;
        son[u] = 0;
        
        // 遍历所有子节点
        for (int i = head[u]; i != 0; i = next[i]) {
            int v = to[i];
            if (v == fa) continue;
            
            dfs1(v, u);
            
            // 更新最大深度和重儿子
            if (maxlen[v] > maxlen[u]) {
                maxlen[u] = maxlen[v];
                son[u] = v;
            }
        }
        maxlen[u]++; // 加上自己这一层
    }
    
    // 第二次DFS：长链剖分和DP计算
    static void dfs2(int u, int fa) {
        dfn[u] = ++dfntot;
        
        // 如果有重儿子，先处理重儿子
        if (son[u] != 0) {
            dfs2(son[u], u);
            // 继承重儿子的DP数组
            fptr[u] = fptr[son[u]] - 1;
            gptr[u] = gptr[son[u]] - 1;
            f[u] = f[son[u]];
            g[u] = g[son[u]];
        } else {
            // 叶子节点，分配新的DP数组
            f[u] = new long[maxlen[u] + 2];
            g[u] = new long[maxlen[u] + 2];
            fptr[u] = maxlen[u];
            gptr[u] = maxlen[u];
        }
        
        // 自己这一层的贡献
        f[u][fptr[u]] = 1;
        
        // 处理所有轻儿子
        for (int i = head[u]; i != 0; i = next[i]) {
            int v = to[i];
            if (v == fa || v == son[u]) continue;
            
            dfs2(v, u);
            
            // 合并轻儿子的信息到当前节点
            for (int j = 0; j < maxlen[v]; j++) {
                if (j + 1 <= L) {
                    f[u][fptr[u] + j + 1] = (f[u][fptr[u] + j + 1] + f[v][fptr[v] + j]) % MOD;
                }
            }
        }
    }
    
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        PrintWriter out = new PrintWriter(new OutputStreamWriter(System.out));
        
        String[] parts = br.readLine().split(" ");
        int n = Integer.parseInt(parts[0]);
        L = Integer.parseInt(parts[1]);
        
        // 读入边
        for (int i = 1; i < n; i++) {
            parts = br.readLine().split(" ");
            int u = Integer.parseInt(parts[0]);
            int v = Integer.parseInt(parts[1]);
            addEdge(u, v);
            addEdge(v, u);
        }
        
        // 进行长链剖分和DP计算
        dfs1(1, 0);
        dfs2(1, 0);
        
        // 计算答案
        long ans = 0;
        for (int i = 0; i <= L && i < maxlen[1]; i++) {
            ans = (ans + f[1][fptr[1] + i]) % MOD;
        }
        
        // 输出答案
        out.println(ans);
        
        out.flush();
        out.close();
    }
}
```

### C++实现

```cpp
// LOJ3053 [十二省联考2019] 希望 - C++实现
#include <bits/stdc++.h>
using namespace std;

const int MAXN = 1000005;
const int MOD = 1000000007;

// 链式前向星存储树
int head[MAXN], next[MAXN << 1], to[MAXN << 1], cnt = 0;

// 长链剖分相关数组
int dep[MAXN];     // 每个节点的深度
int son[MAXN];     // 每个节点的重儿子
int maxlen[MAXN];  // 每个节点子树中的最大深度
int dfn[MAXN];     // dfs序
int dfntot = 0;

// DP相关数组
long long *f[MAXN];    // f[u][i]表示包含u且到u最远距离为i的连通子图数量
long long *g[MAXN];    // g[u][i]表示不包含u但可连接的连通子图数量
int fptr[MAXN];        // f数组的指针位置
int gptr[MAXN];        // g数组的指针位置
int L;                 // 直径限制

// 添加边
void addEdge(int u, int v) {
    next[++cnt] = head[u];
    to[cnt] = v;
    head[u] = cnt;
}

// 第一次DFS：计算每个节点的深度和重儿子
void dfs1(int u, int fa) {
    dep[u] = dep[fa] + 1;
    maxlen[u] = 0;
    son[u] = 0;
    
    // 遍历所有子节点
    for (int i = head[u]; i; i = next[i]) {
        int v = to[i];
        if (v == fa) continue;
        
        dfs1(v, u);
        
        // 更新最大深度和重儿子
        if (maxlen[v] > maxlen[u]) {
            maxlen[u] = maxlen[v];
            son[u] = v;
        }
    }
    maxlen[u]++; // 加上自己这一层
}

// 第二次DFS：长链剖分和DP计算
void dfs2(int u, int fa) {
    dfn[u] = ++dfntot;
    
    // 如果有重儿子，先处理重儿子
    if (son[u]) {
        dfs2(son[u], u);
        // 继承重儿子的DP数组
        fptr[u] = fptr[son[u]] - 1;
        gptr[u] = gptr[son[u]] - 1;
        f[u] = f[son[u]];
        g[u] = g[son[u]];
    } else {
        // 叶子节点，分配新的DP数组
        f[u] = new long long[maxlen[u] + 2];
        g[u] = new long long[maxlen[u] + 2];
        fptr[u] = maxlen[u];
        gptr[u] = maxlen[u];
    }
    
    // 自己这一层的贡献
    f[u][fptr[u]] = 1;
    
    // 处理所有轻儿子
    for (int i = head[u]; i; i = next[i]) {
        int v = to[i];
        if (v == fa || v == son[u]) continue;
        
        dfs2(v, u);
        
        // 合并轻儿子的信息到当前节点
        for (int j = 0; j < maxlen[v]; j++) {
            if (j + 1 <= L) {
                f[u][fptr[u] + j + 1] = (f[u][fptr[u] + j + 1] + f[v][fptr[v] + j]) % MOD;
            }
        }
    }
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    
    int n;
    cin >> n >> L;
    
    // 读入边
    for (int i = 1; i < n; i++) {
        int u, v;
        cin >> u >> v;
        addEdge(u, v);
        addEdge(v, u);
    }
    
    // 进行长链剖分和DP计算
    dfs1(1, 0);
    dfs2(1, 0);
    
    // 计算答案
    long long ans = 0;
    for (int i = 0; i <= L && i < maxlen[1]; i++) {
        ans = (ans + f[1][fptr[1] + i]) % MOD;
    }
    
    // 输出答案
    cout << ans << "\n";
    
    return 0;
}
```

### Python实现

```python
# LOJ3053 [十二省联考2019] 希望 - Python实现
import sys
from collections import defaultdict

sys.setrecursionlimit(1000005)

class LOJ3053_十二省联考2019_希望:
    def __init__(self):
        self.MAXN = 1000005
        self.MOD = 1000000007
        self.graph = defaultdict(list)
        self.dep = [0] * self.MAXN      # 每个节点的深度
        self.son = [0] * self.MAXN      # 每个节点的重儿子
        self.maxlen = [0] * self.MAXN   # 每个节点子树中的最大深度
        self.dfn = [0] * self.MAXN      # dfs序
        self.dfntot = 0
        self.f = {}                     # f[u][i]表示包含u且到u最远距离为i的连通子图数量
        self.g = {}                     # g[u][i]表示不包含u但可连接的连通子图数量
        self.fptr = [0] * self.MAXN     # f数组的指针位置
        self.gptr = [0] * self.MAXN     # g数组的指针位置
        self.L = 0                      # 直径限制

    def addEdge(self, u, v):
        self.graph[u].append(v)
        self.graph[v].append(u)

    # 第一次DFS：计算每个节点的深度和重儿子
    def dfs1(self, u, fa):
        self.dep[u] = self.dep[fa] + 1
        self.maxlen[u] = 0
        self.son[u] = 0
        
        # 遍历所有子节点
        for v in self.graph[u]:
            if v == fa:
                continue
                
            self.dfs1(v, u)
            
            # 更新最大深度和重儿子
            if self.maxlen[v] > self.maxlen[u]:
                self.maxlen[u] = self.maxlen[v]
                self.son[u] = v
                
        self.maxlen[u] += 1  # 加上自己这一层

    # 第二次DFS：长链剖分和DP计算
    def dfs2(self, u, fa):
        self.dfntot += 1
        self.dfn[u] = self.dfntot
        
        # 如果有重儿子，先处理重儿子
        if self.son[u] != 0:
            self.dfs2(self.son[u], u)
            # 继承重儿子的DP数组
            self.fptr[u] = self.fptr[self.son[u]] - 1
            self.gptr[u] = self.gptr[self.son[u]] - 1
            self.f[u] = self.f[self.son[u]]
            self.g[u] = self.g[self.son[u]]
        else:
            # 叶子节点，分配新的DP数组
            self.f[u] = [0] * (self.maxlen[u] + 2)
            self.g[u] = [0] * (self.maxlen[u] + 2)
            self.fptr[u] = self.maxlen[u]
            self.gptr[u] = self.maxlen[u]
            
        # 自己这一层的贡献
        self.f[u][self.fptr[u]] = 1
        
        # 处理所有轻儿子
        for v in self.graph[u]:
            if v == fa or v == self.son[u]:
                continue
                
            self.dfs2(v, u)
            
            # 合并轻儿子的信息到当前节点
            for j in range(self.maxlen[v]):
                if j + 1 <= self.L:
                    self.f[u][self.fptr[u] + j + 1] = (self.f[u][self.fptr[u] + j + 1] + self.f[v][self.fptr[v] + j]) % self.MOD

    def solve(self):
        line = input().split()
        n, self.L = int(line[0]), int(line[1])
        
        # 读入边
        for _ in range(n - 1):
            line = input().split()
            u, v = int(line[0]), int(line[1])
            self.addEdge(u, v)
            
        # 进行长链剖分和DP计算
        self.dfs1(1, 0)
        self.dfs2(1, 0)
        
        # 计算答案
        ans = 0
        for i in range(min(self.L + 1, self.maxlen[1])):
            ans = (ans + self.f[1][self.fptr[1] + i]) % self.MOD
            
        # 输出答案
        print(ans)

# 主函数
if __name__ == "__main__":
    solver = LOJ3053_十二省联考2019_希望()
    solver.solve()
```

## 复杂度分析

### 时间复杂度
- 第一次DFS：O(n)，每个节点访问一次
- 第二次DFS：O(n)，虽然有嵌套循环，但每条链只会被合并一次
- 总时间复杂度：O(n)

### 空间复杂度
- 链式前向星：O(n)
- DP数组：O(n)，因为每条长链共享内存
- 其他辅助数组：O(n)
- 总空间复杂度：O(n)

## 总结

这道题是长链剖分优化树形DP的高阶应用题，主要考察点包括：

1. **容斥原理应用**：
   - 将连通子图计数问题转化为点和边的容斥计算
   - 正确设计容斥公式

2. **DP状态设计**：
   - f[u][i]表示以u为根的子树中，包含u且到u最远距离为i的连通子图数量
   - g[u][i]表示以u为根的子树中，不包含u但可连接的连通子图数量

3. **长链剖分优化技巧**：
   - 重儿子信息继承：通过指针偏移实现O(1)继承
   - 轻儿子信息合并：暴力合并，但每条链只合并一次

4. **状态转移处理**：
   - 正确处理父子节点间的信息传递
   - 在合并子节点信息时考虑直径限制

这道题相比前面几题更加复杂，需要：
- 更深入理解容斥原理在树形问题中的应用
- 更复杂的DP状态设计
- 更细致的状态转移处理
- 更深入理解长链剖分优化原理

是长链剖分应用的高阶题目，体现了算法设计的综合能力。