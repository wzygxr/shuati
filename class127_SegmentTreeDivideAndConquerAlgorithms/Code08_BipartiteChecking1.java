package class167;

import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStreamWriter;
import java.io.PrintWriter;
import java.util.Arrays;

/**
 * 动态二分图检测算法实现 - 基于线段树分治和扩展域并查集
 * <p>
 * 【核心算法】线段树分治 + 扩展域并查集 + 可撤销操作
 * <p>
 * 【算法背景】
 * 动态图的二分性检测是图论中的经典问题。当图中的边可以被动态添加和删除时，
 * 需要在每个操作后快速判断当前图是否保持二分图性质。直接的暴力方法时间复杂度高，
 * 无法处理大规模数据。线段树分治是解决这类离线动态问题的高效方法。
 * <p>
 * 【算法原理解析】
 * 1. 【离线处理思想】：首先收集所有操作，计算每条边存在的时间区间
 * 2. 【时间轴分段】：使用线段树将整个时间轴划分为区间，每个节点代表一个时间区间
 * 3. 【边的挂载】：将每条边挂载到覆盖其时间区间的线段树节点上
 * 4. 【DFS遍历与回滚】：深度优先遍历线段树，在进入节点时应用所有边，离开时撤销操作
 * 5. 【二分图检测】：利用扩展域并查集维护二分图的双色约束，检测是否存在奇环
 * <p>
 * 【核心数据结构】
 * - 扩展域并查集：每个节点i有两个表示（i和i+n），分别代表节点i在二分图的两个不同集合中
 * - 可撤销并查集：支持合并操作的回滚，是线段树分治的基础
 * - 线段树：管理边的时间区间
 * - 链式前向星：高效存储每个线段树节点上的边列表
 * <p>
 * 【算法优势】
 * - 时间复杂度：O(q log q log n)，其中q是操作次数，n是节点数
 * - 空间复杂度：O(n + q log q)
 * - 能够高效处理大量边的动态变化
 * - 支持离线查询所有时间点的二分图状态
 * <p>
 * 【优化策略】
 * - 按秩合并：优化并查集的树结构，提高查找效率
 * - 剪枝优化：当发现冲突时，直接标记整个区间为非二分图
 * - 链式前向星：高效存储和遍历边
 * - 可撤销操作：避免重复初始化数据结构
 * <p>
 * 【与其他方法对比】
 * - 暴力方法：时间复杂度O(q^2)，无法处理大规模数据
 * - 在线算法：通常需要更复杂的数据结构，常数较大
 * - 线段树分治：通过离线处理和回滚机制，实现了高效的动态处理
 * <p>
 * 【应用场景】
 * - 动态图的二分性检测
 * - 支持边插入/删除的连通性问题
 * - 网络动态变化的实时监测
 * - 算法竞赛中的离线动态问题
 */

public class Code08_BipartiteChecking1 {

	public static int MAXN = 100001;
	public static int MAXQ = 100001;
	public static int MAXT = 500001;
	public static int n, q;

	// 边的记录：端点x、端点y、时间点t
	public static int[][] event = new int[MAXN << 1][3];
	public static int eventCnt;

	// 操作记录下来
	public static int[] op = new int[MAXQ];
	public static int[] x = new int[MAXQ];
	public static int[] y = new int[MAXQ];

	// 扩展域并查集
	// 对于节点i，其在左侧的编号为i，右侧的编号为i+n
	public static int[] father = new int[MAXN << 1];
	public static int[] siz = new int[MAXN << 1];
	public static int[][] rollback = new int[MAXN][2];
	public static int opsize = 0;

	// 时间轴线段树上的区间任务列表
	public static int[] head = new int[MAXQ << 2];
	public static int[] next = new int[MAXT];
	public static int[] tox = new int[MAXT];
	public static int[] toy = new int[MAXT];
	public static int cnt = 0;

	// 查询操作的答案
	public static boolean[] ans = new boolean[MAXQ];

	/**
	 * 扩展域并查集的查找操作 - 无路径压缩版本
	 * <p>
	 * 【关键实现细节】本方法没有使用完整的路径压缩！
	 * 在可撤销并查集中，路径压缩会改变树的结构，使得无法简单地通过撤销最后一次合并操作来恢复状态。
	 * 因此，在支持回滚的并查集中，通常只采用按秩合并（size/rank）优化，而不使用路径压缩。
	 * <p>
	 * 扩展域并查集原理详解：
	 * - 在二分图检测中，每个节点i有两个表示：
	 *   - i：表示节点i属于左集合（集合A）
	 *   - i+n：表示节点i属于右集合（集合B）
	 * - 这种表示方法将节点的颜色（在二分图中的划分）编码在集合表示中
	 * <p>
	 * 时间复杂度分析：
	 * - 无路径压缩时，单次find操作的时间复杂度为O(log n)
	 * - 对于m次操作，总时间复杂度为O(m log n)
	 * - 虽然没有路径压缩，但结合按秩合并，实际运行时间仍然较为高效
	 * <p>
	 * 为什么不能使用路径压缩：
	 * 1. 路径压缩会改变多个节点的父指针
	 * 2. 回滚操作只能记录最后一次合并，无法追踪路径压缩修改的所有指针
	 * 3. 要支持路径压缩的回滚，需要记录每次查找操作修改的所有指针，空间和时间复杂度都会显著增加
	 * 
	 * @param i 要查找的元素，范围为1~2n
	 * @return 集合的代表元素（根节点）
	 */
	public static int find(int i) {
		// 简单遍历直到根节点，不进行路径压缩
		// 这样设计是为了支持并查集的回滚操作
		while (i != father[i]) {
			i = father[i];
			}
		return i;
	}

	/**
 * 扩展域并查集的合并操作 - 二分图检测的核心实现
 * <p>
 * 【扩展域并查集原理】
 * 在二分图检测中，我们需要确保任意一条边的两个端点属于不同的颜色集合。
 * 扩展域并查集通过为每个节点维护两个表示来实现这一约束：
 * - x：表示节点x属于左集合（集合A）
 * - x+n：表示节点x属于右集合（集合B）
 * <p>
 * 【合并策略详解】
 * 当我们需要将节点x和y连接时，必须确保它们属于不同的集合：
 * 1. 如果x在集合A，那么y必须在集合B → 合并x和y+n
 * 2. 如果x在集合B，那么y必须在集合A → 合并x+n和y
 * <p>
 * 【冲突检测机制】
 * 如果在合并前发现x和y已经在同一个集合中，说明存在奇环，图不是二分图。
 * 具体来说：
 * - find(x) == find(y)：意味着x和y被强制要求在同一个集合中，产生矛盾
 * - find(x+n) == find(y+n)：意味着x和y被强制要求在同一个集合中（都在B），也产生矛盾
 * <p>
 * 【可撤销实现细节】
 * 1. 使用rollback数组记录每次合并操作的父节点和子节点
 * 2. 维护opsize变量跟踪当前执行的操作次数
 * 3. 每次合并操作最多产生两次实际的树合并
 * 4. 合并操作的回滚通过undo方法实现
 * <p>
 * 【按秩合并优化】
 * 使用siz数组记录每个集合的大小，总是将较小的集合合并到较大的集合中。
 * 这种优化确保树的高度保持较低，提高find操作效率。
 * <p>
 * 【工程化考量】
 * 为了支持回滚操作，find方法不使用路径压缩，这是可撤销并查集的关键限制。
 * 虽然这会使单次find操作的时间复杂度变为O(log n)，但整体算法仍然高效。
 * 
 * @param x 第一个节点
 * @param y 第二个节点
 * @return 如果合并成功（不冲突）返回true；如果发现冲突（无法构成二分图）返回false
 */
	public static boolean union(int x, int y) {
		int fx1 = find(x);     // x在集合A中的代表元素
		int fy1 = find(y);     // y在集合A中的代表元素
		
		// 冲突检测：如果x和y已经在同一个集合中，说明无法构成二分图
		if (fx1 == fy1) {
			return false;
		}
		
		int fx2 = find(x + n); // x在集合B中的代表元素
		int fy2 = find(y + n); // y在集合B中的代表元素
		
		// 合并x在集合A与y在集合B的情况
		if (fx1 != fy2) {
			// 按秩合并：将较小的树合并到较大的树的根上
			if (siz[fx1] < siz[fy2]) {
				int tmp = fx1;
				fx1 = fy2;
				fy2 = tmp;
			}
			// 记录合并操作，用于回滚
			father[fy2] = fx1;
			siz[fx1] += siz[fy2];
			rollback[++opsize][0] = fx1; // 父节点
			rollback[opsize][1] = fy2;   // 子节点
		}
		
		// 合并y在集合A与x在集合B的情况
		if (fx2 != fy1) {
			// 按秩合并
			if (siz[fx2] < siz[fy1]) {
				int tmp = fx2;
				fx2 = fy1;
				fy1 = tmp;
			}
			// 记录合并操作，用于回滚
			father[fy1] = fx2;
			siz[fx2] += siz[fy1];
			rollback[++opsize][0] = fx2; // 父节点
			rollback[opsize][1] = fy1;   // 子节点
		}
		return true;
	}

	/**
	 * 撤销并查集中的最后一次合并操作
	 * <p>
	 * 回滚机制是线段树分治算法的关键组成部分，用于：
	 * 1. 在深度优先遍历线段树时，处理完一个子树后撤销所有操作
	 * 2. 恢复到进入当前线段树节点前的状态，以便处理其他子树
	 * 3. 确保不同子树之间不会相互影响
	 * <p>
	 * 回滚实现原理：
	 * - 在union操作时，将合并的父节点和子节点信息记录在rollback数组中
	 * - 回滚时，将子节点的父指针重新指向自己，恢复集合的独立状态
	 * - 同时恢复父节点的size，撤销合并时的大小累加
	 * <p>
	 * 时间复杂度：O(1)
	 * 空间复杂度：O(1)
	 * <p>
	 * 注意事项：
	 * - 回滚操作必须按照与合并操作相反的顺序执行
	 * - 这是因为合并操作可能形成复杂的树结构，需要自底向上撤销
	 * - 为了支持回滚，find方法没有使用完整的路径压缩
	 */
	public static void undo() {
		// 获取最后一次合并操作的信息
		int fx = rollback[opsize][0]; // 父节点
		int fy = rollback[opsize--][1]; // 子节点，同时递减操作计数器
		
		// 恢复子节点的父节点为自身，使子节点成为独立的集合
		father[fy] = fy;
		
		// 恢复父节点的大小，减去之前合并的子节点集合的大小
		siz[fx] -= siz[fy];
	}

	/**
	 * 使用链式前向星结构将边添加到线段树的指定节点
	 * <p>
	 * 链式前向星是一种高效的图存储结构，特别适合边的动态添加
	 * 实现原理：
	 * 1. head数组：每个线段树节点i对应一个head[i]，指向该节点的第一条边
	 * 2. next数组：next[e]表示边e的下一条边，形成链表结构
	 * 3. tox和toy数组：分别存储边e的两个端点
	 * <p>
	 * 优点：
	 * - 动态添加边的时间复杂度为O(1)
	 * - 遍历某个节点的所有边的时间复杂度为O(k)，其中k是边的数量
	 * - 空间利用率高，只存储实际存在的边
	 * <p>
	 * 应用场景：
	 * - 在线段树分治中，每个线段树节点需要存储在该时间区间内存在的所有边
	 * - 链式前向星结构非常适合这种边的动态添加和遍历需求
	 * 
	 * @param i 线段树节点编号
	 * @param x 边的第一个端点
	 * @param y 边的第二个端点
	 */
	public static void addEdge(int i, int x, int y) {
		// 创建新边：cnt递增，作为新边的唯一标识符
		// 将新边的next指针指向当前节点i的第一条边
		next[++cnt] = head[i];
		
		// 存储边的两个端点信息
		tox[cnt] = x;          // 存储边的第一个端点
		toy[cnt] = y;          // 存储边的第二个端点
		
		// 更新节点i的head指针，使其指向新添加的边
		// 这样，新边成为节点i的第一条边，原有的边链在其后
		head[i] = cnt;         // 更新头节点为新节点
	}

	/**
	 * 线段树区间更新操作：将边挂载到覆盖指定时间区间的线段树节点上
	 * <p>
	 * 算法原理：
	 * - 采用区间拆分策略，将每条边挂载到覆盖其时间区间的最小节点集合上
	 * - 如果当前线段树节点的区间完全包含在目标区间内，直接将边挂载到该节点
	 * - 否则，递归地将边挂载到左右子节点上
	 * <p>
	 * 线段树区间覆盖的优化：
	 * - 每个时间区间[jobl, jobr]会被拆分为O(log q)个线段树节点
	 * - 这确保每条边在分治过程中被处理的次数为O(log q)次
	 * - 相比直接在每个时间点上处理边，时间复杂度从O(q^2)优化到O(q log q)
	 * <p>
	 * 边的存储结构：
	 * - 通过addEdge方法将边以链式前向星的形式存储在对应的线段树节点上
	 * - 每个线段树节点维护一个边列表，存储在该时间区间内有效的所有边
	 * 
	 * @param jobl 边存在的起始时间
	 * @param jobr 边存在的结束时间
	 * @param jobx 边的第一个端点
	 * @param joby 边的第二个端点
	 * @param l 当前线段树节点的左边界
	 * @param r 当前线段树节点的右边界
	 * @param i 当前线段树节点的编号
	 */
	public static void add(int jobl, int jobr, int jobx, int joby, int l, int r, int i) {
		// 如果当前区间完全包含在目标区间内，直接在当前节点添加边
		if (jobl <= l && r <= jobr) {
			// 调用addEdge将边挂载到当前线段树节点
			addEdge(i, jobx, joby);
		} else {
			// 当前节点区间不完全包含在目标区间内，需要继续递归处理子节点
			int mid = (l + r) >> 1; // 计算中间点，将区间分为两部分
			
			// 处理左子节点：如果目标区间与左子区间有交集
			if (jobl <= mid) {
				add(jobl, jobr, jobx, joby, l, mid, i << 1); // 递归处理左子树
			}
			
			// 处理右子节点：如果目标区间与右子区间有交集
			if (jobr > mid) {
				add(jobl, jobr, jobx, joby, mid + 1, r, i << 1 | 1); // 递归处理右子树
			}
		}
	}

	/**
	 * 线段树分治的核心算法：深度优先遍历线段树执行动态二分图检测
	 * <p>
	 * 【线段树分治的核心思想】
	 * 线段树分治是一种离线算法技术，通过将时间轴分割为多个区间，
	 * 每个区间对应线段树的一个节点，边被挂载到其有效时间区间对应的节点上，
	 * 然后通过深度优先遍历线段树，结合可撤销数据结构，高效地处理动态问题。
	 * <p>
	 * 【DFS执行流程详解】
	 * 1. 【记录状态】：保存当前操作次数，用于后续回滚
	 * 2. 【应用边】：处理当前节点存储的所有边，使用可撤销并查集执行合并
	 * 3. 【冲突检测】：如果在合并过程中发现冲突，标记当前区间为非二分图
	 * 4. 【处理叶子节点】：如果是叶子节点，记录该时间点的检测结果
	 * 5. 【递归处理子节点】：
	 *    - 如果当前区间是二分图，递归处理左右子区间
	 *    - 如果不是二分图，应用剪枝优化，直接标记所有子区间
	 * 6. 【回滚操作】：撤销当前节点的所有合并操作，恢复到进入节点前的状态
	 * <p>
	 * 【剪枝优化策略】
	 * 这是算法效率的关键优化：一旦在某个节点发现冲突（图不是二分图），
	 * 可以立即推断出该节点对应的整个时间区间内的所有时刻都不是二分图。
	 * 因此，我们无需递归处理该节点的子节点，而是直接将所有子区间的结果标记为false。
	 * 这种剪枝可以大幅减少计算量，特别是在图早早就变得非二分的情况下。
	 * <p>
	 * 【回滚机制的重要性】
	 * 回滚操作确保了在处理完一个子树后，数据结构的状态被正确恢复，
	 * 从而可以处理另一个子树而不受影响。这避免了重复初始化数据结构，
	 * 是线段树分治算法高效的关键所在。
	 * <p>
	 * 【时间复杂度分析】
	 * - 每条边会被插入到O(log q)个线段树节点中
	 * - 每个线段树节点处理的时间与边的数量成正比
	 * - 每次合并和撤销操作的时间复杂度为O(log n)（无路径压缩）
	 * - 总时间复杂度：O(q log q log n)
	 * <p>
	 * 【空间复杂度分析】
	 * - 线段树存储：O(q log q)
	 * - 递归栈深度：O(log q)
	 * - 并查集和回滚数组：O(n + q log q)
	 * 
	 * @param l 当前线段树节点的左时间边界
	 * @param r 当前线段树节点的右时间边界
	 * @param i 当前线段树节点的编号
	 */
	public static void dfs(int l, int r, int i) {
		// 记录当前节点执行的合并操作次数，用于后续撤销
		int unionCnt = 0;
		
		// 记录当前图是否保持二分图性质
		boolean isBipartite = true;
		
		// 处理当前节点上的所有边
		// 每个边都在[l, r]时间区间内有效
		for (int e = head[i]; e > 0 && isBipartite; e = next[e]) {
			// 尝试在扩展域并查集中合并这两个节点
			// 如果合并失败（出现冲突），说明无法构成二分图
			if (union(tox[e], toy[e])) {
				// 成功合并，每条边的union操作会执行2次实际的合并
				// (x和y+n合并，y和x+n合并)
				unionCnt += 2;
			} else {
				// 合并失败，发现冲突，图不是二分图
				isBipartite = false;
			}
		}
		
		// 处理叶子节点（对应具体的时间点）
		if (l == r) {
			// 记录当前操作后的二分图检测结果
			ans[l] = isBipartite;
		} else {
			// 非叶子节点，需要递归处理子节点
			int mid = (l + r) >> 1; // 计算中间点
			
			if (isBipartite) {
				// 当前区间是二分图，继续递归处理左右子区间
				dfs(l, mid, i << 1);     // 处理左子区间
				dfs(mid + 1, r, i << 1 | 1); // 处理右子区间
			} else {
				// 剪枝优化：如果当前区间不是二分图，那么所有子区间都不是二分图
				// 无需递归处理，直接标记所有子区间的答案为false
				// 这显著减少了计算量，特别是在大规模数据时
				for (int k = l; k <= mid; k++) {
					ans[k] = false;
				}
				for (int k = mid + 1; k <= r; k++) {
					ans[k] = false;
				}
			}
		}
		
		// 回溯：撤销当前节点执行的所有合并操作
		// 这是线段树分治算法的关键步骤，确保状态正确恢复
		// 必须按照与执行相反的顺序撤销操作
		for (int k = 1; k <= unionCnt; k++) {
			undo();
		}
	}

	/**
	 * 线段树分治预处理函数 - 时间区间计算与线段树构建
	 * <p>
	 * 【预处理阶段的核心任务】
	 * 预处理是线段树分治算法的重要组成部分，主要完成以下工作：
	 * 1. 初始化可撤销并查集
	 * 2. 计算每条边的存在时间区间
	 * 3. 将边挂载到线段树的对应节点上
	 * <p>
	 * 【并查集初始化策略】
	 * 扩展域并查集需要为每个原始节点创建两个表示（在集合A和集合B中）：
	 * - 对于节点i，初始化i和i+n为独立的集合
	 * - 每个集合的初始大小为1
	 * - 初始时，每个节点的父节点是其自身
	 * <p>
	 * 【事件排序与分组处理】
	 * 排序策略：按照边的两个端点(x,y)升序排序，如果端点相同，则按时间t升序排序
	 * 这种排序方式确保：
	 * - 相同的边的所有事件会连续排列
	 * - 添加和删除事件会交替出现
	 * <p>
	 * 【双指针技术详解】
	 * 使用双指针l和r来高效处理相同边的事件：
	 * 1. l固定当前边的第一个事件
	 * 2. r向右移动，找到所有与当前边相同的事件
	 * 3. 对于每个相同边的事件组，处理其添加和删除事件对
	 * 这种方法的时间复杂度为O(q)，比暴力枚举更高效
	 * <p>
	 * 【边时间区间计算规则】
	 * 对于每条边，其存在的时间区间[start, end]计算如下：
	 * - start：添加事件的时间t
	 * - end：如果有对应的删除事件，end为删除事件的时间t-1
	 *        如果没有对应的删除事件，end为最后一个操作的时间q
	 * 这是因为：
	 * - 添加操作在时间t执行后，边从时间t开始存在
	 * - 删除操作在时间t执行后，边在时间t-1结束存在
	 * <p>
	 * 【线段树边挂载过程】
	 * 通过调用add方法，将每条边挂载到覆盖其时间区间的所有线段树节点上。
	 * 线段树的区间拆分策略确保每条边被挂载到O(log q)个节点上。
	 * <p>
	 * 【时间复杂度分析】
	 * - 初始化并查集：O(n)
	 * - 排序事件：O(q log q)
	 * - 双指针处理事件：O(q)
	 * - 线段树区间添加：O(q log q)
	 * - 整体时间复杂度：O(n + q log q)
	 * <p>
	 * 【空间复杂度分析】
	 * - 并查集数组：O(n)
	 * - 事件数组：O(q)
	 * - 线段树存储：O(q log q)
	 * - 整体空间复杂度：O(n + q log q)
	 */
	public static void prepare() {
		// 初始化扩展域并查集
		// 对于每个节点i，维护两个表示：i（在集合A中）和i+n（在集合B中）
		// 初始时，每个节点都是独立的集合
		for (int i = 1; i <= (n << 1); i++) {
			father[i] = i;  // 父节点指向自己
			siz[i] = 1;     // 初始集合大小为1
		}
		
		// 排序所有边事件，这是处理边生命周期的关键步骤
		// 排序规则：先按x节点排序，再按y节点排序，最后按时间t排序
		// 这种排序方式确保相同的边(x,y)的所有事件会集中在一起
		Arrays.sort(event, 1, eventCnt + 1,
				(a, b) -> a[0] != b[0] ? a[0] - b[0] : a[1] != b[1] ? a[1] - b[1] : a[2] - b[2]);
		
		int x, y, start, end;
		// 使用双指针技术处理所有边的时间区间
		// l是左指针，r是右指针，指向相同边的最后一个事件
		for (int l = 1, r = 1; l <= eventCnt; l = ++r) {
			x = event[l][0]; // 当前处理的边的第一个端点
			y = event[l][1]; // 当前处理的边的第二个端点
			
			// 找到所有相同边(x,y)的事件，将r指针移动到最后一个相同事件
			while (r + 1 <= eventCnt && event[r + 1][0] == x && event[r + 1][1] == y) {
				r++;
			}
			
			// 处理每对添加和删除事件，确定边的有效时间区间
			// 由于事件已经排序，添加和删除事件会交替出现
			// i每次递增2，处理一对添加和删除事件
			for (int i = l; i <= r; i += 2) {
				start = event[i][2]; // 边的开始时间（添加事件的时间点）
				
				// 确定边的结束时间：
				// - 如果有对应的删除事件（i+1 <= r），则边在删除事件发生前结束
				// - 结束时间为删除事件的时间-1（删除操作发生在时间t，边在t-1时仍有效）
				// - 如果没有对应的删除事件，则边的生命周期延续到最后一个操作q
				end = i + 1 <= r ? (event[i + 1][2] - 1) : q;
				
				// 将边挂载到线段树的对应时间区间[start, end]上
				// 调用add方法将边插入到线段树中
				add(start, end, x, y, 0, q, 1);
			}
		}
	}

	/**
	 * 程序主入口，负责协调整个动态二分图检测算法的执行流程
	 * <p>
	 * 整体工作流程：
	 * 1. 读取输入数据，构建事件列表
	 * 2. 预处理阶段：构建线段树并初始化并查集
	 * 3. 执行线段树分治算法，检测每个操作时刻图的二分性
	 * 4. 输出所有查询操作的结果
	 * <p>
	 * 输入处理优化：
	 * - 使用FastReader高效读取大量输入数据
	 * - 规范化处理边的端点，确保x <= y，方便后续事件处理
	 * - 采用事件驱动模型，将每个添加或删除操作转化为事件
	 * <p>
	 * 输出优化：
	 * - 使用PrintWriter批量输出结果，减少I/O开销
	 * <p>
	 * 输入格式处理：
	 * - 支持高达10^5量级的节点和操作
	 * <p>
	 * 输出格式：
	 * - 对于每个操作时间点，输出"YES"表示是二分图，"NO"表示不是
	 * <p>
	 * 错误处理：
	 * - 假设输入数据格式正确
	 * - 数组大小预先分配足够空间，避免运行时扩容
	 * <p>
	 * 性能考量：
	 * - 使用高效的输入方法减少IO开销
	 * - 线段树分治算法的时间复杂度为O((n+q)log q α(n))
	 * - 空间复杂度为O(n + q log q)
	 * 
	 * @param args 命令行参数（未使用）
	 * @throws IOException 可能出现的输入输出异常
	 */
	/**
	 * 执行动态二分图检测的主方法 - 线段树分治算法的核心入口
	 * <p>
	 * 【算法整体架构】
	 * 动态二分图检测是线段树分治算法的经典应用场景。该算法通过将时间轴拆分为不同区间，
	 * 将边挂载到其有效时间区间对应的线段树节点上，然后结合可撤销并查集进行深度优先遍历，
	 * 高效地检测每个时间点的图是否保持二分图性质。
	 * <p>
	 * 【输入数据处理详解】
	 * 1. 高效IO策略：使用FastReader和PrintWriter代替标准IO，提高大数据量下的处理速度
	 * 2. 边的规范化：将每条边的端点按升序排列(x <= y)，确保相同边的统一处理
	 * 3. 事件建模：将每个添加或删除操作转化为事件，记录边的两个端点和发生时间
	 * <p>
	 * 【线段树分治算法流程】
	 * 1. 预处理阶段（prepare方法）：
	 *    - 初始化扩展域并查集，为每个节点创建两个表示（在集合A和集合B中）
	 *    - 对事件进行排序，使用双指针技术计算每条边的有效时间区间
	 *    - 将边挂载到线段树的对应节点上，每条边被挂载到O(log q)个节点
	 * <p>
	 * 2. 分治处理阶段（dfs方法）：
	 *    - 深度优先遍历线段树，进入节点时应用所有边的合并操作
	 *    - 使用扩展域并查集检测是否存在奇环（二分图冲突）
	 *    - 对于叶子节点，记录该时间点的检测结果
	 *    - 应用剪枝优化：如果当前区间非二分，则所有子区间也非二分
	 *    - 离开节点时撤销所有合并操作，恢复到进入前的状态
	 * <p>
	 * 3. 结果输出阶段：
	 *    - 收集每个时间点的检测结果
	 *    - 批量输出YES或NO
	 * <p>
	 * 【核心技术难点解析】
	 * 1. 扩展域并查集的设计：
	 *    - 每个节点维护两个表示，巧妙地将二分图约束条件转化为并查集操作
	 *    - 通过find(x)和find(x+n)的冲突检测，可以准确识别奇环
	 * <p>
	 * 2. 可撤销并查集的实现：
	 *    - 记录每次合并操作的父节点和子节点信息
	 *    - 按照与执行相反的顺序进行撤销，确保状态正确恢复
	 *    - 不使用路径压缩优化，以支持操作回滚
	 * <p>
	 * 3. 线段树分治的优化：
	 *    - 剪枝策略：一旦发现非二分图，立即停止子树处理
	 *    - 边的区间拆分：将每条边挂载到最少的线段树节点上
	 *    - 双指针处理：高效计算边的生命周期，避免重复处理
	 * <p>
	 * 【时间复杂度精确分析】
	 * - 输入处理：O(q)
	 * - 事件排序：O(q log q)
	 * - 双指针计算边生命周期：O(q)
	 * - 线段树构建与边挂载：O(q log q)
	 * - 线段树分治检测：O(q log q log n)（无路径压缩的并查集操作）
	 * - 结果输出：O(q)
	 * - 总体时间复杂度：O(n + q log q log n)
	 * <p>
	 * 【空间复杂度精确分析】
	 * - 并查集数组（father, siz）：O(n)
	 * - 事件数组：O(q)
	 * - 线段树存储：O(q log q)
	 * - 回滚栈：O(q log q)
	 * - 结果数组：O(q)
	 * - 总体空间复杂度：O(n + q log q)
	 * <p>
	 * 【工程实现优化】
	 * 1. 内存预分配：所有数组在初始化时分配足够空间，避免运行时扩容
	 * 2. 常数优化：规范化边处理、高效IO、剪枝策略等
	 * 3. 递归深度控制：线段树深度为O(log q)，确保不会栈溢出
	 * <p>
	 * 【算法应用场景】
	 * 1. 动态图的二分性维护
	 * 2. 带有时间约束的连通性问题
	 * 3. 动态约束满足问题
	 * 4. 离线处理的动态图算法
	 * 
	 * @throws IOException 可能出现的输入输出异常
	 */
	public static void run() throws IOException {
		// 创建高效输入流，用于快速读取大量输入数据
		// 在大规模数据情况下，FastReader比Scanner效率高约10倍
		FastReader in = new FastReader();
		
		// 创建高效输出流，用于批量输出结果
		// 使用PrintWriter可以减少频繁的I/O操作
		PrintWriter out = new PrintWriter(new OutputStreamWriter(System.out));
		
		// 读取节点数n和操作数q
		// n表示图中的节点数量
		// q表示操作的数量（添加边或删除边）
		n = in.nextInt();
		q = in.nextInt();
		
		// 初始化事件计数器并读取所有操作
		// 每个操作都会被转化为一个事件
		eventCnt = 0;
		for (int i = 1; i <= q; i++) {
			// 读取操作类型：1表示添加边，0表示删除边
			op[i] = in.nextInt();
			
			// 读取边的两个端点x和y
			x[i] = in.nextInt();
			y[i] = in.nextInt();
			
			// 规范化处理：确保x <= y，便于后续对相同边的处理
			// 这样可以保证边(x,y)和(y,x)被视为同一条边
			if (x[i] > y[i]) {
				int tmp = x[i];
				x[i] = y[i];
				y[i] = tmp;
			}
			
			// 记录边事件：无论添加还是删除操作，都记录为一个事件
			// 事件数组event的结构：event[eventCnt][0]=x, event[eventCnt][1]=y, event[eventCnt][2]=i
			// 其中i表示事件发生的时间（操作序号）
			event[++eventCnt][0] = x[i];     // 边的第一个节点
			event[eventCnt][1] = y[i];     // 边的第二个节点
			event[eventCnt][2] = i;        // 事件发生的时间（操作序号）
		}
		
		// 预处理阶段：
		// 1. 初始化扩展域并查集
		// 2. 对事件进行排序，计算每条边的存在时间区间
		// 3. 将边挂载到线段树的对应节点上
		prepare();
		
		// 执行线段树分治算法
		// 从线段树根节点开始深度优先遍历，检测每个时刻图的二分性
		// 初始调用：时间区间为[0,q]，根节点编号为1
		dfs(0, q, 1);
		
		// 输出所有操作后的二分图检测结果
		// 对于每个操作i，ans[i]存储该操作后的二分图状态
		for (int i = 1; i <= q; i++) {
			// 如果是二分图，输出YES；否则输出NO
			out.println(ans[i] ? "YES" : "NO");
		}
		
		// 刷新输出缓冲区并关闭输出流
		// 确保所有结果都被输出到控制台
		out.flush();
		out.close();
	}
	
	/**
	 * 程序主入口，调用run方法执行动态二分图检测
	 */
	public static void main(String[] args) throws IOException {
		run();
	}

	/**
	 * 高效输入工具类，针对大规模数据输入进行了性能优化
	 * <p>
	 * 性能优化原理：
	 * 1. 使用字节数组缓冲区，一次性读取大量数据，减少I/O操作次数
	 * 2. 直接操作字节数据，避免了Scanner的类型转换开销
	 * 3. 采用指针管理缓冲区，提高内存访问效率
	 * 4. 预分配足够大的缓冲区，减少缓冲区扩容和数据拷贝操作
	 * <p>
	 * 与标准Scanner相比：
	 * - 在处理大规模数据时，FastReader比Scanner快约10倍
	 * - 特别适合算法竞赛中的大数据量输入场景
	 * - 内存占用更小，运行时更稳定
	 * - 对于线段树分治等复杂算法，输入效率提升尤为明显
	 * <p>
	 * 工作原理详解：
	 * - read()方法：从缓冲区读取下一个字节，缓冲区为空时重新填充
	 * - nextInt()方法：跳过空白字符，读取连续的数字字符，转换为整数
	 * - isWhitespace()方法：判断字符是否为空白字符
	 * <p>
	 * 工程化考量：
	 * - 错误处理：假设输入格式正确，适合竞赛环境
	 * - 线程安全：不保证线程安全，设计用于单线程环境
	 * - 可扩展性：可以扩展支持其他数据类型的快速读取
	 */
	static class FastReader {
		// 缓冲区大小：64KB，足够处理大多数输入场景
		// 使用位运算1<<16比直接写65536更高效
		final private int BUFFER_SIZE = 1 << 16;
		
		// 输入流引用
		private final InputStream in;
		
		// 字节缓冲区，用于存储从输入流读取的数据
		private final byte[] buffer;
		
		// 指针ptr指向缓冲区中下一个待读取的字节位置
		// len表示缓冲区中有效数据的长度
		private int ptr, len;

		/**
		 * 构造函数：初始化输入流和缓冲区
		 * <p>
		 * 初始化步骤：
		 * 1. 获取系统标准输入流
		 * 2. 创建指定大小的字节缓冲区
		 * 3. 初始化指针和有效长度为0
		 */
		public FastReader() {
			in = System.in;
			buffer = new byte[BUFFER_SIZE];
			ptr = len = 0; // 初始时缓冲区为空，指针指向0位置
		}

		/**
		 * 检查并确保缓冲区中有可用字节
		 * <p>
		 * 核心功能：
		 * - 当缓冲区中没有可用数据时，从输入流读取新数据填充缓冲区
		 * - 重置指针位置到缓冲区起始位置
		 * <p>
		 * 时间复杂度：O(1) 平均情况下，最坏O(BUFFER_SIZE)
		 * 空间复杂度：O(1)
		 * 
		 * @return 如果有可用字节返回true，否则返回false（表示到达流末尾）
		 * @throws IOException 输入流读取异常
		 */
		private boolean hasNextByte() throws IOException {
			// 检查缓冲区当前位置是否还有数据可读
			if (ptr < len)
				return true;
			
			// 缓冲区已读完，需要从输入流读取新数据
			ptr = 0; // 重置指针到缓冲区起始位置
			
			// 从输入流读取数据到缓冲区，返回实际读取的字节数
			len = in.read(buffer);
			
			// 返回是否成功读取到数据
			return len > 0;
		}

		/**
		 * 从缓冲区读取单个字节
		 * <p>
		 * 实现细节：
		 * - 调用hasNextByte()确保缓冲区有可用数据
		 * - 返回当前指针位置的字节，并将指针向前移动一位
		 * <p>
		 * 时间复杂度：O(1) 平均情况下
		 * 
		 * @return 读取的字节值，-1表示到达流末尾
		 * @throws IOException 输入流读取异常
		 */
		private byte readByte() throws IOException {
			// 确保有可用字节可读
			if (!hasNextByte())
				return -1;
			
			// 返回当前字节并移动指针
			return buffer[ptr++];
		}

		/**
		 * 从输入流读取下一个整数
		 * <p>
		 * 算法步骤：
		 * 1. 跳过所有前导空白字符
		 * 2. 处理可能的负号
		 * 3. 逐位读取数字字符，构建整数值
		 * 4. 根据负号标记返回正确符号的整数
		 * <p>
		 * 性能优化点：
		 * - 直接处理字节数据，避免字符转换开销
		 * - 使用num * 10 + (b - '0')的方式高效构建整数
		 * <p>
		 * 时间复杂度：O(位数)，与整数的位数成正比
		 * 
		 * @return 读取的整数值
		 * @throws IOException 输入流读取异常
		 */
		public int nextInt() throws IOException {
			int num = 0; // 存储最终的整数值
			byte b = readByte(); // 读取第一个字节
			
			// 跳过所有空白字符（空格、换行、回车、制表符）
			while (isWhitespace(b))
				b = readByte();
			
			// 处理负数符号
			boolean minus = false;
			if (b == '-') {
				minus = true;
				b = readByte(); // 读取负号后的第一个字节
			}
			
			// 逐位读取数字字符，构建整数值
			while (!isWhitespace(b) && b != -1) {
				// 字符转数字的高效方式：减去'0'的ASCII值
				num = num * 10 + (b - '0');
				b = readByte(); // 读取下一个字节
			}
			
			// 根据符号标记返回正确的整数值
			return minus ? -num : num;
		}

		/**
		 * 判断一个字节是否为空白字符
		 * <p>
		 * 空白字符定义：空格(' ')、换行('\n')、回车('\r')、制表符('\t')
		 * <p>
		 * 时间复杂度：O(1)
		 * 空间复杂度：O(1)
		 * 
		 * @param b 要判断的字节
		 * @return 如果是空白字符返回true，否则返回false
		 */
		private boolean isWhitespace(byte b) {
			return b == ' ' || b == '\n' || b == '\r' || b == '\t';
		}
	}

		/**
		 * 【线段树分治算法总结】
		 * 
		 * 线段树分治是一种强大的离线算法技术，特别适用于处理动态图问题。
		 * 该算法通过将时间轴划分为多个区间，将动态变化的问题转化为静态问题处理。
		 * 在二分图检测的应用中，线段树分治结合扩展域并查集和可撤销操作，
		 * 能够高效地处理大量的动态边操作。
		 * 
		 * 【核心技术要点】
		 * 1. 时间轴分割：将整个时间范围划分为O(log q)层，每层对应线段树的一个节点
		 * 2. 边的生命周期：每条边对应一个或多个时间区间，表示其存在的时间范围
		 * 3. 可撤销并查集：通过记录每次合并操作，支持高效的状态回滚
		 * 4. 扩展域技巧：为每个节点维护两个表示，巧妙地将二分图约束转化为并查集操作
		 * 5. 剪枝优化：一旦发现非二分图，立即停止子树处理，大幅减少计算量
		 * 
		 * 【实现细节深度解析】
		 * - 不使用路径压缩：为了支持操作回滚，find方法必须保持树的原始结构
		 * - 按秩合并：虽然不使用路径压缩，但按秩合并仍然可以保证树的高度较低
		 * - 双指针优化：高效处理边的生命周期，避免重复计算
		 * - 事件驱动模型：将添加/删除操作转化为事件，便于统一处理
		 * 
		 * 【与其他算法的对比】
		 * - 在线DFS/BFS：对于动态图问题，每次修改后重新运行DFS/BFS，时间复杂度O(q(n+m))，
		 *   当q很大时性能极差
		 * - 动态二分图算法：一些专门的动态二分图算法存在，但实现复杂且适用场景有限
		 * - 线段树分治：时间复杂度O(q log q log n)，对于大规模动态边操作具有显著优势
		 * 
		 * 【常见变体和扩展】
		 * 1. 支持边权的动态连通性问题
		 * 2. 动态图的最小生成树维护
		 * 3. 动态约束满足问题
		 * 4. 多维时间区间的扩展应用
		 * 
		 * 【相关题目】
		 * 1. 洛谷 P3247 [HNOI2016] 最小公倍数：动态查询两点间是否存在路径满足某些条件
		 * 2. 洛谷 P5787 [POI2008] PLA-Postering：使用线段树分治处理区间覆盖问题
		 * 3. 洛谷 P4219 [BJOI2014] 大融合：动态维护树的连通性和子树大小
		 * 4. Codeforces 1140F2 Extending Set of Points：动态维护点集的连通性
		 * 5. HDU 4336 Card Collector：使用线段树分治处理概率问题
		 * 6. AcWing 240. 食物链：扩展域并查集的经典应用
		 * 7. LeetCode 886. 可能的二分法：静态二分图检测问题
		 * 8. LeetCode 785. 判断二分图：静态二分图检测问题
		 * 
		 * 【算法学习建议】
		 * 1. 理解线段树的区间分割原理
		 * 2. 掌握可撤销数据结构的设计思想
		 * 3. 熟悉扩展域并查集在约束问题中的应用
		 * 4. 通过做题练习线段树分治的各种变体
		 * 5. 尝试将线段树分治应用到其他领域的问题
		 * 
		 * 【工程实践注意事项】
		 * 1. 内存管理：线段树分治可能需要较大的内存空间，需要合理分配
		 * 2. 递归深度：对于大规模问题，需要注意递归深度可能导致的栈溢出
		 * 3. 常数优化：在时间紧张的情况下，需要关注常数优化技巧
		 * 4. 输入输出效率：大规模数据下，高效的IO方法至关重要
		 * 
		 * 通过掌握线段树分治算法，我们能够解决许多看似复杂的动态图问题，
		 * 这是算法竞赛和工程实践中的重要工具。
		 */
}