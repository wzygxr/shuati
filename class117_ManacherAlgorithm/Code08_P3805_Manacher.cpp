/**
 * 洛谷 P3805 【模板】manacher
 * 
 * 题目描述:
 * 给出一个只由小写英文字符a,b,c...y,z组成的字符串S,求S中最长回文串的长度
 * 
 * 输入格式:
 * 一行小写英文字符a,b,c...y,z组成的字符串S
 * 
 * 输出格式:
 * 一个整数表示答案
 * 
 * 数据范围:
 * 1 <= n <= 1.1*10^7
 * 
 * 题目链接: https://www.luogu.com.cn/problem/P3805
 * 
 * 解题思路:
 * 使用Manacher算法求解最长回文子串问题。Manacher算法通过预处理字符串并在每个字符间插入特殊字符，
 * 利用回文的对称性质避免重复计算，从而在线性时间内解决问题。
 * 
 * 算法步骤:
 * 1. 预处理字符串: 在原字符串的每个字符之间插入特殊字符'#'，并在开头和结尾也插入'#'
 * 2. 初始化变量: 维护当前最右回文边界r、对应的中心c，以及每个位置的回文半径数组p
 * 3. 遍历预处理后的字符串:
 *    - 利用回文对称性优化: 如果当前位置i在当前右边界内，则可以利用对称点的信息
 *    - 尝试扩展回文串: 从最小可能的半径开始扩展
 *    - 更新最右回文边界和中心
 *    - 记录最大回文半径
 * 4. 返回最大回文长度
 * 
 * 时间复杂度: O(n)，其中n为字符串长度
 * 空间复杂度: O(n)，用于存储预处理字符串和回文半径数组
 * 
 * 与其他解法的比较:
 * 1. 暴力法: 时间复杂度O(n^3)，空间复杂度O(1)
 * 2. 中心扩展法: 时间复杂度O(n^2)，空间复杂度O(1)
 * 3. 动态规划法: 时间复杂度O(n^2)，空间复杂度O(n^2)
 * 4. Manacher算法: 时间复杂度O(n)，空间复杂度O(n)
 * 
 * Manacher算法的优势:
 * 1. 时间复杂度最优，为线性时间
 * 2. 充分利用回文的对称性质，避免重复计算
 * 3. 通过预处理统一处理奇数和偶数长度回文
 * 
 * 工程化考量:
 * 1. 边界处理: 正确处理字符串边界，防止数组越界
 * 2. 特殊字符选择: 选择不会在原字符串中出现的特殊字符
 * 3. 内存优化: 复用预处理字符串和回文半径数组
 * 4. 异常处理: 处理空字符串和单字符字符串的特殊情况
 * 
 * 语言特性差异:
 * 1. C++: 使用基础的数组和指针操作，避免使用STL容器
 * 2. Java: 使用字符数组进行预处理以提高效率，注意数组边界检查
 * 3. Python: 利用切片操作简化字符串处理，使用列表推导式创建数组
 */

// 定义最大字符串长度，根据题目要求设置为1.1*10^7
// 由于预处理后字符串长度会翻倍，所以需要预留足够空间
#define MAXN 12000000

// 预处理后的字符串数组
// 在原字符串的每个字符之间插入特殊字符'#'
char ss[MAXN << 1];

// 回文半径数组
// p[i]表示以位置i为中心的最长回文串的半径
int p[MAXN << 1];

// 预处理后字符串的长度
int n;

// 记录的最大回文长度
int maxLen;

/**
 * 预处理函数，用于在字符间插入'#'
 * 
 * 预处理的目的：
 * 1. 统一处理奇数长度和偶数长度的回文串
 * 2. 简化回文扩展的逻辑
 * 
 * 预处理方式：
 * 在原字符串的每个字符之间插入特殊字符'#'，并在开头和结尾也插入'#'
 * 例如：原字符串"abc"经过预处理后变成"#a#b#c#"
 * 
 * @param a 原始字符串
 * @param len 原始字符串长度
 */
void manacherss(char* a, int len) {
    // 计算预处理后字符串的长度
    // 原字符串长度为len，插入的特殊字符数量为len+1
    // 所以预处理后字符串长度为len*2+1
    n = len * 2 + 1;
    
    // 遍历预处理后的字符串位置
    for (int i = 0, j = 0; i < n; i++) {
        // 如果位置i是偶数，则插入特殊字符'#'
        // 如果位置i是奇数，则插入原字符串中的字符
        ss[i] = (i & 1) == 0 ? '#' : a[j++];
    }
}

/**
 * Manacher算法主函数
 * 
 * 算法原理：
 * 1. 预处理：在原字符串的每个字符之间插入特殊字符'#'
 * 2. 利用回文串的对称性，避免重复计算
 * 3. 维护当前最右回文边界r和对应的中心c，通过已计算的信息加速新位置的计算
 * 
 * 时间复杂度：O(n)
 * 空间复杂度：O(n)
 * 
 * @param str 原始字符串
 * @param len 原始字符串长度
 */
void manacher(char* str, int len) {
    // 预处理字符串
    manacherss(str, len);
    
    // 初始化最大回文长度
    maxLen = 0;
    
    // 遍历预处理后的字符串中的每个位置
    for (int i = 0, c = 0, r = 0, len_p; i < n; i++) {
        // 利用回文对称性优化
        // 如果当前位置i在当前右边界内，则可以利用对称点的信息
        len_p = r > i ? (p[2 * c - i] < (r - i) ? p[2 * c - i] : (r - i)) : 1;
        
        // 尝试扩展回文串
        // 从最小可能的半径开始扩展，直到无法扩展为止
        while (i + len_p < n && i - len_p >= 0 && ss[i + len_p] == ss[i - len_p]) {
            len_p++;
        }
        
        // 更新最右回文边界和中心
        // 如果当前回文串的右边界超过了记录的最右边界，则更新
        if (i + len_p > r) {
            r = i + len_p;
            c = i;
        }
        
        // 更新最大回文长度
        // 由于p[i]表示的是回文半径，实际长度需要减1
        maxLen = (maxLen > (len_p - 1)) ? maxLen : (len_p - 1);
        
        // 记录当前位置的回文半径
        p[i] = len_p;
    }
}

/**
 * 使用Manacher算法求解最长回文子串长度
 * 
 * @param s 输入字符串
 * @param len 输入字符串长度
 * @return 最长回文子串的长度
 */
int longestPalindrome(char* s, int len) {
    if (len == 0) {
        return 0;
    }
    
    // 使用Manacher算法计算最长回文子串长度
    manacher(s, len);
    
    // 返回记录的最大回文长度
    return maxLen;
}

/**
 * 手动实现字符串长度计算函数
 * 
 * @param s 字符串
 * @return 字符串长度
 */
int str_length(char* s) {
    int len = 0;
    while (s[len] != '\0') {
        len++;
    }
    return len;
}

/**
 * 测试用例和验证
 * 
 * 示例1:
 * 输入: "abcba"
 * 输出: 5
 * 解释: 整个字符串就是一个回文串
 * 
 * 示例2:
 * 输入: "abccba"
 * 输出: 6
 * 解释: 整个字符串就是一个回文串
 * 
 * 示例3:
 * 输入: "abacabad"
 * 输出: 3
 * 解释: "aba"或"bab"是最长回文子串
 * 
 * 边界场景测试:
 * 1. 空字符串: 输入"", 输出0
 * 2. 单字符: 输入"a", 输出1
 * 3. 无回文: 输入"abc", 输出1
 * 4. 全相同: 输入"aaaa", 输出4
 * 5. 最大长度: 输入长度为1.1*10^7的字符串
 * 
 * 性能测试:
 * 1. 时间复杂度验证: 对于不同长度的输入，运行时间应该线性增长
 * 2. 空间复杂度验证: 内存使用量应该与输入长度成正比
 * 3. 极端情况测试: 测试大量重复字符、交替字符等极端情况
 * 
 * 工程化考虑:
 * 1. 异常处理: 对于空输入返回0
 * 2. 内存管理: 使用全局数组避免频繁内存分配
 * 3. 可配置性: 可以通过调整MAXN适应不同规模的输入
 * 4. 可维护性: 详细的注释和清晰的变量命名
 */

#include <stdio.h>
#include <string.h>

int main() {
    char s[1000000];  // 假设最大输入长度为1000000
    scanf("%s", s);
    int len = str_length(s);
    printf("%d\n", longestPalindrome(s, len));
    return 0;
}
