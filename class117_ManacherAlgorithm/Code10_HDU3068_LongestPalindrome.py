"""
HDU 3068 最长回文

题目描述:
给定一个字符串，找到其中最长的回文子串并返回其长度

输入格式:
输入包含多个测试用例，每个测试用例占一行，为一个仅由小写字母组成的非空字符串
字符串长度不超过110000

输出格式:
对于每个测试用例，输出一行，为该字符串中最长回文子串的长度

题目链接: https://vjudge.net/problem/HDU-3068

解题思路:
使用Manacher算法求解最长回文子串问题。Manacher算法通过预处理字符串并在每个字符间插入特殊字符，
利用回文的对称性质避免重复计算，从而在线性时间内解决问题。

算法步骤:
1. 预处理字符串: 在原字符串的每个字符之间插入特殊字符'#'，并在开头和结尾也插入'#'
2. 初始化变量: 维护当前最右回文边界r、对应的中心c，以及每个位置的回文半径数组p
3. 遍历预处理后的字符串:
   - 利用回文对称性优化: 如果当前位置i在当前右边界内，则可以利用对称点的信息
   - 尝试扩展回文串: 从最小可能的半径开始扩展
   - 更新最右回文边界和中心
   - 记录最大回文半径
4. 返回最大回文长度

时间复杂度: O(n)，其中n为字符串长度
空间复杂度: O(n)，用于存储预处理字符串和回文半径数组

与其他解法的比较:
1. 暴力法: 时间复杂度O(n^3)，空间复杂度O(1)
2. 中心扩展法: 时间复杂度O(n^2)，空间复杂度O(1)
3. 动态规划法: 时间复杂度O(n^2)，空间复杂度O(n^2)
4. Manacher算法: 时间复杂度O(n)，空间复杂度O(n)

Manacher算法的优势:
1. 时间复杂度最优，为线性时间
2. 充分利用回文的对称性质，避免重复计算
3. 通过预处理统一处理奇数和偶数长度回文

工程化考量:
1. 边界处理: 正确处理字符串边界，防止数组越界
2. 特殊字符选择: 选择不会在原字符串中出现的特殊字符
3. 内存优化: 复用预处理字符串和回文半径数组
4. 异常处理: 处理空字符串和单字符字符串的特殊情况

语言特性差异:
1. Python: 利用切片操作简化字符串处理，使用列表推导式创建数组
2. Java: 使用字符数组进行预处理以提高效率，注意数组边界检查
3. C++: 使用基础的数组和指针操作，避免使用STL容器
"""


def manacher(s):
    """
    Manacher算法主函数

    算法原理：
    1. 预处理：在原字符串的每个字符之间插入特殊字符'#'
    2. 利用回文串的对称性，避免重复计算
    3. 维护当前最右回文边界r和对应的中心c，通过已计算的信息加速新位置的计算

    时间复杂度：O(n)
    空间复杂度：O(n)

    :param s: 原始字符串
    :return: 最长回文子串的长度
    """
    if not s:
        return 0

    # 预处理字符串
    processed = preprocess(s)
    n = len(processed)

    # 初始化回文半径数组
    p = [0] * n

    # 初始化最大回文长度
    max_len = 0

    # 初始化中心和右边界
    center = right = 0

    # 遍历预处理后的字符串中的每个位置
    for i in range(n):
        # 利用回文对称性优化
        # 如果当前位置i在当前右边界内，则可以利用对称点的信息
        if i < right:
            mirror = 2 * center - i
            p[i] = min(right - i, p[mirror])

        # 尝试扩展回文串
        # 从最小可能的半径开始扩展，直到无法扩展为止
        try:
            while i + p[i] + 1 < n and i - p[i] - 1 >= 0 and processed[i + p[i] + 1] == processed[i - p[i] - 1]:
                p[i] += 1
        except IndexError:
            pass

        # 更新最右回文边界和中心
        # 如果当前回文串的右边界超过了记录的最右边界，则更新
        if i + p[i] > right:
            right = i + p[i]
            center = i

        # 更新最大回文长度
        # 由于p[i]表示的是回文半径，实际长度需要减1
        max_len = max(max_len, p[i])

    return max_len


def preprocess(s):
    """
    预处理函数，用于在字符间插入'#'

    预处理的目的：
    1. 统一处理奇数长度和偶数长度的回文串
    2. 简化回文扩展的逻辑

    预处理方式：
    在原字符串的每个字符之间插入特殊字符'#'，并在开头和结尾也插入'#'
    例如：原字符串"abc"经过预处理后变成"#a#b#c#"

    :param s: 原始字符串
    :return: 预处理后的字符串
    """
    # 使用列表推导式创建预处理后的字符串
    # 在原字符串的每个字符之间插入特殊字符'#'，并在开头和结尾也插入'#'
    return '#' + '#'.join(s) + '#'


def longest_palindrome(s):
    """
    使用Manacher算法求解最长回文子串长度

    :param s: 输入字符串
    :return: 最长回文子串的长度
    """
    if not s:
        return 0

    # 使用Manacher算法计算最长回文子串长度
    return manacher(s)


# 测试用例和验证
if __name__ == "__main__":
    try:
        while True:
            # 读取输入字符串
            s = input().strip()
            
            # 计算并输出最长回文子串长度
            print(longest_palindrome(s))
    except EOFError:
        pass

"""
测试用例和验证

示例1:
输入: "aaaa"
输出: 4
解释: 整个字符串就是一个回文串

示例2:
输入: "abab"
输出: 3
解释: "aba"或"bab"是最长回文子串

示例3:
输入: "abcd"
输出: 1
解释: 每个单字符都是回文串

边界场景测试:
1. 空字符串: 输入""，输出0
2. 单字符: 输入"a"，输出1
3. 无回文: 输入"abc"，输出1
4. 全相同: 输入"aaaa"，输出4
5. 最大长度: 输入长度为110000的字符串

性能测试:
1. 时间复杂度验证: 对于不同长度的输入，运行时间应该线性增长
2. 空间复杂度验证: 内存使用量应该与输入长度成正比
3. 极端情况测试: 测试大量重复字符、交替字符等极端情况

工程化考虑:
1. 异常处理: 对于空输入返回0
2. 内存管理: 使用列表避免频繁内存分配
3. 可维护性: 详细的注释和清晰的函数命名
"""