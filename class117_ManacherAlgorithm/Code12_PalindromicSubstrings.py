"""
LeetCode 647. 回文子串

题目描述:
给你一个字符串 s ，请你统计并返回这个字符串中 回文子串 的数目

输入格式:
字符串 s

输出格式:
整数，表示回文子串的数量

数据范围:
1 <= s.length <= 1000
s 由小写英文字母组成

题目链接: https://leetcode.cn/problems/palindromic-substrings/

解题思路:
使用Manacher算法求解回文子串数量问题。Manacher算法通过预处理字符串并在每个字符间插入特殊字符，
利用回文的对称性质避免重复计算，从而在线性时间内解决问题。

算法步骤:
1. 预处理字符串: 在原字符串的每个字符之间插入特殊字符'#'，并在开头和结尾也插入'#'
2. 初始化变量: 维护当前最右回文边界r、对应的中心c，以及每个位置的回文半径数组p
3. 遍历预处理后的字符串:
   - 利用回文对称性优化: 如果当前位置i在当前右边界内，则可以利用对称点的信息
   - 尝试扩展回文串: 从最小可能的半径开始扩展
   - 更新最右回文边界和中心
   - 统计回文子串数量: 每个位置的回文半径对应的回文子串数量为len//2
4. 返回回文子串总数

时间复杂度: O(n)，其中n为字符串长度
空间复杂度: O(n)，用于存储预处理字符串和回文半径数组

与其他解法的比较:
1. 暴力法: 时间复杂度O(n^3)，空间复杂度O(1)
2. 中心扩展法: 时间复杂度O(n^2)，空间复杂度O(1)
3. 动态规划法: 时间复杂度O(n^2)，空间复杂度O(n^2)
4. Manacher算法: 时间复杂度O(n)，空间复杂度O(n)

算法优化点:
1. 预处理字符串统一处理奇数和偶数长度的回文串
2. 利用回文对称性避免重复计算
3. 线性时间复杂度的算法实现

语言特性差异:
Python: 利用字符串操作和列表推导式简化代码，注意异常处理以避免索引越界
"""


def count_substrings(s):
    """
    计算字符串s中的回文子串数量
    
    时间复杂度: O(n)
    空间复杂度: O(n)
    
    :param s: 输入字符串
    :return: 回文子串的数量
    """
    # 使用Manacher算法统计回文子串数量
    return manacher(s)


def preprocess(s):
    """
    预处理函数，用于在字符间插入'#'
    
    预处理的目的：
    1. 统一处理奇数长度和偶数长度的回文串
    2. 简化回文扩展的逻辑
    
    预处理方式：
    在原字符串的每个字符之间插入特殊字符'#'，并在开头和结尾也插入'#'
    例如：原字符串"abc"经过预处理后变成"#a#b#c#"
    
    :param s: 原始字符串
    :return: 预处理后的字符串
    """
    # 使用join方法创建预处理后的字符串
    return '#' + '#'.join(s) + '#'


def manacher(s):
    """
    Manacher算法主函数
    
    算法原理：
    1. 预处理：在原字符串的每个字符之间插入特殊字符'#'
    2. 利用回文串的对称性，避免重复计算
    3. 维护当前最右回文边界r和对应的中心c，通过已计算的信息加速新位置的计算
    4. 统计回文子串数量：每个位置i的回文半径对应的回文子串数量为len//2
    
    :param s: 原始字符串
    :return: 回文子串的数量
    """
    # 处理边界情况
    if not s:
        return 0
    
    # 预处理字符串
    processed = preprocess(s)
    n = len(processed)
    
    # 初始化回文半径数组
    p = [0] * n
    
    # 初始化结果计数器
    count = 0
    
    # 初始化中心和右边界
    center = right = 0
    
    # 遍历预处理后的字符串中的每个位置
    for i in range(n):
        # 利用回文对称性优化
        # 如果当前位置i在当前右边界内，则可以利用对称点的信息
        if i < right:
            mirror = 2 * center - i
            p[i] = min(right - i, p[mirror])
        
        # 尝试扩展回文串
        # 从最小可能的半径开始扩展，直到无法扩展为止
        try:
            while (i + p[i] + 1 < n and 
                   i - p[i] - 1 >= 0 and 
                   processed[i + p[i] + 1] == processed[i - p[i] - 1]):
                p[i] += 1
        except IndexError:
            # 防止索引越界
            pass
        
        # 更新最右回文边界和中心
        # 如果当前回文串的右边界超过了记录的最右边界，则更新
        if i + p[i] > right:
            right = i + p[i]
            center = i
        
        # 统计回文子串数量
        # 对于预处理后的字符串，每个位置i的回文半径p[i]对应的回文子串数量为p[i] // 2
        # 例如：p[i] = 3 对应2个回文子串，p[i] = 4对应2个回文子串
        count += (p[i] + 1) // 2
    
    return count


# 测试用例
"""
测试用例1：
输入: s = "abc"
输出: 3
解释: 三个回文子串: "a", "b", "c"

测试用例2：
输入: s = "aaa"
输出: 6
解释: 六个回文子串: "a", "a", "a", "aa", "aa", "aaa"

测试用例3：边界情况
输入: s = ""
输出: 0

测试用例4：边界情况
输入: s = "a"
输出: 1
"""

if __name__ == "__main__":
    # 测试用例1
    s1 = "abc"
    print(f"输入: '{s1}', 输出: {count_substrings(s1)}")  # 应输出3
    
    # 测试用例2
    s2 = "aaa"
    print(f"输入: '{s2}', 输出: {count_substrings(s2)}")  # 应输出6
    
    # 测试边界情况
    s3 = ""
    print(f"输入: '{s3}', 输出: {count_substrings(s3)}")  # 应输出0
    
    s4 = "a"
    print(f"输入: '{s4}', 输出: {count_substrings(s4)}")  # 应输出1
    
    # 额外测试用例
    s5 = "abccba"
    print(f"输入: '{s5}', 输出: {count_substrings(s5)}")  # 应输出9
    
    s6 = "ababa"
    print(f"输入: '{s6}', 输出: {count_substrings(s6)}")  # 应输出9