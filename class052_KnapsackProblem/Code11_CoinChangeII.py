# 零钱兑换 II
# 给你一个整数数组 coins 表示不同面额的硬币，另给一个整数 amount 表示总金额。
# 请你计算并返回可以凑成总金额的硬币组合数。如果任何硬币组合都无法凑出总金额，返回 0 。
# 假设每一种面额的硬币有无限个。
# 测试链接 : https://leetcode.cn/problems/coin-change-ii/

'''
算法详解：
这是一个完全背包问题的变种，求的是组合数而不是最小数量。每种硬币可以使用无限次，
我们需要计算出组成指定金额的组合数。

解题思路：
1. 状态定义：dp[j]表示组成金额j的组合数
2. 状态转移方程：
   dp[j] = dp[j] + dp[j-coins[i]]
3. 初始化：dp[0] = 1，表示组成金额0有1种组合（不选任何硬币）；其余初始化为0

时间复杂度分析：
设有n种硬币，总金额为amount
1. 动态规划计算：O(n * amount)
总时间复杂度：O(n * amount)

空间复杂度分析：
1. 一维DP数组：O(amount)

相关题目扩展：
1. LeetCode 518. 零钱兑换 II（本题）
2. LeetCode 322. 零钱兑换（完全背包求最小数量）
3. LeetCode 279. 完全平方数（完全背包）
4. 洛谷 P1616 疯狂的采药（完全背包模板题）
5. 洛谷 P2918 购买干草（完全背包变种）

工程化考量：
1. 输入验证：检查输入参数的有效性
2. 异常处理：处理空输入、非法输入等边界情况
3. 可配置性：可以将MAX_AMOUNT作为配置参数传入
4. 单元测试：为change方法编写测试用例
5. 性能优化：对于大数据量场景，考虑使用滚动数组优化空间

语言特性差异：
1. Java：使用静态数组提高访问速度
2. C++：可以使用vector，但要注意内存分配开销
3. Python：列表推导式简洁但性能较低

调试技巧：
1. 打印dp数组中间状态，观察状态转移过程
2. 使用断言验证边界条件
3. 构造小规模测试用例手动验证结果

优化点：
1. 剪枝优化：当硬币面额大于当前金额时跳过
2. 排序优化：先处理小面额硬币保证组合不重复
3. 提前终止：当发现无法组成目标金额时提前返回

与标准背包的区别：
1. 目标函数：标准背包求最大价值，本题求组合数
2. 状态初始化：标准背包dp[0] = 0，本题dp[0] = 1
3. 状态转移：标准背包取max，本题累加
4. 遍历顺序：本题需要先遍历物品再遍历背包，保证组合不重复
'''

def change(amount, coins):
    """
    使用动态规划求解零钱兑换II问题
    
    Args:
        amount: int 目标金额
        coins: List[int] 硬币面额列表
    
    Returns:
        int: 组合数
    """
    # 初始化dp数组
    dp = [0] * (amount + 1)
    dp[0] = 1
    
    # 动态规划填表
    for coin in coins:
        for j in range(coin, amount + 1):
            dp[j] += dp[j - coin]
    
    return dp[amount]

# 测试方法
if __name__ == "__main__":
    # 测试用例1: amount = 5, coins = [1, 2, 5]
    # 预期输出: 4 ([5], [2,2,1], [2,1,1,1], [1,1,1,1,1])
    coins1 = [1, 2, 5]
    print("Test 1:", change(5, coins1))
    
    # 测试用例2: amount = 3, coins = [2]
    # 预期输出: 0 (无法组成)
    coins2 = [2]
    print("Test 2:", change(3, coins2))
    
    # 测试用例3: amount = 10, coins = [10]
    # 预期输出: 1 ([10])
    coins3 = [10]
    print("Test 3:", change(10, coins3))