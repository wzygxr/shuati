# 完全平方数
# 给你一个整数 n ，返回和为 n 的完全平方数的最少数量。
# 完全平方数是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。
# 例如，1、4、9 和 16 都是完全平方数，而 3 和 11 不是。
# 测试链接 : https://leetcode.cn/problems/perfect-squares/

'''
算法详解：
这是一个完全背包问题的变种。我们可以将所有小于等于n的完全平方数看作物品，
每个物品可以使用无限次，目标是用最少的物品数量填满容量为n的背包。

解题思路：
1. 预处理：生成所有小于等于n的完全平方数
2. 状态定义：dp[j]表示组成数字j所需的最少完全平方数个数
3. 状态转移方程：
   dp[j] = min(dp[j], dp[j-square[i]] + 1)
4. 初始化：dp[0] = 0，表示组成数字0需要0个完全平方数；其余初始化为无穷大

时间复杂度分析：
设目标数字为n，完全平方数个数为sqrt(n)
1. 预处理完全平方数：O(sqrt(n))
2. 动态规划计算：O(sqrt(n) * n)
总时间复杂度：O(sqrt(n) * n)

空间复杂度分析：
1. 完全平方数数组：O(sqrt(n))
2. DP数组：O(n)
总空间复杂度：O(n)

相关题目扩展：
1. LeetCode 279. 完全平方数（本题）
2. LeetCode 322. 零钱兑换（完全背包）
3. LeetCode 518. 零钱兑换 II（完全背包求方案数）
4. 洛谷 P1616 疯狂的采药（完全背包模板题）
5. 洛谷 P2918 购买干草（完全背包变种）

工程化考量：
1. 输入验证：检查输入参数的有效性
2. 异常处理：处理空输入、非法输入等边界情况
3. 可配置性：可以将MAXN作为配置参数传入
4. 单元测试：为numSquares方法编写测试用例
5. 性能优化：对于大数据量场景，考虑使用滚动数组优化空间

语言特性差异：
1. Java：使用静态数组提高访问速度
2. C++：可以使用vector，但要注意内存分配开销
3. Python：列表推导式简洁但性能较低

调试技巧：
1. 打印dp数组中间状态，观察状态转移过程
2. 使用断言验证边界条件
3. 构造小规模测试用例手动验证结果

优化点：
1. 数学优化：利用四平方和定理，任何正整数都可以表示为至多4个正整数的平方和
2. 剪枝优化：当完全平方数大于当前数字时跳过
3. 提前终止：当发现最优解时提前返回

与标准背包的区别：
1. 物品生成：标准背包物品是给定的，本题需要预处理生成
2. 目标函数：标准背包求最大价值，本题求最小物品数
3. 状态初始化：标准背包dp[0] = 0，其余为0；本题dp[0] = 0，其余为无穷大
4. 状态转移：标准背包取max，本题取min
'''

def numSquares(n):
    """
    使用动态规划求解完全平方数问题
    
    Args:
        n: int 目标数字
    
    Returns:
        int: 最少完全平方数个数
    """
    # 预处理生成所有小于等于n的完全平方数
    squares = []
    i = 1
    while i * i <= n:
        squares.append(i * i)
        i += 1
    
    # 初始化dp数组
    dp = [float('inf')] * (n + 1)
    dp[0] = 0
    
    # 动态规划填表
    for square in squares:
        for j in range(square, n + 1):
            dp[j] = min(dp[j], dp[j - square] + 1)
    
    return dp[n]

# 测试方法
if __name__ == "__main__":
    # 测试用例1: n = 12
    # 预期输出: 3 (4+4+4=12)
    print("Test 1:", numSquares(12))
    
    # 测试用例2: n = 13
    # 预期输出: 2 (4+9=13)
    print("Test 2:", numSquares(13))
    
    # 测试用例3: n = 1
    # 预期输出: 1 (1=1)
    print("Test 3:", numSquares(1))