package class078;

// 监控二叉树
// 给定一个二叉树，我们在树的节点上安装摄像头
// 节点上的每个摄影头都可以监视其父对象、自身及其直接子对象
// 计算监控树的所有节点所需的最小摄像头数量
// 测试链接 : https://leetcode.cn/problems/binary-tree-cameras/
//
// 解题思路:
// 1. 使用树形动态规划（Tree DP）的方法，采用贪心策略
// 2. 对于每个节点，我们定义三种状态：
//    - 状态0: 当前节点未被监控，但其子树都被监控
//    - 状态1: 当前节点被监控，但没有摄像头
//    - 状态2: 当前节点被监控，且有摄像头
// 3. 递归处理左右子树，综合计算当前节点的信息
// 4. 贪心策略：
//    - 如果左右子节点中有未被监控的节点，则当前节点必须安装摄像头
//    - 如果左右子节点都被监控且至少有一个有摄像头，则当前节点被监控但无需摄像头
//    - 如果左右子节点都被监控且都没有摄像头，则当前节点未被监控（留给父节点处理）
//
// 时间复杂度: O(n) - n为树中节点的数量，需要遍历所有节点
// 空间复杂度: O(h) - h为树的高度，递归调用栈的深度
// 是否为最优解: 是，这是计算监控二叉树所需最少摄像头的标准方法
public class Code06_BinaryTreeCameras {

	// 不要提交这个类
	public static class TreeNode {
		public int val;
		public TreeNode left;
		public TreeNode right;
	}

	// 提交如下的方法
	public int minCameraCover(TreeNode root) {
		ans = 0;
		// 特殊处理根节点
		if (f(root) == 0) {
			ans++;
		}
		return ans;
	}
	
	// 遍历过程中一旦需要放置相机，ans++
	public static int ans;

	// 递归含义
	// 假设x上方一定有父亲的情况下，这个假设很重要
	// x为头的整棵树，最终想都覆盖，
	// 并且想使用最少的摄像头，x应该是什么样的状态
	// 返回值含义
	// 0: x是无覆盖的状态，x下方的节点都已经被覆盖
	// 1: x是覆盖状态，x上没摄像头，x下方的节点都已经被覆盖
	// 2: x是覆盖状态，x上有摄像头，x下方的节点都已经被覆盖
	private int f(TreeNode x) {
		// 基本情况：空节点，视为已被监控但无摄像头
		if (x == null) {
			return 1;
		}
		
		// 递归处理左右子树
		int left = f(x.left);
		int right = f(x.right);
		
		// 根据左右子树的状态决定当前节点的状态
		// 如果左右子节点中有未被监控的节点，则当前节点必须安装摄像头
		if (left == 0 || right == 0) {
			ans++;
			return 2;
		}
		
		// 如果左右子节点都被监控且至少有一个有摄像头，则当前节点被监控但无需摄像头
		if (left == 1 && right == 1) {
			return 0;
		}
		
		// 如果左右子节点都被监控且至少有一个有摄像头，则当前节点被监控但无需摄像头
		return 1;
	}

}