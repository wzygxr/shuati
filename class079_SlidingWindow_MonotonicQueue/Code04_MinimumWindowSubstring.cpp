/**
 * @file Code04_MinimumWindowSubstring.cpp
 * @brief 最小覆盖子串 - 滑动窗口与字符计数算法深度解析
 * 
 * 【题目背景】
 * 最小覆盖子串问题是字符串处理中的经典问题，需要高效找到包含目标字符串所有字符的最小子串。
 * 本算法通过滑动窗口技术结合字符计数数组，实现O(n)时间复杂度的解决方案。
 * 
 * 【题目描述】
 * 给你一个字符串 s 、一个字符串 t 。返回 s 中涵盖 t 所有字符的最小子串。
 * 如果 s 中不存在涵盖 t 所有字符的子串，则返回空字符串 "" 。
 * 注意：
 * 对于 t 中重复字符，我们寻找的子字符串中该字符数量必须不少于 t 中该字符数量。
 * 如果 s 中存在这样的子串，我们保证它是唯一的答案。
 * 测试链接：https://leetcode.cn/problems/minimum-window-substring/
 * 
 * 【核心算法思想】
 * 1. 滑动窗口技术：使用双指针维护窗口边界
 * 2. 字符计数数组：使用固定大小数组代替哈希表记录字符频次
 * 3. 匹配计数器：记录窗口中满足目标字符频次要求的字符种类数
 * 4. 窗口扩展策略：右指针移动，扩展窗口直到包含所有目标字符
 * 5. 窗口收缩策略：左指针移动，收缩窗口以找到最小覆盖子串
 * 
 * 【算法复杂度分析】
 * - 时间复杂度：O(n) - 每个字符最多被访问两次（右指针一次，左指针一次）
 * - 空间复杂度：O(1) - 字符集大小固定（ASCII字符集最多256个字符）
 * 
 * 【工程化考量】
 * 1. 字符集处理：支持ASCII字符集，可扩展为Unicode字符集
 * 2. 边界检查：处理空字符串、无效输入等边界情况
 * 3. 性能优化：使用数组代替哈希表提高访问效率
 * 4. 代码可读性：清晰的变量命名和算法步骤注释
 * 
 * 【面试要点】
 * - 理解滑动窗口在字符串匹配中的应用
 * - 能够解释字符计数数组的工作原理
 * - 分析时间复杂度的均摊分析原理
 * - 处理各种边界情况和特殊输入
 */

#include <string>
#include <vector>
#include <climits>
#include <iostream>
#include <algorithm>
using namespace std;

/**
 * 最小覆盖子串算法实现类
 * 
 * 【算法原理深度解析】
 * 本算法通过滑动窗口技术结合字符计数数组，实现高效的最小覆盖子串查找。
 * 关键设计要点：
 * 1. 字符计数数组：使用固定大小的数组记录目标字符串t中每个字符的出现次数
 * 2. 滑动窗口：通过双指针控制窗口范围，动态调整窗口大小
 * 3. 匹配计数器：记录还需要匹配的字符种类数，当计数器为0时表示窗口包含所有字符
 * 4. 最小子串记录：在满足条件时记录最小覆盖子串的起始位置和长度
 * 
 * 【时间复杂度数学证明】
 * 虽然算法包含嵌套循环，但通过均摊分析可知：
 * - 每个字符最多被右指针访问一次（扩展窗口）
 * - 每个字符最多被左指针访问一次（收缩窗口）
 * - 总操作次数为O(n)，因此时间复杂度为O(n)
 * 
 * 【空间复杂度分析】
 * - 使用固定大小的计数数组（128个元素）
 * - 因此空间复杂度为O(1)
 * 
 * 【工程化优化策略】
 * 1. 使用vector代替原生数组，提高安全性
 * 2. 预分配足够空间，避免动态扩容
 * 3. 提供详细的边界检查和异常处理
 * 4. 代码结构清晰，便于理解和维护
 */
class Solution {
public:
    /**
     * 计算最小覆盖子串的核心算法实现
     * 
     * @param s 源字符串
     * @param t 目标字符串
     * @return s中涵盖t所有字符的最小子串，如果不存在返回空字符串
     * 
     * 【测试用例覆盖】
     * - 常规测试："ADOBECODEBANC", "ABC" → "BANC"
     * - 边界测试：空字符串、单字符、完全匹配等
     * - 特殊测试：重复字符、不包含目标字符等
     * 
     * 【算法步骤详解】
     * 1. 边界检查：处理空字符串和无效输入
     * 2. 字符计数：统计目标字符串t中每个字符的频次
     * 3. 滑动窗口：使用双指针维护窗口边界
     * 4. 窗口扩展：右指针移动，扩展窗口直到包含所有目标字符
     * 5. 窗口收缩：左指针移动，收缩窗口以找到最小覆盖子串
     * 6. 结果返回：根据记录的最小窗口信息返回结果
     */
    string minWindow(string s, string t) {
        if (s.empty() || t.empty() || s.length() == 0 || t.length() == 0) {
            return "";
        }
        
        // 用数组代替哈希表，提高效率
        // ASCII码范围是0-127，这里用128足够
        vector<int> need(128, 0); // 需要的字符频次
        vector<int> window(128, 0); // 窗口中的字符频次
        
        // 统计目标字符串中每个字符的频次
        for (int i = 0; i < t.length(); i++) {
            need[t[i]]++;
        }
        
        int left = 0, right = 0; // 滑动窗口的左右边界
        int valid = 0; // 窗口中满足need条件的字符个数
        int start = 0, len = INT_MAX; // 记录最小覆盖子串的起始位置和长度
        
        while (right < s.length()) {
            // c是将要移入窗口的字符
            char c = s[right];
            // 右移窗口
            right++;
            
            // 进行窗口内数据的一系列更新
            if (need[c] > 0) {
                window[c]++;
                // 当window[c]等于need[c]时，说明字符c在窗口中的数量已经满足需求
                if (window[c] == need[c]) {
                    valid++;
                }
            }
            
            // 判断左侧窗口是否要收缩
            while (valid == getValidCount(need)) {
                // 在这里更新最小覆盖子串
                if (right - left < len) {
                    start = left;
                    len = right - left;
                }
                
                // d是将要移出窗口的字符
                char d = s[left];
                // 左移窗口
                left++;
                
                // 进行窗口内数据的一系列更新
                if (need[d] > 0) {
                    if (window[d] == need[d]) {
                        valid--;
                    }
                    window[d]--;
                }
            }
        }
        
        // 返回最小覆盖子串
        return len == INT_MAX ? "" : s.substr(start, len);
    }
    
private:
    // 计算目标字符串中不同字符的个数
    int getValidCount(vector<int>& need) {
        int count = 0;
        for (int i = 0; i < need.size(); i++) {
            if (need[i] > 0) {
                count++;
            }
        }
        return count;
    }
};