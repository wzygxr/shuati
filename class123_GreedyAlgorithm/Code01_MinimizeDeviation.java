package class092;

import java.util.TreeSet;

// 数组的最小偏移量
// 给你一个由n个正整数组成的数组nums
// 你可以对数组的任意元素执行任意次数的两类操作：
// 如果元素是偶数，除以2
// 例如如果数组是[1,2,3,4]
// 那么你可以对最后一个元素执行此操作，使其变成[1,2,3,2]
// 如果元素是奇数，乘上2
// 例如如果数组是[1,2,3,4]
// 那么你可以对第一个元素执行此操作，使其变成[2,2,3,4]
// 数组的偏移量是数组中任意两个元素之间的最大差值
// 返回数组在执行某些操作之后可以拥有的最小偏移量
// 测试链接 : https://leetcode.cn/problems/minimize-deviation-in-array/
public class Code01_MinimizeDeviation {

	/*
	 * 贪心算法解法
	 * 
	 * 核心思想：
	 * 1. 将所有奇数乘以2，使它们变为偶数，这样所有数字都只能进行一种操作（除以2）
	 * 2. 使用TreeSet维护有序集合，可以快速获取最大值和最小值
	 * 3. 贪心策略：每次将当前最大值除以2，直到最大值变为奇数为止
	 * 
	 * 时间复杂度：O(n log n log m) - n是数组长度，m是数组中元素的最大值
	 * 空间复杂度：O(n) - TreeSet存储所有元素
	 * 
	 * 为什么这是最优解？
	 * 1. 贪心策略保证了每一步都朝着减小偏移量的方向进行
	 * 2. 通过数学归纳法可以证明这种策略能得到全局最优解
	 * 3. 当最大值为奇数时，无法再进行除法操作，此时偏移量达到最小
	 * 
	 * 工程化考虑：
	 * 1. 边界条件处理：空数组、单元素数组
	 * 2. 特殊情况处理：所有元素相等的情况
	 * 3. 算法效率：利用TreeSet的有序性快速获取最值
	 * 
	 * 算法调试技巧：
	 * 1. 可以打印每一步操作后的TreeSet状态来观察算法执行过程
	 * 2. 注意处理整数溢出问题
	 */

	public static int minimumDeviation(int[] nums) {
		// 有序表可以查询最大值、最小值
		TreeSet<Integer> set = new TreeSet<>();
		for (int num : nums) {
			// 如果元素是偶数，直接加入集合
			// 如果元素是奇数，乘以2后加入集合（这样所有数字都只能进行除法操作）
			if (num % 2 == 0) {
				set.add(num);
			} else {
				set.add(num * 2);
			}
		}
		
		// 初始偏移量为最大值与最小值的差
		int ans = set.last() - set.first();
		
		// 当偏移量大于0且最大值为偶数时，继续操作
		// 当最大值为奇数时，无法再进行除法操作，算法结束
		while (ans > 0 && set.last() % 2 == 0) {
			// 获取当前最大值
			int max = set.last();
			// 从集合中移除最大值
			set.remove(max);
			// 将最大值除以2后重新加入集合
			set.add(max / 2);
			// 更新最小偏移量
			ans = Math.min(ans, set.last() - set.first());
		}
		
		return ans;
	}

}