// 简化版C++实现，避免使用STL容器
// 由于编译环境问题，使用数组和基本操作替代STL容器

// 合并果子
// 在一个果园里，多多已经将所有的果子打了下来，而且按果子的不同种类分成了不同的堆。
// 多多决定把所有的果子合成一堆。
// 每一次合并，多多可以把两堆果子合并到一起，消耗的体力等于两堆果子的重量之和。
// 可以看出，所有的果子经过n-1次合并之后，就只剩下一堆了。
// 多多在合并果子时总共消耗的体力等于每次合并所耗体力的和。
// 因为还要花大力气把这些果子搬回家，所以多多在合并果子时要尽可能地节省体力。
// 假定每个果子重量都为1，并且已知果子的堆数和每堆果子的数目，
// 你的任务是设计出合并的次序方案，使多多耗费的体力最少，并输出这个最小的体力耗费值。
// 测试链接 : https://www.luogu.com.cn/problem/P1090

/*
 * 贪心算法解法（使用数组模拟最小堆）
 * 
 * 核心思想：
 * 1. 为了使消耗的体力最小，每次都应该选择当前重量最小的两堆果子进行合并
 * 2. 这可以通过维护一个有序数组来实现
 * 
 * 算法步骤：
 * 1. 将所有果子堆的重量放入数组中并排序
 * 2. 每次取出两个最小的元素，将它们合并（相加）
 * 3. 将合并后的结果插入到数组中的合适位置
 * 4. 重复步骤2-3直到数组中只剩一个元素
 * 5. 累计所有合并操作的体力消耗
 * 
 * 时间复杂度：O(n^2) - 每次插入需要O(n)时间，共n-1次操作
 * 空间复杂度：O(n) - 需要额外的数组存储元素
 * 
 * 为什么这是最优解？
 * 1. 贪心策略保证了每一步都做出了当前看起来最好的选择
 * 2. 通过哈夫曼编码的理论可以证明这种策略能得到全局最优解
 * 3. 无法在更少的时间内完成，因为至少需要处理所有元素
 * 
 * 工程化考虑：
 * 1. 边界条件处理：空数组、单元素数组
 * 2. 异常处理：输入参数验证
 * 3. 可读性：变量命名清晰，注释详细
 * 
 * 算法调试技巧：
 * 1. 可以通过打印每一步的数组状态来观察合并过程
 * 2. 用断言验证中间结果是否符合预期
 * 
 * 与机器学习的联系：
 * 1. 这个问题与哈夫曼编码密切相关，哈夫曼编码在数据压缩中有重要应用
 * 2. 在决策树构建中也有类似的贪心思想
 */

// 简单实现插入排序
void insertSort(int arr[], int size) {
    for (int i = 1; i < size; i++) {
        int key = arr[i];
        int j = i - 1;
        
        // 将大于key的元素向后移动
        while (j >= 0 && arr[j] > key) {
            arr[j + 1] = arr[j];
            j--;
        }
        
        arr[j + 1] = key;
    }
}

// 查找插入位置并插入元素
void insertElement(int arr[], int* size, int element) {
    // 找到插入位置
    int pos = 0;
    while (pos < *size && arr[pos] < element) {
        pos++;
    }
    
    // 将元素向后移动
    for (int i = *size; i > pos; i--) {
        arr[i] = arr[i - 1];
    }
    
    // 插入元素
    arr[pos] = element;
    (*size)++;
}

// 合并果子主函数
int mergeFruits(int fruits[], int size) {
    // 边界条件：如果果子堆数小于等于1，不需要合并
    if (size <= 1) {
        return 0;
    }
    
    // 创建工作数组
    int workArr[1000];  // 假设最大数量不超过1000
    int workSize = size;
    
    // 复制数据到工作数组
    for (int i = 0; i < size; i++) {
        workArr[i] = fruits[i];
    }
    
    // 对工作数组进行排序
    insertSort(workArr, workSize);
    
    // 记录总消耗的体力
    int totalEnergy = 0;
    
    // 每次合并两堆果子，直到只剩一堆
    while (workSize > 1) {
        // 取出两个最小的元素
        int first = workArr[0];
        int second = workArr[1];
        
        // 从数组中移除这两个元素
        for (int i = 2; i < workSize; i++) {
            workArr[i - 2] = workArr[i];
        }
        workSize -= 2;
        
        // 合并两堆果子
        int merged = first + second;
        
        // 累计消耗的体力
        totalEnergy += merged;
        
        // 将合并后的结果插入到数组中的合适位置
        insertElement(workArr, &workSize, merged);
    }
    
    return totalEnergy;
}

// 主函数
int main() {
    // 由于环境限制，这里只提供函数实现，不提供完整的测试代码
    // 在实际使用中，需要根据具体需求调用相关函数
    
    return 0;
}