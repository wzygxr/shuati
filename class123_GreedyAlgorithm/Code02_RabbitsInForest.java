package class092;

import java.util.Arrays;

// 森林中的兔子
// 森林中有未知数量的兔子
// 你问兔子们一个问题: "还有多少只兔子与你颜色相同?"
// 你将答案收集到了一个数组answers中
// 你可能没有收集到所有兔子的回答，可能只是一部分兔子的回答
// 其中answers[i]是第i只兔子的答案
// 所有兔子都不会说错，返回森林中兔子的最少数量
// 测试链接 : https://leetcode.cn/problems/rabbits-in-forest/
public class Code02_RabbitsInForest {

	/*
	 * 贪心算法解法
	 * 
	 * 核心思想：
	 * 1. 对于回答相同数字的兔子，尽可能将它们归为同一颜色组
	 * 2. 如果有k只兔子回答数字n，那么至少需要⌈k/(n+1)⌉个颜色组，每组n+1只兔子
	 * 3. 使用贪心策略，优先将回答相同数字的兔子分配到最少的颜色组中
	 * 
	 * 时间复杂度：O(n log n) - 排序的时间复杂度为O(n log n)，遍历数组的时间复杂度为O(n)
	 * 空间复杂度：O(1) - 只使用了常数级别的额外空间
	 * 
	 * 为什么这是最优解？
	 * 1. 贪心策略保证了每组兔子的数量最少
	 * 2. 通过数学方法可以证明这种分配方式能得到全局最优解
	 * 3. 无法在更优的时间复杂度内解决此问题，因为至少需要排序
	 * 
	 * 工程化考虑：
	 * 1. 边界条件处理：空数组、单元素数组
	 * 2. 特殊情况处理：所有兔子回答相同数字的情况
	 * 3. 算法效率：利用排序后相同元素连续的特点优化计算
	 * 
	 * 算法调试技巧：
	 * 1. 可以打印每组兔子的分配情况来观察算法执行过程
	 * 2. 注意处理向上取整的计算方式
	 */

	public static int numRabbits(int[] arr) {
		// a / b 向上取整 -> (a + b - 1) / b
		// 先对数组进行排序，使相同答案的兔子连续排列
		Arrays.sort(arr);
		int n = arr.length;
		int ans = 0;
		
		// 使用双指针遍历数组
		// i指向当前组的第一个元素，j用于遍历
		for (int i = 0, j = 1, x; i < n; j++) {
			// x为当前组兔子的回答数字
			x = arr[i];
			
			// 找到所有回答相同数字的兔子
			while (j < n && x == arr[j]) {
				j++;
			}
			
			// i...j-1 都是同一种答案，当前组有j-i个回答
			// 如果有k只兔子回答数字n，那么至少需要⌈k/(n+1)⌉个颜色组，每组n+1只兔子
			// 向上取整公式：(a + b - 1) / b
			ans += (j - i + x) / (x + 1) * (x + 1);
			
			// 移动到下一组
			i = j;
		}
		
		return ans;
	}

}