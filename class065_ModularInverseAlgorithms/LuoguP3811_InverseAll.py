#!/usr/bin/env python3

"""
洛谷 P3811 【模板】模意义下的乘法逆元
题目链接: https://www.luogu.com.cn/problem/P3811
题目名称: 【模板】乘法逆元
题目来源: 洛谷 (Luogu)
题目难度: 模板题

题目描述:
给定 n, p 求 1∼n 中所有整数在模 p 意义下的乘法逆元。
这里 a 模 p 的乘法逆元定义为 ax ≡ 1 (mod p) 的解。

输入格式:
一行两个正整数 n, p

输出格式:
输出 n 行，第 i 行表示 i 在模 p 下的乘法逆元

数据范围:
1 <= n <= 3 * 10^6
n < p < 20000528
输入保证 p 为质数

解题思路:
使用线性递推方法计算所有逆元，时间复杂度O(n)
递推公式推导：
设 p = k*i + r，其中 k = p // i（整除），r = p % i
则有 k*i + r ≡ 0 (mod p)
两边同时乘以 i^(-1) * r^(-1) 得：
k*r^(-1) + i^(-1) ≡ 0 (mod p)
即 i^(-1) ≡ -k*r^(-1) (mod p)
由于 r < i，所以 r 的逆元在计算 i 的逆元时已经计算过了

算法优势:
1. 时间复杂度为O(n)，比逐个计算逆元更高效
2. 适用于需要批量计算逆元的场景
3. 避免了多次调用扩展欧几里得算法或快速幂

时间复杂度: O(n)
空间复杂度: O(n)

应用场景:
1. 批量计算组合数时预处理阶乘逆元
2. 数论问题中需要大量模逆元计算
3. 密码学中批量生成密钥参数
"""

def main():
    """主函数"""
    # 读取输入
    n, p = map(int, input().split())
    
    # 初始化逆元数组
    inv = [0] * (n + 1)
    
    # 1的逆元是1
    inv[1] = 1
    print(inv[1])
    
    # 线性递推计算2~n的逆元
    # 递推公式: inv[i] = (p - p // i) * inv[p % i] % p
    for i in range(2, n + 1):
        inv[i] = (p - p // i) * inv[p % i] % p
        print(inv[i])


if __name__ == "__main__":
    main()