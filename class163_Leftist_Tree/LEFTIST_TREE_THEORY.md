# 左偏树理论详解

## 1. 左偏树定义

左偏树（Leftist Tree）是一种可合并堆（Mergeable Heap），它不仅满足堆的性质，还满足左偏性质。

### 1.1 基本概念

1. **堆性质**: 父节点的键值大于等于（或小于等于）子节点的键值
2. **左偏性质**: 任意节点的左子节点距离不小于右子节点距离
3. **节点距离**: 从该节点到其子树中最近的外节点（空节点）的边数

### 1.2 外节点定义

外节点是指子节点数小于两个的节点，即：
- 叶子节点（没有子节点）
- 只有一个子节点的节点

### 1.3 距离定义

对于任意节点x，其距离dist(x)定义为：
- 如果x是空节点，则dist(x) = -1
- 否则dist(x) = min(dist(left(x)), dist(right(x))) + 1

但在实际实现中，通常定义空节点的距离为0，非空节点的距离为其右子树距离加1。

## 2. 左偏树性质

### 2.1 核心性质

1. **堆性质**: 保证了树的有序性
2. **左偏性质**: 保证了树的平衡性，右子树的高度不会超过左子树

### 2.2 重要引理

**引理1**: 左偏树中任意节点的距离等于其右子树的距离加1
- 即: dist(x) = dist(right(x)) + 1

**引理2**: 一棵根节点距离为k的左偏树至少有2^k - 1个节点
- 这个性质保证了左偏树的高度是O(log n)

### 2.3 时间复杂度保证

由于左偏树的高度是O(log n)，所以各种操作的时间复杂度都是O(log n)：
- 合并操作: O(log n)
- 插入操作: O(log n)
- 删除操作: O(log n)

## 3. 左偏树操作

### 3.1 合并操作（Merge）

合并是左偏树的核心操作，其他操作都可以通过合并来实现。

#### 算法步骤：

1. 如果其中一个堆为空，返回另一个堆
2. 比较两个堆的根节点，选择较小（或较大）的作为新根
3. 递归合并新根的右子树与另一个堆
4. 如果不满足左偏性质，交换左右子树
5. 更新距离

#### 代码实现（伪代码）：
```
merge(x, y):
    if x is null: return y
    if y is null: return x
    
    if value[x] > value[y]: 
        swap(x, y)
    
    right[x] = merge(right[x], y)
    
    if dist[left[x]] < dist[right[x]]:
        swap(left[x], right[x])
    
    dist[x] = dist[right[x]] + 1
    return x
```

#### 时间复杂度分析：
- 每次递归至少会使一个堆的根节点距离减1
- 根节点距离最多为O(log n)
- 总时间复杂度: O(log n)

### 3.2 插入操作（Insert）

插入操作可以通过合并来实现：
1. 将新元素视为只有一个节点的堆
2. 与原堆合并

#### 时间复杂度：O(log n)

### 3.3 删除根节点（Delete Min/Max）

删除根节点操作也可以通过合并来实现：
1. 合并根节点的左右子树

#### 时间复杂度：O(log n)

### 3.4 删除任意节点

删除任意节点需要更复杂的操作：
1. 合并该节点的左右子树
2. 从该节点开始向上更新距离
3. 如果不满足左偏性质，交换左右子树

#### 时间复杂度：O(log n)

## 4. 左偏树实现细节

### 4.1 节点结构

```
struct Node {
    int value;      // 节点值
    int dist;       // 距离
    Node* left;     // 左子节点
    Node* right;    // 右子节点
}
```

### 4.2 距离维护

在合并操作中需要维护距离：
```java
// 更新距离
node.dist = (node.right == null) ? 0 : node.right.dist + 1;
```

### 4.3 左偏性质维护

在合并操作中需要维护左偏性质：
```java
// 维护左偏性质
if (leftDist < rightDist) {
    // 交换左右子树
    swap(node.left, node.right);
}
```

## 5. 左偏树优化技巧

### 5.1 延迟标记

在某些题目中，需要对整棵树进行操作（如加法、乘法），可以使用延迟标记优化：

```java
struct Node {
    long value;     // 节点值
    int dist;       // 距离
    Node* left;     // 左子节点
    Node* right;    // 右子节点
    long add;       // 加法延迟标记
    long mul;       // 乘法延迟标记
}
```

### 5.2 标记下传

在访问节点前需要下传标记：
```java
void pushDown(Node* node) {
    if (node->mul != 1 || node->add != 0) {
        if (node->left != null) {
            node->left->value = node->left->value * node->mul + node->add;
            node->left->mul *= node->mul;
            node->left->add = node->left->add * node->mul + node->add;
        }
        // 对右子树进行同样操作
        node->mul = 1;
        node->add = 0;
    }
}
```

## 6. 左偏树与其他数据结构的比较

### 6.1 与二叉堆比较

| 特性 | 左偏树 | 二叉堆 |
|------|--------|--------|
| 合并操作 | O(log n) | O(n) |
| 插入操作 | O(log n) | O(log n) |
| 删除操作 | O(log n) | O(log n) |
| 空间复杂度 | O(n) | O(n) |

### 6.2 与斜堆比较

| 特性 | 左偏树 | 斜堆 |
|------|--------|------|
| 理论复杂度 | O(log n) | 均摊O(log n) |
| 实现复杂度 | 中等 | 简单 |
| 实际性能 | 稳定 | 有时更快 |

### 6.3 与配对堆比较

| 特性 | 左偏树 | 配对堆 |
|------|--------|--------|
| 理论复杂度 | O(log n) | 复杂 |
| 实现复杂度 | 中等 | 简单 |
| 实际性能 | 稳定 | 通常更快 |

## 7. 左偏树应用场景

### 7.1 经典应用场景

1. **可合并堆**: 需要频繁合并两个堆的场景
2. **树形DP优化**: 在树形动态规划中维护子树信息
3. **在线算法**: 支持动态插入和删除的算法

### 7.2 典型题目类型

1. **合并集合**: 将两个集合合并并维护最值
2. **删除最值**: 动态删除集合中的最值元素
3. **维护历史信息**: 在数据结构中维护历史操作信息

## 8. 左偏树实现注意事项

### 8.1 边界条件处理

1. **空节点处理**: 正确处理空节点的距离和合并操作
2. **单节点处理**: 单节点的左偏树需要特殊处理
3. **相同值处理**: 在有相同值时需要确定优先级

### 8.2 性能优化

1. **路径压缩**: 在并查集中使用路径压缩
2. **标记清空**: 操作完成后及时清空延迟标记
3. **内存管理**: 及时释放不需要的节点

### 8.3 调试技巧

1. **打印树结构**: 在调试时打印左偏树的结构
2. **验证性质**: 验证合并后的树是否满足左偏性质
3. **测试边界**: 测试空树、单节点等边界情况

## 9. 左偏树扩展

### 9.1 可持久化左偏树

通过可持久化技术，可以实现支持历史版本查询的左偏树。

### 9.2 平衡左偏树

通过引入平衡因子，可以进一步优化左偏树的性能。

### 9.3 多维左偏树

扩展左偏树以支持多维信息的维护。

## 10. 总结

左偏树作为一种高效的可合并堆数据结构，在解决需要频繁合并堆的问题时非常有用。通过掌握其核心操作和优化技巧，可以解决一系列相关问题。在实际应用中，需要注意边界条件的处理和性能优化，以确保算法的正确性和效率。