package class019;

import java.util.Map;
import java.util.HashMap;

// ==================================================================================
// 题目1：子矩阵的最大累加和（填函数风格）
// ==================================================================================
// 题目来源：牛客网 (NowCoder)
// 题目链接：https://www.nowcoder.com/practice/840eee05dccd4ffd8f9433ce8085946b
// 难度等级：中等
// 
// ==================================================================================
// 题目描述
// ==================================================================================
// 给定一个矩阵，求其所有子矩阵中元素和的最大值
// 
// 输入格式：
// - 第一行包含两个整数n和m(1 <= n, m <= 100)，表示矩阵的行数和列数
// - 接下来n行，每行包含m个整数，表示矩阵中的元素(-1000 <= matrix[i][j] <= 1000)
// 
// 输出格式：
// - 一个整数，表示所有子矩阵中元素和的最大值
// 
// 示例1：
// 输入：
// 3 3
// 1 2 3
// -4 5 -6
// 7 8 9
// 输出：
// 27
// 解释：选择整个矩阵，和为1+2+3-4+5-6+7+8+9=27
//
// ==================================================================================
// 核心算法：二维压缩 + Kadane算法（动态规划）
// ==================================================================================
// 
// 【算法思想】
// 本题是经典的「最大子矩阵和」问题，核心思想是：
// 1. 将二维问题降维为一维问题
// 2. 枚举所有可能的上下边界
// 3. 将选定行范围内的每一列压缩为一个值（列和）
// 4. 在压缩后的一维数组上应用Kadane算法求最大子数组和
// 
// 【详细步骤】
// 1. 固定上边界i（第i行）
// 2. 枚举下边界j（第j行，j >= i）
// 3. 对于每个(i,j)组合，计算每一列在[i,j]行范围内的和，得到一维数组arr[]
// 4. 对arr[]应用Kadane算法，求出该行范围内的最大子矩阵和
// 5. 更新全局最大值
// 
// 【Kadane算法核心】
// - 用于求解一维数组的最大子数组和
// - 动态规划思想：当前位置的最大和 = max(当前值, 前面的最大和+当前值)
// - 简化形式：累加当前值，记录最大值，若累加和变负则重置为0
// 
// ==================================================================================
// 时间复杂度分析（详细推导）
// ==================================================================================
// 设矩阵规模为 n×m（n行m列）
// 
// 1. 枚举上边界i：需要n次循环
// 2. 对于每个i，枚举下边界j：需要(n-i)次循环，平均为O(n)
// 3. 对于每个(i,j)，计算压缩数组：需要遍历m列，O(m)
// 4. 对压缩数组应用Kadane算法：O(m)
// 
// 总时间复杂度：
// T(n,m) = Σ(i=0 to n-1) Σ(j=i to n-1) O(m)
//        = Σ(i=0 to n-1) (n-i) × O(m)
//        = O(m) × [n + (n-1) + ... + 1]
//        = O(m) × n(n+1)/2
//        = O(n² × m)
// 
// 当n=m时，时间复杂度为O(n³)
// 
// ==================================================================================
// 空间复杂度分析（详细推导）
// ==================================================================================
// 1. 输入矩阵：O(n×m) - 但这是输入，不计入额外空间
// 2. 辅助数组arr[]：O(m) - 用于存储列压缩结果
// 3. 其他变量：O(1)
// 
// 总空间复杂度：O(m)
// 
// ==================================================================================
// 是否为最优解？
// ==================================================================================
// 【结论】是的，这是最优解！
// 
// 【理论下界分析】
// - 任何正确的算法至少需要读取所有输入：O(n×m)
// - 需要枚举所有可能的子矩阵：共有O(n²×m²)个
// - 但通过巧妙的压缩，本算法将复杂度降至O(n²×m)
// 
// 【是否存在更优解？】
// - 对于一般情况，不存在低于O(n²×m)的算法
// - 已有理论证明：在比较模型下，该问题的下界就是Ω(n²×m)
// - 特殊情况优化：如果矩阵有特殊性质（如全正、单调等），可能有更快算法
// 
// ==================================================================================
// 算法适用场景与题型识别
// ==================================================================================
// 【何时使用此算法】
// 1. 题目要求在二维矩阵中找最大/最小子矩阵和
// 2. 题目涉及矩阵区域求和问题
// 3. 题目可以转化为"固定某些维度，对其他维度降维"的问题
// 
// 【识别关键词】
// - "子矩阵" + "最大和/最小和"
// - "矩阵区域" + "求和"
// - "二维数组" + "连续子数组"
// 
// 【相关题型】
// 1. LeetCode 363. Max Sum of Rectangle No Larger Than K（加了上界限制）
// 2. 最大子矩阵（各种变形）
// 3. 前缀和 + 二维压缩的组合应用
// 
// ==================================================================================
// 边界情况与异常处理
// ==================================================================================
// 【需要考虑的边界情况】
// 1. 空矩阵：n=0 或 m=0 → 应该返回0或报错
// 2. 单元素矩阵：n=1, m=1 → 返回该元素值
// 3. 全负数矩阵：选择最大的单个元素
// 4. 全正数矩阵：选择整个矩阵
// 5. 混合正负数：需要算法正确处理
// 
// 【整数溢出问题】
// - 题目限制：-1000 <= matrix[i][j] <= 1000，n,m <= 100
// - 最坏情况：100×100×1000 = 10,000,000（千万级）
// - int范围：-2^31 ~ 2^31-1（约±21亿）
// - 结论：int类型足够，无需使用long
// 
// ==================================================================================
// 代码可读性优化建议
// ==================================================================================
// 1. 变量命名：使用有意义的名称（如rowStart, rowEnd代替i,j）
// 2. 函数拆分：将Kadane算法独立成函数，提高复用性
// 3. 注释：关键步骤添加注释
// 4. 空行：逻辑块之间添加空行，增强可读性
// 
// ==================================================================================
// 调试技巧
// ==================================================================================
// 【中间过程打印】
// - 打印每次压缩后的数组arr[]
// - 打印每次Kadane算法的结果
// - 打印当前的(i,j)边界
// 
// 【断言验证】
// - 验证压缩数组长度是否为m
// - 验证最大值是否持续更新
// 
// 【小数据测试】
// - 先用2×2矩阵手动计算验证
// - 逐步扩大到3×3, 4×4
// 
// ==================================================================================
// 填函数风格说明
// ==================================================================================
// 【什么是填函数风格？】
// - 在线评测平台提供一个函数签名
// - 你只需要实现函数体内的逻辑
// - 不需要处理输入输出，测试框架会自动调用你的函数
// 
// 【优点】
// - 专注于算法逻辑本身
// - 不用担心IO格式问题
// - 代码简洁，易于测试
// 
// 【缺点】
// - 不适合真实的ACM竞赛（需要自己处理IO）
// - 无法练习IO优化技巧
// 
// ==================================================================================
// 与其他IO风格的对比
// ==================================================================================
// 1. 填函数风格（本文件）：只写核心逻辑，平台提供测试框架
// 2. ACM风格-动态分配（Code02）：每组数据动态创建空间
// 3. ACM风格-静态空间（Code03）：预分配最大空间，复用
// 
// 推荐顺序：先掌握填函数风格 → 再学习ACM风格
// 
// ==================================================================================
// 工程化考量
// ==================================================================================
// 【从代码片段到可复用组件】
// 1. 将maxSumSubmatrix封装为工具类
// 2. 提供多种输入形式（二维数组、List<List<Integer>>等）
// 3. 添加参数校验（null检查、维度检查）
// 
// 【异常抛出】
// - 输入为null → 抛出IllegalArgumentException
// - 维度不一致 → 抛出IllegalArgumentException
// 
// 【单元测试】
// - 测试全正数矩阵
// - 测试全负数矩阵
// - 测试混合矩阵
// - 测试边界情况（1×1, 1×n, n×1）
// 
// 【性能优化】
// - 对于稀疏矩阵，可以使用稀疏表示
// - 对于大规模矩阵，可以考虑并行化（枚举上下边界可以并行）
// 
// ==================================================================================
// 跨语言实现注意事项
// ==================================================================================
// 【Java】
// - 数组越界会抛出ArrayIndexOutOfBoundsException
// - Integer.MIN_VALUE用于初始化最大值
// 
// 【C++】
// - 使用vector<vector<int>>更安全
// - INT_MIN定义在<climits>
// - 注意内存管理（使用vector自动管理）
// 
// 【Python】
// - 使用float('-inf')初始化最大值
// - 列表推导式可以简化代码
// - 注意缩进（Python语法要求）
// 
// ==================================================================================
// 常见错误与避坑指南
// ==================================================================================
// 【错误1】忘记重置辅助数组
// - 问题：每次计算新的(i,j)前，arr[]还保留上次的值
// - 解决：在j循环开始时初始化arr[]为全0
// 
// 【错误2】Kadane算法实现错误
// - 问题：没有正确处理全负数情况
// - 解决：max初始化为Integer.MIN_VALUE，而不是0
// 
// 【错误3】边界条件处理不当
// - 问题：i <= j的边界条件写错
// - 解决：仔细检查循环条件
// 
// ==================================================================================
// 扩展阅读与相关知识
// ==================================================================================
// 【相关算法】
// 1. Kadane算法（一维最大子数组和）
// 2. 前缀和（快速计算区间和）
// 3. 分治法（另一种求最大子数组和的方法）
// 
// 【数学基础】
// 1. 动态规划原理
// 2. 降维思想
// 3. 组合数学（子矩阵个数计算）
// 
// 【机器学习相关】
// - 图像处理中的区域特征提取
// - 卷积神经网络中的池化操作
// - 感兴趣区域(ROI)的特征计算
// 
// ==================================================================================
public class Code01_FillFunction {

	// ==================================================================================
	// 主要函数：子矩阵最大累加和（对外接口）
	// ==================================================================================
	// 这是填函数风格的对外接口，在线评测平台会调用此函数
	//
	// 参数：
	// - mat: 输入矩阵
	// - n: 矩阵行数（在这个版本中，n也表示列数，即方阵）
	//
	// 返回值：
	// - 最大子矩阵和
	public int sumOfSubMatrix(int[][] mat, int n) {
		return maxSumSubmatrix(mat, n, n);
	}

	// ==================================================================================
	// 核心函数：求子矩阵的最大累加和
	// ==================================================================================
	// 算法思路：
	// 1. 枚举所有可能的上边界(i)
	// 2. 对于每个上边界i，枚举下边界(j)，j >= i
	// 3. 将第i行到第j行的每一列相加，形成一个一维数组
	// 4. 对这个一维数组求最大子数组和（Kadane算法）
	// 5. 记录所有情况下的最大值
	//
	// 参数：
	// - mat: 输入矩阵
	// - n: 行数
	// - m: 列数
	//
	// 返回值：
	// - 最大子矩阵和
	//
	// 时间复杂度：O(n² × m)
	// - 外层循环：枚举上边界i，共n次
	// - 中层循环：枚举下边界j，平均n次
	// - 内层循环1：更新压缩数组，m次
	// - 内层循环2：Kadane算法，m次
	// - 总计：n × n × m = O(n²m)
	//
	// 空间复杂度：O(m)
	// - 辅助数组arr[]：O(m)
	// - 其他变量：O(1)
	//
	// 是否为最优解：是的！
	// - 这是经典的最优解，无法在一般情况下继续优化
	// - 已有理论证明：基于比较模型，该问题的下界为Ω(n²m)
	public static int maxSumSubmatrix(int[][] mat, int n, int m) {
		// 初始化最大值为最小整数，以应对全负数矩阵
		int max = Integer.MIN_VALUE;
		
		// 外层循环：枚举上边界（起始行）
		for (int i = 0; i < n; i++) {
			// 辅助数组，用于存储列压缩结果
			// arr[k]表示第k列在[i, j]行范围内的和
			int[] arr = new int[m];
			
			// 中层循环：枚举下边界（结束行）
			for (int j = i; j < n; j++) {
				// 将第j行的每一列加入压缩数组
				// 这样arr[k]就代表[i,j]行范围内第k列的总和
				for (int k = 0; k < m; k++) {
					arr[k] += mat[j][k];
				}
				
				// 对压缩后的一维数组应用Kadane算法
				// 找到当前行范围[i,j]内的最大子矩阵和
				max = Math.max(max, maxSumSubarray(arr, m));
			}
		}
		
		return max;
	}

	// ==================================================================================
	// 辅助函数：求子数组的最大累加和（Kadane算法）
	// ==================================================================================
	// 这是经典的Kadane算法（卡德内算法），用于解决一维数组的最大子数组和问题
	//
	// 【算法原理】
	// 动态规划思想：
	// - 状态定义：cur = 以当前位置结尾的最大子数组和
	// - 状态转移：
	//   - 如果cur > 0，那么将当前元素加入子数组
	//   - 如果cur <= 0，那么从当前元素重新开始
	// - 简化形式：cur = cur < 0 ? arr[i] : cur + arr[i]
	// - 更简化：cur += arr[i]; if(cur < 0) cur = 0;
	//
	// 【算法步骤】
	// 1. 初始化：max = Integer.MIN_VALUE, cur = 0
	// 2. 遍历数组：
	//    a. cur += arr[i] (将当前元素加入)
	//    b. max = Math.max(max, cur) (更新全局最大值)
	//    c. if(cur < 0) cur = 0 (若变负，重新开始)
	// 3. 返回max
	//
	// 【为什么这样做是对的？】
	// - 如果当前cur > 0，说明之前的子数组对后续有贡献，应该保留
	// - 如果cur <= 0，之前的子数组只会拖累，应该从下一个元素重新开始
	// - 这是贪心+动态规划的完美结合
	//
	// 参数：
	// - arr: 一维数组
	// - m: 数组长度
	//
	// 返回值：
	// - 最大子数组和
	//
	// 时间复杂度：O(m)
	// - 只需一次遍历
	//
	// 空间复杂度：O(1)
	// - 只需要两个变量：max和cur
	//
	// 是否为最优解：是的！
	// - O(m)时间复杂度已经是最优（必须遍历每个元素）
	// - O(1)空间复杂度已经是最优（只需常数空间）
	//
	// 【注意事项】
	// 1. 必须将max初始化为Integer.MIN_VALUE，而不是0
	//    - 原因：如果所有元素都是负数，max=0会导致错误
	//    - 例如：[-3, -1, -2]，正确答案是-1，但如果max=0会返回0
	// 2. cur初始化为0是正确的
	//    - 因为第一个元素加入后cur=arr[0]，然后判断是否重置
	// 3. 必须先更新max，再判断cur是否重置
	//    - 如果顺序颠倒，会漏掉某些情况
	public static int maxSumSubarray(int[] arr, int m) {
		// 初始化最大值为最小整数，以处理全负数数组
		int max = Integer.MIN_VALUE;
		
		// cur表示以当前位置结尾的最大子数组和
		int cur = 0;
		
		// 遍历数组
		for (int i = 0; i < m; i++) {
			// 将当前元素加入子数组
			cur += arr[i];
			
			// 更新全局最大值（注意：必须在重置cur之前更新）
			max = Math.max(max, cur);
			
			// 如果当前cur变为负数，从下一个元素重新开始
			// 因为负数只会拖累后续的累加
			cur = cur < 0 ? 0 : cur;
		}
		
		return max;
	}

}

// ==================================================================================
// 题目2：LeetCode 363. 矩形区域不超过 K 的最大数值和
// ==================================================================================
// 题目来源：LeetCode (力扣)
// 题目链接：https://leetcode.com/problems/max-sum-of-rectangle-no-larger-than-k/
// 难度等级：困难
//
// ==================================================================================
// 题目描述
// ==================================================================================
// 给定一个非空二维矩阵 matrix 和一个整数 k，找到这个矩阵中矩形区域的不超过 k 的最大数值和。
//
// 输入：
// - matrix: 二维整数数组
// - k: 整数
//
// 输出：
// - 不超过k的最大矩形区域和
//
// 示例：
// 输入：matrix = [[1,0,1],[0,-2,3]], k = 2
// 输出：2
// 解释：矩形区域 [[0,-2],[1,1]] 的数值和是 2，且 2 是不超过 k 的最大数字（k = 2）。
//
// ==================================================================================
// 核心算法：二维压缩 + Kadane算法 + 前缀和 + TreeSet
// ==================================================================================
// 【算法思想】
// 1. 基础思想仍然是二维压缩，枚举上下边界
// 2. 对于压缩后的一维数组，需要找到子数组和不超过k的最大值
// 3. 使用前缀和 + TreeSet（有序集合）来高效查询
//
// 【时间复杂度】O(n² × m × log m)
// - 枚举上下边界：O(n²)
// - 每次压缩数组：O(m)
// - 使用TreeSet查询：O(m × log m)
//
// 【空间复杂度】O(m)
// - 压缩数组：O(m)
// - TreeSet存储前缀和：O(m)
//
// ==================================================================================
class LeetCode363_MaxSumSubmatrixNoLargerThanK {
    // 主函数：求不超过k的最大矩形和
    public int maxSumSubmatrix(int[][] matrix, int k) {
        if (matrix == null || matrix.length == 0 || matrix[0].length == 0) {
            return 0;
        }
        
        int n = matrix.length;    // 行数
        int m = matrix[0].length; // 列数
        int max = Integer.MIN_VALUE;
        
        // 枚举上边界
        for (int i = 0; i < n; i++) {
            int[] rowSum = new int[m]; // 存储压缩后的行和
            
            // 枚举下边界
            for (int j = i; j < n; j++) {
                // 更新压缩后的行和
                for (int l = 0; l < m; l++) {
                    rowSum[l] += matrix[j][l];
                }
                
                // 在压缩后的一维数组中找不超过k的最大子数组和
                max = Math.max(max, findMaxSubarrayNoLargerThanK(rowSum, k));
                
                // 如果已经找到等于k的解，直接返回
                if (max == k) {
                    return k;
                }
            }
        }
        
        return max;
    }
    
    // 辅助函数：在一维数组中找不超过k的最大子数组和
    private int findMaxSubarrayNoLargerThanK(int[] arr, int k) {
        int maxSum = Integer.MIN_VALUE;
        int prefixSum = 0;
        
        // 使用TreeSet存储前缀和，支持快速查找
        java.util.TreeSet<Integer> prefixSums = new java.util.TreeSet<>();
        prefixSums.add(0); // 初始前缀和为0
        
        for (int num : arr) {
            prefixSum += num;
            
            // 寻找prefixSum - x <= k → x >= prefixSum - k
            // 寻找最小的x >= (prefixSum - k)
            Integer ceiling = prefixSums.ceiling(prefixSum - k);
            if (ceiling != null) {
                maxSum = Math.max(maxSum, prefixSum - ceiling);
            }
            
            // 将当前前缀和加入集合
            prefixSums.add(prefixSum);
        }
        
        return maxSum;
    }
}

// ==================================================================================
// 题目3：LeetCode 1074. 元素和为目标值的子矩阵数量
// ==================================================================================
// 题目来源：LeetCode (力扣)
// 题目链接：https://leetcode.com/problems/number-of-submatrices-that-sum-to-target/
// 难度等级：困难
//
// ==================================================================================
// 题目描述
// ==================================================================================
// 给出矩阵 matrix 和目标值 target，返回元素总和等于目标值的非空子矩阵的数量。
// 子矩阵 x1, y1, x2, y2 是满足 x1 ≤ x ≤ x2 且 y1 ≤ y ≤ y2 的所有单元 (x, y) 的集合。
// 如果 (x1, y1, x2, y2) 和 (x1', y1', x2', y2') 两个子矩阵中部分坐标不同（如：x1 != x1'），那么它们被视为不同的子矩阵。
//
// 输入：
// - matrix: 二维整数数组
// - target: 整数
//
// 输出：
// - 元素和等于target的子矩阵数量
//
// 示例：
// 输入：matrix = [[0,1,0],[1,1,1],[0,1,0]], target = 0
// 输出：4
// 解释：四个只包含 0 的 1x1 子矩阵和两个 1x3 子矩阵，以及两个 3x1 子矩阵。
//
// ==================================================================================
// 核心算法：二维压缩 + 前缀和 + 哈希表
// ==================================================================================
// 【算法思想】
// 1. 基础思想仍然是二维压缩，枚举上下边界
// 2. 对于压缩后的一维数组，计算前缀和
// 3. 使用哈希表统计前缀和出现的次数，快速查找符合条件的子数组数量
//
// 【时间复杂度】O(n² × m)
// - 枚举上下边界：O(n²)
// - 每次压缩数组和哈希表查询：O(m)
//
// 【空间复杂度】O(m)
// - 压缩数组：O(m)
// - 哈希表：O(m)
//
// ==================================================================================
class LeetCode1074_SubmatrixSumEqualsTarget {
    // 主函数：计算和为target的子矩阵数量
    public int numSubmatrixSumTarget(int[][] matrix, int target) {
        if (matrix == null || matrix.length == 0 || matrix[0].length == 0) {
            return 0;
        }
        
        int n = matrix.length;    // 行数
        int m = matrix[0].length; // 列数
        int count = 0;
        
        // 枚举上边界
        for (int i = 0; i < n; i++) {
            int[] rowSum = new int[m]; // 存储压缩后的行和
            
            // 枚举下边界
            for (int j = i; j < n; j++) {
                // 更新压缩后的行和
                for (int l = 0; l < m; l++) {
                    rowSum[l] += matrix[j][l];
                }
                
                // 在压缩后的一维数组中计算和为target的子数组数量
                count += findSubarraySum(rowSum, target);
            }
        }
        
        return count;
    }
    
    // 辅助函数：计算一维数组中和为target的子数组数量
    private int findSubarraySum(int[] arr, int target) {
        java.util.HashMap<Integer, Integer> prefixSumCount = new java.util.HashMap<>();
        prefixSumCount.put(0, 1); // 初始前缀和为0，出现一次
        
        int prefixSum = 0;
        int count = 0;
        
        for (int num : arr) {
            prefixSum += num;
            
            // 查找是否存在前缀和为 (prefixSum - target)
            if (prefixSumCount.containsKey(prefixSum - target)) {
                count += prefixSumCount.get(prefixSum - target);
            }
            
            // 更新当前前缀和的出现次数
            prefixSumCount.put(prefixSum, prefixSumCount.getOrDefault(prefixSum, 0) + 1);
        }
        
        return count;
    }
}

// ==================================================================================
// 题目4：洛谷 P1719 最大加权矩形
// ==================================================================================
// 题目来源：洛谷 (Luogu)
// 题目链接：https://www.luogu.com.cn/problem/P1719
// 难度等级：普及+/提高
//
// ==================================================================================
// 题目描述
// ==================================================================================
// 为了更好地备战NOIP，电脑组的几个女孩子YjQ和Hgq正在努力训练。他们各自编写了一个程序，现在需要测试哪一个程序的效率更高。
// 测试内容是，给定一个包含N×N个元素的矩阵，每个元素有一个权值（可能为负数），找出一个子矩阵，使得这个子矩阵内的所有元素的和最大。
//
// 输入：
// - 第一行包含一个整数N (1 ≤ N ≤ 120)
// - 接下来N行，每行包含N个整数，表示矩阵中的元素
//
// 输出：
// - 一个整数，表示最大子矩阵和
//
// ==================================================================================
// 核心算法：二维压缩 + Kadane算法
// ==================================================================================
// 【算法思想】
// 与题目1完全相同，标准的最大子矩阵和问题
// 适用于ACM静态空间模式
//
// 【时间复杂度】O(n³)
// 【空间复杂度】O(n)
//
// ==================================================================================
class LuoguP1719_MaxWeightRectangle {
    private static final int MAXN = 125; // 题目限制N≤120
    private static int[][] mat = new int[MAXN][MAXN];
    private static int[] arr = new int[MAXN];
    private static int n;
    
    public static int solve() {
        int max = Integer.MIN_VALUE;
        
        // 枚举上边界
        for (int i = 0; i < n; i++) {
            // 重置辅助数组
            java.util.Arrays.fill(arr, 0, n, 0);
            
            // 枚举下边界
            for (int j = i; j < n; j++) {
                // 压缩列
                for (int k = 0; k < n; k++) {
                    arr[k] += mat[j][k];
                }
                
                // 应用Kadane算法
                max = Math.max(max, kadane());
            }
        }
        
        return max;
    }
    
    private static int kadane() {
        int max = Integer.MIN_VALUE;
        int cur = 0;
        
        for (int i = 0; i < n; i++) {
            cur += arr[i];
            max = Math.max(max, cur);
            cur = cur < 0 ? 0 : cur;
        }
        
        return max;
    }
}

// ==================================================================================
// 题目5：牛客网 BM97 子矩阵最大和
// ==================================================================================
// 题目来源：牛客网 (NowCoder)
// 题目链接：https://www.nowcoder.com/practice/840eee05dccd4ffd8f9433ce8085946b
// 难度等级：中等
//
// ==================================================================================
// 题目描述
// ==================================================================================
// 给定一个n*m的矩阵，求其最大子矩阵和
//
// 输入：
// - 输入为一个n*m的二维数组
//
// 输出：
// - 输出最大子矩阵和
//
// ==================================================================================
// 核心算法：二维压缩 + Kadane算法
// ==================================================================================
// 与题目1完全相同，是最大子矩阵和的标准题目
//
// ==================================================================================
class NowCoder_BM97_MaxSumSubmatrix {
    public int maxsumofSubmatrix(int[][] matrix) {
        if (matrix == null || matrix.length == 0 || matrix[0].length == 0) {
            return 0;
        }
        
        int n = matrix.length;
        int m = matrix[0].length;
        int max = Integer.MIN_VALUE;
        
        for (int i = 0; i < n; i++) {
            int[] arr = new int[m];
            for (int j = i; j < n; j++) {
                for (int k = 0; k < m; k++) {
                    arr[k] += matrix[j][k];
                }
                max = Math.max(max, maxSubarray(arr, m));
            }
        }
        
        return max;
    }
    
    private int maxSubarray(int[] arr, int m) {
        int max = Integer.MIN_VALUE;
        int cur = 0;
        
        for (int i = 0; i < m; i++) {
            cur += arr[i];
            max = Math.max(max, cur);
            cur = cur < 0 ? 0 : cur;
        }
        
        return max;
    }
}

// ==================================================================================
// 题目6：CodeChef - MAXREC
// ==================================================================================
// 题目来源：CodeChef
// 题目链接：https://www.codechef.com/problems/MAXREC
// 难度等级：中等
//
// ==================================================================================
// 题目描述
// ==================================================================================
// 给定一个N×M的整数矩阵，找出一个子矩阵，使得其中元素的总和最大。
//
// 输入格式：
// - 第一行包含两个整数N和M
// - 接下来N行，每行包含M个整数
//
// 输出格式：
// - 最大子矩阵和
//
// ==================================================================================
// 核心算法：二维压缩 + Kadane算法
// ==================================================================================
// 与前面的题目相同，标准的最大子矩阵和问题
//
// ==================================================================================
class CodeChef_MAXREC {
    public static int solve(int[][] matrix, int n, int m) {
        int max = Integer.MIN_VALUE;
        
        for (int i = 0; i < n; i++) {
            int[] arr = new int[m];
            for (int j = i; j < n; j++) {
                for (int k = 0; k < m; k++) {
                    arr[k] += matrix[j][k];
                }
                max = Math.max(max, kadane(arr, m));
            }
        }
        
        return max;
    }
    
    private static int kadane(int[] arr, int m) {
        int max = Integer.MIN_VALUE;
        int cur = 0;
        
        for (int i = 0; i < m; i++) {
            cur += arr[i];
            max = Math.max(max, cur);
            cur = cur < 0 ? 0 : cur;
        }
        
        return max;
    }
}

// ==================================================================================
// 题目7：SPOJ - MAXSUBM
// ==================================================================================
// 题目来源：SPOJ
// 题目链接：https://www.spoj.com/problems/MAXSUBM/
// 难度等级：中等
//
// ==================================================================================
// 题目描述
// ==================================================================================
// 给定一个二维数组，求其子矩阵的最大和。
//
// 输入格式：
// - 第一行包含两个整数R和C（行数和列数）
// - 接下来R行，每行包含C个整数
//
// 输出格式：
// - 最大子矩阵和
//
// ==================================================================================
// 核心算法：二维压缩 + Kadane算法
// ==================================================================================
// 与前面的题目相同，标准的最大子矩阵和问题
//
// ==================================================================================
class SPOJ_MAXSUBM {
    public static int solve(int[][] matrix, int r, int c) {
        int max = Integer.MIN_VALUE;
        
        for (int i = 0; i < r; i++) {
            int[] arr = new int[c];
            for (int j = i; j < r; j++) {
                for (int k = 0; k < c; k++) {
                    arr[k] += matrix[j][k];
                }
                max = Math.max(max, kadane(arr, c));
            }
        }
        
        return max;
    }
    
    private static int kadane(int[] arr, int c) {
        int max = Integer.MIN_VALUE;
        int cur = 0;
        
        for (int i = 0; i < c; i++) {
            cur += arr[i];
            max = Math.max(max, cur);
            cur = cur < 0 ? 0 : cur;
        }
        
        return max;
    }
}

// ==================================================================================
// 题目8：LeetCode 152. 乘积最大子数组
// ==================================================================================
// 题目来源：LeetCode (力扣)
// 题目链接：https://leetcode.com/problems/maximum-product-subarray/
// 难度等级：中等
//
// ==================================================================================
// 题目描述
// ==================================================================================
// 给你一个整数数组 nums ，请你找出数组中乘积最大的非空连续子数组（该子数组中至少包含一个数字），
// 并返回该子数组所对应的乘积。
//
// 测试用例的答案是一个 32-位 整数。
//
// 示例 1:
// 输入: nums = [2,3,-2,4]
// 输出: 6
// 解释: 子数组 [2,3] 有最大乘积 6。
//
// 示例 2:
// 输入: nums = [-2,0,-1]
// 输出: 0
// 解释: 结果不能为 2, 因为 [-2,-1] 不是子数组。
//
// ==================================================================================
// 核心算法：动态规划（Kadane算法变种）
// ==================================================================================
// 【算法思想】
// 由于乘积可能由负数×负数得到正数，因此需要同时维护最大值和最小值
// 1. 维护三个变量：maxProd（全局最大值）、curMax（当前最大值）、curMin（当前最小值）
// 2. 对于每个元素，计算三种可能：当前元素本身、当前元素×curMax、当前元素×curMin
// 3. 更新curMax和curMin，然后更新全局最大值
//
// 【时间复杂度】O(n)
// - 只需一次遍历数组
//
// 【空间复杂度】O(1)
// - 只需要常数空间存储变量
//
// 【是否为最优解】是的！
// - 这是该问题的最优解法，无法继续优化
// ==================================================================================
class LeetCode152_MaximumProductSubarray {
    // 主函数：求乘积最大子数组
    public int maxProduct(int[] nums) {
        if (nums == null || nums.length == 0) {
            return 0;
        }
        
        int maxProd = nums[0];    // 全局最大值
        int curMax = nums[0];     // 当前最大值
        int curMin = nums[0];     // 当前最小值
        
        for (int i = 1; i < nums.length; i++) {
            // 由于负数×负数可能得到正数，需要同时考虑三种情况
            int tempMax = curMax;
            curMax = Math.max(Math.max(nums[i], nums[i] * curMax), nums[i] * curMin);
            curMin = Math.min(Math.min(nums[i], nums[i] * tempMax), nums[i] * curMin);
            
            maxProd = Math.max(maxProd, curMax);
        }
        
        return maxProd;
    }
}

// ==================================================================================
// 题目9：LeetCode 918. 环形子数组的最大和
// ==================================================================================
// 题目来源：LeetCode (力扣)
// 题目链接：https://leetcode.com/problems/maximum-sum-circular-subarray/
// 难度等级：中等
//
// ==================================================================================
// 题目描述
// ==================================================================================
// 给定一个由整数数组组成的环形数组 nums，请返回该环形数组中的最大子数组和。
//
// 环形数组意味着数组的末端将会与开头相连呈环状。
// 形式上，nums[i] 的下一个元素是 nums[(i + 1) % n]，nums[i] 的前一个元素是 nums[(i - 1 + n) % n]。
//
// 子数组最多只能包含固定缓冲区 nums 中的每个元素一次。
// 形式上，对于子数组 nums[i], nums[i+1], ..., nums[j]，不存在 i <= k1, k2 <= j 其中 k1 % n == k2 % n。
//
// 示例 1：
// 输入：nums = [1,-2,3,-2]
// 输出：3
// 解释：从子数组 [3] 得到最大和 3
//
// 示例 2：
// 输入：nums = [5,-3,5]
// 输出：10
// 解释：从子数组 [5,5] 得到最大和 5 + 5 = 10
//
// ==================================================================================
// 核心算法：Kadane算法 + 环形数组处理技巧
// ==================================================================================
// 【算法思想】
// 环形数组的最大子数组和有两种情况：
// 1. 情况一：最大子数组在数组中间（非环形）→ 标准Kadane算法
// 2. 情况二：最大子数组跨越数组首尾（环形）→ 总和 - 最小子数组和
//
// 特殊情况：如果数组全为负数，则直接返回最大元素
//
// 【时间复杂度】O(n)
// - 需要两次遍历数组
//
// 【空间复杂度】O(1)
// - 只需要常数空间
//
// 【是否为最优解】是的！
// - 这是环形数组最大子数组和的最优解法
// ==================================================================================
class LeetCode918_MaximumSumCircularSubarray {
    // 主函数：求环形数组的最大子数组和
    public int maxSubarraySumCircular(int[] nums) {
        if (nums == null || nums.length == 0) {
            return 0;
        }
        
        int n = nums.length;
        int maxKadane = kadane(nums); // 情况一：标准最大子数组和
        
        // 如果最大子数组和为负数，说明整个数组都是负数
        if (maxKadane < 0) {
            return maxKadane;
        }
        
        // 计算数组总和
        int totalSum = 0;
        for (int num : nums) {
            totalSum += num;
        }
        
        // 情况二：环形情况的最大和 = 总和 - 最小子数组和
        int minKadane = minKadane(nums);
        int maxCircular = totalSum - minKadane;
        
        // 返回两种情况的最大值
        return Math.max(maxKadane, maxCircular);
    }
    
    // 标准Kadane算法：求最大子数组和
    private int kadane(int[] nums) {
        int max = Integer.MIN_VALUE;
        int cur = 0;
        
        for (int num : nums) {
            cur += num;
            max = Math.max(max, cur);
            cur = cur < 0 ? 0 : cur;
        }
        
        return max;
    }
    
    // 求最小子数组和（Kadane算法变种）
    private int minKadane(int[] nums) {
        int min = Integer.MAX_VALUE;
        int cur = 0;
        
        for (int num : nums) {
            cur += num;
            min = Math.min(min, cur);
            cur = cur > 0 ? 0 : cur;
        }
        
        return min;
    }
}

// ==================================================================================
// 题目10：HDU 1559 - 最大子矩阵（二维前缀和版本）
// ==================================================================================
// 题目来源：杭电OJ (HDU)
// 题目链接：http://acm.hdu.edu.cn/showproblem.php?pid=1559
// 难度等级：中等
//
// ==================================================================================
// 题目描述
// ==================================================================================
// 给定一个大小为N×M的矩阵，以及两个整数x和y，要求找出一个大小为x×y的子矩阵，使得该子矩阵的元素和最大。
//
// 输入格式：
// - 第一行：测试用例数T
// - 每个测试用例：
//   * 第一行：四个整数N, M, x, y
//   * 接下来N行：每行M个整数
//
// 输出格式：
// - 对于每个测试用例，输出最大子矩阵和
//
// ==================================================================================
// 核心算法：二维前缀和 + 滑动窗口
// ==================================================================================
// 【算法思想】
// 1. 计算二维前缀和数组prefixSum[i][j]，表示从(0,0)到(i,j)的矩形区域和
// 2. 对于每个可能的子矩阵起始位置(i,j)，计算大小为x×y的子矩阵和
// 3. 使用前缀和公式：sum = prefixSum[i+x][j+y] - prefixSum[i][j+y] - prefixSum[i+x][j] + prefixSum[i][j]
// 4. 记录所有子矩阵中的最大值
//
// 【时间复杂度】O(N×M)
// - 需要计算前缀和：O(N×M)
// - 需要遍历所有可能的子矩阵：O((N-x+1)×(M-y+1)) ≈ O(N×M)
//
// 【空间复杂度】O(N×M)
// - 需要存储前缀和数组
//
// 【是否为最优解】是的！
// - 对于固定大小的子矩阵问题，这是最优解法
// ==================================================================================
class HDU1559_MaximumSubmatrixFixedSize {
    // 主函数：求固定大小的最大子矩阵和
    public int maxSumSubmatrixFixedSize(int[][] matrix, int x, int y) {
        if (matrix == null || matrix.length == 0 || matrix[0].length == 0) {
            return 0;
        }
        
        int n = matrix.length;
        int m = matrix[0].length;
        
        // 计算二维前缀和
        int[][] prefixSum = new int[n + 1][m + 1];
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= m; j++) {
                prefixSum[i][j] = matrix[i - 1][j - 1] 
                    + prefixSum[i - 1][j] 
                    + prefixSum[i][j - 1] 
                    - prefixSum[i - 1][j - 1];
            }
        }
        
        int maxSum = Integer.MIN_VALUE;
        
        // 遍历所有可能的x×y子矩阵
        for (int i = 0; i <= n - x; i++) {
            for (int j = 0; j <= m - y; j++) {
                // 计算子矩阵和：使用前缀和公式
                int sum = prefixSum[i + x][j + y] 
                    - prefixSum[i][j + y] 
                    - prefixSum[i + x][j] 
                    + prefixSum[i][j];
                
                maxSum = Math.max(maxSum, sum);
            }
        }
        
        return maxSum;
    }
}

// ==================================================================================
// 题目11：POJ 2479 - Maximum sum（最大两段子段和）
// ==================================================================================
// 题目来源：POJ (北大OJ)
// 题目链接：http://poj.org/problem?id=2479
// 难度等级：中等
//
// ==================================================================================
// 题目描述
// ==================================================================================
// 给定一个整数数组，将其分成两个不相交的连续子数组，使得两个子数组的和最大。
// 注意：两个子数组不能重叠，但可以相邻。
//
// 输入格式：
// - 第一行：测试用例数T
// - 每个测试用例：
//   * 第一行：整数n
//   * 第二行：n个整数
//
// 输出格式：
// - 对于每个测试用例，输出最大两段子段和
//
// ==================================================================================
// 核心算法：前后缀分解 + Kadane算法
// ==================================================================================
// 【算法思想】
// 1. 从左到右计算每个位置的最大前缀和（Kadane算法）
// 2. 从右到左计算每个位置的最大后缀和（Kadane算法）
// 3. 对于每个分割点i，计算maxPrefix[i] + maxSuffix[i+1]的最大值
//
// 【时间复杂度】O(n)
// - 需要三次遍历数组
//
// 【空间复杂度】O(n)
// - 需要存储前缀最大值和后缀最大值数组
//
// 【是否为最优解】是的！
// - 这是最大两段子段和问题的最优解法
// ==================================================================================
class POJ2479_MaximumTwoSegmentSum {
    // 主函数：求最大两段子段和
    public int maxTwoSegmentSum(int[] nums) {
        if (nums == null || nums.length < 2) {
            return 0;
        }
        
        int n = nums.length;
        
        // 从左到右计算最大前缀和
        int[] maxPrefix = new int[n];
        int cur = 0;
        int max = Integer.MIN_VALUE;
        
        for (int i = 0; i < n; i++) {
            cur += nums[i];
            max = Math.max(max, cur);
            maxPrefix[i] = max;
            cur = cur < 0 ? 0 : cur;
        }
        
        // 从右到左计算最大后缀和
        int[] maxSuffix = new int[n];
        cur = 0;
        max = Integer.MIN_VALUE;
        
        for (int i = n - 1; i >= 0; i--) {
            cur += nums[i];
            max = Math.max(max, cur);
            maxSuffix[i] = max;
            cur = cur < 0 ? 0 : cur;
        }
        
        // 计算最大两段和
        int result = Integer.MIN_VALUE;
        for (int i = 0; i < n - 1; i++) {
            result = Math.max(result, maxPrefix[i] + maxSuffix[i + 1]);
        }
        
        return result;
    }
}

// ==================================================================================
// 题目12：Codeforces 977F - Consecutive Subsequence（最长连续递增子序列）
// ==================================================================================
// 题目来源：Codeforces
// 题目链接：https://codeforces.com/problemset/problem/977/F
// 难度等级：中等
//
// ==================================================================================
// 题目描述
// ==================================================================================
// 给定一个整数数组，找出最长的连续递增子序列（每个元素比前一个元素大1）。
// 输出该子序列的长度和起始位置。
//
// 示例：
// 输入：[3, 3, 4, 7, 5, 6, 8]
// 输出：4（子序列[3,4,5,6]或[5,6,7,8]）
//
// ==================================================================================
// 核心算法：动态规划 + 哈希表
// ==================================================================================
// 【算法思想】
// 1. 使用哈希表记录每个数字对应的最长连续序列长度
// 2. 对于每个数字num，检查num-1是否在哈希表中
// 3. 如果存在，则dp[num] = dp[num-1] + 1
// 4. 否则，dp[num] = 1
// 5. 记录最大长度和对应的数字
//
// 【时间复杂度】O(n)
// - 只需一次遍历数组
//
// 【空间复杂度】O(n)
// - 需要哈希表存储状态
//
// 【是否为最优解】是的！
// - 这是最长连续递增子序列的最优解法
// ==================================================================================
class Codeforces977F_ConsecutiveSubsequence {
    // 主函数：求最长连续递增子序列
    public int[] findLongestConsecutiveSubsequence(int[] nums) {
        if (nums == null || nums.length == 0) {
            return new int[0];
        }
        
        Map<Integer, Integer> dp = new HashMap<>();
        int maxLength = 0;
        int endValue = 0;
        
        for (int num : nums) {
            // 如果num-1存在，则当前序列长度 = dp[num-1] + 1
            // 否则当前序列长度 = 1
            dp.put(num, dp.getOrDefault(num - 1, 0) + 1);
            
            // 更新最大长度
            if (dp.get(num) > maxLength) {
                maxLength = dp.get(num);
                endValue = num;
            }
        }
        
        // 重构序列
        int[] result = new int[maxLength];
        int current = endValue;
        for (int i = maxLength - 1; i >= 0; i--) {
            result[i] = current;
            current--;
        }
        
        return result;
    }
    
    // 简化版本：只返回长度
    public int findLongestConsecutiveSubsequenceLength(int[] nums) {
        if (nums == null || nums.length == 0) {
            return 0;
        }
        
        Map<Integer, Integer> dp = new HashMap<>();
        int maxLength = 0;
        
        for (int num : nums) {
            dp.put(num, dp.getOrDefault(num - 1, 0) + 1);
            maxLength = Math.max(maxLength, dp.get(num));
        }
        
        return maxLength;
    }
}




