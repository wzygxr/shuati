# 树链剖分异常处理与性能优化

## 一、异常处理机制

### 1. 输入验证异常

#### 节点编号验证
```java
/**
 * 验证节点编号是否有效
 * @param u 节点编号
 * @throws IllegalArgumentException 如果节点编号无效
 */
private void validateNode(int u) {
    if (u < 1 || u > n) {
        throw new IllegalArgumentException(
            String.format("Invalid node id: %d, valid range: [1, %d]", u, n)
        );
    }
}

/**
 * 验证边权范围
 * @param w 边权值
 * @throws IllegalArgumentException 如果边权超出范围
 */
private void validateWeight(int w) {
    if (w < MIN_WEIGHT || w > MAX_WEIGHT) {
        throw new IllegalArgumentException(
            String.format("Weight %d out of range [%d, %d]", w, MIN_WEIGHT, MAX_WEIGHT)
        );
    }
}
```

#### 操作参数验证
```java
/**
 * 验证路径操作参数
 */
private void validatePathOperation(int u, int v, int val) {
    validateNode(u);
    validateNode(v);
    
    if (u == v) {
        logger.warn("Path operation on same node: {} -> {}", u, v);
    }
    
    // 验证操作值范围
    if (val < MIN_OPERATION_VALUE || val > MAX_OPERATION_VALUE) {
        throw new IllegalArgumentException("Operation value out of range");
    }
}
```

### 2. 边界情况处理

#### 空树处理
```java
public void initialize(Tree tree) {
    if (tree == null || tree.isEmpty()) {
        logger.warn("Initializing HLD with empty tree");
        this.n = 0;
        return;
    }
    
    this.n = tree.getNodeCount();
    if (n == 0) {
        logger.warn("Tree contains 0 nodes");
        return;
    }
    
    // 正常初始化流程
    initArrays();
    dfs1(tree.getRoot(), 0);
    dfs2(tree.getRoot(), tree.getRoot());
    buildSegmentTree();
}
```

#### 单节点树处理
```java
public int queryPath(int u, int v) {
    if (n == 0) {
        throw new IllegalStateException("HLD not initialized or tree is empty");
    }
    
    if (n == 1) {
        // 单节点树，直接返回根节点值
        validateNode(u);
        validateNode(v);
        if (u != 1 || v != 1) {
            throw new IllegalArgumentException("Invalid nodes for single-node tree");
        }
        return queryPoint(1);
    }
    
    // 正常路径查询逻辑
    return doQueryPath(u, v);
}
```

### 3. 内存异常处理

#### 数组越界防护
```java
/**
 * 安全的数组访问
 */
private int safeArrayAccess(int[] arr, int index, String arrayName) {
    if (index < 0 || index >= arr.length) {
        throw new ArrayIndexOutOfBoundsException(
            String.format("Index %d out of bounds for %s (length: %d)", 
                index, arrayName, arr.length)
        );
    }
    return arr[index];
}

/**
 * 安全的线段树区间验证
 */
private void validateSegmentTreeRange(int l, int r, int segL, int segR) {
    if (l < segL || r > segR || l > r) {
        throw new IllegalArgumentException(
            String.format("Invalid segment tree range [%d, %d] for segment [%d, %d]", 
                l, r, segL, segR)
        );
    }
}
```

## 二、性能优化策略

### 1. 内存优化

#### 数组布局优化
```java
// 优化前：分散的数组声明
int[] parent = new int[n + 1];
int[] depth = new int[n + 1];
int[] size = new int[n + 1];

// 优化后：使用二维数组提高缓存局部性
int[][] hldArrays = new int[6][n + 1];
// hldArrays[0] = parent
// hldArrays[1] = depth  
// hldArrays[2] = size
// hldArrays[3] = heavy
// hldArrays[4] = head
// hldArrays[5] = pos
```

#### 对象池技术
```java
/**
 * 边对象池，避免频繁创建对象
 */
public class EdgePool {
    private static final int POOL_SIZE = 10000;
    private static final Stack<Edge> pool = new Stack<>();
    
    public static Edge getEdge(int v, int w) {
        if (!pool.isEmpty()) {
            Edge edge = pool.pop();
            edge.v = v;
            edge.w = w;
            return edge;
        }
        return new Edge(v, w);
    }
    
    public static void returnEdge(Edge edge) {
        if (pool.size() < POOL_SIZE) {
            pool.push(edge);
        }
    }
}
```

### 2. 算法优化

#### 位运算优化
```java
// 除法优化
int mid = (l + r) >> 1;  // 替代 (l + r) / 2

// 模运算优化（当模数是2的幂次时）
int mod = 1 << 20;  // 2^20
int result = (a + b) & (mod - 1);  // 替代 (a + b) % mod

// 循环展开
for (int i = 0; i < n; i += 4) {
    // 处理i, i+1, i+2, i+3
    process(arr[i]);
    process(arr[i + 1]);
    process(arr[i + 2]);
    process(arr[i + 3]);
}
```

#### 缓存友好的数据访问
```java
/**
 * 预计算重链信息，提高缓存命中率
 */
public class CacheFriendlyHLD {
    private int[] chainStart;    // 每条重链的起始位置
    private int[] chainLength;   // 每条重链的长度
    private int[] chainData;     // 按重链顺序存储的数据
    
    public void optimizeForCache() {
        // 按重链顺序重新组织数据
        List<List<Integer>> chains = extractChains();
        
        int pos = 0;
        chainStart = new int[chains.size()];
        chainLength = new int[chains.size()];
        chainData = new int[n];
        
        for (int i = 0; i < chains.size(); i++) {
            chainStart[i] = pos;
            chainLength[i] = chains.get(i).size();
            
            for (int node : chains.get(i)) {
                chainData[pos++] = node;
            }
        }
    }
}
```

### 3. I/O优化

#### 快速输入输出
```java
/**
 * 快速输入类，优化大规模数据读取
 */
public class FastIO {
    private BufferedReader br;
    private StringTokenizer st;
    
    public FastIO() {
        br = new BufferedReader(new InputStreamReader(System.in));
    }
    
    public int nextInt() throws IOException {
        while (st == null || !st.hasMoreTokens()) {
            st = new StringTokenizer(br.readLine());
        }
        return Integer.parseInt(st.nextToken());
    }
    
    public void println(int x) {
        // 使用StringBuilder减少系统调用
        sb.append(x).append('\n');
        if (sb.length() > BUFFER_SIZE) {
            flush();
        }
    }
    
    private void flush() {
        System.out.print(sb);
        sb.setLength(0);
    }
}
```

### 4. 并行化优化

#### 多线程预处理
```java
/**
 * 并行化树链剖分预处理
 */
public class ParallelHLD {
    private ExecutorService executor = Executors.newFixedThreadPool(
        Runtime.getRuntime().availableProcessors()
    );
    
    public void parallelPreprocess() {
        // 并行计算子树大小
        List<Future<?>> futures = new ArrayList<>();
        
        for (int i = 1; i <= n; i += BATCH_SIZE) {
            final int start = i;
            final int end = Math.min(i + BATCH_SIZE - 1, n);
            
            futures.add(executor.submit(() -> {
                for (int u = start; u <= end; u++) {
                    computeSubtreeSize(u);
                }
            }));
        }
        
        // 等待所有任务完成
        for (Future<?> future : futures) {
            try {
                future.get();
            } catch (Exception e) {
                logger.error("Parallel computation failed", e);
            }
        }
    }
}
```

## 三、监控与调试

### 1. 性能监控

#### 运行时统计
```java
public class HLDMetrics {
    private long preprocessTime;
    private long totalQueryTime;
    private long totalUpdateTime;
    private int queryCount;
    private int updateCount;
    
    public void recordQuery(long startTime) {
        long duration = System.nanoTime() - startTime;
        totalQueryTime += duration;
        queryCount++;
        
        if (duration > SLOW_QUERY_THRESHOLD) {
            logger.warn("Slow query detected: {} ns", duration);
        }
    }
    
    public double getAverageQueryTime() {
        return queryCount == 0 ? 0 : (double) totalQueryTime / queryCount;
    }
}
```

#### 内存使用监控
```java
public class MemoryMonitor {
    public void logMemoryUsage() {
        Runtime runtime = Runtime.getRuntime();
        long usedMemory = runtime.totalMemory() - runtime.freeMemory();
        long maxMemory = runtime.maxMemory();
        
        logger.info("Memory usage: {}/{} MB ({}%)", 
            usedMemory / (1024 * 1024),
            maxMemory / (1024 * 1024),
            (usedMemory * 100) / maxMemory);
    }
}
```

### 2. 调试工具

#### 可视化调试
```java
/**
 * 树结构可视化，用于调试
 */
public class TreeVisualizer {
    public void visualizeTree() {
        StringBuilder sb = new StringBuilder();
        sb.append("Tree Structure:\n");
        
        for (int u = 1; u <= n; u++) {
            sb.append(String.format("Node %d: parent=%d, depth=%d, size=%d, head=%d, pos=%d\n",
                u, parent[u], depth[u], size[u], head[u], pos[u]));
        }
        
        logger.debug(sb.toString());
    }
    
    public void visualizeChains() {
        Map<Integer, List<Integer>> chains = new HashMap<>();
        
        for (int u = 1; u <= n; u++) {
            chains.computeIfAbsent(head[u], k -> new ArrayList<>()).add(u);
        }
        
        for (List<Integer> chain : chains.values()) {
            logger.debug("Chain {}: {}", chain.get(0), chain);
        }
    }
}
```

## 四、最佳实践建议

### 1. 代码组织
- 将树链剖分核心逻辑封装成独立的类
- 提供清晰的API接口和详细的文档
- 实现配置化的参数调整

### 2. 测试策略
- 编写全面的单元测试覆盖各种边界情况
- 进行压力测试验证大规模数据下的性能
- 使用性能分析工具定位瓶颈

### 3. 部署考虑
- 根据目标环境调整内存分配策略
- 提供多种实现版本适应不同需求
- 实现优雅的降级机制

通过以上异常处理和性能优化策略，可以显著提升树链剖分算法的稳定性和效率，使其更适合在实际生产环境中使用。