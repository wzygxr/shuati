# 树链剖分工程化实践指南

## 一、代码架构设计

### 1. 模块化设计
```java
// 树链剖分核心类
class HeavyLightDecomposition {
    // 预处理阶段
    void dfs1(int u, int p);
    void dfs2(int u, int h);
    
    // 路径操作
    void updatePath(int u, int v, int val);
    int queryPath(int u, int v);
    
    // 子树操作
    void updateSubtree(int u, int val);
    int querySubtree(int u);
}

// 线段树类
class SegmentTree {
    void build(int l, int r);
    void update(int l, int r, int val);
    int query(int l, int r);
}
```

### 2. 接口设计原则
- **单一职责**：每个类只负责一个功能
- **开闭原则**：对扩展开放，对修改关闭
- **依赖倒置**：依赖抽象而非具体实现

## 二、异常处理机制

### 1. 输入验证
```java
// 验证节点编号有效性
private void validateNode(int u) {
    if (u < 1 || u > n) {
        throw new IllegalArgumentException("Invalid node id: " + u);
    }
}

// 验证边权范围
private void validateWeight(int w) {
    if (w < MIN_WEIGHT || w > MAX_WEIGHT) {
        throw new IllegalArgumentException("Weight out of range: " + w);
    }
}
```

### 2. 边界情况处理
```java
// 处理空树
if (n == 0) {
    return 0; // 或抛出异常
}

// 处理单节点树
if (n == 1) {
    return w[1]; // 直接返回根节点权值
}

// 处理自环（u == v）
if (u == v) {
    return queryPoint(u); // 直接查询单点
}
```

## 三、性能优化策略

### 1. 内存优化
```java
// 使用基本类型数组而非对象数组
int[] parent = new int[n + 1]; // 优于 Integer[]

// 避免不必要的对象创建
// 错误做法：频繁创建新对象
for (int i = 0; i < n; i++) {
    List<Integer> list = new ArrayList<>(); // 每次循环创建新对象
}

// 正确做法：复用对象
List<Integer> list = new ArrayList<>();
for (int i = 0; i < n; i++) {
    list.clear(); // 清空后复用
}
```

### 2. 算法优化
```java
// 使用位运算替代除法
int mid = (l + r) >> 1; // 优于 (l + r) / 2

// 使用System.arraycopy进行数组复制
System.arraycopy(src, 0, dest, 0, length); // 优于循环复制

// 避免在循环中调用方法
// 错误做法
for (int i = 0; i < list.size(); i++) { // 每次循环调用size()
    // ...
}

// 正确做法
int size = list.size();
for (int i = 0; i < size; i++) {
    // ...
}
```

## 四、测试策略

### 1. 单元测试
```java
@Test
public void testHLDWithChainTree() {
    // 测试链状树
    int n = 1000;
    Tree tree = createChainTree(n);
    HeavyLightDecomposition hld = new HeavyLightDecomposition(tree);
    
    // 验证路径查询
    assertEquals(expected, hld.queryPath(1, n));
    
    // 验证路径更新
    hld.updatePath(1, n, 10);
    assertEquals(expected + 10 * (n - 1), hld.queryPath(1, n));
}

@Test
public void testHLDWithStarTree() {
    // 测试菊花图
    int n = 1000;
    Tree tree = createStarTree(n);
    HeavyLightDecomposition hld = new HeavyLightDecomposition(tree);
    
    // 验证子树操作
    hld.updateSubtree(1, 5);
    assertEquals(5 * (n - 1), hld.querySubtree(1));
}
```

### 2. 压力测试
```java
@Test(timeout = 1000) // 1秒超时
public void stressTestLargeInput() {
    int n = 100000;
    Tree tree = generateRandomTree(n);
    HeavyLightDecomposition hld = new HeavyLightDecomposition(tree);
    
    // 执行大量操作
    for (int i = 0; i < 100000; i++) {
        int u = random.nextInt(n) + 1;
        int v = random.nextInt(n) + 1;
        hld.queryPath(u, v);
    }
}
```

## 五、调试与日志

### 1. 调试输出
```java
// 条件编译的调试输出
private static final boolean DEBUG = false;

private void debug(String message) {
    if (DEBUG) {
        System.err.println("[DEBUG] " + message);
    }
}

// 在关键步骤添加调试信息
debug("Processing path from " + u + " to " + v);
debug("Current head: " + head[u] + ", depth: " + depth[u]);
```

### 2. 性能监控
```java
// 记录操作时间
long startTime = System.nanoTime();
// 执行操作
long endTime = System.nanoTime();
long duration = endTime - startTime;

if (duration > WARNING_THRESHOLD) {
    logger.warn("Slow operation: " + duration + " ns");
}
```

## 六、代码规范

### 1. 命名规范
```java
// 类名：大驼峰
class HeavyLightDecomposition

// 方法名：小驼峰
void dfsFirstPass(int u, int parent)

// 常量：全大写
static final int MAX_NODES = 100000;

// 变量：有意义的名称
int[] subtreeSize; // 优于 int[] sz;
```

### 2. 注释规范
```java
/**
 * 执行第一次DFS遍历
 * 
 * @param u 当前节点
 * @param p 父节点
 * @throws IllegalArgumentException 如果节点编号无效
 */
private void dfs1(int u, int p) {
    // 验证输入参数
    validateNode(u);
    validateNode(p);
    
    // 设置父节点和深度
    parent[u] = p;
    depth[u] = depth[p] + 1;
    
    // 计算子树大小并找到重儿子
    // ...
}
```

## 七、配置化设计

### 1. 可配置参数
```java
public class HLDConfig {
    // 最大节点数
    public static int MAX_NODES = 100000;
    
    // 是否启用懒标记优化
    public static boolean ENABLE_LAZY_PROPAGATION = true;
    
    // 线段树实现方式
    public static SegmentTreeType SEGMENT_TREE_TYPE = SegmentTreeType.ARRAY_BASED;
}
```

### 2. 环境适配
```java
// 根据运行环境调整参数
if (isProductionEnvironment()) {
    HLDConfig.MAX_NODES = 1000000;
    HLDConfig.ENABLE_LAZY_PROPAGATION = true;
} else {
    HLDConfig.MAX_NODES = 10000; // 开发环境使用较小规模
}
```

## 八、错误处理与恢复

### 1. 优雅降级
```java
public int safeQueryPath(int u, int v) {
    try {
        return queryPath(u, v);
    } catch (Exception e) {
        logger.error("Query path failed", e);
        // 返回默认值或使用备用算法
        return fallbackQuery(u, v);
    }
}
```

### 2. 资源清理
```java
public void cleanup() {
    // 释放数组引用
    parent = null;
    depth = null;
    // ... 其他资源清理
    
    System.gc(); // 建议垃圾回收
}
```

## 九、性能监控指标

### 1. 关键指标
- **预处理时间**：衡量算法初始化效率
- **单次操作时间**：衡量算法运行效率
- **内存使用量**：衡量空间效率
- **缓存命中率**：衡量内存访问效率

### 2. 监控实现
```java
public class HLDMetrics {
    private long preprocessTime;
    private long totalOperations;
    private long totalTime;
    
    public void recordOperation(long duration) {
        totalOperations++;
        totalTime += duration;
    }
    
    public double getAverageOperationTime() {
        return totalOperations == 0 ? 0 : (double) totalTime / totalOperations;
    }
}
```

## 十、部署与维护

### 1. 版本管理
- 使用Git进行版本控制
- 为每个重要功能创建分支
- 使用语义化版本号

### 2. 文档维护
- 维护API文档
- 记录算法变更
- 提供使用示例

### 3. 持续集成
- 自动化测试
- 代码质量检查
- 性能基准测试

通过以上工程化实践，可以确保树链剖分算法在实际项目中的稳定性、可维护性和高性能。