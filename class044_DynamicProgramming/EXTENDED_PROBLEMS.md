# 动态规划题目扩展详解

## 新增题目详细分析

### Code19: 爬楼梯 (Climbing Stairs)

**题目描述**：
假设你正在爬楼梯。需要 n 阶你才能到达楼顶。每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶？

**解题思路**：
1. **状态定义**：dp[i] 表示爬到第 i 阶楼梯的方法数
2. **状态转移**：dp[i] = dp[i-1] + dp[i-2]
3. **边界条件**：dp[0] = 1, dp[1] = 1
4. **空间优化**：使用滚动数组将空间复杂度优化到 O(1)

**时间复杂度分析**：
- 暴力递归：O(2^n) - 存在大量重复计算
- 记忆化搜索：O(n) - 每个状态只计算一次
- 动态规划：O(n) - 线性扫描
- 矩阵快速幂：O(log n) - 最优解法

**工程化考量**：
- 边界处理：n=0, n=1 的特殊情况
- 性能优化：使用迭代代替递归
- 代码清晰：明确的变量命名和注释

### Code20: 使用最小花费爬楼梯 (Min Cost Climbing Stairs)

**题目描述**：
给你一个整数数组 cost ，其中 cost[i] 是从楼梯第 i 个台阶向上爬需要支付的费用。一旦你支付此费用，即可选择向上爬一个或者两个台阶。你可以选择从下标为 0 或下标为 1 的台阶开始爬楼梯。请你计算并返回达到楼梯顶部的最低花费。

**解题思路**：
1. **状态定义**：dp[i] 表示到达第 i 阶楼梯的最小花费
2. **状态转移**：dp[i] = min(dp[i-1] + cost[i-1], dp[i-2] + cost[i-2])
3. **边界条件**：dp[0] = 0, dp[1] = 0
4. **最终目标**：min(dp[n], dp[n-1])

**时间复杂度分析**：
- 动态规划：O(n) - 线性时间复杂度
- 空间优化：O(1) - 使用滚动数组

**工程化考量**：
- 异常输入：空数组、单元素数组处理
- 性能测试：大规模数据下的表现
- 多解法对比：不同实现方式的优劣

### Code21: 打家劫舍II (House Robber II)

**题目描述**：
你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都围成一圈，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额。

**解题思路**：
1. **问题转化**：将环形问题分解为两个线性问题
   - 情况1：不偷最后一间房（可以偷第一间房）
   - 情况2：不偷第一间房（可以偷最后一间房）
2. **子问题解决**：使用打家劫舍I的解法
3. **结果合并**：取两个子问题的最大值

**时间复杂度分析**：
- 分解思路：O(n) - 解决两个线性问题
- 空间优化：O(1) - 常数空间复杂度

**工程化考量**：
- 环形处理：通用的环形问题解法
- 代码复用：重用打家劫舍I的解决方案
- 边界测试：确保环形处理的正确性

### Code22: 删除并获得点数 (Delete and Earn)

**题目描述**：
给你一个整数数组 nums ，你可以对它进行一些操作。每次操作中，选择任意一个 nums[i] ，删除它并获得 nums[i] 的点数。之后，你必须删除所有等于 nums[i] - 1 和 nums[i] + 1 的元素。开始你拥有 0 个点数。返回你能通过这些操作获得的最大点数。

**解题思路**：
1. **问题转化**：统计每个数字的总点数，转化为不能选择相邻数字的打家劫舍问题
2. **计数统计**：创建计数数组 sum，其中 sum[i] = i * (i的出现次数)
3. **状态转移**：dp[i] = max(dp[i-1], dp[i-2] + sum[i])

**时间复杂度分析**：
- 预处理：O(n + k) - n为数组长度，k为最大值
- 动态规划：O(k) - k为数字范围
- 总体复杂度：O(n + k)

**工程化考量**：
- 数字范围优化：当k很大时使用TreeMap
- 空间优化：使用滚动数组
- 异常处理：空数组、重复元素等情况

### Code23: 乘积最大子数组 (Maximum Product Subarray)

**题目描述**：
给你一个整数数组 nums ，请你找出数组中乘积最大的非空连续子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。

**解题思路**：
1. **关键洞察**：由于存在负数，最小值可能变成最大值，需要同时维护最大最小值
2. **状态定义**：
   - maxDp[i]: 以i结尾的最大乘积
   - minDp[i]: 以i结尾的最小乘积
3. **状态转移**：
   - maxDp[i] = max(nums[i], nums[i] * maxDp[i-1], nums[i] * minDp[i-1])
   - minDp[i] = min(nums[i], nums[i] * maxDp[i-1], nums[i] * minDp[i-1])

**时间复杂度分析**：
- 动态规划：O(n) - 线性扫描
- 空间优化：O(1) - 常数空间

**工程化考量**：
- 正负号处理：同时维护最大最小值
- 边界处理：包含0的情况
- 性能优化：空间优化版本

### Code24: 买卖股票的最佳时机 (Best Time to Buy and Sell Stock)

**题目描述**：
给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。你只能选择某一天买入这只股票，并选择在未来的某一个不同的日子卖出该股票。设计一个算法来计算你所能获取的最大利润。返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0。

**解题思路**：
1. **记录最低价**：遍历过程中记录历史最低价
2. **计算利润**：当前价格 - 历史最低价
3. **更新最大值**：维护最大利润

**时间复杂度分析**：
- 单次遍历：O(n) - 最优解法
- 空间复杂度：O(1) - 常数空间

**工程化考量**：
- 状态机思路：持有/不持有状态
- 多种解法：Kadane算法变种
- 边界测试：价格递减等特殊情况

## 补充题目详解

### AtCoder Educational DP Contest A - Frog 1

**题目描述**：
有N个石头排成一排，从左到右编号为1, 2, ..., N。青蛙从石头1开始，想跳到石头N。石头i的高度是h[i]。青蛙可以从石头i跳到石头i+1或石头i+2（如果存在）。从石头i跳到石头j的代价是|h[i] - h[j]|。求青蛙从石头1跳到石头N的最小总代价。

**解题思路**：
1. **状态定义**：dp[i]表示从石头1跳到石头i的最小代价
2. **状态转移**：dp[i] = min(dp[i-1] + |h[i] - h[i-1]|, dp[i-2] + |h[i] - h[i-2]|)
3. **边界条件**：dp[1] = 0

**时间复杂度分析**：
- 动态规划：O(N) - 线性扫描
- 空间优化：O(1) - 使用滚动数组

**工程化考量**：
- 边界处理：正确处理N=2的特殊情况
- 性能优化：使用迭代代替递归

### LeetCode 1143. 最长公共子序列

**题目描述**：
给定两个字符串 text1 和 text2，返回这两个字符串的最长公共子序列的长度。如果不存在公共子序列，返回 0。

**解题思路**：
1. **状态定义**：dp[i][j]表示text1的前i个字符和text2的前j个字符的最长公共子序列长度
2. **状态转移**：
   - 如果text1[i-1] == text2[j-1]，则dp[i][j] = dp[i-1][j-1] + 1
   - 否则dp[i][j] = max(dp[i-1][j], dp[i][j-1])
3. **边界条件**：dp[0][j] = dp[i][0] = 0

**时间复杂度分析**：
- 动态规划：O(m*n) - m和n分别是两个字符串的长度
- 空间优化：O(min(m,n)) - 使用滚动数组

**工程化考量**：
- 边界处理：正确处理空字符串的情况
- 性能优化：使用滚动数组优化空间复杂度

### SPOJ EDIST - Edit Distance

**题目描述**：
给定两个字符串A和B。我们需要将A转换为B，可以进行以下三种操作：1. 插入一个字符 2. 删除一个字符 3. 替换一个字符。每种操作的代价都是1。求将A转换为B的最小代价。

**解题思路**：
1. **状态定义**：dp[i][j]表示将字符串A的前i个字符转换为字符串B的前j个字符的最小代价
2. **状态转移**：
   - 如果A[i-1] == B[j-1]，则dp[i][j] = dp[i-1][j-1]
   - 否则dp[i][j] = min(dp[i-1][j] + 1, dp[i][j-1] + 1, dp[i-1][j-1] + 1)
3. **边界条件**：
   - dp[0][j] = j（将空字符串转换为B的前j个字符需要j次插入操作）
   - dp[i][0] = i（将A的前i个字符转换为空字符串需要i次删除操作）

**时间复杂度分析**：
- 动态规划：O(m*n) - m和n分别是两个字符串的长度
- 空间优化：O(min(m,n)) - 使用滚动数组

**工程化考量**：
- 边界处理：正确处理空字符串的情况
- 性能优化：使用滚动数组优化空间复杂度

## 算法技巧深度解析

### 1. 状态定义的艺术
- **明确含义**：dp[i]应该清晰表达状态含义
- **维度选择**：根据问题复杂度选择一维、二维或多维DP
- **状态压缩**：使用位运算等技巧减少状态空间

### 2. 状态转移的优化
- **递推关系**：找到最优子结构
- **记忆化搜索**：自顶向下的递归解法
- **迭代DP**：自底向上的迭代解法

### 3. 空间复杂度优化
- **滚动数组**：只保存必要的前几个状态
- **状态压缩**：使用变量代替数组
- **原地修改**：在输入数组上直接修改

### 4. 时间复杂度优化
- **预处理**：提前计算必要信息
- **剪枝**：提前终止不必要的计算
- **分治**：将大问题分解为小问题

## 工程化实践指南

### 1. 代码规范
```java
// 良好的DP代码示例
public int solution(int[] nums) {
    // 边界检查
    if (nums == null || nums.length == 0) return 0;
    
    // 状态初始化
    int n = nums.length;
    int[] dp = new int[n];
    
    // 边界条件处理
    dp[0] = nums[0];
    
    // 状态转移
    for (int i = 1; i < n; i++) {
        dp[i] = Math.max(dp[i-1] + nums[i], nums[i]);
    }
    
    // 结果提取
    return Arrays.stream(dp).max().getAsInt();
}
```

### 2. 测试策略
- **单元测试**：覆盖所有边界情况
- **性能测试**：验证大规模数据下的表现
- **压力测试**：极端输入的处理能力

### 3. 调试技巧
- **打印中间状态**：跟踪dp数组的变化
- **可视化工具**：使用图表展示状态转移
- **断言检查**：验证状态转移的正确性

## 进阶学习路径

### 第一阶段：基础掌握
1. 理解DP基本概念
2. 掌握经典DP模型
3. 完成LeetCode简单难度题目

### 第二阶段：技能提升
1. 学习高级DP技巧
2. 解决中等难度题目
3. 参加编程竞赛

### 第三阶段：专家水平
1. 研究复杂DP问题
2. 开发新的DP算法
3. 参与算法研究

## 资源推荐

### 学习资料
- [动态规划专题 - LeetCode](https://leetcode.cn/tag/dynamic-programming/)
- [算法竞赛入门经典 - 刘汝佳]
- [挑战程序设计竞赛 - 秋叶拓哉]

### 实践平台
- LeetCode（力扣）
- AtCoder
- Codeforces
- 牛客网

### 工具推荐
- [Visualgo](https://visualgo.net/) - 算法可视化
- [Algorithm Visualizer](https://algorithm-visualizer.org/) - 算法演示
- [LeetCode Animation](https://github.com/MisterBooo/LeetCodeAnimation) - 题目动画

---
*本文档将持续更新，建议定期查看最新内容*