# 组合数学与杨辉三角题目总结

本文件总结了组合数学与杨辉三角相关题目的解法，包含Java、Python、C++三种语言的实现。

## 1. 杨辉三角生成

### 题目描述
给定一个非负整数 numRows，生成杨辉三角的前 numRows 行。

### Java 实现
```java
public class PascalTriangle {
    public static int[][] generate(int numRows) {
        int[][] triangle = new int[numRows][];
        
        for (int i = 0; i < numRows; i++) {
            triangle[i] = new int[i + 1];
            triangle[i][0] = triangle[i][i] = 1;
            
            for (int j = 1; j < i; j++) {
                triangle[i][j] = triangle[i-1][j-1] + triangle[i-1][j];
            }
        }
        
        return triangle;
    }
}
```

### Python 实现
```python
class PascalTriangle:
    @staticmethod
    def generate(num_rows):
        triangle = []
        
        for i in range(num_rows):
            row = [1] * (i + 1)
            
            for j in range(1, i):
                row[j] = triangle[i-1][j-1] + triangle[i-1][j]
            
            triangle.append(row)
        
        return triangle
```

### C++ 实现
```cpp
#include <vector>
using namespace std;

class PascalTriangle {
public:
    static vector<vector<int>> generate(int numRows) {
        vector<vector<int>> triangle;
        
        for (int i = 0; i < numRows; i++) {
            vector<int> row(i + 1, 1);
            
            for (int j = 1; j < i; j++) {
                row[j] = triangle[i-1][j-1] + triangle[i-1][j];
            }
            
            triangle.push_back(row);
        }
        
        return triangle;
    }
};
```

## 2. 杨辉三角第k行

### 题目描述
给定一个非负索引 rowIndex，返回「杨辉三角」的第 rowIndex 行。

### Java 实现
```java
import java.util.*;

public class PascalTriangleRow {
    public static List<Integer> getRow(int rowIndex) {
        List<Integer> row = new ArrayList<>();
        row.add(1);
        
        for (int i = 1; i <= rowIndex; i++) {
            for (int j = i - 1; j > 0; j--) {
                row.set(j, row.get(j) + row.get(j-1));
            }
            row.add(1);
        }
        
        return row;
    }
}
```

### Python 实现
```python
class PascalTriangleRow:
    @staticmethod
    def get_row(row_index):
        row = [1]
        
        for i in range(1, row_index + 1):
            for j in range(i - 1, 0, -1):
                row[j] = row[j] + row[j-1]
            row.append(1)
        
        return row
```

### C++ 实现
```cpp
#include <vector>
using namespace std;

class PascalTriangleRow {
public:
    static vector<int> getRow(int rowIndex) {
        vector<int> row(1, 1);
        
        for (int i = 1; i <= rowIndex; i++) {
            for (int j = i - 1; j > 0; j--) {
                row[j] = row[j] + row[j-1];
            }
            row.push_back(1);
        }
        
        return row;
    }
};
```

## 3. 组合数计算

### 题目描述
计算组合数C(n, k) = n! / (k! * (n-k)!)

### Java 实现
```java
public class Combination {
    public static final int MOD = 1000000007;
    
    // 直接计算组合数
    public static long combination(int n, int k) {
        if (k > n || k < 0) return 0;
        if (k == 0 || k == n) return 1;
        
        long result = 1;
        for (int i = 1; i <= Math.min(k, n - k); i++) {
            result = result * (n - i + 1) / i;
        }
        return result;
    }
    
    // 模运算下的组合数计算
    public static long combinationMod(int n, int k) {
        if (k > n || k < 0) return 0;
        if (k == 0 || k == n) return 1;
        
        long[] fact = new long[n + 1];
        fact[0] = 1;
        for (int i = 1; i <= n; i++) {
            fact[i] = (fact[i-1] * i) % MOD;
        }
        
        long result = fact[n];
        result = (result * modInverse(fact[k], MOD)) % MOD;
        result = (result * modInverse(fact[n-k], MOD)) % MOD;
        return result;
    }
    
    // 计算模逆元
    public static long modInverse(long a, long mod) {
        return power(a, mod - 2, mod);
    }
    
    // 快速幂
    public static long power(long base, long exp, long mod) {
        long result = 1;
        while (exp > 0) {
            if (exp % 2 == 1) {
                result = (result * base) % mod;
            }
            base = (base * base) % mod;
            exp /= 2;
        }
        return result;
    }
}
```

### Python 实现
```python
class Combination:
    MOD = 1000000007
    
    @staticmethod
    def combination(n, k):
        """直接计算组合数"""
        if k > n or k < 0:
            return 0
        if k == 0 or k == n:
            return 1
        
        result = 1
        for i in range(min(k, n - k)):
            result = result * (n - i) // (i + 1)
        return result
    
    @staticmethod
    def combination_mod(n, k):
        """模运算下的组合数计算"""
        if k > n or k < 0:
            return 0
        if k == 0 or k == n:
            return 1
        
        fact = [1] * (n + 1)
        for i in range(1, n + 1):
            fact[i] = (fact[i-1] * i) % Combination.MOD
        
        result = fact[n]
        result = (result * Combination.mod_inverse(fact[k], Combination.MOD)) % Combination.MOD
        result = (result * Combination.mod_inverse(fact[n-k], Combination.MOD)) % Combination.MOD
        return result
    
    @staticmethod
    def mod_inverse(a, mod):
        """计算模逆元"""
        return Combination.power(a, mod - 2, mod)
    
    @staticmethod
    def power(base, exp, mod):
        """快速幂"""
        result = 1
        while exp > 0:
            if exp % 2 == 1:
                result = (result * base) % mod
            base = (base * base) % mod
            exp //= 2
        return result
```

### C++ 实现
```cpp
#include <vector>
using namespace std;

class Combination {
public:
    static const long long MOD = 1000000007;
    
    // 直接计算组合数
    static long long combination(int n, int k) {
        if (k > n || k < 0) return 0;
        if (k == 0 || k == n) return 1;
        
        long long result = 1;
        for (int i = 1; i <= min(k, n - k); i++) {
            result = result * (n - i + 1) / i;
        }
        return result;
    }
    
    // 模运算下的组合数计算
    static long long combinationMod(int n, int k) {
        if (k > n || k < 0) return 0;
        if (k == 0 || k == n) return 1;
        
        vector<long long> fact(n + 1);
        fact[0] = 1;
        for (int i = 1; i <= n; i++) {
            fact[i] = (fact[i-1] * i) % MOD;
        }
        
        long long result = fact[n];
        result = (result * modInverse(fact[k], MOD)) % MOD;
        result = (result * modInverse(fact[n-k], MOD)) % MOD;
        return result;
    }
    
    // 计算模逆元
    static long long modInverse(long long a, long long mod) {
        return power(a, mod - 2, mod);
    }
    
    // 快速幂
    static long long power(long long base, long long exp, long long mod) {
        long long result = 1;
        while (exp > 0) {
            if (exp % 2 == 1) {
                result = (result * base) % mod;
            }
            base = (base * base) % mod;
            exp /= 2;
        }
        return result;
    }
};
```

## 4. 不同路径

### 题目描述
一个机器人位于一个 m x n 网格的左上角，机器人每次只能向下或者向右移动一步，求总共有多少条不同的路径。

### Java 实现
```java
public class UniquePaths {
    public static int uniquePaths(int m, int n) {
        long result = 1;
        for (int i = 1; i <= m-1; i++) {
            result = result * (n-1+i) / i;
        }
        return (int)result;
    }
}
```

### Python 实现
```python
class UniquePaths:
    @staticmethod
    def unique_paths(m, n):
        result = 1
        for i in range(1, m):
            result = result * (n-1+i) // i
        return result
```

### C++ 实现
```cpp
class UniquePaths {
public:
    static int uniquePaths(int m, int n) {
        long long result = 1;
        for (int i = 1; i <= m-1; i++) {
            result = result * (n-1+i) / i;
        }
        return (int)result;
    }
};
```

## 5. 不同的二叉搜索树

### 题目描述
给定一个整数 n，求恰由 n 个节点组成且节点值从 1 到 n 互不相同的二叉搜索树有多少种？

### Java 实现
```java
public class UniqueBST {
    public static int numTrees(int n) {
        long catalan = 1;
        for (int i = 0; i < n; i++) {
            catalan = catalan * 2 * (2 * i + 1) / (i + 2);
        }
        return (int)catalan;
    }
}
```

### Python 实现
```python
class UniqueBST:
    @staticmethod
    def num_trees(n):
        catalan = 1
        for i in range(n):
            catalan = catalan * 2 * (2 * i + 1) // (i + 2)
        return catalan
```

### C++ 实现
```cpp
class UniqueBST {
public:
    static int numTrees(int n) {
        long long catalan = 1;
        for (int i = 0; i < n; i++) {
            catalan = catalan * 2 * (2 * i + 1) / (i + 2);
        }
        return (int)catalan;
    }
};
```

## 6. 整数拆分

### 题目描述
给定一个正整数 n，将其拆分为至少两个正整数的和，并使这些整数的乘积最大化。

### Java 实现
```java
public class IntegerBreak {
    public static int integerBreak(int n) {
        if (n <= 3) return n - 1;
        
        int quotient = n / 3;
        int remainder = n % 3;
        
        if (remainder == 0) {
            return (int) Math.pow(3, quotient);
        } else if (remainder == 1) {
            return (int) Math.pow(3, quotient - 1) * 4;
        } else {
            return (int) Math.pow(3, quotient) * 2;
        }
    }
}
```

### Python 实现
```python
class IntegerBreak:
    @staticmethod
    def integer_break(n):
        if n <= 3:
            return n - 1
        
        quotient = n // 3
        remainder = n % 3
        
        if remainder == 0:
            return 3 ** quotient
        elif remainder == 1:
            return 3 ** (quotient - 1) * 4
        else:
            return 3 ** quotient * 2
```

### C++ 实现
```cpp
#include <cmath>
using namespace std;

class IntegerBreak {
public:
    static int integerBreak(int n) {
        if (n <= 3) return n - 1;
        
        int quotient = n / 3;
        int remainder = n % 3;
        
        if (remainder == 0) {
            return (int) pow(3, quotient);
        } else if (remainder == 1) {
            return (int) pow(3, quotient - 1) * 4;
        } else {
            return (int) pow(3, quotient) * 2;
        }
    }
};
```

## 7. 零钱兑换 II

### 题目描述
给你一个整数数组 coins 表示不同面额的硬币，另给一个整数 amount 表示总金额。请你计算并返回可以凑成总金额的硬币组合数。

### Java 实现
```java
public class Change {
    public static int change(int amount, int[] coins) {
        int[] dp = new int[amount + 1];
        dp[0] = 1;
        
        for (int coin : coins) {
            for (int i = coin; i <= amount; i++) {
                dp[i] += dp[i - coin];
            }
        }
        
        return dp[amount];
    }
}
```

### Python 实现
```python
class Change:
    @staticmethod
    def change(amount, coins):
        dp = [0] * (amount + 1)
        dp[0] = 1
        
        for coin in coins:
            for i in range(coin, amount + 1):
                dp[i] += dp[i - coin]
        
        return dp[amount]
```

### C++ 实现
```cpp
#include <vector>
using namespace std;

class Change {
public:
    static int change(int amount, vector<int>& coins) {
        vector<int> dp(amount + 1, 0);
        dp[0] = 1;
        
        for (int coin : coins) {
            for (int i = coin; i <= amount; i++) {
                dp[i] += dp[i - coin];
            }
        }
        
        return dp[amount];
    }
};
```

## 8. K个逆序对数组

### 题目描述
给出两个整数 n 和 k，找出所有包含从 1 到 n 的数字，且恰好拥有 k 个逆序对的不同的数组的个数。

### Java 实现
```java
public class KInversePairs {
    public static int kInversePairs(int n, int k) {
        int MOD = 1000000007;
        int[][] dp = new int[n+1][k+1];
        
        for (int i = 1; i <= n; i++) {
            dp[i][0] = 1;
        }
        
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= k; j++) {
                dp[i][j] = (dp[i][j-1] + dp[i-1][j]) % MOD;
                if (j >= i) {
                    dp[i][j] = (dp[i][j] - dp[i-1][j-i] + MOD) % MOD;
                }
            }
        }
        
        return dp[n][k];
    }
}
```

### Python 实现
```python
class KInversePairs:
    @staticmethod
    def k_inverse_pairs(n, k):
        MOD = 1000000007
        dp = [[0] * (k+1) for _ in range(n+1)]
        
        for i in range(1, n+1):
            dp[i][0] = 1
        
        for i in range(1, n+1):
            for j in range(1, k+1):
                dp[i][j] = (dp[i][j-1] + dp[i-1][j]) % MOD
                if j >= i:
                    dp[i][j] = (dp[i][j] - dp[i-1][j-i] + MOD) % MOD
        
        return dp[n][k]
```

### C++ 实现
```cpp
#include <vector>
using namespace std;

class KInversePairs {
public:
    static int kInversePairs(int n, int k) {
        const int MOD = 1000000007;
        vector<vector<int>> dp(n+1, vector<int>(k+1, 0));
        
        for (int i = 1; i <= n; i++) {
            dp[i][0] = 1;
        }
        
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= k; j++) {
                dp[i][j] = (dp[i][j-1] + dp[i-1][j]) % MOD;
                if (j >= i) {
                    dp[i][j] = (dp[i][j] - dp[i-1][j-i] + MOD) % MOD;
                }
            }
        }
        
        return dp[n][k];
    }
};
```

## 总结

通过以上实现，我们可以看到组合数学和杨辉三角在算法中的广泛应用：

1. **杨辉三角**：基础的组合数表示，可用于计算二项式系数
2. **组合数计算**：直接计算或通过模运算处理大数
3. **动态规划**：许多计数问题可以通过动态规划解决
4. **数学优化**：利用数学性质优化算法复杂度

掌握这些知识点对于解决相关算法问题非常有帮助。