# 洛谷 P3258 [JLOI2014] 松鼠的新家

## 题目描述

松鼠家族的成员需要在树上移动，从一个节点到另一个节点。给定一棵包含N个节点的树，以及N-1次移动操作。每次移动操作表示从节点a移动到节点b，经过的路径上的所有节点（包括起点和终点）都会被访问一次。求每个节点被访问的次数。

## 题目链接

[洛谷 P3258 [JLOI2014] 松鼠的新家](https://www.luogu.com.cn/problem/P3258)

## 输入格式

- 第一行包含一个整数N，表示节点的数量。
- 第二行包含N个整数，表示访问节点的顺序。
- 接下来N-1行，每行包含两个整数u和v，表示节点u和节点v之间有一条边。

## 输出格式

输出N行，第i行表示节点i被访问的次数。

## 样例输入

```
5
1 2 3 4 5
1 2
2 3
2 4
4 5
```

## 样例输出

```
1
2
1
2
1
```

## 数据范围

- 1 <= N <= 300000

## 解题思路

这是一道典型的树上点差分问题。我们需要统计树上每条路径经过的节点次数。

### 算法分析

1. **树上点差分**：
   - 对于树上从节点u到节点v的路径，我们需要将路径上所有节点的访问次数加1。
   - 使用树上点差分技术，我们可以在O(1)时间内完成这个操作：
     - diff[u] += 1
     - diff[v] += 1
     - diff[lca(u,v)] -= 1
     - diff[parent[lca(u,v)]] -= 1
   - 最后通过一次DFS遍历，计算每个节点的子树和，得到最终结果。

2. **LCA计算**：
   - 使用倍增法预处理LCA，时间复杂度为O(N log N)预处理，O(log N)查询。

3. **特殊处理**：
   - 注意每次移动的终点也是下一次移动的起点，除了最后一次移动，所以需要对除最后一个节点外的所有节点的访问次数减1。

### 时间复杂度

- 预处理阶段：O(N log N)（倍增法求LCA）
- 修改操作：O(1)每次
- 查询结果：O(N)（DFS遍历）
- 总体复杂度：O(N log N)

### 空间复杂度

- 树存储：O(N)
- LCA相关数组：O(N log N)
- 差分数组：O(N)
- 总体复杂度：O(N log N)

## 代码实现

### Java版本

```java
// 详细实现见Code08_SquirrelNewHome.java
```

### C++版本

```cpp
// 详细实现见Code08_SquirrelNewHome.cpp
```

### Python版本

```python
# 详细实现见Code08_SquirrelNewHome.py
```

## 算法要点

1. **树上点差分**：
   - 点差分用于处理对路径上所有点的修改操作。
   - 对于路径u到v：
     ```
     diff[u] += d
     diff[v] += d
     diff[lca(u,v)] -= d
     diff[father[lca(u,v)]] -= d
     ```

2. **LCA算法**：
   - 使用倍增法预处理LCA，预处理时间复杂度O(N log N)，查询时间复杂度O(log N)。

3. **DFS遍历**：
   - 通过DFS遍历计算子树和，得到最终结果。

## 常见错误与注意事项

1. **LCA计算错误**：
   - 倍增数组初始化错误
   - 深度比较错误
   - 跳跃过程错误

2. **差分标记错误**：
   - 点差分和边差分混淆
   - 标记位置错误
   - 系数错误

3. **边界处理错误**：
   - 根节点的特殊处理
   - LCA为端点的特殊情况未考虑
   - 数组越界

4. **特殊处理**：
   - 每次移动的终点也是下一次移动的起点，需要特殊处理

## 扩展应用

1. **树上边差分**：
   - 处理对路径上所有边的修改操作。
   - 对于路径u到v：
     ```
     diff[u] += d
     diff[v] += d
     diff[lca(u,v)] -= 2 * d
     ```

2. **树链剖分 + 线段树**：
   - 对于更复杂的操作，可以结合树链剖分和线段树：
     - 支持区间修改和区间查询
     - 更灵活的操作支持
     - 但代码复杂度较高

3. **树上启发式合并**：
   - 对于子树信息合并问题：
     - 时间复杂度优化到O(N log N)
     - 适用于特定类型的树上问题

## 相关题目

1. **洛谷 P3128 [USACO15DEC] Max Flow P** - 树上点差分模板题
2. **LOJ 10131 暗的连锁** - 树上边差分
3. **POJ 3417 Network** - 树上边差分
4. **洛谷 P2680 运输计划** - 树上边差分+二分

## 总结

树上点差分是处理树上路径修改问题的重要算法技巧，通过将路径修改转化为端点标记，大大优化了时间复杂度。掌握树上点差分需要：

1. 深入理解差分思想
2. 熟练掌握LCA算法
3. 灵活应用点差分
4. 注意实现细节和边界条件

通过系统学习和大量练习，可以熟练掌握这一重要算法技巧，为解决更复杂的树上问题打下坚实基础。