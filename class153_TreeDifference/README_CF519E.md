# Codeforces 519E. A and B and Lecture Rooms

## 题目描述

给定一棵有 `n` 个节点的树（节点编号从 1 到 n），树由 `edges` 数组表示。有多个查询，每个查询给出两个节点 `u` 和 `v`，要求找到树上到 `u` 和 `v` 距离相等的节点数量。

## 算法思路

### 核心思想
1. **LCA计算**：使用倍增法快速计算两个节点的最近公共祖先
2. **距离计算**：通过深度计算节点间距离
3. **中点分析**：根据距离的奇偶性判断是否存在满足条件的节点
4. **子树大小统计**：利用子树大小计算满足条件的节点数量

### 具体步骤

1. **预处理阶段**：
   - 构建树的邻接表表示
   - 使用DFS预处理每个节点的深度、父节点和子树大小
   - 使用倍增法预处理父节点数组，用于快速计算LCA

2. **查询处理**：
   - 如果 `u == v`，所有节点都满足条件，返回 `n`
   - 计算 `u` 和 `v` 之间的距离 `dist = depth[u] + depth[v] - 2 * depth[lca]`
   - 如果距离为奇数，没有满足条件的节点，返回 `0`
   - 如果距离为偶数：
     - 当 `u` 和 `v` 在同一深度时，中点在LCA处
     - 当 `u` 和 `v` 在不同深度时，找到路径的中点

## 时间复杂度
- 预处理：O(n log n)
- 每个查询：O(log n)
- 总复杂度：O(n log n + q log n)，其中 q 是查询数量

## 空间复杂度
- O(n log n) 用于存储倍增数组
- O(n) 用于存储深度和子树大小信息

## 关键点分析

1. **距离计算**：树上两点距离 = depth[u] + depth[v] - 2 * depth[lca]
2. **中点位置**：
   - 当深度相同时，中点在LCA处
   - 当深度不同时，中点位于较深节点向上移动 dist/2 步的位置
3. **节点计数**：
   - 深度相同时：n - size[uMid] - size[vMid]
   - 深度不同时：size[mid] - size[prev]

## 代码实现

提供了三种语言的实现：
- **Java**：使用邻接表和倍增法
- **C++**：使用 vector 和数学函数
- **Python**：使用列表和数学模块

## 测试用例

```
输入:
n = 4
edges = [[1,2], [1,3], [2,4]]
queries = [[1,2], [2,3], [3,4], [2,4]]

输出: [2, 1, 1, 1]
```

解释：
- 查询(1,2)：节点3和4到1和2的距离相等
- 查询(2,3)：只有节点1满足条件
- 查询(3,4)：只有节点1满足条件
- 查询(2,4)：只有节点1满足条件

## 应用场景
- 网络拓扑分析
- 社交网络距离计算
- 路径规划中的等距点查找