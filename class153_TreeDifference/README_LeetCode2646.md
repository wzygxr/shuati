# LeetCode 2646. 最小化旅行的价格

## 题目描述

给定一棵有 `n` 个节点的树（节点编号从 0 到 n-1），每个节点有一个价格 `price[i]`。树由 `edges` 数组表示，其中 `edges[i] = [u, v]` 表示节点 u 和 v 之间有一条边。

有 `m` 个旅行路径，每个路径由 `trips[i] = [u, v]` 表示，表示从节点 u 旅行到节点 v。

你可以选择将某些节点的价格减半（即价格变为原来的一半，向下取整）。要求最小化所有旅行路径的总价格。

## 算法思路

### 核心思想
1. **树上差分统计**：使用树上差分算法统计每条边被经过的次数
2. **树形DP决策**：使用树形动态规划决定哪些节点应该减半

### 具体步骤

1. **构建图结构**：根据 edges 构建邻接表表示的树
2. **预处理LCA**：使用倍增法预处理每个节点的父节点信息，用于快速计算LCA
3. **树上差分统计**：
   - 对于每个旅行路径 (u, v)，找到它们的最近公共祖先 (LCA)
   - 在 u 和 v 处加1，在 LCA 处减2
   - 通过DFS统计每个节点被经过的总次数
4. **树形DP决策**：
   - `dp[u][0]`：节点 u 不减半的最小总价格
   - `dp[u][1]`：节点 u 减半的最小总价格
   - 状态转移：
     - 如果当前节点不减半，子节点可以减半或不减半
     - 如果当前节点减半，子节点不能减半

## 时间复杂度
- 预处理LCA：O(n log n)
- 树上差分：O(m log n)
- 树形DP：O(n)
- 总复杂度：O((n + m) log n)

## 空间复杂度
- O(n log n) 用于存储倍增数组
- O(n) 用于存储差分数组和DP数组

## 代码实现

提供了三种语言的实现：
- **Java**：使用邻接表和倍增法
- **C++**：使用 vector 和队列
- **Python**：使用列表和双端队列

## 测试用例

### 测试用例1
```
n = 4
edges = [[0,1],[1,2],[1,3]]
price = [2,2,10,6]
trips = [[0,3],[2,1],[2,3]]
输出: 23
```

### 测试用例2
```
n = 2
edges = [[0,1]]
price = [2,2]
trips = [[0,0]]
输出: 1
```

## 关键点
1. 树上差分是统计路径覆盖次数的有效方法
2. 树形DP需要考虑相邻节点的约束关系
3. 减半操作只能进行一次，且相邻节点不能同时减半
4. 使用倍增法可以高效计算LCA

## 应用场景
- 网络流量优化
- 资源分配问题
- 路径规划优化