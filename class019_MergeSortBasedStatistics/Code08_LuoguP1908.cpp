#include <iostream>
#include <vector>
#include <algorithm>
#include <cstdio>
#include <cstring>
using namespace std;

/**
 * ============================================================================
 * 题目8: 洛谷 P1908 - 逆序对 (Inversion Pairs)
 * ============================================================================
 * 
 * 题目来源: 洛谷
 * 题目链接: https://www.luogu.com.cn/problem/P1908
 * 难度级别: 普及+/提高
 * 
 * 问题描述:
 * 给定一个序列，求出这个序列的逆序对个数。
 * 逆序对定义：对于序列中的两个元素a[i]和a[j]，如果i<j且a[i]>a[j]，则称这两个元素构成一个逆序对。
 * 
 * 输入格式:
 * 第一行，一个整数n，表示序列长度。
 * 第二行，n个整数，表示给定的序列。
 * 
 * 输出格式:
 * 输出一个整数，表示序列中逆序对的个数。
 * 
 * 示例输入输出:
 * 输入:
 * 6
 * 5 4 2 6 3 1
 * 输出:
 * 11
 * 
 * 数据范围:
 * 对于60%的数据，n <= 1000
 * 对于100%的数据，n <= 500000，序列中每个数的绝对值不超过10^9
 * 
 * ============================================================================
 * 核心算法思想: 归并排序分治统计
 * ============================================================================
 * 
 * 方法1: 暴力解法 (不推荐)
 * - 思路: 双重循环遍历所有 i < j 的情况，判断 nums[i] > nums[j]
 * - 时间复杂度: O(N^2) - 双重循环
 * - 空间复杂度: O(1) - 不需要额外空间
 * - 问题: 数据量大时超时
 * 
 * 方法2: 归并排序思想 (最优解) ★★★★★
 * - 核心洞察: 利用归并排序的分治过程，在合并两个有序子数组之前，
 *   统计左侧子数组中每个元素与右侧子数组形成的逆序对数量
 * 
 * - 归并排序过程:
 *   1. 分治: 将数组不断二分，直到只有一个元素
 *   2. 统计: 在合并前，统计左侧子数组中每个元素能与右侧子数组形成的逆序对数量
 *   3. 合并: 合并两个有序子数组
 * 
 * - 统计逆序对的关键步骤:
 *   - 当右子数组中的元素被选中时，不会对左侧元素产生影响
 *   - 当左子数组中的元素被选中时，右子数组中已处理的元素都小于它，形成逆序对
 *   - 因此，每次选中左子数组元素时，需要累加右侧已处理的元素数量
 * 
 * - 时间复杂度详细计算:
 *   T(n) = 2T(n/2) + O(n)  [Master定理 case 2]
 *   = O(n log n)
 *   - 递归深度: log n
 *   - 每层统计和合并: O(n)
 * 
 * - 空间复杂度详细计算:
 *   S(n) = O(n) + O(log n)
 *   - O(n): 辅助数组help
 *   - O(log n): 递归调用栈
 *   总计: O(n)
 * 
 * - 是否最优解: ★ 是 ★
 *   理由: 基于比较的算法下界为O(n log n)，本算法已达到最优
 * 
 * ============================================================================
 * 相关题目列表 (基于归并排序的统计问题)
 * ============================================================================
 * 1. LeetCode 315 - 计算右侧小于当前元素的个数
 *    https://leetcode.cn/problems/count-of-smaller-numbers-after-self/
 *    问题：统计每个元素右侧比它小的元素个数
 *    解法：归并排序过程中记录元素原始索引，统计右侧小于当前元素的数量
 * 
 * 2. LeetCode 493 - 翻转对
 *    https://leetcode.cn/problems/reverse-pairs/
 *    问题：统计满足 nums[i] > 2*nums[j] 且 i < j 的对的数量
 *    解法：归并排序过程中使用双指针统计跨越左右区间的翻转对
 * 
 * 3. LeetCode 327 - 区间和的个数
 *    https://leetcode.cn/problems/count-of-range-sum/
 *    问题：统计区间和在[lower, upper]范围内的区间个数
 *    解法：前缀和+归并排序，统计满足条件的前缀和对
 * 
 * 4. 剑指Offer 51 / LCR 170 - 数组中的逆序对
 *    https://leetcode.cn/problems/shu-zu-zhong-de-ni-xu-dui-lcof/
 *    问题：统计数组中逆序对的总数
 *    解法：归并排序过程中统计逆序对数量
 * 
 * 5. POJ 2299 - Ultra-QuickSort
 *    http://poj.org/problem?id=2299
 *    问题：计算将数组排序所需的最小交换次数（即逆序对数量）
 *    解法：归并排序统计逆序对
 * 
 * 6. HDU 1394 - Minimum Inversion Number
 *    http://acm.hdu.edu.cn/showproblem.php?pid=1394
 *    问题：将数组循环左移，求所有可能排列中的最小逆序对数量
 *    解法：归并排序+逆序对性质分析
 * 
 * 7. HackerRank - Merge Sort: Counting Inversions
 *    https://www.hackerrank.com/challenges/merge-sort/problem
 *    问题：统计逆序对数量
 *    解法：归并排序统计逆序对
 * 
 * 8. SPOJ - INVCNT
 *    https://www.spoj.com/problems/INVCNT/
 *    问题：统计逆序对数量
 *    解法：归并排序统计逆序对
 * 
 * 9. CodeChef - INVCNT
 *    https://www.codechef.com/problems/INVCNT
 *    问题：统计逆序对数量
 *    解法：归并排序或树状数组
 * 
 * 10. UVa 10810 - Ultra-QuickSort
 *     https://onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=1751
 *     问题：计算逆序对数量
 *     解法：归并排序统计逆序对
 * 
 * 这些题目虽然具体形式不同，但核心思想都是利用归并排序的分治特性，在合并过程中高效统计满足特定条件的元素对数量。
 */

const int MAXN = 500001;
int n;
long long arr[MAXN];
long long help[MAXN];

/**
 * 归并排序并统计逆序对数量
 * 
 * @param l 左边界
 * @param r 右边界
 * @return 区间[l,r]中的逆序对数量
 */
long long mergeSort(int l, int r) {
    if (l == r) {
        return 0;
    }
    
    int m = l + (r - l) / 2;
    // 分治：左半部分逆序对 + 右半部分逆序对 + 跨越两部分的逆序对
    return mergeSort(l, m) + mergeSort(m + 1, r) + merge(l, m, r);
}

/**
 * 合并两个有序子数组并统计逆序对数量
 * 
 * @param l 左边界
 * @param m 中点
 * @param r 右边界
 * @return 跨越[l,m]和[m+1,r]的逆序对数量
 */
long long merge(int l, int m, int r) {
    long long count = 0;
    int i = l;      // help数组的当前位置
    int a = l;      // 左侧数组指针
    int b = m + 1;  // 右侧数组指针
    
    // 合并过程，同时统计逆序对
    while (a <= m && b <= r) {
        if (arr[a] <= arr[b]) {
            // 左侧元素小于等于右侧元素
            // 右侧数组中已处理的元素(b - (m+1))个都小于arr[a]，构成逆序对
            count += (b - m - 1);
            help[i++] = arr[a++];
        } else {
            // 右侧元素小于左侧元素
            help[i++] = arr[b++];
        }
    }
    
    // 处理左侧剩余元素
    while (a <= m) {
        // 左侧剩余元素与右侧所有元素都构成逆序对
        count += (b - m - 1);
        help[i++] = arr[a++];
    }
    
    // 处理右侧剩余元素
    while (b <= r) {
        help[i++] = arr[b++];
    }
    
    // 将help数组拷贝回原数组
    for (i = l; i <= r; i++) {
        arr[i] = help[i];
    }
    
    return count;
}

/**
 * 主函数 - 处理输入输出
 * 
 * 输入处理优化:
 * 使用scanf提高输入效率
 * 对于大规模数据(500000个元素)，这种优化非常必要
 */
int main() {
    // IO优化
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    
    // 读取数组长度
    scanf("%d", &n);
    
    // 读取数组元素
    for (int i = 0; i < n; i++) {
        scanf("%lld", &arr[i]);
    }
    
    // 计算并输出逆序对数量
    printf("%lld\n", mergeSort(0, n - 1));
    
    return 0;
}

/*
 * ============================================================================
 * C++语言特有关注事项
 * ============================================================================
 * 1. 数据类型溢出问题：
 *    - 逆序对数量可能超过int范围，使用long long类型存储结果
 *    - 当n=500000时，最坏情况下逆序对数量可达n*(n-1)/2≈1.25*10^11，超出int范围
 *    - 数组元素范围为[-10^9, 10^9]，使用long long存储确保不会溢出
 * 
 * 2. 输入输出优化：
 *    - 使用scanf/printf而非cin/cout提高输入输出效率
 *    - 使用ios::sync_with_stdio(false)关闭C++与C的IO同步
 *    - 使用cin.tie(nullptr)解除cin与cout的绑定
 * 
 * 3. 内存管理：
 *    - 使用全局数组避免频繁内存分配
 *    - MAXN设为500001，满足题目要求
 *    - 静态数组在栈上分配，访问速度快
 * 
 * 4. 递归深度：
 *    - 归并排序递归深度为log2(500000)≈19层，不会超出C++默认栈限制
 * 
 * 5. 位运算优化：
 *    - 可使用(l+r)>>1代替(l+r)/2提高运算效率
 *    - 注意当l和r都很大时，(l+r)可能导致溢出，应改为l+((r-l)>>1)
 * 
 * ============================================================================
 * 工程化考量
 * ============================================================================
 * 1. 性能优化：
 *    - 对于小规模子数组(如n<10)，可考虑使用插入排序
 *    - 可添加判断：当arr[m] <= arr[m+1]时，子数组已有序，可跳过合并
 * 
 * 2. 错误处理：
 *    - 可添加输入验证，检查n是否在合法范围内
 *    - 可添加文件结束检查，处理输入异常
 * 
 * 3. 可扩展性：
 *    - 算法易于扩展到其他统计问题(如翻转对、小和问题)
 *    - 可封装为函数库供其他程序调用
 * 
 * 4. 编译优化：
 *    - 可使用-O2编译选项优化性能
 *    - 可使用-march=native利用CPU特性进一步优化
 * 
 * 5. 测试策略：
 *    - 应包含边界测试(空数组、单元素、全相同元素等)
 *    - 应包含性能测试(大规模数据)
 *    - 应包含正确性测试(已知结果的测试用例)
 */