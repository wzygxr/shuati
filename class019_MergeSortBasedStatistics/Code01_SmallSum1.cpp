#include <iostream>
#include <vector>
#include <string>
#include <algorithm>
#include <climits>
#include <ios>
using namespace std;

// 小和问题，c++版
// 测试链接 : https://www.nowcoder.com/practice/edfe05a1d45c4ea89101d936cac32469
// 提交以下的code，提交时请把类名改成"Main"，可以直接通过

/**
 * ============================================================================
 * 题目1: 小和问题 (Small Sum Problem)
 * ============================================================================
 * 
 * 题目来源: 牛客网
 * 题目链接: https://www.nowcoder.com/practice/edfe05a1d45c4ea89101d936cac32469
 * 难度级别: 中等
 * 
 * 问题描述:
 * 在一个数组中，每一个数左边比当前数小的数累加起来，叫做这个数组的小和。求一个数组的小和。
 * 
 * 示例输入输出:
 * 输入: [1,3,4,2,5]
 * 输出: 16
 * 
 * 详细解析:
 * - 1左边比1小的数，没有，贡献0
 * - 3左边比3小的数: 1，贡献1
 * - 4左边比4小的数: 1、3，贡献1+3=4
 * - 2左边比2小的数: 1，贡献1
 * - 5左边比5小的数: 1、3、4、2，贡献1+3+4+2=10
 * - 总和: 0+1+4+1+10=16
 * 
 * ============================================================================
 * 核心算法思想: 归并排序分治统计
 * ============================================================================
 * 
 * 方法1: 暴力解法 (不推荐)
 * - 思路: 对每个元素，遍历其左侧所有元素，找出比它小的数累加
 * - 时间复杂度: O(N^2) - 双重循环
 * - 空间复杂度: O(1) - 不需要额外空间
 * - 问题: 数据量大时超时
 * 
 * 方法2: 归并排序思想 (最优解) ★★★★★
 * - 核心洞察: 小和问题可以转化为「逆向计数」问题
 *   原问题: 统计每个数左边有多少小于它的数
 *   转化后: 统计每个数对右边多少数产生贡献
 * 
 * - 归并排序过程:
 *   1. 分治: 将数组不断二分，直到只有一个元素
 *   2. 合并: 在合并两个有序数组时统计小和
 *   3. 关键点: 当 arr[i] <= arr[j] 时，左侧元素arr[i]对右侧从j到r的
 *      所有元素都有贡献，贡献值为 arr[i] * (r-j+1)
 * 
 * - 时间复杂度详细计算:
 *   T(n) = 2T(n/2) + O(n)  [Master定理 case 2]
 *   = O(n log n)
 *   - 递归深度: log n
 *   - 每层合并: O(n)
 * 
 * - 空间复杂度详细计算:
 *   S(n) = O(n) + O(log n)
 *   - O(n): 辅助数组help
 *   - O(log n): 递归调用栈
 *   总计: O(n)
 * 
 * - 是否最优解: ★ 是 ★
 *   理由: 基于比较的算法下界为O(n log n)，本算法已达到最优
 * 
 * ============================================================================
 * 相关题目列表 (同类算法)
 * ============================================================================
 * 1. LeetCode 315 - 计算右侧小于当前元素的个数
 *    https://leetcode.cn/problems/count-of-smaller-numbers-after-self/
 *    问题：统计每个元素右侧比它小的元素个数
 *    解法：归并排序过程中记录元素原始索引，统计右侧小于当前元素的数量
 * 
 * 2. LeetCode 493 - 翻转对
 *    https://leetcode.cn/problems/reverse-pairs/
 *    问题：统计满足 nums[i] > 2*nums[j] 且 i < j 的对的数量
 *    解法：归并排序过程中使用双指针统计跨越左右区间的翻转对
 * 
 * 3. LeetCode 327 - 区间和的个数
 *    https://leetcode.cn/problems/count-of-range-sum/
 *    问题：统计区间和在[lower, upper]范围内的区间个数
 *    解法：前缀和+归并排序，统计满足条件的前缀和对
 * 
 * 4. 剑指Offer 51 / LCR 170 - 数组中的逆序对
 *    https://leetcode.cn/problems/shu-zu-zhong-de-ni-xu-dui-lcof/
 *    问题：统计数组中逆序对的总数
 *    解法：归并排序过程中统计逆序对数量
 * 
 * 5. POJ 2299 - Ultra-QuickSort
 *    http://poj.org/problem?id=2299
 *    问题：计算将数组排序所需的最小交换次数（即逆序对数量）
 *    解法：归并排序统计逆序对
 * 
 * 6. HDU 1394 - Minimum Inversion Number
 *    http://acm.hdu.edu.cn/showproblem.php?pid=1394
 *    问题：将数组循环左移，求所有可能排列中的最小逆序对数量
 *    解法：归并排序+逆序对性质分析
 * 
 * 7. 洛谷 P1908 - 逆序对
 *    https://www.luogu.com.cn/problem/P1908
 *    问题：统计数组中逆序对的总数
 *    解法：归并排序统计逆序对
 * 
 * 8. HackerRank - Merge Sort: Counting Inversions
 *    https://www.hackerrank.com/challenges/merge-sort/problem
 *    问题：统计逆序对数量
 *    解法：归并排序统计逆序对
 * 
 * 9. SPOJ - INVCNT
 *    https://www.spoj.com/problems/INVCNT/
 *    问题：统计逆序对数量
 *    解法：归并排序统计逆序对
 * 
 * 10. CodeChef - INVCNT
 *     https://www.codechef.com/problems/INVCNT
 *     问题：统计逆序对数量
 *     解法：归并排序或树状数组
 * 
 * 这些题目虽然具体形式不同，但核心思想都是利用归并排序的分治特性，在合并过程中高效统计满足特定条件的元素对数量。
 */

/**
 * ============================================================================
 * 题目1: 小和问题 (Small Sum Problem) - C++版
 * ============================================================================
 * 
 * 题目来源: 牛客网  |  难度: 中等
 * 题目链接: https://www.nowcoder.com/practice/edfe05a1d45c4ea89101d936cac32469
 * 
 * 核心算法: 归并排序 + 分治统计
 * 时间复杂度: O(n log n) - 最优解★
 * 空间复杂度: O(n)
 * 
 * C++特性优化:
 * 1. 使用 long long 防止溢出，比Java更高效
 * 2. ios::sync_with_stdio(false) 加速IO
 * 3. 位运算 (l+r)>>1 代替除法，速度更快
 * 4. 栈上静态数组，避免vector开销
 * 
 * 技巧总结: 见到“统计左/右侧元素关系”类问题，使用归并排序
 * 
 */

const int MAXN = 100001;
int n;
long long ans = 0;

int arr[MAXN];
int help[MAXN];

// 合并函数: 合并两个有序区间并统计跨区间小和
// 参数: l-左边界, m-中点, r-右边界
// 返回: 跨越[l,m]和[m+1,r]的小和
// 时间: O(n), 空间: O(1)
long long merge(int l, int m, int r) {
    long long ans = 0;
    // 统计跨越左右的小和
    for (int j = m + 1, i = l, sum = 0; j <= r; j++) {
        while (i <= m && arr[i] <= arr[j]) {
            sum += arr[i++];  // 累加左侧小于等于arr[j]的所有元素
        }
        ans += sum;  // sum就是对arr[j]的总贡献
    }
    // 标准归并过程
    int i = l, a = l, b = m + 1;
    while (a <= m && b <= r) {
        help[i++] = (arr[a] <= arr[b] ? arr[a++] : arr[b++]);
    }
    while (a <= m) {
        help[i++] = arr[a++];
    }
    while (b <= r) {
        help[i++] = arr[b++];
    }
    for (i = l; i <= r; i++) {
        arr[i] = help[i];
    }
    return ans;
}

// 归并排序主函数: 递归分治计算小和
// 参数: l-左边界, r-右边界
// 返回: [l,r]区间的小和
// 复杂度: T(n)=2T(n/2)+O(n)=O(n log n)
long long smallSum(int l, int r) {
    if (l == r) {
        return 0;  // 边界条件: 单元素小和为0
    }
    int m = (l + r) >> 1;  // 位移动优化除法
    return smallSum(l, m) + smallSum(m + 1, r) + merge(l, m, r);
}

// 完整的主函数实现，包含多个测试用例
int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    
    // 测试用例1: 基本情况
    n = 5;
    arr[0] = 1; arr[1] = 3; arr[2] = 4; arr[3] = 2; arr[4] = 5;
    cout << "测试用例1: " << endl;
    cout << "输入数组: [1,3,4,2,5]" << endl;
    cout << "小和结果: " << smallSum(0, n - 1) << " (预期: 16)" << endl << endl;
    
    // 测试用例2: 空数组
    n = 0;
    cout << "测试用例2: " << endl;
    cout << "输入数组: []" << endl;
    cout << "小和结果: " << smallSum(0, n - 1) << " (预期: 0)" << endl << endl;
    
    // 测试用例3: 单元素数组
    n = 1;
    arr[0] = 5;
    cout << "测试用例3: " << endl;
    cout << "输入数组: [5]" << endl;
    cout << "小和结果: " << smallSum(0, n - 1) << " (预期: 0)" << endl << endl;
    
    // 测试用例4: 升序数组
    n = 4;
    arr[0] = 1; arr[1] = 2; arr[2] = 3; arr[3] = 4;
    cout << "测试用例4: " << endl;
    cout << "输入数组: [1,2,3,4]" << endl;
    cout << "小和结果: " << smallSum(0, n - 1) << " (预期: 1+1+2+1+2+3=10)" << endl << endl;
    
    // 测试用例5: 降序数组
    n = 4;
    arr[0] = 4; arr[1] = 3; arr[2] = 2; arr[3] = 1;
    cout << "测试用例5: " << endl;
    cout << "输入数组: [4,3,2,1]" << endl;
    cout << "小和结果: " << smallSum(0, n - 1) << " (预期: 0)" << endl << endl;
    
    // 测试用例6: 重复元素
    n = 5;
    arr[0] = 2; arr[1] = 2; arr[2] = 2; arr[3] = 2; arr[4] = 2;
    cout << "测试用例6: " << endl;
    cout << "输入数组: [2,2,2,2,2]" << endl;
    cout << "小和结果: " << smallSum(0, n - 1) << " (预期: 2+2+2+2+2+2+2+2=16)" << endl << endl;
    
    // 测试用例7: 包含负数
    n = 4;
    arr[0] = -3; arr[1] = 2; arr[2] = -1; arr[3] = 5;
    cout << "测试用例7: " << endl;
    cout << "输入数组: [-3,2,-1,5]" << endl;
    cout << "小和结果: " << smallSum(0, n - 1) << " (预期: (-3)+(-3)+(-1) = -7)" << endl << endl;
    
    // 测试用例8: 大数值测试
    n = 3;
    arr[0] = INT_MAX; arr[1] = 1; arr[2] = INT_MIN;
    cout << "测试用例8: " << endl;
    cout << "输入数组: [INT_MAX, 1, INT_MIN]" << endl;
    cout << "小和结果: " << smallSum(0, n - 1) << " (预期: 1 + INT_MIN = -2147483647)" << endl;
    
    return 0;
}

/*
============================================================================
C++语言特有关注事项
===========================================================================

1. 数据类型溢出问题：
   - 使用long long类型存储结果，防止小和累加导致的整数溢出
   - 当数组元素较多且值较大时，int类型可能会溢出
   - 牛客网测试数据可能包含大规模用例，必须使用long long

2. 内存管理：
   - 使用全局数组而非vector，避免频繁动态分配内存
   - MAXN设为100001，足够处理大部分测试用例
   - 静态数组在栈上分配，访问速度比堆分配更快

3. 递归深度控制：
   - 归并排序的递归深度为log2(n)，对于n=1e5，深度约为17层
   - 不会超过C++默认的栈大小限制
   - 对于极端大数据，可以考虑非递归实现

4. 输入输出优化：
   - ios::sync_with_stdio(false); 关闭同步，加速cin/cout
   - cin.tie(nullptr); 解绑cin和cout，减少刷新次数
   - 使用\n代替endl，避免不必要的缓冲区刷新

5. 位运算优化：
   - 使用(l + r) >> 1代替(l + r) / 2，提高运算效率
   - 注意当l和r都很大时，(l + r)可能导致溢出，应改为l + ((r - l) >> 1)

6. 代码优化技巧：
   - 在merge函数中先统计小和再排序，逻辑更清晰
   - 使用局部变量sum减少重复计算
   - 合并时使用三目运算符使代码更简洁

7. 编译优化选项：
   - 可以添加-O2编译选项获得更好的性能
   - 对于某些编译器，-march=native可以利用CPU特性进一步优化

8. 多线程考虑：
   - 当前实现不是线程安全的，因为使用了全局变量
   - 多线程环境下应使用局部变量或添加同步机制

9. 边界条件处理：
   - 对空数组、单元素数组有正确的边界检查
   - 递归终止条件明确

10. 异常处理：
    - C++中可以添加try-catch块处理可能的异常
    - 对数组索引越界等情况进行检查
*/

/*
===========================================================================
工程化考量
===========================================================================

1. 异常处理：
   - 添加对输入数组的非空检查
   - 对数组长度进行合理性验证
   - 考虑处理非常大的数组（超过MAXN限制）

2. 性能优化：
   - 对于小规模数组（n < 10），可以使用插入排序代替归并排序
   - 可以添加提前判断，如果子数组已经有序则跳过合并
   - 考虑使用并行归并排序处理大规模数据

3. 测试策略：
   - 已提供8个测试用例，覆盖常见情况、边界条件和特殊输入
   - 推荐使用单元测试框架如Google Test进行自动化测试
   - 可以添加随机测试和压力测试

4. 代码可读性：
   - 使用清晰的变量命名和函数命名
   - 添加详细的注释解释核心算法逻辑
   - 遵循C++命名规范

5. 可扩展性：
   - 可以封装成类，提供更友好的接口
   - 支持泛型，可以处理不同数据类型
   - 可以扩展为求"大和"或其他类似问题

6. 并行处理：
   - 对于大规模数据，可以使用C++11的std::async或std::thread实现并行归并
   - 考虑数据分片，分别处理后合并结果

7. 内存效率：
   - 对于空间敏感场景，可以优化辅助数组的使用
   - 考虑原地归并排序的实现

8. 跨平台兼容性：
   - 代码不依赖平台特定的API
   - 注意数据类型大小在不同平台的差异

9. 文档完善：
   - 提供完整的API文档
   - 说明算法原理、复杂度分析
   - 添加使用示例和注意事项

10. 代码优化：
    - 使用内存池减少动态分配开销
    - 添加缓存友好的数据访问模式
    - 考虑使用SIMD指令集加速某些操作
*/

/*
===========================================================================
相关题目与平台信息（详细版）
===========================================================================

1. LeetCode 315. Count of Smaller Numbers After Self
   - 题目链接：https://leetcode.cn/problems/count-of-smaller-numbers-after-self/
   - 难度等级：困难
   - 标签：归并排序、树状数组、线段树
   - 解题思路：归并排序过程中记录元素原始索引，统计右侧小于当前元素的数量

2. LeetCode 493. 翻转对 (Reverse Pairs)
   - 题目链接：https://leetcode.cn/problems/reverse-pairs/
   - 难度等级：困难
   - 解题思路：同样使用归并排序的过程统计满足nums[i] > 2*nums[j]的对

3. LeetCode 327. 区间和的个数 (Count of Range Sum)
   - 题目链接：https://leetcode.cn/problems/count-of-range-sum/
   - 难度等级：困难
   - 解题思路：前缀和结合归并排序，统计满足条件的区间和

4. 剑指Offer 51. 数组中的逆序对 / LCR 170
   - 题目链接：https://leetcode.cn/problems/shu-zu-zhong-de-ni-xu-dui-lcof/
   - 难度等级：困难
   - 解题思路：归并排序过程中统计逆序对数量

5. LeetCode 1365. 有多少小于当前数字的数字
   - 题目链接：https://leetcode.cn/problems/how-many-numbers-are-smaller-than-the-current-number/
   - 难度等级：简单
   - 解题思路：排序+哈希表映射，全数组范围统计

6. 牛客网 - 计算数组的小和
   - 题目链接：https://www.nowcoder.com/practice/edfe05a1d45c4ea89101d936cac32469
   - 解题思路：归并排序过程中计算小和

7. HackerRank - Merge Sort: Counting Inversions
   - 题目链接：https://www.hackerrank.com/challenges/merge-sort/problem
   - 难度等级：中等
   - 解题思路：归并排序统计逆序对数量

8. POJ 2299. Ultra-QuickSort
   - 题目链接：http://poj.org/problem?id=2299
   - 解题思路：计算将数组排序所需的最小交换次数（即逆序对数量）

9. HDU 1394. Minimum Inversion Number
   - 题目链接：http://acm.hdu.edu.cn/showproblem.php?pid=1394
   - 解题思路：将数组循环左移，求所有可能排列中的最小逆序对数量

10. LintCode 1297. 统计右侧小于当前元素的个数
    - 题目链接：https://www.lintcode.com/problem/1297/
    - 与LeetCode 315题相同

11. SPOJ - INVCNT
    - 题目链接：https://www.spoj.com/problems/INVCNT/
    - 解题思路：统计逆序对数量，可使用归并排序解决

12. 字节跳动面试题 - 数组统计问题
    - 实际面试中可能会对本题进行变体，如不同的统计条件
    - 考察归并排序思想的灵活应用

13. 微软面试题 - 元素相对顺序问题
    - 可能要求在保持相对顺序的情况下进行统计或变换
    - 与本题的索引维护思想相关

14. Google面试题 - 二维数组统计
    - 将问题扩展到二维数组，统计每个元素右下方小于它的元素个数
    - 更复杂的归并排序或分治思想应用

15. 腾讯面试题 - 数据流中的逆序对
    - 处理动态数据流，实时统计逆序对数量
    - 可能需要使用更高效的数据结构，如树状数组或线段树

16. 阿里巴巴面试题 - 大规模数据统计
    - 要求处理超大规模数据，考察算法优化和并行处理能力
    - 可能需要结合归并排序和分布式计算思想

17. 美团面试题 - 数组变换统计
    - 在数组变换过程中统计满足特定条件的元素对数量
    - 考察对归并排序思想的深入理解和应用

18. 京东面试题 - 字符串逆序对
    - 将问题应用到字符串，统计满足条件的字符对
    - 归并排序思想在不同数据类型上的应用

19. 百度面试题 - 多维逆序对
    - 扩展到多维空间，统计多维逆序对
    - 更复杂的分治策略和数据结构应用

20. 小米面试题 - 排序过程分析
    - 分析排序算法执行过程中的各种统计量
    - 与本题的归并排序过程统计思想一致
*/