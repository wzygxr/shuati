# Hash Function 哈希函数

本目录包含哈希函数相关的算法实现，涵盖了基础和高级哈希技术，包括哈希表、哈希冲突解决、滚动哈希、一致性哈希、布隆过滤器等多种应用场景。

## 目录结构

- `HashFunction.java`: Java实现
- `HashFunction.cpp`: C++实现  
- `HashFunction.py`: Python实现

## 实现的问题

### LintCode 128. Hash Function
- **问题描述**：实现一个基于33的哈希函数
- **算法思路**：使用霍纳法则优化计算
- **时间复杂度**：O(n)
- **空间复杂度**：O(1)

### LeetCode 28. Find the Index of the First Occurrence in a String
- **问题描述**：实现字符串匹配算法
- **算法思路**：使用Rabin-Karp滚动哈希算法
- **时间复杂度**：O(n+m)
- **空间复杂度**：O(1)

### LeetCode 187. Repeated DNA Sequences
- **问题描述**：找到DNA序列中重复出现的长度为10的子串
- **算法思路**：使用滚动哈希技术结合哈希表
- **时间复杂度**：O(n)
- **空间复杂度**：O(n)

### LeetCode 214. Shortest Palindrome
- **问题描述**：通过在字符串前面添加字符转换为最短回文串
- **算法思路**：使用滚动哈希技术找到最长前缀回文串
- **时间复杂度**：O(n)
- **空间复杂度**：O(n)

### LeetCode 705. Design HashSet
- **问题描述**：设计实现一个哈希集合
- **算法思路**：使用链地址法解决哈希冲突
- **时间复杂度**：O(n/b)，其中n是元素个数，b是桶数
- **空间复杂度**：O(n)

### LeetCode 706. Design HashMap
- **问题描述**：设计实现一个哈希映射
- **算法思路**：使用链地址法解决哈希冲突
- **时间复杂度**：O(n/b)，其中n是元素个数，b是桶数
- **空间复杂度**：O(n)

## 高级哈希技术实现

### 一致性哈希 (Consistent Hashing)
- **核心概念**：将服务器和键映射到一个虚拟环上，每个键顺时针分配给最近的服务器
- **主要特点**：
  - 支持虚拟节点以提高负载均衡性
  - 服务器添加/删除时最小化数据迁移
  - 适用于分布式缓存、数据库分片等场景
- **实现特性**：
  - 使用FNV-1a哈希算法提供良好分布性
  - 优化的数据结构实现以加速查找
  - 支持动态添加和删除节点
- **应用场景**：Redis集群、Memcached集群、CDN节点分配等

### 布隆过滤器 (Bloom Filter)
- **核心概念**：使用多个哈希函数将元素映射到位数组，用于快速判断元素是否可能存在
- **主要特点**：
  - 空间效率高，不需要存储元素本身
  - 存在一定的误判率，但不会漏判（false positives possible, false negatives impossible）
  - 删除操作困难
- **实现特性**：
  - 可配置的哈希函数数量和位数组大小
  - 支持动态调整参数以平衡误判率和空间使用
  - 高效的哈希计算算法
- **应用场景**：缓存穿透防护、垃圾邮件过滤、爬虫URL去重等

### 双重哈希 (Double Hashing)
- **核心概念**：使用两个不同的哈希函数确定探测序列，优化开放寻址法的性能
- **主要特点**：
  - 减少了主聚集和次聚集问题
  - 提供更好的分布性和查询性能
  - 适用于需要高效冲突解决的场景
- **实现特性**：
  - 优化的哈希函数选择以减少冲突
  - 动态扩容机制管理负载因子
  - 高效的探测序列生成
- **应用场景**：高性能哈希表实现、内存数据库等

## 哈希函数基础概念

### 哈希函数的性质

1. **确定性**：相同的输入总是产生相同的输出
2. **高效性**：计算哈希值的时间复杂度为O(1)或接近O(1)
3. **均匀分布**：输出值应该均匀分布在可能的取值范围内
4. **不可逆性**：从哈希值难以推导出原始输入（对于密码学哈希函数）

### 哈希冲突解决方法

1. **链地址法（Separate Chaining）**：每个哈希桶存储一个链表，发生冲突时将元素添加到链表末尾
2. **开放寻址法（Open Addressing）**：当发生冲突时，寻找其他空槽位
   - 线性探测（Linear Probing）
   - 二次探测（Quadratic Probing）
   - 双重哈希（Double Hashing）
3. **再哈希法（Rehashing）**：当负载因子过高时，重新哈希并调整哈希表大小

### 常见哈希算法

1. **MD5**：消息摘要算法，生成128位哈希值
2. **SHA系列**：安全哈希算法家族（SHA-1, SHA-256等）
3. **FNV-1a**：非加密哈希函数，广泛用于哈希表实现
4. **MurmurHash**：针对性能和分布均匀性优化的哈希算法

## 实际应用场景

1. **数据检索**：快速查找、插入和删除操作
2. **缓存系统**：如Redis、Memcached等使用哈希表进行高效数据存储
3. **分布式系统**：一致性哈希用于负载均衡和数据分片
4. **缓存优化**：布隆过滤器用于防止缓存穿透
5. **密码存储**：存储密码的哈希值而非明文
6. **数据去重**：识别重复数据
7. **字符串匹配**：滚动哈希用于高效子串查找

## 算法设计思路

### 哈希函数选择

在实现中，我们根据不同的应用场景选择合适的哈希函数：

- **简单哈希函数**：用于基础哈希表实现，如LintCode 128
- **滚动哈希**：用于字符串匹配和子串查找，如LeetCode 28和187
- **FNV-1a**：用于一致性哈希实现，提供良好的分布性
- **多次哈希**：用于布隆过滤器，减少误判率
- **双重哈希**：用于高效解决哈希冲突

### 哈希冲突解决

对于哈希冲突，我们主要使用以下方法：

- **链地址法**：用于LeetCode 705和706的哈希表实现
- **开放寻址法**：在高级哈希表中使用双重哈希优化性能
- **虚拟节点**：在一致性哈希中使用虚拟节点减少哈希冲突

### 性能优化

为了提高哈希表性能，我们采用以下优化策略：

- **负载因子管理**：当负载因子超过阈值时进行扩容
- **预分配空间**：为哈希表预先分配适当的空间
- **哈希函数优化**：选择具有良好分布性的哈希函数
- **惰性删除**：在某些实现中使用标记删除而非物理删除

## 跨语言实现一致性

所有算法都在Java、C++和Python中实现，确保跨语言一致性：

- **接口设计**：提供统一的接口和方法签名
- **算法实现**：保持相同的算法思路和数据结构
- **测试用例**：使用相同的测试用例验证不同语言的实现
- **性能特性**：在各语言中保持相似的时间和空间复杂度

## 运行示例

```bash
# Java示例
javac HashFunction.java
java HashFunction

# C++示例
g++ HashFunction.cpp -o HashFunction
./HashFunction

# Python示例
python HashFunction.py
```

## 测试用例

每个实现都包含了全面的测试用例，覆盖了各种边界情况和典型应用场景：

- 空输入测试
- 边界条件测试
- 冲突情况测试
- 性能测试
- 特殊输入测试（如重复元素、极限情况等）

## 更多哈希相关题目实现

### LeetCode 1. Two Sum (两数之和)
- **问题来源**: https://leetcode.com/problems/two-sum/
- **问题描述**: 给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出和为目标值 target 的那两个整数，并返回它们的数组下标。
- **算法思路**: 使用哈希表存储每个数字及其对应的索引，遍历数组时检查target - nums[i]是否在哈希表中
- **时间复杂度**: O(n)
- **空间复杂度**: O(n)

### LeetCode 49. Group Anagrams (字母异位词分组)
- **问题来源**: https://leetcode.com/problems/group-anagrams/
- **问题描述**: 给你一个字符串数组，请你将字母异位词组合在一起。可以按任意顺序返回结果列表。
- **算法思路**: 使用排序后的字符串作为哈希表的键，将具有相同排序字符串的单词分组
- **时间复杂度**: O(n * k log k)，其中n是字符串数量，k是字符串最大长度
- **空间复杂度**: O(n * k)

### LeetCode 242. Valid Anagram (有效的字母异位词)
- **问题来源**: https://leetcode.com/problems/valid-anagram/
- **问题描述**: 给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。
- **算法思路**: 使用哈希表统计每个字符出现的次数，然后比较两个字符串的字符频率
- **时间复杂度**: O(n)
- **空间复杂度**: O(1)，因为字符集大小固定为26

### LeetCode 3. Longest Substring Without Repeating Characters (无重复字符的最长子串)
- **问题来源**: https://leetcode.com/problems/longest-substring-without-repeating-characters/
- **问题描述**: 给定一个字符串 s ，请你找出其中不含有重复字符的最长子串的长度。
- **算法思路**: 使用滑动窗口和哈希表记录字符最后出现的位置
- **时间复杂度**: O(n)
- **空间复杂度**: O(min(m, n))，其中m是字符集大小

### LeetCode 76. Minimum Window Substring (最小覆盖子串)
- **问题来源**: https://leetcode.com/problems/minimum-window-substring/
- **问题描述**: 给你一个字符串 s 、一个字符串 t 。返回 s 中涵盖 t 所有字符的最小子串。
- **算法思路**: 使用滑动窗口和哈希表统计字符频率，维护一个计数器记录还需要匹配的字符数量
- **时间复杂度**: O(m + n)
- **空间复杂度**: O(m + n)

### LeetCode 560. Subarray Sum Equals K (和为K的子数组)
- **问题来源**: https://leetcode.com/problems/subarray-sum-equals-k/
- **问题描述**: 给你一个整数数组 nums 和一个整数 k ，请你统计并返回该数组中和为 k 的连续子数组的个数。
- **算法思路**: 使用前缀和和哈希表，记录每个前缀和出现的次数
- **时间复杂度**: O(n)
- **空间复杂度**: O(n)

### LeetCode 347. Top K Frequent Elements (前K个高频元素)
- **问题来源**: https://leetcode.com/problems/top-k-frequent-elements/
- **问题描述**: 给你一个整数数组 nums 和一个整数 k ，请你返回其中出现频率前 k 高的元素。
- **算法思路**: 使用哈希表统计频率，然后使用桶排序或优先队列找出前k个高频元素
- **时间复杂度**: O(n log k)
- **空间复杂度**: O(n)

### LeetCode 380. Insert Delete GetRandom O(1) (常数时间插入、删除和获取随机元素)
- **问题来源**: https://leetcode.com/problems/insert-delete-getrandom-o1/
- **问题描述**: 实现RandomizedSet类，支持在常数时间内插入、删除和获取随机元素。
- **算法思路**: 使用哈希表存储值和索引的映射，使用动态数组存储值
- **时间复杂度**: O(1) 平均时间复杂度
- **空间复杂度**: O(n)

### LeetCode 146. LRU Cache (LRU缓存)
- **问题来源**: https://leetcode.com/problems/lru-cache/
- **问题描述**: 设计并实现一个满足 LRU (最近最少使用) 缓存约束的数据结构。
- **算法思路**: 使用哈希表+双向链表实现，哈希表提供O(1)的查找，双向链表维护访问顺序
- **时间复杂度**: O(1)
- **空间复杂度**: O(capacity)

## 哈希算法应用场景总结

### 1. 数据检索与存储
- **哈希表**: 快速查找、插入和删除操作
- **分布式哈希表**: 大规模分布式系统中的数据存储和检索

### 2. 字符串处理
- **字符串匹配**: Rabin-Karp算法用于高效子串查找
- **重复检测**: 检测重复字符串或DNA序列
- **回文检测**: 使用滚动哈希检测回文串

### 3. 缓存系统
- **LRU缓存**: 基于访问频率的缓存淘汰策略
- **分布式缓存**: 一致性哈希用于负载均衡
- **缓存穿透防护**: 布隆过滤器防止缓存穿透

### 4. 数据去重与统计
- **频率统计**: 统计元素出现频率
- **数据去重**: 识别重复数据
- **Top K问题**: 找出出现频率最高的元素

### 5. 安全与加密
- **密码存储**: 存储密码的哈希值而非明文
- **数据完整性**: 使用哈希值验证数据完整性
- **数字签名**: 基于哈希函数的数字签名算法

## 哈希算法性能优化策略

### 1. 哈希函数选择
- **简单哈希**: 适用于基础哈希表实现
- **加密哈希**: 适用于安全相关场景
- **滚动哈希**: 适用于字符串匹配和子串查找

### 2. 冲突解决策略
- **链地址法**: 适用于大多数场景，实现简单
- **开放寻址法**: 适用于内存敏感场景
- **双重哈希**: 减少聚集现象，提高性能

### 3. 负载因子管理
- **动态扩容**: 当负载因子超过阈值时自动扩容
- **预分配空间**: 根据预期数据量预先分配适当空间
- **惰性删除**: 使用标记删除而非物理删除

### 4. 内存优化
- **位图压缩**: 布隆过滤器使用位数组节省空间
- **虚拟节点**: 一致性哈希使用虚拟节点提高负载均衡性
- **数据压缩**: 对存储的数据进行适当压缩

## 跨语言实现对比

### Java实现特点
- **内置支持**: 提供丰富的哈希相关类库
- **内存管理**: 自动垃圾回收，简化内存管理
- **线程安全**: 提供线程安全的哈希表实现

### C++实现特点
- **性能优化**: 直接内存操作，性能更高
- **模板支持**: 支持泛型编程，代码复用性高
- **标准库**: STL提供丰富的哈希相关容器

### Python实现特点
- **简洁语法**: 代码简洁，易于理解和维护
- **动态类型**: 无需声明变量类型，开发效率高
- **丰富库支持**: 提供多种哈希算法和数据结构

## 测试与验证

### 单元测试覆盖
- **边界测试**: 空输入、极限值测试
- **功能测试**: 基本功能验证
- **性能测试**: 时间复杂度和空间复杂度验证
- **并发测试**: 多线程环境下的正确性验证

### 正确性验证
- **算法正确性**: 确保算法逻辑正确
- **边界处理**: 正确处理各种边界情况
- **异常处理**: 对异常输入进行适当处理

## 各大平台哈希算法题目扩展

### Codeforces 271D - Good Substrings (好子串)
- **题目来源**: https://codeforces.com/problemset/problem/271/D
- **题目描述**: 给定一个字符串s和一个坏字符标记字符串bad，统计s中最多包含k个坏字符的不同子串数量
- **算法思路**: 使用滚动哈希技术计算所有子串的哈希值，结合坏字符计数进行筛选
- **时间复杂度**: O(n²)
- **空间复杂度**: O(n)

### Codeforces 514C - Watto and Mechanism (Watto和机制)
- **题目来源**: https://codeforces.com/problemset/problem/514/C
- **题目描述**: 给定一个字典和多个查询字符串，判断每个查询字符串是否可以通过修改字典中某个字符串的一个字符得到
- **算法思路**: 使用滚动哈希预计算字典中所有字符串的哈希值，查询时尝试修改每个位置的字符并检查哈希值
- **时间复杂度**: O(n + m * L)，其中n是字典大小，m是查询数量，L是字符串长度
- **空间复杂度**: O(n)

### Codeforces 835D - Palindromic characteristics (回文特性)
- **题目来源**: https://codeforces.com/problemset/problem/835/D
- **题目描述**: 定义k级回文串：1级回文串是普通回文串，k级回文串是回文串且前半部分是(k-1)级回文串
- **算法思路**: 使用滚动哈希判断回文串，同时使用动态规划计算回文级别
- **时间复杂度**: O(n²)
- **空间复杂度**: O(n²)

### 剑指Offer 50. 第一个只出现一次的字符
- **题目来源**: 剑指Offer面试题50
- **题目描述**: 在字符串s中找出第一个只出现一次的字符
- **算法思路**: 使用哈希表统计每个字符出现的次数，然后遍历字符串找到第一个出现次数为1的字符
- **时间复杂度**: O(n)
- **空间复杂度**: O(1)，因为字符集大小固定

### 剑指Offer 03. 数组中重复的数字
- **题目来源**: 剑指Offer面试题03
- **题目描述**: 在一个长度为n的数组里的所有数字都在0到n-1的范围内，找出数组中任意一个重复的数字
- **算法思路**: 使用哈希表记录已经访问过的数字，当遇到重复数字时返回
- **时间复杂度**: O(n)
- **空间复杂度**: O(n)

### 剑指Offer 48. 最长不含重复字符的子字符串
- **题目来源**: 剑指Offer面试题48
- **题目描述**: 请从字符串中找出一个最长的不包含重复字符的子字符串，计算该最长子字符串的长度
- **算法思路**: 使用滑动窗口和哈希表记录字符最后出现的位置
- **时间复杂度**: O(n)
- **空间复杂度**: O(min(m, n))，其中m是字符集大小

### HDU 4821 - String (字符串)
- **题目来源**: http://acm.hdu.edu.cn/showproblem.php?pid=4821
- **题目描述**: 给定字符串s和整数M、L，统计有多少个长度为M*L的子串，可以分成M个长度为L的不同子串
- **算法思路**: 使用滚动哈希计算所有长度为L的子串哈希值，然后滑动窗口统计满足条件的子串
- **时间复杂度**: O(n)
- **空间复杂度**: O(n)

### POJ 2774 - Long Long Message (最长公共子串)
- **题目来源**: http://poj.org/problem?id=2774
- **题目描述**: 给定两个字符串，求它们的最长公共子串长度
- **算法思路**: 使用二分答案+滚动哈希，检查是否存在长度为mid的公共子串
- **时间复杂度**: O(n log n)
- **空间复杂度**: O(n)

### SPOJ - SUBST1 (不同子串数量)
- **题目来源**: https://www.spoj.com/problems/SUBST1/
- **题目描述**: 给定一个字符串，计算其不同子串的数量
- **算法思路**: 使用滚动哈希计算所有子串的哈希值，使用哈希集合去重
- **时间复杂度**: O(n²)
- **空间复杂度**: O(n²)

### AtCoder ABC 284 E - Count Simple Paths (简单路径计数)
- **题目来源**: https://atcoder.jp/contests/abc284/tasks/abc284_e
- **题目描述**: 给定无向图，计算从节点1开始的不同简单路径数量
- **算法思路**: 使用DFS遍历所有路径，使用哈希集合记录路径的哈希值
- **时间复杂度**: O(2ⁿ)
- **空间复杂度**: O(n)

### USACO 2019 December Contest, Gold - Milk Visits (牛奶访问)
- **题目来源**: http://www.usaco.org/index.php?page=viewproblem2&cpid=970
- **题目描述**: 给定一棵树，每个节点有一种牛奶类型，查询从u到v的路径上是否包含特定类型的牛奶
- **算法思路**: 使用LCA和路径哈希，对每种牛奶类型建立哈希值
- **时间复杂度**: O(n + q log n)
- **空间复杂度**: O(n)

## 高级哈希应用实现

### 完美哈希 (Perfect Hashing)
- **应用场景**: 静态数据集，需要O(1)查找时间且无冲突
- **算法原理**: 使用两级哈希表，第一级哈希将元素分组，第二级为每个组创建无冲突的哈希表
- **优势**: 保证O(1)查找时间，无哈希冲突
- **限制**: 仅适用于静态数据集，构建过程较复杂

### 计数布隆过滤器 (Counting Bloom Filter)
- **应用场景**: 需要支持删除操作的布隆过滤器变种
- **算法原理**: 使用计数器数组代替位数组，支持元素的添加和删除
- **优势**: 支持删除操作，保持布隆过滤器的空间效率
- **限制**: 空间使用略高于标准布隆过滤器

### 可扩展哈希 (Extendible Hashing)
- **应用场景**: 数据库索引、文件系统等需要动态扩展的哈希结构
- **算法原理**: 使用目录结构指向桶，当桶满时进行分裂，目录深度动态调整
- **优势**: 支持动态扩展，保持较好的性能
- **限制**: 目录结构增加了一定的空间开销

### 线性哈希 (Linear Hashing)
- **应用场景**: 数据库系统、文件系统等需要渐进式扩展的哈希结构
- **算法原理**: 使用线性探测和分裂策略，避免目录结构的空间开销
- **优势**: 渐进式扩展，无目录结构开销
- **限制**: 分裂过程可能影响性能

### 完美哈希 (Perfect Hashing)
- **应用场景**: 静态数据集，需要O(1)查找时间且无冲突
- **算法原理**: 使用两级哈希表，第一级哈希将元素分组，第二级为每个组创建无冲突的哈希表
- **优势**: 保证O(1)查找时间，无哈希冲突
- **限制**: 仅适用于静态数据集，构建过程较复杂

### 计数布隆过滤器 (Counting Bloom Filter)
- **应用场景**: 需要支持删除操作的布隆过滤器变种
- **算法原理**: 使用计数器数组代替位数组，支持元素的添加和删除
- **优势**: 支持删除操作，保持布隆过滤器的空间效率
- **限制**: 空间使用略高于标准布隆过滤器

### 可扩展哈希 (Extendible Hashing)
- **应用场景**: 数据库索引、文件系统等需要动态扩展的哈希结构
- **算法原理**: 使用目录结构指向桶，当桶满时进行分裂，目录深度动态调整
- **优势**: 支持动态扩展，保持较好的性能
- **限制**: 目录结构增加了一定的空间开销

### 线性哈希 (Linear Hashing)
- **应用场景**: 数据库系统、文件系统等需要渐进式扩展的哈希结构
- **算法原理**: 使用线性探测和分裂策略，避免目录结构的空间开销
- **优势**: 渐进式扩展，无目录结构开销
- **限制**: 分裂过程可能影响性能

## 哈希算法工程化考量

### 1. 异常处理与边界场景
- **空输入处理**: 所有函数都正确处理空输入和边界值
- **溢出防护**: 使用大质数取模防止整数溢出
- **内存管理**: 合理管理内存分配和释放

### 2. 性能优化策略
- **常数优化**: 减少不必要的计算和内存访问
- **缓存友好**: 优化数据访问模式提高缓存命中率
- **并行化**: 支持多线程环境下的安全访问

### 3. 可配置性与扩展性
- **参数可调**: 哈希函数参数可根据需求调整
- **接口统一**: 提供一致的接口便于扩展
- **模块化设计**: 各组件独立，便于维护和测试

### 4. 测试与验证
- **单元测试**: 覆盖所有功能和边界情况
- **性能测试**: 验证时间复杂度和空间复杂度
- **压力测试**: 测试大规模数据下的表现

## 总结

本目录提供了从基础到高级的哈希技术实现，涵盖了哈希函数的核心概念、冲突解决方法、常见算法和实际应用场景。通过学习和使用这些实现，可以深入理解哈希技术在计算机科学中的重要性和多样性，以及如何在实际项目中选择和应用合适的哈希算法。

所有实现都经过了充分的测试和验证，确保在不同语言环境下的一致性和正确性。通过对比不同语言的实现，可以更好地理解哈希算法在不同编程环境下的应用特点和优化策略。

### 完全掌握哈希算法需要关注的方面

1. **理论基础**: 理解哈希函数的基本原理和数学基础
2. **算法实现**: 掌握各种哈希算法的实现细节和优化技巧
3. **工程实践**: 了解哈希算法在实际系统中的应用场景和挑战
4. **性能分析**: 能够分析哈希算法的性能特征和瓶颈
5. **安全考量**: 理解哈希函数在安全领域的应用和限制
6. **跨语言对比**: 掌握不同编程语言中哈希实现的差异
7. **调试技巧**: 具备调试哈希相关问题的能力
8. **优化策略**: 能够根据具体场景选择合适的哈希算法和参数

通过系统学习本目录中的所有实现，可以全面掌握哈希算法的理论和实践，为后续的算法学习和工程开发打下坚实基础。