package class031;

// 颠倒二进制位 - Reverse Bits
// 测试链接 : https://leetcode.cn/problems/reverse-bits/
// 相关题目:
// 1. 位1的个数 - Number of 1 Bits: https://leetcode.cn/problems/number-of-1-bits/
// 2. 2的幂 - Power of Two: https://leetcode.cn/problems/power-of-two/
// 3. 比特位计数 - Counting Bits: https://leetcode.cn/problems/counting-bits/
// 4. 汉明距离 - Hamming Distance: https://leetcode.cn/problems/hamming-distance/
// 5. 格雷编码 - Gray Code: https://leetcode.cn/problems/gray-code/

/*
题目描述：
颠倒给定的 32 位无符号整数的二进制位。

示例：
输入：n = 00000010100101000001111010011100
输出：964176192 (00111001011110000010100101000000)
解释：输入的二进制串 00000010100101000001111010011100 表示无符号整数 43261596，
因此返回 964176192，其二进制表示形式为 00111001011110000010100101000000。

输入：n = 11111111111111111111111111111101
输出：3221225471 (10111111111111111111111111111111)
解释：输入的二进制串 11111111111111111111111111111101 表示无符号整数 4294967293，
因此返回 3221225471 其二进制表示形式为 10111111111111111111111111111111 。

提示：
输入是一个长度为 32 的二进制字符串

解题思路：
这是一个经典的位运算问题，可以通过分治法来解决。
我们逐步交换相邻的位、相邻的两位、相邻的四位...直到交换整个32位。

具体步骤：
1. 交换相邻的位：0xaaaaaaaa = 10101010101010101010101010101010，0x55555555 = 01010101010101010101010101010101
2. 交换相邻的两位：0xcccccccc = 11001100110011001100110011001100，0x33333333 = 00110011001100110011001100110011
3. 交换相邻的四位：0xf0f0f0f0 = 11110000111100001111000011110000，0x0f0f0f0f = 00001111000011110000111100001111
4. 交换相邻的八位：0xff00ff00 = 11111111000000001111111100000000，0x00ff00ff = 00000000111111110000000011111111
5. 交换前十六位和后十六位

时间复杂度：O(1)
空间复杂度：O(1)

补充题目：
1. 洛谷 P10118 『STA - R4』And: https://www.luogu.com.cn/problem/P10118
2. 洛谷 P9451 [ZSHOI-R1] 新概念报数: https://www.luogu.com.cn/problem/P9451
3. 洛谷 P10114 [LMXOI Round 1] Size: https://www.luogu.com.cn/problem/P10114
4. 洛谷 P1469 找筷子: https://www.luogu.com.cn/problem/P1469
5. Codeforces 276D Little Girl and Maximum XOR: https://www.luogu.com.cn/problem/CF276D
*/
public class Code05_ReverseBits {

	/**
	 * 颠倒给定的32位无符号整数的二进制位
	 * 使用分治法：逐步交换相邻的位、相邻的两位、相邻的四位...直到交换整个32位
	 * 
	 * @param n 32位无符号整数
	 * @return 颠倒二进制位后的结果
	 */
	public static int reverseBits(int n) {
		// 交换相邻的位
		// 0xaaaaaaaa = 10101010101010101010101010101010 (偶数位为1)
		// 0x55555555 = 01010101010101010101010101010101 (奇数位为1)
		n = ((n & 0xaaaaaaaa) >>> 1) | ((n & 0x55555555) << 1);
		
		// 交换相邻的两位
		// 0xcccccccc = 11001100110011001100110011001100
		// 0x33333333 = 00110011001100110011001100110011
		n = ((n & 0xcccccccc) >>> 2) | ((n & 0x33333333) << 2);
		
		// 交换相邻的四位
		// 0xf0f0f0f0 = 11110000111100001111000011110000
		// 0x0f0f0f0f = 00001111000011110000111100001111
		n = ((n & 0xf0f0f0f0) >>> 4) | ((n & 0x0f0f0f0f) << 4);
		
		// 交换相邻的八位
		// 0xff00ff00 = 11111111000000001111111100000000
		// 0x00ff00ff = 00000000111111110000000011111111
		n = ((n & 0xff00ff00) >>> 8) | ((n & 0x00ff00ff) << 8);
		
		// 交换前十六位和后十六位
		n = (n >>> 16) | (n << 16);
		
		return n;
	}

}