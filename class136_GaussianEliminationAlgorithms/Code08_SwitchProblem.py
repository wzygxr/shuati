#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""
POJ 1830 开关问题 (Python版本)
题目链接：http://poj.org/problem?id=1830

题目大意：
有N个开关，每个开关都与某些开关有着联系
每当你打开或者关闭某个开关的时候，其他的与此开关相关联的开关也会相应地发生变化
给出开始状态和结束状态，求方案数

算法思路：
该问题可以建模为异或方程组问题：
1. 每个开关是否被按下表示为一个变量xi（0或1）
2. 每个开关的最终状态由初始状态和受影响的开关决定
3. 通过高斯消元法求解异或方程组
4. 自由变量的数量决定了解的总数（每个自由变量有两种选择）

数学建模：
- 设xi表示第i个开关是否被按下（1表示按下，0表示不按下）
- 设aij表示按下第j个开关对第i个开关的影响（1表示有影响，0表示无影响）
- 设bi表示第i个开关的初始状态与目标状态的异或值
- 则有方程：a11*x1 XOR a12*x2 XOR ... XOR a1n*xn = b1
            a21*x1 XOR a22*x2 XOR ... XOR a2n*xn = b2
            ...
            an1*x1 XOR an2*x2 XOR ... XOR ann*xn = bn

时间复杂度：O(n³)，其中n为开关数量
空间复杂度：O(n²)，主要用于存储增广矩阵

解题要点：
- 使用异或运算处理开关状态转换（0表示不变，1表示改变）
- 构建正确的系数矩阵表示开关之间的影响关系
- 处理自由变量以计算解的总数
"""

import sys
import math

# 常量定义
# 最大开关数量+1，题目中N<=30
MAXN = 35

# 增广矩阵，用于高斯消元求解异或方程组
# mat[i][j] 表示第i个方程中第j个变量的系数
# mat[i][n+1] 表示第i个方程的常数项
mat = [[0 for _ in range(MAXN)] for _ in range(MAXN)]

# 结果数组，存储每个开关是否被按下（1表示按下，0表示不按下）
result = [0 for _ in range(MAXN)]

# 当前测试用例的开关数量
n = 0


def gauss():
    """
    高斯消元法求解异或方程组
    时间复杂度: O(n³)
    空间复杂度: O(n²)
    
    异或方程组形式：
    a11*x1 XOR a12*x2 XOR ... XOR a1n*xn = b1
    a21*x1 XOR a22*x2 XOR ... XOR a2n*xn = b2
    ...
    an1*x1 XOR an2*x2 XOR ... XOR ann*xn = bn
    
    其中：
    - xi表示第i个开关是否需要按下（1表示按下，0表示不按下）
    - aij表示按下第j个开关对第i个开关的影响（1表示有影响，0表示无影响）
    - bi表示第i个开关的初始状态与目标状态的异或值
    
    算法步骤：
    1. 前向消元：将增广矩阵转换为上三角形式
       - 对每一列寻找主元（系数为1的行）
       - 交换行使主元位于对角线上
       - 用主元行消除其他行在该列的系数
    2. 检查解的存在性：寻找矛盾方程
    3. 回代求解：从最后一行开始计算变量值
    
    Returns:
        int: 自由变元的数量，返回-1表示无解
    """
    global n
    free_num = 0  # 自由变元个数
    
    # 前向消元过程 - 对每一列进行处理
    for i in range(1, n + 1):
        # 寻找第i列中系数为1的行，将其作为主元行
        pivot_row = i
        for j in range(i + 1, n + 1):
            if mat[j][i] == 1:
                pivot_row = j
                break
        
        # 如果找不到系数为1的行，则当前变量为自由变量
        if mat[pivot_row][i] == 0:
            free_num += 1  # 统计自由变量数量
            continue       # 跳过当前列，处理下一列
        
        # 将找到的主元行与当前处理行交换
        if pivot_row != i:
            for j in range(1, n + 2):  # 包括增广部分
                mat[i][j], mat[pivot_row][j] = mat[pivot_row][j], mat[i][j]
        
        # 用主元行消除其他所有行在第i列的系数
        for j in range(1, n + 1):
            # 跳过主元行本身
            if i != j and mat[j][i] == 1:
                # 对整行进行异或操作，消除第i列的系数
                for k in range(1, n + 2):
                    mat[j][k] ^= mat[i][k]  # 异或操作是线性代数中加法的等价操作
    
    # 检查是否有矛盾方程（无解情况）
    # 寻找系数全为0但常数项不为0的行
    for i in range(n - free_num + 1, n + 1):
        if mat[i][n + 1] != 0:
            return -1  # 无解
    
    # 回代求解主元变量
    for i in range(n - free_num, 0, -1):
        result[i] = mat[i][n + 1]  # 初始值为主元方程的常数项
        # 减去其他已求解变量的影响
        for j in range(i + 1, n + 1):
            if mat[i][j] == 1:  # 只有当系数为1时才需要异或
                result[i] ^= result[j]
    
    # 自由变量的取值不影响方程组的一致性，可以取0或1
    # 此处未设置自由变量的值，它们的不同取值对应不同的解
    
    return free_num  # 返回自由变元个数，解的总数为2^free_num


def main():
    """
    主函数
    处理输入、构建方程组、调用高斯消元并输出结果
    
    处理流程：
    1. 读取测试用例数量
    2. 对于每个测试用例：
       a. 读取开关数量
       b. 初始化矩阵
       c. 读取初始状态和目标状态
       d. 构建增广矩阵
       e. 读取开关之间的关系
       f. 调用高斯消元求解
       g. 输出结果
    """
    global n
    
    # 读取测试用例数量
    cases = int(sys.stdin.readline().strip())
    
    # 处理每个测试用例
    for t in range(1, cases + 1):
        # 读取开关数量
        n = int(sys.stdin.readline().strip())
        
        # 初始化矩阵为0
        for i in range(1, n + 1):
            for j in range(1, n + 2):
                mat[i][j] = 0
        
        # 读取初始状态
        start = [0] + list(map(int, sys.stdin.readline().split()))
        
        # 读取目标状态
        end = [0] + list(map(int, sys.stdin.readline().split()))
        
        # 设置增广矩阵的常数项
        # 常数项 = 初始状态 XOR 目标状态
        # 如果结果为1，表示需要改变该开关状态；为0表示不需要改变
        for i in range(1, n + 1):
            mat[i][n + 1] = start[i] ^ end[i]
        
        # 初始化对角线元素为1（每个开关都会影响自己）
        for i in range(1, n + 1):
            mat[i][i] = 1
        
        # 读取开关之间的关系
        while True:
            line = sys.stdin.readline().strip()
            if not line:
                break
                
            parts = line.split()
            if len(parts) != 2:
                continue
                
            a = int(parts[0])
            b = int(parts[1])
            
            if a == 0 and b == 0:
                break
            
            # 按下开关a会影响开关b
            mat[b][a] = 1  # 设置系数矩阵：第b行第a列的值为1
        
        # 使用高斯消元法求解异或方程组
        free_num = gauss()
        
        # 输出结果
        if free_num == -1:
            print("Oh, it's impossible~!!")  # 无解
        else:
            # 计算解的总数：2^free_num
            # 注意：当free_num很大时可能会溢出，Python整数没有大小限制
            ans = 1 << free_num  # 使用位运算更高效且避免浮点数误差
            print(ans)  # 方案数为2^自由变元个数


"""
代码优化与工程化考量：

1. 算法优化：
   - 异或高斯消元相比普通高斯消元更简单，因为只涉及0和1的运算
   - 可以使用位运算进一步优化，例如用整数或位集来表示矩阵行，减少内存使用
   - 对于大规模数据，可以考虑使用更高效的消元策略

2. 数值稳定性：
   - 异或运算不存在浮点数精度问题，数值稳定性很好
   - 所有运算都是精确的，不会出现舍入误差

3. 内存优化：
   - 对于小规模问题（n<=30），当前实现足够高效
   - 对于更大的n值，可以考虑使用位压缩技术，例如每32个元素用一个整数表示
   - 在Python中，可以使用位运算和整数来优化矩阵的存储和运算

4. 异常处理：
   - 添加了输入验证，确保程序在无效输入下不会崩溃
   - 处理了无解的情况
   - 但还可以进一步增强异常处理，如输入参数范围检查

5. 代码可读性：
   - 添加了详细的注释说明
   - 使用有意义的变量名
   - 提取常用功能为单独的函数

6. 可扩展性：
   - 可以轻松修改以处理更大规模的异或方程组
   - 基础算法可以应用于其他需要解异或方程组的问题
   - 可以考虑将高斯消元部分提取为独立的工具类

7. 性能优化：
   - 使用了高效的输入处理方式（sys.stdin.readline）
   - 对于异或运算，Python内部已经优化得很好
   - 在回代阶段，可以通过提前终止无效计算来优化性能

8. 边界情况处理：
   - 处理了无解的情况
   - 处理了多解的情况（通过统计自由变量）
   - 对于自由变量的取值，可以进一步优化以找到某些最优解（如按下开关数量最少的解）

9. 潜在问题：
   - 输入处理部分可能在某些特殊输入格式下出现问题
   - 对于非常大的n值，当前的矩阵实现可能不够高效

10. Python语言特性利用：
    - 利用Python的列表推导式简化矩阵初始化
    - 利用Python的整数没有大小限制的特性，避免溢出问题
    - 可以考虑使用NumPy库进行矩阵操作，提高性能

11. 代码结构改进：
    - 可以将全局变量改为局部变量或类成员变量，提高代码的可维护性
    - 可以使用面向对象的方式重构代码，封装相关功能
    - 可以添加单元测试来验证代码的正确性

该实现适用于各类异或方程组问题，特别是在算法竞赛中常见的开关控制类问题。
对于更复杂的应用场景，可以考虑使用更高效的数据结构和算法优化。
"""

if __name__ == "__main__":
    main()