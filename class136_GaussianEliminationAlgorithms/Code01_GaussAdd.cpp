/**
 * =================================================================================
 * 高斯消元法求解线性方程组模板 - Code01_GaussAdd.cpp
 * =================================================================================
 * 
 * 问题来源：洛谷 P3389 【模板】高斯消元法
 * 题目链接：https://www.luogu.com.cn/problem/P3389
 * 
 * 算法功能：
 * - 求解n元一次线性方程组 Ax = b
 * - 判断解的情况：唯一解、无解、无穷多解
 * - 若存在唯一解，输出解的值（保留两位小数）
 * - 若不存在唯一解，输出"No Solution"
 * 
 * 数学原理：
 * 高斯消元法通过初等行变换将增广矩阵 [A|b] 化为行阶梯形或简化行阶梯形：
 * 1. 交换两行：改变方程的顺序
 * 2. 某行乘以非零常数：缩放方程
 * 3. 某行的倍数加到另一行：消去变量
 * 
 * 时间复杂度分析：
 * - 时间复杂度：O(n³)，其中n为方程组中方程的个数
 *   - 外层循环：n次迭代
 *   - 选主元：每次O(n)比较
 *   - 归一化：每次O(n)除法运算
 *   - 消元：每次O(n²)运算
 *   - 总复杂度：n × (n + n + n²) = O(n³)
 * 
 * 空间复杂度分析：
 * - 空间复杂度：O(n²)，用于存储n×(n+1)的增广矩阵
 *   - 系数矩阵：n×n = O(n²)
 *   - 常数项向量：n = O(n)
 *   - 临时变量：O(1)
 * 
 * C++实现特点：
 * 1. 高性能：接近机器级别的性能
 * 2. 模板支持：可扩展为支持不同数据类型
 * 3. 内存控制：手动内存管理，更精细的资源控制
 * 4. SIMD支持：可利用CPU的SIMD指令集加速计算
 * 
 * 编译指令：
 * g++ -O2 -std=c++17 Code01_GaussAdd.cpp -o gauss_solver
 * 
 * 作者：算法之旅项目组
 * 版本：v1.0
 * 日期：2025-10-28
 * =================================================================================
 */

#include <iostream>
#include <iomanip>
#include <cmath>
#include <vector>
#include <algorithm>

using namespace std;

// 精度控制常量，用于判断浮点数是否为0
const double EPS = 1e-7;

/**
 * 高斯消元算法主函数
 * 
 * 功能描述：
 * 使用高斯-约旦消元法求解线性方程组，将增广矩阵化为简化行阶梯形
 * 
 * 算法步骤：
 * 1. 选主元：选择当前列绝对值最大的元素，提高数值稳定性
 * 2. 交换行：将主元行交换到当前处理行位置
 * 3. 检查主元：若主元近似为0，则方程组无唯一解
 * 4. 归一化：将主元行除以主元值，使主元系数为1
 * 5. 消元：用主元行消去其他所有行在当前列的元素
 * 
 * 参数说明：
 * @param mat 增广矩阵，大小为n×(n+1)
 * @param n 变量个数（方程个数）
 * @return 解的情况：1表示有唯一解，0表示无解或无穷多解
 */
int gauss(vector<vector<double>>& mat, int n) {
    // 逐列处理
    for (int i = 0; i < n; i++) {
        // 选主元：找出第i列中从第i行到第n行绝对值最大的元素
        int maxRow = i;
        for (int j = i + 1; j < n; j++) {
            if (fabs(mat[j][i]) > fabs(mat[maxRow][i])) {
                maxRow = j;
            }
        }
        
        // 交换当前行与主元所在行
        if (maxRow != i) {
            swap(mat[i], mat[maxRow]);
        }
        
        // 检查主元是否为0（考虑精度问题）
        if (fabs(mat[i][i]) < EPS) {
            return 0; // 无唯一解
        }
        
        // 归一化：将主元行的主元系数化为1
        double pivot = mat[i][i];
        for (int j = i; j <= n; j++) {
            mat[i][j] /= pivot;
        }
        
        // 消元：用主元行消去其他所有行在第i列的系数
        for (int j = 0; j < n; j++) {
            if (i != j) {
                double factor = mat[j][i];
                for (int k = i; k <= n; k++) {
                    mat[j][k] -= mat[i][k] * factor;
                }
            }
        }
    }
    
    return 1; // 有唯一解
}

/**
 * 主函数：读取输入，执行高斯消元，输出结果
 */
int main() {
    // 提高IO效率
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    
    int n;
    cin >> n;
    
    // 创建增广矩阵，大小为n×(n+1)
    vector<vector<double>> mat(n, vector<double>(n + 1));
    
    // 读取增广矩阵数据
    for (int i = 0; i < n; i++) {
        for (int j = 0; j <= n; j++) {
            cin >> mat[i][j];
        }
    }
    
    // 执行高斯消元
    int result = gauss(mat, n);
    
    // 输出结果
    if (result == 0) {
        cout << "No Solution" << endl;
    } else {
        // 设置输出精度为两位小数
        cout << fixed << setprecision(2);
        for (int i = 0; i < n; i++) {
            // 经过高斯-约旦消元后，解直接存储在增广矩阵的最后一列
            cout << mat[i][n] << endl;
        }
    }
    
    return 0;
}

/**
 * =================================================================================
 * C++实现特色与优化
 * =================================================================================
 * 
 * 1. 性能优化：
 *    - 使用vector容器，自动内存管理
 *    - 引用交换：swap(mat[i], mat[maxRow]) 高效行交换
 *    - IO优化：ios::sync_with_stdio(false) 关闭同步
 * 
 * 2. 数值稳定性：
 *    - 选主元策略：避免小主元导致的数值不稳定
 *    - 精度控制：使用EPS阈值判断浮点数是否为0
 *    - 标准化处理：所有运算使用double类型
 * 
 * 3. 工程化考量：
 *    - 异常安全：使用RAII原则管理资源
 *    - 模块化设计：算法逻辑封装为独立函数
 *    - 可扩展性：易于修改为模板函数支持不同数据类型
 * 
 * 4. 编译优化：
 *    - O2优化：开启编译器优化选项
 *    - C++17标准：使用现代C++特性
 *    - 向量化：编译器可能自动向量化循环
 * 
 * 测试用例：
 * 输入：
 * 2
 * 2 3 8
 * 4 1 6
 * 输出：
 * 1.00
 * 2.00
 * 
 * 边界测试：
 * - n=1的单变量方程
 * - 奇异矩阵（无解或无穷多解）
 * - 极端数值（极大值、极小值）
 * =================================================================================
 */