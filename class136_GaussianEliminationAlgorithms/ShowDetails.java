package class133;

// 课上讲述高斯消元解决加法方程组的例子
//
// 该程序演示了高斯消元法在解决线性方程组时的各种情况：
// 1. 唯一解：方程组有唯一解
// 2. 矛盾：方程组无解
// 3. 多解：方程组有无穷多解
// 4. 表达式冗余：方程组中有冗余方程
// 5. 表达式不足：方程组中缺少足够的方程

public class ShowDetails {

	public static int MAXN = 101;

	// 增广矩阵，用于高斯消元求解线性方程组
	// mat[i][j] 表示第i个方程中第j个变量的系数
	// mat[i][n+1] 表示第i个方程的常数项
	public static double[][] mat = new double[MAXN][MAXN];

	// 0.0000001 == 1e-7
	// 因为double类型有精度问题，所以认为
	// 如果一个数字绝对值  <  sml，则认为该数字是0
	// 如果一个数字绝对值  >= sml，则认为该数字不是0
	public static double sml = 1e-7;

	/**
	 * 高斯消元法解决加法方程组模版
	 * 需要保证变量有n个，表达式也有n个
	 * 
	 * 算法特点：
	 * 1. 严格区分矛盾、多解、唯一解三种情况
	 * 2. 使用部分主元法提高数值稳定性
	 * 3. 处理各种特殊情况（冗余方程、不足方程等）
	 * 
	 * 算法步骤：
	 * 1. 对于每一行i，选择主元（绝对值最大的元素）
	 * 2. 将主元所在的行与第i行交换
	 * 3. 将第i行的主元系数化为1
	 * 4. 用第i行消除其他所有行的第i列系数
	 * 
	 * @param n 变量数量
	 */
	public static void gauss(int n) {
		for (int i = 1; i <= n; i++) {
			// 如果想严格区分矛盾、多解、唯一解，一定要这么写
			int max = i;
			for (int j = 1; j <= n; j++) {
				// 跳过已经处理过的行
				if (j < i && Math.abs(mat[j][j]) >= sml) {
					continue;
				}
				// 找到第i列中绝对值最大的元素所在的行
				if (Math.abs(mat[j][i]) > Math.abs(mat[max][i])) {
					max = j;
				}
			}
			// 交换行，将主元所在的行与第i行交换
			swap(i, max);
			// 如果主元的绝对值不小于sml，进行消元操作
			if (Math.abs(mat[i][i]) >= sml) {
				double tmp = mat[i][i];
				// 将第i行的主元系数化为1
				for (int j = i; j <= n + 1; j++) {
					mat[i][j] /= tmp;
				}
				// 用第i行消除其他所有行的第i列系数
				for (int j = 1; j <= n; j++) {
					if (i != j) {
						double rate = mat[j][i] / mat[i][i];
						for (int k = i; k <= n + 1; k++) {
							mat[j][k] -= mat[i][k] * rate;
						}
					}
				}
			}
		}
	}

	/**
	 * 交换矩阵中的两行
	 * @param a 第一行的行号
	 * @param b 第二行的行号
	 */
	public static void swap(int a, int b) {
		double[] tmp = mat[a];
		mat[a] = mat[b];
		mat[b] = tmp;
	}

	/**
	 * 打印增广矩阵
	 * @param n 变量数量
	 */
	public static void print(int n) {
		for (int i = 1; i <= n; i++) {
			for (int j = 1; j <= n + 1; j++) {
				System.out.printf("%.2f  ", mat[i][j]);
			}
			System.out.println();
		}
		System.out.println("========================");
	}

	/**
	 * 主函数
	 * 演示高斯消元法在各种情况下的应用
	 * 
	 * 演示内容：
	 * 1. 唯一解：方程组有唯一解
	 * 2. 矛盾：方程组无解
	 * 3. 多解：方程组有无穷多解
	 * 4. 表达式冗余，唯一解：方程组中有冗余方程但有唯一解
	 * 5. 表达式冗余，矛盾：方程组中有冗余方程且无解
	 * 6. 表达式冗余，多解：方程组中有冗余方程且有无穷多解
	 * 7. 表达式不足，矛盾：方程组中缺少足够的方程且无解
	 * 8. 表达式不足，多解：方程组中缺少足够的方程且有无穷多解
	 * 9. 正确区分矛盾、多解、唯一解：复杂情况下的区分
	 * 10. 有些主元可以确定值：部分变量可以确定值的情况
	 * 11. 有些主元还受到自由元的影响：部分变量受自由变量影响的情况
	 */
	public static void main(String[] args) {
		// 唯一解
		// 1*x1 + 2*x2 - 1*x3 = 9
		// 2*x1 - 1*x2 + 2*x3 = 7
		// 1*x1 - 2*x2 + 2*x3 = 0
		System.out.println("唯一解");
		mat[1][1] = 1; mat[1][2] = 2; mat[1][3] = -1; mat[1][4] = 9;
		mat[2][1] = 2; mat[2][2] = -1; mat[2][3] = 2; mat[2][4] = 7;
		mat[3][1] = 1; mat[3][2] = -2; mat[3][3] = 2; mat[3][4] = 0;
		gauss(3);
		print(3);

		// 矛盾
		// 1*x1 + 1*x2 = 3
		// 2*x1 + 2*x2 = 7
		System.out.println("矛盾");
		mat[1][1] = 1; mat[1][2] = 1; mat[1][3] = 3;
		mat[2][1] = 2; mat[2][2] = 2; mat[2][3] = 7;
		gauss(2);
		print(2);

		// 多解
		// 1*x1 + 1*x2 = 3
		// 2*x1 + 2*x2 = 6
		System.out.println("多解");
		mat[1][1] = 1; mat[1][2] = 1; mat[1][3] = 3;
		mat[2][1] = 2; mat[2][2] = 2; mat[2][3] = 6;
		gauss(2);
		print(2);

		// 表达式冗余，唯一解
		// 1*x1 + 2*x2 - 1*x3 + 0*x4 = 9
		// 2*x1 + 4*x2 - 2*x3 + 0*x4 = 18
		// 2*x1 - 1*x2 + 2*x3 + 0*x4 = 7
		// 1*x1 - 2*x2 + 2*x3 + 0*x4 = 0
		System.out.println("表达式冗余，唯一解");
		mat[1][1] = 1; mat[1][2] = 2; mat[1][3] = -1; mat[1][4] = 0; mat[1][5] = 9;
		mat[2][1] = 2; mat[2][2] = 4; mat[2][3] = -2; mat[2][4] = 0; mat[2][5] = 18;
		mat[3][1] = 2; mat[3][2] = -1; mat[3][3] = 2; mat[3][4] = 0; mat[3][5] = 7;
		mat[4][1] = 1; mat[4][2] = -2; mat[4][3] = 2; mat[4][4] = 0; mat[4][5] = 0;
		gauss(4);
		print(4);

		// 表达式冗余，矛盾
		// 1*x1 + 2*x2 - 1*x3 = 9
		// 2*x1 + 4*x2 - 2*x3 = 18
		// 2*x1 - 1*x2 + 2*x3 = 7
		// 4*x1 - 2*x2 + 4*x3 = 10
		System.out.println("表达式冗余，矛盾");
		mat[1][1] = 1; mat[1][2] = 2; mat[1][3] = -1; mat[1][4] = 0; mat[1][5] = 9;
		mat[2][1] = 2; mat[2][2] = 4; mat[2][3] = -2; mat[2][4] = 0; mat[2][5] = 18;
		mat[3][1] = 2; mat[3][2] = -1; mat[3][3] = 2; mat[3][4] = 0; mat[3][5] = 7;
		mat[4][1] = 4; mat[4][2] = -2; mat[4][3] = 4; mat[4][4] = 0; mat[4][5] = 10;
		gauss(4);
		print(4);

		// 表达式冗余，多解
		// 1*x1 + 2*x2 - 1*x3 = 9
		// 2*x1 + 4*x2 - 2*x3 = 18
		// 2*x1 - 1*x2 + 2*x3 = 7
		// 4*x1 - 2*x2 + 4*x3 = 14
		System.out.println("表达式冗余，多解");
		mat[1][1] = 1; mat[1][2] = 2; mat[1][3] = -1; mat[1][4] = 0; mat[1][5] = 9;
		mat[2][1] = 2; mat[2][2] = 4; mat[2][3] = -2; mat[2][4] = 0; mat[2][5] = 18;
		mat[3][1] = 2; mat[3][2] = -1; mat[3][3] = 2; mat[3][4] = 0; mat[3][5] = 7;
		mat[4][1] = 4; mat[4][2] = -2; mat[4][3] = 4; mat[4][4] = 0; mat[4][5] = 14;
		gauss(4);
		print(4);

		// 表达式不足，矛盾
		// 1*x1 + 2*x2 - 1*x3 = 5
		// 2*x1 + 4*x2 - 2*x3 = 7
		System.out.println("表达式不足，矛盾");
		mat[1][1] = 1; mat[1][2] = 2; mat[1][3] = -1; mat[1][4] = 5;
		mat[2][1] = 2; mat[2][2] = 4; mat[2][3] = -2; mat[2][4] = 7;
		mat[3][1] = 0; mat[3][2] = 0; mat[3][3] = 0;  mat[3][4] = 0;
		gauss(3);
		print(3);

		// 表达式不足，多解
		// 1*x1 + 2*x2 - 1*x3 = 5
		// 2*x1 + 2*x2 - 1*x3 = 8
		System.out.println("表达式不足，多解");
		mat[1][1] = 1; mat[1][2] = 2; mat[1][3] = -1; mat[1][4] = 5;
		mat[2][1] = 2; mat[2][2] = 2; mat[2][3] = -1; mat[2][4] = 8;
		mat[3][1] = 0; mat[3][2] = 0; mat[3][3] = 0;  mat[3][4] = 0;
		gauss(3);
		print(3);

		// 正确区分矛盾、多解、唯一解
		// 0*x1 + 2*x2 = 3
		// 0*x1 + 0*x2 = 0
		System.out.println("正确区分矛盾、多解、唯一解");
		mat[1][1] = 0; mat[1][2] = 2; mat[1][3] = 3;
		mat[2][1] = 0; mat[2][2] = 0; mat[2][3] = 0;
		gauss(2);
		print(2);

		// 有些主元可以确定值
		// a  + b + c = 5
		// 2a + b + c = 7
		System.out.println("有些主元可以确定值");
		mat[1][1] = 1; mat[1][2] = 1; mat[1][3] = 1; mat[1][4] = 5;
		mat[2][1] = 2; mat[2][2] = 1; mat[2][3] = 1; mat[2][4] = 7;
		mat[3][1] = 0; mat[3][2] = 0; mat[3][3] = 0; mat[3][4] = 0;
		gauss(3);
		print(3);

		// 有些主元还受到自由元的影响
		// a + b = 5
		System.out.println("有些主元还受到自由元的影响");
		mat[1][1] = 1; mat[1][2] = 1; mat[1][3] = 5;
		mat[2][1] = 0; mat[2][2] = 0; mat[2][3] = 0;
		gauss(2);
		print(2);
	}

}