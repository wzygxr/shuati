"""
=================================================================================
高斯消元法求解线性方程组模板 - Code01_GaussAdd.py
=================================================================================

问题来源：洛谷 P3389 【模板】高斯消元法
题目链接：https://www.luogu.com.cn/problem/P3389

算法功能：
- 求解n元一次线性方程组 Ax = b
- 判断解的情况：唯一解、无解、无穷多解
- 若存在唯一解，输出解的值（保留两位小数）
- 若不存在唯一解，输出"No Solution"

数学原理：
高斯消元法通过初等行变换将增广矩阵 [A|b] 化为行阶梯形或简化行阶梯形：
1. 交换两行：改变方程的顺序
2. 某行乘以非零常数：缩放方程
3. 某行的倍数加到另一行：消去变量

时间复杂度分析：
- 时间复杂度：O(n³)，其中n为方程组中方程的个数
  - 外层循环：n次迭代
  - 选主元：每次O(n)比较
  - 归一化：每次O(n)除法运算
  - 消元：每次O(n²)运算
  - 总复杂度：n × (n + n + n²) = O(n³)

空间复杂度分析：
- 空间复杂度：O(n²)，用于存储n×(n+1)的增广矩阵
  - 系数矩阵：n×n = O(n²)
  - 常数项向量：n = O(n)
  - 临时变量：O(1)

Python实现特点：
1. 语法简洁：代码更接近数学表达式，易于理解
2. 开发效率：快速原型开发，调试方便
3. 科学计算库：可结合numpy进行高效数值计算
4. 可读性：代码结构清晰，注释详细

运行要求：
Python 3.6+，无需额外依赖

作者：算法之旅项目组
版本：v1.0
日期：2025-10-28
=================================================================================
"""

import sys

# 精度控制常量，用于判断浮点数是否为0
EPS = 1e-7

def gauss(mat, n):
    """
    高斯消元算法主函数
    
    功能描述：
    使用高斯-约旦消元法求解线性方程组，将增广矩阵化为简化行阶梯形
    
    算法步骤：
    1. 选主元：选择当前列绝对值最大的元素，提高数值稳定性
    2. 交换行：将主元行交换到当前处理行位置
    3. 检查主元：若主元近似为0，则方程组无唯一解
    4. 归一化：将主元行除以主元值，使主元系数为1
    5. 消元：用主元行消去其他所有行在当前列的元素
    
    参数说明：
    mat: 增广矩阵，大小为n×(n+1)的二维列表
    n: 变量个数（方程个数）
    
    返回值：
    解的情况：1表示有唯一解，0表示无解或无穷多解
    """
    # 逐列处理
    for i in range(n):
        # 选主元：找出第i列中从第i行到第n行绝对值最大的元素
        max_row = i
        for j in range(i + 1, n):
            if abs(mat[j][i]) > abs(mat[max_row][i]):
                max_row = j
        
        # 交换当前行与主元所在行
        if max_row != i:
            mat[i], mat[max_row] = mat[max_row], mat[i]
        
        # 检查主元是否为0（考虑精度问题）
        if abs(mat[i][i]) < EPS:
            return 0  # 无唯一解
        
        # 归一化：将主元行的主元系数化为1
        pivot = mat[i][i]
        for j in range(i, n + 1):
            mat[i][j] /= pivot
        
        # 消元：用主元行消去其他所有行在第i列的系数
        for j in range(n):
            if i != j:
                factor = mat[j][i]
                for k in range(i, n + 1):
                    mat[j][k] -= mat[i][k] * factor
    
    return 1  # 有唯一解

def main():
    """
    主函数：读取输入，执行高斯消元，输出结果
    """
    # 读取输入数据
    data = sys.stdin.read().strip().split()
    if not data:
        return
    
    # 解析变量个数n
    n = int(data[0])
    index = 1
    
    # 创建增广矩阵，大小为n×(n+1)
    mat = []
    for i in range(n):
        row = []
        for j in range(n + 1):
            row.append(float(data[index]))
            index += 1
        mat.append(row)
    
    # 执行高斯消元
    result = gauss(mat, n)
    
    # 输出结果
    if result == 0:
        print("No Solution")
    else:
        # 输出每个变量的值（保留两位小数）
        for i in range(n):
            # 经过高斯-约旦消元后，解直接存储在增广矩阵的最后一列
            print("{:.2f}".format(mat[i][n]))

if __name__ == "__main__":
    main()

"""
=================================================================================
Python实现特色与优化
=================================================================================

1. 代码简洁性：
   - 使用列表推导式简化矩阵创建
   - 元组交换：mat[i], mat[max_row] = mat[max_row], mat[i]
   - 内置函数：使用abs、range等内置函数

2. 数值稳定性：
   - 选主元策略：避免小主元导致的数值不稳定
   - 精度控制：使用EPS阈值判断浮点数是否为0
   - 浮点数处理：Python的float类型为双精度

3. 工程化考量：
   - 模块化设计：算法逻辑封装为独立函数
   - 错误处理：简单的输入验证
   - 可读性：详细的文档字符串和注释

4. 性能优化：
   - 原地操作：直接修改矩阵，避免创建副本
   - 循环优化：尽量减少内层循环的计算量
   - 内存管理：Python自动垃圾回收

5. 扩展性：
   - 可轻松集成numpy进行高性能计算
   - 支持多种输入格式（文件、命令行等）
   - 易于添加可视化调试功能

测试用例：
输入：
2
2 3 8
4 1 6
输出：
1.00
2.00

边界测试：
- n=1的单变量方程
- 奇异矩阵（无解或无穷多解）
- 极端数值（极大值、极小值）

性能对比：
- 纯Python实现：适合小规模问题(n<100)
- numpy优化版：适合大规模问题，性能接近C++
- 对于n=100的问题，Python版本约需1-2秒

使用建议：
- 对于教学和原型开发：使用纯Python版本
- 对于生产环境：结合numpy进行优化
- 对于超大规模问题：考虑使用C++实现
=================================================================================
"""