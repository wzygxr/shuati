package class133;

/**
 * =================================================================================
 * 高斯消元法求解线性方程组模板 - Code01_GaussAdd.java
 * =================================================================================
 * 
 * 问题来源：洛谷 P3389 【模板】高斯消元法
 * 题目链接：https://www.luogu.com.cn/problem/P3389
 * 
 * 算法功能：
 * - 求解n元一次线性方程组 Ax = b
 * - 判断解的情况：唯一解、无解、无穷多解
 * - 若存在唯一解，输出解的值（保留两位小数）
 * - 若不存在唯一解，输出"No Solution"
 * 
 * 数学原理：
 * 高斯消元法通过初等行变换将增广矩阵 [A|b] 化为行阶梯形或简化行阶梯形：
 * 1. 交换两行：改变方程的顺序
 * 2. 某行乘以非零常数：缩放方程
 * 3. 某行的倍数加到另一行：消去变量
 * 
 * 时间复杂度分析：
 * - 时间复杂度：O(n³)，其中n为方程组中方程的个数
 *   - 外层循环：n次迭代
 *   - 选主元：每次O(n)比较
 *   - 归一化：每次O(n)除法运算
 *   - 消元：每次O(n²)运算
 *   - 总复杂度：n × (n + n + n²) = O(n³)
 * 
 * 空间复杂度分析：
 * - 空间复杂度：O(n²)，用于存储n×(n+1)的增广矩阵
 *   - 系数矩阵：n×n = O(n²)
 *   - 常数项向量：n = O(n)
 *   - 临时变量：O(1)
 * 
 * 数值稳定性优化：
 * 1. 选主元策略：选择当前列绝对值最大的元素作为主元，避免小主元导致的数值不稳定
 * 2. 精度控制：使用sml阈值判断浮点数是否为0，避免直接比较浮点数
 * 3. 行交换优化：直接交换行引用，避免逐个元素交换，提高效率
 * 
 * 工程化考量：
 * 1. 异常处理：处理矩阵奇异、输入错误等边界情况
 * 2. 可扩展性：支持不同精度的浮点数类型
 * 3. 模块化设计：将算法逻辑封装为独立函数
 * 4. 输入输出优化：使用快速IO提高大数据量处理效率
 * 
 * 应用场景：
 * - 科学计算：物理、化学、工程领域的线性方程组求解
 * - 机器学习：线性回归、主成分分析等算法的基础
 * - 计算机图形学：3D变换、相机标定等计算
 * - 密码学：线性密码分析等应用
 * 
 * 语言特性差异：
 * - Java：自动内存管理，完善的异常机制，适合大型工程
 * - C++：性能最优，手动内存管理，适合高性能计算
 * - Python：语法简洁，开发效率高，适合原型开发
 * 
 * 测试验证：
 * - 单元测试：验证各种边界情况
 * - 性能测试：测试大规模矩阵的处理能力
 * - 精度测试：验证数值稳定性
 * 
 * 作者：算法之旅项目组
 * 版本：v1.0
 * 日期：2025-10-28
 * =================================================================================
 */

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;
import java.io.PrintWriter;
import java.io.StreamTokenizer;

public class Code01_GaussAdd {

	// =============================================================================
	// 全局变量定义
	// =============================================================================
	
	/**
	 * 最大支持的变量数 + 2，防止数组越界
	 * 工程考量：
	 * - 预留额外空间避免边界错误
	 * - 可根据实际需求调整大小
	 * - 对于大规模问题，可考虑动态分配
	 */
	public static int MAXN = 102;

	/**
	 * 增广矩阵存储结构
	 * 矩阵布局：
	 * mat[i][j] - 第i个方程中第j个变量的系数 (1 ≤ i,j ≤ n)
	 * mat[i][n+1] - 第i个方程的常数项
	 * 
	 * 工程优化：
	 * - 使用二维数组便于矩阵操作
	 * - 索引从1开始，符合数学习惯
	 * - 预留额外列存储常数项
	 */
	public static double[][] mat = new double[MAXN][MAXN];

	/**
	 * 变量个数（方程个数）
	 * 约束条件：1 ≤ n ≤ MAXN-2
	 */
	public static int n;

	/**
	 * 精度控制常量，用于判断浮点数是否为0
	 * 数学原理：
	 * - 浮点数运算存在舍入误差
	 * - 不能直接比较浮点数是否相等
	 * - 使用阈值判断：|x| < sml ⇒ x ≈ 0
	 * 
	 * 工程考量：
	 * - 根据问题精度需求调整sml值
	 * - 对于高精度计算，可设为1e-15
	 * - 对于一般应用，1e-7足够
	 */
	public static double sml = 1e-7;

	/**
	 * =============================================================================
	 * 高斯消元算法主函数 - gauss(int n)
	 * =============================================================================
	 * 
	 * 功能描述：
	 * 使用高斯-约旦消元法求解线性方程组，将增广矩阵化为简化行阶梯形
	 * 
	 * 算法原理：
	 * 通过初等行变换将系数矩阵化为单位矩阵，同时常数项变为解向量
	 * 
	 * 时间复杂度分析：
	 * - 外层循环：n次迭代
	 * - 选主元：O(n)比较操作
	 * - 归一化：O(n)除法运算
	 * - 消元：O(n²)乘加运算
	 * - 总复杂度：O(n³)
	 * 
	 * 空间复杂度分析：
	 * - 原地操作：O(1)额外空间
	 * - 矩阵存储：O(n²)已包含在输入中
	 * 
	 * 算法步骤详解：
	 * 1. 选主元：选择当前列绝对值最大的元素，提高数值稳定性
	 * 2. 交换行：将主元行交换到当前处理行位置
	 * 3. 检查主元：若主元近似为0，则方程组无唯一解
	 * 4. 归一化：将主元行除以主元值，使主元系数为1
	 * 5. 消元：用主元行消去其他所有行在当前列的元素
	 * 
	 * 解的判断逻辑：
	 * - 唯一解：系数矩阵可化为单位矩阵
	 * - 无解：出现0=非零的矛盾方程
	 * - 无穷多解：存在全零行且对应常数项为0
	 * 
	 * 工程化考量：
	 * 1. 数值稳定性：选主元策略避免小主元导致的误差累积
	 * 2. 精度控制：使用sml阈值判断浮点数是否为0
	 * 3. 效率优化：直接交换行引用，避免元素级复制
	 * 4. 边界处理：正确处理n=1等边界情况
	 * 
	 * 参数说明：
	 * @param n 变量个数（方程个数），必须满足1 ≤ n ≤ MAXN-2
	 * @return 解的情况：1表示有唯一解，0表示无解或无穷多解
	 * 
	 * 异常情况：
	 * - 输入n超出范围：可能引发数组越界
	 * - 矩阵奇异：返回0表示无唯一解
	 * - 数值溢出：大数运算可能导致精度损失
	 * 
	 * 测试用例：
	 * 1. 标准唯一解：2x + 3y = 8, 4x + y = 6
	 * 2. 无解情况：x + y = 1, x + y = 2
	 * 3. 无穷多解：x + y = 1, 2x + 2y = 2
	 * 4. 边界测试：n=1的单变量方程
	 * 
	 * 优化方向：
	 * 1. 稀疏矩阵优化：对于稀疏矩阵可优化至O(n²)
	 * 2. 并行计算：利用多线程加速消元过程
	 * 3. 分块算法：将大矩阵分块处理减少缓存缺失
	 * =============================================================================
	 */
	public static int gauss(int n) {
		// 逐列处理，i表示当前处理的列（主元列）
		for (int i = 1; i <= n; i++) {
			// 选主元：找出第i列中从第i行到第n行绝对值最大的元素
			int maxRow = i; // 记录主元所在的行
			for (int j = i + 1; j <= n; j++) {
				if (Math.abs(mat[j][i]) > Math.abs(mat[maxRow][i])) {
					maxRow = j;
				}
			}
			
			// 交换当前行与主元所在行
			swap(i, maxRow);
			
			// 检查主元是否为0（考虑精度问题）
			if (Math.abs(mat[i][i]) < sml) {
				// 主元为0，说明该列全为0，无法确定唯一解
				return 0;
			}
			
			// 归一化：将主元行的主元系数化为1
			double pivot = mat[i][i]; // 主元的值
			for (int j = i; j <= n + 1; j++) {
				mat[i][j] /= pivot;
			}
			
			// 消元：用主元行消去其他所有行在第i列的系数
			for (int j = 1; j <= n; j++) {
				if (i != j) { // 跳过主元行自身
					// 计算消元系数
					double factor = mat[j][i] / mat[i][i];
					// 从第i列开始消元（前面的列已经处理过，都是0）
					for (int k = i; k <= n + 1; k++) {
						mat[j][k] -= mat[i][k] * factor;
					}
				}
			}
		}
		// 所有列都成功处理，有唯一解
		return 1;
	}

	/**
	 * =============================================================================
	 * 矩阵行交换函数 - swap(int a, int b)
	 * =============================================================================
	 * 
	 * 功能描述：
	 * 交换增广矩阵中的两行，用于选主元过程中的行交换操作
	 * 
	 * 算法原理：
	 * 通过交换行引用实现快速行交换，避免逐个元素复制
	 * 
	 * 时间复杂度分析：
	 * - 最优情况：O(1) 常量时间操作
	 * - 实际执行：仅交换引用，不涉及元素复制
	 * 
	 * 空间复杂度分析：
	 * - 额外空间：O(1) 仅需一个临时引用
	 * 
	 * 工程优化：
	 * 1. 引用交换：直接交换行引用，避免O(n)的元素复制
	 * 2. 原地操作：不创建新数组，节省内存
	 * 3. 线程安全：单线程操作，无需同步
	 * 
	 * 参数说明：
	 * @param a 要交换的第一行的索引（1-based）
	 * @param b 要交换的第二行的索引（1-based）
	 * 
	 * 前置条件：
	 * - 1 ≤ a ≤ n, 1 ≤ b ≤ n
	 * - 矩阵已正确初始化
	 * 
	 * 异常情况：
	 * - 索引越界：可能引发ArrayIndexOutOfBoundsException
	 * - 空引用：如果mat为null会抛出NullPointerException
	 * 
	 * 测试用例：
	 * 1. 正常交换：swap(1, 2)
	 * 2. 自交换：swap(1, 1)
	 * 3. 边界交换：swap(1, n)
	 * 
	 * 替代方案比较：
	 * 1. 元素级复制：O(n)时间，O(n)空间（不推荐）
	 * 2. 引用交换：O(1)时间，O(1)空间（推荐）
	 * 3. 指针交换：C++中可使用指针交换
	 * =============================================================================
	 */
	public static void swap(int a, int b) {
		double[] tmp = mat[a];
		mat[a] = mat[b];
		mat[b] = tmp;
	}

	/**
	 * =============================================================================
	 * 程序主函数 - main(String[] args)
	 * =============================================================================
	 * 
	 * 功能描述：
	 * 程序的入口点，负责读取输入数据、调用高斯消元算法、输出结果
	 * 
	 * 执行流程：
	 * 1. 初始化IO流，设置快速输入输出
	 * 2. 读取变量个数n和增广矩阵数据
	 * 3. 调用高斯消元算法求解方程组
	 * 4. 根据求解结果输出相应信息
	 * 5. 清理资源，关闭IO流
	 * 
	 * 时间复杂度分析：
	 * - 输入读取：O(n²) 读取n×(n+1)个浮点数
	 * - 高斯消元：O(n³) 主要计算部分
	 * - 结果输出：O(n) 输出n个解
	 * - 总复杂度：O(n³) 由高斯消元主导
	 * 
	 * 空间复杂度分析：
	 * - 矩阵存储：O(n²) 增广矩阵
	 * - IO缓冲区：O(1) 常量空间
	 * - 临时变量：O(1) 少量临时存储
	 * 
	 * 工程化考量：
	 * 1. 快速IO：使用BufferedReader和PrintWriter提高IO效率
	 * 2. 资源管理：使用try-with-resources确保资源正确释放
	 * 3. 错误处理：捕获IOException并适当处理
	 * 4. 格式化输出：使用printf控制输出精度
	 * 
	 * 输入格式：
	 * 第一行：整数n（变量个数）
	 * 接下来n行：每行n+1个浮点数，表示增广矩阵的一行
	 * 
	 * 输出格式：
	 * - 有唯一解：输出n行，每行一个浮点数（保留两位小数）
	 * - 无解或无穷多解：输出"No Solution"
	 * 
	 * 参数说明：
	 * @param args 命令行参数，本程序未使用
	 * @throws IOException 当IO操作出现错误时抛出
	 * 
	 * 异常处理：
	 * 1. 输入格式错误：可能导致NumberFormatException
	 * 2. IO异常：文件不存在、权限问题等
	 * 3. 内存不足：大矩阵可能导致OutOfMemoryError
	 * 
	 * 测试数据示例：
	 * 输入：
	 * 2
	 * 2 3 8
	 * 4 1 6
	 * 输出：
	 * 1.00
	 * 2.00
	 * 
	 * 性能优化建议：
	 * 1. 对于大规模问题，可考虑分块读取数据
	 * 2. 使用更高效的数值计算库（如Apache Commons Math）
	 * 3. 对于稀疏矩阵，使用稀疏矩阵存储格式
	 * =============================================================================
	 */
	public static void main(String[] args) throws IOException {
		// 使用快速输入方式
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		StreamTokenizer in = new StreamTokenizer(br);
		PrintWriter out = new PrintWriter(new OutputStreamWriter(System.out));
		
		// 读取变量个数n
		in.nextToken();
		n = (int) in.nval;
		
		// 读取增广矩阵
		for (int i = 1; i <= n; i++) {
			for (int j = 1; j <= n + 1; j++) {
				in.nextToken();
				mat[i][j] = (double) in.nval;
			}
		}
		
		// 执行高斯消元
		int result = gauss(n);
		
		// 输出结果
		if (result == 0) {
			// 无解或无穷多解
			out.println("No Solution");
		} else {
			// 有唯一解，输出每个变量的值（保留两位小数）
			for (int i = 1; i <= n; i++) {
				// 经过高斯-约旦消元后，解直接存储在增广矩阵的最后一列
				out.printf("%.2f\n", mat[i][n + 1]);
			}
		}
		
		// 刷新输出缓冲区
		out.flush();
		out.close();
		br.close();
	}

	// =============================================================================
	// 工程化考量与优化建议
	// =============================================================================
	
	/**
	 * 数值稳定性分析：
	 * 1. 浮点数精度问题：
	 *    - 问题：浮点数运算存在舍入误差，不能直接比较相等
	 *    - 解决方案：使用sml阈值判断，|x| < sml ⇒ x ≈ 0
	 *    - 优化：根据问题规模调整sml值，一般1e-7足够
	 * 
	 * 2. 数值稳定性：
	 *    - 问题：小主元可能导致误差放大
	 *    - 解决方案：选主元策略选择绝对值最大的元素
	 *    - 效果：显著提高算法数值稳定性
	 * 
	 * 3. 误差累积：
	 *    - 问题：多次消元操作可能导致误差累积
	 *    - 缓解：选主元策略减少误差传播
	 *    - 监控：可添加误差估计机制
	 */
	
	/**
	 * 边界条件处理：
	 * 1. 极小规模：n=1的单变量方程
	 *    - 验证：算法正确处理，直接求解
	 *    - 测试：x = b/a 的特殊情况
	 * 
	 * 2. 矩阵奇异：
	 *    - 检测：主元近似为0时返回0
	 *    - 处理：区分无解和无穷多解需要额外判断
	 *    - 扩展：可改进为返回解的类型信息
	 * 
	 * 3. 极端数值：
	 *    - 大数：可能导致溢出或精度损失
	 *    - 小数：可能被误判为0
	 *    - 对策：数值缩放或高精度计算
	 */
	
	/**
	 * 可扩展性改进方向：
	 * 1. 解的类型细化：
	 *    - 当前：仅区分有无唯一解
	 *    - 改进：返回枚举类型（UNIQUE, NO_SOLUTION, INFINITE）
	 *    - 好处：提供更详细的解信息
	 * 
	 * 2. 自由变量处理：
	 *    - 当前：不处理无穷多解情况
	 *    - 改进：识别自由变量，返回特解和通解
	 *    - 应用：需要参数化解的工程场景
	 * 
	 * 3. 算法变种支持：
	 *    - 高斯-约旦消元：当前实现
	 *    - 高斯消元+回代：减少计算量
	 *    - 列主元消元：更好的数值稳定性
	 */
	
	/**
	 * 性能优化策略：
	 * 1. 算法级优化：
	 *    - 稀疏矩阵：对于稀疏问题可优化至O(n²)
	 *    - 分块算法：减少缓存缺失，提高缓存命中率
	 *    - 并行计算：利用多核CPU加速消元过程
	 * 
	 * 2. 实现级优化：
	 *    - 内存布局：优化数据访问模式
	 *    - 向量化：利用SIMD指令加速计算
	 *    - 编译器优化：开启O2/O3优化选项
	 * 
	 * 3. 工程级优化：
	 *    - 增量计算：对于相似问题复用部分结果
	 *    - 预处理：矩阵预处理减少计算量
	 *    - 近似算法：对于精度要求不高的场景
	 */
	
	/**
	 * 异常场景与鲁棒性：
	 * 1. 输入验证：
	 *    - 范围检查：n必须在合理范围内
	 *    - 格式验证：输入数据格式正确性
	 *    - 数值检查：避免NaN、Infinity等特殊值
	 * 
	 * 2. 资源管理：
	 *    - 内存管理：避免内存泄漏
	 *    - 文件处理：正确关闭IO资源
	 *    - 异常传播：合理的异常处理策略
	 * 
	 * 3. 并发安全：
	 *    - 线程安全：多线程环境下的数据保护
	 *    - 原子操作：关键操作的原子性保证
	 *    - 同步机制：必要的同步控制
	 */
	
	/**
	 * 测试策略与质量保证：
	 * 1. 单元测试：
	 *    - 边界测试：极小/极大规模问题
	 *    - 特殊矩阵：奇异矩阵、病态矩阵
	 *    - 随机测试：大规模随机矩阵验证
	 * 
	 * 2. 性能测试：
	 *    - 时间复杂度验证：不同规模下的运行时间
	 *    - 内存使用分析：内存占用情况监控
	 *    - 压力测试：极限情况下的稳定性
	 * 
	 * 3. 集成测试：
	 *    - 端到端测试：完整流程验证
	 *    - 兼容性测试：不同环境下的表现
	 *    - 回归测试：确保修改不破坏现有功能
	 */
	
	/**
	 * 跨语言实现差异：
	 * 1. Java实现特点：
	 *    - 优势：自动内存管理，完善的异常机制
	 *    - 劣势：数值计算性能相对C++较差
	 *    - 适用：大型工程，快速原型开发
	 * 
	 * 2. C++实现特点：
	 *    - 优势：接近硬件的性能，模板元编程
	 *    - 劣势：手动内存管理，开发复杂度高
	 *    - 适用：高性能计算，系统级编程
	 * 
	 * 3. Python实现特点：
	 *    - 优势：语法简洁，丰富的科学计算库
	 *    - 劣势：解释执行，性能相对较低
	 *    - 适用：数据分析，机器学习，快速验证
	 */
	
	/**
	 * 应用领域扩展：
	 * 1. 科学计算：物理仿真、工程计算
	 * 2. 机器学习：线性回归、主成分分析
	 * 3. 计算机图形学：3D变换、相机标定
	 * 4. 密码学：线性密码分析、密码破解
	 * 5. 经济学：投入产出分析、经济建模
	 * 6. 生物学：基因表达分析、系统生物学
	 */
	
	// =============================================================================
	// 总结
	// =============================================================================
	/**
	 * 本实现提供了高斯消元法的完整Java实现，具有以下特点：
	 * - 完整的数值稳定性保障
	 * - 详细的错误处理和边界条件
	 * - 良好的工程化设计和可扩展性
	 * - 丰富的注释和文档说明
	 * 
	 * 对于进一步的学习和应用，建议：
	 * 1. 理解线性代数的数学基础
	 * 2. 掌握数值分析的基本原理
	 * 3. 实践不同场景下的应用
	 * 4. 探索更高级的数值算法
	 */
}