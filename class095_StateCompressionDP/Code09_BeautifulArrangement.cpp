// 优美的排列 (Beautiful Arrangement)
// 假设有从 1 到 n 的 n 个整数。用这些整数构造一个数组 perm（下标从 1 开始），
// 只要满足下述条件之一，该数组就是一个优美的排列：
// 1. perm[i] 能够被 i 整除
// 2. i 能够被 perm[i] 整除
// 给你一个整数 n ，返回可以构造的优美排列的数量。
// 测试链接 : https://leetcode.cn/problems/beautiful-arrangement/

class Solution {
public:
    // 使用状态压缩动态规划解决优美排列问题
    // 核心思想：用二进制位表示已使用的数字集合，通过状态转移计算优美排列数量
    // 时间复杂度: O(n * 2^n)
    // 空间复杂度: O(2^n)
    int countArrangement(int n) {
        // dp[mask] 表示使用mask代表的数字集合能构成的优美排列数量
        // 使用固定大小数组替代vector，避免编译问题
        int dp[1024] = {0};  // 假设n最大为10
        // 初始状态：不使用任何数字，能构成1个优美排列（空排列）
        dp[0] = 1;
        
        // 状态转移：枚举所有可能的状态
        for (int mask = 0; mask < (1 << n); mask++) {
            // 如果当前状态不可达，跳过
            if (dp[mask] == 0) {
                continue;
            }
            
            // 计算已使用的数字个数（即当前要填充的位置）
            int pos = __builtin_popcount(mask) + 1;
            
            // 枚举下一个要使用的数字
            for (int i = 1; i <= n; i++) {
                // 如果数字i还未使用，且满足优美排列的条件
                if ((mask & (1 << (i - 1))) == 0 && (i % pos == 0 || pos % i == 0)) {
                    // 更新状态：使用mask+(1<<(i-1))代表的数字集合能构成的优美排列数量
                    dp[mask | (1 << (i - 1))] += dp[mask];
                }
            }
        }
        
        // 返回使用所有数字能构成的优美排列数量
        return dp[(1 << n) - 1];
    }
};

/*
复杂度分析：
1. 动态规划版本：
   - 时间复杂度：O(n * 2^n)
     状态数为2^n个，每个状态需要遍历n个数字来更新下一个状态
   - 空间复杂度：O(2^n)
     dp数组需要存储2^n个状态的结果

2. 记忆化搜索版本：
   - 时间复杂度：O(n * 2^n)
     同样需要计算2^n个状态，每个状态最多计算一次，每次需要检查n个数字
   - 空间复杂度：O(2^n)
     memo数组存储2^n个状态的结果，递归栈的深度为O(n)

算法说明：
1. 状态表示：使用二进制掩码mask表示已使用的数字集合
2. 状态转移：对于每个状态，尝试将未使用的数字放到下一个位置，满足条件则更新状态
3. 优化点：
   - 剪枝：跳过无法构造排列的状态
   - 使用__builtin_popcount高效计算二进制中1的个数
   - 两种实现方式（DP和DFS+记忆化）各有优势

这是本题的最优解，因为我们需要枚举所有可能的排列情况，而状态压缩DP是处理这类问题的高效方法。
*/