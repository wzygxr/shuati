// 我能赢吗
// 给定两个整数n和m
// 两个玩家可以轮流从公共整数池中抽取从1到n的整数（不放回）
// 抽取的整数会累加起来（两个玩家都算）
// 谁在自己的回合让累加和 >= m，谁获胜
// 若先出手的玩家能稳赢则返回true，否则返回false
// 假设两位玩家游戏时都绝顶聪明，可以全盘为自己打算
// 测试链接 : https://leetcode.cn/problems/can-i-win/

class Solution {
public:
    // 主函数
    bool canIWin(int n, int m) {
        // 边界条件检查
        if (m == 0) {
            // 根据题目规则，当目标值为0时，先手直接获胜
            return true;
        }
        
        // 计算1到n的总和
        int sum = n * (n + 1) / 2;
        if (sum < m) {
            // 如果总和小于目标值，任何人都无法获胜
            return false;
        }
        
        // 创建状态压缩DP数组
        // dp[mask] 表示在mask状态下，当前玩家是否能赢
        // -1: 未计算, 0: 不能赢, 1: 能赢
        int dp[1024 * 32];  // 假设n最大为10
        for (int i = 0; i < (1 << (n + 1)); i++) {
            dp[i] = -1;
        }
        
        // 初始状态是所有数字都可用，即全1的二进制状态
        return dfs(n, (1 << (n + 1)) - 1, m, dp);
    }

private:
    // 深度优先搜索 + 记忆化
    // n: 可选数字范围是1~n
    // mask: 当前数字使用状态，二进制位为1表示对应数字可用
    // rest: 还需要的目标值
    // dp: 记忆化数组
    bool dfs(int n, int mask, int rest, int* dp) {
        // 递归终止条件：剩余目标值 <= 0，说明上一个玩家已经获胜
        if (rest <= 0) {
            return false;
        }
        
        // 检查是否已经计算过当前状态
        if (dp[mask] != -1) {
            return dp[mask] == 1;
        }
        
        // 尝试选择每一个可用的数字
        bool canWin = false;
        for (int i = 1; i <= n; i++) {
            // 检查数字i是否可用（对应位是否为1）
            if ((mask & (1 << i)) != 0) {
                // 选择数字i后，递归调用对方玩家的回合
                // 如果对方玩家不能赢，那么当前玩家能赢
                if (!dfs(n, mask ^ (1 << i), rest - i, dp)) {
                    canWin = true;
                    break;  // 找到一个必胜策略即可返回
                }
            }
        }
        
        // 记录结果到dp数组中
        dp[mask] = canWin ? 1 : 0;
        return canWin;
    }
};

/*
复杂度分析：
- 时间复杂度：O(n * 2^n)
  状态数为2^n个（每个数字有选或不选两种状态），每个状态需要遍历n个数字
  由于使用了记忆化搜索，每个状态只计算一次

- 空间复杂度：O(2^n)
  dp数组需要存储2^n个状态的结果
  递归调用栈的深度最多为n（每次选择一个数字）

注意事项：
1. 边界条件处理：当目标值为0时直接返回true
2. 总和检查：如果1到n的总和小于目标值，任何人都无法获胜
3. 位运算优化：使用位运算高效地管理数字的使用状态
4. 记忆化搜索：避免重复计算相同状态

这是本题的最优解，因为问题的性质决定了我们需要枚举所有可能的选择，而状态压缩DP是解决这类问题的标准方法。
*/