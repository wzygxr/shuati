#include <iostream>
#include <bitset>
#include <vector>
#include <cstring>
using namespace std;

// POJ 2443 Set Operation
// 题目链接: http://poj.org/problem?id=2443
// 题目大意:
// 给定N个集合，第i个集合S(i)有C(i)个元素（集合可以包含两个相同的元素）。
// 集合中的每个元素都用1~10000的正数表示。
// 查询两个给定元素i和j是否同时属于至少一个集合。
// 换句话说，确定是否存在一个数字k(1≤k≤N)，使得元素i和元素j都属于S(k)。
//
// 输入:
// 第一行包含一个整数N(1 <= N <= 1000)，表示集合的数量。
// 接下来N行，每行以数字C(i)(1 <= C(i) <= 10000)开始，然后是C(i)个数字，
// 这些数字用空格分隔，给出集合中的元素（这些C(i)个数字不需要彼此不同）。
// 第N+2行包含一个数字Q(1 <= Q <= 200000)，表示查询的数量。
// 然后是Q行。每行包含一对数字i和j(1 <= i, j <= 10000，i可以等于j)，
// 描述需要回答的元素。
//
// 输出:
// 对于每个查询，在一行中，如果存在这样的数字k，打印"Yes"；否则打印"No"。
//
// 解题思路:
// 使用bitset优化的方法:
// 1. 对于每个元素x，我们用一个bitset记录它在哪些集合中出现过
// 2. 对于查询(x,y)，我们检查vis[x] & vis[y]是否为0
//    如果不为0，说明存在至少一个集合同时包含x和y
// 时间复杂度: O(N*C + Q)  其中C是集合的平均大小
// 空间复杂度: O(10000 * N / 32) = O(312500) bit

const int MAXN = 1001;     // 集合数量最大值
const int MAXV = 10001;    // 元素值最大值

// 使用bitset优化的方法
// vis[x]表示元素x在哪些集合中出现过
// 例如：如果元素5在第1、3、4个集合中出现过，那么vis[5]的第1、3、4位为1
bitset<MAXN> vis[MAXV];    // vis[x]表示元素x在哪些集合中出现过

// 主函数，处理输入并输出结果
int main() {
    // 优化输入输出速度，关闭stdio同步，解除cin与cout的绑定
    ios::sync_with_stdio(false);
    cin.tie(0);
    
    int n;  // 集合数量
    // 读取集合数量
    cin >> n;
    
    // 读取每个集合
    // 对于第i个集合，读取其中的所有元素，并在对应元素的bitset中将第i位置为1
    for (int i = 1; i <= n; i++) {
        int c;  // 第i个集合中元素的数量
        // 读取第i个集合中元素的数量
        cin >> c;
        // 读取第i个集合中的所有元素
        for (int j = 1; j <= c; j++) {
            int x;  // 集合中的元素
            // 读取元素值
            cin >> x;
            // 标记元素x在第i个集合中出现过
            // set(i)方法将bitset中第i位设置为1
            vis[x].set(i);
        }
    }
    
    // 处理查询
    int q;  // 查询数量
    // 读取查询数量
    cin >> q;
    // 处理每个查询
    for (int i = 0; i < q; i++) {
        int x, y;  // 查询的两个元素
        // 读取查询的两个元素
        cin >> x >> y;
        
        // 检查是否存在一个集合同时包含x和y
        // 通过按位与操作检查是否有共同的集合
        // (vis[x] & vis[y])计算两个bitset的按位与结果
        // .any()检查结果中是否有任何位为1
        if ((vis[x] & vis[y]).any()) {
            // 存在至少一个集合同时包含x和y
            cout << "Yes\n";
        } else {
            // 不存在同时包含x和y的集合
            cout << "No\n";
        }
    }
    
    return 0;
}