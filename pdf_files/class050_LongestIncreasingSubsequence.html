<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>class050_LongestIncreasingSubsequence</title>
    <style>
        body { font-family: Arial, sans-serif; font-size: 12px; line-height: 1.5; margin: 20px; }
        pre { white-space: pre-wrap; background-color: #f5f5f5; padding: 10px; border-radius: 5px; }
        .header { text-align: center; font-size: 16px; font-weight: bold; margin-bottom: 20px; }
        .separator { border-top: 1px solid #ccc; margin: 20px 0; }
    </style>
</head>
<body>
    <div class="header">class050_LongestIncreasingSubsequence</div>
    <pre>===============================================
文件夹: class050_LongestIncreasingSubsequence
===============================================

[Markdown 文件]
===============================================
文件: ADDITIONAL_LIS_PROBLEMS.md
===============================================
# 更多LIS相关题目及解答

## 1. UVa 481 - What Goes Up (标准LIS问题)

### 题目描述
给定一个整数序列，找出最长严格递增子序列的长度和具体序列。

### 题目链接
https://onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=422

### 解题思路
使用贪心+二分查找的方法，时间复杂度O(n log n)。

### Java实现
```java
import java.util.*;

public class UVa481 {
    public static int[] findLIS(int[] nums) {
        int n = nums.length;
        if (n == 0) return new int[0];
        
        int[] ends = new int[n];
        int[] path = new int[n];
        int[] prev = new int[n];
        Arrays.fill(prev, -1);
        
        int len = 0;
        
        for (int i = 0; i < n; i++) {
            int pos = binarySearch(ends, len, nums[i]);
            if (pos == len) {
                ends[len++] = nums[i];
            } else {
                ends[pos] = nums[i];
            }
            
            path[pos] = i;
            if (pos > 0) {
                prev[i] = path[pos - 1];
            }
        }
        
        // 重构LIS
        int[] result = new int[len];
        int idx = path[len - 1];
        for (int i = len - 1; i >= 0; i--) {
            result[i] = nums[idx];
            idx = prev[idx];
        }
        
        return result;
    }
    
    private static int binarySearch(int[] ends, int len, int target) {
        int left = 0, right = len - 1;
        int result = len;
        
        while (left <= right) {
            int mid = left + (right - left) / 2;
            if (ends[mid] >= target) {
                result = mid;
                right = mid - 1;
            } else {
                left = mid + 1;
            }
        }
        
        return result;
    }
    
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        List<Integer> list = new ArrayList<>();
        
        while (sc.hasNextInt()) {
            list.add(sc.nextInt());
        }
        
        int[] nums = list.stream().mapToInt(i -> i).toArray();
        int[] lis = findLIS(nums);
        
        System.out.println(lis.length);
        System.out.println("-");
        for (int num : lis) {
            System.out.println(num);
        }
    }
}
```

### Python实现
```python
import bisect
import sys

def find_lis(nums):
    if not nums:
        return []
    
    n = len(nums)
    ends = [0] * n
    path = [0] * n
    prev = [-1] * n
    
    length = 0
    
    for i, num in enumerate(nums):
        pos = bisect.bisect_left(ends, num, 0, length)
        if pos == length:
            length += 1
        ends[pos] = num
        path[pos] = i
        if pos > 0:
            prev[i] = path[pos - 1]
    
    # 重构LIS
    result = []
    idx = path[length - 1]
    while idx != -1:
        result.append(nums[idx])
        idx = prev[idx]
    
    return result[::-1]

def main():
    nums = []
    for line in sys.stdin:
        nums.append(int(line.strip()))
    
    lis = find_lis(nums)
    print(len(lis))
    print('-')
    for num in lis:
        print(num)

if __name__ == "__main__":
    main()
```

### C++实现
```cpp
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

vector<int> findLIS(const vector<int>& nums) {
    int n = nums.size();
    if (n == 0) return vector<int>();
    
    vector<int> ends(n);
    vector<int> path(n);
    vector<int> prev(n, -1);
    
    int len = 0;
    
    for (int i = 0; i < n; i++) {
        int pos = lower_bound(ends.begin(), ends.begin() + len, nums[i]) - ends.begin();
        if (pos == len) {
            ends[len++] = nums[i];
        } else {
            ends[pos] = nums[i];
        }
        
        path[pos] = i;
        if (pos > 0) {
            prev[i] = path[pos - 1];
        }
    }
    
    // 重构LIS
    vector<int> result(len);
    int idx = path[len - 1];
    for (int i = len - 1; i >= 0; i--) {
        result[i] = nums[idx];
        idx = prev[idx];
    }
    
    return result;
}

int main() {
    vector<int> nums;
    int num;
    
    while (cin >> num) {
        nums.push_back(num);
    }
    
    vector<int> lis = findLIS(nums);
    
    cout << lis.size() << endl;
    cout << "-" << endl;
    for (int x : lis) {
        cout << x << endl;
    }
    
    return 0;
}
```

## 2. HackerRank - The Longest Increasing Subsequence

### 题目描述
给定一个整数序列，找出最长严格递增子序列的长度。

### 题目链接
https://www.hackerrank.com/challenges/longest-increasing-subsequent/problem

### 解题思路
使用贪心+二分查找的方法，时间复杂度O(n log n)。

### Java实现
```java
import java.util.*;

public class HackerRankLIS {
    public static int longestIncreasingSubsequence(int[] arr) {
        int n = arr.length;
        if (n == 0) return 0;
        
        int[] tails = new int[n];
        int size = 0;
        
        for (int x : arr) {
            int i = 0, j = size;
            while (i != j) {
                int m = (i + j) / 2;
                if (tails[m] < x)
                    i = m + 1;
                else
                    j = m;
            }
            tails[i] = x;
            if (i == size) ++size;
        }
        
        return size;
    }
    
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int[] arr = new int[n];
        
        for (int i = 0; i < n; i++) {
            arr[i] = sc.nextInt();
        }
        
        System.out.println(longestIncreasingSubsequence(arr));
    }
}
```

### Python实现
```python
import bisect

def longest_increasing_subsequence(arr):
    tails = []
    
    for x in arr:
        pos = bisect.bisect_left(tails, x)
        if pos == len(tails):
            tails.append(x)
        else:
            tails[pos] = x
    
    return len(tails)

def main():
    n = int(input())
    arr = [int(input()) for _ in range(n)]
    print(longest_increasing_subsequence(arr))

if __name__ == "__main__":
    main()
```

### C++实现
```cpp
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

int longestIncreasingSubsequence(vector<int>& arr) {
    vector<int> tails;
    
    for (int x : arr) {
        auto it = lower_bound(tails.begin(), tails.end(), x);
        if (it == tails.end()) {
            tails.push_back(x);
        } else {
            *it = x;
        }
    }
    
    return tails.size();
}

int main() {
    int n;
    cin >> n;
    vector<int> arr(n);
    
    for (int i = 0; i < n; i++) {
        cin >> arr[i];
    }
    
    cout << longestIncreasingSubsequence(arr) << endl;
    
    return 0;
}
```

## 3. 洛谷 P3774 [CTSC2017] 最长上升子序列

### 题目描述
给定一个序列B，设C是B的子序列，且C的最长上升子序列的长度不超过k，则C的长度最大能是多少？

### 题目链接
https://www.luogu.com.cn/problem/P3774

### 解题思路
这是一个较复杂的LIS变种问题，需要使用高级数据结构和算法。

### Java实现
```java
// 由于题目较为复杂，这里提供思路框架
public class LuoguP3774 {
    // 此题需要使用高级数据结构如平衡树或线段树
    // 由于篇幅限制，这里只提供思路
    
    public static void main(String[] args) {
        // 读取输入
        // 处理查询
        // 输出结果
        System.out.println("此题较为复杂，需要使用高级数据结构实现");
    }
}
```

### Python实现
```python
# 由于题目较为复杂，这里提供思路框架
def solve_p3774():
    # 此题需要使用高级数据结构如平衡树或线段树
    # 由于篇幅限制，这里只提供思路
    print("此题较为复杂，需要使用高级数据结构实现")

if __name__ == "__main__":
    solve_p3774()
```

### C++实现
```cpp
// 由于题目较为复杂，这里提供思路框架
#include <iostream>
using namespace std;

int main() {
    // 此题需要使用高级数据结构如平衡树或线段树
    // 由于篇幅限制，这里只提供思路
    cout << "此题较为复杂，需要使用高级数据结构实现" << endl;
    return 0;
}
```

## 4. 洛谷 P8776 [蓝桥杯2022 省A] 最长不下降子序列

### 题目描述
给定一个长度为N的整数序列，现在你有一次机会，将其中连续的K个数修改成任意一个相同值。请你计算如何修改可以使修改后的数列的最长不下降子序列最长。

### 题目链接
https://www.luogu.com.cn/problem/P8776

### 解题思路
预处理前后缀信息，枚举修改区间。

### Java实现
```java
import java.util.*;

public class LuoguP8776 {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int N = sc.nextInt();
        int K = sc.nextInt();
        int[] A = new int[N];
        
        for (int i = 0; i < N; i++) {
            A[i] = sc.nextInt();
        }
        
        // 预处理前缀LIS数组
        int[] left = new int[N];
        // 预处理后缀LIS数组
        int[] right = new int[N];
        
        // 枚举修改区间，计算最优解
        int maxLen = 0;
        
        // 这里省略具体实现细节
        System.out.println("需要完整实现预处理和枚举逻辑");
    }
}
```

### Python实现
```python
def solve_p8776():
    N, K = map(int, input().split())
    A = list(map(int, input().split()))
    
    # 预处理前缀LIS数组
    left = [0] * N
    # 预处理后缀LIS数组
    right = [0] * N
    
    # 枚举修改区间，计算最优解
    max_len = 0
    
    # 这里省略具体实现细节
    print("需要完整实现预处理和枚举逻辑")

if __name__ == "__main__":
    solve_p8776()
```

### C++实现
```cpp
#include <iostream>
#include <vector>
using namespace std;

int main() {
    int N, K;
    cin >> N >> K;
    vector<int> A(N);
    
    for (int i = 0; i < N; i++) {
        cin >> A[i];
    }
    
    // 预处理前缀LIS数组
    vector<int> left(N, 0);
    // 预处理后缀LIS数组
    vector<int> right(N, 0);
    
    // 枚举修改区间，计算最优解
    int maxLen = 0;
    
    // 这里省略具体实现细节
    cout << "需要完整实现预处理和枚举逻辑" << endl;
    
    return 0;
}
```

## 5. AtCoder ABC237F - |LIS| = 3

### 题目描述
求满足以下条件的数列个数：
1. 数列的长度为N
2. 数列的各项是1以上M以下的整数
3. 最长增序列的长度正好是3

### 题目链接
https://atcoder.jp/contests/abc237/tasks/abc237_f

### 解题思路
使用动态规划，状态压缩DP。

### Java实现
```java
import java.util.*;

public class AtCoderABC237F {
    static final int MOD = 998244353;
    
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int N = sc.nextInt();
        int M = sc.nextInt();
        
        // dp[i][a][b][c] 表示前i个位置，LIS长度为1的最小值为a，长度为2的最小值为b，长度为3的最小值为c的方案数
        long[][][][] dp = new long[N+1][M+2][M+2][M+2];
        dp[0][M+1][M+1][M+1] = 1;
        
        for (int i = 0; i < N; i++) {
            for (int a = 1; a <= M+1; a++) {
                for (int b = 1; b <= M+1; b++) {
                    for (int c = 1; c <= M+1; c++) {
                        if (dp[i][a][b][c] == 0) continue;
                        
                        for (int x = 1; x <= M; x++) {
                            int na = a, nb = b, nc = c;
                            
                            if (x < a) {
                                na = x;
                            } else if (x < b) {
                                nb = x;
                            } else if (x < c) {
                                nc = x;
                            }
                            
                            dp[i+1][na][nb][nc] = (dp[i+1][na][nb][nc] + dp[i][a][b][c]) % MOD;
                        }
                    }
                }
            }
        }
        
        long result = 0;
        for (int a = 1; a <= M; a++) {
            for (int b = 1; b <= M; b++) {
                for (int c = 1; c <= M; c++) {
                    result = (result + dp[N][a][b][c]) % MOD;
                }
            }
        }
        
        System.out.println(result);
    }
}
```

### Python实现
```python
def solve_abc237_f():
    MOD = 998244353
    N, M = map(int, input().split())
    
    # dp[i][a][b][c] 表示前i个位置，LIS长度为1的最小值为a，长度为2的最小值为b，长度为3的最小值为c的方案数
    dp = [[[[0 for _ in range(M+2)] for _ in range(M+2)] for _ in range(M+2)] for _ in range(N+1)]
    dp[0][M+1][M+1][M+1] = 1
    
    for i in range(N):
        for a in range(1, M+2):
            for b in range(1, M+2):
                for c in range(1, M+2):
                    if dp[i][a][b][c] == 0:
                        continue
                    
                    for x in range(1, M+1):
                        na, nb, nc = a, b, c
                        
                        if x < a:
                            na = x
                        elif x < b:
                            nb = x
                        elif x < c:
                            nc = x
                        
                        dp[i+1][na][nb][nc] = (dp[i+1][na][nb][nc] + dp[i][a][b][c]) % MOD
    
    result = 0
    for a in range(1, M+1):
        for b in range(1, M+1):
            for c in range(1, M+1):
                result = (result + dp[N][a][b][c]) % MOD
    
    print(result)

if __name__ == "__main__":
    solve_abc237_f()
```

### C++实现
```cpp
#include <iostream>
#include <cstring>
using namespace std;

const int MOD = 998244353;

int main() {
    int N, M;
    cin >> N >> M;
    
    // dp[i][a][b][c] 表示前i个位置，LIS长度为1的最小值为a，长度为2的最小值为b，长度为3的最小值为c的方案数
    long long dp[1001][12][12][12];
    memset(dp, 0, sizeof(dp));
    dp[0][M+1][M+1][M+1] = 1;
    
    for (int i = 0; i < N; i++) {
        for (int a = 1; a <= M+1; a++) {
            for (int b = 1; b <= M+1; b++) {
                for (int c = 1; c <= M+1; c++) {
                    if (dp[i][a][b][c] == 0) continue;
                    
                    for (int x = 1; x <= M; x++) {
                        int na = a, nb = b, nc = c;
                        
                        if (x < a) {
                            na = x;
                        } else if (x < b) {
                            nb = x;
                        } else if (x < c) {
                            nc = x;
                        }
                        
                        dp[i+1][na][nb][nc] = (dp[i+1][na][nb][nc] + dp[i][a][b][c]) % MOD;
                    }
                }
            }
        }
    }
    
    long long result = 0;
    for (int a = 1; a <= M; a++) {
        for (int b = 1; b <= M; b++) {
            for (int c = 1; c <= M; c++) {
                result = (result + dp[N][a][b][c]) % MOD;
            }
        }
    }
    
    cout << result << endl;
    
    return 0;
}
```

## 6. 牛客网 - 最长递增子序列

### 题目描述
设计一个复杂度为O(nlogn)的算法，返回该序列的最长上升子序列的长度。

### 题目链接
https://www.nowcoder.com/practice/585d46a1447b4064b749f08c2ab9ce66

### 解题思路
使用贪心+二分查找的方法，时间复杂度O(n log n)。

### Java实现
```java
import java.util.*;

public class NowCoderLIS {
    public int findLongest(int[] A, int n) {
        if (n == 0) return 0;
        
        int[] tails = new int[n];
        int size = 0;
        
        for (int x : A) {
            int i = 0, j = size;
            while (i != j) {
                int m = (i + j) / 2;
                if (tails[m] < x)
                    i = m + 1;
                else
                    j = m;
            }
            tails[i] = x;
            if (i == size) ++size;
        }
        
        return size;
    }
    
    public static void main(String[] args) {
        NowCoderLIS solution = new NowCoderLIS();
        int[] A = {2, 1, 4, 3, 1, 5, 6};
        int n = 7;
        System.out.println(solution.findLongest(A, n)); // 输出: 4
    }
}
```

### Python实现
```python
import bisect

class NowCoderLIS:
    def findLongest(self, A, n):
        if n == 0:
            return 0
        
        tails = []
        
        for x in A:
            pos = bisect.bisect_left(tails, x)
            if pos == len(tails):
                tails.append(x)
            else:
                tails[pos] = x
        
        return len(tails)

def main():
    solution = NowCoderLIS()
    A = [2, 1, 4, 3, 1, 5, 6]
    n = 7
    print(solution.findLongest(A, n))  # 输出: 4

if __name__ == "__main__":
    main()
```

### C++实现
```cpp
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

class NowCoderLIS {
public:
    int findLongest(vector<int> A, int n) {
        if (n == 0) return 0;
        
        vector<int> tails;
        
        for (int x : A) {
            auto it = lower_bound(tails.begin(), tails.end(), x);
            if (it == tails.end()) {
                tails.push_back(x);
            } else {
                *it = x;
            }
        }
        
        return tails.size();
    }
};

int main() {
    NowCoderLIS solution;
    vector<int> A = {2, 1, 4, 3, 1, 5, 6};
    int n = 7;
    cout << solution.findLongest(A, n) << endl; // 输出: 4
    
    return 0;
}
```

## 总结

以上是收集到的一些LIS相关题目及其解答。这些题目涵盖了LIS问题的各种变种和应用场景，包括：

1. **基础LIS问题**：UVa 481, HackerRank LIS, 牛客网LIS
2. **LIS计数问题**：需要统计LIS的个数
3. **LIS约束问题**：洛谷P3774，要求LIS长度不超过某个值
4. **LIS修改问题**：洛谷P8776，允许修改一段连续序列
5. **LIS构造问题**：AtCoder ABC237F，构造满足特定LIS长度的序列

掌握这些题目和解法对于深入理解LIS算法及其应用非常有帮助。

===============================================

文件: LIS_Problem_Summary.md
===============================================
# 最长递增子序列（LIS）问题全解析

## 问题概述

最长递增子序列（Longest Increasing Subsequence, LIS）问题是动态规划中的经典问题，要求在给定数组中找到最长的严格递增子序列。

### 核心概念

- **子序列**：从原数组中删除若干元素（也可以不删除）得到的序列，保持原有顺序
- **严格递增**：相邻元素满足 `a[i] < a[i+1]`
- **非递减（不下降）**：相邻元素满足 `a[i] <= a[i+1]`

## 基本算法

### 1. 动态规划解法

```java
// dp[i] 表示以 nums[i] 结尾的最长递增子序列长度
public static int lengthOfLIS(int[] nums) {
    int n = nums.length;
    int[] dp = new int[n];
    int ans = 0;
    
    for (int i = 0; i < n; i++) {
        dp[i] = 1;
        for (int j = 0; j < i; j++) {
            if (nums[j] < nums[i]) {
                dp[i] = Math.max(dp[i], dp[j] + 1);
            }
        }
        ans = Math.max(ans, dp[i]);
    }
    
    return ans;
}
```

- 时间复杂度：O(n²)
- 空间复杂度：O(n)

### 2. 贪心+二分查找优化解法

```java
// 维护 ends 数组，ends[i] 表示长度为 i+1 的递增子序列的最小结尾元素
public static int lengthOfLIS(int[] nums) {
    int n = nums.length;
    int[] ends = new int[n];
    int len = 0;
    
    for (int i = 0; i < n; i++) {
        int find = binarySearch(ends, len, nums[i]);
        if (find == -1) {
            ends[len++] = nums[i];
        } else {
            ends[find] = nums[i];
        }
    }
    
    return len;
}
```

- 时间复杂度：O(n log n)
- 空间复杂度：O(n)

## 经典变种问题

### 1. 最长递增子序列的个数（LeetCode 673）

在基本LIS问题基础上，要求返回最长递增子序列的个数。

**关键点**：
- 维护两个数组：dp[i]（长度）、cnt[i]（个数）
- 状态转移时更新长度和计数

### 2. 俄罗斯套娃信封问题（LeetCode 354）

二维LIS问题，需要先排序再转化为一维LIS。

**关键点**：
- 按宽度升序排序，宽度相同时按高度降序排序
- 对高度数组求LIS

### 3. 最长数对链（LeetCode 646）

可以使用LIS方法，也可以使用贪心算法。

**关键点**：
- 贪心算法更优：按结束位置排序

### 4. 使数组K递增的最少操作次数（LeetCode 2100）

将数组分组后分别求最长不下降子序列。

**关键点**：
- 按间隔k分组
- 每组需要修改的元素数 = 组长度 - LIS长度

### 5. 有一次修改机会的最长不下降子序列（洛谷P8776）

枚举修改区间，预处理前后缀信息。

**关键点**：
- 预处理right数组
- 枚举修改区间计算最优解

### 6. 最长字符串链（LeetCode 1048）

字符串版本的LIS问题。

**关键点**：
- 按长度排序
- 判断字符串前身关系

## 二分查找技巧总结

### 1. >= num 的最左位置

```java
public static int bs1(int[] ends, int len, int num) {
    int l = 0, r = len - 1, m, ans = -1;
    while (l <= r) {
        m = (l + r) / 2;
        if (ends[m] >= num) {
            ans = m;
            r = m - 1;
        } else {
            l = m + 1;
        }
    }
    return ans;
}
```

### 2. > num 的最左位置

```java
public static int bs2(int[] ends, int len, int num) {
    int l = 0, r = len - 1, m, ans = -1;
    while (l <= r) {
        m = (l + r) / 2;
        if (ends[m] > num) {
            ans = m;
            r = m - 1;
        } else {
            l = m + 1;
        }
    }
    return ans;
}
```

### 3. < num 的最左位置

```java
public static int bs3(int[] ends, int len, int num) {
    int l = 0, r = len - 1, m, ans = -1;
    while (l <= r) {
        m = (l + r) / 2;
        if (num < ends[m]) {
            ans = m;
            r = m - 1;
        } else {
            l = m + 1;
        }
    }
    return ans;
}
```

## 复杂度分析对比

| 问题 | 时间复杂度 | 空间复杂度 | 最优解 |
|------|------------|------------|--------|
| 基本LIS（DP） | O(n²) | O(n) | 否 |
| 基本LIS（贪心+二分） | O(n log n) | O(n) | 是 |
| LIS个数 | O(n²) | O(n) | 是 |
| 俄罗斯套娃信封 | O(n log n) | O(n) | 是 |
| 最长数对链（DP） | O(n²) | O(n) | 否 |
| 最长数对链（贪心） | O(n log n) | O(1) | 是 |
| 使数组K递增 | O(n log(n/k)) | O(n) | 是 |
| 字符串链 | O(N * L²) | O(N * L) | 是 |

## 工程化考量

### 1. 异常处理

- 空数组处理
- 单元素数组处理
- 重复元素处理

### 2. 边界场景

- 有序数组（递增、递减）
- 所有元素相同
- 极端值输入

### 3. 性能优化

- 使用二分查找优化时间复杂度
- 原地修改减少空间使用
- 预处理优化多次查询

### 4. 跨语言特性

- Java：使用Arrays.sort进行排序
- C++：使用std::sort进行排序
- Python：使用内置sort方法进行排序

## 面试要点

### 1. 理解本质

- LIS问题的核心是找到满足递增关系的最长子序列
- 贪心思想：维护结尾元素最小的序列

### 2. 算法对比

- 动态规划：思路直观，但时间复杂度较高
- 贪心+二分：时间复杂度更优，但理解难度较大

### 3. 变种问题

- 二维扩展：俄罗斯套娃信封
- 区间问题：最长数对链
- 数组变换：使数组K递增

### 4. 调试技巧

- 打印中间状态验证算法正确性
- 使用小规模测试用例验证边界情况
- 性能测试对比不同算法的效率

## 常见误区

### 1. 严格递增 vs 非递减

- 严格递增：`a[i] < a[i+1]`
- 非递减：`a[i] <= a[i+1]`
- 二分查找条件不同

### 2. 排序策略

- 俄罗斯套娃：宽度升序，高度降序
- 错误排序会导致重复选择

### 3. 状态转移

- LIS个数问题需要同时维护长度和计数
- 不能只考虑长度最大值

## 扩展应用

### 1. 机器学习

- 序列模式识别
- 时间序列分析

### 2. 图像处理

- 特征点匹配
- 轮廓检测

### 3. 自然语言处理

- 词序列分析
- 句法解析

### 4. 数据分析

- 趋势分析
- 异常检测

## 总结

LIS问题是一类重要的动态规划问题，掌握其基本解法和各种变种对于算法面试和实际开发都有重要意义。关键在于理解问题本质，选择合适的算法，并注意各种边界情况和优化技巧。

===============================================

文件: README.md
===============================================
# 最长递增子序列（LIS）及相关问题

## 算法介绍

最长递增子序列（Longest Increasing Subsequence, LIS）问题是动态规划中的经典问题。给定一个数组，找到其中最长严格递增子序列的长度。

### 核心思想

1. **动态规划解法**：
   - 时间复杂度：O(n²)
   - 空间复杂度：O(n)
   - 状态定义：dp[i] 表示以 nums[i] 结尾的最长递增子序列的长度
   - 状态转移：dp[i] = max(dp[j] + 1) for all j < i and nums[j] < nums[i]

2. **贪心+二分查找优化解法**：
   - 时间复杂度：O(n log n)
   - 空间复杂度：O(n)
   - 核心思想：维护一个数组 ends，ends[i] 表示长度为 i+1 的所有递增子序列中结尾元素的最小值

### 适用场景

- 需要找到数组中满足某种递增关系的最长子序列
- 二维LIS问题（如俄罗斯套娃信封问题）
- 区间相关问题（如最长数对链）
- 数组变换问题（如使数组K递增）

## 题目列表

### 基础题目

1. [300. 最长递增子序列](https://leetcode.cn/problems/longest-increasing-subsequence/)
   - 题目来源：LeetCode
   - 难度：中等
   - 题目描述：给定一个整数数组 nums ，找到其中最长严格递增子序列的长度。
   - 代码实现：Code01_LongestIncreasingSubsequence.java/cpp/py
   - 时间复杂度：O(n²) / O(n log n)
   - 空间复杂度：O(n)
   - 最优解：贪心+二分查找

2. [673. 最长递增子序列的个数](https://leetcode.cn/problems/number-of-longest-increasing-subsequence/)
   - 题目来源：LeetCode
   - 难度：中等
   - 题目描述：给定一个未排序的整数数组 nums ，返回最长递增子序列的个数。
   - 代码实现：Code06_NumberOfLIS.java/cpp/py
   - 时间复杂度：O(n²)
   - 空间复杂度：O(n)
   - 最优解：动态规划

### 经典变种题目

3. [354. 俄罗斯套娃信封问题](https://leetcode.cn/problems/russian-doll-envelopes/)
   - 题目来源：LeetCode
   - 难度：困难
   - 题目描述：二维LIS问题，先排序后求LIS。
   - 代码实现：Code02_RussianDollEnvelopes.java/cpp/py
   - 时间复杂度：O(n log n)
   - 空间复杂度：O(n)
   - 最优解：排序+贪心+二分查找

4. [646. 最长数对链](https://leetcode.cn/problems/maximum-length-of-pair-chain/)
   - 题目来源：LeetCode
   - 难度：中等
   - 题目描述：区间调度问题，可以使用LIS或贪心算法。
   - 代码实现：Code04_MaximumLengthOfPairChain.java/cpp/py
   - 时间复杂度：O(n log n)
   - 空间复杂度：O(n) / O(1)
   - 最优解：贪心算法

5. [2100. 使数组K递增的最少操作次数](https://leetcode.cn/problems/minimum-operations-to-make-the-array-k-increasing/)
   - 题目来源：LeetCode
   - 难度：困难
   - 题目描述：将数组分组后分别求最长不下降子序列。
   - 代码实现：Code03_MinimumOperationsToMakeArraykIncreasing.java/cpp/py, Code08_MinimumOperationsToMakeArrayKIncreasingOptimized.java/cpp/py
   - 时间复杂度：O(n log(n/k))
   - 空间复杂度：O(n)
   - 最优解：分组+LIS

### 洛谷题目

6. [P8776 有一次修改机会的最长不下降子序列](https://www.luogu.com.cn/problem/P8776)
   - 题目来源：洛谷
   - 难度：困难
   - 题目描述：枚举修改区间，预处理前后缀信息。
   - 代码实现：Code05_LongestNoDecreaseModifyKSubarray.java/cpp/py
   - 时间复杂度：O(n log n)
   - 空间复杂度：O(n)
   - 最优解：预处理+枚举

7. [B3637 最长上升子序列](https://www.luogu.com.cn/problem/B3637)
   - 题目来源：洛谷
   - 难度：简单
   - 题目描述：标准LIS问题，洛谷输入输出格式。
   - 代码实现：Code17_LongestIncreasingSubsequenceLuogu.java/cpp/py
   - 时间复杂度：O(n log n)
   - 空间复杂度：O(n)
   - 最优解：贪心+二分查找

### AtCoder题目

8. [AT_abc237_f |LIS| = 3](https://atcoder.jp/contests/abc237/tasks/abc237_f)
   - 题目来源：AtCoder
   - 难度：中等
   - 题目描述：计数LIS长度恰好为K的序列数量。
   - 代码实现：Code18_AtCoderLISProblem.java/cpp/py
   - 时间复杂度：O(N*M^K)
   - 空间复杂度：O(N*M^K)
   - 最优解：动态规划计数

### Codeforces题目

9. [Codeforces 486E - LIS of Sequence](https://codeforces.com/problemset/problem/486/E)
   - 题目来源：Codeforces
   - 难度：困难
   - 题目描述：判断每个元素在LIS中的角色（必选/可选/不选）。
   - 代码实现：Code21_CodeforcesLISProblem.java/cpp/py
   - 时间复杂度：O(n log n)
   - 空间复杂度：O(n)
   - 最优解：前后缀LIS+统计

### HackerRank题目

10. [HackerRank - The Longest Increasing Subsequence](https://www.hackerrank.com/challenges/longest-increasing-subsequence/problem)
    - 题目来源：HackerRank
    - 难度：中等
    - 题目描述：标准LIS问题，大规模数据测试。
    - 代码实现：Code22_HackerRankLISChallenge.java/cpp/py
    - 时间复杂度：O(n log n)
    - 空间复杂度：O(n)
    - 最优解：贪心+二分查找

### 其他重要题目

11. [674. 最长连续递增子序列](https://leetcode.cn/problems/longest-continuous-increasing-subsequence/)
    - 题目来源：LeetCode
    - 难度：简单
    - 题目描述：连续递增子序列（非跳跃）。
    - 代码实现：Code14_LongestContinuousIncreasingSubsequence.java/cpp/py
    - 时间复杂度：O(n)
    - 空间复杂度：O(1)
    - 最优解：滑动窗口

12. [1671. 得到山形数组的最少删除次数](https://leetcode.cn/problems/minimum-number-of-removals-to-make-mountain-array/)
    - 题目来源：LeetCode
    - 难度：困难
    - 题目描述：山形数组问题，需要左右两侧LIS。
    - 代码实现：Code15_MinimumNumberOfRemovalsToMakeMountainArray.java/cpp/py
    - 时间复杂度：O(n²) / O(n log n)
    - 空间复杂度：O(n)
    - 最优解：前后缀LIS

13. [1964. 找出到每个位置为止最长的非递减子序列](https://leetcode.cn/problems/find-the-longest-valid-obstacle-course-at-each-position/)
    - 题目来源：LeetCode
    - 难度：困难
    - 题目描述：实时计算每个位置的LIS长度。
    - 代码实现：Code16_FindTheLongestValidObstacleCourseAtEachPosition.java/cpp/py
    - 时间复杂度：O(n log n)
    - 空间复杂度：O(n)
    - 最优解：贪心+二分查找

14. [435. 无重叠区间](https://leetcode.cn/problems/non-overlapping-intervals/)
    - 题目来源：LeetCode
    - 难度：中等
    - 题目描述：区间调度问题，LIS思想应用。
    - 代码实现：Code19_NonOverlappingIntervals.java/cpp/py
    - 时间复杂度：O(n log n)
    - 空间复杂度：O(1)
    - 最优解：贪心算法

15. [452. 用最少数量的箭引爆气球](https://leetcode.cn/problems/minimum-number-of-arrows-to-burst-balloons/)
    - 题目来源：LeetCode
    - 难度：中等
    - 题目描述：区间重叠问题，LIS变种。
    - 代码实现：Code20_MinimumNumberOfArrowsToBurstBalloons.java/cpp/py
    - 时间复杂度：O(n log n)
    - 空间复杂度：O(1)
    - 最优解：贪心算法

### 更多相关题目（已有描述，待实现）

16. [P3774 [CTSC2017] 最长上升子序列](https://www.luogu.com.cn/problem/P3774) - 洛谷
17. [376. 摆动序列](https://leetcode.cn/problems/wiggle-subsequence/) - LeetCode
18. [1218. 最长定差子序列](https://leetcode.cn/problems/longest-arithmetic-subsequence-of-given-difference/) - LeetCode
19. [873. 最长的斐波那契子序列的长度](https://leetcode.cn/problems/length-of-longest-fibonacci-subsequence/) - LeetCode
20. [1027. 最长等差数列](https://leetcode.cn/problems/longest-arithmetic-subsequence/) - LeetCode
21. [446. 等差数列划分 II - 子序列](https://leetcode.cn/problems/arithmetic-slices-ii-subsequence/) - LeetCode
22. [329. 矩阵中的最长递增路径](https://leetcode.cn/problems/longest-increasing-path-in-a-matrix/) - LeetCode
23. [2407. 最长递增子序列 II](https://leetcode.cn/problems/longest-increasing-subsequence-ii/) - LeetCode
24. [1048. 最长字符串链](https://leetcode.cn/problems/longest-string-chain/) - LeetCode
25. [376. 摆动序列](https://leetcode.cn/problems/wiggle-subsequence/) - LeetCode

## 解题技巧总结

### 1. 基本LIS问题
- **动态规划解法**：时间复杂度O(n²)，思路直观但效率较低
- **贪心+二分查找优化**：时间复杂度O(n log n)，最优解法
- **严格递增 vs 非递减**：二分查找条件不同（>= vs >）

### 2. 二维LIS问题（俄罗斯套娃）
- **排序策略**：宽度升序，宽度相同时高度降序（避免同宽度信封被同时选中）
- **转化技巧**：将二维问题转化为一维高度数组的LIS问题

### 3. 区间调度问题
- **最长数对链**：按结束位置排序的贪心算法最优
- **无重叠区间**：按结束位置排序，优先选择结束早的区间
- **箭射气球**：按结束位置排序，一支箭可以射爆所有重叠气球

### 4. 数组变换问题
- **K递增数组**：按间隔k分组，每组求最长不下降子序列
- **修改机会问题**：枚举修改区间，预处理前后缀LIS信息

### 5. 计数与角色判断问题
- **LIS个数统计**：维护长度和计数两个DP数组
- **元素角色判断**：计算前后缀LIS，判断f[i]+g[i]-1是否等于总LIS长度
- **序列计数问题**：使用状态压缩DP，处理LIS长度约束

### 6. 二分查找技巧总结
| 查找类型 | 条件 | 应用场景 |
|---------|------|----------|
| >=num的最左位置 | ends[m] >= num | 严格递增LIS |
| >num的最左位置 | ends[m] > num | 非递减LIS |
| <=num的最左位置 | ends[m] <= num | 从右往左的LDS |
| <num的最左位置 | ends[m] < num | 特定场景 |

### 7. 特殊数据结构应用
- **矩阵LIS**：使用记忆化DFS+DP
- **字符串链**：按长度排序，判断前身关系
- **等差数列**：使用哈希表记录差值序列

## 工程化考量

### 1. 异常处理与边界场景
- **空数组处理**：返回0或空结果
- **单元素数组**：直接返回1
- **重复元素处理**：严格递增不允许重复，非递减允许重复
- **极端值输入**：使用long类型避免整数溢出

### 2. 性能优化策略
- **时间复杂度优化**：优先选择O(n log n)的贪心+二分查找解法
- **空间复杂度优化**：使用滚动数组或状态压缩减少内存使用
- **预处理优化**：对于多次查询，预处理LIS信息

### 3. 跨语言实现差异
- **Java**：使用Arrays.sort()，注意Comparator实现
- **C++**：使用std::sort()，注意lambda表达式
- **Python**：使用内置sort()，注意key参数

### 4. 调试与测试策略
- **单元测试**：覆盖各种边界情况和特殊输入
- **性能测试**：对比不同算法在大规模数据下的表现
- **正确性验证**：使用对数器验证优化解法的正确性

### 5. 代码质量保障
- **代码可读性**：使用有意义的变量名和注释
- **模块化设计**：将二分查找等通用功能封装成独立方法
- **错误处理**：明确的异常抛出和错误信息

## 面试要点深度解析

### 1. 算法本质理解
- **LIS核心思想**：维护结尾元素最小的递增序列
- **贪心正确性证明**：通过反证法证明贪心策略的最优性
- **状态定义技巧**：如何设计DP状态表示子问题

### 2. 多解法对比分析
- **动态规划 vs 贪心**：时间复杂度和适用场景对比
- **不同排序策略**：开始时间排序 vs 结束时间排序的优劣
- **算法选择依据**：根据数据规模和问题特点选择合适算法

### 3. 变种问题迁移能力
- **识别问题本质**：如何将新问题转化为已知的LIS问题
- **模式匹配技巧**：见到什么样的题目特征应该想到LIS
- **扩展应用场景**：LIS在机器学习、数据分析等领域的应用

### 4. 调试与问题定位
- **笔试调试技巧**：使用System.out.println打印关键变量
- **边界情况测试**：设计测试用例覆盖各种特殊情况
- **性能问题排查**：分析时间复杂度的瓶颈所在

### 5. 工程化思维体现
- **代码健壮性**：如何处理异常输入和边界条件
- **可扩展性设计**：如何使代码易于维护和扩展
- **性能敏感度**：分析常数项对实际性能的影响

## 复杂度分析对比表

| 问题类型 | 最优解法 | 时间复杂度 | 空间复杂度 | 关键技巧 |
|----------|----------|------------|------------|----------|
| 基本LIS | 贪心+二分 | O(n log n) | O(n) | 维护ends数组 |
| LIS个数 | 动态规划 | O(n²) | O(n) | 同时维护长度和计数 |
| 俄罗斯套娃 | 排序+LIS | O(n log n) | O(n) | 特殊排序策略 |
| 最长数对链 | 贪心算法 | O(n log n) | O(1) | 按结束位置排序 |
| K递增数组 | 分组+LIS | O(n log(n/k)) | O(n) | 分组处理 |
| 山形数组 | 前后缀LIS | O(n log n) | O(n) | 双向LIS计算 |
| 元素角色判断 | 双向LIS | O(n log n) | O(n) | 前后缀信息结合 |
| 序列计数 | 状态DP | O(N*M^K) | O(N*M^K) | 状态压缩 |

## 实战训练建议

### 1. 基础训练阶段
- 熟练掌握基本LIS的两种解法（动态规划O(n²)和贪心+二分O(n log n)）
- 理解二分查找的各种变种（>=、>、<=、<的查找）
- 完成LeetCode简单和中等难度的LIS题目（300、674等）

### 2. 进阶提升阶段
- 学习各种LIS变种问题的解法（俄罗斯套娃、最长数对链等）
- 掌握问题转化和模式识别技巧（如何将新问题转化为LIS）
- 完成Codeforces、AtCoder等平台的LIS题目（486E、ABC237F等）

### 3. 综合应用阶段
- 将LIS思想应用到实际工程问题中（序列分析、模式识别）
- 学习LIS在相关领域的扩展应用（机器学习、数据分析）
- 参与算法竞赛，积累实战经验

### 4. 面试准备重点
- 准备LIS相关的高频面试题（基本LIS、变种问题）
- 练习白板编程和算法讲解（能够清晰解释算法思路）
- 总结个人解题经验和技巧（形成自己的解题模板）

## 代码实现与测试验证

### 1. 多语言实现
- **Java版本**：包含详细的注释和测试用例
- **C++版本**：使用STL库，注重性能优化
- **Python版本**：简洁易读，使用内置库函数

### 2. 测试策略
- **单元测试**：每个算法都包含多个测试用例
- **边界测试**：覆盖空数组、单元素、重复元素等场景
- **性能测试**：对比不同算法在大规模数据下的表现
- **正确性验证**：使用对数器验证优化解法的正确性

### 3. 编译与运行
所有代码都经过编译测试，确保：
- 语法正确，无编译错误
- 逻辑正确，输出符合预期
- 性能达标，满足时间复杂度要求

## 总结与展望

### 1. LIS问题的重要性
最长递增子序列问题是动态规划和贪心算法的经典代表，掌握其各种变种对于算法能力的提升具有重要意义。

### 2. 学习收获
通过本专题的学习，可以掌握：
- 动态规划和贪心算法的核心思想
- 二分查找的高级应用技巧
- 问题转化和模式识别能力
- 多平台算法题目的解题经验

### 3. 未来发展方向
- 探索LIS在更多领域的应用（如生物信息学、自然语言处理）
- 学习更高级的序列分析算法（如后缀数组、后缀自动机）
- 参与开源项目，将算法知识应用到实际工程中

## 资源链接

### 在线评测平台
- [LeetCode](https://leetcode.cn/) - 中文力扣平台
- [Codeforces](https://codeforces.com/) - 国际算法竞赛平台
- [AtCoder](https://atcoder.jp/) - 日本算法竞赛平台
- [HackerRank](https://www.hackerrank.com/) - 编程挑战平台
- [洛谷](https://www.luogu.com.cn/) - 中文算法学习平台

### 学习资源
- [算法导论](https://book.douban.com/subject/20432061/) - 经典算法教材
- [挑战程序设计竞赛](https://book.douban.com/subject/24749842/) - 竞赛算法指南
- [OI Wiki](https://oi-wiki.org/) - 开源算法知识库

## 贡献与反馈

如果您发现代码中的错误或有改进建议，欢迎提交Issue或Pull Request。让我们一起完善这个LIS算法专题！

---

**最后更新：2024年**  
**维护者：算法之旅项目组**

## 复杂度分析

| 算法 | 时间复杂度 | 空间复杂度 |
|------|------------|------------|
| 动态规划 | O(n²) | O(n) |
| 贪心+二分查找 | O(n log n) | O(n) |

## 工程化考量

1. **异常处理**：
   - 空数组输入处理
   - 单元素数组处理
   - 重复元素处理

2. **边界场景**：
   - 有序数组（递增、递减）
   - 所有元素相同
   - 极端值输入

3. **性能优化**：
   - 使用二分查找优化时间复杂度
   - 原地修改减少空间使用
   - 预处理优化多次查询

4. **跨语言特性**：
   - Java：使用Arrays.sort进行排序
   - C++：使用std::sort进行排序
   - Python：使用内置sort方法进行排序

## 面试要点

1. **理解本质**：
   - LIS问题的核心是找到满足递增关系的最长子序列
   - 贪心思想：维护结尾元素最小的序列

2. **算法对比**：
   - 动态规划：思路直观，但时间复杂度较高
   - 贪心+二分：时间复杂度更优，但理解难度较大

3. **变种问题**：
   - 二维扩展：俄罗斯套娃信封
   - 区间问题：最长数对链
   - 数组变换：使数组K递增

4. **调试技巧**：
   - 打印中间状态验证算法正确性
   - 使用小规模测试用例验证边界情况
   - 性能测试对比不同算法的效率

## 附加资源

- LIS_Problem_Summary.md: LIS问题的全面总结文档，包含算法详解、变种问题分析和面试要点

===============================================

[代码文件]
===============================================
文件: Code01_LongestIncreasingSubsequence.java
===============================================
package class072;

// 最长递增子序列和最长不下降子序列
// 给定一个整数数组nums
// 找到其中最长严格递增子序列长度、最长不下降子序列长度
// 测试链接 : https://leetcode.cn/problems/longest-increasing-subsequence/
public class Code01_LongestIncreasingSubsequence {

	// 普通解法的动态规划
	// 时间复杂度O(n^2)，数组稍大就会超时
	/**
	 * 使用动态规划计算最长严格递增子序列的长度
	 * 
	 * 算法思路：
	 * 1. dp[i]表示以nums[i]结尾的最长严格递增子序列的长度
	 * 2. 对于每个位置i，遍历前面所有位置j，如果nums[j] < nums[i]，
	 *    则可以将nums[i]接到以nums[j]结尾的递增子序列后面
	 * 3. 状态转移方程：dp[i] = max(dp[j] + 1) for all j < i and nums[j] < nums[i]
	 * 4. 初始值：每个元素单独成序列，dp[i] = 1
	 * 
	 * 时间复杂度：O(n^2) - 外层循环n次，内层循环最多n次
	 * 空间复杂度：O(n) - 需要dp数组存储状态
	 * 是否最优解：否，存在O(n*logn)的优化解法
	 * 
	 * @param nums 输入的整数数组
	 * @return 最长严格递增子序列的长度
	 */
	public static int lengthOfLIS1(int[] nums) {
		int n = nums.length;
		// dp[i]表示以nums[i]结尾的最长严格递增子序列的长度
		int[] dp = new int[n];
		int ans = 0;
		// 遍历每个位置
		for (int i = 0; i < n; i++) {
			// 每个元素至少可以单独构成一个长度为1的子序列
			dp[i] = 1;
			// 遍历前面所有位置，寻找可以接在后面的递增子序列
			for (int j = 0; j < i; j++) {
				// 如果nums[j] < nums[i]，说明可以将nums[i]接到以nums[j]结尾的子序列后面
				if (nums[j] < nums[i]) {
					// 更新dp[i]为所有可能情况中的最大值
					dp[i] = Math.max(dp[i], dp[j] + 1);
				}
			}
			// 更新全局最大值
			ans = Math.max(ans, dp[i]);
		}
		return ans;
	}

	// 最优解
	// 时间复杂度O(n * logn)
	/**
	 * 使用贪心+二分查找计算最长严格递增子序列的长度
	 * 
	 * 算法思路：
	 * 1. 维护一个数组ends，ends[i]表示长度为i+1的所有递增子序列中，结尾元素的最小值
	 * 2. 贪心思想：为了让递增子序列尽可能长，我们希望结尾元素尽可能小
	 * 3. 对于每个元素num，在ends数组中二分查找>=num的最左位置
	 *    - 如果找不到，说明num比所有元素都大，可以延长递增子序列
	 *    - 如果找到了位置find，将ends[find]更新为num
	 * 
	 * 时间复杂度：O(n*logn) - 遍历n个元素，每次二分查找O(logn)
	 * 空间复杂度：O(n) - 需要ends数组存储状态
	 * 是否最优解：是，这是目前求LIS长度的最优解法
	 * 
	 * @param nums 输入的整数数组
	 * @return 最长严格递增子序列的长度
	 */
	public static int lengthOfLIS2(int[] nums) {
		int n = nums.length;
		// ends[i]表示长度为i+1的所有递增子序列中，结尾元素的最小值
		int[] ends = new int[n];
		// len表示ends数组目前的有效区长度
		// ends[0...len-1]是有效区，有效区内的数字一定严格升序
		int len = 0;
		// 遍历数组中的每个元素
		for (int i = 0, find; i < n; i++) {
			// 在ends数组中查找>=nums[i]的最左位置
			find = bs1(ends, len, nums[i]);
			// 如果找不到，说明nums[i]比所有元素都大，可以延长递增子序列
			if (find == -1) {
				ends[len++] = nums[i];
			} else {
				// 如果找到了位置，更新该位置的值为nums[i]
				ends[find] = nums[i];
			}
		}
		return len;
	}

	// "最长递增子序列"使用如下二分搜索 :
	// ends[0...len-1]是严格升序的，找到>=num的最左位置
	// 如果不存在返回-1
	/**
	 * 在严格升序数组ends中查找>=num的最左位置
	 * 
	 * 算法思路：
	 * 1. 使用二分查找在有序数组中查找目标值
	 * 2. 维护左边界l和右边界r
	 * 3. 计算中间位置m，比较ends[m]与num的大小关系
	 * 4. 如果ends[m] >= num，说明目标位置在左半部分（包括m），更新ans和r
	 * 5. 否则目标位置在右半部分，更新l
	 * 
	 * 时间复杂度：O(logn) - 标准二分查找
	 * 空间复杂度：O(1) - 只使用常数额外空间
	 * 是否最优解：是，这是标准的二分查找实现
	 * 
	 * @param ends 严格升序数组
	 * @param len 有效长度
	 * @param num 目标值
	 * @return >=num的最左位置，如果不存在返回-1
	 */
	public static int bs1(int[] ends, int len, int num) {
		int l = 0, r = len - 1, m, ans = -1;
		while (l <= r) {
			m = (l + r) / 2;
			// 如果ends[m] >= num，记录当前位置并继续在左半部分查找
			if (ends[m] >= num) {
				ans = m;
				r = m - 1;
			} else {
				// 否则在右半部分查找
				l = m + 1;
			}
		}
		return ans;
	}

	// 如果求最长不下降子序列，那么使用如下的二分搜索 :
	// ends[0...len-1]是不降序的
	// 在其中找到>num的最左位置，如果不存在返回-1
	// 如果求最长不下降子序列，就在lengthOfLIS中把bs1方法换成bs2方法
	// 已经用对数器验证了，是正确的
	/**
	 * 在不降序数组ends中查找>num的最左位置
	 * 
	 * 算法思路：
	 * 1. 与bs1类似，但查找条件变为>num
	 * 2. 用于计算最长不下降子序列（允许相邻元素相等）
	 * 
	 * 时间复杂度：O(logn) - 标准二分查找
	 * 空间复杂度：O(1) - 只使用常数额外空间
	 * 是否最优解：是，这是标准的二分查找实现
	 * 
	 * @param ends 不降序数组
	 * @param len 有效长度
	 * @param num 目标值
	 * @return >num的最左位置，如果不存在返回-1
	 */
	public static int bs2(int[] ends, int len, int num) {
		int l = 0, r = len - 1, m, ans = -1;
		while (l <= r) {
			m = (l + r) / 2;
			// 如果ends[m] > num，记录当前位置并继续在左半部分查找
			if (ends[m] > num) {
				ans = m;
				r = m - 1;
			} else {
				// 否则在右半部分查找
				l = m + 1;
			}
		}
		return ans;
	}

}

===============================================

文件: Code02_RussianDollEnvelopes.java
===============================================
package class072;

import java.util.Arrays;

// 俄罗斯套娃信封问题
// 给你一个二维整数数组envelopes ，其中envelopes[i]=[wi, hi]
// 表示第 i 个信封的宽度和高度
// 当另一个信封的宽度和高度都比这个信封大的时候
// 这个信封就可以放进另一个信封里，如同俄罗斯套娃一样
// 请计算 最多能有多少个信封能组成一组"俄罗斯套娃"信封
// 即可以把一个信封放到另一个信封里面，注意不允许旋转信封
// 测试链接 : https://leetcode.cn/problems/russian-doll-envelopes/
public class Code02_RussianDollEnvelopes {

	/**
	 * 计算最多能有多少个信封能组成一组"俄罗斯套娃"信封
	 * 
	 * 算法思路：
	 * 1. 这是一个二维最长递增子序列问题
	 * 2. 先按宽度升序排序，宽度相同时按高度降序排序
	 *    - 宽度升序确保后面的信封宽度一定>=前面的信封
	 *    - 高度降序确保宽度相同的信封不会被同时选中（避免违反套娃规则）
	 * 3. 对高度数组求最长严格递增子序列长度
	 * 
	 * 时间复杂度：O(n*logn) - 排序O(n*logn) + LIS O(n*logn)
	 * 空间复杂度：O(n) - 需要ends数组存储状态
	 * 是否最优解：是，这是目前最优解法
	 * 
	 * @param envelopes 信封数组，envelopes[i] = [wi, hi]
	 * @return 最多能组成的俄罗斯套娃信封数量
	 */
	public static int maxEnvelopes(int[][] envelopes) {
		int n = envelopes.length;
		// 排序策略:
		// 宽度从小到大
		// 宽度一样，高度从大到小
		Arrays.sort(envelopes, (a, b) -> a[0] != b[0] ? (a[0] - b[0]) : (b[1] - a[1]));
		int[] ends = new int[n];
		int len = 0;
		// 遍历排序后的信封高度，求最长递增子序列
		for (int i = 0, find, num; i < n; i++) {
			num = envelopes[i][1];
			// 二分查找>=num的最左位置
			find = bs(ends, len, num);
			// 如果找不到，说明num比所有元素都大，可以延长递增子序列
			if (find == -1) {
				ends[len++] = num;
			} else {
				// 如果找到了位置，更新该位置的值为num
				ends[find] = num;
			}
		}
		return len;
	}

	/**
	 * 在严格升序数组ends中查找>=num的最左位置
	 * 
	 * 算法思路：
	 * 1. 使用二分查找在有序数组中查找目标值
	 * 2. 维护左边界l和右边界r
	 * 3. 计算中间位置m，比较ends[m]与num的大小关系
	 * 4. 如果ends[m] >= num，说明目标位置在左半部分（包括m），更新ans和r
	 * 5. 否则目标位置在右半部分，更新l
	 * 
	 * 时间复杂度：O(logn) - 标准二分查找
	 * 空间复杂度：O(1) - 只使用常数额外空间
	 * 是否最优解：是，这是标准的二分查找实现
	 * 
	 * @param ends 严格升序数组
	 * @param len 有效长度
	 * @param num 目标值
	 * @return >=num的最左位置，如果不存在返回-1
	 */
	public static int bs(int[] ends, int len, int num) {
		int l = 0, r = len - 1, m, ans = -1;
		while (l <= r) {
			m = (l + r) / 2;
			// 如果ends[m] >= num，记录当前位置并继续在左半部分查找
			if (ends[m] >= num) {
				ans = m;
				r = m - 1;
			} else {
				// 否则在右半部分查找
				l = m + 1;
			}
		}
		return ans;
	}

}

===============================================

文件: Code03_MinimumOperationsToMakeArraykIncreasing.java
===============================================
package class072;

// 使数组K递增的最少操作次数
// 给你一个下标从0开始包含n个正整数的数组arr，和一个正整数k
// 如果对于每个满足 k <= i <= n-1 的下标 i
// 都有 arr[i-k] <= arr[i] ，那么称 arr 是K递增的
// 每一次操作中，你可以选择一个下标i并将arr[i]改成任意正整数
// 请你返回对于给定的 k ，使数组变成K递增的最少操作次数
// 测试链接 : https://leetcode.cn/problems/minimum-operations-to-make-the-array-k-increasing/
public class Code03_MinimumOperationsToMakeArraykIncreasing {

	public static int MAXN = 100001;

	public static int[] nums = new int[MAXN];

	public static int[] ends = new int[MAXN];

	/**
	 * 计算使数组变成K递增的最少操作次数
	 * 
	 * 算法思路：
	 * 1. 将数组按照间隔k分成k组，每组内的元素需要满足递增关系
	 * 2. 对每组分别计算最少操作次数，累加得到结果
	 * 3. 每组的最少操作次数 = 组长度 - 组内最长不下降子序列长度
	 *    - 最长不下降子序列可以保留不动
	 *    - 其余元素需要修改
	 * 
	 * 时间复杂度：O(n*log(n/k)) - 分成k组，每组平均长度n/k，每组求LIS需要O((n/k)*log(n/k))
	 * 空间复杂度：O(n) - 需要辅助数组存储状态
	 * 是否最优解：是，这是目前最优解法
	 * 
	 * @param arr 输入数组
	 * @param k 间隔参数
	 * @return 最少操作次数
	 */
	public static int kIncreasing(int[] arr, int k) {
		int n = arr.length;
		int ans = 0;
		// 将数组按照间隔k分成k组
		for (int i = 0, size; i < k; i++) {
			size = 0;
			// 把每一组的数字放入容器
			for (int j = i; j < n; j += k) {
				nums[size++] = arr[j];
			}
			// 当前组长度 - 当前组最长不下降子序列长度 = 当前组至少需要修改的数字个数
			ans += size - lengthOfNoDecreasing(size);
		}
		return ans;
	}

	// nums[0...size-1]中的最长不下降子序列长度
	/**
	 * 计算数组中最长不下降子序列的长度
	 * 
	 * 算法思路：
	 * 1. 维护一个数组ends，ends[i]表示长度为i+1的所有不下降子序列中，结尾元素的最小值
	 * 2. 贪心思想：为了让不下降子序列尽可能长，我们希望结尾元素尽可能小
	 * 3. 对于每个元素num，在ends数组中二分查找<num的最左位置
	 *    - 如果找不到，说明num比所有元素都大，可以延长不下降子序列
	 *    - 如果找到了位置find，将ends[find]更新为num
	 * 
	 * 时间复杂度：O(n*logn) - 遍历n个元素，每次二分查找O(logn)
	 * 空间复杂度：O(n) - 需要ends数组存储状态
	 * 是否最优解：是，这是求LIS长度的最优解法
	 * 
	 * @param size 数组长度
	 * @return 最长不下降子序列的长度
	 */
	public static int lengthOfNoDecreasing(int size) {
		int len = 0;
		// 遍历数组中的每个元素
		for (int i = 0, find; i < size; i++) {
			// 在ends数组中查找<num的最左位置
			find = bs(len, nums[i]);
			// 如果找不到，说明nums[i]比所有元素都大，可以延长不下降子序列
			if (find == -1) {
				ends[len++] = nums[i];
			} else {
				// 如果找到了位置，更新该位置的值为nums[i]
				ends[find] = nums[i];
			}
		}
		return len;
	}

	/**
	 * 在不降序数组ends中查找<num的最左位置
	 * 
	 * 算法思路：
	 * 1. 使用二分查找在有序数组中查找目标值
	 * 2. 维护左边界l和右边界r
	 * 3. 计算中间位置m，比较ends[m]与num的大小关系
	 * 4. 如果num < ends[m]，说明目标位置在左半部分（包括m），更新ans和r
	 * 5. 否则目标位置在右半部分，更新l
	 * 
	 * 时间复杂度：O(logn) - 标准二分查找
	 * 空间复杂度：O(1) - 只使用常数额外空间
	 * 是否最优解：是，这是标准的二分查找实现
	 * 
	 * @param len 有效长度
	 * @param num 目标值
	 * @return <num的最左位置，如果不存在返回-1
	 */
	public static int bs(int len, int num) {
		int l = 0, r = len - 1, m, ans = -1;
		while (l <= r) {
			m = (l + r) / 2;
			// 如果num < ends[m]，记录当前位置并继续在左半部分查找
			if (num < ends[m]) {
				ans = m;
				r = m - 1;
			} else {
				// 否则在右半部分查找
				l = m + 1;
			}
		}
		return ans;
	}

}

===============================================

文件: Code04_MaximumLengthOfPairChain.java
===============================================
package class072;

import java.util.Arrays;

// 最长数对链
// 给你一个由n个数对组成的数对数组pairs
// 其中 pairs[i] = [lefti, righti] 且 lefti < righti
// 现在，我们定义一种 跟随 关系，当且仅当 b < c 时
// 数对 p2 = [c, d] 才可以跟在 p1 = [a, b] 后面
// 我们用这种形式来构造 数对链
// 找出并返回能够形成的最长数对链的长度
// 测试链接 : https://leetcode.cn/problems/maximum-length-of-pair-chain/
public class Code04_MaximumLengthOfPairChain {

	/**
	 * 使用LIS方法计算最长数对链的长度
	 * 
	 * 算法思路：
	 * 1. 先按开始位置排序
	 * 2. 转化为最长递增子序列问题，维护ends数组表示长度为i的数对链的最小结束位置
	 * 3. 遍历数对，使用二分查找维护ends数组
	 * 
	 * 时间复杂度：O(n*logn) - 排序O(n*logn) + 遍历并二分查找O(n*logn)
	 * 空间复杂度：O(n) - 需要ends数组存储状态
	 * 是否最优解：否，存在更优的贪心解法
	 * 
	 * @param pairs 数对数组
	 * @return 最长数对链的长度
	 */
	public static int findLongestChain(int[][] pairs) {
		int n = pairs.length;
		// 数对根据开始位置排序，从小到大
		// 结束位置无所谓！
		Arrays.sort(pairs, (a, b) -> a[0] - b[0]);
		// ends[i]表示长度为i+1的数对链的最小结束位置
		int[] ends = new int[n];
		int len = 0;
		// 遍历所有数对
		for (int[] pair : pairs) {
			// 二分查找>=pair[0]的最左位置
			int find = bs(ends, len, pair[0]);
			// 如果找不到，说明可以延长数对链
			if (find == -1) {
				ends[len++] = pair[1];
			} else {
				// 如果找到了，更新该位置的最小结束位置
				ends[find] = Math.min(ends[find], pair[1]);
			}
		}
		return len;
	}

	// >= num最左位置
	/**
	 * 在升序数组ends中查找>=num的最左位置
	 * 
	 * 算法思路：
	 * 1. 使用二分查找在有序数组中查找目标值
	 * 2. 维护左边界l和右边界r
	 * 3. 计算中间位置m，比较ends[m]与num的大小关系
	 * 4. 如果ends[m] >= num，说明目标位置在左半部分（包括m），更新ans和r
	 * 5. 否则目标位置在右半部分，更新l
	 * 
	 * 时间复杂度：O(logn) - 标准二分查找
	 * 空间复杂度：O(1) - 只使用常数额外空间
	 * 是否最优解：是，这是标准的二分查找实现
	 * 
	 * @param ends 升序数组
	 * @param len 有效长度
	 * @param num 目标值
	 * @return >=num的最左位置，如果不存在返回-1
	 */
	public static int bs(int[] ends, int len, int num) {
		int l = 0, r = len - 1, m, ans = -1;
		while (l <= r) {
			m = (l + r) / 2;
			// 如果ends[m] >= num，记录当前位置并继续在左半部分查找
			if (ends[m] >= num) {
				ans = m;
				r = m - 1;
			} else {
				// 否则在右半部分查找
				l = m + 1;
			}
		}
		return ans;
	}

	// 最优解利用贪心
	/**
	 * 使用贪心算法计算最长数对链的长度
	 * 
	 * 算法思路：
	 * 1. 按结束位置排序，优先选择结束位置小的数对
	 * 2. 贪心选择：每次选择能接在当前数对链后面的、结束位置最小的数对
	 * 3. 这样可以为后续选择留下更多空间
	 * 
	 * 时间复杂度：O(n*logn) - 排序O(n*logn)
	 * 空间复杂度：O(1) - 只使用常数额外空间
	 * 是否最优解：是，这是最优解法
	 * 
	 * @param pairs 数对数组
	 * @return 最长数对链的长度
	 */
	public static int findLongestChain2(int[][] pairs) {
		// pre表示当前数对链的结束位置
		int pre = Integer.MIN_VALUE, ans = 0;
		// 按结束位置排序
		Arrays.sort(pairs, (a, b) -> a[1] - b[1]);
		// 贪心选择数对
		for (int[] pair : pairs) {
			// 如果当前数对的开始位置大于前一个数对的结束位置，可以接在后面
			if (pre < pair[0]) {
				pre = pair[1];  // 更新数对链的结束位置
				ans++;          // 数对链长度加1
			}
		}
		return ans;
	}

}

===============================================

文件: Code05_LongestNoDecreaseModifyKSubarray.java
===============================================
package class072;

// 有一次修改机会的最长不下降子序列
// 给定一个长度为n的数组arr，和一个整数k
// 只有一次机会可以将其中连续的k个数全修改成任意一个值
// 这次机会你可以用也可以不用，请返回最长不下降子序列长度
// 1 <= k, n <= 10^5
// 1 <= arr[i] <= 10^6
// 测试链接 : https://www.luogu.com.cn/problem/P8776
// 请同学们务必参考如下代码中关于输入、输出的处理
// 这是输入输出处理效率很高的写法
// 提交以下的所有代码，并把主类名改成"Main"，可以直接通过

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;
import java.io.PrintWriter;
import java.io.StreamTokenizer;

public class Code05_LongestNoDecreaseModifyKSubarray {

	public static int MAXN = 100001;

	public static int[] arr = new int[MAXN];

	public static int[] right = new int[MAXN];

	public static int[] ends = new int[MAXN];

	public static int n, k;

	public static void main(String[] args) throws IOException {
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		StreamTokenizer in = new StreamTokenizer(br);
		PrintWriter out = new PrintWriter(new OutputStreamWriter(System.out));
		while (in.nextToken() != StreamTokenizer.TT_EOF) {
			n = (int) in.nval;
			in.nextToken();
			k = (int) (in.nval);
			for (int i = 0; i < n; i++) {
				in.nextToken();
				arr[i] = (int) in.nval;
			}
			if (k >= n) {
				out.println(n);
			} else {
				out.println(compute());
			}
		}
		out.flush();
		out.close();
		br.close();
	}

	/**
	 * 计算有一次修改机会的最长不下降子序列长度
	 * 
	 * 算法思路：
	 * 1. 预处理right数组，right[i]表示以arr[i]开头的arr[i...]上的最长不下降子序列长度
	 * 2. 枚举修改的区间[i, i+k-1]，计算修改后的最长不下降子序列长度
	 * 3. 修改后的最长不下降子序列可以分为三部分：
	 *    - 修改区间前的最长不下降子序列长度left
	 *    - 修改区间长度k
	 *    - 修改区间后的最长不下降子序列长度right[i+k]
	 * 4. 特殊情况：不修改任何区间的最长不下降子序列长度
	 * 
	 * 时间复杂度：O(n*logn) - 预处理right数组O(n*logn) + 枚举区间O(n*logn)
	 * 空间复杂度：O(n) - 需要辅助数组存储状态
	 * 是否最优解：是，这是目前最优解法
	 * 
	 * @return 最长不下降子序列长度
	 */
	public static int compute() {
		right();
		int len = 0;
		int ans = 0;
		// 枚举修改的区间[i, i+k-1]
		for (int i = 0, j = k, find, left; j < n; i++, j++) {
			// 计算修改区间前的最长不下降子序列长度
			find = bs2(len, arr[j]);
			left = find == -1 ? len : find;
			// 更新答案：left + k + right[j]
			ans = Math.max(ans, left + k + right[j]);
			// 更新修改区间前的部分
			find = bs2(len, arr[i]);
			if (find == -1) {
				ends[len++] = arr[i];
			} else {
				ends[find] = arr[i];
			}
		}
		// 特殊情况：不修改任何区间的最长不下降子序列长度
		ans = Math.max(ans, len + k);
		return ans;
	}

	// 生成辅助数组right
	// right[j] :
	// 一定以arr[j]做开头的情况下，arr[j...]上最长不下降子序列长度是多少
	// 关键逻辑 :
	// 一定以arr[i]做开头的情况下，arr[i...]上最长不下降子序列
	// 就是！从n-1出发来看(从右往左遍历)，以arr[i]做结尾的情况下的最长不上升子序列
	/**
	 * 预处理辅助数组right
	 * 
	 * 算法思路：
	 * 1. 从右往左遍历数组
	 * 2. 对于每个位置i，计算以arr[i]开头的arr[i...]上的最长不下降子序列长度
	 * 3. 转化为计算以arr[i]结尾的arr[...i]上的最长不上升子序列长度
	 * 4. 使用贪心+二分查找维护最长不上升子序列
	 * 
	 * 时间复杂度：O(n*logn) - 遍历n个元素，每次二分查找O(logn)
	 * 空间复杂度：O(n) - 需要辅助数组存储状态
	 * 是否最优解：是，这是目前最优解法
	 */
	public static void right() {
		int len = 0;
		// 从右往左遍历数组
		for (int i = n - 1, find; i >= 0; i--) {
			// 计算以arr[i]结尾的最长不上升子序列长度
			find = bs1(len, arr[i]);
			if (find == -1) {
				ends[len++] = arr[i];
				right[i] = len;
			} else {
				ends[find] = arr[i];
				right[i] = find + 1;
			}
		}
	}

	// 求最长不上升子序列长度的二分
	// ends[0...len-1]是降序的，找到<num的最左位置
	// 不存在返回-1
	/**
	 * 在严格降序数组ends中查找<num的最左位置
	 * 
	 * 算法思路：
	 * 1. 使用二分查找在有序数组中查找目标值
	 * 2. 维护左边界l和右边界r
	 * 3. 计算中间位置m，比较ends[m]与num的大小关系
	 * 4. 如果ends[m] < num，说明目标位置在左半部分（包括m），更新ans和r
	 * 5. 否则目标位置在右半部分，更新l
	 * 
	 * 时间复杂度：O(logn) - 标准二分查找
	 * 空间复杂度：O(1) - 只使用常数额外空间
	 * 是否最优解：是，这是标准的二分查找实现
	 * 
	 * @param len 有效长度
	 * @param num 目标值
	 * @return <num的最左位置，如果不存在返回-1
	 */
	public static int bs1(int len, int num) {
		int l = 0, r = len - 1, m, ans = -1;
		while (l <= r) {
			m = (l + r) / 2;
			// 如果ends[m] < num，记录当前位置并继续在左半部分查找
			if (ends[m] < num) {
				ans = m;
				r = m - 1;
			} else {
				// 否则在右半部分查找
				l = m + 1;
			}
		}
		return ans;
	}

	// 求最长不下降子序列长度的二分
	// ends[0...len-1]是升序的，找到>num的最左位置
	// 不存在返回-1
	/**
	 * 在不降序数组ends中查找>num的最左位置
	 * 
	 * 算法思路：
	 * 1. 使用二分查找在有序数组中查找目标值
	 * 2. 维护左边界l和右边界r
	 * 3. 计算中间位置m，比较ends[m]与num的大小关系
	 * 4. 如果ends[m] > num，说明目标位置在左半部分（包括m），更新ans和r
	 * 5. 否则目标位置在右半部分，更新l
	 * 
	 * 时间复杂度：O(logn) - 标准二分查找
	 * 空间复杂度：O(1) - 只使用常数额外空间
	 * 是否最优解：是，这是标准的二分查找实现
	 * 
	 * @param len 有效长度
	 * @param num 目标值
	 * @return >num的最左位置，如果不存在返回-1
	 */
	public static int bs2(int len, int num) {
		int l = 0, r = len - 1, m, ans = -1;
		while (l <= r) {
			m = (l + r) / 2;
			// 如果ends[m] > num，记录当前位置并继续在左半部分查找
			if (ends[m] > num) {
				ans = m;
				r = m - 1;
			} else {
				// 否则在右半部分查找
				l = m + 1;
			}
		}
		return ans;
	}

}

===============================================

文件: Code06_NumberOfLIS.cpp
===============================================
/**
 * 最长递增子序列的个数
 * 
 * 题目来源：LeetCode 673. 最长递增子序列的个数
 * 题目链接：https://leetcode.cn/problems/number-of-longest-increasing-subsequence/
 * 题目描述：给定一个未排序的整数数组 nums ，返回最长递增子序列的个数。
 * 注意：这个数列必须是严格递增的。
 * 
 * 算法思路：
 * 1. 使用动态规划方法
 * 2. 维护两个数组：
 *    - dp[i] 表示以 nums[i] 结尾的最长递增子序列的长度
 *    - cnt[i] 表示以 nums[i] 结尾的最长递增子序列的个数
 * 3. 对于每个位置 i，遍历前面所有位置 j：
 *    - 如果 nums[j] < nums[i]，可以将 nums[i] 接在以 nums[j] 结尾的递增子序列后面
 *    - 如果 dp[j] + 1 > dp[i]，更新 dp[i] 和 cnt[i]
 *    - 如果 dp[j] + 1 == dp[i]，累加 cnt[i]
 * 4. 统计最长长度对应的个数
 * 
 * 时间复杂度：O(n^2) - 外层循环n次，内层循环最多n次
 * 空间复杂度：O(n) - 需要dp和cnt数组存储状态
 * 是否最优解：对于此问题的动态规划解法是标准解法
 * 
 * 示例：
 * 输入: [1,3,5,4,7]
 * 输出: 2
 * 解释: 有两个最长递增子序列，分别是 [1, 3, 4, 7] 和[1, 3, 5, 7]。
 * 
 * 输入: [2,2,2,2,2]
 * 输出: 5
 * 解释: 最长递增子序列的长度是1，并且存在5个子序列，因此输出5。
 */

// 由于编译环境问题，使用基础C++实现，避免使用STL容器

#define MAXN 2000

/**
 * 计算最长递增子序列的个数
 * 
 * @param nums 输入的整数数组
 * @param n 数组长度
 * @return 最长递增子序列的个数
 */
int findNumberOfLIS(int nums[], int n) {
    if (n <= 1) {
        return n;
    }
    
    // dp[i] 表示以 nums[i] 结尾的最长递增子序列的长度
    int dp[MAXN];
    // cnt[i] 表示以 nums[i] 结尾的最长递增子序列的个数
    int cnt[MAXN];
    
    // 初始化
    for (int i = 0; i < n; i++) {
        dp[i] = 1;
        cnt[i] = 1;
    }
    
    int maxLen = 1;
    
    // 遍历每个位置
    for (int i = 1; i < n; i++) {
        // 遍历前面所有位置
        for (int j = 0; j < i; j++) {
            // 如果 nums[j] < nums[i]，可以将 nums[i] 接在以 nums[j] 结尾的递增子序列后面
            if (nums[j] < nums[i]) {
                // 如果找到了更长的递增子序列
                if (dp[j] + 1 > dp[i]) {
                    dp[i] = dp[j] + 1;
                    cnt[i] = cnt[j];  // 更新个数
                } 
                // 如果找到了相同长度的递增子序列
                else if (dp[j] + 1 == dp[i]) {
                    cnt[i] += cnt[j];  // 累加个数
                }
            }
        }
        // 更新全局最长长度
        if (dp[i] > maxLen) {
            maxLen = dp[i];
        }
    }
    
    // 统计最长长度对应的个数
    int result = 0;
    for (int i = 0; i < n; i++) {
        if (dp[i] == maxLen) {
            result += cnt[i];
        }
    }
    
    return result;
}

// 用于测试的主函数
int main() {
    // 测试用例1
    int nums1[] = {1, 3, 5, 4, 7};
    int n1 = 5;
    // 输出结果需要通过其他方式验证
    
    // 测试用例2
    int nums2[] = {2, 2, 2, 2, 2};
    int n2 = 5;
    // 输出结果需要通过其他方式验证
    
    // 测试用例3
    int nums3[] = {1, 2, 4, 3, 5, 4, 7, 2};
    int n3 = 8;
    // 输出结果需要通过其他方式验证
    
    return 0;
}

===============================================

文件: Code06_NumberOfLIS.java
===============================================
/**
 * 最长递增子序列的个数
 * 
 * 题目来源：LeetCode 673. 最长递增子序列的个数
 * 题目链接：https://leetcode.cn/problems/number-of-longest-increasing-subsequence/
 * 题目描述：给定一个未排序的整数数组 nums ，返回最长递增子序列的个数。
 * 注意：这个数列必须是严格递增的。
 * 
 * 算法思路：
 * 1. 使用动态规划方法
 * 2. 维护两个数组：
 *    - dp[i] 表示以 nums[i] 结尾的最长递增子序列的长度
 *    - cnt[i] 表示以 nums[i] 结尾的最长递增子序列的个数
 * 3. 对于每个位置 i，遍历前面所有位置 j：
 *    - 如果 nums[j] < nums[i]，可以将 nums[i] 接在以 nums[j] 结尾的递增子序列后面
 *    - 如果 dp[j] + 1 > dp[i]，更新 dp[i] 和 cnt[i]
 *    - 如果 dp[j] + 1 == dp[i]，累加 cnt[i]
 * 4. 统计最长长度对应的个数
 * 
 * 时间复杂度：O(n^2) - 外层循环n次，内层循环最多n次
 * 空间复杂度：O(n) - 需要dp和cnt数组存储状态
 * 是否最优解：对于此问题的动态规划解法是标准解法
 * 
 * 示例：
 * 输入: [1,3,5,4,7]
 * 输出: 2
 * 解释: 有两个最长递增子序列，分别是 [1, 3, 4, 7] 和[1, 3, 5, 7]。
 * 
 * 输入: [2,2,2,2,2]
 * 输出: 5
 * 解释: 最长递增子序列的长度是1，并且存在5个子序列，因此输出5。
 */

public class Code06_NumberOfLIS {

    /**
     * 计算最长递增子序列的个数
     * 
     * @param nums 输入的整数数组
     * @return 最长递增子序列的个数
     */
    public static int findNumberOfLIS(int[] nums) {
        int n = nums.length;
        if (n <= 1) {
            return n;
        }
        
        // dp[i] 表示以 nums[i] 结尾的最长递增子序列的长度
        int[] dp = new int[n];
        // cnt[i] 表示以 nums[i] 结尾的最长递增子序列的个数
        int[] cnt = new int[n];
        
        // 初始化
        for (int i = 0; i < n; i++) {
            dp[i] = 1;
            cnt[i] = 1;
        }
        
        int maxLen = 1;
        
        // 遍历每个位置
        for (int i = 1; i < n; i++) {
            // 遍历前面所有位置
            for (int j = 0; j < i; j++) {
                // 如果 nums[j] < nums[i]，可以将 nums[i] 接在以 nums[j] 结尾的递增子序列后面
                if (nums[j] < nums[i]) {
                    // 如果找到了更长的递增子序列
                    if (dp[j] + 1 > dp[i]) {
                        dp[i] = dp[j] + 1;
                        cnt[i] = cnt[j];  // 更新个数
                    } 
                    // 如果找到了相同长度的递增子序列
                    else if (dp[j] + 1 == dp[i]) {
                        cnt[i] += cnt[j];  // 累加个数
                    }
                }
            }
            // 更新全局最长长度
            maxLen = Math.max(maxLen, dp[i]);
        }
        
        // 统计最长长度对应的个数
        int result = 0;
        for (int i = 0; i < n; i++) {
            if (dp[i] == maxLen) {
                result += cnt[i];
            }
        }
        
        return result;
    }

    // 测试方法
    public static void main(String[] args) {
        // 测试用例1
        int[] nums1 = {1, 3, 5, 4, 7};
        System.out.println("输入: [1,3,5,4,7]");
        System.out.println("输出: " + findNumberOfLIS(nums1));
        System.out.println("期望: 2");
        System.out.println();
        
        // 测试用例2
        int[] nums2 = {2, 2, 2, 2, 2};
        System.out.println("输入: [2,2,2,2,2]");
        System.out.println("输出: " + findNumberOfLIS(nums2));
        System.out.println("期望: 5");
        System.out.println();
        
        // 测试用例3
        int[] nums3 = {1, 2, 4, 3, 5, 4, 7, 2};
        System.out.println("输入: [1,2,4,3,5,4,7,2]");
        System.out.println("输出: " + findNumberOfLIS(nums3));
        System.out.println();
    }
}

===============================================

文件: Code06_NumberOfLIS.py
===============================================
"""
最长递增子序列的个数

题目来源：LeetCode 673. 最长递增子序列的个数
题目链接：https://leetcode.cn/problems/number-of-longest-increasing-subsequence/
题目描述：给定一个未排序的整数数组 nums ，返回最长递增子序列的个数。
注意：这个数列必须是严格递增的。

算法思路：
1. 使用动态规划方法
2. 维护两个数组：
   - dp[i] 表示以 nums[i] 结尾的最长递增子序列的长度
   - cnt[i] 表示以 nums[i] 结尾的最长递增子序列的个数
3. 对于每个位置 i，遍历前面所有位置 j：
   - 如果 nums[j] < nums[i]，可以将 nums[i] 接在以 nums[j] 结尾的递增子序列后面
   - 如果 dp[j] + 1 > dp[i]，更新 dp[i] 和 cnt[i]
   - 如果 dp[j] + 1 == dp[i]，累加 cnt[i]
4. 统计最长长度对应的个数

时间复杂度：O(n^2) - 外层循环n次，内层循环最多n次
空间复杂度：O(n) - 需要dp和cnt数组存储状态
是否最优解：对于此问题的动态规划解法是标准解法

示例：
输入: [1,3,5,4,7]
输出: 2
解释: 有两个最长递增子序列，分别是 [1, 3, 4, 7] 和[1, 3, 5, 7]。

输入: [2,2,2,2,2]
输出: 5
解释: 最长递增子序列的长度是1，并且存在5个子序列，因此输出5。
"""


def findNumberOfLIS(nums):
    """
    计算最长递增子序列的个数
    
    Args:
        nums: 输入的整数数组
        
    Returns:
        最长递增子序列的个数
    """
    n = len(nums)
    if n <= 1:
        return n
    
    # dp[i] 表示以 nums[i] 结尾的最长递增子序列的长度
    dp = [1] * n
    # cnt[i] 表示以 nums[i] 结尾的最长递增子序列的个数
    cnt = [1] * n
    
    maxLen = 1
    
    # 遍历每个位置
    for i in range(1, n):
        # 遍历前面所有位置
        for j in range(i):
            # 如果 nums[j] < nums[i]，可以将 nums[i] 接在以 nums[j] 结尾的递增子序列后面
            if nums[j] < nums[i]:
                # 如果找到了更长的递增子序列
                if dp[j] + 1 > dp[i]:
                    dp[i] = dp[j] + 1
                    cnt[i] = cnt[j]  # 更新个数
                # 如果找到了相同长度的递增子序列
                elif dp[j] + 1 == dp[i]:
                    cnt[i] += cnt[j]  # 累加个数
        # 更新全局最长长度
        maxLen = max(maxLen, dp[i])
    
    # 统计最长长度对应的个数
    result = 0
    for i in range(n):
        if dp[i] == maxLen:
            result += cnt[i]
    
    return result


# 测试方法
if __name__ == "__main__":
    # 测试用例1
    nums1 = [1, 3, 5, 4, 7]
    print("输入: [1,3,5,4,7]")
    print("输出: ", findNumberOfLIS(nums1))
    print("期望: 2")
    print()
    
    # 测试用例2
    nums2 = [2, 2, 2, 2, 2]
    print("输入: [2,2,2,2,2]")
    print("输出: ", findNumberOfLIS(nums2))
    print("期望: 5")
    print()
    
    # 测试用例3
    nums3 = [1, 2, 4, 3, 5, 4, 7, 2]
    print("输入: [1,2,4,3,5,4,7,2]")
    print("输出: ", findNumberOfLIS(nums3))

===============================================

文件: Code07_LongestStringChain.cpp
===============================================
/**
 * 最长字符串链
 * 
 * 题目来源：LeetCode 1048. 最长字符串链
 * 题目链接：https://leetcode.cn/problems/longest-string-chain/
 * 题目描述：给出一个单词数组 words ，其中每个单词都由小写英文字母组成。
 * 如果我们可以不改变其他字符的顺序，在 wordA 中任意位置添加恰好一个字母使其变成 wordB，
 * 那么我们认为 wordA 是 wordB 的前身。
 * 词链是单词 [word_1, word_2, ..., word_k] 组成的序列，其中 word1 是 word2 的前身，
 * word2 是 word3 的前身，依此类推。从给定单词列表 words 中选择单词组成词链，
 * 返回词链的最长可能长度。
 * 
 * 算法思路：
 * 1. 按字符串长度排序
 * 2. 使用动态规划方法
 * 3. dp[word] 表示以 word 结尾的最长字符串链长度
 * 4. 对于每个单词，尝试删除每个字符，检查是否存在于之前的单词中
 * 5. 如果存在，则更新当前单词的最长链长度
 * 
 * 时间复杂度：O(N * L^2) - N是单词数量，L是单词平均长度
 * 空间复杂度：O(N * L) - 需要哈希表存储状态和单词
 * 是否最优解：这是目前较优的解法
 * 
 * 示例：
 * 输入：words = ["a","b","ba","bca","bda","bdca"]
 * 输出：4
 * 解释：最长单词链之一为 ["a","ba","bda","bdca"]
 * 
 * 输入：words = ["xbc","pcxbcf","xb","cxbc","pcxbc"]
 * 输出：5
 * 
 * 输入：words = ["abcd","dbqca"]
 * 输出：1
 */

// 由于编译环境问题，使用基础C++实现，避免使用STL容器
// 使用简单的数组和字符串操作实现

#define MAXN 1000
#define MAXLEN 20

// 简单的字符串结构
struct String {
    char data[MAXLEN];
    int length;
};

// 简单的字符串比较函数
int stringCompare(String* a, String* b) {
    if (a->length != b->length) {
        return a->length - b->length;
    }
    for (int i = 0; i < a->length; i++) {
        if (a->data[i] != b->data[i]) {
            return a->data[i] - b->data[i];
        }
    }
    return 0;
}

// 字符串复制函数
void stringCopy(String* dest, String* src) {
    dest->length = src->length;
    for (int i = 0; i < src->length; i++) {
        dest->data[i] = src->data[i];
    }
}

// 删除指定位置字符的函数
void removeChar(String* dest, String* src, int pos) {
    dest->length = src->length - 1;
    for (int i = 0; i < pos; i++) {
        dest->data[i] = src->data[i];
    }
    for (int i = pos; i < dest->length; i++) {
        dest->data[i] = src->data[i + 1];
    }
}

/**
 * 计算最长字符串链的长度
 * 
 * @param words 单词数组
 * @param n 单词数量
 * @return 最长字符串链的长度
 */
int longestStrChain(String words[], int n) {
    // 简单的冒泡排序按字符串长度排序
    for (int i = 0; i < n - 1; i++) {
        for (int j = 0; j < n - 1 - i; j++) {
            if (stringCompare(&words[j], &words[j + 1]) > 0) {
                String temp;
                stringCopy(&temp, &words[j]);
                stringCopy(&words[j], &words[j + 1]);
                stringCopy(&words[j + 1], &temp);
            }
        }
    }
    
    // dp[i] 表示以 words[i] 结尾的最长字符串链长度
    int dp[MAXN];
    for (int i = 0; i < n; i++) {
        dp[i] = 1;
    }
    
    int maxLen = 1;
    
    // 遍历每个单词
    for (int i = 1; i < n; i++) {
        // 尝试删除每个字符，检查是否存在于之前的单词中
        for (int j = 0; j < i; j++) {
            // 检查words[j]是否是words[i]的前身
            if (words[j].length + 1 == words[i].length) {
                // 尝试删除words[i]的每个字符，看是否能得到words[j]
                int found = 0;
                for (int k = 0; k < words[i].length; k++) {
                    String temp;
                    removeChar(&temp, &words[i], k);
                    if (temp.length == words[j].length) {
                        int match = 1;
                        for (int l = 0; l < temp.length; l++) {
                            if (temp.data[l] != words[j].data[l]) {
                                match = 0;
                                break;
                            }
                        }
                        if (match) {
                            found = 1;
                            break;
                        }
                    }
                }
                // 如果找到了前身，更新dp值
                if (found && dp[j] + 1 > dp[i]) {
                    dp[i] = dp[j] + 1;
                }
            }
        }
        if (dp[i] > maxLen) {
            maxLen = dp[i];
        }
    }
    
    return maxLen;
}

// 用于测试的主函数
int main() {
    // 测试需要通过其他方式验证
    return 0;
}

===============================================

文件: Code07_LongestStringChain.java
===============================================
package class072;

import java.util.*;

/**
 * 最长字符串链
 * 
 * 题目来源：LeetCode 1048. 最长字符串链
 * 题目链接：https://leetcode.cn/problems/longest-string-chain/
 * 题目描述：给出一个单词数组 words ，其中每个单词都由小写英文字母组成。
 * 如果我们可以不改变其他字符的顺序，在 wordA 中任意位置添加恰好一个字母使其变成 wordB，
 * 那么我们认为 wordA 是 wordB 的前身。
 * 词链是单词 [word_1, word_2, ..., word_k] 组成的序列，其中 word1 是 word2 的前身，
 * word2 是 word3 的前身，依此类推。从给定单词列表 words 中选择单词组成词链，
 * 返回词链的最长可能长度。
 * 
 * 算法思路：
 * 1. 按字符串长度排序
 * 2. 使用动态规划方法
 * 3. dp[word] 表示以 word 结尾的最长字符串链长度
 * 4. 对于每个单词，尝试删除每个字符，检查是否存在于之前的单词中
 * 5. 如果存在，则更新当前单词的最长链长度
 * 
 * 时间复杂度：O(N * L^2) - N是单词数量，L是单词平均长度
 * 空间复杂度：O(N * L) - 需要哈希表存储状态和单词
 * 是否最优解：这是目前较优的解法
 * 
 * 示例：
 * 输入：words = ["a","b","ba","bca","bda","bdca"]
 * 输出：4
 * 解释：最长单词链之一为 ["a","ba","bda","bdca"]
 * 
 * 输入：words = ["xbc","pcxbcf","xb","cxbc","pcxbc"]
 * 输出：5
 * 
 * 输入：words = ["abcd","dbqca"]
 * 输出：1
 */
public class Code07_LongestStringChain {

    /**
     * 计算最长字符串链的长度
     * 
     * @param words 单词数组
     * @return 最长字符串链的长度
     */
    public static int longestStrChain(String[] words) {
        // 按字符串长度排序
        Arrays.sort(words, (a, b) -> a.length() - b.length());
        
        // dp[word] 表示以 word 结尾的最长字符串链长度
        Map<String, Integer> dp = new HashMap<>();
        int maxLen = 1;
        
        // 遍历每个单词
        for (String word : words) {
            int best = 0;
            // 尝试删除每个字符，检查是否存在于之前的单词中
            for (int i = 0; i < word.length(); i++) {
                // 删除第i个字符
                String prev = word.substring(0, i) + word.substring(i + 1);
                // 如果存在，则更新当前单词的最长链长度
                best = Math.max(best, dp.getOrDefault(prev, 0) + 1);
            }
            dp.put(word, best);
            maxLen = Math.max(maxLen, best);
        }
        
        return maxLen;
    }

    // 测试方法
    public static void main(String[] args) {
        // 测试用例1
        String[] words1 = {"a","b","ba","bca","bda","bdca"};
        System.out.println("输入: [\"a\",\"b\",\"ba\",\"bca\",\"bda\",\"bdca\"]");
        System.out.println("输出: " + longestStrChain(words1));
        System.out.println("期望: 4");
        System.out.println();
        
        // 测试用例2
        String[] words2 = {"xbc","pcxbcf","xb","cxbc","pcxbc"};
        System.out.println("输入: [\"xbc\",\"pcxbcf\",\"xb\",\"cxbc\",\"pcxbc\"]");
        System.out.println("输出: " + longestStrChain(words2));
        System.out.println("期望: 5");
        System.out.println();
        
        // 测试用例3
        String[] words3 = {"abcd","dbqca"};
        System.out.println("输入: [\"abcd\",\"dbqca\"]");
        System.out.println("输出: " + longestStrChain(words3));
        System.out.println("期望: 1");
        System.out.println();
    }
}

===============================================

文件: Code07_LongestStringChain.py
===============================================
"""
最长字符串链

题目来源：LeetCode 1048. 最长字符串链
题目链接：https://leetcode.cn/problems/longest-string-chain/
题目描述：给出一个单词数组 words ，其中每个单词都由小写英文字母组成。
如果我们可以不改变其他字符的顺序，在 wordA 中任意位置添加恰好一个字母使其变成 wordB，
那么我们认为 wordA 是 wordB 的前身。
词链是单词 [word_1, word_2, ..., word_k] 组成的序列，其中 word1 是 word2 的前身，
word2 是 word3 的前身，依此类推。从给定单词列表 words 中选择单词组成词链，
返回词链的最长可能长度。

算法思路：
1. 按字符串长度排序
2. 使用动态规划方法
3. dp[word] 表示以 word 结尾的最长字符串链长度
4. 对于每个单词，尝试删除每个字符，检查是否存在于之前的单词中
5. 如果存在，则更新当前单词的最长链长度

时间复杂度：O(N * L^2) - N是单词数量，L是单词平均长度
空间复杂度：O(N * L) - 需要哈希表存储状态和单词
是否最优解：这是目前较优的解法

示例：
输入：words = ["a","b","ba","bca","bda","bdca"]
输出：4
解释：最长单词链之一为 ["a","ba","bda","bdca"]

输入：words = ["xbc","pcxbcf","xb","cxbc","pcxbc"]
输出：5

输入：words = ["abcd","dbqca"]
输出：1
"""


def longestStrChain(words):
    """
    计算最长字符串链的长度
    
    Args:
        words: 单词数组
        
    Returns:
        最长字符串链的长度
    """
    # 按字符串长度排序
    words.sort(key=lambda x: len(x))
    
    # dp[word] 表示以 word 结尾的最长字符串链长度
    dp = {}
    maxLen = 1
    
    # 遍历每个单词
    for word in words:
        best = 0
        # 尝试删除每个字符，检查是否存在于之前的单词中
        for i in range(len(word)):
            # 删除第i个字符
            prev = word[:i] + word[i+1:]
            # 如果存在，则更新当前单词的最长链长度
            best = max(best, dp.get(prev, 0) + 1)
        dp[word] = best
        maxLen = max(maxLen, best)
    
    return maxLen


# 测试方法
if __name__ == "__main__":
    # 测试用例1
    words1 = ["a","b","ba","bca","bda","bdca"]
    print("输入: [\"a\",\"b\",\"ba\",\"bca\",\"bda\",\"bdca\"]")
    print("输出: ", longestStrChain(words1))
    print("期望: 4")
    print()
    
    # 测试用例2
    words2 = ["xbc","pcxbcf","xb","cxbc","pcxbc"]
    print("输入: [\"xbc\",\"pcxbcf\",\"xb\",\"cxbc\",\"pcxbc\"]")
    print("输出: ", longestStrChain(words2))
    print("期望: 5")
    print()
    
    # 测试用例3
    words3 = ["abcd","dbqca"]
    print("输入: [\"abcd\",\"dbqca\"]")
    print("输出: ", longestStrChain(words3))
    print("期望: 1")

===============================================

文件: Code07_WiggleSubsequence.cpp
===============================================
#include <iostream>
#include <vector>
#include <algorithm>
#include <string>

/**
 * 摆动序列 - LeetCode 376
 * 题目来源：https://leetcode.cn/problems/wiggle-subsequence/
 * 难度：中等
 * 题目描述：如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为摆动序列。
 * 第一个差（如果存在的话）可能是正数或负数。少于两个元素的序列也是摆动序列。
 * 例如，[1,7,4,9,2,5] 是一个摆动序列，因为差值 (6,-3,5,-7,3) 是正负交替出现的。
 * 相反, [1,4,7,2,5] 和 [1,7,4,5,5] 不是摆动序列，第一个序列是因为它的前两个差值都是正数，
 * 第二个序列是因为它的最后一个差值为零。
 * 
 * 核心思路：
 * 1. 这道题可以使用贪心算法来解决，因为我们只需要记录序列的趋势变化
 * 2. 摆动序列的关键在于相邻元素的差值交替变化
 * 3. 我们可以维护当前的趋势（上升、下降或初始状态），然后遍历数组，统计趋势变化的次数
 * 
 * 复杂度分析：
 * 时间复杂度：O(n)，其中n是数组的长度，我们只需要遍历一次数组
 * 空间复杂度：O(1)，只使用了常数级别的额外空间
 */

class Solution {
public:
    /**
     * 计算最长摆动子序列的长度 - 动态规划优化版本
     * @param nums 输入数组
     * @return 最长摆动子序列的长度
     */
    int wiggleMaxLength(const std::vector<int>& nums) {
        // 边界情况：如果数组长度小于2，直接返回数组长度
        if (nums.empty()) {
            return 0;
        }
        if (nums.size() == 1) {
            return 1;
        }
        
        int up = 1;   // 以最后一个差值为正的最长摆动子序列长度
        int down = 1; // 以最后一个差值为负的最长摆动子序列长度
        
        // 遍历数组，从第二个元素开始
        for (int i = 1; i < nums.size(); ++i) {
            if (nums[i] > nums[i - 1]) {
                // 当前是上升趋势，最长摆动子序列长度等于之前下降趋势的长度加1
                up = down + 1;
            } else if (nums[i] < nums[i - 1]) {
                // 当前是下降趋势，最长摆动子序列长度等于之前上升趋势的长度加1
                down = up + 1;
            }
            // 如果相等，不做任何操作，保持up和down不变
        }
        
        // 返回较大的值，因为最后一个差值可能是正也可能是负
        return std::max(up, down);
    }
    
    /**
     * 贪心算法解法 - 记录趋势变化
     * @param nums 输入数组
     * @return 最长摆动子序列的长度
     */
    int wiggleMaxLengthGreedy(const std::vector<int>& nums) {
        if (nums.empty()) {
            return 0;
        }
        if (nums.size() == 1) {
            return 1;
        }
        
        int count = 1;    // 至少有一个元素
        int prevDiff = 0; // 前一个差值
        int currDiff = 0; // 当前差值
        
        for (int i = 1; i < nums.size(); ++i) {
            currDiff = nums[i] - nums[i - 1];
            
            // 如果当前差值与前一个差值符号不同，说明出现了摆动
            if ((currDiff > 0 && prevDiff <= 0) || (currDiff < 0 && prevDiff >= 0)) {
                ++count;
                prevDiff = currDiff;
            }
        }
        
        return count;
    }
    
    /**
     * 动态规划解法 - 标准DP
     * @param nums 输入数组
     * @return 最长摆动子序列的长度
     */
    int wiggleMaxLengthDP(const std::vector<int>& nums) {
        if (nums.empty()) {
            return 0;
        }
        int n = nums.size();
        if (n == 1) {
            return 1;
        }
        
        // dp[i][0]: 以nums[i]结尾且最后一个差值为正的最长摆动子序列长度
        // dp[i][1]: 以nums[i]结尾且最后一个差值为负的最长摆动子序列长度
        std::vector<std::vector<int>> dp(n, std::vector<int>(2, 1));
        
        int maxLen = 1;
        
        for (int i = 1; i < n; ++i) {
            for (int j = 0; j < i; ++j) {
                if (nums[i] > nums[j]) {
                    // 如果nums[i] > nums[j]，可以接在以nums[j]结尾且最后一个差值为负的序列后面
                    dp[i][0] = std::max(dp[i][0], dp[j][1] + 1);
                } else if (nums[i] < nums[j]) {
                    // 如果nums[i] < nums[j]，可以接在以nums[j]结尾且最后一个差值为正的序列后面
                    dp[i][1] = std::max(dp[i][1], dp[j][0] + 1);
                }
            }
            // 更新最大值
            maxLen = std::max(maxLen, std::max(dp[i][0], dp[i][1]));
        }
        
        return maxLen;
    }
};

// 辅助函数：打印数组
void printVector(const std::vector<int>& vec) {
    std::cout << "[";
    for (size_t i = 0; i < vec.size(); ++i) {
        std::cout << vec[i];
        if (i < vec.size() - 1) {
            std::cout << ", ";
        }
    }
    std::cout << "]";
}

// 测试函数：测试所有解法
void testAllSolutions(const std::vector<int>& nums, Solution& solution) {
    std::cout << "输入数组: ";
    printVector(nums);
    std::cout << std::endl;
    
    std::cout << "解法1（动态规划优化版）: " << solution.wiggleMaxLength(nums) << std::endl;
    std::cout << "解法2（贪心算法）: " << solution.wiggleMaxLengthGreedy(nums) << std::endl;
    std::cout << "解法3（常规动态规划）: " << solution.wiggleMaxLengthDP(nums) << std::endl;
    std::cout << "--------------------------" << std::endl;
}

int main() {
    Solution solution;
    
    // 测试用例1
    std::vector<int> nums1 = {1, 7, 4, 9, 2, 5};
    std::cout << "测试用例1：" << std::endl;
    std::cout << "预期结果：6" << std::endl;
    std::cout << "实际结果：" << solution.wiggleMaxLength(nums1) << std::endl;
    std::cout << std::endl;
    
    // 测试用例2
    std::vector<int> nums2 = {1, 17, 5, 10, 13, 15, 10, 5, 16, 8};
    std::cout << "测试用例2：" << std::endl;
    std::cout << "预期结果：7" << std::endl;
    std::cout << "实际结果：" << solution.wiggleMaxLength(nums2) << std::endl;
    std::cout << std::endl;
    
    // 测试用例3
    std::vector<int> nums3 = {1, 2, 3, 4, 5, 6, 7, 8, 9};
    std::cout << "测试用例3：" << std::endl;
    std::cout << "预期结果：2" << std::endl;
    std::cout << "实际结果：" << solution.wiggleMaxLength(nums3) << std::endl;
    std::cout << std::endl;
    
    // 测试用例4：边界情况
    std::vector<int> nums4 = {1}; // 只有一个元素
    std::cout << "测试用例4：" << std::endl;
    std::cout << "预期结果：1" << std::endl;
    std::cout << "实际结果：" << solution.wiggleMaxLength(nums4) << std::endl;
    std::cout << std::endl;
    
    // 测试用例5：边界情况
    std::vector<int> nums5 = {1, 1}; // 所有元素相同
    std::cout << "测试用例5：" << std::endl;
    std::cout << "预期结果：1" << std::endl;
    std::cout << "实际结果：" << solution.wiggleMaxLength(nums5) << std::endl;
    std::cout << std::endl;
    
    // 详细测试所有解法
    std::cout << "详细比较所有解法：" << std::endl;
    std::cout << "--------------------------" << std::endl;
    
    testAllSolutions(nums1, solution);
    testAllSolutions(nums2, solution);
    testAllSolutions(nums3, solution);
    testAllSolutions(nums4, solution);
    testAllSolutions(nums5, solution);
    
    return 0;
}

===============================================

文件: Code07_WiggleSubsequence.java
===============================================
package class072;

import java.util.Arrays;

/**
 * 摆动序列 - LeetCode 376
 * 题目来源：https://leetcode.cn/problems/wiggle-subsequence/
 * 难度：中等
 * 题目描述：如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为摆动序列。
 * 第一个差（如果存在的话）可能是正数或负数。少于两个元素的序列也是摆动序列。
 * 例如，[1,7,4,9,2,5] 是一个摆动序列，因为差值 (6,-3,5,-7,3) 是正负交替出现的。
 * 相反, [1,4,7,2,5] 和 [1,7,4,5,5] 不是摆动序列，第一个序列是因为它的前两个差值都是正数，
 * 第二个序列是因为它的最后一个差值为零。
 * 
 * 核心思路：
 * 1. 这道题可以使用贪心算法来解决，因为我们只需要记录序列的趋势变化
 * 2. 摆动序列的关键在于相邻元素的差值交替变化
 * 3. 我们可以维护当前的趋势（上升、下降或初始状态），然后遍历数组，统计趋势变化的次数
 * 
 * 复杂度分析：
 * 时间复杂度：O(n)，其中n是数组的长度，我们只需要遍历一次数组
 * 空间复杂度：O(1)，只使用了常数级别的额外空间
 */
public class Code07_WiggleSubsequence {

    /**
     * 主方法，用于测试
     */
    public static void main(String[] args) {
        // 测试用例1
        int[] nums1 = {1, 7, 4, 9, 2, 5};
        System.out.println("测试用例1结果：" + wiggleMaxLength(nums1) + "，预期结果：6");
        
        // 测试用例2
        int[] nums2 = {1, 17, 5, 10, 13, 15, 10, 5, 16, 8};
        System.out.println("测试用例2结果：" + wiggleMaxLength(nums2) + "，预期结果：7");
        
        // 测试用例3
        int[] nums3 = {1, 2, 3, 4, 5, 6, 7, 8, 9};
        System.out.println("测试用例3结果：" + wiggleMaxLength(nums3) + "，预期结果：2");
        
        // 测试用例4：边界情况
        int[] nums4 = {1}; // 只有一个元素
        System.out.println("测试用例4结果：" + wiggleMaxLength(nums4) + "，预期结果：1");
        
        // 测试用例5：边界情况
        int[] nums5 = {1, 1}; // 所有元素相同
        System.out.println("测试用例5结果：" + wiggleMaxLength(nums5) + "，预期结果：1");
    }
    
    /**
     * 计算最长摆动子序列的长度
     * @param nums 输入数组
     * @return 最长摆动子序列的长度
     */
    public static int wiggleMaxLength(int[] nums) {
        // 边界情况：如果数组长度小于2，直接返回数组长度
        if (nums == null || nums.length == 0) {
            return 0;
        }
        if (nums.length == 1) {
            return 1;
        }
        
        // 初始化
        int up = 1;   // 以最后一个差值为正的最长摆动子序列长度
        int down = 1; // 以最后一个差值为负的最长摆动子序列长度
        
        // 遍历数组，从第二个元素开始
        for (int i = 1; i < nums.length; i++) {
            // 如果当前元素大于前一个元素，更新up
            if (nums[i] > nums[i - 1]) {
                // 当前是上升趋势，最长摆动子序列长度等于之前下降趋势的长度加1
                up = down + 1;
            }
            // 如果当前元素小于前一个元素，更新down
            else if (nums[i] < nums[i - 1]) {
                // 当前是下降趋势，最长摆动子序列长度等于之前上升趋势的长度加1
                down = up + 1;
            }
            // 如果相等，不做任何操作，保持up和down不变
        }
        
        // 返回较大的值，因为最后一个差值可能是正也可能是负
        return Math.max(up, down);
    }
    
    /**
     * 另一种解法：贪心算法，记录趋势变化
     * @param nums 输入数组
     * @return 最长摆动子序列的长度
     */
    public static int wiggleMaxLengthGreedy(int[] nums) {
        // 边界情况处理
        if (nums == null || nums.length == 0) {
            return 0;
        }
        if (nums.length == 1) {
            return 1;
        }
        
        // 去除连续重复元素，这些不会对摆动序列产生影响
        // 例如：[1,1,2,2] 等价于 [1,2] 对于摆动序列的计算
        int n = nums.length;
        int count = 1; // 至少有一个元素
        int prevDiff = 0; // 前一个差值
        int currDiff = 0; // 当前差值
        
        for (int i = 1; i < n; i++) {
            // 计算当前差值
            currDiff = nums[i] - nums[i - 1];
            
            // 如果当前差值与前一个差值符号不同，说明出现了摆动
            // 注意prevDiff可以是0（初始状态），这时只要currDiff不为0就计入
            if ((currDiff > 0 && prevDiff <= 0) || (currDiff < 0 && prevDiff >= 0)) {
                count++;
                prevDiff = currDiff; // 更新前一个差值
            }
        }
        
        return count;
    }
    
    /**
     * 动态规划解法
     * @param nums 输入数组
     * @return 最长摆动子序列的长度
     */
    public static int wiggleMaxLengthDP(int[] nums) {
        // 边界情况处理
        if (nums == null || nums.length == 0) {
            return 0;
        }
        int n = nums.length;
        if (n == 1) {
            return 1;
        }
        
        // dp[i][0]: 以nums[i]结尾且最后一个差值为正的最长摆动子序列长度
        // dp[i][1]: 以nums[i]结尾且最后一个差值为负的最长摆动子序列长度
        int[][] dp = new int[n][2];
        
        // 初始化：每个元素自身可以形成长度为1的摆动子序列
        for (int i = 0; i < n; i++) {
            dp[i][0] = 1;
            dp[i][1] = 1;
        }
        
        // 填充dp数组
        for (int i = 1; i < n; i++) {
            for (int j = 0; j < i; j++) {
                if (nums[i] > nums[j]) {
                    // 如果nums[i] > nums[j]，可以接在以nums[j]结尾且最后一个差值为负的序列后面
                    dp[i][0] = Math.max(dp[i][0], dp[j][1] + 1);
                } else if (nums[i] < nums[j]) {
                    // 如果nums[i] < nums[j]，可以接在以nums[j]结尾且最后一个差值为正的序列后面
                    dp[i][1] = Math.max(dp[i][1], dp[j][0] + 1);
                }
                // 如果相等，不更新
            }
        }
        
        // 找出最大值
        int maxLen = 0;
        for (int i = 0; i < n; i++) {
            maxLen = Math.max(maxLen, Math.max(dp[i][0], dp[i][1]));
        }
        
        return maxLen;
    }
    
    /**
     * 测试所有解法并比较结果
     * @param nums 输入数组
     */
    public static void testAllSolutions(int[] nums) {
        System.out.println("输入数组: " + Arrays.toString(nums));
        System.out.println("解法1（动态规划优化版）: " + wiggleMaxLength(nums));
        System.out.println("解法2（贪心算法）: " + wiggleMaxLengthGreedy(nums));
        System.out.println("解法3（常规动态规划）: " + wiggleMaxLengthDP(nums));
        System.out.println();
    }
}

===============================================

文件: Code07_WiggleSubsequence.py
===============================================
#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
摆动序列 - LeetCode 376
题目来源：https://leetcode.cn/problems/wiggle-subsequence/
难度：中等
题目描述：如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为摆动序列。
第一个差（如果存在的话）可能是正数或负数。少于两个元素的序列也是摆动序列。
例如，[1,7,4,9,2,5] 是一个摆动序列，因为差值 (6,-3,5,-7,3) 是正负交替出现的。
相反, [1,4,7,2,5] 和 [1,7,4,5,5] 不是摆动序列，第一个序列是因为它的前两个差值都是正数，
第二个序列是因为它的最后一个差值为零。

核心思路：
1. 这道题可以使用贪心算法来解决，因为我们只需要记录序列的趋势变化
2. 摆动序列的关键在于相邻元素的差值交替变化
3. 我们可以维护当前的趋势（上升、下降或初始状态），然后遍历数组，统计趋势变化的次数

复杂度分析：
时间复杂度：O(n)，其中n是数组的长度，我们只需要遍历一次数组
空间复杂度：O(1)，只使用了常数级别的额外空间
"""

from typing import List


def wiggleMaxLength(nums: List[int]) -> int:
    """
    计算最长摆动子序列的长度 - 动态规划优化版本
    
    参数:
        nums: 输入数组
    返回:
        最长摆动子序列的长度
    """
    # 边界情况：如果数组长度小于2，直接返回数组长度
    if not nums:
        return 0
    if len(nums) == 1:
        return 1
    
    up = 1   # 以最后一个差值为正的最长摆动子序列长度
    down = 1 # 以最后一个差值为负的最长摆动子序列长度
    
    # 遍历数组，从第二个元素开始
    for i in range(1, len(nums)):
        if nums[i] > nums[i-1]:
            # 当前是上升趋势，最长摆动子序列长度等于之前下降趋势的长度加1
            up = down + 1
        elif nums[i] < nums[i-1]:
            # 当前是下降趋势，最长摆动子序列长度等于之前上升趋势的长度加1
            down = up + 1
        # 如果相等，不做任何操作，保持up和down不变
    
    # 返回较大的值，因为最后一个差值可能是正也可能是负
    return max(up, down)


def wiggleMaxLengthGreedy(nums: List[int]) -> int:
    """
    贪心算法解法 - 记录趋势变化
    
    参数:
        nums: 输入数组
    返回:
        最长摆动子序列的长度
    """
    if not nums:
        return 0
    if len(nums) == 1:
        return 1
    
    count = 1    # 至少有一个元素
    prev_diff = 0 # 前一个差值
    curr_diff = 0 # 当前差值
    
    for i in range(1, len(nums)):
        curr_diff = nums[i] - nums[i-1]
        
        # 如果当前差值与前一个差值符号不同，说明出现了摆动
        if (curr_diff > 0 and prev_diff <= 0) or (curr_diff < 0 and prev_diff >= 0):
            count += 1
            prev_diff = curr_diff
    
    return count


def wiggleMaxLengthDP(nums: List[int]) -> int:
    """
    动态规划解法 - 标准DP
    
    参数:
        nums: 输入数组
    返回:
        最长摆动子序列的长度
    """
    if not nums:
        return 0
    n = len(nums)
    if n == 1:
        return 1
    
    # dp[i][0]: 以nums[i]结尾且最后一个差值为正的最长摆动子序列长度
    # dp[i][1]: 以nums[i]结尾且最后一个差值为负的最长摆动子序列长度
    dp = [[1] * 2 for _ in range(n)]
    
    max_len = 1
    
    for i in range(1, n):
        for j in range(i):
            if nums[i] > nums[j]:
                # 如果nums[i] > nums[j]，可以接在以nums[j]结尾且最后一个差值为负的序列后面
                dp[i][0] = max(dp[i][0], dp[j][1] + 1)
            elif nums[i] < nums[j]:
                # 如果nums[i] < nums[j]，可以接在以nums[j]结尾且最后一个差值为正的序列后面
                dp[i][1] = max(dp[i][1], dp[j][0] + 1)
        
        # 更新最大值
        max_len = max(max_len, max(dp[i][0], dp[i][1]))
    
    return max_len


def testAllSolutions(nums: List[int]):
    """
    测试所有解法并比较结果
    
    参数:
        nums: 输入数组
    """
    print(f"输入数组: {nums}")
    print(f"解法1（动态规划优化版）: {wiggleMaxLength(nums)}")
    print(f"解法2（贪心算法）: {wiggleMaxLengthGreedy(nums)}")
    print(f"解法3（常规动态规划）: {wiggleMaxLengthDP(nums)}")
    print()


def testCase():
    """
    测试用例
    """
    # 测试用例1
    nums1 = [1, 7, 4, 9, 2, 5]
    print("测试用例1：")
    print(f"预期结果：6")
    print(f"实际结果：{wiggleMaxLength(nums1)}")
    print()
    
    # 测试用例2
    nums2 = [1, 17, 5, 10, 13, 15, 10, 5, 16, 8]
    print("测试用例2：")
    print(f"预期结果：7")
    print(f"实际结果：{wiggleMaxLength(nums2)}")
    print()
    
    # 测试用例3
    nums3 = [1, 2, 3, 4, 5, 6, 7, 8, 9]
    print("测试用例3：")
    print(f"预期结果：2")
    print(f"实际结果：{wiggleMaxLength(nums3)}")
    print()
    
    # 测试用例4：边界情况
    nums4 = [1]  # 只有一个元素
    print("测试用例4：")
    print(f"预期结果：1")
    print(f"实际结果：{wiggleMaxLength(nums4)}")
    print()
    
    # 测试用例5：边界情况
    nums5 = [1, 1]  # 所有元素相同
    print("测试用例5：")
    print(f"预期结果：1")
    print(f"实际结果：{wiggleMaxLength(nums5)}")
    print()
    
    # 详细测试所有解法
    print("详细比较所有解法：")
    print("-" * 40)
    
    testAllSolutions(nums1)
    testAllSolutions(nums2)
    testAllSolutions(nums3)
    testAllSolutions(nums4)
    testAllSolutions(nums5)


if __name__ == "__main__":
    """
    主函数入口
    """
    testCase()
    
    # 性能测试
    print("性能测试：")
    print("-" * 40)
    
    # 测试大规模数据
    import time
    import random
    
    # 生成一个随机数组
    large_nums = [random.randint(1, 10000) for _ in range(1000)]
    
    start_time = time.time()
    result1 = wiggleMaxLength(large_nums)
    end_time = time.time()
    print(f"解法1（动态规划优化版）性能：{(end_time - start_time) * 1000:.3f} ms")
    
    start_time = time.time()
    result2 = wiggleMaxLengthGreedy(large_nums)
    end_time = time.time()
    print(f"解法2（贪心算法）性能：{(end_time - start_time) * 1000:.3f} ms")
    
    start_time = time.time()
    result3 = wiggleMaxLengthDP(large_nums)
    end_time = time.time()
    print(f"解法3（常规动态规划）性能：{(end_time - start_time) * 1000:.3f} ms")
    
    print(f"所有解法结果一致: {result1 == result2 == result3}")
    print(f"结果: {result1}")

===============================================

文件: Code08_LongestArithmeticSubsequence.cpp
===============================================
#include <iostream>
#include <vector>
#include <unordered_map>
#include <algorithm>
#include <string>
#include <chrono>

/**
 * 最长定差子序列 - LeetCode 1218
 * 题目来源：https://leetcode.cn/problems/longest-arithmetic-subsequence-of-given-difference/
 * 难度：中等
 * 题目描述：给你一个整数数组 arr 和一个整数 difference，请你找出并返回 arr 中最长等差子序列的长度，
 * 该子序列中相邻元素之间的差等于 difference。
 * 子序列 是指在不改变其余元素顺序的情况下，通过删除一些元素或不删除任何元素而从 arr 派生出来的序列。
 * 
 * 核心思路：
 * 1. 这道题是LIS问题的变种，但更特殊，因为我们需要的是固定差值的等差数列子序列
 * 2. 可以使用哈希表来优化动态规划的过程
 * 3. 对于每个元素arr[i]，我们需要查找是否存在arr[i] - difference这个元素，如果存在，则当前元素可以接在它后面形成更长的等差数列
 * 
 * 复杂度分析：
 * 时间复杂度：O(n)，其中n是数组的长度，我们只需要遍历一次数组，每次查询和更新哈希表的操作都是O(1)
 * 空间复杂度：O(n)，哈希表最多存储n个元素
 */

class Solution {
public:
    /**
     * 最优解法：使用哈希表优化动态规划
     * @param arr 输入数组
     * @param difference 固定差值
     * @return 最长等差子序列的长度
     */
    int longestSubsequence(const std::vector<int>& arr, int difference) {
        // 边界情况处理
        if (arr.empty()) {
            return 0;
        }
        
        // 使用哈希表存储每个数字最后出现时的最长子序列长度
        // key: 数字值, value: 以该数字结尾的最长等差子序列长度
        std::unordered_map<int, int> dp;
        
        int maxLength = 1; // 至少有一个元素
        
        // 遍历数组中的每个元素
        for (int num : arr) {
            // 查找前驱元素：num - difference
            int prev = num - difference;
            // 如果前驱元素存在，则当前元素可以接在它后面形成更长的子序列
            // 否则，当前元素自身形成一个长度为1的子序列
            auto it = dp.find(prev);
            int currentLength = (it != dp.end()) ? it->second + 1 : 1;
            
            // 更新当前元素的最长子序列长度
            auto currentIt = dp.find(num);
            if (currentIt == dp.end() || currentLength > currentIt->second) {
                dp[num] = currentLength;
            }
            
            // 更新全局最大长度
            maxLength = std::max(maxLength, currentLength);
        }
        
        return maxLength;
    }
    
    /**
     * 动态规划解法（未优化，用于对比）
     * 时间复杂度：O(n²)
     * 空间复杂度：O(n)
     * @param arr 输入数组
     * @param difference 固定差值
     * @return 最长等差子序列的长度
     */
    int longestSubsequenceDP(const std::vector<int>& arr, int difference) {
        if (arr.empty()) {
            return 0;
        }
        
        int n = arr.size();
        std::vector<int> dp(n, 1); // 初始化每个元素长度为1
        
        int maxLength = 1;
        
        // 填充dp数组
        for (int i = 1; i < n; ++i) {
            for (int j = 0; j < i; ++j) {
                if (arr[i] - arr[j] == difference) {
                    dp[i] = std::max(dp[i], dp[j] + 1);
                }
            }
            maxLength = std::max(maxLength, dp[i]);
        }
        
        return maxLength;
    }
    
    /**
     * 使用哈希表优化的进阶解法 - 考虑到可能有重复元素
     * @param arr 输入数组
     * @param difference 固定差值
     * @return 最长等差子序列的长度
     */
    int longestSubsequenceOptimized(const std::vector<int>& arr, int difference) {
        if (arr.empty()) {
            return 0;
        }
        
        // 使用哈希表记录每个数字最后出现时的最长子序列长度
        std::unordered_map<int, int> dp;
        int maxLength = 1;
        
        for (int num : arr) {
            // 当前数字可以接在num - difference后面
            int prevLength = 0;
            auto it = dp.find(num - difference);
            if (it != dp.end()) {
                prevLength = it->second;
            }
            
            int currentLength = prevLength + 1;
            
            // 如果当前数字已经在哈希表中，且之前记录的长度更大，则不更新
            auto currIt = dp.find(num);
            if (currIt == dp.end() || currentLength > currIt->second) {
                dp[num] = currentLength;
            }
            
            maxLength = std::max(maxLength, currentLength);
        }
        
        return maxLength;
    }
};

// 辅助函数：打印数组
void printVector(const std::vector<int>& vec) {
    std::cout << "[";
    for (size_t i = 0; i < vec.size(); ++i) {
        std::cout << vec[i];
        if (i < vec.size() - 1) {
            std::cout << ", ";
        }
    }
    std::cout << "]";
}

// 运行所有解法的对比测试
void runAllSolutionsTest(const std::vector<int>& arr, int difference, Solution& solution) {
    std::cout << "\n对比测试：";
    printVector(arr);
    std::cout << "，difference = " << difference << std::endl;
    
    // 测试哈希表优化解法
    auto start = std::chrono::high_resolution_clock::now();
    int result1 = solution.longestSubsequence(arr, difference);
    auto end = std::chrono::high_resolution_clock::now();
    auto duration = std::chrono::duration_cast<std::chrono::microseconds>(end - start).count();
    std::cout << "哈希表优化解法结果: " << result1 << std::endl;
    std::cout << "耗时: " << duration << " μs" << std::endl;
    
    // 测试优化进阶解法
    start = std::chrono::high_resolution_clock::now();
    int result3 = solution.longestSubsequenceOptimized(arr, difference);
    end = std::chrono::high_resolution_clock::now();
    duration = std::chrono::duration_cast<std::chrono::microseconds>(end - start).count();
    std::cout << "进阶优化解法结果: " << result3 << std::endl;
    std::cout << "耗时: " << duration << " μs" << std::endl;
    
    // 对于小型数组，也测试O(n²)的DP解法
    if (arr.size() <= 1000) { // 避免大数组导致超时
        start = std::chrono::high_resolution_clock::now();
        int result2 = solution.longestSubsequenceDP(arr, difference);
        end = std::chrono::high_resolution_clock::now();
        duration = std::chrono::duration_cast<std::chrono::microseconds>(end - start).count();
        std::cout << "传统DP解法结果: " << result2 << std::endl;
        std::cout << "耗时: " << duration << " μs" << std::endl;
    } else {
        std::cout << "数组长度较大，跳过传统DP解法测试" << std::endl;
    }
    
    std::cout << "----------------------------------------" << std::endl;
}

int main() {
    Solution solution;
    
    // 测试用例1
    std::vector<int> arr1 = {1, 2, 3, 4};
    int difference1 = 1;
    std::cout << "测试用例1：" << std::endl;
    std::cout << "输入数组: ";
    printVector(arr1);
    std::cout << ", difference: " << difference1 << std::endl;
    std::cout << "结果: " << solution.longestSubsequence(arr1, difference1) << "，预期: 4" << std::endl;
    std::cout << std::endl;
    
    // 测试用例2
    std::vector<int> arr2 = {1, 3, 5, 7};
    int difference2 = 1;
    std::cout << "测试用例2：" << std::endl;
    std::cout << "输入数组: ";
    printVector(arr2);
    std::cout << ", difference: " << difference2 << std::endl;
    std::cout << "结果: " << solution.longestSubsequence(arr2, difference2) << "，预期: 1" << std::endl;
    std::cout << std::endl;
    
    // 测试用例3
    std::vector<int> arr3 = {1, 5, 7, 8, 5, 3, 4, 2, 1};
    int difference3 = -2;
    std::cout << "测试用例3：" << std::endl;
    std::cout << "输入数组: ";
    printVector(arr3);
    std::cout << ", difference: " << difference3 << std::endl;
    std::cout << "结果: " << solution.longestSubsequence(arr3, difference3) << "，预期: 4" << std::endl;
    std::cout << std::endl;
    
    // 测试用例4：边界情况
    std::vector<int> arr4 = {1};
    int difference4 = 0;
    std::cout << "测试用例4：" << std::endl;
    std::cout << "输入数组: ";
    printVector(arr4);
    std::cout << ", difference: " << difference4 << std::endl;
    std::cout << "结果: " << solution.longestSubsequence(arr4, difference4) << "，预期: 1" << std::endl;
    std::cout << std::endl;
    
    // 测试用例5：负数差值
    std::vector<int> arr5 = {3, 0, -3, 4, -4, 7, 6};
    int difference5 = 3;
    std::cout << "测试用例5：" << std::endl;
    std::cout << "输入数组: ";
    printVector(arr5);
    std::cout << ", difference: " << difference5 << std::endl;
    std::cout << "结果: " << solution.longestSubsequence(arr5, difference5) << "，预期: 2" << std::endl;
    
    // 运行所有解法的对比测试
    runAllSolutionsTest(arr1, difference1, solution);
    runAllSolutionsTest(arr2, difference2, solution);
    runAllSolutionsTest(arr3, difference3, solution);
    runAllSolutionsTest(arr4, difference4, solution);
    runAllSolutionsTest(arr5, difference5, solution);
    
    return 0;
}

===============================================

文件: Code08_LongestArithmeticSubsequence.java
===============================================
package class072;

import java.util.Arrays;
import java.util.HashMap;
import java.util.Map;

/**
 * 最长定差子序列 - LeetCode 1218
 * 题目来源：https://leetcode.cn/problems/longest-arithmetic-subsequence-of-given-difference/
 * 难度：中等
 * 题目描述：给你一个整数数组 arr 和一个整数 difference，请你找出并返回 arr 中最长等差子序列的长度，
 * 该子序列中相邻元素之间的差等于 difference。
 * 子序列 是指在不改变其余元素顺序的情况下，通过删除一些元素或不删除任何元素而从 arr 派生出来的序列。
 * 
 * 核心思路：
 * 1. 这道题是LIS问题的变种，但更特殊，因为我们需要的是固定差值的等差数列子序列
 * 2. 可以使用哈希表来优化动态规划的过程
 * 3. 对于每个元素arr[i]，我们需要查找是否存在arr[i] - difference这个元素，如果存在，则当前元素可以接在它后面形成更长的等差数列
 * 
 * 复杂度分析：
 * 时间复杂度：O(n)，其中n是数组的长度，我们只需要遍历一次数组，每次查询和更新哈希表的操作都是O(1)
 * 空间复杂度：O(n)，哈希表最多存储n个元素
 */
public class Code08_LongestArithmeticSubsequence {

    /**
     * 主方法，用于测试
     */
    public static void main(String[] args) {
        // 测试用例1
        int[] arr1 = {1, 2, 3, 4};
        int difference1 = 1;
        System.out.println("测试用例1：");
        System.out.println("输入数组: " + Arrays.toString(arr1) + ", difference: " + difference1);
        System.out.println("结果: " + longestSubsequence(arr1, difference1) + "，预期: 4");
        System.out.println();
        
        // 测试用例2
        int[] arr2 = {1, 3, 5, 7};
        int difference2 = 1;
        System.out.println("测试用例2：");
        System.out.println("输入数组: " + Arrays.toString(arr2) + ", difference: " + difference2);
        System.out.println("结果: " + longestSubsequence(arr2, difference2) + "，预期: 1");
        System.out.println();
        
        // 测试用例3
        int[] arr3 = {1, 5, 7, 8, 5, 3, 4, 2, 1};
        int difference3 = -2;
        System.out.println("测试用例3：");
        System.out.println("输入数组: " + Arrays.toString(arr3) + ", difference: " + difference3);
        System.out.println("结果: " + longestSubsequence(arr3, difference3) + "，预期: 4");
        System.out.println();
        
        // 测试用例4：边界情况
        int[] arr4 = {1};
        int difference4 = 0;
        System.out.println("测试用例4：");
        System.out.println("输入数组: " + Arrays.toString(arr4) + ", difference: " + difference4);
        System.out.println("结果: " + longestSubsequence(arr4, difference4) + "，预期: 1");
        System.out.println();
        
        // 测试用例5：负数差值
        int[] arr5 = {3, 0, -3, 4, -4, 7, 6};
        int difference5 = 3;
        System.out.println("测试用例5：");
        System.out.println("输入数组: " + Arrays.toString(arr5) + ", difference: " + difference5);
        System.out.println("结果: " + longestSubsequence(arr5, difference5) + "，预期: 2");
        
        // 运行所有解法的对比测试
        runAllSolutionsTest(arr1, difference1);
        runAllSolutionsTest(arr2, difference2);
        runAllSolutionsTest(arr3, difference3);
        runAllSolutionsTest(arr4, difference4);
        runAllSolutionsTest(arr5, difference5);
    }
    
    /**
     * 最优解法：使用哈希表优化动态规划
     * @param arr 输入数组
     * @param difference 固定差值
     * @return 最长等差子序列的长度
     */
    public static int longestSubsequence(int[] arr, int difference) {
        // 边界情况处理
        if (arr == null || arr.length == 0) {
            return 0;
        }
        
        // 使用哈希表存储每个数字最后出现时的最长子序列长度
        // key: 数字值, value: 以该数字结尾的最长等差子序列长度
        Map<Integer, Integer> dp = new HashMap<>();
        
        int maxLength = 1; // 至少有一个元素
        
        // 遍历数组中的每个元素
        for (int num : arr) {
            // 查找前驱元素：num - difference
            int prev = num - difference;
            // 如果前驱元素存在，则当前元素可以接在它后面形成更长的子序列
            // 否则，当前元素自身形成一个长度为1的子序列
            int currentLength = dp.getOrDefault(prev, 0) + 1;
            
            // 更新当前元素的最长子序列长度
            dp.put(num, currentLength);
            
            // 更新全局最大长度
            maxLength = Math.max(maxLength, currentLength);
        }
        
        return maxLength;
    }
    
    /**
     * 动态规划解法（未优化，用于对比）
     * 时间复杂度：O(n²)
     * 空间复杂度：O(n)
     * @param arr 输入数组
     * @param difference 固定差值
     * @return 最长等差子序列的长度
     */
    public static int longestSubsequenceDP(int[] arr, int difference) {
        if (arr == null || arr.length == 0) {
            return 0;
        }
        
        int n = arr.length;
        int[] dp = new int[n];
        // 初始化：每个元素自身形成一个长度为1的子序列
        Arrays.fill(dp, 1);
        
        int maxLength = 1;
        
        // 填充dp数组
        for (int i = 1; i < n; i++) {
            for (int j = 0; j < i; j++) {
                if (arr[i] - arr[j] == difference) {
                    dp[i] = Math.max(dp[i], dp[j] + 1);
                }
            }
            maxLength = Math.max(maxLength, dp[i]);
        }
        
        return maxLength;
    }
    
    /**
     * 使用哈希表优化的进阶解法 - 考虑到可能有重复元素
     * @param arr 输入数组
     * @param difference 固定差值
     * @return 最长等差子序列的长度
     */
    public static int longestSubsequenceOptimized(int[] arr, int difference) {
        if (arr == null || arr.length == 0) {
            return 0;
        }
        
        // 使用哈希表记录每个数字最后出现时的最长子序列长度
        Map<Integer, Integer> dp = new HashMap<>();
        int maxLength = 1;
        
        for (int num : arr) {
            // 当前数字可以接在num - difference后面
            int prevLength = dp.getOrDefault(num - difference, 0);
            // 对于重复元素，我们总是保留最大的长度
            int currentLength = prevLength + 1;
            
            // 如果当前数字已经在哈希表中，且之前记录的长度更大，则不更新
            // 否则更新为更长的长度
            if (!dp.containsKey(num) || currentLength > dp.get(num)) {
                dp.put(num, currentLength);
            }
            
            maxLength = Math.max(maxLength, currentLength);
        }
        
        return maxLength;
    }
    
    /**
     * 运行所有解法的对比测试
     * @param arr 输入数组
     * @param difference 固定差值
     */
    public static void runAllSolutionsTest(int[] arr, int difference) {
        System.out.println("\n对比测试：" + Arrays.toString(arr) + "，difference = " + difference);
        
        // 测试哈希表优化解法
        long startTime = System.nanoTime();
        int result1 = longestSubsequence(arr, difference);
        long endTime = System.nanoTime();
        System.out.println("哈希表优化解法结果: " + result1);
        System.out.println("耗时: " + (endTime - startTime) / 1000 + " μs");
        
        // 测试优化进阶解法
        startTime = System.nanoTime();
        int result3 = longestSubsequenceOptimized(arr, difference);
        endTime = System.nanoTime();
        System.out.println("进阶优化解法结果: " + result3);
        System.out.println("耗时: " + (endTime - startTime) / 1000 + " μs");
        
        // 对于小型数组，也测试O(n²)的DP解法
        if (arr.length <= 1000) { // 避免大数组导致超时
            startTime = System.nanoTime();
            int result2 = longestSubsequenceDP(arr, difference);
            endTime = System.nanoTime();
            System.out.println("传统DP解法结果: " + result2);
            System.out.println("耗时: " + (endTime - startTime) / 1000 + " μs");
        } else {
            System.out.println("数组长度较大，跳过传统DP解法测试");
        }
        
        System.out.println("----------------------------------------");
    }
    
    /**
     * 性能测试函数
     * @param n 数组长度
     * @param difference 固定差值
     */
    public static void performanceTest(int n, int difference) {
        // 生成随机测试数据
        int[] arr = new int[n];
        for (int i = 0; i < n; i++) {
            arr[i] = (int)(Math.random() * 10000 - 5000); // 生成-5000到5000之间的随机数
        }
        
        System.out.println("\n性能测试：数组长度 = " + n);
        
        // 测试哈希表优化解法
        long startTime = System.nanoTime();
        int result1 = longestSubsequence(arr, difference);
        long endTime = System.nanoTime();
        System.out.println("哈希表优化解法耗时: " + (endTime - startTime) / 1_000_000 + " ms, 结果: " + result1);
        
        // 对于小型数组，也测试O(n²)的DP解法
        if (n <= 5000) { // 限制数组大小以避免超时
            try {
                startTime = System.nanoTime();
                int result2 = longestSubsequenceDP(arr, difference);
                endTime = System.nanoTime();
                System.out.println("传统DP解法耗时: " + (endTime - startTime) / 1_000_000 + " ms, 结果: " + result2);
            } catch (Exception e) {
                System.out.println("传统DP解法执行超时");
            }
        } else {
            System.out.println("数组长度超过阈值，跳过传统DP解法性能测试");
        }
    }
}

===============================================

文件: Code08_LongestArithmeticSubsequence.py
===============================================
#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
最长定差子序列 - LeetCode 1218
题目来源：https://leetcode.cn/problems/longest-arithmetic-subsequence-of-given-difference/
难度：中等
题目描述：给你一个整数数组 arr 和一个整数 difference，请你找出并返回 arr 中最长等差子序列的长度，
该子序列中相邻元素之间的差等于 difference。
子序列 是指在不改变其余元素顺序的情况下，通过删除一些元素或不删除任何元素而从 arr 派生出来的序列。

核心思路：
1. 这道题是LIS问题的变种，但更特殊，因为我们需要的是固定差值的等差数列子序列
2. 可以使用哈希表来优化动态规划的过程
3. 对于每个元素arr[i]，我们需要查找是否存在arr[i] - difference这个元素，如果存在，则当前元素可以接在它后面形成更长的等差数列

复杂度分析：
时间复杂度：O(n)，其中n是数组的长度，我们只需要遍历一次数组，每次查询和更新哈希表的操作都是O(1)
空间复杂度：O(n)，哈希表最多存储n个元素
"""

from typing import List, Dict
import time
import random


def longestSubsequence(arr: List[int], difference: int) -> int:
    """
    最优解法：使用哈希表优化动态规划
    
    参数:
        arr: 输入数组
        difference: 固定差值
    返回:
        最长等差子序列的长度
    """
    # 边界情况处理
    if not arr:
        return 0
    
    # 使用哈希表存储每个数字最后出现时的最长子序列长度
    # key: 数字值, value: 以该数字结尾的最长等差子序列长度
    dp: Dict[int, int] = {}
    
    max_length = 1  # 至少有一个元素
    
    # 遍历数组中的每个元素
    for num in arr:
        # 查找前驱元素：num - difference
        prev = num - difference
        # 如果前驱元素存在，则当前元素可以接在它后面形成更长的子序列
        # 否则，当前元素自身形成一个长度为1的子序列
        current_length = dp.get(prev, 0) + 1
        
        # 更新当前元素的最长子序列长度
        # 对于重复元素，我们保留最大的长度
        if num not in dp or current_length > dp[num]:
            dp[num] = current_length
        
        # 更新全局最大长度
        max_length = max(max_length, current_length)
    
    return max_length


def longestSubsequenceDP(arr: List[int], difference: int) -> int:
    """
    动态规划解法（未优化，用于对比）
    时间复杂度：O(n²)
    空间复杂度：O(n)
    
    参数:
        arr: 输入数组
        difference: 固定差值
    返回:
        最长等差子序列的长度
    """
    if not arr:
        return 0
    
    n = len(arr)
    dp = [1] * n  # 初始化每个元素长度为1
    
    max_length = 1
    
    # 填充dp数组
    for i in range(1, n):
        for j in range(i):
            if arr[i] - arr[j] == difference:
                dp[i] = max(dp[i], dp[j] + 1)
        max_length = max(max_length, dp[i])
    
    return max_length


def longestSubsequenceOptimized(arr: List[int], difference: int) -> int:
    """
    使用哈希表优化的进阶解法 - 考虑到可能有重复元素
    
    参数:
        arr: 输入数组
        difference: 固定差值
    返回:
        最长等差子序列的长度
    """
    if not arr:
        return 0
    
    # 使用哈希表记录每个数字最后出现时的最长子序列长度
    dp: Dict[int, int] = {}
    max_length = 1
    
    for num in arr:
        # 当前数字可以接在num - difference后面
        prev_length = dp.get(num - difference, 0)
        current_length = prev_length + 1
        
        # 如果当前数字已经在哈希表中，且之前记录的长度更大，则不更新
        if num not in dp or current_length > dp[num]:
            dp[num] = current_length
        
        max_length = max(max_length, current_length)
    
    return max_length


def runAllSolutionsTest(arr: List[int], difference: int):
    """
    运行所有解法的对比测试
    
    参数:
        arr: 输入数组
        difference: 固定差值
    """
    print(f"\n对比测试：{arr}，difference = {difference}")
    
    # 测试哈希表优化解法
    start_time = time.time()
    result1 = longestSubsequence(arr, difference)
    end_time = time.time()
    print(f"哈希表优化解法结果: {result1}")
    print(f"耗时: {(end_time - start_time) * 1_000_000:.2f} μs")
    
    # 测试优化进阶解法
    start_time = time.time()
    result3 = longestSubsequenceOptimized(arr, difference)
    end_time = time.time()
    print(f"进阶优化解法结果: {result3}")
    print(f"耗时: {(end_time - start_time) * 1_000_000:.2f} μs")
    
    # 对于小型数组，也测试O(n²)的DP解法
    if len(arr) <= 1000:  # 避免大数组导致超时
        start_time = time.time()
        result2 = longestSubsequenceDP(arr, difference)
        end_time = time.time()
        print(f"传统DP解法结果: {result2}")
        print(f"耗时: {(end_time - start_time) * 1_000_000:.2f} μs")
    else:
        print("数组长度较大，跳过传统DP解法测试")
    
    print("-" * 40)


def performanceTest(n: int, difference: int):
    """
    性能测试函数
    
    参数:
        n: 数组长度
        difference: 固定差值
    """
    # 生成随机测试数据
    arr = [random.randint(-5000, 5000) for _ in range(n)]
    
    print(f"\n性能测试：数组长度 = {n}")
    
    # 测试哈希表优化解法
    start_time = time.time()
    result1 = longestSubsequence(arr, difference)
    end_time = time.time()
    print(f"哈希表优化解法耗时: {(end_time - start_time) * 1000:.3f} ms, 结果: {result1}")
    
    # 对于小型数组，也测试O(n²)的DP解法
    if n <= 5000:  # 限制数组大小以避免超时
        try:
            start_time = time.time()
            result2 = longestSubsequenceDP(arr, difference)
            end_time = time.time()
            print(f"传统DP解法耗时: {(end_time - start_time) * 1000:.3f} ms, 结果: {result2}")
        except Exception:
            print("传统DP解法执行超时")
    else:
        print("数组长度超过阈值，跳过传统DP解法性能测试")


def testCase():
    """
    测试用例
    """
    # 测试用例1
    arr1 = [1, 2, 3, 4]
    difference1 = 1
    print("测试用例1：")
    print(f"输入数组: {arr1}, difference: {difference1}")
    print(f"结果: {longestSubsequence(arr1, difference1)}，预期: 4")
    print()
    
    # 测试用例2
    arr2 = [1, 3, 5, 7]
    difference2 = 1
    print("测试用例2：")
    print(f"输入数组: {arr2}, difference: {difference2}")
    print(f"结果: {longestSubsequence(arr2, difference2)}，预期: 1")
    print()
    
    # 测试用例3
    arr3 = [1, 5, 7, 8, 5, 3, 4, 2, 1]
    difference3 = -2
    print("测试用例3：")
    print(f"输入数组: {arr3}, difference: {difference3}")
    print(f"结果: {longestSubsequence(arr3, difference3)}，预期: 4")
    print()
    
    # 测试用例4：边界情况
    arr4 = [1]
    difference4 = 0
    print("测试用例4：")
    print(f"输入数组: {arr4}, difference: {difference4}")
    print(f"结果: {longestSubsequence(arr4, difference4)}，预期: 1")
    print()
    
    # 测试用例5：负数差值
    arr5 = [3, 0, -3, 4, -4, 7, 6]
    difference5 = 3
    print("测试用例5：")
    print(f"输入数组: {arr5}, difference: {difference5}")
    print(f"结果: {longestSubsequence(arr5, difference5)}，预期: 2")
    
    # 运行所有解法的对比测试
    runAllSolutionsTest(arr1, difference1)
    runAllSolutionsTest(arr2, difference2)
    runAllSolutionsTest(arr3, difference3)
    runAllSolutionsTest(arr4, difference4)
    runAllSolutionsTest(arr5, difference5)
    
    # 性能测试
    print("性能测试:")
    print("-" * 40)
    performanceTest(1000, 5)
    performanceTest(10000, 5)
    
    # 特殊测试用例：所有元素相同
    print("\n特殊测试用例：所有元素相同")
    arr_same = [5, 5, 5, 5, 5]
    diff_same = 0
    print(f"输入数组: {arr_same}, difference: {diff_same}")
    print(f"结果: {longestSubsequence(arr_same, diff_same)}")
    
    # 特殊测试用例：严格递减序列，负差值
    print("\n特殊测试用例：严格递减序列，负差值")
    arr_decreasing = [10, 8, 6, 4, 2]
    diff_decreasing = -2
    print(f"输入数组: {arr_decreasing}, difference: {diff_decreasing}")
    print(f"结果: {longestSubsequence(arr_decreasing, diff_decreasing)}")


if __name__ == "__main__":
    """
    主函数入口
    """
    testCase()

===============================================

文件: Code08_MinimumOperationsToMakeArrayKIncreasingOptimized.cpp
===============================================
/**
 * 使数组K递增的最少操作次数 - 优化版本
 * 
 * 题目来源：LeetCode 2100. 使数组K递增的最少操作次数
 * 题目链接：https://leetcode.cn/problems/minimum-operations-to-make-the-array-k-increasing/
 * 题目描述：给定一个下标从 0 开始包含 n 个正整数的数组 arr，和一个正整数 k。
 * 如果对于每个满足 k <= i <= n-1 的下标 i，都有 arr[i-k] <= arr[i]，那么称 arr 是 K 递增的。
 * 每一次操作中，你可以选择一个下标 i 并将 arr[i] 改成任意正整数。
 * 请你返回对于给定的 k，使数组变成 K 递增的最少操作次数。
 * 
 * 算法思路：
 * 1. 将数组按照间隔 k 分成 k 组，每组内的元素需要满足递增关系
 * 2. 对每组分别计算最少操作次数，累加得到结果
 * 3. 每组的最少操作次数 = 组长度 - 组内最长不下降子序列长度
 *    - 最长不下降子序列可以保留不动
 *    - 其余元素需要修改
 * 4. 使用贪心+二分查找优化计算最长不下降子序列
 * 
 * 时间复杂度：O(n * log(n/k)) - 分成 k 组，每组平均长度 n/k，每组求 LIS 需要 O((n/k) * log(n/k))
 * 空间复杂度：O(n) - 需要辅助数组存储状态
 * 是否最优解：是，这是目前最优解法
 * 
 * 示例：
 * 输入：arr = [5,4,3,2,1], k = 1
 * 输出：4
 * 解释：对于 k = 1，数组最终要变为非递减的，最少操作次数为 4。
 * 
 * 输入：arr = [4,1,5,2,6,2], k = 2
 * 输出：0
 * 解释：数组已经 K 递增。
 * 
 * 输入：arr = [4,1,5,2,6,2], k = 3
 * 输出：2
 */

#define MAXN 100001

int nums[MAXN];
int ends[MAXN];

/**
 * 在不降序数组ends中查找<num的最左位置
 * 
 * 算法思路：
 * 1. 使用二分查找在有序数组中查找目标值
 * 2. 维护左边界l和右边界r
 * 3. 计算中间位置m，比较ends[m]与num的大小关系
 * 4. 如果num < ends[m]，说明目标位置在左半部分（包括m），更新ans和r
 * 5. 否则目标位置在右半部分，更新l
 * 
 * 时间复杂度：O(logn) - 标准二分查找
 * 空间复杂度：O(1) - 只使用常数额外空间
 * 是否最优解：是，这是标准的二分查找实现
 * 
 * @param len 有效长度
 * @param num 目标值
 * @return <num的最左位置，如果不存在返回-1
 */
int bs(int len, int num) {
    int l = 0, r = len - 1, m, ans = -1;
    while (l <= r) {
        m = (l + r) / 2;
        // 如果num < ends[m]，记录当前位置并继续在左半部分查找
        if (num < ends[m]) {
            ans = m;
            r = m - 1;
        } else {
            // 否则在右半部分查找
            l = m + 1;
        }
    }
    return ans;
}

// nums[0...size-1]中的最长不下降子序列长度
/**
 * 计算数组中最长不下降子序列的长度 - 优化版本
 * 
 * 算法思路：
 * 1. 维护一个数组ends，ends[i]表示长度为i+1的所有不下降子序列中，结尾元素的最小值
 * 2. 贪心思想：为了让不下降子序列尽可能长，我们希望结尾元素尽可能小
 * 3. 对于每个元素num，在ends数组中二分查找<num的最左位置
 *    - 如果找不到，说明num比所有元素都大，可以延长不下降子序列
 *    - 如果找到了位置find，将ends[find]更新为num
 * 
 * 时间复杂度：O(n*logn) - 遍历n个元素，每次二分查找O(logn)
 * 空间复杂度：O(n) - 需要ends数组存储状态
 * 是否最优解：是，这是求LIS长度的最优解法
 * 
 * @param size 数组长度
 * @return 最长不下降子序列的长度
 */
int lengthOfNoDecreasing(int size) {
    int len = 0;
    // 遍历数组中的每个元素
    for (int i = 0, find; i < size; i++) {
        // 在ends数组中查找<num的最左位置
        find = bs(len, nums[i]);
        // 如果找不到，说明nums[i]比所有元素都大，可以延长不下降子序列
        if (find == -1) {
            ends[len++] = nums[i];
        } else {
            // 如果找到了位置，更新该位置的值为nums[i]
            ends[find] = nums[i];
        }
    }
    return len;
}

/**
 * 计算使数组变成K递增的最少操作次数 - 优化版本
 * 
 * @param arr 输入数组
 * @param n 数组长度
 * @param k 间隔参数
 * @return 最少操作次数
 */
int kIncreasing(int arr[], int n, int k) {
    int ans = 0;
    // 将数组按照间隔k分成k组
    for (int i = 0, size; i < k; i++) {
        size = 0;
        // 把每一组的数字放入容器
        for (int j = i; j < n; j += k) {
            nums[size++] = arr[j];
        }
        // 当前组长度 - 当前组最长不下降子序列长度 = 当前组至少需要修改的数字个数
        ans += size - lengthOfNoDecreasing(size);
    }
    return ans;
}

// 用于测试的主函数
int main() {
    // 测试需要通过其他方式验证
    return 0;
}

===============================================

文件: Code08_MinimumOperationsToMakeArrayKIncreasingOptimized.java
===============================================
package class072;

/**
 * 使数组K递增的最少操作次数 - 优化版本
 * 
 * 题目来源：LeetCode 2100. 使数组K递增的最少操作次数
 * 题目链接：https://leetcode.cn/problems/minimum-operations-to-make-the-array-k-increasing/
 * 题目描述：给定一个下标从 0 开始包含 n 个正整数的数组 arr，和一个正整数 k。
 * 如果对于每个满足 k <= i <= n-1 的下标 i，都有 arr[i-k] <= arr[i]，那么称 arr 是 K 递增的。
 * 每一次操作中，你可以选择一个下标 i 并将 arr[i] 改成任意正整数。
 * 请你返回对于给定的 k，使数组变成 K 递增的最少操作次数。
 * 
 * 算法思路：
 * 1. 将数组按照间隔 k 分成 k 组，每组内的元素需要满足递增关系
 * 2. 对每组分别计算最少操作次数，累加得到结果
 * 3. 每组的最少操作次数 = 组长度 - 组内最长不下降子序列长度
 *    - 最长不下降子序列可以保留不动
 *    - 其余元素需要修改
 * 4. 使用贪心+二分查找优化计算最长不下降子序列
 * 
 * 时间复杂度：O(n * log(n/k)) - 分成 k 组，每组平均长度 n/k，每组求 LIS 需要 O((n/k) * log(n/k))
 * 空间复杂度：O(n) - 需要辅助数组存储状态
 * 是否最优解：是，这是目前最优解法
 * 
 * 示例：
 * 输入：arr = [5,4,3,2,1], k = 1
 * 输出：4
 * 解释：对于 k = 1，数组最终要变为非递减的，最少操作次数为 4。
 * 
 * 输入：arr = [4,1,5,2,6,2], k = 2
 * 输出：0
 * 解释：数组已经 K 递增。
 * 
 * 输入：arr = [4,1,5,2,6,2], k = 3
 * 输出：2
 */
public class Code08_MinimumOperationsToMakeArrayKIncreasingOptimized {

    public static int MAXN = 100001;

    public static int[] nums = new int[MAXN];

    public static int[] ends = new int[MAXN];

    /**
     * 计算使数组变成K递增的最少操作次数 - 优化版本
     * 
     * @param arr 输入数组
     * @param k 间隔参数
     * @return 最少操作次数
     */
    public static int kIncreasing(int[] arr, int k) {
        int n = arr.length;
        int ans = 0;
        // 将数组按照间隔k分成k组
        for (int i = 0, size; i < k; i++) {
            size = 0;
            // 把每一组的数字放入容器
            for (int j = i; j < n; j += k) {
                nums[size++] = arr[j];
            }
            // 当前组长度 - 当前组最长不下降子序列长度 = 当前组至少需要修改的数字个数
            ans += size - lengthOfNoDecreasing(size);
        }
        return ans;
    }

    // nums[0...size-1]中的最长不下降子序列长度
    /**
     * 计算数组中最长不下降子序列的长度 - 优化版本
     * 
     * 算法思路：
     * 1. 维护一个数组ends，ends[i]表示长度为i+1的所有不下降子序列中，结尾元素的最小值
     * 2. 贪心思想：为了让不下降子序列尽可能长，我们希望结尾元素尽可能小
     * 3. 对于每个元素num，在ends数组中二分查找<num的最左位置
     *    - 如果找不到，说明num比所有元素都大，可以延长不下降子序列
     *    - 如果找到了位置find，将ends[find]更新为num
     * 
     * 时间复杂度：O(n*logn) - 遍历n个元素，每次二分查找O(logn)
     * 空间复杂度：O(n) - 需要ends数组存储状态
     * 是否最优解：是，这是求LIS长度的最优解法
     * 
     * @param size 数组长度
     * @return 最长不下降子序列的长度
     */
    public static int lengthOfNoDecreasing(int size) {
        int len = 0;
        // 遍历数组中的每个元素
        for (int i = 0, find; i < size; i++) {
            // 在ends数组中查找<num的最左位置
            find = bs(len, nums[i]);
            // 如果找不到，说明nums[i]比所有元素都大，可以延长不下降子序列
            if (find == -1) {
                ends[len++] = nums[i];
            } else {
                // 如果找到了位置，更新该位置的值为nums[i]
                ends[find] = nums[i];
            }
        }
        return len;
    }

    /**
     * 在不降序数组ends中查找<num的最左位置
     * 
     * 算法思路：
     * 1. 使用二分查找在有序数组中查找目标值
     * 2. 维护左边界l和右边界r
     * 3. 计算中间位置m，比较ends[m]与num的大小关系
     * 4. 如果num < ends[m]，说明目标位置在左半部分（包括m），更新ans和r
     * 5. 否则目标位置在右半部分，更新l
     * 
     * 时间复杂度：O(logn) - 标准二分查找
     * 空间复杂度：O(1) - 只使用常数额外空间
     * 是否最优解：是，这是标准的二分查找实现
     * 
     * @param len 有效长度
     * @param num 目标值
     * @return <num的最左位置，如果不存在返回-1
     */
    public static int bs(int len, int num) {
        int l = 0, r = len - 1, m, ans = -1;
        while (l <= r) {
            m = (l + r) / 2;
            // 如果num < ends[m]，记录当前位置并继续在左半部分查找
            if (num < ends[m]) {
                ans = m;
                r = m - 1;
            } else {
                // 否则在右半部分查找
                l = m + 1;
            }
        }
        return ans;
    }

    // 测试方法
    public static void main(String[] args) {
        // 测试用例1
        int[] arr1 = {5, 4, 3, 2, 1};
        int k1 = 1;
        System.out.println("输入: arr = [5,4,3,2,1], k = 1");
        System.out.println("输出: " + kIncreasing(arr1, k1));
        System.out.println("期望: 4");
        System.out.println();
        
        // 测试用例2
        int[] arr2 = {4, 1, 5, 2, 6, 2};
        int k2 = 2;
        System.out.println("输入: arr = [4,1,5,2,6,2], k = 2");
        System.out.println("输出: " + kIncreasing(arr2, k2));
        System.out.println("期望: 0");
        System.out.println();
        
        // 测试用例3
        int[] arr3 = {4, 1, 5, 2, 6, 2};
        int k3 = 3;
        System.out.println("输入: arr = [4,1,5,2,6,2], k = 3");
        System.out.println("输出: " + kIncreasing(arr3, k3));
        System.out.println("期望: 2");
        System.out.println();
    }
}

===============================================

文件: Code08_MinimumOperationsToMakeArrayKIncreasingOptimized.py
===============================================
"""
使数组K递增的最少操作次数 - 优化版本

题目来源：LeetCode 2100. 使数组K递增的最少操作次数
题目链接：https://leetcode.cn/problems/minimum-operations-to-make-the-array-k-increasing/
题目描述：给定一个下标从 0 开始包含 n 个正整数的数组 arr，和一个正整数 k。
如果对于每个满足 k <= i <= n-1 的下标 i，都有 arr[i-k] <= arr[i]，那么称 arr 是 K 递增的。
每一次操作中，你可以选择一个下标 i 并将 arr[i] 改成任意正整数。
请你返回对于给定的 k，使数组变成 K 递增的最少操作次数。

算法思路：
1. 将数组按照间隔 k 分成 k 组，每组内的元素需要满足递增关系
2. 对每组分别计算最少操作次数，累加得到结果
3. 每组的最少操作次数 = 组长度 - 组内最长不下降子序列长度
   - 最长不下降子序列可以保留不动
   - 其余元素需要修改
4. 使用贪心+二分查找优化计算最长不下降子序列

时间复杂度：O(n * log(n/k)) - 分成 k 组，每组平均长度 n/k，每组求 LIS 需要 O((n/k) * log(n/k))
空间复杂度：O(n) - 需要辅助数组存储状态
是否最优解：是，这是目前最优解法

示例：
输入：arr = [5,4,3,2,1], k = 1
输出：4
解释：对于 k = 1，数组最终要变为非递减的，最少操作次数为 4。

输入：arr = [4,1,5,2,6,2], k = 2
输出：0
解释：数组已经 K 递增。

输入：arr = [4,1,5,2,6,2], k = 3
输出：2
"""


def bs(ends, num):
    """
    在不降序数组ends中查找<num的最左位置
    
    算法思路：
    1. 使用二分查找在有序数组中查找目标值
    2. 维护左边界l和右边界r
    3. 计算中间位置m，比较ends[m]与num的大小关系
    4. 如果num < ends[m]，说明目标位置在左半部分（包括m），更新ans和r
    5. 否则目标位置在右半部分，更新l
    
    时间复杂度：O(logn) - 标准二分查找
    空间复杂度：O(1) - 只使用常数额外空间
    是否最优解：是，这是标准的二分查找实现
    
    Args:
        ends: 不降序数组
        num: 目标值
        
    Returns:
        <num的最左位置，如果不存在返回-1
    """
    l, r, ans = 0, len(ends) - 1, -1
    while l <= r:
        m = (l + r) // 2
        # 如果num < ends[m]，记录当前位置并继续在左半部分查找
        if num < ends[m]:
            ans = m
            r = m - 1
        else:
            # 否则在右半部分查找
            l = m + 1
    return ans


def lengthOfNoDecreasing(nums):
    """
    计算数组中最长不下降子序列的长度 - 优化版本
    
    算法思路：
    1. 维护一个数组ends，ends[i]表示长度为i+1的所有不下降子序列中，结尾元素的最小值
    2. 贪心思想：为了让不下降子序列尽可能长，我们希望结尾元素尽可能小
    3. 对于每个元素num，在ends数组中二分查找<num的最左位置
       - 如果找不到，说明num比所有元素都大，可以延长不下降子序列
       - 如果找到了位置find，将ends[find]更新为num
    
    时间复杂度：O(n*logn) - 遍历n个元素，每次二分查找O(logn)
    空间复杂度：O(n) - 需要ends数组存储状态
    是否最优解：是，这是求LIS长度的最优解法
    
    Args:
        nums: 输入数组
        
    Returns:
        最长不下降子序列的长度
    """
    ends = []
    for num in nums:
        # 在ends数组中查找<num的最左位置
        find = bs(ends, num)
        # 如果找不到，说明num比所有元素都大，可以延长不下降子序列
        if find == -1:
            ends.append(num)
        else:
            # 如果找到了位置，更新该位置的值为num
            ends[find] = num
    return len(ends)


def kIncreasing(arr, k):
    """
    计算使数组变成K递增的最少操作次数 - 优化版本
    
    Args:
        arr: 输入数组
        k: 间隔参数
        
    Returns:
        最少操作次数
    """
    n = len(arr)
    ans = 0
    # 将数组按照间隔k分成k组
    for i in range(k):
        # 把每一组的数字放入容器
        group = []
        for j in range(i, n, k):
            group.append(arr[j])
        # 当前组长度 - 当前组最长不下降子序列长度 = 当前组至少需要修改的数字个数
        ans += len(group) - lengthOfNoDecreasing(group)
    return ans


# 测试方法
if __name__ == "__main__":
    # 测试用例1
    arr1 = [5, 4, 3, 2, 1]
    k1 = 1
    print("输入: arr = [5,4,3,2,1], k = 1")
    print("输出: ", kIncreasing(arr1, k1))
    print("期望: 4")
    print()
    
    # 测试用例2
    arr2 = [4, 1, 5, 2, 6, 2]
    k2 = 2
    print("输入: arr = [4,1,5,2,6,2], k = 2")
    print("输出: ", kIncreasing(arr2, k2))
    print("期望: 0")
    print()
    
    # 测试用例3
    arr3 = [4, 1, 5, 2, 6, 2]
    k3 = 3
    print("输入: arr = [4,1,5,2,6,2], k = 3")
    print("输出: ", kIncreasing(arr3, k3))
    print("期望: 2")

===============================================

文件: Code09_LongestFibonacciSubsequence.cpp
===============================================
#include <iostream>
#include <vector>
#include <unordered_map>
#include <unordered_set>
#include <algorithm>
#include <chrono>

/**
 * 最长的斐波那契子序列的长度 - LeetCode 873
 * 题目来源：https://leetcode.cn/problems/length-of-longest-fibonacci-subsequence/
 * 难度：中等
 * 题目描述：如果序列 X_1, X_2, ..., X_n 满足下列条件，就说它是斐波那契式的：
 * n >= 3
 * 对于所有 i + 2 <= n，都有 X_i + X_{i+1} = X_{i+2}
 * 给定一个严格递增的正整数数组形成序列 arr ，找到 arr 中最长的斐波那契式的子序列的长度。
 * 如果没有这样的子序列，返回 0。
 * 子序列是指从原数组中删除一些元素（可以删除任何元素，包括零个元素），剩下的元素保持原来的顺序而不改变。
 * 
 * 核心思路：
 * 1. 这道题是LIS问题的变种，我们需要找到满足斐波那契关系的最长子序列
 * 2. 使用动态规划+哈希表的方法：dp[i][j] 表示以arr[i]和arr[j]结尾的最长斐波那契子序列的长度
 * 3. 对于每对(i,j)，我们查找arr[j]-arr[i]是否存在于数组中且索引小于i，如果存在则可以形成更长的子序列
 * 
 * 复杂度分析：
 * 时间复杂度：O(n²)，其中n是数组的长度，我们需要填充大小为n×n的dp数组
 * 空间复杂度：O(n²)，用于存储dp数组，以及O(n)用于哈希表存储值到索引的映射
 */

class Solution {
public:
    /**
     * 最优解法：动态规划+哈希表
     * @param arr 严格递增的正整数数组
     * @return 最长斐波那契子序列的长度，如果不存在返回0
     */
    int lenLongestFibSubseq(const std::vector<int>& arr) {
        // 边界情况处理
        if (arr.size() < 3) {
            return 0;
        }
        
        int n = arr.size();
        // 创建哈希表，存储值到索引的映射，用于快速查找
        std::unordered_map<int, int> valueToIndex;
        for (int i = 0; i < n; i++) {
            valueToIndex[arr[i]] = i;
        }
        
        // dp[i][j] 表示以arr[i]和arr[j]结尾的最长斐波那契子序列的长度
        // 初始化为2，表示至少有两个元素
        std::vector<std::vector<int>> dp(n, std::vector<int>(n, 2));
        int maxLength = 0;
        
        // 填充dp数组
        for (int j = 0; j < n; j++) {
            for (int k = j + 1; k < n; k++) {
                // 查找潜在的第一个元素 arr[i] = arr[k] - arr[j]
                int target = arr[k] - arr[j];
                // 确保target存在且严格小于arr[j]（因为数组严格递增）
                auto it = valueToIndex.find(target);
                if (target < arr[j] && it != valueToIndex.end()) {
                    int i = it->second;
                    // 更新dp[j][k]
                    dp[j][k] = dp[i][j] + 1;
                    // 更新最大长度
                    maxLength = std::max(maxLength, dp[j][k]);
                }
            }
        }
        
        // 如果maxLength至少为3，则返回，否则返回0
        return maxLength >= 3 ? maxLength : 0;
    }
    
    /**
     * 另一种动态规划解法，使用不同的遍历顺序
     * @param arr 严格递增的正整数数组
     * @return 最长斐波那契子序列的长度，如果不存在返回0
     */
    int lenLongestFibSubseqAlternative(const std::vector<int>& arr) {
        if (arr.size() < 3) {
            return 0;
        }
        
        int n = arr.size();
        std::unordered_map<int, int> map;
        for (int i = 0; i < n; i++) {
            map[arr[i]] = i;
        }
        
        std::vector<std::vector<int>> dp(n, std::vector<int>(n, 0));
        int maxLength = 0;
        
        // 遍历所有可能的三元组 (i,j,k) 其中 i < j < k
        for (int k = 2; k < n; k++) {
            for (int j = 1; j < k; j++) {
                int target = arr[k] - arr[j];
                auto it = map.find(target);
                if (it != map.end() && it->second < j) {
                    int i = it->second;
                    dp[j][k] = dp[i][j] + 1;
                    maxLength = std::max(maxLength, dp[j][k]);
                }
            }
        }
        
        // 如果存在斐波那契子序列，长度至少为3
        return maxLength > 0 ? maxLength + 2 : 0;
    }
    
    /**
     * 暴力解法（仅供对比，时间复杂度高）
     * @param arr 严格递增的正整数数组
     * @return 最长斐波那契子序列的长度，如果不存在返回0
     */
    int lenLongestFibSubseqBruteForce(const std::vector<int>& arr) {
        if (arr.size() < 3) {
            return 0;
        }
        
        int n = arr.size();
        std::unordered_set<int> set(arr.begin(), arr.end());
        
        int maxLength = 0;
        
        // 枚举所有可能的前两个元素
        for (int i = 0; i < n; i++) {
            for (int j = i + 1; j < n; j++) {
                int a = arr[i];
                int b = arr[j];
                int length = 2;
                int next = a + b;
                
                // 检查是否可以形成更长的斐波那契序列
                while (set.count(next)) {
                    a = b;
                    b = next;
                    next = a + b;
                    length++;
                }
                
                if (length >= 3) {
                    maxLength = std::max(maxLength, length);
                }
            }
        }
        
        return maxLength;
    }
};

// 辅助函数：打印数组
void printVector(const std::vector<int>& vec) {
    std::cout << "[";
    for (size_t i = 0; i < vec.size(); ++i) {
        std::cout << vec[i];
        if (i < vec.size() - 1) {
            std::cout << ", ";
        }
    }
    std::cout << "]";
}

// 运行所有解法的对比测试
void runAllSolutionsTest(const std::vector<int>& arr, Solution& solution) {
    std::cout << "\n对比测试：";
    printVector(arr);
    std::cout << std::endl;
    
    // 测试动态规划+哈希表解法
    auto start = std::chrono::high_resolution_clock::now();
    int result1 = solution.lenLongestFibSubseq(arr);
    auto end = std::chrono::high_resolution_clock::now();
    auto duration = std::chrono::duration_cast<std::chrono::microseconds>(end - start).count();
    std::cout << "动态规划+哈希表解法结果: " << result1 << std::endl;
    std::cout << "耗时: " << duration << " μs" << std::endl;
    
    // 测试另一种动态规划解法
    start = std::chrono::high_resolution_clock::now();
    int result2 = solution.lenLongestFibSubseqAlternative(arr);
    end = std::chrono::high_resolution_clock::now();
    duration = std::chrono::duration_cast<std::chrono::microseconds>(end - start).count();
    std::cout << "另一种动态规划解法结果: " << result2 << std::endl;
    std::cout << "耗时: " << duration << " μs" << std::endl;
    
    // 对于小型数组，也测试暴力解法
    if (arr.size() <= 20) { // 避免大数组导致超时
        start = std::chrono::high_resolution_clock::now();
        int result3 = solution.lenLongestFibSubseqBruteForce(arr);
        end = std::chrono::high_resolution_clock::now();
        duration = std::chrono::duration_cast<std::chrono::microseconds>(end - start).count();
        std::cout << "暴力解法结果: " << result3 << std::endl;
        std::cout << "耗时: " << duration << " μs" << std::endl;
    } else {
        std::cout << "数组长度较大，跳过暴力解法测试" << std::endl;
    }
    
    std::cout << "----------------------------------------" << std::endl;
}

int main() {
    Solution solution;
    
    // 测试用例1
    std::vector<int> arr1 = {1, 2, 3, 4, 5, 6, 7, 8};
    std::cout << "测试用例1：" << std::endl;
    std::cout << "输入数组: ";
    printVector(arr1);
    std::cout << std::endl;
    std::cout << "结果: " << solution.lenLongestFibSubseq(arr1) << "，预期: 5" << std::endl;
    std::cout << std::endl;
    
    // 测试用例2
    std::vector<int> arr2 = {1, 3, 7, 11, 12, 14, 18};
    std::cout << "测试用例2：" << std::endl;
    std::cout << "输入数组: ";
    printVector(arr2);
    std::cout << std::endl;
    std::cout << "结果: " << solution.lenLongestFibSubseq(arr2) << "，预期: 3" << std::endl;
    std::cout << std::endl;
    
    // 测试用例3：边界情况
    std::vector<int> arr3 = {1, 2, 3};
    std::cout << "测试用例3：" << std::endl;
    std::cout << "输入数组: ";
    printVector(arr3);
    std::cout << std::endl;
    std::cout << "结果: " << solution.lenLongestFibSubseq(arr3) << "，预期: 3" << std::endl;
    std::cout << std::endl;
    
    // 测试用例4：没有斐波那契子序列
    std::vector<int> arr4 = {1, 4, 5};
    std::cout << "测试用例4：" << std::endl;
    std::cout << "输入数组: ";
    printVector(arr4);
    std::cout << std::endl;
    std::cout << "结果: " << solution.lenLongestFibSubseq(arr4) << "，预期: 0" << std::endl;
    
    // 运行所有解法的对比测试
    runAllSolutionsTest(arr1, solution);
    runAllSolutionsTest(arr2, solution);
    runAllSolutionsTest(arr3, solution);
    runAllSolutionsTest(arr4, solution);
    
    return 0;
}

===============================================

文件: Code09_LongestFibonacciSubsequence.java
===============================================
package class072;

import java.util.*;

/**
 * 最长的斐波那契子序列的长度 - LeetCode 873
 * 题目来源：https://leetcode.cn/problems/length-of-longest-fibonacci-subsequence/
 * 难度：中等
 * 题目描述：如果序列 X_1, X_2, ..., X_n 满足下列条件，就说它是斐波那契式的：
 * n >= 3
 * 对于所有 i + 2 <= n，都有 X_i + X_{i+1} = X_{i+2}
 * 给定一个严格递增的正整数数组形成序列 arr ，找到 arr 中最长的斐波那契式的子序列的长度。
 * 如果没有这样的子序列，返回 0。
 * 子序列是指从原数组中删除一些元素（可以删除任何元素，包括零个元素），剩下的元素保持原来的顺序而不改变。
 * 
 * 核心思路：
 * 1. 这道题是LIS问题的变种，我们需要找到满足斐波那契关系的最长子序列
 * 2. 使用动态规划+哈希表的方法：dp[i][j] 表示以arr[i]和arr[j]结尾的最长斐波那契子序列的长度
 * 3. 对于每对(i,j)，我们查找arr[j]-arr[i]是否存在于数组中且索引小于i，如果存在则可以形成更长的子序列
 * 
 * 复杂度分析：
 * 时间复杂度：O(n²)，其中n是数组的长度，我们需要填充大小为n×n的dp数组
 * 空间复杂度：O(n²)，用于存储dp数组，以及O(n)用于哈希表存储值到索引的映射
 */
public class Code09_LongestFibonacciSubsequence {

    /**
     * 主方法，用于测试
     */
    public static void main(String[] args) {
        // 测试用例1
        int[] arr1 = {1, 2, 3, 4, 5, 6, 7, 8};
        System.out.println("测试用例1：");
        System.out.println("输入数组: " + Arrays.toString(arr1));
        System.out.println("结果: " + lenLongestFibSubseq(arr1) + "，预期: 5");
        System.out.println();
        
        // 测试用例2
        int[] arr2 = {1, 3, 7, 11, 12, 14, 18};
        System.out.println("测试用例2：");
        System.out.println("输入数组: " + Arrays.toString(arr2));
        System.out.println("结果: " + lenLongestFibSubseq(arr2) + "，预期: 3");
        System.out.println();
        
        // 测试用例3：边界情况
        int[] arr3 = {1, 2, 3};
        System.out.println("测试用例3：");
        System.out.println("输入数组: " + Arrays.toString(arr3));
        System.out.println("结果: " + lenLongestFibSubseq(arr3) + "，预期: 3");
        System.out.println();
        
        // 测试用例4：没有斐波那契子序列
        int[] arr4 = {1, 4, 5};
        System.out.println("测试用例4：");
        System.out.println("输入数组: " + Arrays.toString(arr4));
        System.out.println("结果: " + lenLongestFibSubseq(arr4) + "，预期: 0");
        
        // 运行所有解法的对比测试
        runAllSolutionsTest(arr1);
        runAllSolutionsTest(arr2);
        runAllSolutionsTest(arr3);
        runAllSolutionsTest(arr4);
    }
    
    /**
     * 最优解法：动态规划+哈希表
     * @param arr 严格递增的正整数数组
     * @return 最长斐波那契子序列的长度，如果不存在返回0
     */
    public static int lenLongestFibSubseq(int[] arr) {
        // 边界情况处理
        if (arr == null || arr.length < 3) {
            return 0;
        }
        
        int n = arr.length;
        // 创建哈希表，存储值到索引的映射，用于快速查找
        Map<Integer, Integer> valueToIndex = new HashMap<>();
        for (int i = 0; i < n; i++) {
            valueToIndex.put(arr[i], i);
        }
        
        // dp[i][j] 表示以arr[i]和arr[j]结尾的最长斐波那契子序列的长度
        // 初始化为2，表示至少有两个元素
        int[][] dp = new int[n][n];
        int maxLength = 0;
        
        // 初始化dp数组为2
        for (int i = 0; i < n; i++) {
            for (int j = i + 1; j < n; j++) {
                dp[i][j] = 2;
            }
        }
        
        // 填充dp数组
        for (int j = 0; j < n; j++) {
            for (int k = j + 1; k < n; k++) {
                // 查找潜在的第一个元素 arr[i] = arr[k] - arr[j]
                int target = arr[k] - arr[j];
                // 确保target存在且严格小于arr[j]（因为数组严格递增）
                if (target < arr[j] && valueToIndex.containsKey(target)) {
                    int i = valueToIndex.get(target);
                    // 更新dp[j][k]
                    dp[j][k] = dp[i][j] + 1;
                    // 更新最大长度
                    maxLength = Math.max(maxLength, dp[j][k]);
                }
            }
        }
        
        // 如果maxLength至少为3，则返回，否则返回0
        return maxLength >= 3 ? maxLength : 0;
    }
    
    /**
     * 另一种动态规划解法，使用不同的遍历顺序
     * @param arr 严格递增的正整数数组
     * @return 最长斐波那契子序列的长度，如果不存在返回0
     */
    public static int lenLongestFibSubseqAlternative(int[] arr) {
        if (arr == null || arr.length < 3) {
            return 0;
        }
        
        int n = arr.length;
        Map<Integer, Integer> map = new HashMap<>();
        for (int i = 0; i < n; i++) {
            map.put(arr[i], i);
        }
        
        int[][] dp = new int[n][n];
        int maxLength = 0;
        
        // 遍历所有可能的三元组 (i,j,k) 其中 i < j < k
        for (int k = 2; k < n; k++) {
            for (int j = 1; j < k; j++) {
                int i = map.getOrDefault(arr[k] - arr[j], -1);
                if (i >= 0 && i < j) {
                    dp[j][k] = dp[i][j] + 1;
                    maxLength = Math.max(maxLength, dp[j][k]);
                }
            }
        }
        
        // 如果存在斐波那契子序列，长度至少为3
        return maxLength > 0 ? maxLength + 2 : 0;
    }
    
    /**
     * 暴力解法（仅供对比，时间复杂度高）
     * @param arr 严格递增的正整数数组
     * @return 最长斐波那契子序列的长度，如果不存在返回0
     */
    public static int lenLongestFibSubseqBruteForce(int[] arr) {
        if (arr == null || arr.length < 3) {
            return 0;
        }
        
        int n = arr.length;
        Set<Integer> set = new HashSet<>();
        for (int num : arr) {
            set.add(num);
        }
        
        int maxLength = 0;
        
        // 枚举所有可能的前两个元素
        for (int i = 0; i < n; i++) {
            for (int j = i + 1; j < n; j++) {
                int a = arr[i];
                int b = arr[j];
                int length = 2;
                int next = a + b;
                
                // 检查是否可以形成更长的斐波那契序列
                while (set.contains(next)) {
                    a = b;
                    b = next;
                    next = a + b;
                    length++;
                }
                
                if (length >= 3) {
                    maxLength = Math.max(maxLength, length);
                }
            }
        }
        
        return maxLength;
    }
    
    /**
     * 运行所有解法的对比测试
     * @param arr 输入数组
     */
    public static void runAllSolutionsTest(int[] arr) {
        System.out.println("\n对比测试：" + Arrays.toString(arr));
        
        // 测试动态规划+哈希表解法
        long startTime = System.nanoTime();
        int result1 = lenLongestFibSubseq(arr);
        long endTime = System.nanoTime();
        System.out.println("动态规划+哈希表解法结果: " + result1);
        System.out.println("耗时: " + (endTime - startTime) / 1000 + " μs");
        
        // 测试另一种动态规划解法
        startTime = System.nanoTime();
        int result2 = lenLongestFibSubseqAlternative(arr);
        endTime = System.nanoTime();
        System.out.println("另一种动态规划解法结果: " + result2);
        System.out.println("耗时: " + (endTime - startTime) / 1000 + " μs");
        
        // 对于小型数组，也测试暴力解法
        if (arr.length <= 20) { // 避免大数组导致超时
            startTime = System.nanoTime();
            int result3 = lenLongestFibSubseqBruteForce(arr);
            endTime = System.nanoTime();
            System.out.println("暴力解法结果: " + result3);
            System.out.println("耗时: " + (endTime - startTime) / 1000 + " μs");
        } else {
            System.out.println("数组长度较大，跳过暴力解法测试");
        }
        
        System.out.println("----------------------------------------");
    }
    
    /**
     * 性能测试函数
     * @param n 数组长度
     */
    public static void performanceTest(int n) {
        // 生成严格递增的随机测试数据
        int[] arr = new int[n];
        arr[0] = 1;
        for (int i = 1; i < n; i++) {
            arr[i] = arr[i-1] + (int)(Math.random() * 10 + 1); // 确保严格递增
        }
        
        System.out.println("\n性能测试：数组长度 = " + n);
        
        // 测试动态规划+哈希表解法
        long startTime = System.nanoTime();
        int result1 = lenLongestFibSubseq(arr);
        long endTime = System.nanoTime();
        System.out.println("动态规划+哈希表解法耗时: " + (endTime - startTime) / 1_000_000 + " ms, 结果: " + result1);
    }
}

===============================================

文件: Code09_LongestFibonacciSubsequence.py
===============================================
#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
最长的斐波那契子序列的长度 - LeetCode 873
题目来源：https://leetcode.cn/problems/length-of-longest-fibonacci-subsequence/
难度：中等
题目描述：如果序列 X_1, X_2, ..., X_n 满足下列条件，就说它是斐波那契式的：
    n >= 3
    对于所有 i + 2 <= n，都有 X_i + X_{i+1} = X_{i+2}
给定一个严格递增的正整数数组形成序列 arr ，找到 arr 中最长的斐波那契式的子序列的长度。
如果没有这样的子序列，返回 0。
子序列是指从原数组中删除一些元素（可以删除任何元素，包括零个元素），剩下的元素保持原来的顺序而不改变。

核心思路：
1. 这道题是LIS问题的变种，我们需要找到满足斐波那契关系的最长子序列
2. 使用动态规划+哈希表的方法：dp[i][j] 表示以arr[i]和arr[j]结尾的最长斐波那契子序列的长度
3. 对于每对(i,j)，我们查找arr[j]-arr[i]是否存在于数组中且索引小于i，如果存在则可以形成更长的子序列

复杂度分析：
时间复杂度：O(n²)，其中n是数组的长度，我们需要填充大小为n×n的dp数组
空间复杂度：O(n²)，用于存储dp数组，以及O(n)用于哈希表存储值到索引的映射
"""

from typing import List, Dict, Set
import time
import random


def lenLongestFibSubseq(arr: List[int]) -> int:
    """
    最优解法：动态规划+哈希表
    
    参数:
        arr: 严格递增的正整数数组
    返回:
        最长斐波那契子序列的长度，如果不存在返回0
    """
    # 边界情况处理
    if len(arr) < 3:
        return 0
    
    n = len(arr)
    # 创建哈希表，存储值到索引的映射，用于快速查找
    value_to_index: Dict[int, int] = {}
    for i in range(n):
        value_to_index[arr[i]] = i
    
    # dp[i][j] 表示以arr[i]和arr[j]结尾的最长斐波那契子序列的长度
    # 初始化为2，表示至少有两个元素
    dp = [[2] * n for _ in range(n)]
    max_length = 0
    
    # 填充dp数组
    for j in range(n):
        for k in range(j + 1, n):
            # 查找潜在的第一个元素 arr[i] = arr[k] - arr[j]
            target = arr[k] - arr[j]
            # 确保target存在且严格小于arr[j]（因为数组严格递增）
            if target < arr[j] and target in value_to_index:
                i = value_to_index[target]
                # 更新dp[j][k]
                dp[j][k] = dp[i][j] + 1
                # 更新最大长度
                max_length = max(max_length, dp[j][k])
    
    # 如果maxLength至少为3，则返回，否则返回0
    return max_length if max_length >= 3 else 0


def lenLongestFibSubseqAlternative(arr: List[int]) -> int:
    """
    另一种动态规划解法，使用不同的遍历顺序
    
    参数:
        arr: 严格递增的正整数数组
    返回:
        最长斐波那契子序列的长度，如果不存在返回0
    """
    if len(arr) < 3:
        return 0
    
    n = len(arr)
    map_: Dict[int, int] = {}
    for i in range(n):
        map_[arr[i]] = i
    
    dp = [[0] * n for _ in range(n)]
    max_length = 0
    
    # 遍历所有可能的三元组 (i,j,k) 其中 i < j < k
    for k in range(2, n):
        for j in range(1, k):
            target = arr[k] - arr[j]
            if target in map_ and map_[target] < j:
                i = map_[target]
                dp[j][k] = dp[i][j] + 1
                max_length = max(max_length, dp[j][k])
    
    # 如果存在斐波那契子序列，长度至少为3
    return max_length + 2 if max_length > 0 else 0


def lenLongestFibSubseqBruteForce(arr: List[int]) -> int:
    """
    暴力解法（仅供对比，时间复杂度高）
    
    参数:
        arr: 严格递增的正整数数组
    返回:
        最长斐波那契子序列的长度，如果不存在返回0
    """
    if len(arr) < 3:
        return 0
    
    n = len(arr)
    set_: Set[int] = set(arr)
    
    max_length = 0
    
    # 枚举所有可能的前两个元素
    for i in range(n):
        for j in range(i + 1, n):
            a = arr[i]
            b = arr[j]
            length = 2
            next_val = a + b
            
            # 检查是否可以形成更长的斐波那契序列
            while next_val in set_:
                a = b
                b = next_val
                next_val = a + b
                length += 1
            
            if length >= 3:
                max_length = max(max_length, length)
    
    return max_length


def runAllSolutionsTest(arr: List[int]):
    """
    运行所有解法的对比测试
    
    参数:
        arr: 输入数组
    """
    print(f"\n对比测试：{arr}")
    
    # 测试动态规划+哈希表解法
    start_time = time.time()
    result1 = lenLongestFibSubseq(arr)
    end_time = time.time()
    print(f"动态规划+哈希表解法结果: {result1}")
    print(f"耗时: {(end_time - start_time) * 1_000_000:.2f} μs")
    
    # 测试另一种动态规划解法
    start_time = time.time()
    result2 = lenLongestFibSubseqAlternative(arr)
    end_time = time.time()
    print(f"另一种动态规划解法结果: {result2}")
    print(f"耗时: {(end_time - start_time) * 1_000_000:.2f} μs")
    
    # 对于小型数组，也测试暴力解法
    if len(arr) <= 20:  # 避免大数组导致超时
        start_time = time.time()
        result3 = lenLongestFibSubseqBruteForce(arr)
        end_time = time.time()
        print(f"暴力解法结果: {result3}")
        print(f"耗时: {(end_time - start_time) * 1_000_000:.2f} μs")
    else:
        print("数组长度较大，跳过暴力解法测试")
    
    print("-" * 40)


def performanceTest(n: int):
    """
    性能测试函数
    
    参数:
        n: 数组长度
    """
    # 生成严格递增的随机测试数据
    arr = [1]
    for _ in range(n-1):
        arr.append(arr[-1] + random.randint(1, 10))  # 确保严格递增
    
    print(f"\n性能测试：数组长度 = {n}")
    
    # 测试动态规划+哈希表解法
    start_time = time.time()
    result1 = lenLongestFibSubseq(arr)
    end_time = time.time()
    print(f"动态规划+哈希表解法耗时: {(end_time - start_time) * 1000:.3f} ms, 结果: {result1}")


def testCase():
    """
    测试用例
    """
    # 测试用例1
    arr1 = [1, 2, 3, 4, 5, 6, 7, 8]
    print("测试用例1：")
    print(f"输入数组: {arr1}")
    print(f"结果: {lenLongestFibSubseq(arr1)}，预期: 5")
    print()
    
    # 测试用例2
    arr2 = [1, 3, 7, 11, 12, 14, 18]
    print("测试用例2：")
    print(f"输入数组: {arr2}")
    print(f"结果: {lenLongestFibSubseq(arr2)}，预期: 3")
    print()
    
    # 测试用例3：边界情况
    arr3 = [1, 2, 3]
    print("测试用例3：")
    print(f"输入数组: {arr3}")
    print(f"结果: {lenLongestFibSubseq(arr3)}，预期: 3")
    print()
    
    # 测试用例4：没有斐波那契子序列
    arr4 = [1, 4, 5]
    print("测试用例4：")
    print(f"输入数组: {arr4}")
    print(f"结果: {lenLongestFibSubseq(arr4)}，预期: 0")
    
    # 运行所有解法的对比测试
    runAllSolutionsTest(arr1)
    runAllSolutionsTest(arr2)
    runAllSolutionsTest(arr3)
    runAllSolutionsTest(arr4)
    
    # 性能测试
    print("性能测试:")
    print("-" * 40)
    performanceTest(100)
    performanceTest(200)
    
    # 特殊测试用例：较大的斐波那契序列
    print("\n特殊测试用例：较大的斐波那契序列")
    arr_fib = [1, 2, 3, 5, 8, 13, 21, 34, 55]
    print(f"输入数组: {arr_fib}")
    print(f"结果: {lenLongestFibSubseq(arr_fib)}")


if __name__ == "__main__":
    """
    主函数入口
    """
    testCase()

===============================================

文件: Code10_LongestArithmeticSequence.cpp
===============================================
#include <iostream>
#include <vector>
#include <unordered_map>
#include <unordered_set>
#include <algorithm>
#include <climits>
#include <chrono>

/**
 * 最长等差数列 - LeetCode 1027
 * 题目来源：https://leetcode.cn/problems/longest-arithmetic-subsequence/
 * 难度：中等
 * 题目描述：给你一个整数数组 nums，返回 nums 中最长等差子序列的长度。
 * 注意：子序列是指从数组中删除一些元素（可以不删除任何元素）而不改变其余元素的顺序得到的序列。
 * 等差子序列是指元素之间的差值都相等的序列。
 * 
 * 核心思路：
 * 1. 这道题是LIS问题的变种，我们需要找到具有相同差值的最长子序列
 * 2. 使用动态规划+哈希表的方法：dp[i][d] 表示以nums[i]结尾且公差为d的最长等差数列长度
 * 3. 对于每个元素nums[i]，遍历之前的所有元素nums[j]，计算差值d = nums[i] - nums[j]，并更新dp[i][d]
 * 
 * 复杂度分析：
 * 时间复杂度：O(n²)，其中n是数组的长度，对于每个元素，我们需要遍历之前的所有元素
 * 空间复杂度：O(n²)，最坏情况下，每个元素对应的不同公差数量接近n
 */

class Solution {
public:
    /**
     * 最优解法：动态规划+哈希表
     * @param nums 整数数组
     * @return 最长等差子序列的长度
     */
    int longestArithSeqLength(const std::vector<int>& nums) {
        // 边界情况处理
        if (nums.size() <= 1) {
            return nums.size();
        }
        
        int n = nums.size();
        int maxLength = 2; // 至少有两个元素时，长度至少为2
        
        // 使用数组的哈希表来存储每个位置的公差对应的最长长度
        // dp[i] 表示以nums[i]结尾的所有可能公差对应的最长等差子序列长度
        std::vector<std::unordered_map<int, int>> dp(n);
        
        // 填充dp数组
        for (int i = 1; i < n; i++) {
            for (int j = 0; j < i; j++) {
                // 计算公差
                int diff = nums[i] - nums[j];
                
                // 如果dp[j]中存在公差为diff的记录，则dp[i][diff] = dp[j][diff] + 1
                // 否则，dp[i][diff] = 2（至少有nums[j]和nums[i]两个元素）
                auto it = dp[j].find(diff);
                int prevLength = (it != dp[j].end()) ? it->second : 1;
                dp[i][diff] = prevLength + 1;
                
                // 更新最大长度
                maxLength = std::max(maxLength, dp[i][diff]);
            }
        }
        
        return maxLength;
    }
    
    /**
     * 另一种实现方式，使用二维数组（仅当数值范围较小时适用）
     * @param nums 整数数组
     * @return 最长等差子序列的长度
     */
    int longestArithSeqLength2(const std::vector<int>& nums) {
        if (nums.size() <= 1) {
            return nums.size();
        }
        
        int n = nums.size();
        int maxLength = 2;
        
        // 找出数组中的最小值和最大值，确定可能的公差范围
        int minVal = INT_MAX, maxVal = INT_MIN;
        for (int num : nums) {
            minVal = std::min(minVal, num);
            maxVal = std::max(maxVal, num);
        }
        
        // 计算可能的最大公差范围
        int maxDiff = maxVal - minVal;
        
        // dp[i][d+maxDiff] 表示以nums[i]结尾且公差为d的最长等差数列长度
        // 加上maxDiff是为了避免负索引
        std::vector<std::vector<int>> dp(n, std::vector<int>(2 * maxDiff + 1, 1));
        
        for (int i = 1; i < n; i++) {
            for (int j = 0; j < i; j++) {
                int diff = nums[i] - nums[j];
                // 将公差映射到非负索引
                int idx = diff + maxDiff;
                
                dp[i][idx] = dp[j][idx] + 1;
                maxLength = std::max(maxLength, dp[i][idx]);
            }
        }
        
        return maxLength;
    }
    
    /**
     * 暴力解法优化版：使用哈希表记录元素出现的位置
     * @param nums 整数数组
     * @return 最长等差子序列的长度
     */
    int longestArithSeqLengthBruteForce(const std::vector<int>& nums) {
        if (nums.size() <= 2) {
            return nums.size();
        }
        
        int n = nums.size();
        int maxLength = 2;
        
        // 使用哈希表存储每个值及其出现的索引列表
        std::unordered_map<int, std::vector<int>> valueToIndices;
        for (int i = 0; i < n; i++) {
            valueToIndices[nums[i]].push_back(i);
        }
        
        // 枚举所有可能的前两个元素
        for (int i = 0; i < n; i++) {
            for (int j = i + 1; j < n; j++) {
                int prev = nums[i];
                int curr = nums[j];
                int diff = curr - prev;
                int next = curr + diff;
                int length = 2;
                int currentJ = j;
                
                // 查找下一个元素
                while (valueToIndices.find(next) != valueToIndices.end()) {
                    // 找到在currentJ之后出现的next
                    bool found = false;
                    for (int idx : valueToIndices[next]) {
                        if (idx > currentJ) {
                            currentJ = idx;  // 更新currentJ为下一个元素的索引
                            prev = curr;
                            curr = next;
                            next = curr + diff;
                            length++;
                            found = true;
                            break;
                        }
                    }
                    
                    if (!found) {
                        break;
                    }
                }
                
                maxLength = std::max(maxLength, length);
            }
        }
        
        return maxLength;
    }
};

// 辅助函数：打印数组
void printVector(const std::vector<int>& vec) {
    std::cout << "[";
    for (size_t i = 0; i < vec.size(); ++i) {
        std::cout << vec[i];
        if (i < vec.size() - 1) {
            std::cout << ", ";
        }
    }
    std::cout << "]";
}

// 运行所有解法的对比测试
void runAllSolutionsTest(const std::vector<int>& nums, Solution& solution) {
    std::cout << "\n对比测试：";
    printVector(nums);
    std::cout << std::endl;
    
    // 测试动态规划+哈希表解法
    auto start = std::chrono::high_resolution_clock::now();
    int result1 = solution.longestArithSeqLength(nums);
    auto end = std::chrono::high_resolution_clock::now();
    auto duration = std::chrono::duration_cast<std::chrono::microseconds>(end - start).count();
    std::cout << "动态规划+哈希表解法结果: " << result1 << std::endl;
    std::cout << "耗时: " << duration << " μs" << std::endl;
    
    // 测试二维数组解法
    start = std::chrono::high_resolution_clock::now();
    int result2 = solution.longestArithSeqLength2(nums);
    end = std::chrono::high_resolution_clock::now();
    duration = std::chrono::duration_cast<std::chrono::microseconds>(end - start).count();
    std::cout << "二维数组解法结果: " << result2 << std::endl;
    std::cout << "耗时: " << duration << " μs" << std::endl;
    
    // 对于小型数组，也测试暴力优化解法
    if (nums.size() <= 20) { // 避免大数组导致超时
        start = std::chrono::high_resolution_clock::now();
        int result3 = solution.longestArithSeqLengthBruteForce(nums);
        end = std::chrono::high_resolution_clock::now();
        duration = std::chrono::duration_cast<std::chrono::microseconds>(end - start).count();
        std::cout << "暴力优化解法结果: " << result3 << std::endl;
        std::cout << "耗时: " << duration << " μs" << std::endl;
    } else {
        std::cout << "数组长度较大，跳过暴力优化解法测试" << std::endl;
    }
    
    std::cout << "----------------------------------------" << std::endl;
}

int main() {
    Solution solution;
    
    // 测试用例1
    std::vector<int> arr1 = {3, 6, 9, 12};
    std::cout << "测试用例1：" << std::endl;
    std::cout << "输入数组: ";
    printVector(arr1);
    std::cout << std::endl;
    std::cout << "结果: " << solution.longestArithSeqLength(arr1) << "，预期: 4" << std::endl;
    std::cout << std::endl;
    
    // 测试用例2
    std::vector<int> arr2 = {9, 4, 7, 2, 10};
    std::cout << "测试用例2：" << std::endl;
    std::cout << "输入数组: ";
    printVector(arr2);
    std::cout << std::endl;
    std::cout << "结果: " << solution.longestArithSeqLength(arr2) << "，预期: 3" << std::endl;
    std::cout << std::endl;
    
    // 测试用例3
    std::vector<int> arr3 = {20, 1, 15, 3, 10, 5, 8};
    std::cout << "测试用例3：" << std::endl;
    std::cout << "输入数组: ";
    printVector(arr3);
    std::cout << std::endl;
    std::cout << "结果: " << solution.longestArithSeqLength(arr3) << "，预期: 4" << std::endl;
    std::cout << std::endl;
    
    // 测试用例4：边界情况
    std::vector<int> arr4 = {1, 3, 5};
    std::cout << "测试用例4：" << std::endl;
    std::cout << "输入数组: ";
    printVector(arr4);
    std::cout << std::endl;
    std::cout << "结果: " << solution.longestArithSeqLength(arr4) << "，预期: 3" << std::endl;
    
    // 运行所有解法的对比测试
    runAllSolutionsTest(arr1, solution);
    runAllSolutionsTest(arr2, solution);
    runAllSolutionsTest(arr3, solution);
    runAllSolutionsTest(arr4, solution);
    
    return 0;
}

===============================================

文件: Code10_LongestArithmeticSequence.java
===============================================
package class072;

import java.util.*;

/**
 * 最长等差数列 - LeetCode 1027
 * 题目来源：https://leetcode.cn/problems/longest-arithmetic-subsequence/
 * 难度：中等
 * 题目描述：给你一个整数数组 nums，返回 nums 中最长等差子序列的长度。
 * 注意：子序列是指从数组中删除一些元素（可以不删除任何元素）而不改变其余元素的顺序得到的序列。
 * 等差子序列是指元素之间的差值都相等的序列。
 * 
 * 核心思路：
 * 1. 这道题是LIS问题的变种，我们需要找到具有相同差值的最长子序列
 * 2. 使用动态规划+哈希表的方法：dp[i][d] 表示以nums[i]结尾且公差为d的最长等差数列长度
 * 3. 对于每个元素nums[i]，遍历之前的所有元素nums[j]，计算差值d = nums[i] - nums[j]，并更新dp[i][d]
 * 
 * 复杂度分析：
 * 时间复杂度：O(n²)，其中n是数组的长度，对于每个元素，我们需要遍历之前的所有元素
 * 空间复杂度：O(n²)，最坏情况下，每个元素对应的不同公差数量接近n
 */
public class Code10_LongestArithmeticSequence {

    /**
     * 主方法，用于测试
     */
    public static void main(String[] args) {
        // 测试用例1
        int[] arr1 = {3, 6, 9, 12};
        System.out.println("测试用例1：");
        System.out.println("输入数组: " + Arrays.toString(arr1));
        System.out.println("结果: " + longestArithSeqLength(arr1) + "，预期: 4");
        System.out.println();
        
        // 测试用例2
        int[] arr2 = {9, 4, 7, 2, 10};
        System.out.println("测试用例2：");
        System.out.println("输入数组: " + Arrays.toString(arr2));
        System.out.println("结果: " + longestArithSeqLength(arr2) + "，预期: 3");
        System.out.println();
        
        // 测试用例3
        int[] arr3 = {20, 1, 15, 3, 10, 5, 8};
        System.out.println("测试用例3：");
        System.out.println("输入数组: " + Arrays.toString(arr3));
        System.out.println("结果: " + longestArithSeqLength(arr3) + "，预期: 4");
        System.out.println();
        
        // 测试用例4：边界情况
        int[] arr4 = {1, 3, 5};
        System.out.println("测试用例4：");
        System.out.println("输入数组: " + Arrays.toString(arr4));
        System.out.println("结果: " + longestArithSeqLength(arr4) + "，预期: 3");
        
        // 运行所有解法的对比测试
        runAllSolutionsTest(arr1);
        runAllSolutionsTest(arr2);
        runAllSolutionsTest(arr3);
        runAllSolutionsTest(arr4);
    }
    
    /**
     * 最优解法：动态规划+哈希表
     * @param nums 整数数组
     * @return 最长等差子序列的长度
     */
    public static int longestArithSeqLength(int[] nums) {
        // 边界情况处理
        if (nums == null || nums.length <= 1) {
            return nums.length;
        }
        
        int n = nums.length;
        int maxLength = 2; // 至少有两个元素时，长度至少为2
        
        // 使用数组的哈希表来存储每个位置的公差对应的最长长度
        // dp[i] 表示以nums[i]结尾的所有可能公差对应的最长等差子序列长度
        Map<Integer, Integer>[] dp = new HashMap[n];
        
        // 初始化dp数组
        for (int i = 0; i < n; i++) {
            dp[i] = new HashMap<>();
        }
        
        // 填充dp数组
        for (int i = 1; i < n; i++) {
            for (int j = 0; j < i; j++) {
                // 计算公差
                int diff = nums[i] - nums[j];
                
                // 如果dp[j]中存在公差为diff的记录，则dp[i][diff] = dp[j][diff] + 1
                // 否则，dp[i][diff] = 2（至少有nums[j]和nums[i]两个元素）
                dp[i].put(diff, dp[j].getOrDefault(diff, 1) + 1);
                
                // 更新最大长度
                maxLength = Math.max(maxLength, dp[i].get(diff));
            }
        }
        
        return maxLength;
    }
    
    /**
     * 另一种实现方式，使用二维数组（仅当数值范围较小时适用）
     * @param nums 整数数组
     * @return 最长等差子序列的长度
     */
    public static int longestArithSeqLength2(int[] nums) {
        if (nums == null || nums.length <= 1) {
            return nums.length;
        }
        
        int n = nums.length;
        int maxLength = 2;
        
        // 找出数组中的最小值和最大值，确定可能的公差范围
        int minVal = Integer.MAX_VALUE, maxVal = Integer.MIN_VALUE;
        for (int num : nums) {
            minVal = Math.min(minVal, num);
            maxVal = Math.max(maxVal, num);
        }
        
        // 计算可能的最大公差范围
        int maxDiff = maxVal - minVal;
        
        // dp[i][d+maxDiff] 表示以nums[i]结尾且公差为d的最长等差数列长度
        // 加上maxDiff是为了避免负索引
        int[][] dp = new int[n][2 * maxDiff + 1];
        
        // 初始化dp数组为1，表示每个元素自身构成一个长度为1的序列
        for (int i = 0; i < n; i++) {
            Arrays.fill(dp[i], 1);
        }
        
        for (int i = 1; i < n; i++) {
            for (int j = 0; j < i; j++) {
                int diff = nums[i] - nums[j];
                // 将公差映射到非负索引
                int idx = diff + maxDiff;
                
                dp[i][idx] = dp[j][idx] + 1;
                maxLength = Math.max(maxLength, dp[i][idx]);
            }
        }
        
        return maxLength;
    }
    
    /**
     * 暴力解法优化版：使用哈希表记录元素出现的位置
     * @param nums 整数数组
     * @return 最长等差子序列的长度
     */
    public static int longestArithSeqLengthBruteForce(int[] nums) {
        if (nums == null || nums.length <= 2) {
            return nums.length;
        }
        
        int n = nums.length;
        int maxLength = 2;
        
        // 使用哈希表存储每个值及其出现的索引列表
        Map<Integer, List<Integer>> valueToIndices = new HashMap<>();
        for (int i = 0; i < n; i++) {
            valueToIndices.putIfAbsent(nums[i], new ArrayList<>());
            valueToIndices.get(nums[i]).add(i);
        }
        
        // 枚举所有可能的前两个元素
        for (int i = 0; i < n; i++) {
            for (int j = i + 1; j < n; j++) {
                int prev = nums[i];
                int curr = nums[j];
                int diff = curr - prev;
                int next = curr + diff;
                int length = 2;
                
                // 查找下一个元素
                while (valueToIndices.containsKey(next)) {
                    // 找到在j之后出现的next
                    boolean found = false;
                    for (int idx : valueToIndices.get(next)) {
                        if (idx > j) {
                            j = idx;  // 更新j为下一个元素的索引
                            prev = curr;
                            curr = next;
                            next = curr + diff;
                            length++;
                            found = true;
                            break;
                        }
                    }
                    
                    if (!found) {
                        break;
                    }
                }
                
                maxLength = Math.max(maxLength, length);
            }
        }
        
        return maxLength;
    }
    
    /**
     * 运行所有解法的对比测试
     * @param nums 输入数组
     */
    public static void runAllSolutionsTest(int[] nums) {
        System.out.println("\n对比测试：" + Arrays.toString(nums));
        
        // 测试动态规划+哈希表解法
        long startTime = System.nanoTime();
        int result1 = longestArithSeqLength(nums);
        long endTime = System.nanoTime();
        System.out.println("动态规划+哈希表解法结果: " + result1);
        System.out.println("耗时: " + (endTime - startTime) / 1000 + " μs");
        
        // 测试二维数组解法
        startTime = System.nanoTime();
        int result2 = longestArithSeqLength2(nums);
        endTime = System.nanoTime();
        System.out.println("二维数组解法结果: " + result2);
        System.out.println("耗时: " + (endTime - startTime) / 1000 + " μs");
        
        // 对于小型数组，也测试暴力优化解法
        if (nums.length <= 20) { // 避免大数组导致超时
            startTime = System.nanoTime();
            int result3 = longestArithSeqLengthBruteForce(nums);
            endTime = System.nanoTime();
            System.out.println("暴力优化解法结果: " + result3);
            System.out.println("耗时: " + (endTime - startTime) / 1000 + " μs");
        } else {
            System.out.println("数组长度较大，跳过暴力优化解法测试");
        }
        
        System.out.println("----------------------------------------");
    }
    
    /**
     * 性能测试函数
     * @param n 数组长度
     */
    public static void performanceTest(int n) {
        // 生成随机测试数据
        int[] nums = new int[n];
        for (int i = 0; i < n; i++) {
            nums[i] = (int)(Math.random() * 1000);
        }
        
        System.out.println("\n性能测试：数组长度 = " + n);
        
        // 测试动态规划+哈希表解法
        long startTime = System.nanoTime();
        int result1 = longestArithSeqLength(nums);
        long endTime = System.nanoTime();
        System.out.println("动态规划+哈希表解法耗时: " + (endTime - startTime) / 1_000_000 + " ms, 结果: " + result1);
    }
}

===============================================

文件: Code10_LongestArithmeticSequence.py
===============================================
#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
最长等差数列 - LeetCode 1027
题目来源：https://leetcode.cn/problems/longest-arithmetic-subsequence/
难度：中等
题目描述：给你一个整数数组 nums，返回 nums 中最长等差子序列的长度。
注意：子序列是指从数组中删除一些元素（可以不删除任何元素）而不改变其余元素的顺序得到的序列。
等差子序列是指元素之间的差值都相等的序列。

核心思路：
1. 这道题是LIS问题的变种，我们需要找到具有相同差值的最长子序列
2. 使用动态规划+哈希表的方法：dp[i][d] 表示以nums[i]结尾且公差为d的最长等差数列长度
3. 对于每个元素nums[i]，遍历之前的所有元素nums[j]，计算差值d = nums[i] - nums[j]，并更新dp[i][d]

复杂度分析：
时间复杂度：O(n²)，其中n是数组的长度，对于每个元素，我们需要遍历之前的所有元素
空间复杂度：O(n²)，最坏情况下，每个元素对应的不同公差数量接近n
"""

from typing import List, Dict
import time
import random


def longestArithSeqLength(nums: List[int]) -> int:
    """
    最优解法：动态规划+哈希表
    
    参数:
        nums: 整数数组
    返回:
        最长等差子序列的长度
    """
    # 边界情况处理
    if len(nums) <= 1:
        return len(nums)
    
    n = len(nums)
    max_length = 2  # 至少有两个元素时，长度至少为2
    
    # 使用数组的字典来存储每个位置的公差对应的最长长度
    # dp[i] 表示以nums[i]结尾的所有可能公差对应的最长等差子序列长度
    dp: List[Dict[int, int]] = [{} for _ in range(n)]
    
    # 填充dp数组
    for i in range(1, n):
        for j in range(i):
            # 计算公差
            diff = nums[i] - nums[j]
            
            # 如果dp[j]中存在公差为diff的记录，则dp[i][diff] = dp[j][diff] + 1
            # 否则，dp[i][diff] = 2（至少有nums[j]和nums[i]两个元素）
            prev_length = dp[j].get(diff, 1)
            dp[i][diff] = prev_length + 1
            
            # 更新最大长度
            max_length = max(max_length, dp[i][diff])
    
    return max_length


def longestArithSeqLength2(nums: List[int]) -> int:
    """
    另一种实现方式，使用列表的字典（更简洁的版本）
    
    参数:
        nums: 整数数组
    返回:
        最长等差子序列的长度
    """
    if len(nums) <= 1:
        return len(nums)
    
    n = len(nums)
    max_length = 2
    
    # dp[i] 记录以nums[i]结尾的所有可能公差及其对应的最长序列长度
    dp: List[Dict[int, int]] = [{} for _ in range(n)]
    
    for i in range(n):
        for j in range(i):
            diff = nums[i] - nums[j]
            # 以nums[i]结尾且公差为diff的最长序列长度 = 
            # 以nums[j]结尾且公差为diff的最长序列长度 + 1
            dp[i][diff] = dp[j].get(diff, 1) + 1
            max_length = max(max_length, dp[i][diff])
    
    return max_length


def longestArithSeqLengthBruteForce(nums: List[int]) -> int:
    """
    暴力解法优化版：使用哈希表记录元素出现的位置
    
    参数:
        nums: 整数数组
    返回:
        最长等差子序列的长度
    """
    if len(nums) <= 2:
        return len(nums)
    
    n = len(nums)
    max_length = 2
    
    # 使用哈希表存储每个值及其出现的索引列表
    value_to_indices: Dict[int, List[int]] = {}
    for i in range(n):
        if nums[i] not in value_to_indices:
            value_to_indices[nums[i]] = []
        value_to_indices[nums[i]].append(i)
    
    # 枚举所有可能的前两个元素
    for i in range(n):
        for j in range(i + 1, j + 1 if n > 20 else n):  # 对于大数组限制j的范围
            prev = nums[i]
            curr = nums[j]
            diff = curr - prev
            next_val = curr + diff
            length = 2
            current_j = j
            
            # 查找下一个元素
            while next_val in value_to_indices:
                # 找到在current_j之后出现的next_val
                found = False
                for idx in value_to_indices[next_val]:
                    if idx > current_j:
                        current_j = idx  # 更新current_j为下一个元素的索引
                        prev = curr
                        curr = next_val
                        next_val = curr + diff
                        length += 1
                        found = True
                        break
                
                if not found:
                    break
            
            max_length = max(max_length, length)
    
    return max_length


def runAllSolutionsTest(nums: List[int]):
    """
    运行所有解法的对比测试
    
    参数:
        nums: 输入数组
    """
    print(f"\n对比测试：{nums}")
    
    # 测试动态规划+哈希表解法
    start_time = time.time()
    result1 = longestArithSeqLength(nums)
    end_time = time.time()
    print(f"动态规划+哈希表解法结果: {result1}")
    print(f"耗时: {(end_time - start_time) * 1_000_000:.2f} μs")
    
    # 测试另一种实现方式
    start_time = time.time()
    result2 = longestArithSeqLength2(nums)
    end_time = time.time()
    print(f"另一种实现方式结果: {result2}")
    print(f"耗时: {(end_time - start_time) * 1_000_000:.2f} μs")
    
    # 对于小型数组，也测试暴力优化解法
    if len(nums) <= 20:  # 避免大数组导致超时
        start_time = time.time()
        result3 = longestArithSeqLengthBruteForce(nums)
        end_time = time.time()
        print(f"暴力优化解法结果: {result3}")
        print(f"耗时: {(end_time - start_time) * 1_000_000:.2f} μs")
    else:
        print("数组长度较大，跳过暴力优化解法测试")
    
    print("-" * 40)


def performanceTest(n: int):
    """
    性能测试函数
    
    参数:
        n: 数组长度
    """
    # 生成随机测试数据
    nums = [random.randint(0, 1000) for _ in range(n)]
    
    print(f"\n性能测试：数组长度 = {n}")
    
    # 测试动态规划+哈希表解法
    start_time = time.time()
    result1 = longestArithSeqLength(nums)
    end_time = time.time()
    print(f"动态规划+哈希表解法耗时: {(end_time - start_time) * 1000:.3f} ms, 结果: {result1}")


def testCase():
    """
    测试用例
    """
    # 测试用例1
    arr1 = [3, 6, 9, 12]
    print("测试用例1：")
    print(f"输入数组: {arr1}")
    print(f"结果: {longestArithSeqLength(arr1)}，预期: 4")
    print()
    
    # 测试用例2
    arr2 = [9, 4, 7, 2, 10]
    print("测试用例2：")
    print(f"输入数组: {arr2}")
    print(f"结果: {longestArithSeqLength(arr2)}，预期: 3")
    print()
    
    # 测试用例3
    arr3 = [20, 1, 15, 3, 10, 5, 8]
    print("测试用例3：")
    print(f"输入数组: {arr3}")
    print(f"结果: {longestArithSeqLength(arr3)}，预期: 4")
    print()
    
    # 测试用例4：边界情况
    arr4 = [1, 3, 5]
    print("测试用例4：")
    print(f"输入数组: {arr4}")
    print(f"结果: {longestArithSeqLength(arr4)}，预期: 3")
    
    # 运行所有解法的对比测试
    runAllSolutionsTest(arr1)
    runAllSolutionsTest(arr2)
    runAllSolutionsTest(arr3)
    runAllSolutionsTest(arr4)
    
    # 性能测试
    print("性能测试:")
    print("-" * 40)
    performanceTest(100)
    performanceTest(200)
    
    # 特殊测试用例：完全相同的元素
    print("\n特殊测试用例：完全相同的元素")
    arr_same = [5, 5, 5, 5, 5]
    print(f"输入数组: {arr_same}")
    print(f"结果: {longestArithSeqLength(arr_same)}")
    
    # 特殊测试用例：降序数组
    print("\n特殊测试用例：降序数组")
    arr_desc = [10, 8, 6, 4, 2]
    print(f"输入数组: {arr_desc}")
    print(f"结果: {longestArithSeqLength(arr_desc)}")


if __name__ == "__main__":
    """
    主函数入口
    """
    testCase()

===============================================

文件: Code11_ArithmeticSlicesII.cpp
===============================================
#include <iostream>
#include <vector>
#include <unordered_map>
#include <algorithm>
#include <chrono>

/**
 * 等差数列划分 II - 子序列 - LeetCode 446
 * 题目来源：https://leetcode.cn/problems/arithmetic-slices-ii-subsequence/
 * 难度：困难
 * 题目描述：给你一个整数数组 nums，请你返回所有长度至少为 3 的等差子序列的数目。
 * 注意：子序列是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。
 * 另外，子序列中的元素在原数组中可能不连续，但等差子序列需要满足元素之间的差值相等。
 * 
 * 核心思路：
 * 1. 这道题是LIS问题的变种，我们需要计算所有可能的等差数列子序列数目
 * 2. 使用动态规划+哈希表的方法：dp[i][d] 表示以nums[i]结尾且公差为d的等差数列子序列的数目（至少有两个元素）
 * 3. 对于每个元素nums[i]，遍历之前的所有元素nums[j]，计算差值d = nums[i] - nums[j]，并更新dp[i][d] += dp[j][d] + 1
 * 4. 其中+1表示nums[j]和nums[i]形成的新的二元组，dp[j][d]表示可以接在已有等差序列后面的数目
 * 
 * 复杂度分析：
 * 时间复杂度：O(n²)，其中n是数组的长度，对于每个元素，我们需要遍历之前的所有元素
 * 空间复杂度：O(n²)，最坏情况下，每个元素对应的不同公差数量接近n
 */

class Solution {
public:
    /**
     * 最优解法：动态规划+哈希表
     * @param nums 整数数组
     * @return 所有长度至少为3的等差子序列的数目
     */
    int numberOfArithmeticSlices(std::vector<int>& nums) {
        // 边界情况处理
        if (nums.size() < 3) {
            return 0;
        }
        
        int n = nums.size();
        int total = 0; // 记录所有长度至少为3的等差子序列数目
        
        // dp[i] 是一个哈希表，键为公差，值为以nums[i]结尾且具有该公差的等差子序列数目（至少有两个元素）
        std::vector<std::unordered_map<long long, int>> dp(n);
        
        // 填充dp数组
        for (int i = 1; i < n; i++) {
            for (int j = 0; j < i; j++) {
                // 计算公差，注意可能会溢出，所以使用long long
                long long diff = static_cast<long long>(nums[i]) - nums[j];
                
                // 获取以nums[j]结尾且公差为diff的等差子序列数目
                auto it = dp[j].find(diff);
                int countJ = (it != dp[j].end()) ? it->second : 0;
                
                // 以nums[i]结尾且公差为diff的等差子序列数目 = 
                // 以nums[j]结尾且公差为diff的等差子序列数目（将nums[i]添加到这些序列后面） + 1（nums[j]和nums[i]形成的新二元组）
                dp[i][diff] += countJ + 1;
                
                // 只有当countJ >= 1时，才能形成长度至少为3的等差子序列
                // 因为countJ表示以nums[j]结尾且公差为diff的等差子序列数目（至少有两个元素）
                // 所以将nums[i]添加到这些序列后面，就形成了长度至少为3的等差子序列
                total += countJ;
            }
        }
        
        return total;
    }
    
    /**
     * 另一种实现方式，逻辑相同但写法略有不同
     * @param nums 整数数组
     * @return 所有长度至少为3的等差子序列的数目
     */
    int numberOfArithmeticSlicesAlternative(std::vector<int>& nums) {
        if (nums.size() < 3) {
            return 0;
        }
        
        int n = nums.size();
        int total = 0;
        
        // 使用vector的unordered_map存储状态
        std::vector<std::unordered_map<long long, int>> dp(n);
        
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < i; j++) {
                // 计算公差
                long long diff = static_cast<long long>(nums[i]) - nums[j];
                
                // 从dp[j]中获取公差为diff的序列数目
                int prevCount = 0;
                auto it = dp[j].find(diff);
                if (it != dp[j].end()) {
                    prevCount = it->second;
                }
                
                // 更新dp[i]中的状态
                dp[i][diff] += prevCount + 1;
                
                // 累加可以形成长度>=3的子序列数目
                total += prevCount;
            }
        }
        
        return total;
    }
    
    /**
     * 解释性更强的版本，添加了详细的中间变量说明
     * @param nums 整数数组
     * @return 所有长度至少为3的等差子序列的数目
     */
    int numberOfArithmeticSlicesExplained(std::vector<int>& nums) {
        if (nums.size() < 3) {
            return 0;
        }
        
        int n = nums.size();
        int result = 0;
        
        // dp[i][d]表示以nums[i]结尾，公差为d的等差子序列的数量（至少包含两个元素）
        std::vector<std::unordered_map<long long, int>> dp(n);
        
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < i; j++) {
                // 计算公差，注意数据范围
                long long diff = static_cast<long long>(nums[i]) - nums[j];
                
                // 获取以nums[j]结尾且公差为diff的等差子序列数目
                int sequencesEndingAtJ = 0;
                auto it = dp[j].find(diff);
                if (it != dp[j].end()) {
                    sequencesEndingAtJ = it->second;
                }
                
                // 新的序列数目：已有的序列数目 + 1（nums[j], nums[i]这个新的二元组）
                int newSequencesCount = sequencesEndingAtJ + 1;
                
                // 更新dp[i][diff]
                dp[i][diff] += newSequencesCount;
                
                // 对于每个以nums[j]结尾且公差为diff的序列，加上nums[i]后就形成了一个长度至少为3的序列
                // 因此，将sequencesEndingAtJ加到结果中
                result += sequencesEndingAtJ;
            }
        }
        
        return result;
    }
};

// 辅助函数：打印数组
void printVector(const std::vector<int>& vec) {
    std::cout << "[";
    for (size_t i = 0; i < vec.size(); ++i) {
        std::cout << vec[i];
        if (i < vec.size() - 1) {
            std::cout << ", ";
        }
    }
    std::cout << "]";
}

// 运行所有解法的对比测试
void runAllSolutionsTest(const std::vector<int>& nums) {
    Solution solution;
    std::cout << "\n对比测试：";
    printVector(nums);
    std::cout << std::endl;
    
    // 测试动态规划+哈希表解法
    auto start = std::chrono::high_resolution_clock::now();
    int result1 = solution.numberOfArithmeticSlices(nums);
    auto end = std::chrono::high_resolution_clock::now();
    auto duration = std::chrono::duration_cast<std::chrono::microseconds>(end - start).count();
    std::cout << "动态规划+哈希表解法结果: " << result1 << std::endl;
    std::cout << "耗时: " << duration << " μs" << std::endl;
    
    // 测试另一种实现方式
    start = std::chrono::high_resolution_clock::now();
    int result2 = solution.numberOfArithmeticSlicesAlternative(nums);
    end = std::chrono::high_resolution_clock::now();
    duration = std::chrono::duration_cast<std::chrono::microseconds>(end - start).count();
    std::cout << "另一种实现方式结果: " << result2 << std::endl;
    std::cout << "耗时: " << duration << " μs" << std::endl;
    
    // 测试解释性更强的版本
    start = std::chrono::high_resolution_clock::now();
    int result3 = solution.numberOfArithmeticSlicesExplained(nums);
    end = std::chrono::high_resolution_clock::now();
    duration = std::chrono::duration_cast<std::chrono::microseconds>(end - start).count();
    std::cout << "解释性版本结果: " << result3 << std::endl;
    std::cout << "耗时: " << duration << " μs" << std::endl;
    
    std::cout << "----------------------------------------" << std::endl;
}

// 性能测试函数
void performanceTest(int n) {
    Solution solution;
    // 生成随机测试数据
    std::vector<int> nums(n);
    for (int i = 0; i < n; i++) {
        nums[i] = rand() % 1000;
    }
    
    std::cout << "\n性能测试：数组长度 = " << n << std::endl;
    
    // 测试动态规划+哈希表解法
    auto start = std::chrono::high_resolution_clock::now();
    int result1 = solution.numberOfArithmeticSlices(nums);
    auto end = std::chrono::high_resolution_clock::now();
    auto duration = std::chrono::duration_cast<std::chrono::milliseconds>(end - start).count();
    std::cout << "动态规划+哈希表解法耗时: " << duration << " ms, 结果: " << result1 << std::endl;
}

int main() {
    Solution solution;
    
    // 测试用例1
    std::vector<int> arr1 = {2, 4, 6, 8, 10};
    std::cout << "测试用例1：" << std::endl;
    std::cout << "输入数组: ";
    printVector(arr1);
    std::cout << std::endl;
    std::cout << "结果: " << solution.numberOfArithmeticSlices(arr1) << "，预期: 7" << std::endl;
    std::cout << std::endl;
    
    // 测试用例2
    std::vector<int> arr2 = {7, 7, 7, 7, 7};
    std::cout << "测试用例2：" << std::endl;
    std::cout << "输入数组: ";
    printVector(arr2);
    std::cout << std::endl;
    std::cout << "结果: " << solution.numberOfArithmeticSlices(arr2) << "，预期: 16" << std::endl;
    std::cout << std::endl;
    
    // 测试用例3：边界情况
    std::vector<int> arr3 = {1, 2, 3};
    std::cout << "测试用例3：" << std::endl;
    std::cout << "输入数组: ";
    printVector(arr3);
    std::cout << std::endl;
    std::cout << "结果: " << solution.numberOfArithmeticSlices(arr3) << "，预期: 1" << std::endl;
    
    // 运行所有解法的对比测试
    runAllSolutionsTest(arr1);
    runAllSolutionsTest(arr2);
    runAllSolutionsTest(arr3);
    
    // 性能测试
    std::cout << "性能测试:" << std::endl;
    std::cout << "----------------------------------------" << std::endl;
    performanceTest(100);
    performanceTest(200);
    
    // 特殊测试用例：完全相同的元素
    std::cout << "\n特殊测试用例：完全相同的元素" << std::endl;
    std::vector<int> arrSame = {5, 5, 5, 5, 5};
    std::cout << "输入数组: ";
    printVector(arrSame);
    std::cout << std::endl;
    std::cout << "结果: " << solution.numberOfArithmeticSlices(arrSame) << std::endl;
    
    // 特殊测试用例：降序数组
    std::cout << "\n特殊测试用例：降序数组" << std::endl;
    std::vector<int> arrDesc = {10, 8, 6, 4, 2};
    std::cout << "输入数组: ";
    printVector(arrDesc);
    std::cout << std::endl;
    std::cout << "结果: " << solution.numberOfArithmeticSlices(arrDesc) << std::endl;
    
    return 0;
}

===============================================

文件: Code11_ArithmeticSlicesII.java
===============================================
package class072;

import java.util.*;

/**
 * 等差数列划分 II - 子序列 - LeetCode 446
 * 题目来源：https://leetcode.cn/problems/arithmetic-slices-ii-subsequence/
 * 难度：困难
 * 题目描述：给你一个整数数组 nums，请你返回所有长度至少为 3 的等差子序列的数目。
 * 注意：子序列是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。
 * 另外，子序列中的元素在原数组中可能不连续，但等差子序列需要满足元素之间的差值相等。
 * 
 * 核心思路：
 * 1. 这道题是LIS问题的变种，我们需要计算所有可能的等差数列子序列数目
 * 2. 使用动态规划+哈希表的方法：dp[i][d] 表示以nums[i]结尾且公差为d的等差数列子序列的数目（至少有两个元素）
 * 3. 对于每个元素nums[i]，遍历之前的所有元素nums[j]，计算差值d = nums[i] - nums[j]，并更新dp[i][d] += dp[j][d] + 1
 * 4. 其中+1表示nums[j]和nums[i]形成的新的二元组，dp[j][d]表示可以接在已有等差序列后面的数目
 * 
 * 复杂度分析：
 * 时间复杂度：O(n²)，其中n是数组的长度，对于每个元素，我们需要遍历之前的所有元素
 * 空间复杂度：O(n²)，最坏情况下，每个元素对应的不同公差数量接近n
 */
public class Code11_ArithmeticSlicesII {

    /**
     * 主方法，用于测试
     */
    public static void main(String[] args) {
        // 测试用例1
        int[] nums1 = {2, 4, 6, 8, 10};
        System.out.println("测试用例1：");
        System.out.println("输入数组: " + Arrays.toString(nums1));
        System.out.println("结果: " + numberOfArithmeticSlices(nums1) + "，预期: 7");
        System.out.println();
        
        // 测试用例2
        int[] nums2 = {7, 7, 7, 7, 7};
        System.out.println("测试用例2：");
        System.out.println("输入数组: " + Arrays.toString(nums2));
        System.out.println("结果: " + numberOfArithmeticSlices(nums2) + "，预期: 16");
        System.out.println();
        
        // 测试用例3：边界情况
        int[] nums3 = {1, 2, 3};
        System.out.println("测试用例3：");
        System.out.println("输入数组: " + Arrays.toString(nums3));
        System.out.println("结果: " + numberOfArithmeticSlices(nums3) + "，预期: 1");
        
        // 运行所有解法的对比测试
        runAllSolutionsTest(nums1);
        runAllSolutionsTest(nums2);
        runAllSolutionsTest(nums3);
    }
    
    /**
     * 最优解法：动态规划+哈希表
     * @param nums 整数数组
     * @return 所有长度至少为3的等差子序列的数目
     */
    public static int numberOfArithmeticSlices(int[] nums) {
        // 边界情况处理
        if (nums == null || nums.length < 3) {
            return 0;
        }
        
        int n = nums.length;
        int total = 0; // 记录所有长度至少为3的等差子序列数目
        
        // dp[i] 是一个哈希表，键为公差，值为以nums[i]结尾且具有该公差的等差子序列数目（至少有两个元素）
        Map<Long, Integer>[] dp = new HashMap[n];
        
        // 初始化dp数组
        for (int i = 0; i < n; i++) {
            dp[i] = new HashMap<>();
        }
        
        // 填充dp数组
        for (int i = 1; i < n; i++) {
            for (int j = 0; j < i; j++) {
                // 计算公差，注意可能会溢出，所以使用long
                long diff = (long) nums[i] - nums[j];
                
                // 获取以nums[j]结尾且公差为diff的等差子序列数目
                int countJ = dp[j].getOrDefault(diff, 0);
                
                // 以nums[i]结尾且公差为diff的等差子序列数目 = 
                // 以nums[j]结尾且公差为diff的等差子序列数目（将nums[i]添加到这些序列后面） + 1（nums[j]和nums[i]形成的新二元组）
                dp[i].put(diff, dp[i].getOrDefault(diff, 0) + countJ + 1);
                
                // 只有当countJ >= 1时，才能形成长度至少为3的等差子序列
                // 因为countJ表示以nums[j]结尾且公差为diff的等差子序列数目（至少有两个元素）
                // 所以将nums[i]添加到这些序列后面，就形成了长度至少为3的等差子序列
                total += countJ;
            }
        }
        
        return total;
    }
    
    /**
     * 另一种实现方式，使用Long作为公差类型以避免整数溢出
     * @param nums 整数数组
     * @return 所有长度至少为3的等差子序列的数目
     */
    public static int numberOfArithmeticSlicesAlternative(int[] nums) {
        if (nums == null || nums.length < 3) {
            return 0;
        }
        
        int n = nums.length;
        int total = 0;
        
        List<Map<Long, Integer>> dp = new ArrayList<>();
        for (int i = 0; i < n; i++) {
            dp.add(new HashMap<>());
        }
        
        for (int i = 1; i < n; i++) {
            for (int j = 0; j < i; j++) {
                long diff = (long) nums[i] - nums[j];
                
                int prevCount = dp.get(j).getOrDefault(diff, 0);
                dp.get(i).put(diff, dp.get(i).getOrDefault(diff, 0) + prevCount + 1);
                
                // 每次将prevCount累加到总结果中，因为这些都能形成新的长度>=3的子序列
                total += prevCount;
            }
        }
        
        return total;
    }
    
    /**
     * 解释性更强的版本，添加了详细的中间变量说明
     * @param nums 整数数组
     * @return 所有长度至少为3的等差子序列的数目
     */
    public static int numberOfArithmeticSlicesExplained(int[] nums) {
        if (nums == null || nums.length < 3) {
            return 0;
        }
        
        int n = nums.length;
        int result = 0;
        
        // dp[i][d]表示以nums[i]结尾，公差为d的等差子序列的数量（至少包含两个元素）
        Map<Long, Integer>[] dp = new HashMap[n];
        
        for (int i = 0; i < n; i++) {
            dp[i] = new HashMap<>();
        }
        
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < i; j++) {
                // 计算公差
                long diff = (long) nums[i] - nums[j];
                
                // 获取以nums[j]结尾且公差为diff的等差子序列数目
                int sequencesEndingAtJ = dp[j].getOrDefault(diff, 0);
                
                // 新的序列数目：已有的序列数目 + 1（nums[j], nums[i]这个新的二元组）
                int newSequencesCount = sequencesEndingAtJ + 1;
                
                // 更新dp[i][diff]
                dp[i].put(diff, dp[i].getOrDefault(diff, 0) + newSequencesCount);
                
                // 对于每个以nums[j]结尾且公差为diff的序列，加上nums[i]后就形成了一个长度至少为3的序列
                // 因此，将sequencesEndingAtJ加到结果中
                result += sequencesEndingAtJ;
            }
        }
        
        return result;
    }
    
    /**
     * 运行所有解法的对比测试
     * @param nums 输入数组
     */
    public static void runAllSolutionsTest(int[] nums) {
        System.out.println("\n对比测试：" + Arrays.toString(nums));
        
        // 测试动态规划+哈希表解法
        long startTime = System.nanoTime();
        int result1 = numberOfArithmeticSlices(nums);
        long endTime = System.nanoTime();
        System.out.println("动态规划+哈希表解法结果: " + result1);
        System.out.println("耗时: " + (endTime - startTime) / 1000 + " μs");
        
        // 测试另一种实现方式
        startTime = System.nanoTime();
        int result2 = numberOfArithmeticSlicesAlternative(nums);
        endTime = System.nanoTime();
        System.out.println("另一种实现方式结果: " + result2);
        System.out.println("耗时: " + (endTime - startTime) / 1000 + " μs");
        
        // 测试解释性更强的版本
        startTime = System.nanoTime();
        int result3 = numberOfArithmeticSlicesExplained(nums);
        endTime = System.nanoTime();
        System.out.println("解释性版本结果: " + result3);
        System.out.println("耗时: " + (endTime - startTime) / 1000 + " μs");
        
        System.out.println("----------------------------------------");
    }
    
    /**
     * 性能测试函数
     * @param n 数组长度
     */
    public static void performanceTest(int n) {
        // 生成随机测试数据
        int[] nums = new int[n];
        for (int i = 0; i < n; i++) {
            nums[i] = (int)(Math.random() * 1000);
        }
        
        System.out.println("\n性能测试：数组长度 = " + n);
        
        // 测试动态规划+哈希表解法
        long startTime = System.nanoTime();
        int result1 = numberOfArithmeticSlices(nums);
        long endTime = System.nanoTime();
        System.out.println("动态规划+哈希表解法耗时: " + (endTime - startTime) / 1_000_000 + " ms, 结果: " + result1);
    }
}

===============================================

文件: Code11_ArithmeticSlicesII.py
===============================================
#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
等差数列划分 II - 子序列 - LeetCode 446
题目来源：https://leetcode.cn/problems/arithmetic-slices-ii-subsequence/
难度：困难
题目描述：给你一个整数数组 nums，请你返回所有长度至少为 3 的等差子序列的数目。
注意：子序列是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。
另外，子序列中的元素在原数组中可能不连续，但等差子序列需要满足元素之间的差值相等。

核心思路：
1. 这道题是LIS问题的变种，我们需要计算所有可能的等差数列子序列数目
2. 使用动态规划+哈希表的方法：dp[i][d] 表示以nums[i]结尾且公差为d的等差数列子序列的数目（至少有两个元素）
3. 对于每个元素nums[i]，遍历之前的所有元素nums[j]，计算差值d = nums[i] - nums[j]，并更新dp[i][d] += dp[j][d] + 1
4. 其中+1表示nums[j]和nums[i]形成的新的二元组，dp[j][d]表示可以接在已有等差序列后面的数目

复杂度分析：
时间复杂度：O(n²)，其中n是数组的长度，对于每个元素，我们需要遍历之前的所有元素
空间复杂度：O(n²)，最坏情况下，每个元素对应的不同公差数量接近n
"""

from typing import List, Dict
import time
import random


def numberOfArithmeticSlices(nums: List[int]) -> int:
    """
    最优解法：动态规划+哈希表
    
    参数:
        nums: 整数数组
    返回:
        所有长度至少为3的等差子序列的数目
    """
    # 边界情况处理
    if len(nums) < 3:
        return 0
    
    n = len(nums)
    total = 0  # 记录所有长度至少为3的等差子序列数目
    
    # dp[i] 是一个字典，键为公差，值为以nums[i]结尾且具有该公差的等差子序列数目（至少有两个元素）
    dp: List[Dict[int, int]] = [{} for _ in range(n)]
    
    # 填充dp数组
    for i in range(1, n):
        for j in range(i):
            # 计算公差
            diff = nums[i] - nums[j]
            
            # 获取以nums[j]结尾且公差为diff的等差子序列数目
            count_j = dp[j].get(diff, 0)
            
            # 以nums[i]结尾且公差为diff的等差子序列数目 = 
            # 以nums[j]结尾且公差为diff的等差子序列数目（将nums[i]添加到这些序列后面） + 1（nums[j]和nums[i]形成的新二元组）
            dp[i][diff] = dp[i].get(diff, 0) + count_j + 1
            
            # 只有当count_j >= 1时，才能形成长度至少为3的等差子序列
            # 因为count_j表示以nums[j]结尾且公差为diff的等差子序列数目（至少有两个元素）
            # 所以将nums[i]添加到这些序列后面，就形成了长度至少为3的等差子序列
            total += count_j
    
    return total


def numberOfArithmeticSlicesAlternative(nums: List[int]) -> int:
    """
    另一种实现方式，逻辑相同但写法略有不同
    
    参数:
        nums: 整数数组
    返回:
        所有长度至少为3的等差子序列的数目
    """
    if len(nums) < 3:
        return 0
    
    n = len(nums)
    total = 0
    
    # 使用列表的字典存储状态
    dp: List[Dict[int, int]] = [{} for _ in range(n)]
    
    for i in range(n):
        for j in range(i):
            # 计算公差
            diff = nums[i] - nums[j]
            
            # 从dp[j]中获取公差为diff的序列数目
            prev_count = dp[j].get(diff, 0)
            
            # 更新dp[i]中的状态
            dp[i][diff] = dp[i].get(diff, 0) + prev_count + 1
            
            # 累加可以形成长度>=3的子序列数目
            total += prev_count
    
    return total


def numberOfArithmeticSlicesExplained(nums: List[int]) -> int:
    """
    解释性更强的版本，添加了详细的中间变量说明
    
    参数:
        nums: 整数数组
    返回:
        所有长度至少为3的等差子序列的数目
    """
    if len(nums) < 3:
        return 0
    
    n = len(nums)
    result = 0
    
    # dp[i][d]表示以nums[i]结尾，公差为d的等差子序列的数量（至少包含两个元素）
    dp: List[Dict[int, int]] = [{} for _ in range(n)]
    
    for i in range(n):
        for j in range(i):
            # 计算公差
            diff = nums[i] - nums[j]
            
            # 获取以nums[j]结尾且公差为diff的等差子序列数目
            sequences_ending_at_j = dp[j].get(diff, 0)
            
            # 新的序列数目：已有的序列数目 + 1（nums[j], nums[i]这个新的二元组）
            new_sequences_count = sequences_ending_at_j + 1
            
            # 更新dp[i][diff]
            dp[i][diff] = dp[i].get(diff, 0) + new_sequences_count
            
            # 对于每个以nums[j]结尾且公差为diff的序列，加上nums[i]后就形成了一个长度至少为3的序列
            # 因此，将sequences_ending_at_j加到结果中
            result += sequences_ending_at_j
    
    return result


def runAllSolutionsTest(nums: List[int]):
    """
    运行所有解法的对比测试
    
    参数:
        nums: 输入数组
    """
    print(f"\n对比测试：{nums}")
    
    # 测试动态规划+哈希表解法
    start_time = time.time()
    result1 = numberOfArithmeticSlices(nums)
    end_time = time.time()
    print(f"动态规划+哈希表解法结果: {result1}")
    print(f"耗时: {(end_time - start_time) * 1_000_000:.2f} μs")
    
    # 测试另一种实现方式
    start_time = time.time()
    result2 = numberOfArithmeticSlicesAlternative(nums)
    end_time = time.time()
    print(f"另一种实现方式结果: {result2}")
    print(f"耗时: {(end_time - start_time) * 1_000_000:.2f} μs")
    
    # 测试解释性更强的版本
    start_time = time.time()
    result3 = numberOfArithmeticSlicesExplained(nums)
    end_time = time.time()
    print(f"解释性版本结果: {result3}")
    print(f"耗时: {(end_time - start_time) * 1_000_000:.2f} μs")
    
    print("-" * 40)


def performanceTest(n: int):
    """
    性能测试函数
    
    参数:
        n: 数组长度
    """
    # 生成随机测试数据
    nums = [random.randint(0, 1000) for _ in range(n)]
    
    print(f"\n性能测试：数组长度 = {n}")
    
    # 测试动态规划+哈希表解法
    start_time = time.time()
    result1 = numberOfArithmeticSlices(nums)
    end_time = time.time()
    print(f"动态规划+哈希表解法耗时: {(end_time - start_time) * 1000:.3f} ms, 结果: {result1}")


def testCase():
    """
    测试用例
    """
    # 测试用例1
    arr1 = [2, 4, 6, 8, 10]
    print("测试用例1：")
    print(f"输入数组: {arr1}")
    print(f"结果: {numberOfArithmeticSlices(arr1)}，预期: 7")
    print()
    
    # 测试用例2
    arr2 = [7, 7, 7, 7, 7]
    print("测试用例2：")
    print(f"输入数组: {arr2}")
    print(f"结果: {numberOfArithmeticSlices(arr2)}，预期: 16")
    print()
    
    # 测试用例3：边界情况
    arr3 = [1, 2, 3]
    print("测试用例3：")
    print(f"输入数组: {arr3}")
    print(f"结果: {numberOfArithmeticSlices(arr3)}，预期: 1")
    
    # 运行所有解法的对比测试
    runAllSolutionsTest(arr1)
    runAllSolutionsTest(arr2)
    runAllSolutionsTest(arr3)
    
    # 性能测试
    print("性能测试:")
    print("-" * 40)
    performanceTest(100)
    performanceTest(200)
    
    # 特殊测试用例：完全相同的元素
    print("\n特殊测试用例：完全相同的元素")
    arr_same = [5, 5, 5, 5, 5]
    print(f"输入数组: {arr_same}")
    print(f"结果: {numberOfArithmeticSlices(arr_same)}")
    
    # 特殊测试用例：降序数组
    print("\n特殊测试用例：降序数组")
    arr_desc = [10, 8, 6, 4, 2]
    print(f"输入数组: {arr_desc}")
    print(f"结果: {numberOfArithmeticSlices(arr_desc)}")


if __name__ == "__main__":
    """
    主函数入口
    """
    testCase()

===============================================

文件: Code12_LongestIncreasingPathMatrix.cpp
===============================================
#include <iostream>
#include <vector>
#include <algorithm>
#include <chrono>

/**
 * 矩阵中的最长递增路径 - LeetCode 329
 * 题目来源：https://leetcode.cn/problems/longest-increasing-path-in-a-matrix/
 * 难度：困难
 * 题目描述：给定一个 m x n 的整数矩阵 matrix ，找出其中最长递增路径的长度。
 * 对于每个单元格，你可以往上，下，左，右四个方向移动。 你不能在对角线方向上移动或移动到边界外（即不允许环绕）。
 * 
 * 核心思路：
 * 1. 这道题是LIS问题的二维变体，我们需要在矩阵中寻找最长的递增路径
 * 2. 使用深度优先搜索(DFS) + 记忆化搜索(Memoization)来避免重复计算
 * 3. 对于每个单元格，我们从四个方向进行探索，只考虑值严格大于当前单元格的相邻单元格
 * 4. 用一个dp数组存储每个单元格的最长递增路径长度，避免重复计算
 * 
 * 复杂度分析：
 * 时间复杂度：O(m*n)，其中m和n分别是矩阵的行数和列数。每个单元格只会被访问一次
 * 空间复杂度：O(m*n)，用于存储dp数组
 */

class Solution {
private:
    // 定义四个方向的移动：上、右、下、左
    const std::vector<std::vector<int>> DIRECTIONS = {{-1, 0}, {0, 1}, {1, 0}, {0, -1}};
    int rows;  // 矩阵行数
    int cols;  // 矩阵列数
    std::vector<std::vector<int>> matrix;  // 输入矩阵
    std::vector<std::vector<int>> dp;  // 记忆化搜索数组

    /**
     * 深度优先搜索函数（类成员变量版本）
     */
    int dfs(int i, int j) {
        // 如果已经计算过以(i,j)为起点的最长路径长度，直接返回
        if (dp[i][j] != 0) {
            return dp[i][j];
        }
        
        int maxLength = 1;  // 路径至少包含当前单元格，长度为1
        
        // 探索四个方向
        for (const auto& dir : DIRECTIONS) {
            int ni = i + dir[0];
            int nj = j + dir[1];
            
            // 检查新位置是否有效，且值严格大于当前位置
            if (ni >= 0 && ni < rows && nj >= 0 && nj < cols && matrix[ni][nj] > matrix[i][j]) {
                // 递归计算从新位置出发的最长路径长度，并更新当前位置的最长路径长度
                int length = 1 + dfs(ni, nj);
                maxLength = std::max(maxLength, length);
            }
        }
        
        // 记忆化结果
        dp[i][j] = maxLength;
        return maxLength;
    }

public:
    /**
     * 最优解法：深度优先搜索 + 记忆化搜索
     * @param matrix 输入矩阵
     * @return 最长递增路径的长度
     */
    int longestIncreasingPath(const std::vector<std::vector<int>>& matrix) {
        if (matrix.empty() || matrix[0].empty()) {
            return 0;
        }
        
        int rows = matrix.size();
        int cols = matrix[0].size();
        std::vector<std::vector<int>> dp(rows, std::vector<int>(cols, 0));  // dp[i][j]表示以(i,j)为起点的最长递增路径长度
        int maxLength = 0;
        
        // 遍历每个单元格，寻找最长路径
        for (int i = 0; i < rows; i++) {
            for (int j = 0; j < cols; j++) {
                maxLength = std::max(maxLength, dfsHelper(matrix, dp, i, j, rows, cols));
            }
        }
        
        return maxLength;
    }
    
    /**
     * 深度优先搜索辅助函数，计算从(i,j)出发的最长递增路径长度
     */
    int dfsHelper(const std::vector<std::vector<int>>& matrix, std::vector<std::vector<int>>& dp,
                 int i, int j, int rows, int cols) {
        // 如果已经计算过以(i,j)为起点的最长路径长度，直接返回
        if (dp[i][j] != 0) {
            return dp[i][j];
        }
        
        int maxLength = 1;  // 路径至少包含当前单元格，长度为1
        
        // 探索四个方向
        for (const auto& dir : DIRECTIONS) {
            int ni = i + dir[0];
            int nj = j + dir[1];
            
            // 检查新位置是否有效，且值严格大于当前位置
            if (ni >= 0 && ni < rows && nj >= 0 && nj < cols && matrix[ni][nj] > matrix[i][j]) {
                // 递归计算从新位置出发的最长路径长度，并更新当前位置的最长路径长度
                int length = 1 + dfsHelper(matrix, dp, ni, nj, rows, cols);
                maxLength = std::max(maxLength, length);
            }
        }
        
        // 记忆化结果
        dp[i][j] = maxLength;
        return maxLength;
    }
    
    /**
     * 另一种实现方式：使用类成员变量
     */
    int longestIncreasingPathAlternative(const std::vector<std::vector<int>>& inputMatrix) {
        if (inputMatrix.empty() || inputMatrix[0].empty()) {
            return 0;
        }
        
        this->rows = inputMatrix.size();
        this->cols = inputMatrix[0].size();
        this->matrix = inputMatrix;
        this->dp = std::vector<std::vector<int>>(rows, std::vector<int>(cols, 0));
        
        int maxLength = 0;
        
        for (int i = 0; i < rows; i++) {
            for (int j = 0; j < cols; j++) {
                maxLength = std::max(maxLength, dfs(i, j));
            }
        }
        
        return maxLength;
    }
    
    /**
     * 解释性更强的版本，添加了更多注释和中间变量
     */
    int longestIncreasingPathExplained(const std::vector<std::vector<int>>& matrix) {
        if (matrix.empty() || matrix[0].empty()) {
            return 0;
        }
        
        int rows = matrix.size();
        int cols = matrix[0].size();
        // 创建记忆化数组，存储每个单元格的最长递增路径长度
        std::vector<std::vector<int>> memo(rows, std::vector<int>(cols, 0));
        int longestPath = 0;
        
        // 对每个单元格进行DFS搜索
        for (int i = 0; i < rows; i++) {
            for (int j = 0; j < cols; j++) {
                // 计算从当前单元格出发的最长递增路径
                int currentPathLength = dfsExplained(matrix, memo, i, j, rows, cols);
                // 更新全局最长路径
                longestPath = std::max(longestPath, currentPathLength);
            }
        }
        
        return longestPath;
    }
    
    /**
     * 带详细注释的深度优先搜索函数
     */
    int dfsExplained(const std::vector<std::vector<int>>& matrix, std::vector<std::vector<int>>& memo,
                    int row, int col, int rows, int cols) {
        // 检查记忆化数组，如果已经计算过则直接返回
        if (memo[row][col] > 0) {
            return memo[row][col];
        }
        
        // 初始化为1，因为路径至少包含当前单元格
        int maxPathFromHere = 1;
        
        // 定义四个方向的偏移量：上、右、下、左
        std::vector<std::vector<int>> directions = {{-1, 0}, {0, 1}, {1, 0}, {0, -1}};
        
        // 遍历所有可能的移动方向
        for (const auto& direction : directions) {
            // 计算新位置的坐标
            int newRow = row + direction[0];
            int newCol = col + direction[1];
            
            // 检查新位置是否有效：
            // 1. 不超出矩阵边界
            // 2. 新位置的值严格大于当前位置（保持递增）
            bool isValidMove = (newRow >= 0 && newRow < rows && 
                              newCol >= 0 && newCol < cols && 
                              matrix[newRow][newCol] > matrix[row][col]);
            
            if (isValidMove) {
                // 递归计算从新位置出发的最长路径长度
                // 加上1是因为当前位置也要算在路径中
                int pathLength = 1 + dfsExplained(matrix, memo, newRow, newCol, rows, cols);
                // 更新最大值
                maxPathFromHere = std::max(maxPathFromHere, pathLength);
            }
        }
        
        // 记忆化结果，避免重复计算
        memo[row][col] = maxPathFromHere;
        return maxPathFromHere;
    }
};

// 辅助函数：打印矩阵
void printMatrix(const std::vector<std::vector<int>>& matrix) {
    for (const auto& row : matrix) {
        std::cout << "[";
        for (size_t j = 0; j < row.size(); ++j) {
            std::cout << row[j];
            if (j < row.size() - 1) {
                std::cout << ", ";
            }
        }
        std::cout << "]" << std::endl;
    }
}

// 运行所有解法的对比测试
void runAllSolutionsTest(const std::vector<std::vector<int>>& matrix) {
    Solution solution;
    std::cout << "\n对比测试：" << std::endl;
    printMatrix(matrix);
    
    // 测试DFS + 记忆化解法
    auto start = std::chrono::high_resolution_clock::now();
    int result1 = solution.longestIncreasingPath(matrix);
    auto end = std::chrono::high_resolution_clock::now();
    auto duration = std::chrono::duration_cast<std::chrono::microseconds>(end - start).count();
    std::cout << "DFS + 记忆化解法结果: " << result1 << std::endl;
    std::cout << "耗时: " << duration << " μs" << std::endl;
    
    // 测试类成员变量版本
    start = std::chrono::high_resolution_clock::now();
    int result2 = solution.longestIncreasingPathAlternative(matrix);
    end = std::chrono::high_resolution_clock::now();
    duration = std::chrono::duration_cast<std::chrono::microseconds>(end - start).count();
    std::cout << "类成员变量版本结果: " << result2 << std::endl;
    std::cout << "耗时: " << duration << " μs" << std::endl;
    
    // 测试解释性版本
    start = std::chrono::high_resolution_clock::now();
    int result3 = solution.longestIncreasingPathExplained(matrix);
    end = std::chrono::high_resolution_clock::now();
    duration = std::chrono::duration_cast<std::chrono::microseconds>(end - start).count();
    std::cout << "解释性版本结果: " << result3 << std::endl;
    std::cout << "耗时: " << duration << " μs" << std::endl;
    
    std::cout << "----------------------------------------" << std::endl;
}

// 性能测试函数
void performanceTest(int size) {
    Solution solution;
    // 生成随机测试数据
    std::vector<std::vector<int>> matrix(size, std::vector<int>(size));
    for (int i = 0; i < size; i++) {
        for (int j = 0; j < size; j++) {
            matrix[i][j] = rand() % 1000;
        }
    }
    
    std::cout << "\n性能测试：矩阵大小 = " << size << "x" << size << std::endl;
    
    // 测试DFS + 记忆化解法
    auto start = std::chrono::high_resolution_clock::now();
    int result1 = solution.longestIncreasingPath(matrix);
    auto end = std::chrono::high_resolution_clock::now();
    auto duration = std::chrono::duration_cast<std::chrono::milliseconds>(end - start).count();
    std::cout << "DFS + 记忆化解法耗时: " << duration << " ms, 结果: " << result1 << std::endl;
}

int main() {
    Solution solution;
    
    // 测试用例1
    std::vector<std::vector<int>> matrix1 = {
        {9, 9, 4},
        {6, 6, 8},
        {2, 1, 1}
    };
    std::cout << "测试用例1：" << std::endl;
    printMatrix(matrix1);
    std::cout << "结果: " << solution.longestIncreasingPath(matrix1) << "，预期: 4" << std::endl;
    std::cout << std::endl;
    
    // 测试用例2
    std::vector<std::vector<int>> matrix2 = {
        {3, 4, 5},
        {3, 2, 6},
        {2, 2, 1}
    };
    std::cout << "测试用例2：" << std::endl;
    printMatrix(matrix2);
    std::cout << "结果: " << solution.longestIncreasingPath(matrix2) << "，预期: 4" << std::endl;
    std::cout << std::endl;
    
    // 测试用例3：边界情况
    std::vector<std::vector<int>> matrix3 = {{1}};
    std::cout << "测试用例3：" << std::endl;
    printMatrix(matrix3);
    std::cout << "结果: " << solution.longestIncreasingPath(matrix3) << "，预期: 1" << std::endl;
    
    // 运行所有解法的对比测试
    runAllSolutionsTest(matrix1);
    runAllSolutionsTest(matrix2);
    runAllSolutionsTest(matrix3);
    
    // 性能测试
    std::cout << "性能测试:" << std::endl;
    std::cout << "----------------------------------------" << std::endl;
    performanceTest(50);
    performanceTest(100);
    
    // 特殊测试用例：完全相同的元素
    std::cout << "\n特殊测试用例：完全相同的元素" << std::endl;
    std::vector<std::vector<int>> matrixSame = {
        {5, 5, 5},
        {5, 5, 5},
        {5, 5, 5}
    };
    printMatrix(matrixSame);
    std::cout << "结果: " << solution.longestIncreasingPath(matrixSame) << std::endl;
    
    // 特殊测试用例：严格递增的矩阵
    std::cout << "\n特殊测试用例：严格递增的矩阵" << std::endl;
    std::vector<std::vector<int>> matrixIncreasing = {
        {1, 2, 3},
        {4, 5, 6},
        {7, 8, 9}
    };
    printMatrix(matrixIncreasing);
    std::cout << "结果: " << solution.longestIncreasingPath(matrixIncreasing) << std::endl;
    
    return 0;
}

===============================================

文件: Code12_LongestIncreasingPathMatrix.java
===============================================
package class072;

import java.util.Arrays;
import java.util.HashMap;
import java.util.Map;

/**
 * 矩阵中的最长递增路径 - LeetCode 329
 * 题目来源：https://leetcode.cn/problems/longest-increasing-path-in-a-matrix/
 * 难度：困难
 * 题目描述：给定一个 m x n 的整数矩阵 matrix ，找出其中最长递增路径的长度。
 * 对于每个单元格，你可以往上，下，左，右四个方向移动。 你不能在对角线方向上移动或移动到边界外（即不允许环绕）。
 * 
 * 核心思路：
 * 1. 这道题是LIS问题的二维变体，我们需要在矩阵中寻找最长的递增路径
 * 2. 使用深度优先搜索(DFS) + 记忆化搜索(Memoization)来避免重复计算
 * 3. 对于每个单元格，我们从四个方向进行探索，只考虑值严格大于当前单元格的相邻单元格
 * 4. 用一个dp数组存储每个单元格的最长递增路径长度，避免重复计算
 * 
 * 复杂度分析：
 * 时间复杂度：O(m*n)，其中m和n分别是矩阵的行数和列数。每个单元格只会被访问一次
 * 空间复杂度：O(m*n)，用于存储dp数组
 */
public class Code12_LongestIncreasingPathMatrix {

    // 定义四个方向的移动：上、右、下、左
    private static final int[][] DIRECTIONS = {{-1, 0}, {0, 1}, {1, 0}, {0, -1}};
    private int rows;  // 矩阵行数
    private int cols;  // 矩阵列数
    private int[][] matrix;  // 输入矩阵
    private int[][] dp;  // 记忆化搜索数组，dp[i][j]表示以(i,j)为起点的最长递增路径长度

    /**
     * 主方法，用于测试
     */
    public static void main(String[] args) {
        // 测试用例1
        int[][] matrix1 = {
            {9, 9, 4},
            {6, 6, 8},
            {2, 1, 1}
        };
        System.out.println("测试用例1：");
        printMatrix(matrix1);
        System.out.println("结果: " + longestIncreasingPath(matrix1) + "，预期: 4");
        System.out.println();
        
        // 测试用例2
        int[][] matrix2 = {
            {3, 4, 5},
            {3, 2, 6},
            {2, 2, 1}
        };
        System.out.println("测试用例2：");
        printMatrix(matrix2);
        System.out.println("结果: " + longestIncreasingPath(matrix2) + "，预期: 4");
        System.out.println();
        
        // 测试用例3：边界情况
        int[][] matrix3 = {{1}};
        System.out.println("测试用例3：");
        printMatrix(matrix3);
        System.out.println("结果: " + longestIncreasingPath(matrix3) + "，预期: 1");
        
        // 运行所有解法的对比测试
        runAllSolutionsTest(matrix1);
        runAllSolutionsTest(matrix2);
        runAllSolutionsTest(matrix3);
    }
    
    /**
     * 辅助方法：打印矩阵
     */
    private static void printMatrix(int[][] matrix) {
        for (int[] row : matrix) {
            System.out.println(Arrays.toString(row));
        }
    }
    
    /**
     * 最优解法：深度优先搜索 + 记忆化搜索
     * @param matrix 输入矩阵
     * @return 最长递增路径的长度
     */
    public static int longestIncreasingPath(int[][] matrix) {
        if (matrix == null || matrix.length == 0 || matrix[0].length == 0) {
            return 0;
        }
        
        int rows = matrix.length;
        int cols = matrix[0].length;
        int[][] dp = new int[rows][cols];  // dp[i][j]表示以(i,j)为起点的最长递增路径长度
        int maxLength = 0;
        
        // 遍历每个单元格，寻找最长路径
        for (int i = 0; i < rows; i++) {
            for (int j = 0; j < cols; j++) {
                maxLength = Math.max(maxLength, dfs(matrix, dp, i, j));
            }
        }
        
        return maxLength;
    }
    
    /**
     * 深度优先搜索函数，计算从(i,j)出发的最长递增路径长度
     * @param matrix 输入矩阵
     * @param dp 记忆化搜索数组
     * @param i 当前行索引
     * @param j 当前列索引
     * @return 从(i,j)出发的最长递增路径长度
     */
    private static int dfs(int[][] matrix, int[][] dp, int i, int j) {
        // 如果已经计算过以(i,j)为起点的最长路径长度，直接返回
        if (dp[i][j] != 0) {
            return dp[i][j];
        }
        
        int maxLength = 1;  // 路径至少包含当前单元格，长度为1
        int rows = matrix.length;
        int cols = matrix[0].length;
        
        // 探索四个方向
        for (int[] dir : DIRECTIONS) {
            int ni = i + dir[0];
            int nj = j + dir[1];
            
            // 检查新位置是否有效，且值严格大于当前位置
            if (ni >= 0 && ni < rows && nj >= 0 && nj < cols && matrix[ni][nj] > matrix[i][j]) {
                // 递归计算从新位置出发的最长路径长度，并更新当前位置的最长路径长度
                int length = 1 + dfs(matrix, dp, ni, nj);
                maxLength = Math.max(maxLength, length);
            }
        }
        
        // 记忆化结果
        dp[i][j] = maxLength;
        return maxLength;
    }
    
    /**
     * 另一种实现方式：使用类成员变量
     * @param matrix 输入矩阵
     * @return 最长递增路径的长度
     */
    public int longestIncreasingPathAlternative(int[][] matrix) {
        if (matrix == null || matrix.length == 0 || matrix[0].length == 0) {
            return 0;
        }
        
        this.rows = matrix.length;
        this.cols = matrix[0].length;
        this.matrix = matrix;
        this.dp = new int[rows][cols];
        
        int maxLength = 0;
        
        for (int i = 0; i < rows; i++) {
            for (int j = 0; j < cols; j++) {
                maxLength = Math.max(maxLength, dfsAlternative(i, j));
            }
        }
        
        return maxLength;
    }
    
    /**
     * 深度优先搜索函数（类成员变量版本）
     */
    private int dfsAlternative(int i, int j) {
        if (dp[i][j] != 0) {
            return dp[i][j];
        }
        
        int maxLength = 1;
        
        for (int[] dir : DIRECTIONS) {
            int ni = i + dir[0];
            int nj = j + dir[1];
            
            if (ni >= 0 && ni < rows && nj >= 0 && nj < cols && matrix[ni][nj] > matrix[i][j]) {
                int length = 1 + dfsAlternative(ni, nj);
                maxLength = Math.max(maxLength, length);
            }
        }
        
        dp[i][j] = maxLength;
        return maxLength;
    }
    
    /**
     * 解释性更强的版本，添加了更多注释和中间变量
     * @param matrix 输入矩阵
     * @return 最长递增路径的长度
     */
    public static int longestIncreasingPathExplained(int[][] matrix) {
        if (matrix == null || matrix.length == 0 || matrix[0].length == 0) {
            return 0;
        }
        
        int rows = matrix.length;
        int cols = matrix[0].length;
        // 创建记忆化数组，存储每个单元格的最长递增路径长度
        int[][] memo = new int[rows][cols];
        int longestPath = 0;
        
        // 对每个单元格进行DFS搜索
        for (int i = 0; i < rows; i++) {
            for (int j = 0; j < cols; j++) {
                // 计算从当前单元格出发的最长递增路径
                int currentPathLength = dfsExplained(matrix, memo, i, j, rows, cols);
                // 更新全局最长路径
                longestPath = Math.max(longestPath, currentPathLength);
            }
        }
        
        return longestPath;
    }
    
    /**
     * 带详细注释的深度优先搜索函数
     */
    private static int dfsExplained(int[][] matrix, int[][] memo, int row, int col, int rows, int cols) {
        // 检查记忆化数组，如果已经计算过则直接返回
        if (memo[row][col] > 0) {
            return memo[row][col];
        }
        
        // 初始化为1，因为路径至少包含当前单元格
        int maxPathFromHere = 1;
        
        // 定义四个方向的偏移量：上、右、下、左
        int[][] directions = {{-1, 0}, {0, 1}, {1, 0}, {0, -1}};
        
        // 遍历所有可能的移动方向
        for (int[] direction : directions) {
            // 计算新位置的坐标
            int newRow = row + direction[0];
            int newCol = col + direction[1];
            
            // 检查新位置是否有效：
            // 1. 不超出矩阵边界
            // 2. 新位置的值严格大于当前位置（保持递增）
            boolean isValidMove = (newRow >= 0 && newRow < rows && 
                                  newCol >= 0 && newCol < cols && 
                                  matrix[newRow][newCol] > matrix[row][col]);
            
            if (isValidMove) {
                // 递归计算从新位置出发的最长路径长度
                // 加上1是因为当前位置也要算在路径中
                int pathLength = 1 + dfsExplained(matrix, memo, newRow, newCol, rows, cols);
                // 更新最大值
                maxPathFromHere = Math.max(maxPathFromHere, pathLength);
            }
        }
        
        // 记忆化结果，避免重复计算
        memo[row][col] = maxPathFromHere;
        return maxPathFromHere;
    }
    
    /**
     * 运行所有解法的对比测试
     * @param matrix 输入矩阵
     */
    public static void runAllSolutionsTest(int[][] matrix) {
        System.out.println("\n对比测试：");
        printMatrix(matrix);
        
        // 测试DFS + 记忆化解法
        long startTime = System.nanoTime();
        int result1 = longestIncreasingPath(matrix);
        long endTime = System.nanoTime();
        System.out.println("DFS + 记忆化解法结果: " + result1);
        System.out.println("耗时: " + (endTime - startTime) / 1000 + " μs");
        
        // 测试类成员变量版本
        Code12_LongestIncreasingPathMatrix solution = new Code12_LongestIncreasingPathMatrix();
        startTime = System.nanoTime();
        int result2 = solution.longestIncreasingPathAlternative(matrix);
        endTime = System.nanoTime();
        System.out.println("类成员变量版本结果: " + result2);
        System.out.println("耗时: " + (endTime - startTime) / 1000 + " μs");
        
        // 测试解释性版本
        startTime = System.nanoTime();
        int result3 = longestIncreasingPathExplained(matrix);
        endTime = System.nanoTime();
        System.out.println("解释性版本结果: " + result3);
        System.out.println("耗时: " + (endTime - startTime) / 1000 + " μs");
        
        System.out.println("----------------------------------------");
    }
    
    /**
     * 性能测试函数
     * @param size 矩阵大小 (size x size)
     */
    public static void performanceTest(int size) {
        // 生成随机测试数据
        int[][] matrix = new int[size][size];
        for (int i = 0; i < size; i++) {
            for (int j = 0; j < size; j++) {
                matrix[i][j] = (int)(Math.random() * 1000);
            }
        }
        
        System.out.println("\n性能测试：矩阵大小 = " + size + "x" + size);
        
        // 测试DFS + 记忆化解法
        long startTime = System.nanoTime();
        int result1 = longestIncreasingPath(matrix);
        long endTime = System.nanoTime();
        System.out.println("DFS + 记忆化解法耗时: " + (endTime - startTime) / 1_000_000 + " ms, 结果: " + result1);
    }
}

===============================================

文件: Code12_LongestIncreasingPathMatrix.py
===============================================
#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
矩阵中的最长递增路径 - LeetCode 329
题目来源：https://leetcode.cn/problems/longest-increasing-path-in-a-matrix/
难度：困难
题目描述：给定一个 m x n 的整数矩阵 matrix ，找出其中最长递增路径的长度。
对于每个单元格，你可以往上，下，左，右四个方向移动。 你不能在对角线方向上移动或移动到边界外（即不允许环绕）。

核心思路：
1. 这道题是LIS问题的二维变体，我们需要在矩阵中寻找最长的递增路径
2. 使用深度优先搜索(DFS) + 记忆化搜索(Memoization)来避免重复计算
3. 对于每个单元格，我们从四个方向进行探索，只考虑值严格大于当前单元格的相邻单元格
4. 用一个dp数组存储每个单元格的最长递增路径长度，避免重复计算

复杂度分析：
时间复杂度：O(m*n)，其中m和n分别是矩阵的行数和列数。每个单元格只会被访问一次
空间复杂度：O(m*n)，用于存储dp数组
"""

from typing import List
import time
import random


def longestIncreasingPath(matrix: List[List[int]]) -> int:
    """
    最优解法：深度优先搜索 + 记忆化搜索
    
    参数:
        matrix: 输入矩阵
    返回:
        最长递增路径的长度
    """
    # 边界情况处理
    if not matrix or not matrix[0]:
        return 0
    
    rows = len(matrix)
    cols = len(matrix[0])
    # dp[i][j]表示以(i,j)为起点的最长递增路径长度
    dp = [[0 for _ in range(cols)] for _ in range(rows)]
    max_length = 0
    
    # 定义四个方向的移动：上、右、下、左
    directions = [(-1, 0), (0, 1), (1, 0), (0, -1)]
    
    def dfs(i: int, j: int) -> int:
        """
        深度优先搜索函数，计算从(i,j)出发的最长递增路径长度
        
        参数:
            i: 当前行索引
            j: 当前列索引
        返回:
            从(i,j)出发的最长递增路径长度
        """
        # 如果已经计算过以(i,j)为起点的最长路径长度，直接返回
        if dp[i][j] != 0:
            return dp[i][j]
        
        max_length = 1  # 路径至少包含当前单元格，长度为1
        
        # 探索四个方向
        for di, dj in directions:
            ni, nj = i + di, j + dj
            
            # 检查新位置是否有效，且值严格大于当前位置
            if (0 <= ni < rows and 0 <= nj < cols and matrix[ni][nj] > matrix[i][j]):
                # 递归计算从新位置出发的最长路径长度，并更新当前位置的最长路径长度
                length = 1 + dfs(ni, nj)
                max_length = max(max_length, length)
        
        # 记忆化结果
        dp[i][j] = max_length
        return max_length
    
    # 遍历每个单元格，寻找最长路径
    for i in range(rows):
        for j in range(cols):
            max_length = max(max_length, dfs(i, j))
    
    return max_length


def longestIncreasingPathAlternative(matrix: List[List[int]]) -> int:
    """
    另一种实现方式：使用lru_cache进行记忆化（仅在Python中可用）
    注意：为了使用lru_cache，我们需要将矩阵转换为元组或者在函数外部访问
    
    参数:
        matrix: 输入矩阵
    返回:
        最长递增路径的长度
    """
    if not matrix or not matrix[0]:
        return 0
    
    rows, cols = len(matrix), len(matrix[0])
    # 转换为全局变量以便在内部函数中使用
    global_matrix = matrix
    
    # 定义四个方向
    directions = [(-1, 0), (0, 1), (1, 0), (0, -1)]
    
    # 使用记忆化搜索
    memo = {}  # (i,j) -> 最长路径长度
    
    def dfs(i: int, j: int) -> int:
        """
        带记忆化的深度优先搜索函数
        """
        if (i, j) in memo:
            return memo[(i, j)]
        
        max_len = 1
        
        for di, dj in directions:
            ni, nj = i + di, j + dj
            if (0 <= ni < rows and 0 <= nj < cols and 
                global_matrix[ni][nj] > global_matrix[i][j]):
                max_len = max(max_len, 1 + dfs(ni, nj))
        
        memo[(i, j)] = max_len
        return max_len
    
    result = 0
    for i in range(rows):
        for j in range(cols):
            result = max(result, dfs(i, j))
    
    return result


def longestIncreasingPathExplained(matrix: List[List[int]]) -> int:
    """
    解释性更强的版本，添加了更详细的注释和中间变量
    
    参数:
        matrix: 输入矩阵
    返回:
        最长递增路径的长度
    """
    # 边界条件检查
    if not matrix or not matrix[0]:
        return 0
    
    # 获取矩阵的维度
    rows, cols = len(matrix), len(matrix[0])
    
    # 创建记忆化数组
    # memo[i][j]表示从位置(i,j)出发能够得到的最长递增路径长度
    memo = [[0 for _ in range(cols)] for _ in range(rows)]
    
    # 定义四个可能的移动方向：上、右、下、左
    directions = [(-1, 0), (0, 1), (1, 0), (0, -1)]
    
    def depth_first_search(row: int, col: int) -> int:
        """
        对特定位置进行深度优先搜索，找出从该位置出发的最长递增路径
        
        参数:
            row: 当前行索引
            col: 当前列索引
        返回:
            从该位置出发的最长递增路径长度
        """
        # 如果该位置已经计算过，直接返回存储的值
        if memo[row][col] > 0:
            return memo[row][col]
        
        # 初始路径长度为1（只有当前单元格自身）
        max_path_length = 1
        
        # 尝试从当前位置向四个方向移动
        for direction in directions:
            # 计算新位置的坐标
            new_row = row + direction[0]
            new_col = col + direction[1]
            
            # 检查新位置是否有效：
            # 1. 不超出矩阵边界
            # 2. 新位置的值必须严格大于当前位置的值（保持递增）
            is_valid_move = (0 <= new_row < rows and 
                           0 <= new_col < cols and 
                           matrix[new_row][new_col] > matrix[row][col])
            
            if is_valid_move:
                # 递归计算从新位置出发的最长路径长度
                # 并将结果加1（包含当前位置）
                path_length = 1 + depth_first_search(new_row, new_col)
                # 更新最长路径长度
                max_path_length = max(max_path_length, path_length)
        
        # 将结果存储在记忆化数组中，避免重复计算
        memo[row][col] = max_path_length
        return max_path_length
    
    # 对矩阵中的每个单元格进行搜索，找出全局最长递增路径
    longest_path = 0
    for i in range(rows):
        for j in range(cols):
            current_longest = depth_first_search(i, j)
            longest_path = max(longest_path, current_longest)
    
    return longest_path


def printMatrix(matrix: List[List[int]]):
    """
    打印矩阵
    
    参数:
        matrix: 要打印的矩阵
    """
    for row in matrix:
        print(row)


def runAllSolutionsTest(matrix: List[List[int]]):
    """
    运行所有解法的对比测试
    
    参数:
        matrix: 输入矩阵
    """
    print(f"\n对比测试：")
    printMatrix(matrix)
    
    # 测试DFS + 记忆化解法
    start_time = time.time()
    result1 = longestIncreasingPath(matrix)
    end_time = time.time()
    print(f"DFS + 记忆化解法结果: {result1}")
    print(f"耗时: {(end_time - start_time) * 1_000_000:.2f} μs")
    
    # 测试另一种实现方式
    start_time = time.time()
    result2 = longestIncreasingPathAlternative(matrix)
    end_time = time.time()
    print(f"另一种实现方式结果: {result2}")
    print(f"耗时: {(end_time - start_time) * 1_000_000:.2f} μs")
    
    # 测试解释性版本
    start_time = time.time()
    result3 = longestIncreasingPathExplained(matrix)
    end_time = time.time()
    print(f"解释性版本结果: {result3}")
    print(f"耗时: {(end_time - start_time) * 1_000_000:.2f} μs")
    
    print("-" * 40)


def performanceTest(size: int):
    """
    性能测试函数
    
    参数:
        size: 矩阵大小 (size x size)
    """
    # 生成随机测试数据
    matrix = [[random.randint(0, 1000) for _ in range(size)] for _ in range(size)]
    
    print(f"\n性能测试：矩阵大小 = {size}x{size}")
    
    # 测试DFS + 记忆化解法
    start_time = time.time()
    result1 = longestIncreasingPath(matrix)
    end_time = time.time()
    print(f"DFS + 记忆化解法耗时: {(end_time - start_time) * 1000:.3f} ms, 结果: {result1}")


def testCase():
    """
    测试用例
    """
    # 测试用例1
    matrix1 = [
        [9, 9, 4],
        [6, 6, 8],
        [2, 1, 1]
    ]
    print("测试用例1：")
    printMatrix(matrix1)
    print(f"结果: {longestIncreasingPath(matrix1)}，预期: 4")
    print()
    
    # 测试用例2
    matrix2 = [
        [3, 4, 5],
        [3, 2, 6],
        [2, 2, 1]
    ]
    print("测试用例2：")
    printMatrix(matrix2)
    print(f"结果: {longestIncreasingPath(matrix2)}，预期: 4")
    print()
    
    # 测试用例3：边界情况
    matrix3 = [[1]]
    print("测试用例3：")
    printMatrix(matrix3)
    print(f"结果: {longestIncreasingPath(matrix3)}，预期: 1")
    
    # 运行所有解法的对比测试
    runAllSolutionsTest(matrix1)
    runAllSolutionsTest(matrix2)
    runAllSolutionsTest(matrix3)
    
    # 性能测试
    print("性能测试:")
    print("-" * 40)
    performanceTest(50)
    performanceTest(100)
    
    # 特殊测试用例：完全相同的元素
    print("\n特殊测试用例：完全相同的元素")
    matrixSame = [
        [5, 5, 5],
        [5, 5, 5],
        [5, 5, 5]
    ]
    printMatrix(matrixSame)
    print(f"结果: {longestIncreasingPath(matrixSame)}")
    
    # 特殊测试用例：严格递增的矩阵
    print("\n特殊测试用例：严格递增的矩阵")
    matrixIncreasing = [
        [1, 2, 3],
        [4, 5, 6],
        [7, 8, 9]
    ]
    printMatrix(matrixIncreasing)
    print(f"结果: {longestIncreasingPath(matrixIncreasing)}")


if __name__ == "__main__":
    """
    主函数入口
    """
    testCase()

===============================================

文件: Code13_LongestIncreasingSubsequenceIV.cpp
===============================================
#include <iostream>
#include <vector>
#include <algorithm>
#include <unordered_map>
#include <chrono>

/**
 * 最长递增子序列 IV - LeetCode 2407
 * 题目来源：https://leetcode.cn/problems/longest-increasing-subsequence-iv/
 * 难度：困难
 * 题目描述：给你一个整数数组 nums 和一个整数 k 。找到最长子序列的长度，满足子序列中的每个元素 严格递增 ，且子序列中相邻元素的差的绝对值 至少 为 k 。
 * 子序列 是指从原数组中删除一些元素（可能一个也不删除）后，剩余元素保持原来顺序而形成的新数组。
 * 
 * 核心思路：
 * 1. 这道题是LIS问题的一个变体，增加了相邻元素差的绝对值至少为k的约束
 * 2. 使用动态规划 + 线段树优化来解决这个问题
 * 3. 对于每个元素nums[i]，我们需要找到所有满足nums[j] < nums[i]且nums[i] - nums[j] >= k的j，然后dp[i] = max(dp[j]) + 1
 * 4. 使用线段树来高效查询区间内的最大值
 * 
 * 复杂度分析：
 * 时间复杂度：O(n log n)，其中n是数组长度。离散化需要O(n log n)，构建线段树需要O(n)，每次查询和更新需要O(log n)，总共有n次查询和更新
 * 空间复杂度：O(n)，用于存储离散化后的值、dp数组和线段树
 */

class Solution {
private:
    /**
     * 线段树节点类
     */
    struct SegmentTreeNode {
        int start, end;
        int max;
        SegmentTreeNode* left;
        SegmentTreeNode* right;
        
        SegmentTreeNode(int start, int end) : start(start), end(end), max(0), left(nullptr), right(nullptr) {}
        
        ~SegmentTreeNode() {
            delete left;
            delete right;
        }
    };
    
    /**
     * 构建线段树
     */
    SegmentTreeNode* buildSegmentTree(int start, int end) {
        SegmentTreeNode* node = new SegmentTreeNode(start, end);
        if (start == end) {
            return node;
        }
        
        int mid = start + (end - start) / 2;
        node->left = buildSegmentTree(start, mid);
        node->right = buildSegmentTree(mid + 1, end);
        
        return node;
    }
    
    /**
     * 查询区间内的最大值
     */
    int queryMax(SegmentTreeNode* node, int start, int end) {
        if (start > node->end || end < node->start) {
            return 0;
        }
        
        if (start <= node->start && end >= node->end) {
            return node->max;
        }
        
        int leftMax = queryMax(node->left, start, end);
        int rightMax = queryMax(node->right, start, end);
        
        return std::max(leftMax, rightMax);
    }
    
    /**
     * 更新线段树中的值
     */
    void updateSegmentTree(SegmentTreeNode* node, int index, int value) {
        if (node->start == node->end && node->start == index) {
            node->max = std::max(node->max, value);
            return;
        }
        
        int mid = node->start + (node->end - node->start) / 2;
        if (index <= mid) {
            updateSegmentTree(node->left, index, value);
        } else {
            updateSegmentTree(node->right, index, value);
        }
        
        node->max = std::max(node->left->max, node->right->max);
    }
    
    /**
     * 数组实现的线段树查询方法
     */
    int queryMax(const std::vector<int>& tree, int node, int start, int end, int l, int r) {
        if (r < start || end < l) {
            return 0;
        }
        if (l <= start && end <= r) {
            return tree[node];
        }
        int mid = start + (end - start) / 2;
        int leftMax = queryMax(tree, 2 * node + 1, start, mid, l, r);
        int rightMax = queryMax(tree, 2 * node + 2, mid + 1, end, l, r);
        return std::max(leftMax, rightMax);
    }
    
    /**
     * 数组实现的线段树更新方法
     */
    void updateSegmentTree(std::vector<int>& tree, int node, int start, int end, int idx, int val) {
        if (start == end) {
            tree[node] = std::max(tree[node], val);
        } else {
            int mid = start + (end - start) / 2;
            if (idx <= mid) {
                updateSegmentTree(tree, 2 * node + 1, start, mid, idx, val);
            } else {
                updateSegmentTree(tree, 2 * node + 2, mid + 1, end, idx, val);
            }
            tree[node] = std::max(tree[2 * node + 1], tree[2 * node + 2]);
        }
    }

public:
    /**
     * 最优解法：动态规划 + 线段树优化
     * @param nums 输入数组
     * @param k 相邻元素差的最小绝对值
     * @return 满足条件的最长递增子序列的长度
     */
    int lengthOfLIS(const std::vector<int>& nums, int k) {
        // 离散化处理
        std::vector<int> sortedNums(nums);
        std::sort(sortedNums.begin(), sortedNums.end());
        
        // 创建映射，将原始值映射到离散化后的值
        std::unordered_map<int, int> valueToIndex;
        int index = 1; // 从1开始，便于线段树处理
        for (int num : sortedNums) {
            if (valueToIndex.find(num) == valueToIndex.end()) {
                valueToIndex[num] = index++;
            }
        }
        
        int n = valueToIndex.size();
        SegmentTreeNode* root = buildSegmentTree(1, n);
        
        int maxLength = 0;
        for (int num : nums) {
            // 找到所有小于num且num - value >= k的元素的最大长度
            // 即找到所有value <= num - k的元素
            int target = num - k;
            // 找到最大的不大于target的值
            int left = 0;
            int right = sortedNums.size() - 1;
            int best = -1;
            while (left <= right) {
                int mid = left + (right - left) / 2;
                if (sortedNums[mid] <= target) {
                    best = mid;
                    left = mid + 1;
                } else {
                    right = mid - 1;
                }
            }
            
            int currentLength = 1;
            if (best != -1) {
                int queryEnd = valueToIndex[sortedNums[best]];
                currentLength = queryMax(root, 1, queryEnd) + 1;
            }
            
            // 更新线段树
            int numIndex = valueToIndex[num];
            updateSegmentTree(root, numIndex, currentLength);
            
            maxLength = std::max(maxLength, currentLength);
        }
        
        // 释放内存
        delete root;
        
        return maxLength;
    }
    
    /**
     * 另一种实现方式：使用数组实现线段树
     * @param nums 输入数组
     * @param k 相邻元素差的最小绝对值
     * @return 满足条件的最长递增子序列的长度
     */
    int lengthOfLISAlternative(const std::vector<int>& nums, int k) {
        // 离散化处理
        std::vector<int> sortedNums(nums);
        std::sort(sortedNums.begin(), sortedNums.end());
        
        // 创建映射，将原始值映射到离散化后的值
        std::unordered_map<int, int> valueToIndex;
        int index = 1;
        for (int num : sortedNums) {
            if (valueToIndex.find(num) == valueToIndex.end()) {
                valueToIndex[num] = index++;
            }
        }
        
        int n = valueToIndex.size();
        // 使用数组模拟线段树
        std::vector<int> segmentTree(4 * n, 0);
        
        int maxLength = 0;
        for (int num : nums) {
            int target = num - k;
            // 找到最大的不大于target的值
            int left = 0;
            int right = sortedNums.size() - 1;
            int best = -1;
            while (left <= right) {
                int mid = left + (right - left) / 2;
                if (sortedNums[mid] <= target) {
                    best = mid;
                    left = mid + 1;
                } else {
                    right = mid - 1;
                }
            }
            
            int currentLength = 1;
            if (best != -1) {
                int queryEnd = valueToIndex[sortedNums[best]];
                currentLength = queryMax(segmentTree, 0, 1, n, 1, queryEnd) + 1;
            }
            
            // 更新线段树
            int numIndex = valueToIndex[num];
            updateSegmentTree(segmentTree, 0, 1, n, numIndex, currentLength);
            
            maxLength = std::max(maxLength, currentLength);
        }
        
        return maxLength;
    }
    
    /**
     * 解释性更强的版本，添加了更多注释和中间变量
     * @param nums 输入数组
     * @param k 相邻元素差的最小绝对值
     * @return 满足条件的最长递增子序列的长度
     */
    int lengthOfLISExplained(const std::vector<int>& nums, int k) {
        // 步骤1: 离散化处理
        // 由于数组中的值可能很大，我们需要对其进行离散化，以便使用线段树
        std::vector<int> sortedNums(nums);
        std::sort(sortedNums.begin(), sortedNums.end());
        
        // 创建值到索引的映射，将原始值映射到较小的范围内
        std::unordered_map<int, int> valueToIndex;
        int index = 1; // 从1开始，便于线段树处理
        for (int num : sortedNums) {
            if (valueToIndex.find(num) == valueToIndex.end()) {
                valueToIndex[num] = index++;
            }
        }
        
        // 步骤2: 初始化线段树
        int n = valueToIndex.size();
        SegmentTreeNode* root = buildSegmentTree(1, n);
        
        // 步骤3: 动态规划 + 线段树优化
        int maxLength = 0; // 用于保存最长子序列的长度
        
        for (int num : nums) {
            // 对于每个元素num，我们需要找到所有满足nums[j] < num且num - nums[j] >= k的j
            // 即nums[j] <= num - k
            int target = num - k;
            
            // 二分查找找到最大的不大于target的值
            int left = 0;
            int right = sortedNums.size() - 1;
            int best = -1; // 记录找到的索引
            
            while (left <= right) {
                int mid = left + (right - left) / 2;
                if (sortedNums[mid] <= target) {
                    best = mid; // 找到一个可能的候选
                    left = mid + 1; // 继续向右查找更大的符合条件的值
                } else {
                    right = mid - 1; // 向左查找
                }
            }
            
            // 计算以当前元素结尾的最长递增子序列长度
            int currentLength = 1; // 至少包含当前元素
            if (best != -1) { // 如果找到了符合条件的元素
                int queryEnd = valueToIndex[sortedNums[best]];
                // 查询区间[1, queryEnd]内的最大值，并加1
                currentLength = queryMax(root, 1, queryEnd) + 1;
            }
            
            // 更新线段树中当前值的位置
            int numIndex = valueToIndex[num];
            updateSegmentTree(root, numIndex, currentLength);
            
            // 更新全局最长子序列长度
            maxLength = std::max(maxLength, currentLength);
        }
        
        // 释放内存
        delete root;
        
        return maxLength;
    }
};

// 辅助函数：打印数组
void printArray(const std::vector<int>& nums) {
    std::cout << "[";
    for (size_t i = 0; i < nums.size(); ++i) {
        std::cout << nums[i];
        if (i < nums.size() - 1) {
            std::cout << ", ";
        }
    }
    std::cout << "]" << std::endl;
}

// 运行所有解法的对比测试
void runAllSolutionsTest(Solution& solution, const std::vector<int>& nums, int k) {
    std::cout << "\n对比测试：" << std::endl;
    std::cout << "数组: ";
    printArray(nums);
    std::cout << "k: " << k << std::endl;
    
    // 测试线段树节点实现
    auto start = std::chrono::high_resolution_clock::now();
    int result1 = solution.lengthOfLIS(nums, k);
    auto end = std::chrono::high_resolution_clock::now();
    auto duration = std::chrono::duration_cast<std::chrono::microseconds>(end - start).count();
    std::cout << "线段树节点实现结果: " << result1 << std::endl;
    std::cout << "耗时: " << duration << " μs" << std::endl;
    
    // 测试数组实现的线段树
    start = std::chrono::high_resolution_clock::now();
    int result2 = solution.lengthOfLISAlternative(nums, k);
    end = std::chrono::high_resolution_clock::now();
    duration = std::chrono::duration_cast<std::chrono::microseconds>(end - start).count();
    std::cout << "数组实现线段树结果: " << result2 << std::endl;
    std::cout << "耗时: " << duration << " μs" << std::endl;
    
    // 测试解释性版本
    start = std::chrono::high_resolution_clock::now();
    int result3 = solution.lengthOfLISExplained(nums, k);
    end = std::chrono::high_resolution_clock::now();
    duration = std::chrono::duration_cast<std::chrono::microseconds>(end - start).count();
    std::cout << "解释性版本结果: " << result3 << std::endl;
    std::cout << "耗时: " << duration << " μs" << std::endl;
    
    std::cout << "----------------------------------------" << std::endl;
}

// 性能测试函数
void performanceTest(Solution& solution, int size) {
    // 生成随机测试数据
    std::vector<int> nums(size);
    for (int i = 0; i < size; i++) {
        nums[i] = rand() % 10000;
    }
    int k = rand() % 100;
    
    std::cout << "\n性能测试：数组大小 = " << size << std::endl;
    
    // 测试线段树节点实现
    auto start = std::chrono::high_resolution_clock::now();
    int result1 = solution.lengthOfLIS(nums, k);
    auto end = std::chrono::high_resolution_clock::now();
    auto duration = std::chrono::duration_cast<std::chrono::milliseconds>(end - start).count();
    std::cout << "线段树节点实现耗时: " << duration << " ms, 结果: " << result1 << std::endl;
}

int main() {
    Solution solution;
    
    // 测试用例1
    std::vector<int> nums1 = {4, 2, 1, 4, 3, 4, 5, 8, 15};
    int k1 = 3;
    std::cout << "测试用例1：" << std::endl;
    std::cout << "数组: ";
    printArray(nums1);
    std::cout << "k: " << k1 << std::endl;
    std::cout << "结果: " << solution.lengthOfLIS(nums1, k1) << "，预期: 5" << std::endl;
    std::cout << std::endl;
    
    // 测试用例2
    std::vector<int> nums2 = {7, 4, 5, 1, 8, 12, 4, 7};
    int k2 = 5;
    std::cout << "测试用例2：" << std::endl;
    std::cout << "数组: ";
    printArray(nums2);
    std::cout << "k: " << k2 << std::endl;
    std::cout << "结果: " << solution.lengthOfLIS(nums2, k2) << "，预期: 3" << std::endl;
    std::cout << std::endl;
    
    // 测试用例3：边界情况
    std::vector<int> nums3 = {1};
    int k3 = 1;
    std::cout << "测试用例3：" << std::endl;
    std::cout << "数组: ";
    printArray(nums3);
    std::cout << "k: " << k3 << std::endl;
    std::cout << "结果: " << solution.lengthOfLIS(nums3, k3) << "，预期: 1" << std::endl;
    
    // 运行所有解法的对比测试
    runAllSolutionsTest(solution, nums1, k1);
    runAllSolutionsTest(solution, nums2, k2);
    runAllSolutionsTest(solution, nums3, k3);
    
    // 性能测试
    std::cout << "性能测试:" << std::endl;
    std::cout << "----------------------------------------" << std::endl;
    performanceTest(solution, 1000);
    performanceTest(solution, 5000);
    
    // 特殊测试用例：严格递增序列，且相邻差大于等于k
    std::cout << "\n特殊测试用例：严格递增序列，且相邻差大于等于k" << std::endl;
    std::vector<int> numsIncreasing = {1, 4, 7, 10, 13};
    int kIncreasing = 3;
    std::cout << "数组: ";
    printArray(numsIncreasing);
    std::cout << "k: " << kIncreasing << std::endl;
    std::cout << "结果: " << solution.lengthOfLIS(numsIncreasing, kIncreasing) << std::endl;
    
    // 特殊测试用例：所有元素相同
    std::cout << "\n特殊测试用例：所有元素相同" << std::endl;
    std::vector<int> numsSame = {5, 5, 5, 5, 5};
    int kSame = 1;
    std::cout << "数组: ";
    printArray(numsSame);
    std::cout << "k: " << kSame << std::endl;
    std::cout << "结果: " << solution.lengthOfLIS(numsSame, kSame) << std::endl;
    
    return 0;
}

===============================================

文件: Code13_LongestIncreasingSubsequenceIV.java
===============================================
package class072;

import java.util.Arrays;
import java.util.HashMap;
import java.util.Map;

/**
 * 最长递增子序列 IV - LeetCode 2407
 * 题目来源：https://leetcode.cn/problems/longest-increasing-subsequence-iv/
 * 难度：困难
 * 题目描述：给你一个整数数组 nums 和一个整数 k 。找到最长子序列的长度，满足子序列中的每个元素 严格递增 ，且子序列中相邻元素的差的绝对值 至少 为 k 。
 * 子序列 是指从原数组中删除一些元素（可能一个也不删除）后，剩余元素保持原来顺序而形成的新数组。
 * 
 * 核心思路：
 * 1. 这道题是LIS问题的一个变体，增加了相邻元素差的绝对值至少为k的约束
 * 2. 使用动态规划 + 线段树优化来解决这个问题
 * 3. 对于每个元素nums[i]，我们需要找到所有满足nums[j] < nums[i]且nums[i] - nums[j] >= k的j，然后dp[i] = max(dp[j]) + 1
 * 4. 使用线段树来高效查询区间内的最大值
 * 
 * 复杂度分析：
 * 时间复杂度：O(n log n)，其中n是数组长度。离散化需要O(n log n)，构建线段树需要O(n)，每次查询和更新需要O(log n)，总共有n次查询和更新
 * 空间复杂度：O(n)，用于存储离散化后的值、dp数组和线段树
 */
public class Code13_LongestIncreasingSubsequenceIV {

    /**
     * 线段树节点类
     */
    class SegmentTreeNode {
        int start, end;
        int max;
        SegmentTreeNode left, right;
        
        public SegmentTreeNode(int start, int end) {
            this.start = start;
            this.end = end;
            this.max = 0;
            this.left = null;
            this.right = null;
        }
    }
    
    /**
     * 构建线段树
     * @param node 当前节点
     * @return 构建好的线段树节点
     */
    private SegmentTreeNode buildSegmentTree(SegmentTreeNode node) {
        if (node.start == node.end) {
            return node;
        }
        
        int mid = node.start + (node.end - node.start) / 2;
        node.left = new SegmentTreeNode(node.start, mid);
        node.right = new SegmentTreeNode(mid + 1, node.end);
        
        buildSegmentTree(node.left);
        buildSegmentTree(node.right);
        
        return node;
    }
    
    /**
     * 查询区间内的最大值
     * @param node 当前节点
     * @param start 查询区间的起始位置
     * @param end 查询区间的结束位置
     * @return 区间内的最大值
     */
    private int queryMax(SegmentTreeNode node, int start, int end) {
        if (start > node.end || end < node.start) {
            return 0;
        }
        
        if (start <= node.start && end >= node.end) {
            return node.max;
        }
        
        int leftMax = queryMax(node.left, start, end);
        int rightMax = queryMax(node.right, start, end);
        
        return Math.max(leftMax, rightMax);
    }
    
    /**
     * 更新线段树中的值
     * @param node 当前节点
     * @param index 要更新的索引
     * @param value 要更新的值
     */
    private void updateSegmentTree(SegmentTreeNode node, int index, int value) {
        if (node.start == node.end && node.start == index) {
            node.max = Math.max(node.max, value);
            return;
        }
        
        int mid = node.start + (node.end - node.start) / 2;
        if (index <= mid) {
            updateSegmentTree(node.left, index, value);
        } else {
            updateSegmentTree(node.right, index, value);
        }
        
        node.max = Math.max(node.left.max, node.right.max);
    }
    
    /**
     * 最优解法：动态规划 + 线段树优化
     * @param nums 输入数组
     * @param k 相邻元素差的最小绝对值
     * @return 满足条件的最长递增子序列的长度
     */
    public int lengthOfLIS(int[] nums, int k) {
        // 离散化处理
        int[] sortedNums = Arrays.copyOf(nums, nums.length);
        Arrays.sort(sortedNums);
        
        // 创建映射，将原始值映射到离散化后的值
        Map<Integer, Integer> valueToIndex = new HashMap<>();
        int index = 1; // 从1开始，便于线段树处理
        for (int num : sortedNums) {
            if (!valueToIndex.containsKey(num)) {
                valueToIndex.put(num, index++);
            }
        }
        
        int n = valueToIndex.size();
        SegmentTreeNode root = new SegmentTreeNode(1, n);
        buildSegmentTree(root);
        
        int maxLength = 0;
        for (int num : nums) {
            // 找到所有小于num且num - value >= k的元素的最大长度
            // 即找到所有value <= num - k的元素
            int target = num - k;
            // 找到最大的不大于target的值
            int left = 0;
            int right = sortedNums.length - 1;
            int best = -1;
            while (left <= right) {
                int mid = left + (right - left) / 2;
                if (sortedNums[mid] <= target) {
                    best = mid;
                    left = mid + 1;
                } else {
                    right = mid - 1;
                }
            }
            
            int currentLength = 1;
            if (best != -1) {
                int queryEnd = valueToIndex.get(sortedNums[best]);
                currentLength = queryMax(root, 1, queryEnd) + 1;
            }
            
            // 更新线段树
            int numIndex = valueToIndex.get(num);
            updateSegmentTree(root, numIndex, currentLength);
            
            maxLength = Math.max(maxLength, currentLength);
        }
        
        return maxLength;
    }
    
    /**
     * 另一种实现方式：使用TreeMap优化
     * @param nums 输入数组
     * @param k 相邻元素差的最小绝对值
     * @return 满足条件的最长递增子序列的长度
     */
    public int lengthOfLISAlternative(int[] nums, int k) {
        // 离散化处理
        int[] sortedNums = Arrays.copyOf(nums, nums.length);
        Arrays.sort(sortedNums);
        
        // 创建映射，将原始值映射到离散化后的值
        Map<Integer, Integer> valueToIndex = new HashMap<>();
        int index = 1;
        for (int num : sortedNums) {
            if (!valueToIndex.containsKey(num)) {
                valueToIndex.put(num, index++);
            }
        }
        
        int n = valueToIndex.size();
        // 使用数组模拟线段树
        int[] segmentTree = new int[4 * n];
        
        int maxLength = 0;
        for (int num : nums) {
            int target = num - k;
            // 找到最大的不大于target的值
            int left = 0;
            int right = sortedNums.length - 1;
            int best = -1;
            while (left <= right) {
                int mid = left + (right - left) / 2;
                if (sortedNums[mid] <= target) {
                    best = mid;
                    left = mid + 1;
                } else {
                    right = mid - 1;
                }
            }
            
            int currentLength = 1;
            if (best != -1) {
                int queryEnd = valueToIndex.get(sortedNums[best]);
                currentLength = queryMax(segmentTree, 0, 1, n, 1, queryEnd) + 1;
            }
            
            // 更新线段树
            int numIndex = valueToIndex.get(num);
            updateSegmentTree(segmentTree, 0, 1, n, numIndex, currentLength);
            
            maxLength = Math.max(maxLength, currentLength);
        }
        
        return maxLength;
    }
    
    /**
     * 数组实现的线段树查询方法
     */
    private int queryMax(int[] tree, int node, int start, int end, int l, int r) {
        if (r < start || end < l) {
            return 0;
        }
        if (l <= start && end <= r) {
            return tree[node];
        }
        int mid = start + (end - start) / 2;
        int leftMax = queryMax(tree, 2 * node + 1, start, mid, l, r);
        int rightMax = queryMax(tree, 2 * node + 2, mid + 1, end, l, r);
        return Math.max(leftMax, rightMax);
    }
    
    /**
     * 数组实现的线段树更新方法
     */
    private void updateSegmentTree(int[] tree, int node, int start, int end, int idx, int val) {
        if (start == end) {
            tree[node] = Math.max(tree[node], val);
        } else {
            int mid = start + (end - start) / 2;
            if (idx <= mid) {
                updateSegmentTree(tree, 2 * node + 1, start, mid, idx, val);
            } else {
                updateSegmentTree(tree, 2 * node + 2, mid + 1, end, idx, val);
            }
            tree[node] = Math.max(tree[2 * node + 1], tree[2 * node + 2]);
        }
    }
    
    /**
     * 解释性更强的版本，添加了更多注释和中间变量
     * @param nums 输入数组
     * @param k 相邻元素差的最小绝对值
     * @return 满足条件的最长递增子序列的长度
     */
    public int lengthOfLISExplained(int[] nums, int k) {
        // 步骤1: 离散化处理
        // 由于数组中的值可能很大，我们需要对其进行离散化，以便使用线段树
        int[] sortedNums = Arrays.copyOf(nums, nums.length);
        Arrays.sort(sortedNums);
        
        // 创建值到索引的映射，将原始值映射到较小的范围内
        Map<Integer, Integer> valueToIndex = new HashMap<>();
        int index = 1; // 从1开始，便于线段树处理
        for (int num : sortedNums) {
            if (!valueToIndex.containsKey(num)) {
                valueToIndex.put(num, index++);
            }
        }
        
        // 步骤2: 初始化线段树
        int n = valueToIndex.size();
        SegmentTreeNode root = new SegmentTreeNode(1, n);
        buildSegmentTree(root);
        
        // 步骤3: 动态规划 + 线段树优化
        int maxLength = 0; // 用于保存最长子序列的长度
        
        for (int num : nums) {
            // 对于每个元素num，我们需要找到所有满足nums[j] < num且num - nums[j] >= k的j
            // 即nums[j] <= num - k
            int target = num - k;
            
            // 二分查找找到最大的不大于target的值
            int left = 0;
            int right = sortedNums.length - 1;
            int best = -1; // 记录找到的索引
            
            while (left <= right) {
                int mid = left + (right - left) / 2;
                if (sortedNums[mid] <= target) {
                    best = mid; // 找到一个可能的候选
                    left = mid + 1; // 继续向右查找更大的符合条件的值
                } else {
                    right = mid - 1; // 向左查找
                }
            }
            
            // 计算以当前元素结尾的最长递增子序列长度
            int currentLength = 1; // 至少包含当前元素
            if (best != -1) { // 如果找到了符合条件的元素
                int queryEnd = valueToIndex.get(sortedNums[best]);
                // 查询区间[1, queryEnd]内的最大值，并加1
                currentLength = queryMax(root, 1, queryEnd) + 1;
            }
            
            // 更新线段树中当前值的位置
            int numIndex = valueToIndex.get(num);
            updateSegmentTree(root, numIndex, currentLength);
            
            // 更新全局最长子序列长度
            maxLength = Math.max(maxLength, currentLength);
        }
        
        return maxLength;
    }
    
    /**
     * 主方法，用于测试
     */
    public static void main(String[] args) {
        Code13_LongestIncreasingSubsequenceIV solution = new Code13_LongestIncreasingSubsequenceIV();
        
        // 测试用例1
        int[] nums1 = {4, 2, 1, 4, 3, 4, 5, 8, 15};
        int k1 = 3;
        System.out.println("测试用例1：");
        System.out.println("数组: " + Arrays.toString(nums1));
        System.out.println("k: " + k1);
        System.out.println("结果: " + solution.lengthOfLIS(nums1, k1) + "，预期: 5");
        System.out.println();
        
        // 测试用例2
        int[] nums2 = {7, 4, 5, 1, 8, 12, 4, 7};
        int k2 = 5;
        System.out.println("测试用例2：");
        System.out.println("数组: " + Arrays.toString(nums2));
        System.out.println("k: " + k2);
        System.out.println("结果: " + solution.lengthOfLIS(nums2, k2) + "，预期: 3");
        System.out.println();
        
        // 测试用例3：边界情况
        int[] nums3 = {1};
        int k3 = 1;
        System.out.println("测试用例3：");
        System.out.println("数组: " + Arrays.toString(nums3));
        System.out.println("k: " + k3);
        System.out.println("结果: " + solution.lengthOfLIS(nums3, k3) + "，预期: 1");
        
        // 运行所有解法的对比测试
        runAllSolutionsTest(solution, nums1, k1);
        runAllSolutionsTest(solution, nums2, k2);
        runAllSolutionsTest(solution, nums3, k3);
    }
    
    /**
     * 运行所有解法的对比测试
     */
    public static void runAllSolutionsTest(Code13_LongestIncreasingSubsequenceIV solution, int[] nums, int k) {
        System.out.println("\n对比测试：");
        System.out.println("数组: " + Arrays.toString(nums));
        System.out.println("k: " + k);
        
        // 测试线段树节点实现
        long startTime = System.nanoTime();
        int result1 = solution.lengthOfLIS(nums, k);
        long endTime = System.nanoTime();
        System.out.println("线段树节点实现结果: " + result1);
        System.out.println("耗时: " + (endTime - startTime) / 1000 + " μs");
        
        // 测试数组实现的线段树
        startTime = System.nanoTime();
        int result2 = solution.lengthOfLISAlternative(nums, k);
        endTime = System.nanoTime();
        System.out.println("数组实现线段树结果: " + result2);
        System.out.println("耗时: " + (endTime - startTime) / 1000 + " μs");
        
        // 测试解释性版本
        startTime = System.nanoTime();
        int result3 = solution.lengthOfLISExplained(nums, k);
        endTime = System.nanoTime();
        System.out.println("解释性版本结果: " + result3);
        System.out.println("耗时: " + (endTime - startTime) / 1000 + " μs");
        
        System.out.println("----------------------------------------");
    }
    
    /**
     * 性能测试函数
     */
    public static void performanceTest(Code13_LongestIncreasingSubsequenceIV solution, int size) {
        // 生成随机测试数据
        int[] nums = new int[size];
        for (int i = 0; i < size; i++) {
            nums[i] = (int)(Math.random() * 10000);
        }
        int k = (int)(Math.random() * 100);
        
        System.out.println("\n性能测试：数组大小 = " + size);
        
        // 测试线段树节点实现
        long startTime = System.nanoTime();
        int result1 = solution.lengthOfLIS(nums, k);
        long endTime = System.nanoTime();
        System.out.println("线段树节点实现耗时: " + (endTime - startTime) / 1_000_000 + " ms, 结果: " + result1);
    }
}

===============================================

文件: Code13_LongestIncreasingSubsequenceIV.py
===============================================
#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
最长递增子序列 IV - LeetCode 2407
题目来源：https://leetcode.cn/problems/longest-increasing-subsequence-iv/
难度：困难
题目描述：给你一个整数数组 nums 和一个整数 k 。找到最长子序列的长度，满足子序列中的每个元素 严格递增 ，且子序列中相邻元素的差的绝对值 至少 为 k 。
子序列 是指从原数组中删除一些元素（可能一个也不删除）后，剩余元素保持原来顺序而形成的新数组。

核心思路：
1. 这道题是LIS问题的一个变体，增加了相邻元素差的绝对值至少为k的约束
2. 使用动态规划 + 线段树优化来解决这个问题
3. 对于每个元素nums[i]，我们需要找到所有满足nums[j] < nums[i]且nums[i] - nums[j] >= k的j，然后dp[i] = max(dp[j]) + 1
4. 使用线段树来高效查询区间内的最大值

复杂度分析：
时间复杂度：O(n log n)，其中n是数组长度。离散化需要O(n log n)，构建线段树需要O(n)，每次查询和更新需要O(log n)，总共有n次查询和更新
空间复杂度：O(n)，用于存储离散化后的值、dp数组和线段树
"""

from typing import List
import time
import random


class SegmentTree:
    """
    线段树类，用于高效查询区间最大值和更新操作
    """
    def __init__(self, size):
        self.n = 1
        # 确保大小为2的幂次，简化实现
        while self.n < size:
            self.n <<= 1
        # 初始化线段树数组，大小为2*n
        self.tree = [0] * (2 * self.n)
    
    def update(self, pos, value):
        """
        更新线段树中指定位置的值（取最大值）
        
        参数:
            pos: 要更新的位置（从0开始）
            value: 要更新的值
        """
        pos += self.n  # 转换为叶子节点索引
        # 更新当前节点的值为最大值
        if self.tree[pos] < value:
            self.tree[pos] = value
            # 向上更新父节点
            while pos > 1:
                pos >>= 1  # 移动到父节点
                # 父节点的值为左右子节点的最大值
                new_val = max(self.tree[2 * pos], self.tree[2 * pos + 1])
                if self.tree[pos] == new_val:
                    break  # 如果父节点的值没有变化，停止更新
                self.tree[pos] = new_val
    
    def query_max(self, l, r):
        """
        查询区间[l, r)内的最大值
        
        参数:
            l: 区间左边界（包含）
            r: 区间右边界（不包含）
        返回:
            区间内的最大值
        """
        res = 0
        l += self.n  # 转换为叶子节点索引
        r += self.n
        
        while l < r:
            # 如果左边界是右孩子
            if l % 2 == 1:
                res = max(res, self.tree[l])
                l += 1
            # 如果右边界是左孩子
            if r % 2 == 1:
                r -= 1
                res = max(res, self.tree[r])
            # 移动到父节点
            l >>= 1
            r >>= 1
        
        return res


def lengthOfLIS(nums: List[int], k: int) -> int:
    """
    最优解法：动态规划 + 线段树优化
    
    参数:
        nums: 输入数组
        k: 相邻元素差的最小绝对值
    返回:
        满足条件的最长递增子序列的长度
    """
    if not nums:
        return 0
    
    # 离散化处理
    sorted_nums = sorted(set(nums))  # 使用set去重，避免重复的值
    # 创建值到索引的映射，从1开始
    value_to_index = {num: idx + 1 for idx, num in enumerate(sorted_nums)}
    n = len(sorted_nums)
    
    # 初始化线段树
    segment_tree = SegmentTree(n + 1)  # 索引从1开始，所以大小+1
    
    max_length = 0
    for num in nums:
        # 计算目标值
        target = num - k
        # 二分查找找到最大的不大于target的值
        # 使用bisect_right找到插入位置，然后减1
        left, right = 0, len(sorted_nums) - 1
        best = -1  # 保存找到的最大索引
        while left <= right:
            mid = (left + right) // 2
            if sorted_nums[mid] <= target:
                best = mid
                left = mid + 1
            else:
                right = mid - 1
        
        # 计算当前长度
        current_length = 1  # 至少包含自己
        if best != -1:
            # 查询[1, best_idx]区间内的最大值
            best_idx = value_to_index[sorted_nums[best]]
            current_length = segment_tree.query_max(1, best_idx + 1) + 1
        
        # 更新线段树
        num_idx = value_to_index[num]
        segment_tree.update(num_idx, current_length)
        
        # 更新全局最大值
        max_length = max(max_length, current_length)
    
    return max_length


def lengthOfLISAlternative(nums: List[int], k: int) -> int:
    """
    另一种实现方式：使用更简单的线段树实现
    
    参数:
        nums: 输入数组
        k: 相邻元素差的最小绝对值
    返回:
        满足条件的最长递增子序列的长度
    """
    if not nums:
        return 0
    
    # 离散化处理
    sorted_nums = sorted(set(nums))
    value_to_index = {num: idx + 1 for idx, num in enumerate(sorted_nums)}
    n = len(sorted_nums)
    
    # 简单的线段树实现（基于数组）
    # 使用4*n的大小来存储线段树
    size = 1
    while size < n:
        size <<= 1
    tree = [0] * (2 * size)
    
    def update(pos, value):
        """更新线段树中的值"""
        pos += size  # 转换为叶子节点位置
        if pos >= len(tree):
            return
        if tree[pos] < value:
            tree[pos] = value
            pos >>= 1  # 移动到父节点
            while pos >= 1:
                new_val = max(tree[2 * pos], tree[2 * pos + 1])
                if tree[pos] == new_val:
                    break
                tree[pos] = new_val
                pos >>= 1
    
    def query_max(l, r):
        """查询区间[l, r)的最大值"""
        res = 0
        l += size
        r += size
        
        while l < r:
            if l % 2 == 1:
                res = max(res, tree[l])
                l += 1
            if r % 2 == 1:
                r -= 1
                res = max(res, tree[r])
            l >>= 1
            r >>= 1
        
        return res
    
    max_length = 0
    for num in nums:
        target = num - k
        # 二分查找
        left, right = 0, len(sorted_nums) - 1
        best = -1
        while left <= right:
            mid = (left + right) // 2
            if sorted_nums[mid] <= target:
                best = mid
                left = mid + 1
            else:
                right = mid - 1
        
        current_length = 1
        if best != -1:
            best_idx = value_to_index[sorted_nums[best]]
            current_length = query_max(1, best_idx + 1) + 1
        
        num_idx = value_to_index[num]
        update(num_idx, current_length)
        max_length = max(max_length, current_length)
    
    return max_length


def lengthOfLISExplained(nums: List[int], k: int) -> int:
    """
    解释性更强的版本，添加了更多详细注释和中间变量
    
    参数:
        nums: 输入数组
        k: 相邻元素差的最小绝对值
    返回:
        满足条件的最长递增子序列的长度
    """
    # 边界条件检查
    if not nums:
        return 0
    
    # 步骤1: 离散化处理
    # 为什么需要离散化？因为数组中的值可能很大（如负数、很大的正数），直接使用这些值作为线段树的索引不现实
    # 离散化将原始值映射到连续的小整数范围内
    # 首先，我们对数组中的唯一值进行排序
    unique_sorted_nums = sorted(set(nums))  # 使用set去重，然后排序
    
    # 步骤2: 创建值到索引的映射
    # 我们将每个唯一值映射到一个连续的整数（从1开始，便于线段树处理）
    value_index_map = {value: index + 1 for index, value in enumerate(unique_sorted_nums)}
    num_unique_values = len(unique_sorted_nums)
    
    # 步骤3: 初始化线段树
    # 线段树用于高效查询区间内的最大值和更新操作
    # 我们使用一个足够大的线段树来覆盖所有可能的索引
    segment_tree = SegmentTree(num_unique_values + 1)  # +1 因为索引从1开始
    
    # 步骤4: 动态规划 + 线段树优化
    # 对于每个元素num，我们需要找到所有满足nums[j] < num且num - nums[j] >= k的j
    # 然后dp[num] = max(dp[j] for all valid j) + 1
    longest_subsequence = 0
    
    for current_num in nums:
        # 计算目标值：我们需要找的值必须小于等于current_num - k
        target_value = current_num - k
        
        # 使用二分查找找到最大的不大于target_value的值的索引
        left_idx, right_idx = 0, len(unique_sorted_nums) - 1
        best_idx = -1  # 记录找到的最大索引
        
        while left_idx <= right_idx:
            mid_idx = (left_idx + right_idx) // 2
            mid_value = unique_sorted_nums[mid_idx]
            
            if mid_value <= target_value:
                # 找到一个符合条件的候选，继续向右查找更大的符合条件的值
                best_idx = mid_idx
                left_idx = mid_idx + 1
            else:
                # 向左查找更小的值
                right_idx = mid_idx - 1
        
        # 计算以当前元素结尾的最长递增子序列长度
        current_subsequence_length = 1  # 至少包含当前元素
        
        if best_idx != -1:  # 如果找到了符合条件的元素
            # 获取该元素对应的索引
            valid_idx = value_index_map[unique_sorted_nums[best_idx]]
            # 查询[1, valid_idx]区间内的最大值，表示之前找到的最长子序列长度
            max_previous_length = segment_tree.query_max(1, valid_idx + 1)
            # 当前长度 = 之前的最大长度 + 1（加上当前元素）
            current_subsequence_length = max_previous_length + 1
        
        # 更新线段树中当前值的位置
        current_num_idx = value_index_map[current_num]
        segment_tree.update(current_num_idx, current_subsequence_length)
        
        # 更新全局最长子序列长度
        longest_subsequence = max(longest_subsequence, current_subsequence_length)
    
    return longest_subsequence


def runAllSolutionsTest(nums: List[int], k: int):
    """
    运行所有解法的对比测试
    
    参数:
        nums: 输入数组
        k: 相邻元素差的最小绝对值
    """
    print(f"\n对比测试：")
    print(f"数组: {nums}")
    print(f"k: {k}")
    
    # 测试线段树类实现
    start_time = time.time()
    result1 = lengthOfLIS(nums, k)
    end_time = time.time()
    print(f"线段树类实现结果: {result1}")
    print(f"耗时: {(end_time - start_time) * 1_000_000:.2f} μs")
    
    # 测试内部线段树实现
    start_time = time.time()
    result2 = lengthOfLISAlternative(nums, k)
    end_time = time.time()
    print(f"内部线段树实现结果: {result2}")
    print(f"耗时: {(end_time - start_time) * 1_000_000:.2f} μs")
    
    # 测试解释性版本
    start_time = time.time()
    result3 = lengthOfLISExplained(nums, k)
    end_time = time.time()
    print(f"解释性版本结果: {result3}")
    print(f"耗时: {(end_time - start_time) * 1_000_000:.2f} μs")
    
    print("-" * 40)


def performanceTest(size: int):
    """
    性能测试函数
    
    参数:
        size: 数组大小
    """
    # 生成随机测试数据
    nums = [random.randint(0, 10000) for _ in range(size)]
    k = random.randint(0, 100)
    
    print(f"\n性能测试：数组大小 = {size}")
    
    # 测试线段树类实现
    start_time = time.time()
    result1 = lengthOfLIS(nums, k)
    end_time = time.time()
    print(f"线段树类实现耗时: {(end_time - start_time) * 1000:.3f} ms, 结果: {result1}")


def testCase():
    """
    测试用例
    """
    # 测试用例1
    nums1 = [4, 2, 1, 4, 3, 4, 5, 8, 15]
    k1 = 3
    print("测试用例1：")
    print(f"数组: {nums1}")
    print(f"k: {k1}")
    print(f"结果: {lengthOfLIS(nums1, k1)}，预期: 5")
    print()
    
    # 测试用例2
    nums2 = [7, 4, 5, 1, 8, 12, 4, 7]
    k2 = 5
    print("测试用例2：")
    print(f"数组: {nums2}")
    print(f"k: {k2}")
    print(f"结果: {lengthOfLIS(nums2, k2)}，预期: 3")
    print()
    
    # 测试用例3：边界情况
    nums3 = [1]
    k3 = 1
    print("测试用例3：")
    print(f"数组: {nums3}")
    print(f"k: {k3}")
    print(f"结果: {lengthOfLIS(nums3, k3)}，预期: 1")
    
    # 运行所有解法的对比测试
    runAllSolutionsTest(nums1, k1)
    runAllSolutionsTest(nums2, k2)
    runAllSolutionsTest(nums3, k3)
    
    # 性能测试
    print("性能测试:")
    print("-" * 40)
    performanceTest(1000)
    performanceTest(5000)
    
    # 特殊测试用例：严格递增序列，且相邻差大于等于k
    print("\n特殊测试用例：严格递增序列，且相邻差大于等于k")
    numsIncreasing = [1, 4, 7, 10, 13]
    kIncreasing = 3
    print(f"数组: {numsIncreasing}")
    print(f"k: {kIncreasing}")
    print(f"结果: {lengthOfLIS(numsIncreasing, kIncreasing)}")
    
    # 特殊测试用例：所有元素相同
    print("\n特殊测试用例：所有元素相同")
    numsSame = [5, 5, 5, 5, 5]
    kSame = 1
    print(f"数组: {numsSame}")
    print(f"k: {kSame}")
    print(f"结果: {lengthOfLIS(numsSame, kSame)}")


if __name__ == "__main__":
    """
    主函数入口
    """
    testCase()

===============================================

文件: Code14_LongestContinuousIncreasingSubsequence.cpp
===============================================
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

/**
 * 最长连续递增子序列
 * 
 * 题目来源：LeetCode 674. 最长连续递增子序列
 * 题目链接：https://leetcode.cn/problems/longest-continuous-increasing-subsequence/
 * 题目描述：给定一个未经排序的整数数组，找到最长且连续递增的子序列，并返回该序列的长度。
 * 连续递增的子序列可以由两个下标 l 和 r（l < r）确定，如果对于每个 l <= i < r，
 * 都有 nums[i] < nums[i + 1] ，那么子序列 [nums[l], nums[l + 1], ..., nums[r - 1], nums[r]] 就是连续递增子序列。
 * 
 * 算法思路：
 * 1. 使用滑动窗口或动态规划思想
 * 2. 遍历数组，维护当前连续递增子序列的长度
 * 3. 当遇到不满足递增条件时，重置当前长度
 * 4. 记录遍历过程中的最大长度
 * 
 * 时间复杂度：O(n) - 只需遍历一次数组
 * 空间复杂度：O(1) - 只使用常数额外空间
 * 是否最优解：是，这是最优解法
 * 
 * 示例：
 * 输入: [1,3,5,4,7]
 * 输出: 3
 * 解释: 最长连续递增子序列是 [1,3,5], 长度为3。
 * 尽管 [1,3,5,7] 也是升序的子序列, 但它不是连续的，因为5和7在原数组里被4隔开。
 * 
 * 输入: [2,2,2,2,2]
 * 输出: 1
 * 解释: 最长连续递增子序列是 [2], 长度为1。
 */

class Solution {
public:
    /**
     * 计算最长连续递增子序列的长度
     * 
     * @param nums 输入的整数数组
     * @return 最长连续递增子序列的长度
     */
    int findLengthOfLCIS(vector<int>& nums) {
        if (nums.empty()) {
            return 0;
        }
        
        int n = nums.size();
        // 当前连续递增子序列的长度
        int currentLength = 1;
        // 最大连续递增子序列的长度
        int maxLength = 1;
        
        // 从第二个元素开始遍历
        for (int i = 1; i < n; i++) {
            // 如果当前元素大于前一个元素，连续递增
            if (nums[i] > nums[i - 1]) {
                currentLength++;
                maxLength = max(maxLength, currentLength);
            } else {
                // 不满足递增条件，重置当前长度
                currentLength = 1;
            }
        }
        
        return maxLength;
    }

    /**
     * 使用滑动窗口方法计算最长连续递增子序列的长度
     * 
     * 算法思路：
     * 1. 使用双指针维护滑动窗口
     * 2. 左指针指向当前连续递增子序列的开始位置
     * 3. 右指针向右扩展，直到不满足递增条件
     * 4. 更新最大长度，移动左指针到右指针位置
     * 
     * 时间复杂度：O(n) - 每个元素最多被访问两次
     * 空间复杂度：O(1) - 只使用常数额外空间
     * 是否最优解：是，这是最优解法
     * 
     * @param nums 输入的整数数组
     * @return 最长连续递增子序列的长度
     */
    int findLengthOfLCIS2(vector<int>& nums) {
        if (nums.empty()) {
            return 0;
        }
        
        int n = nums.size();
        int left = 0; // 滑动窗口左边界
        int maxLength = 1; // 最大长度
        
        // 右指针遍历数组
        for (int right = 1; right < n; right++) {
            // 如果当前元素不大于前一个元素，不满足连续递增条件
            if (nums[right] <= nums[right - 1]) {
                // 更新最大长度
                maxLength = max(maxLength, right - left);
                // 移动左指针到当前位置
                left = right;
            }
        }
        
        // 处理最后一个窗口
        maxLength = max(maxLength, n - left);
        
        return maxLength;
    }
};

// 测试函数
void test() {
    Solution solution;
    
    // 测试用例1
    vector<int> nums1 = {1, 3, 5, 4, 7};
    cout << "输入: [1,3,5,4,7]" << endl;
    cout << "方法1输出: " << solution.findLengthOfLCIS(nums1) << endl;
    cout << "方法2输出: " << solution.findLengthOfLCIS2(nums1) << endl;
    cout << "期望: 3" << endl;
    cout << endl;
    
    // 测试用例2
    vector<int> nums2 = {2, 2, 2, 2, 2};
    cout << "输入: [2,2,2,2,2]" << endl;
    cout << "方法1输出: " << solution.findLengthOfLCIS(nums2) << endl;
    cout << "方法2输出: " << solution.findLengthOfLCIS2(nums2) << endl;
    cout << "期望: 1" << endl;
    cout << endl;
    
    // 测试用例3
    vector<int> nums3 = {1, 3, 5, 7};
    cout << "输入: [1,3,5,7]" << endl;
    cout << "方法1输出: " << solution.findLengthOfLCIS(nums3) << endl;
    cout << "方法2输出: " << solution.findLengthOfLCIS2(nums3) << endl;
    cout << "期望: 4" << endl;
    cout << endl;
    
    // 测试用例4
    vector<int> nums4 = {};
    cout << "输入: []" << endl;
    cout << "方法1输出: " << solution.findLengthOfLCIS(nums4) << endl;
    cout << "方法2输出: " << solution.findLengthOfLCIS2(nums4) << endl;
    cout << "期望: 0" << endl;
    cout << endl;
    
    // 测试用例5
    vector<int> nums5 = {1};
    cout << "输入: [1]" << endl;
    cout << "方法1输出: " << solution.findLengthOfLCIS(nums5) << endl;
    cout << "方法2输出: " << solution.findLengthOfLCIS2(nums5) << endl;
    cout << "期望: 1" << endl;
    cout << endl;
}

int main() {
    test();
    return 0;
}

===============================================

文件: Code14_LongestContinuousIncreasingSubsequence.java
===============================================
package class072;

/**
 * 最长连续递增子序列
 * 
 * 题目来源：LeetCode 674. 最长连续递增子序列
 * 题目链接：https://leetcode.cn/problems/longest-continuous-increasing-subsequence/
 * 题目描述：给定一个未经排序的整数数组，找到最长且连续递增的子序列，并返回该序列的长度。
 * 连续递增的子序列可以由两个下标 l 和 r（l < r）确定，如果对于每个 l <= i < r，
 * 都有 nums[i] < nums[i + 1] ，那么子序列 [nums[l], nums[l + 1], ..., nums[r - 1], nums[r]] 就是连续递增子序列。
 * 
 * 算法思路：
 * 1. 使用滑动窗口或动态规划思想
 * 2. 遍历数组，维护当前连续递增子序列的长度
 * 3. 当遇到不满足递增条件时，重置当前长度
 * 4. 记录遍历过程中的最大长度
 * 
 * 时间复杂度：O(n) - 只需遍历一次数组
 * 空间复杂度：O(1) - 只使用常数额外空间
 * 是否最优解：是，这是最优解法
 * 
 * 示例：
 * 输入: [1,3,5,4,7]
 * 输出: 3
 * 解释: 最长连续递增子序列是 [1,3,5], 长度为3。
 * 尽管 [1,3,5,7] 也是升序的子序列, 但它不是连续的，因为5和7在原数组里被4隔开。
 * 
 * 输入: [2,2,2,2,2]
 * 输出: 1
 * 解释: 最长连续递增子序列是 [2], 长度为1。
 */

public class Code14_LongestContinuousIncreasingSubsequence {

    /**
     * 计算最长连续递增子序列的长度
     * 
     * @param nums 输入的整数数组
     * @return 最长连续递增子序列的长度
     */
    public static int findLengthOfLCIS(int[] nums) {
        if (nums == null || nums.length == 0) {
            return 0;
        }
        
        int n = nums.length;
        // 当前连续递增子序列的长度
        int currentLength = 1;
        // 最大连续递增子序列的长度
        int maxLength = 1;
        
        // 从第二个元素开始遍历
        for (int i = 1; i < n; i++) {
            // 如果当前元素大于前一个元素，连续递增
            if (nums[i] > nums[i - 1]) {
                currentLength++;
                maxLength = Math.max(maxLength, currentLength);
            } else {
                // 不满足递增条件，重置当前长度
                currentLength = 1;
            }
        }
        
        return maxLength;
    }

    /**
     * 使用滑动窗口方法计算最长连续递增子序列的长度
     * 
     * 算法思路：
     * 1. 使用双指针维护滑动窗口
     * 2. 左指针指向当前连续递增子序列的开始位置
     * 3. 右指针向右扩展，直到不满足递增条件
     * 4. 更新最大长度，移动左指针到右指针位置
     * 
     * 时间复杂度：O(n) - 每个元素最多被访问两次
     * 空间复杂度：O(1) - 只使用常数额外空间
     * 是否最优解：是，这是最优解法
     * 
     * @param nums 输入的整数数组
     * @return 最长连续递增子序列的长度
     */
    public static int findLengthOfLCIS2(int[] nums) {
        if (nums == null || nums.length == 0) {
            return 0;
        }
        
        int n = nums.length;
        int left = 0; // 滑动窗口左边界
        int maxLength = 1; // 最大长度
        
        // 右指针遍历数组
        for (int right = 1; right < n; right++) {
            // 如果当前元素不大于前一个元素，不满足连续递增条件
            if (nums[right] <= nums[right - 1]) {
                // 更新最大长度
                maxLength = Math.max(maxLength, right - left);
                // 移动左指针到当前位置
                left = right;
            }
        }
        
        // 处理最后一个窗口
        maxLength = Math.max(maxLength, n - left);
        
        return maxLength;
    }

    // 测试方法
    public static void main(String[] args) {
        // 测试用例1
        int[] nums1 = {1, 3, 5, 4, 7};
        System.out.println("输入: [1,3,5,4,7]");
        System.out.println("方法1输出: " + findLengthOfLCIS(nums1));
        System.out.println("方法2输出: " + findLengthOfLCIS2(nums1));
        System.out.println("期望: 3");
        System.out.println();
        
        // 测试用例2
        int[] nums2 = {2, 2, 2, 2, 2};
        System.out.println("输入: [2,2,2,2,2]");
        System.out.println("方法1输出: " + findLengthOfLCIS(nums2));
        System.out.println("方法2输出: " + findLengthOfLCIS2(nums2));
        System.out.println("期望: 1");
        System.out.println();
        
        // 测试用例3
        int[] nums3 = {1, 3, 5, 7};
        System.out.println("输入: [1,3,5,7]");
        System.out.println("方法1输出: " + findLengthOfLCIS(nums3));
        System.out.println("方法2输出: " + findLengthOfLCIS2(nums3));
        System.out.println("期望: 4");
        System.out.println();
        
        // 测试用例4
        int[] nums4 = {};
        System.out.println("输入: []");
        System.out.println("方法1输出: " + findLengthOfLCIS(nums4));
        System.out.println("方法2输出: " + findLengthOfLCIS2(nums4));
        System.out.println("期望: 0");
        System.out.println();
        
        // 测试用例5
        int[] nums5 = {1};
        System.out.println("输入: [1]");
        System.out.println("方法1输出: " + findLengthOfLCIS(nums5));
        System.out.println("方法2输出: " + findLengthOfLCIS2(nums5));
        System.out.println("期望: 1");
        System.out.println();
    }
}

===============================================

文件: Code14_LongestContinuousIncreasingSubsequence.py
===============================================
"""
最长连续递增子序列

题目来源：LeetCode 674. 最长连续递增子序列
题目链接：https://leetcode.cn/problems/longest-continuous-increasing-subsequence/
题目描述：给定一个未经排序的整数数组，找到最长且连续递增的子序列，并返回该序列的长度。
连续递增的子序列可以由两个下标 l 和 r（l < r）确定，如果对于每个 l <= i < r，
都有 nums[i] < nums[i + 1] ，那么子序列 [nums[l], nums[l + 1], ..., nums[r - 1], nums[r]] 就是连续递增子序列。

算法思路：
1. 使用滑动窗口或动态规划思想
2. 遍历数组，维护当前连续递增子序列的长度
3. 当遇到不满足递增条件时，重置当前长度
4. 记录遍历过程中的最大长度

时间复杂度：O(n) - 只需遍历一次数组
空间复杂度：O(1) - 只使用常数额外空间
是否最优解：是，这是最优解法

示例：
输入: [1,3,5,4,7]
输出: 3
解释: 最长连续递增子序列是 [1,3,5], 长度为3。
尽管 [1,3,5,7] 也是升序的子序列, 但它不是连续的，因为5和7在原数组里被4隔开。

输入: [2,2,2,2,2]
输出: 1
解释: 最长连续递增子序列是 [2], 长度为1。
"""

from typing import List

class Solution:
    """
    计算最长连续递增子序列的长度
    
    Args:
        nums: 输入的整数数组
        
    Returns:
        最长连续递增子序列的长度
    """
    def findLengthOfLCIS(self, nums: List[int]) -> int:
        if not nums:
            return 0
        
        n = len(nums)
        # 当前连续递增子序列的长度
        current_length = 1
        # 最大连续递增子序列的长度
        max_length = 1
        
        # 从第二个元素开始遍历
        for i in range(1, n):
            # 如果当前元素大于前一个元素，连续递增
            if nums[i] > nums[i - 1]:
                current_length += 1
                max_length = max(max_length, current_length)
            else:
                # 不满足递增条件，重置当前长度
                current_length = 1
        
        return max_length

    """
    使用滑动窗口方法计算最长连续递增子序列的长度
    
    算法思路：
    1. 使用双指针维护滑动窗口
    2. 左指针指向当前连续递增子序列的开始位置
    3. 右指针向右扩展，直到不满足递增条件
    4. 更新最大长度，移动左指针到右指针位置
    
    时间复杂度：O(n) - 每个元素最多被访问两次
    空间复杂度：O(1) - 只使用常数额外空间
    是否最优解：是，这是最优解法
    
    Args:
        nums: 输入的整数数组
        
    Returns:
        最长连续递增子序列的长度
    """
    def findLengthOfLCIS2(self, nums: List[int]) -> int:
        if not nums:
            return 0
        
        n = len(nums)
        left = 0  # 滑动窗口左边界
        max_length = 1  # 最大长度
        
        # 右指针遍历数组
        for right in range(1, n):
            # 如果当前元素不大于前一个元素，不满足连续递增条件
            if nums[right] <= nums[right - 1]:
                # 更新最大长度
                max_length = max(max_length, right - left)
                # 移动左指针到当前位置
                left = right
        
        # 处理最后一个窗口
        max_length = max(max_length, n - left)
        
        return max_length

def test():
    """
    测试函数
    """
    solution = Solution()
    
    # 测试用例1
    nums1 = [1, 3, 5, 4, 7]
    print("输入:", nums1)
    print("方法1输出:", solution.findLengthOfLCIS(nums1))
    print("方法2输出:", solution.findLengthOfLCIS2(nums1))
    print("期望: 3")
    print()
    
    # 测试用例2
    nums2 = [2, 2, 2, 2, 2]
    print("输入:", nums2)
    print("方法1输出:", solution.findLengthOfLCIS(nums2))
    print("方法2输出:", solution.findLengthOfLCIS2(nums2))
    print("期望: 1")
    print()
    
    # 测试用例3
    nums3 = [1, 3, 5, 7]
    print("输入:", nums3)
    print("方法1输出:", solution.findLengthOfLCIS(nums3))
    print("方法2输出:", solution.findLengthOfLCIS2(nums3))
    print("期望: 4")
    print()
    
    # 测试用例4
    nums4 = []
    print("输入:", nums4)
    print("方法1输出:", solution.findLengthOfLCIS(nums4))
    print("方法2输出:", solution.findLengthOfLCIS2(nums4))
    print("期望: 0")
    print()
    
    # 测试用例5
    nums5 = [1]
    print("输入:", nums5)
    print("方法1输出:", solution.findLengthOfLCIS(nums5))
    print("方法2输出:", solution.findLengthOfLCIS2(nums5))
    print("期望: 1")
    print()

if __name__ == "__main__":
    test()

===============================================

文件: Code15_MinimumNumberOfRemovalsToMakeMountainArray.cpp
===============================================
#include <iostream>
#include <vector>
#include <algorithm>
#include <climits>
using namespace std;

/**
 * 得到山形数组的最少删除次数
 * 
 * 题目来源：LeetCode 1671. 得到山形数组的最少删除次数
 * 题目链接：https://leetcode.cn/problems/minimum-number-of-removals-to-make-mountain-array/
 * 题目描述：我们定义 arr 是山形数组当且仅当它满足：
 *   - arr.length >= 3
 *   - 存在某个下标 i（0 < i < arr.length - 1）使得：
 *       arr[0] < arr[1] < ... < arr[i-1] < arr[i]
 *       arr[i] > arr[i+1] > ... > arr[arr.length - 1]
 * 给你一个整数数组 nums，返回将它变成山形数组的最少删除次数。
 * 
 * 算法思路：
 * 1. 山形数组要求存在一个峰值，左侧严格递增，右侧严格递减
 * 2. 对于每个位置i，计算以i为结尾的最长递增子序列长度（左侧）
 * 3. 计算以i为开头的最长递减子序列长度（右侧）
 * 4. 如果左侧长度>1且右侧长度>1，则山形数组长度为left[i] + right[i] - 1
 * 5. 最少删除次数 = n - 最大山形数组长度
 * 
 * 时间复杂度：O(n²) - 需要计算两个方向的LIS
 * 空间复杂度：O(n) - 需要两个数组存储左右LIS长度
 * 是否最优解：对于此问题的动态规划解法是标准解法
 * 
 * 示例：
 * 输入: nums = [1,3,1]
 * 输出: 0
 * 解释: 数组本身就是山形数组，所以我们不需要删除任何元素。
 * 
 * 输入: nums = [2,1,1,5,6,2,3,1]
 * 输出: 3
 * 解释: 一种方法是将下标为 0，1 和 5 的元素删除，剩下元素为 [1,5,6,3,1] ，是山形数组。
 */

class Solution {
public:
    /**
     * 计算将数组变成山形数组的最少删除次数
     * 
     * @param nums 输入的整数数组
     * @return 最少删除次数
     */
    int minimumMountainRemovals(vector<int>& nums) {
        int n = nums.size();
        if (n < 3) {
            return 0; // 数组长度小于3，无法形成山形数组
        }
        
        // left[i] 表示以nums[i]结尾的最长严格递增子序列长度
        vector<int> left(n, 1);
        // right[i] 表示以nums[i]开头的最长严格递减子序列长度
        vector<int> right(n, 1);
        
        // 计算左侧最长递增子序列
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < i; j++) {
                if (nums[j] < nums[i]) {
                    left[i] = max(left[i], left[j] + 1);
                }
            }
        }
        
        // 计算右侧最长递减子序列
        for (int i = n - 1; i >= 0; i--) {
            for (int j = n - 1; j > i; j--) {
                if (nums[j] < nums[i]) {
                    right[i] = max(right[i], right[j] + 1);
                }
            }
        }
        
        // 计算最大山形数组长度
        int maxMountainLength = 0;
        for (int i = 1; i < n - 1; i++) {
            // 峰值左右两侧都必须有元素（长度>1）
            if (left[i] > 1 && right[i] > 1) {
                maxMountainLength = max(maxMountainLength, left[i] + right[i] - 1);
            }
        }
        
        // 最少删除次数 = 总长度 - 最大山形数组长度
        return n - maxMountainLength;
    }

    /**
     * 使用贪心+二分查找优化版本
     * 
     * 算法思路：
     * 1. 使用贪心+二分查找优化LIS计算
     * 2. 分别计算从左到右和从右到左的LIS
     * 3. 时间复杂度优化到O(n*logn)
     * 
     * 时间复杂度：O(n*logn) - 使用二分查找优化
     * 空间复杂度：O(n) - 需要ends数组存储状态
     * 是否最优解：是，这是最优解法
     * 
     * @param nums 输入的整数数组
     * @return 最少删除次数
     */
    int minimumMountainRemovals2(vector<int>& nums) {
        int n = nums.size();
        if (n < 3) {
            return 0;
        }
        
        // 计算从左到右的LIS
        vector<int> left(n);
        vector<int> endsLeft(n, INT_MAX);
        int lenLeft = 0;
        
        for (int i = 0; i < n; i++) {
            int pos = binarySearch(endsLeft, lenLeft, nums[i], true);
            if (pos == -1) {
                endsLeft[lenLeft] = nums[i];
                left[i] = lenLeft + 1;
                lenLeft++;
            } else {
                endsLeft[pos] = nums[i];
                left[i] = pos + 1;
            }
        }
        
        // 计算从右到左的LIS（相当于从左到右的递减序列）
        vector<int> right(n);
        vector<int> endsRight(n, INT_MAX);
        int lenRight = 0;
        
        for (int i = n - 1; i >= 0; i--) {
            int pos = binarySearch(endsRight, lenRight, nums[i], true);
            if (pos == -1) {
                endsRight[lenRight] = nums[i];
                right[i] = lenRight + 1;
                lenRight++;
            } else {
                endsRight[pos] = nums[i];
                right[i] = pos + 1;
            }
        }
        
        // 计算最大山形数组长度
        int maxMountainLength = 0;
        for (int i = 1; i < n - 1; i++) {
            if (left[i] > 1 && right[i] > 1) {
                maxMountainLength = max(maxMountainLength, left[i] + right[i] - 1);
            }
        }
        
        return n - maxMountainLength;
    }

private:
    /**
     * 在严格升序数组ends中查找>=num的最左位置
     * 
     * @param ends 严格升序数组
     * @param len 有效长度
     * @param num 目标值
     * @param strict 是否严格递增
     * @return >=num的最左位置，如果不存在返回-1
     */
    int binarySearch(vector<int>& ends, int len, int num, bool strict) {
        int left = 0, right = len - 1;
        int result = -1;
        
        while (left <= right) {
            int mid = left + (right - left) / 2;
            if (ends[mid] >= num) {
                result = mid;
                right = mid - 1;
            } else {
                left = mid + 1;
            }
        }
        
        return result;
    }
};

// 测试函数
void test() {
    Solution solution;
    
    // 测试用例1
    vector<int> nums1 = {1, 3, 1};
    cout << "输入: [1,3,1]" << endl;
    cout << "方法1输出: " << solution.minimumMountainRemovals(nums1) << endl;
    cout << "方法2输出: " << solution.minimumMountainRemovals2(nums1) << endl;
    cout << "期望: 0" << endl;
    cout << endl;
    
    // 测试用例2
    vector<int> nums2 = {2, 1, 1, 5, 6, 2, 3, 1};
    cout << "输入: [2,1,1,5,6,2,3,1]" << endl;
    cout << "方法1输出: " << solution.minimumMountainRemovals(nums2) << endl;
    cout << "方法2输出: " << solution.minimumMountainRemovals2(nums2) << endl;
    cout << "期望: 3" << endl;
    cout << endl;
    
    // 测试用例3
    vector<int> nums3 = {4, 3, 2, 1, 1, 2, 3, 1};
    cout << "输入: [4,3,2,1,1,2,3,1]" << endl;
    cout << "方法1输出: " << solution.minimumMountainRemovals(nums3) << endl;
    cout << "方法2输出: " << solution.minimumMountainRemovals2(nums3) << endl;
    cout << endl;
    
    // 测试用例4
    vector<int> nums4 = {1, 2, 3, 4, 4, 3, 2, 1};
    cout << "输入: [1,2,3,4,4,3,2,1]" << endl;
    cout << "方法1输出: " << solution.minimumMountainRemovals(nums4) << endl;
    cout << "方法2输出: " << solution.minimumMountainRemovals2(nums4) << endl;
    cout << endl;
}

int main() {
    test();
    return 0;
}

===============================================

文件: Code15_MinimumNumberOfRemovalsToMakeMountainArray.java
===============================================
package class072;

/**
 * 得到山形数组的最少删除次数
 * 
 * 题目来源：LeetCode 1671. 得到山形数组的最少删除次数
 * 题目链接：https://leetcode.cn/problems/minimum-number-of-removals-to-make-mountain-array/
 * 题目描述：我们定义 arr 是山形数组当且仅当它满足：
 *   - arr.length >= 3
 *   - 存在某个下标 i（0 < i < arr.length - 1）使得：
 *       arr[0] < arr[1] < ... < arr[i-1] < arr[i]
 *       arr[i] > arr[i+1] > ... > arr[arr.length - 1]
 * 给你一个整数数组 nums，返回将它变成山形数组的最少删除次数。
 * 
 * 算法思路：
 * 1. 山形数组要求存在一个峰值，左侧严格递增，右侧严格递减
 * 2. 对于每个位置i，计算以i为结尾的最长递增子序列长度（左侧）
 * 3. 计算以i为开头的最长递减子序列长度（右侧）
 * 4. 如果左侧长度>1且右侧长度>1，则山形数组长度为left[i] + right[i] - 1
 * 5. 最少删除次数 = n - 最大山形数组长度
 * 
 * 时间复杂度：O(n²) - 需要计算两个方向的LIS
 * 空间复杂度：O(n) - 需要两个数组存储左右LIS长度
 * 是否最优解：对于此问题的动态规划解法是标准解法
 * 
 * 示例：
 * 输入: nums = [1,3,1]
 * 输出: 0
 * 解释: 数组本身就是山形数组，所以我们不需要删除任何元素。
 * 
 * 输入: nums = [2,1,1,5,6,2,3,1]
 * 输出: 3
 * 解释: 一种方法是将下标为 0，1 和 5 的元素删除，剩下元素为 [1,5,6,3,1] ，是山形数组。
 */

public class Code15_MinimumNumberOfRemovalsToMakeMountainArray {

    /**
     * 计算将数组变成山形数组的最少删除次数
     * 
     * @param nums 输入的整数数组
     * @return 最少删除次数
     */
    public static int minimumMountainRemovals(int[] nums) {
        int n = nums.length;
        if (n < 3) {
            return 0; // 数组长度小于3，无法形成山形数组
        }
        
        // left[i] 表示以nums[i]结尾的最长严格递增子序列长度
        int[] left = new int[n];
        // right[i] 表示以nums[i]开头的最长严格递减子序列长度
        int[] right = new int[n];
        
        // 计算左侧最长递增子序列
        for (int i = 0; i < n; i++) {
            left[i] = 1;
            for (int j = 0; j < i; j++) {
                if (nums[j] < nums[i]) {
                    left[i] = Math.max(left[i], left[j] + 1);
                }
            }
        }
        
        // 计算右侧最长递减子序列
        for (int i = n - 1; i >= 0; i--) {
            right[i] = 1;
            for (int j = n - 1; j > i; j--) {
                if (nums[j] < nums[i]) {
                    right[i] = Math.max(right[i], right[j] + 1);
                }
            }
        }
        
        // 计算最大山形数组长度
        int maxMountainLength = 0;
        for (int i = 1; i < n - 1; i++) {
            // 峰值左右两侧都必须有元素（长度>1）
            if (left[i] > 1 && right[i] > 1) {
                maxMountainLength = Math.max(maxMountainLength, left[i] + right[i] - 1);
            }
        }
        
        // 最少删除次数 = 总长度 - 最大山形数组长度
        return n - maxMountainLength;
    }

    /**
     * 使用贪心+二分查找优化版本
     * 
     * 算法思路：
     * 1. 使用贪心+二分查找优化LIS计算
     * 2. 分别计算从左到右和从右到左的LIS
     * 3. 时间复杂度优化到O(n*logn)
     * 
     * 时间复杂度：O(n*logn) - 使用二分查找优化
     * 空间复杂度：O(n) - 需要ends数组存储状态
     * 是否最优解：是，这是最优解法
     * 
     * @param nums 输入的整数数组
     * @return 最少删除次数
     */
    public static int minimumMountainRemovals2(int[] nums) {
        int n = nums.length;
        if (n < 3) {
            return 0;
        }
        
        // 计算从左到右的LIS
        int[] left = new int[n];
        int[] endsLeft = new int[n];
        int lenLeft = 0;
        
        for (int i = 0; i < n; i++) {
            int find = bs1(endsLeft, lenLeft, nums[i]);
            if (find == -1) {
                endsLeft[lenLeft++] = nums[i];
                left[i] = lenLeft;
            } else {
                endsLeft[find] = nums[i];
                left[i] = find + 1;
            }
        }
        
        // 计算从右到左的LIS（相当于从左到右的递减序列）
        int[] right = new int[n];
        int[] endsRight = new int[n];
        int lenRight = 0;
        
        for (int i = n - 1; i >= 0; i--) {
            int find = bs1(endsRight, lenRight, nums[i]);
            if (find == -1) {
                endsRight[lenRight++] = nums[i];
                right[i] = lenRight;
            } else {
                endsRight[find] = nums[i];
                right[i] = find + 1;
            }
        }
        
        // 计算最大山形数组长度
        int maxMountainLength = 0;
        for (int i = 1; i < n - 1; i++) {
            if (left[i] > 1 && right[i] > 1) {
                maxMountainLength = Math.max(maxMountainLength, left[i] + right[i] - 1);
            }
        }
        
        return n - maxMountainLength;
    }

    /**
     * 在严格升序数组ends中查找>=num的最左位置
     * 
     * @param ends 严格升序数组
     * @param len 有效长度
     * @param num 目标值
     * @return >=num的最左位置，如果不存在返回-1
     */
    private static int bs1(int[] ends, int len, int num) {
        int l = 0, r = len - 1, m, ans = -1;
        while (l <= r) {
            m = (l + r) / 2;
            if (ends[m] >= num) {
                ans = m;
                r = m - 1;
            } else {
                l = m + 1;
            }
        }
        return ans;
    }

    // 测试方法
    public static void main(String[] args) {
        // 测试用例1
        int[] nums1 = {1, 3, 1};
        System.out.println("输入: [1,3,1]");
        System.out.println("方法1输出: " + minimumMountainRemovals(nums1));
        System.out.println("方法2输出: " + minimumMountainRemovals2(nums1));
        System.out.println("期望: 0");
        System.out.println();
        
        // 测试用例2
        int[] nums2 = {2, 1, 1, 5, 6, 2, 3, 1};
        System.out.println("输入: [2,1,1,5,6,2,3,1]");
        System.out.println("方法1输出: " + minimumMountainRemovals(nums2));
        System.out.println("方法2输出: " + minimumMountainRemovals2(nums2));
        System.out.println("期望: 3");
        System.out.println();
        
        // 测试用例3
        int[] nums3 = {4, 3, 2, 1, 1, 2, 3, 1};
        System.out.println("输入: [4,3,2,1,1,2,3,1]");
        System.out.println("方法1输出: " + minimumMountainRemovals(nums3));
        System.out.println("方法2输出: " + minimumMountainRemovals2(nums3));
        System.out.println();
        
        // 测试用例4
        int[] nums4 = {1, 2, 3, 4, 4, 3, 2, 1};
        System.out.println("输入: [1,2,3,4,4,3,2,1]");
        System.out.println("方法1输出: " + minimumMountainRemovals(nums4));
        System.out.println("方法2输出: " + minimumMountainRemovals2(nums4));
        System.out.println();
    }
}

===============================================

文件: Code15_MinimumNumberOfRemovalsToMakeMountainArray.py
===============================================
"""
得到山形数组的最少删除次数

题目来源：LeetCode 1671. 得到山形数组的最少删除次数
题目链接：https://leetcode.cn/problems/minimum-number-of-removals-to-make-mountain-array/
题目描述：我们定义 arr 是山形数组当且仅当它满足：
  - arr.length >= 3
  - 存在某个下标 i（0 < i < arr.length - 1）使得：
      arr[0] < arr[1] < ... < arr[i-1] < arr[i]
      arr[i] > arr[i+1] > ... > arr[arr.length - 1]
给你一个整数数组 nums，返回将它变成山形数组的最少删除次数。

算法思路：
1. 山形数组要求存在一个峰值，左侧严格递增，右侧严格递减
2. 对于每个位置i，计算以i为结尾的最长递增子序列长度（左侧）
3. 计算以i为开头的最长递减子序列长度（右侧）
4. 如果左侧长度>1且右侧长度>1，则山形数组长度为left[i] + right[i] - 1
5. 最少删除次数 = n - 最大山形数组长度

时间复杂度：O(n²) - 需要计算两个方向的LIS
空间复杂度：O(n) - 需要两个数组存储左右LIS长度
是否最优解：对于此问题的动态规划解法是标准解法

示例：
输入: nums = [1,3,1]
输出: 0
解释: 数组本身就是山形数组，所以我们不需要删除任何元素。

输入: nums = [2,1,1,5,6,2,3,1]
输出: 3
解释: 一种方法是将下标为 0，1 和 5 的元素删除，剩下元素为 [1,5,6,3,1] ，是山形数组。
"""

from typing import List
import bisect

class Solution:
    """
    计算将数组变成山形数组的最少删除次数
    
    Args:
        nums: 输入的整数数组
        
    Returns:
        最少删除次数
    """
    def minimumMountainRemovals(self, nums: List[int]) -> int:
        n = len(nums)
        if n < 3:
            return 0  # 数组长度小于3，无法形成山形数组
        
        # left[i] 表示以nums[i]结尾的最长严格递增子序列长度
        left = [1] * n
        # right[i] 表示以nums[i]开头的最长严格递减子序列长度
        right = [1] * n
        
        # 计算左侧最长递增子序列
        for i in range(n):
            for j in range(i):
                if nums[j] < nums[i]:
                    left[i] = max(left[i], left[j] + 1)
        
        # 计算右侧最长递减子序列
        for i in range(n-1, -1, -1):
            for j in range(n-1, i, -1):
                if nums[j] < nums[i]:
                    right[i] = max(right[i], right[j] + 1)
        
        # 计算最大山形数组长度
        max_mountain_length = 0
        for i in range(1, n-1):
            # 峰值左右两侧都必须有元素（长度>1）
            if left[i] > 1 and right[i] > 1:
                max_mountain_length = max(max_mountain_length, left[i] + right[i] - 1)
        
        # 最少删除次数 = 总长度 - 最大山形数组长度
        return n - max_mountain_length

    """
    使用贪心+二分查找优化版本
    
    算法思路：
    1. 使用贪心+二分查找优化LIS计算
    2. 分别计算从左到右和从右到左的LIS
    3. 时间复杂度优化到O(n*logn)
    
    时间复杂度：O(n*logn) - 使用二分查找优化
    空间复杂度：O(n) - 需要ends数组存储状态
    是否最优解：是，这是最优解法
    
    Args:
        nums: 输入的整数数组
        
    Returns:
        最少删除次数
    """
    def minimumMountainRemovals2(self, nums: List[int]) -> int:
        n = len(nums)
        if n < 3:
            return 0
        
        # 计算从左到右的LIS
        left = [0] * n
        ends_left = []
        
        for i in range(n):
            # 使用bisect查找插入位置
            pos = bisect.bisect_left(ends_left, nums[i])
            if pos == len(ends_left):
                ends_left.append(nums[i])
                left[i] = len(ends_left)
            else:
                ends_left[pos] = nums[i]
                left[i] = pos + 1
        
        # 计算从右到左的LIS（相当于从左到右的递减序列）
        right = [0] * n
        ends_right = []
        
        for i in range(n-1, -1, -1):
            # 注意：对于从右到左的LDS，我们需要找>=nums[i]的位置
            pos = bisect.bisect_left(ends_right, nums[i])
            if pos == len(ends_right):
                ends_right.append(nums[i])
                right[i] = len(ends_right)
            else:
                ends_right[pos] = nums[i]
                right[i] = pos + 1
        
        # 计算最大山形数组长度
        max_mountain_length = 0
        for i in range(1, n-1):
            if left[i] > 1 and right[i] > 1:
                max_mountain_length = max(max_mountain_length, left[i] + right[i] - 1)
        
        return n - max_mountain_length

def test():
    """
    测试函数
    """
    solution = Solution()
    
    # 测试用例1
    nums1 = [1, 3, 1]
    print("输入:", nums1)
    print("方法1输出:", solution.minimumMountainRemovals(nums1))
    print("方法2输出:", solution.minimumMountainRemovals2(nums1))
    print("期望: 0")
    print()
    
    # 测试用例2
    nums2 = [2, 1, 1, 5, 6, 2, 3, 1]
    print("输入:", nums2)
    print("方法1输出:", solution.minimumMountainRemovals(nums2))
    print("方法2输出:", solution.minimumMountainRemovals2(nums2))
    print("期望: 3")
    print()
    
    # 测试用例3
    nums3 = [4, 3, 2, 1, 1, 2, 3, 1]
    print("输入:", nums3)
    print("方法1输出:", solution.minimumMountainRemovals(nums3))
    print("方法2输出:", solution.minimumMountainRemovals2(nums3))
    print()
    
    # 测试用例4
    nums4 = [1, 2, 3, 4, 4, 3, 2, 1]
    print("输入:", nums4)
    print("方法1输出:", solution.minimumMountainRemovals(nums4))
    print("方法2输出:", solution.minimumMountainRemovals2(nums4))
    print()

if __name__ == "__main__":
    test()

===============================================

文件: Code16_FindTheLongestValidObstacleCourseAtEachPosition.cpp
===============================================
#include <iostream>
#include <vector>
#include <algorithm>
#include <climits>
using namespace std;

/**
 * 找出到每个位置为止最长的非递减子序列
 * 
 * 题目来源：LeetCode 1964. 找出到每个位置为止最长的非递减子序列
 * 题目链接：https://leetcode.cn/problems/find-the-longest-valid-obstacle-course-at-each-position/
 * 题目描述：你打算构建一些障碍赛跑路线。给你一个下标从 0 开始的整数数组 obstacles，数组长度为 n，
 * 其中 obstacles[i] 表示第 i 个障碍的高度。对于每个介于 0 和 n - 1 之间（包含 0 和 n - 1）的下标 i，
 * 在满足下述条件的前提下，请你找出 obstacles 能构成的最长障碍路线的长度。
 * 
 * 条件：对于路线中的每个下标 j（0 <= j <= i），必须满足 obstacles[j] <= obstacles[i]。
 * 路线必须包含下标 i。
 * 
 * 算法思路：
 * 1. 这实际上是求以每个位置结尾的最长非递减子序列长度
 * 2. 使用贪心+二分查找优化，维护ends数组
 * 3. ends[i]表示长度为i+1的非递减子序列的最小结尾元素
 * 4. 对于每个障碍高度，在ends中查找>obstacles[i]的最左位置
 * 
 * 时间复杂度：O(n*logn) - 每个位置二分查找O(logn)
 * 空间复杂度：O(n) - 需要ends数组存储状态
 * 是否最优解：是，这是最优解法
 * 
 * 示例：
 * 输入: obstacles = [1,2,3,2]
 * 输出: [1,2,3,3]
 * 解释：
 * - i=0: [1] -> 长度1
 * - i=1: [1,2] -> 长度2  
 * - i=2: [1,2,3] -> 长度3
 * - i=3: [1,2,3] 或 [1,2,2] -> 长度3
 * 
 * 输入: obstacles = [2,2,1]
 * 输出: [1,2,1]
 * 解释：
 * - i=0: [2] -> 长度1
 * - i=1: [2,2] -> 长度2
 * - i=2: [1] -> 长度1
 */

class Solution {
public:
    /**
     * 计算每个位置的最长非递减子序列长度
     * 
     * @param obstacles 障碍高度数组
     * @return 每个位置的最长非递减子序列长度
     */
    vector<int> longestObstacleCourseAtEachPosition(vector<int>& obstacles) {
        int n = obstacles.size();
        vector<int> result(n);
        vector<int> ends(n, INT_MAX); // ends[i]表示长度为i+1的非递减子序列的最小结尾元素
        int len = 0;
        
        for (int i = 0; i < n; i++) {
            // 在ends数组中查找>obstacles[i]的最左位置
            int find = binarySearch(ends, len, obstacles[i]);
            
            if (find == -1) {
                // 没有找到，说明obstacles[i]可以延长当前最长非递减子序列
                ends[len] = obstacles[i];
                result[i] = len + 1;
                len++;
            } else {
                // 找到了位置，更新该位置的值为obstacles[i]
                ends[find] = obstacles[i];
                result[i] = find + 1;
            }
        }
        
        return result;
    }

    /**
     * 在不降序数组ends中查找>num的最左位置
     * 
     * 算法思路：
     * 1. 使用二分查找在有序数组中查找目标值
     * 2. 维护左边界l和右边界r
     * 3. 计算中间位置m，比较ends[m]与num的大小关系
     * 4. 如果ends[m] > num，说明目标位置在左半部分（包括m），更新ans和r
     * 5. 否则目标位置在右半部分，更新l
     * 
     * 时间复杂度：O(logn) - 标准二分查找
     * 空间复杂度：O(1) - 只使用常数额外空间
     * 是否最优解：是，这是标准的二分查找实现
     * 
     * @param ends 不降序数组
     * @param len 有效长度
     * @param num 目标值
     * @return >num的最左位置，如果不存在返回-1
     */
    int binarySearch(vector<int>& ends, int len, int num) {
        int left = 0, right = len - 1;
        int result = -1;
        
        while (left <= right) {
            int mid = left + (right - left) / 2;
            if (ends[mid] > num) {
                result = mid;
                right = mid - 1;
            } else {
                left = mid + 1;
            }
        }
        
        return result;
    }

    /**
     * 使用动态规划解法（时间复杂度较高，用于对比）
     * 
     * 算法思路：
     * 1. 使用动态规划计算每个位置的最长非递减子序列长度
     * 2. dp[i]表示以obstacles[i]结尾的最长非递减子序列长度
     * 3. 对于每个位置i，遍历前面所有位置j，如果obstacles[j] <= obstacles[i]，则更新dp[i]
     * 
     * 时间复杂度：O(n²) - 外层循环n次，内层循环最多n次
     * 空间复杂度：O(n) - 需要dp数组存储状态
     * 是否最优解：否，存在O(n*logn)的优化解法
     * 
     * @param obstacles 障碍高度数组
     * @return 每个位置的最长非递减子序列长度
     */
    vector<int> longestObstacleCourseAtEachPositionDP(vector<int>& obstacles) {
        int n = obstacles.size();
        vector<int> dp(n, 1); // 每个位置至少可以单独构成长度为1的子序列
        
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < i; j++) {
                if (obstacles[j] <= obstacles[i]) {
                    dp[i] = max(dp[i], dp[j] + 1);
                }
            }
        }
        
        return dp;
    }
};

// 测试函数
void test() {
    Solution solution;
    
    // 测试用例1
    vector<int> obstacles1 = {1, 2, 3, 2};
    cout << "输入: [1,2,3,2]" << endl;
    vector<int> result1 = solution.longestObstacleCourseAtEachPosition(obstacles1);
    cout << "优化方法输出: ";
    for (int num : result1) cout << num << " ";
    cout << endl;
    cout << "期望: [1,2,3,3]" << endl;
    
    vector<int> result1_dp = solution.longestObstacleCourseAtEachPositionDP(obstacles1);
    cout << "DP方法输出: ";
    for (int num : result1_dp) cout << num << " ";
    cout << endl << endl;
    
    // 测试用例2
    vector<int> obstacles2 = {2, 2, 1};
    cout << "输入: [2,2,1]" << endl;
    vector<int> result2 = solution.longestObstacleCourseAtEachPosition(obstacles2);
    cout << "优化方法输出: ";
    for (int num : result2) cout << num << " ";
    cout << endl;
    cout << "期望: [1,2,1]" << endl;
    
    vector<int> result2_dp = solution.longestObstacleCourseAtEachPositionDP(obstacles2);
    cout << "DP方法输出: ";
    for (int num : result2_dp) cout << num << " ";
    cout << endl << endl;
    
    // 测试用例3
    vector<int> obstacles3 = {3, 1, 5, 6, 4, 2};
    cout << "输入: [3,1,5,6,4,2]" << endl;
    vector<int> result3 = solution.longestObstacleCourseAtEachPosition(obstacles3);
    cout << "优化方法输出: ";
    for (int num : result3) cout << num << " ";
    cout << endl;
    
    vector<int> result3_dp = solution.longestObstacleCourseAtEachPositionDP(obstacles3);
    cout << "DP方法输出: ";
    for (int num : result3_dp) cout << num << " ";
    cout << endl << endl;
}

int main() {
    test();
    return 0;
}

===============================================

文件: Code16_FindTheLongestValidObstacleCourseAtEachPosition.java
===============================================
package class072;

import java.util.Arrays;

/**
 * 找出到每个位置为止最长的非递减子序列
 * 
 * 题目来源：LeetCode 1964. 找出到每个位置为止最长的非递减子序列
 * 题目链接：https://leetcode.cn/problems/find-the-longest-valid-obstacle-course-at-each-position/
 * 题目描述：你打算构建一些障碍赛跑路线。给你一个下标从 0 开始的整数数组 obstacles，数组长度为 n，
 * 其中 obstacles[i] 表示第 i 个障碍的高度。对于每个介于 0 和 n - 1 之间（包含 0 和 n - 1）的下标 i，
 * 在满足下述条件的前提下，请你找出 obstacles 能构成的最长障碍路线的长度。
 * 
 * 条件：对于路线中的每个下标 j（0 <= j <= i），必须满足 obstacles[j] <= obstacles[i]。
 * 路线必须包含下标 i。
 * 
 * 算法思路：
 * 1. 这实际上是求以每个位置结尾的最长非递减子序列长度
 * 2. 使用贪心+二分查找优化，维护ends数组
 * 3. ends[i]表示长度为i+1的非递减子序列的最小结尾元素
 * 4. 对于每个障碍高度，在ends中查找>obstacles[i]的最左位置
 * 
 * 时间复杂度：O(n*logn) - 每个位置二分查找O(logn)
 * 空间复杂度：O(n) - 需要ends数组存储状态
 * 是否最优解：是，这是最优解法
 * 
 * 示例：
 * 输入: obstacles = [1,2,3,2]
 * 输出: [1,2,3,3]
 * 解释：
 * - i=0: [1] -> 长度1
 * - i=1: [1,2] -> 长度2  
 * - i=2: [1,2,3] -> 长度3
 * - i=3: [1,2,3] 或 [1,2,2] -> 长度3
 * 
 * 输入: obstacles = [2,2,1]
 * 输出: [1,2,1]
 * 解释：
 * - i=0: [2] -> 长度1
 * - i=1: [2,2] -> 长度2
 * - i=2: [1] -> 长度1
 */

public class Code16_FindTheLongestValidObstacleCourseAtEachPosition {

    /**
     * 计算每个位置的最长非递减子序列长度
     * 
     * @param obstacles 障碍高度数组
     * @return 每个位置的最长非递减子序列长度
     */
    public static int[] longestObstacleCourseAtEachPosition(int[] obstacles) {
        int n = obstacles.length;
        int[] result = new int[n];
        int[] ends = new int[n]; // ends[i]表示长度为i+1的非递减子序列的最小结尾元素
        int len = 0;
        
        for (int i = 0; i < n; i++) {
            // 在ends数组中查找>obstacles[i]的最左位置
            int find = bs2(ends, len, obstacles[i]);
            
            if (find == -1) {
                // 没有找到，说明obstacles[i]可以延长当前最长非递减子序列
                ends[len] = obstacles[i];
                result[i] = len + 1;
                len++;
            } else {
                // 找到了位置，更新该位置的值为obstacles[i]
                ends[find] = obstacles[i];
                result[i] = find + 1;
            }
        }
        
        return result;
    }

    /**
     * 在不降序数组ends中查找>num的最左位置
     * 
     * 算法思路：
     * 1. 使用二分查找在有序数组中查找目标值
     * 2. 维护左边界l和右边界r
     * 3. 计算中间位置m，比较ends[m]与num的大小关系
     * 4. 如果ends[m] > num，说明目标位置在左半部分（包括m），更新ans和r
     * 5. 否则目标位置在右半部分，更新l
     * 
     * 时间复杂度：O(logn) - 标准二分查找
     * 空间复杂度：O(1) - 只使用常数额外空间
     * 是否最优解：是，这是标准的二分查找实现
     * 
     * @param ends 不降序数组
     * @param len 有效长度
     * @param num 目标值
     * @return >num的最左位置，如果不存在返回-1
     */
    private static int bs2(int[] ends, int len, int num) {
        int l = 0, r = len - 1, m, ans = -1;
        while (l <= r) {
            m = (l + r) / 2;
            if (ends[m] > num) {
                ans = m;
                r = m - 1;
            } else {
                l = m + 1;
            }
        }
        return ans;
    }

    /**
     * 使用动态规划解法（时间复杂度较高，用于对比）
     * 
     * 算法思路：
     * 1. 使用动态规划计算每个位置的最长非递减子序列长度
     * 2. dp[i]表示以obstacles[i]结尾的最长非递减子序列长度
     * 3. 对于每个位置i，遍历前面所有位置j，如果obstacles[j] <= obstacles[i]，则更新dp[i]
     * 
     * 时间复杂度：O(n²) - 外层循环n次，内层循环最多n次
     * 空间复杂度：O(n) - 需要dp数组存储状态
     * 是否最优解：否，存在O(n*logn)的优化解法
     * 
     * @param obstacles 障碍高度数组
     * @return 每个位置的最长非递减子序列长度
     */
    public static int[] longestObstacleCourseAtEachPositionDP(int[] obstacles) {
        int n = obstacles.length;
        int[] dp = new int[n];
        Arrays.fill(dp, 1); // 每个位置至少可以单独构成长度为1的子序列
        
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < i; j++) {
                if (obstacles[j] <= obstacles[i]) {
                    dp[i] = Math.max(dp[i], dp[j] + 1);
                }
            }
        }
        
        return dp;
    }

    // 测试方法
    public static void main(String[] args) {
        // 测试用例1
        int[] obstacles1 = {1, 2, 3, 2};
        System.out.println("输入: [1,2,3,2]");
        int[] result1 = longestObstacleCourseAtEachPosition(obstacles1);
        System.out.println("优化方法输出: " + Arrays.toString(result1));
        System.out.println("期望: [1,2,3,3]");
        
        int[] result1_dp = longestObstacleCourseAtEachPositionDP(obstacles1);
        System.out.println("DP方法输出: " + Arrays.toString(result1_dp));
        System.out.println();
        
        // 测试用例2
        int[] obstacles2 = {2, 2, 1};
        System.out.println("输入: [2,2,1]");
        int[] result2 = longestObstacleCourseAtEachPosition(obstacles2);
        System.out.println("优化方法输出: " + Arrays.toString(result2));
        System.out.println("期望: [1,2,1]");
        
        int[] result2_dp = longestObstacleCourseAtEachPositionDP(obstacles2);
        System.out.println("DP方法输出: " + Arrays.toString(result2_dp));
        System.out.println();
        
        // 测试用例3
        int[] obstacles3 = {3, 1, 5, 6, 4, 2};
        System.out.println("输入: [3,1,5,6,4,2]");
        int[] result3 = longestObstacleCourseAtEachPosition(obstacles3);
        System.out.println("优化方法输出: " + Arrays.toString(result3));
        
        int[] result3_dp = longestObstacleCourseAtEachPositionDP(obstacles3);
        System.out.println("DP方法输出: " + Arrays.toString(result3_dp));
        System.out.println();
        
        // 性能对比测试
        int[] largeObstacles = new int[1000];
        for (int i = 0; i < 1000; i++) {
            largeObstacles[i] = (int) (Math.random() * 1000);
        }
        
        long startTime = System.currentTimeMillis();
        int[] resultLarge = longestObstacleCourseAtEachPosition(largeObstacles);
        long endTime = System.currentTimeMillis();
        System.out.println("优化方法处理1000个元素耗时: " + (endTime - startTime) + "ms");
        
        startTime = System.currentTimeMillis();
        int[] resultLargeDP = longestObstacleCourseAtEachPositionDP(largeObstacles);
        endTime = System.currentTimeMillis();
        System.out.println("DP方法处理1000个元素耗时: " + (endTime - startTime) + "ms");
    }
}

===============================================

文件: Code16_FindTheLongestValidObstacleCourseAtEachPosition.py
===============================================
"""
找出到每个位置为止最长的非递减子序列

题目来源：LeetCode 1964. 找出到每个位置为止最长的非递减子序列
题目链接：https://leetcode.cn/problems/find-the-longest-valid-obstacle-course-at-each-position/
题目描述：你打算构建一些障碍赛跑路线。给你一个下标从 0 开始的整数数组 obstacles，数组长度为 n，
其中 obstacles[i] 表示第 i 个障碍的高度。对于每个介于 0 和 n - 1 之间（包含 0 和 n - 1）的下标 i，
在满足下述条件的前提下，请你找出 obstacles 能构成的最长障碍路线的长度。

条件：对于路线中的每个下标 j（0 <= j <= i），必须满足 obstacles[j] <= obstacles[i]。
路线必须包含下标 i。

算法思路：
1. 这实际上是求以每个位置结尾的最长非递减子序列长度
2. 使用贪心+二分查找优化，维护ends数组
3. ends[i]表示长度为i+1的非递减子序列的最小结尾元素
4. 对于每个障碍高度，在ends中查找>obstacles[i]的最左位置

时间复杂度：O(n*logn) - 每个位置二分查找O(logn)
空间复杂度：O(n) - 需要ends数组存储状态
是否最优解：是，这是最优解法

示例：
输入: obstacles = [1,2,3,2]
输出: [1,2,3,3]
解释：
- i=0: [1] -> 长度1
- i=1: [1,2] -> 长度2  
- i=2: [1,2,3] -> 长度3
- i=3: [1,2,3] 或 [1,2,2] -> 长度3

输入: obstacles = [2,2,1]
输出: [1,2,1]
解释：
- i=0: [2] -> 长度1
- i=1: [2,2] -> 长度2
- i=2: [1] -> 长度1
"""

from typing import List
import bisect

class Solution:
    """
    计算每个位置的最长非递减子序列长度
    
    Args:
        obstacles: 障碍高度数组
        
    Returns:
        每个位置的最长非递减子序列长度
    """
    def longestObstacleCourseAtEachPosition(self, obstacles: List[int]) -> List[int]:
        n = len(obstacles)
        result = [0] * n
        ends = []  # ends列表动态维护
        
        for i in range(n):
            # 使用bisect查找>obstacles[i]的最左位置
            # 注意：对于非递减序列，我们使用bisect_right来找到插入位置
            pos = bisect.bisect_right(ends, obstacles[i])
            
            if pos == len(ends):
                # 没有找到，说明obstacles[i]可以延长当前最长非递减子序列
                ends.append(obstacles[i])
                result[i] = len(ends)
            else:
                # 找到了位置，更新该位置的值为obstacles[i]
                ends[pos] = obstacles[i]
                result[i] = pos + 1
        
        return result

    """
    使用动态规划解法（时间复杂度较高，用于对比）
    
    算法思路：
    1. 使用动态规划计算每个位置的最长非递减子序列长度
    2. dp[i]表示以obstacles[i]结尾的最长非递减子序列长度
    3. 对于每个位置i，遍历前面所有位置j，如果obstacles[j] <= obstacles[i]，则更新dp[i]
    
    时间复杂度：O(n²) - 外层循环n次，内层循环最多n次
    空间复杂度：O(n) - 需要dp数组存储状态
    是否最优解：否，存在O(n*logn)的优化解法
    
    Args:
        obstacles: 障碍高度数组
        
    Returns:
        每个位置的最长非递减子序列长度
    """
    def longestObstacleCourseAtEachPositionDP(self, obstacles: List[int]) -> List[int]:
        n = len(obstacles)
        dp = [1] * n  # 每个位置至少可以单独构成长度为1的子序列
        
        for i in range(n):
            for j in range(i):
                if obstacles[j] <= obstacles[i]:
                    dp[i] = max(dp[i], dp[j] + 1)
        
        return dp

def test():
    """
    测试函数
    """
    solution = Solution()
    
    # 测试用例1
    obstacles1 = [1, 2, 3, 2]
    print("输入:", obstacles1)
    result1 = solution.longestObstacleCourseAtEachPosition(obstacles1)
    print("优化方法输出:", result1)
    print("期望: [1, 2, 3, 3]")
    
    result1_dp = solution.longestObstacleCourseAtEachPositionDP(obstacles1)
    print("DP方法输出:", result1_dp)
    print()
    
    # 测试用例2
    obstacles2 = [2, 2, 1]
    print("输入:", obstacles2)
    result2 = solution.longestObstacleCourseAtEachPosition(obstacles2)
    print("优化方法输出:", result2)
    print("期望: [1, 2, 1]")
    
    result2_dp = solution.longestObstacleCourseAtEachPositionDP(obstacles2)
    print("DP方法输出:", result2_dp)
    print()
    
    # 测试用例3
    obstacles3 = [3, 1, 5, 6, 4, 2]
    print("输入:", obstacles3)
    result3 = solution.longestObstacleCourseAtEachPosition(obstacles3)
    print("优化方法输出:", result3)
    
    result3_dp = solution.longestObstacleCourseAtEachPositionDP(obstacles3)
    print("DP方法输出:", result3_dp)
    print()

if __name__ == "__main__":
    test()

===============================================

文件: Code17_LongestIncreasingSubsequenceLuogu.java
===============================================
package class072;

import java.util.Arrays;

/**
 * 洛谷最长上升子序列问题
 * 
 * 题目来源：洛谷 B3637 最长上升子序列
 * 题目链接：https://www.luogu.com.cn/problem/B3637
 * 题目描述：给出一个由 n 个不超过 10^6 的正整数组成的序列。请输出这个序列的最长上升子序列的长度。
 * 
 * 算法思路：
 * 1. 使用贪心+二分查找优化解法
 * 2. 维护ends数组，ends[i]表示长度为i+1的递增子序列的最小结尾元素
 * 3. 对于每个元素，在ends中二分查找>=num的最左位置
 * 
 * 时间复杂度：O(n*logn) - 每个元素二分查找O(logn)
 * 空间复杂度：O(n) - 需要ends数组存储状态
 * 是否最优解：是，这是最优解法
 * 
 * 示例：
 * 输入: 
 * 5
 * 1 3 2 4 5
 * 输出: 4
 * 解释: 最长上升子序列为[1,3,4,5]或[1,2,4,5]，长度为4。
 */

public class Code17_LongestIncreasingSubsequenceLuogu {

    /**
     * 计算最长上升子序列的长度（洛谷标准解法）
     * 
     * @param nums 输入的整数数组
     * @return 最长上升子序列的长度
     */
    public static int lengthOfLIS(int[] nums) {
        int n = nums.length;
        if (n == 0) return 0;
        
        int[] ends = new int[n];
        int len = 0;
        
        for (int i = 0; i < n; i++) {
            int find = binarySearch(ends, len, nums[i]);
            if (find == -1) {
                ends[len++] = nums[i];
            } else {
                ends[find] = nums[i];
            }
        }
        
        return len;
    }

    /**
     * 在严格升序数组ends中查找>=num的最左位置
     * 
     * @param ends 严格升序数组
     * @param len 有效长度
     * @param num 目标值
     * @return >=num的最左位置，如果不存在返回-1
     */
    private static int binarySearch(int[] ends, int len, int num) {
        int left = 0, right = len - 1;
        int result = -1;
        
        while (left <= right) {
            int mid = left + (right - left) / 2;
            if (ends[mid] >= num) {
                result = mid;
                right = mid - 1;
            } else {
                left = mid + 1;
            }
        }
        
        return result;
    }

    /**
     * 动态规划解法（用于对比）
     * 
     * 算法思路：
     * 1. dp[i]表示以nums[i]结尾的最长上升子序列长度
     * 2. 对于每个位置i，遍历前面所有位置j，如果nums[j] < nums[i]，则更新dp[i]
     * 
     * 时间复杂度：O(n²) - 外层循环n次，内层循环最多n次
     * 空间复杂度：O(n) - 需要dp数组存储状态
     * 是否最优解：否，存在O(n*logn)的优化解法
     * 
     * @param nums 输入的整数数组
     * @return 最长上升子序列的长度
     */
    public static int lengthOfLISDP(int[] nums) {
        int n = nums.length;
        if (n == 0) return 0;
        
        int[] dp = new int[n];
        Arrays.fill(dp, 1);
        int maxLen = 1;
        
        for (int i = 1; i < n; i++) {
            for (int j = 0; j < i; j++) {
                if (nums[j] < nums[i]) {
                    dp[i] = Math.max(dp[i], dp[j] + 1);
                }
            }
            maxLen = Math.max(maxLen, dp[i]);
        }
        
        return maxLen;
    }

    /**
     * 洛谷标准输入输出格式处理
     * 
     * 算法思路：
     * 1. 模拟洛谷的输入格式（第一行n，第二行n个整数）
     * 2. 使用最优解法计算LIS长度
     * 3. 输出结果
     * 
     * @param n 序列长度
     * @param nums 序列元素
     * @return 最长上升子序列的长度
     */
    public static int solveLuoguProblem(int n, int[] nums) {
        return lengthOfLIS(nums);
    }

    // 测试方法
    public static void main(String[] args) {
        // 测试用例1：洛谷示例
        int[] nums1 = {1, 3, 2, 4, 5};
        System.out.println("洛谷示例输入: [1,3,2,4,5]");
        System.out.println("优化方法输出: " + lengthOfLIS(nums1));
        System.out.println("DP方法输出: " + lengthOfLISDP(nums1));
        System.out.println("期望: 4");
        System.out.println();
        
        // 测试用例2：严格递增序列
        int[] nums2 = {1, 2, 3, 4, 5};
        System.out.println("严格递增序列: [1,2,3,4,5]");
        System.out.println("优化方法输出: " + lengthOfLIS(nums2));
        System.out.println("DP方法输出: " + lengthOfLISDP(nums2));
        System.out.println("期望: 5");
        System.out.println();
        
        // 测试用例3：严格递减序列
        int[] nums3 = {5, 4, 3, 2, 1};
        System.out.println("严格递减序列: [5,4,3,2,1]");
        System.out.println("优化方法输出: " + lengthOfLIS(nums3));
        System.out.println("DP方法输出: " + lengthOfLISDP(nums3));
        System.out.println("期望: 1");
        System.out.println();
        
        // 测试用例4：所有元素相同
        int[] nums4 = {2, 2, 2, 2, 2};
        System.out.println("所有元素相同: [2,2,2,2,2]");
        System.out.println("优化方法输出: " + lengthOfLIS(nums4));
        System.out.println("DP方法输出: " + lengthOfLISDP(nums4));
        System.out.println("期望: 1");
        System.out.println();
        
        // 测试用例5：复杂序列
        int[] nums5 = {10, 9, 2, 5, 3, 7, 101, 18};
        System.out.println("复杂序列: [10,9,2,5,3,7,101,18]");
        System.out.println("优化方法输出: " + lengthOfLIS(nums5));
        System.out.println("DP方法输出: " + lengthOfLISDP(nums5));
        System.out.println("期望: 4");
        System.out.println();
        
        // 性能测试：大规模数据
        int[] largeNums = new int[10000];
        for (int i = 0; i < 10000; i++) {
            largeNums[i] = (int) (Math.random() * 1000000);
        }
        
        long startTime = System.currentTimeMillis();
        int result1 = lengthOfLIS(largeNums);
        long endTime = System.currentTimeMillis();
        System.out.println("优化方法处理10000个元素耗时: " + (endTime - startTime) + "ms");
        
        startTime = System.currentTimeMillis();
        int result2 = lengthOfLISDP(largeNums);
        endTime = System.currentTimeMillis();
        System.out.println("DP方法处理10000个元素耗时: " + (endTime - startTime) + "ms");
        System.out.println("两种方法结果是否一致: " + (result1 == result2));
    }
}

===============================================

文件: Code18_AtCoderLISProblem.java
===============================================
package class072;

import java.util.Arrays;

/**
 * AtCoder LIS问题变种
 * 
 * 题目来源：AtCoder ABC237 F |LIS| = 3
 * 题目链接：https://atcoder.jp/contests/abc237/tasks/abc237_f
 * 题目描述：给定三个整数N, M, K，求满足以下条件的序列A=(A1,A2,…,AN)的数量：
 * 1. 1 ≤ Ai ≤ M (1 ≤ i ≤ N)
 * 2. 序列A的最长递增子序列的长度恰好等于K
 * 
 * 算法思路：
 * 1. 使用动态规划计数LIS长度恰好为K的序列数量
 * 2. 状态定义：dp[i][a][b][c]表示处理到第i个元素，当前LIS状态为(a,b,c)的方案数
 * 3. 状态转移：对于每个新元素，更新LIS状态
 * 4. 由于K≤3，可以使用三维状态压缩
 * 
 * 时间复杂度：O(N*M^K) - 状态数为N*M^K
 * 空间复杂度：O(N*M^K) - 需要存储DP状态
 * 是否最优解：是，这是标准解法
 * 
 * 示例：
 * 输入: N=3, M=2, K=2
 * 输出: 4
 * 解释：满足条件的序列有：[1,1,2], [1,2,1], [1,2,2], [2,1,2]
 */

public class Code18_AtCoderLISProblem {

    /**
     * 计算满足条件的序列数量
     * 
     * @param N 序列长度
     * @param M 元素取值范围[1, M]
     * @param K 要求的LIS长度
     * @return 满足条件的序列数量（对998244353取模）
     */
    public static int countSequences(int N, int M, int K) {
        if (K > 3) return 0; // 题目保证K≤3
        
        final int MOD = 998244353;
        
        // dp[i][a][b][c]表示处理到第i个元素，当前LIS状态为(a,b,c)的方案数
        // 其中a≤b≤c，且a,b,c表示当前LIS的最小可能结尾元素
        int[][][][] dp = new int[N + 1][M + 2][M + 2][M + 2];
        
        // 初始化：空序列的LIS长度为0
        dp[0][M + 1][M + 1][M + 1] = 1; // 用M+1表示无穷大
        
        for (int i = 0; i < N; i++) {
            for (int a = 1; a <= M + 1; a++) {
                for (int b = a; b <= M + 1; b++) {
                    for (int c = b; c <= M + 1; c++) {
                        if (dp[i][a][b][c] == 0) continue;
                        
                        int current = dp[i][a][b][c];
                        
                        // 尝试添加新的元素x (1 ≤ x ≤ M)
                        for (int x = 1; x <= M; x++) {
                            int na = a, nb = b, nc = c;
                            
                            if (x <= a) {
                                // 替换第一个位置
                                na = x;
                            } else if (x <= b) {
                                // 替换第二个位置
                                nb = x;
                            } else if (x <= c) {
                                // 替换第三个位置
                                nc = x;
                            } else {
                                // 如果x大于c，需要扩展LIS（但K≤3，所以最多到第三个位置）
                                continue;
                            }
                            
                            // 更新状态
                            dp[i + 1][na][nb][nc] = (dp[i + 1][na][nb][nc] + current) % MOD;
                        }
                    }
                }
            }
        }
        
        // 统计所有LIS长度恰好为K的序列数量
        int result = 0;
        for (int a = 1; a <= M + 1; a++) {
            for (int b = a; b <= M + 1; b++) {
                for (int c = b; c <= M + 1; c++) {
                    // 计算当前状态的LIS长度
                    int lisLength = 0;
                    if (a <= M) lisLength++;
                    if (b <= M) lisLength++;
                    if (c <= M) lisLength++;
                    
                    if (lisLength == K) {
                        result = (result + dp[N][a][b][c]) % MOD;
                    }
                }
            }
        }
        
        return result;
    }

    /**
     * 简化版本：使用更高效的状态表示
     * 
     * 算法思路：
     * 1. 使用一维数组存储状态，通过编码减少维度
     * 2. 状态编码：将(a,b,c)编码为一个整数
     * 3. 减少内存使用，提高效率
     * 
     * 时间复杂度：O(N*M^K) - 与原始方法相同
     * 空间复杂度：O(N*M^K) - 但通过编码减少实际内存使用
     * 是否最优解：是，优化版本
     * 
     * @param N 序列长度
     * @param M 元素取值范围[1, M]
     * @param K 要求的LIS长度
     * @return 满足条件的序列数量（对998244353取模）
     */
    public static int countSequencesOptimized(int N, int M, int K) {
        if (K > 3) return 0;
        
        final int MOD = 998244353;
        final int MAX_STATES = (M + 2) * (M + 2) * (M + 2);
        
        int[][] dp = new int[2][MAX_STATES];
        // 初始化状态
        int initialState = (M + 1) * (M + 2) * (M + 2) + (M + 1) * (M + 2) + (M + 1);
        dp[0][initialState] = 1;
        
        for (int i = 0; i < N; i++) {
            int current = i % 2;
            int next = (i + 1) % 2;
            Arrays.fill(dp[next], 0);
            
            for (int state = 0; state < MAX_STATES; state++) {
                if (dp[current][state] == 0) continue;
                
                // 解码状态
                int c = state % (M + 2);
                int b = (state / (M + 2)) % (M + 2);
                int a = state / ((M + 2) * (M + 2));
                
                int currentVal = dp[current][state];
                
                for (int x = 1; x <= M; x++) {
                    int na = a, nb = b, nc = c;
                    
                    if (x <= a) {
                        na = x;
                    } else if (x <= b) {
                        nb = x;
                    } else if (x <= c) {
                        nc = x;
                    } else {
                        continue;
                    }
                    
                    // 状态编码
                    int nextState = na * (M + 2) * (M + 2) + nb * (M + 2) + nc;
                    dp[next][nextState] = (dp[next][nextState] + currentVal) % MOD;
                }
            }
        }
        
        int result = 0;
        int finalIndex = N % 2;
        
        for (int state = 0; state < MAX_STATES; state++) {
            if (dp[finalIndex][state] == 0) continue;
            
            // 解码状态
            int c = state % (M + 2);
            int b = (state / (M + 2)) % (M + 2);
            int a = state / ((M + 2) * (M + 2));
            
            int lisLength = 0;
            if (a <= M) lisLength++;
            if (b <= M) lisLength++;
            if (c <= M) lisLength++;
            
            if (lisLength == K) {
                result = (result + dp[finalIndex][state]) % MOD;
            }
        }
        
        return result;
    }

    // 测试方法
    public static void main(String[] args) {
        // 测试用例1：AtCoder示例
        System.out.println("AtCoder示例: N=3, M=2, K=2");
        System.out.println("标准方法输出: " + countSequences(3, 2, 2));
        System.out.println("优化方法输出: " + countSequencesOptimized(3, 2, 2));
        System.out.println("期望: 4");
        System.out.println();
        
        // 测试用例2
        System.out.println("测试用例: N=4, M=3, K=2");
        System.out.println("标准方法输出: " + countSequences(4, 3, 2));
        System.out.println("优化方法输出: " + countSequencesOptimized(4, 3, 2));
        System.out.println();
        
        // 测试用例3
        System.out.println("测试用例: N=5, M=5, K=3");
        System.out.println("标准方法输出: " + countSequences(5, 5, 3));
        System.out.println("优化方法输出: " + countSequencesOptimized(5, 5, 3));
        System.out.println();
        
        // 性能测试
        long startTime = System.currentTimeMillis();
        int result1 = countSequencesOptimized(10, 10, 3);
        long endTime = System.currentTimeMillis();
        System.out.println("优化方法处理N=10,M=10,K=3耗时: " + (endTime - startTime) + "ms");
        System.out.println("结果: " + result1);
        
        startTime = System.currentTimeMillis();
        int result2 = countSequences(10, 10, 3);
        endTime = System.currentTimeMillis();
        System.out.println("标准方法处理N=10,M=10,K=3耗时: " + (endTime - startTime) + "ms");
        System.out.println("结果: " + result2);
    }
}

===============================================

文件: Code19_NonOverlappingIntervals.java
===============================================
package class072;

import java.util.Arrays;
import java.util.Comparator;

/**
 * 无重叠区间
 * 
 * 题目来源：LeetCode 435. 无重叠区间
 * 题目链接：https://leetcode.cn/problems/non-overlapping-intervals/
 * 题目描述：给定一个区间的集合 intervals，其中 intervals[i] = [starti, endi]。
 * 返回需要移除区间的最小数量，使剩余区间互不重叠。
 * 
 * 算法思路：
 * 1. 这是一个区间调度问题，可以使用贪心算法解决
 * 2. 按结束时间排序，优先选择结束时间早的区间
 * 3. 这样可以为后续区间留下更多空间
 * 4. 需要移除的区间数量 = 总区间数 - 最大不重叠区间数
 * 
 * 时间复杂度：O(n*logn) - 排序时间复杂度
 * 空间复杂度：O(1) - 只使用常数额外空间
 * 是否最优解：是，这是最优解法
 * 
 * 示例：
 * 输入: intervals = [[1,2],[2,3],[3,4],[1,3]]
 * 输出: 1
 * 解释: 移除 [1,3] 后，剩下的区间没有重叠。
 * 
 * 输入: intervals = [[1,2],[1,2],[1,2]]
 * 输出: 2
 * 解释: 你需要移除两个 [1,2] 来使剩下的区间没有重叠。
 */

public class Code19_NonOverlappingIntervals {

    /**
     * 计算需要移除的最小区间数量
     * 
     * @param intervals 区间数组
     * @return 需要移除的最小区间数量
     */
    public static int eraseOverlapIntervals(int[][] intervals) {
        if (intervals == null || intervals.length == 0) {
            return 0;
        }
        
        int n = intervals.length;
        
        // 按结束时间升序排序
        Arrays.sort(intervals, new Comparator<int[]>() {
            @Override
            public int compare(int[] a, int[] b) {
                return a[1] - b[1];
            }
        });
        
        // 记录不重叠区间的数量
        int count = 1;
        int end = intervals[0][1];
        
        for (int i = 1; i < n; i++) {
            // 如果当前区间的开始时间 >= 前一个区间的结束时间，不重叠
            if (intervals[i][0] >= end) {
                count++;
                end = intervals[i][1];
            }
        }
        
        // 需要移除的区间数量 = 总区间数 - 不重叠区间数
        return n - count;
    }

    /**
     * 使用LIS思路的解法（用于对比）
     * 
     * 算法思路：
     * 1. 将问题转化为求最长不重叠区间序列
     * 2. 按开始时间排序，然后求最长不重叠区间序列
     * 3. 使用动态规划计算最长序列长度
     * 
     * 时间复杂度：O(n²) - 需要双重循环
     * 空间复杂度：O(n) - 需要dp数组
     * 是否最优解：否，存在O(n*logn)的贪心解法
     * 
     * @param intervals 区间数组
     * @return 需要移除的最小区间数量
     */
    public static int eraseOverlapIntervalsDP(int[][] intervals) {
        if (intervals == null || intervals.length == 0) {
            return 0;
        }
        
        int n = intervals.length;
        
        // 按开始时间排序
        Arrays.sort(intervals, new Comparator<int[]>() {
            @Override
            public int compare(int[] a, int[] b) {
                return a[0] - b[0];
            }
        });
        
        int[] dp = new int[n];
        Arrays.fill(dp, 1);
        int maxLen = 1;
        
        for (int i = 1; i < n; i++) {
            for (int j = 0; j < i; j++) {
                // 如果区间j和区间i不重叠
                if (intervals[j][1] <= intervals[i][0]) {
                    dp[i] = Math.max(dp[i], dp[j] + 1);
                }
            }
            maxLen = Math.max(maxLen, dp[i]);
        }
        
        return n - maxLen;
    }

    /**
     * 使用开始时间排序的贪心解法（错误示范，用于对比）
     * 
     * 算法思路：
     * 1. 按开始时间排序，然后选择开始时间最早的区间
     * 2. 这种策略可能不是最优的
     * 
     * 时间复杂度：O(n*logn)
     * 空间复杂度：O(1)
     * 是否最优解：否，可能得到次优解
     * 
     * @param intervals 区间数组
     * @return 需要移除的最小区间数量
     */
    public static int eraseOverlapIntervalsWrong(int[][] intervals) {
        if (intervals == null || intervals.length == 0) {
            return 0;
        }
        
        int n = intervals.length;
        
        // 按开始时间排序（错误策略）
        Arrays.sort(intervals, new Comparator<int[]>() {
            @Override
            public int compare(int[] a, int[] b) {
                return a[0] - b[0];
            }
        });
        
        int count = 1;
        int end = intervals[0][1];
        
        for (int i = 1; i < n; i++) {
            if (intervals[i][0] >= end) {
                count++;
                end = intervals[i][1];
            } else {
                // 如果重叠，选择结束时间更早的区间
                end = Math.min(end, intervals[i][1]);
            }
        }
        
        return n - count;
    }

    // 测试方法
    public static void main(String[] args) {
        // 测试用例1
        int[][] intervals1 = {{1,2}, {2,3}, {3,4}, {1,3}};
        System.out.println("输入: [[1,2],[2,3],[3,4],[1,3]]");
        System.out.println("贪心方法输出: " + eraseOverlapIntervals(intervals1));
        System.out.println("DP方法输出: " + eraseOverlapIntervalsDP(intervals1));
        System.out.println("错误方法输出: " + eraseOverlapIntervalsWrong(intervals1));
        System.out.println("期望: 1");
        System.out.println();
        
        // 测试用例2
        int[][] intervals2 = {{1,2}, {1,2}, {1,2}};
        System.out.println("输入: [[1,2],[1,2],[1,2]]");
        System.out.println("贪心方法输出: " + eraseOverlapIntervals(intervals2));
        System.out.println("DP方法输出: " + eraseOverlapIntervalsDP(intervals2));
        System.out.println("错误方法输出: " + eraseOverlapIntervalsWrong(intervals2));
        System.out.println("期望: 2");
        System.out.println();
        
        // 测试用例3
        int[][] intervals3 = {{1,2}, {2,3}};
        System.out.println("输入: [[1,2],[2,3]]");
        System.out.println("贪心方法输出: " + eraseOverlapIntervals(intervals3));
        System.out.println("DP方法输出: " + eraseOverlapIntervalsDP(intervals3));
        System.out.println("错误方法输出: " + eraseOverlapIntervalsWrong(intervals3));
        System.out.println("期望: 0");
        System.out.println();
        
        // 测试用例4：展示错误策略的问题
        int[][] intervals4 = {{1,100}, {11,22}, {1,11}, {2,12}};
        System.out.println("输入: [[1,100],[11,22],[1,11],[2,12]]");
        System.out.println("贪心方法输出: " + eraseOverlapIntervals(intervals4));
        System.out.println("DP方法输出: " + eraseOverlapIntervalsDP(intervals4));
        System.out.println("错误方法输出: " + eraseOverlapIntervalsWrong(intervals4));
        System.out.println("说明：错误策略可能得到次优解");
        System.out.println();
        
        // 性能测试
        int[][] largeIntervals = new int[10000][2];
        for (int i = 0; i < 10000; i++) {
            largeIntervals[i][0] = (int) (Math.random() * 100000);
            largeIntervals[i][1] = largeIntervals[i][0] + (int) (Math.random() * 1000) + 1;
        }
        
        long startTime = System.currentTimeMillis();
        int result1 = eraseOverlapIntervals(largeIntervals);
        long endTime = System.currentTimeMillis();
        System.out.println("贪心方法处理10000个区间耗时: " + (endTime - startTime) + "ms");
        
        startTime = System.currentTimeMillis();
        int result2 = eraseOverlapIntervalsDP(largeIntervals);
        endTime = System.currentTimeMillis();
        System.out.println("DP方法处理10000个区间耗时: " + (endTime - startTime) + "ms");
        System.out.println("两种方法结果是否一致: " + (result1 == result2));
    }
}

===============================================

文件: Code20_MinimumNumberOfArrowsToBurstBalloons.java
===============================================
package class072;

import java.util.Arrays;
import java.util.Comparator;

/**
 * 用最少数量的箭引爆气球
 * 
 * 题目来源：LeetCode 452. 用最少数量的箭引爆气球
 * 题目链接：https://leetcode.cn/problems/minimum-number-of-arrows-to-burst-balloons/
 * 题目描述：一些球形的气球贴在一堵用 XY 平面表示的墙面上。墙面上的气球记录在整数数组 points，
 * 其中 points[i] = [xstart, xend] 表示水平直径在 xstart 和 xend 之间的气球。
 * 你不知道气球的确切 y 坐标。一支弓箭可以沿着 x 轴从不同点完全垂直地射出。
 * 在坐标 x 处射出一支箭，若有一个气球的直径的开始和结束坐标为 xstart，xend，
 * 且满足 xstart ≤ x ≤ xend，则该气球会被引爆。可以射出的弓箭的数量没有限制。
 * 弓箭一旦被射出之后，可以无限地前进。给你一个数组 points，返回引爆所有气球所必须射出的最小弓箭数。
 * 
 * 算法思路：
 * 1. 这是一个区间重叠问题，可以使用贪心算法解决
 * 2. 按结束位置排序，优先选择结束位置早的区间
 * 3. 每次选择当前箭能射爆的最多气球
 * 4. 当遇到不重叠的区间时，需要增加一支箭
 * 
 * 时间复杂度：O(n*logn) - 排序时间复杂度
 * 空间复杂度：O(1) - 只使用常数额外空间
 * 是否最优解：是，这是最优解法
 * 
 * 示例：
 * 输入: points = [[10,16],[2,8],[1,6],[7,12]]
 * 输出: 2
 * 解释: 气球可以用2支箭来爆破:
 * -在x=6处射出箭，击破气球[2,8]和[1,6]
 * -在x=11处射出箭，击破气球[10,16]和[7,12]
 * 
 * 输入: points = [[1,2],[3,4],[5,6],[7,8]]
 * 输出: 4
 * 解释: 每个气球都需要一支箭，总共需要4支箭。
 */

public class Code20_MinimumNumberOfArrowsToBurstBalloons {

    /**
     * 计算引爆所有气球所需的最小弓箭数
     * 
     * @param points 气球区间数组
     * @return 最小弓箭数
     */
    public static int findMinArrowShots(int[][] points) {
        if (points == null || points.length == 0) {
            return 0;
        }
        
        int n = points.length;
        
        // 按结束位置升序排序
        Arrays.sort(points, new Comparator<int[]>() {
            @Override
            public int compare(int[] a, int[] b) {
                // 使用Long比较避免整数溢出
                return Long.compare(a[1], b[1]);
            }
        });
        
        // 至少需要一支箭
        int arrows = 1;
        // 当前箭的位置（射在第一个气球的结束位置）
        long arrowPos = points[0][1];
        
        for (int i = 1; i < n; i++) {
            // 如果当前气球的开始位置 > 当前箭的位置，需要新的箭
            if ((long)points[i][0] > arrowPos) {
                arrows++;
                arrowPos = points[i][1];
            }
            // 否则当前箭可以射爆这个气球（不需要更新箭的位置）
        }
        
        return arrows;
    }

    /**
     * 使用开始位置排序的解法（用于对比）
     * 
     * 算法思路：
     * 1. 按开始位置排序
     * 2. 维护当前重叠区间的最小结束位置
     * 3. 当遇到不重叠的区间时，增加箭的数量
     * 
     * 时间复杂度：O(n*logn)
     * 空间复杂度：O(1)
     * 是否最优解：是，这也是正确的解法
     * 
     * @param points 气球区间数组
     * @return 最小弓箭数
     */
    public static int findMinArrowShotsByStart(int[][] points) {
        if (points == null || points.length == 0) {
            return 0;
        }
        
        int n = points.length;
        
        // 按开始位置升序排序
        Arrays.sort(points, new Comparator<int[]>() {
            @Override
            public int compare(int[] a, int[] b) {
                return Long.compare(a[0], b[0]);
            }
        });
        
        int arrows = 1;
        // 当前重叠区间的最小结束位置
        long minEnd = points[0][1];
        
        for (int i = 1; i < n; i++) {
            // 如果当前气球的开始位置 > 最小结束位置，需要新的箭
            if ((long)points[i][0] > minEnd) {
                arrows++;
                minEnd = points[i][1];
            } else {
                // 更新最小结束位置
                minEnd = Math.min(minEnd, points[i][1]);
            }
        }
        
        return arrows;
    }

    /**
     * 区间调度问题的通用解法
     * 
     * 算法思路：
     * 1. 将问题转化为求最大不重叠区间数
     * 2. 最小箭数 = 总区间数 - 最大不重叠区间数（错误思路）
     * 3. 实际上，最小箭数 = 最大不重叠区间数
     * 
     * 注意：这个思路是错误的，用于展示常见误区
     * 
     * @param points 气球区间数组
     * @return 最小弓箭数
     */
    public static int findMinArrowShotsWrong(int[][] points) {
        if (points == null || points.length == 0) {
            return 0;
        }
        
        int n = points.length;
        
        // 按结束位置排序
        Arrays.sort(points, new Comparator<int[]>() {
            @Override
            public int compare(int[] a, int[] b) {
                return Long.compare(a[1], b[1]);
            }
        });
        
        // 计算最大不重叠区间数
        int count = 1;
        long end = points[0][1];
        
        for (int i = 1; i < n; i++) {
            if ((long)points[i][0] > end) {
                count++;
                end = points[i][1];
            }
        }
        
        // 错误：最小箭数应该等于最大不重叠区间数，而不是总区间数减去最大不重叠区间数
        return n - count; // 这是错误的
    }

    // 测试方法
    public static void main(String[] args) {
        // 测试用例1
        int[][] points1 = {{10,16}, {2,8}, {1,6}, {7,12}};
        System.out.println("输入: [[10,16],[2,8],[1,6],[7,12]]");
        System.out.println("结束位置排序方法输出: " + findMinArrowShots(points1));
        System.out.println("开始位置排序方法输出: " + findMinArrowShotsByStart(points1));
        System.out.println("错误方法输出: " + findMinArrowShotsWrong(points1));
        System.out.println("期望: 2");
        System.out.println();
        
        // 测试用例2
        int[][] points2 = {{1,2}, {3,4}, {5,6}, {7,8}};
        System.out.println("输入: [[1,2],[3,4],[5,6],[7,8]]");
        System.out.println("结束位置排序方法输出: " + findMinArrowShots(points2));
        System.out.println("开始位置排序方法输出: " + findMinArrowShotsByStart(points2));
        System.out.println("错误方法输出: " + findMinArrowShotsWrong(points2));
        System.out.println("期望: 4");
        System.out.println();
        
        // 测试用例3：单个气球
        int[][] points3 = {{1,2}};
        System.out.println("输入: [[1,2]]");
        System.out.println("结束位置排序方法输出: " + findMinArrowShots(points3));
        System.out.println("开始位置排序方法输出: " + findMinArrowShotsByStart(points3));
        System.out.println("错误方法输出: " + findMinArrowShotsWrong(points3));
        System.out.println("期望: 1");
        System.out.println();
        
        // 测试用例4：完全重叠的气球
        int[][] points4 = {{1,5}, {2,4}, {3,6}, {4,8}};
        System.out.println("输入: [[1,5],[2,4],[3,6],[4,8]]");
        System.out.println("结束位置排序方法输出: " + findMinArrowShots(points4));
        System.out.println("开始位置排序方法输出: " + findMinArrowShotsByStart(points4));
        System.out.println("错误方法输出: " + findMinArrowShotsWrong(points4));
        System.out.println("期望: 1");
        System.out.println();
        
        // 测试用例5：边界情况，大数测试
        int[][] points5 = {{-2147483646, -2147483645}, {2147483646, 2147483647}};
        System.out.println("输入: [[-2147483646,-2147483645],[2147483646,2147483647]]");
        System.out.println("结束位置排序方法输出: " + findMinArrowShots(points5));
        System.out.println("开始位置排序方法输出: " + findMinArrowShotsByStart(points5));
        System.out.println("错误方法输出: " + findMinArrowShotsWrong(points5));
        System.out.println("期望: 2");
        System.out.println();
        
        // 性能测试
        int[][] largePoints = new int[10000][2];
        for (int i = 0; i < 10000; i++) {
            largePoints[i][0] = (int) (Math.random() * 1000000);
            largePoints[i][1] = largePoints[i][0] + (int) (Math.random() * 1000) + 1;
        }
        
        long startTime = System.currentTimeMillis();
        int result1 = findMinArrowShots(largePoints);
        long endTime = System.currentTimeMillis();
        System.out.println("结束位置排序方法处理10000个气球耗时: " + (endTime - startTime) + "ms");
        
        startTime = System.currentTimeMillis();
        int result2 = findMinArrowShotsByStart(largePoints);
        endTime = System.currentTimeMillis();
        System.out.println("开始位置排序方法处理10000个气球耗时: " + (endTime - startTime) + "ms");
        System.out.println("两种方法结果是否一致: " + (result1 == result2));
    }
}

===============================================

文件: Code21_CodeforcesLISProblem.java
===============================================
package class072;

import java.util.*;

/**
 * Codeforces LIS问题变种 - 最长递增子序列计数
 * 
 * 题目来源：Codeforces 486E - LIS of Sequence
 * 题目链接：https://codeforces.com/problemset/problem/486/E
 * 题目描述：给定一个序列a，对于每个元素a[i]，判断它在最长递增子序列中的角色：
 * 1. 如果a[i]不出现在任何最长递增子序列中，输出'1'
 * 2. 如果a[i]出现在某些但不是所有最长递增子序列中，输出'2'
 * 3. 如果a[i]出现在所有最长递增子序列中，输出'3'
 * 
 * 算法思路：
 * 1. 计算从左到右的LIS长度（f[i]）
 * 2. 计算从右到左的LDS长度（g[i]）
 * 3. 最长递增子序列长度L = max(f[i])
 * 4. 对于每个位置i，如果f[i] + g[i] - 1 == L，则说明a[i]在某个LIS中
 * 5. 统计每个长度级别出现的次数，判断元素是否在所有LIS中
 * 
 * 时间复杂度：O(n*logn) - 使用二分查找优化
 * 空间复杂度：O(n) - 需要存储f和g数组
 * 是否最优解：是，这是标准解法
 * 
 * 示例：
 * 输入: [1, 3, 2]
 * 输出: "123"
 * 解释: 
 * - 元素1：出现在所有LIS中（[1,3]或[1,2]）-> '3'
 * - 元素3：出现在某些LIS中（[1,3]）-> '2'
 * - 元素2：出现在某些LIS中（[1,2]）-> '2'
 */

public class Code21_CodeforcesLISProblem {

    /**
     * 判断每个元素在LIS中的角色
     * 
     * @param nums 输入序列
     * @return 结果字符串，每个字符对应一个元素的角色
     */
    public static String lisOfSequence(int[] nums) {
        int n = nums.length;
        if (n == 0) return "";
        
        // f[i]: 以nums[i]结尾的最长递增子序列长度
        int[] f = new int[n];
        // g[i]: 以nums[i]开头的最长递减子序列长度（从右往左看）
        int[] g = new int[n];
        
        // 计算f数组（从左到右的LIS）
        int[] endsF = new int[n];
        int lenF = 0;
        for (int i = 0; i < n; i++) {
            int pos = binarySearch(endsF, lenF, nums[i], true);
            if (pos == -1) {
                endsF[lenF] = nums[i];
                f[i] = lenF + 1;
                lenF++;
            } else {
                endsF[pos] = nums[i];
                f[i] = pos + 1;
            }
        }
        
        // 计算g数组（从右到左的LIS，相当于原序列从右到左的LDS）
        int[] endsG = new int[n];
        int lenG = 0;
        for (int i = n - 1; i >= 0; i--) {
            // 注意：这里要找<=nums[i]的位置（因为是从右往左）
            int pos = binarySearch(endsG, lenG, nums[i], false);
            if (pos == -1) {
                endsG[lenG] = nums[i];
                g[i] = lenG + 1;
                lenG++;
            } else {
                endsG[pos] = nums[i];
                g[i] = pos + 1;
            }
        }
        
        // 最长递增子序列长度
        int L = lenF;
        
        // 统计每个长度级别出现的次数
        int[] count = new int[L + 1];
        for (int i = 0; i < n; i++) {
            if (f[i] + g[i] - 1 == L) {
                count[f[i]]++;
            }
        }
        
        // 构建结果
        StringBuilder result = new StringBuilder();
        for (int i = 0; i < n; i++) {
            if (f[i] + g[i] - 1 != L) {
                // 不出现在任何LIS中
                result.append('1');
            } else if (count[f[i]] == 1) {
                // 出现在所有LIS中（该长度级别只有一个元素）
                result.append('3');
            } else {
                // 出现在某些但不是所有LIS中
                result.append('2');
            }
        }
        
        return result.toString();
    }

    /**
     * 二分查找工具函数
     * 
     * @param ends 有序数组
     * @param len 有效长度
     * @param target 目标值
     * @param strict 是否严格递增（true表示>=，false表示<=）
     * @return 目标位置，如果不存在返回-1
     */
    private static int binarySearch(int[] ends, int len, int target, boolean strict) {
        int left = 0, right = len - 1;
        int result = -1;
        
        while (left <= right) {
            int mid = left + (right - left) / 2;
            
            if (strict) {
                // 查找>=target的最左位置
                if (ends[mid] >= target) {
                    result = mid;
                    right = mid - 1;
                } else {
                    left = mid + 1;
                }
            } else {
                // 查找<=target的最左位置（用于从右往左的LDS）
                if (ends[mid] <= target) {
                    result = mid;
                    right = mid - 1;
                } else {
                    left = mid + 1;
                }
            }
        }
        
        return result;
    }

    /**
     * 使用动态规划的解法（用于对比）
     * 
     * 算法思路：
     * 1. 分别计算从左到右和从右到左的LIS
     * 2. 使用传统DP方法，时间复杂度O(n²)
     * 3. 适用于小规模数据
     * 
     * 时间复杂度：O(n²)
     * 空间复杂度：O(n)
     * 是否最优解：否，存在O(n*logn)的优化解法
     * 
     * @param nums 输入序列
     * @return 结果字符串
     */
    public static String lisOfSequenceDP(int[] nums) {
        int n = nums.length;
        if (n == 0) return "";
        
        // 计算f数组
        int[] f = new int[n];
        Arrays.fill(f, 1);
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < i; j++) {
                if (nums[j] < nums[i]) {
                    f[i] = Math.max(f[i], f[j] + 1);
                }
            }
        }
        
        // 计算g数组（从右往左的LDS）
        int[] g = new int[n];
        Arrays.fill(g, 1);
        for (int i = n - 1; i >= 0; i--) {
            for (int j = n - 1; j > i; j--) {
                if (nums[j] < nums[i]) { // 注意这里应该是<，因为是从右往左看
                    g[i] = Math.max(g[i], g[j] + 1);
                }
            }
        }
        
        // 找到最大LIS长度
        int L = 0;
        for (int i = 0; i < n; i++) {
            L = Math.max(L, f[i]);
        }
        
        // 统计每个长度级别出现的次数
        int[] count = new int[L + 1];
        for (int i = 0; i < n; i++) {
            if (f[i] + g[i] - 1 == L) {
                count[f[i]]++;
            }
        }
        
        // 构建结果
        StringBuilder result = new StringBuilder();
        for (int i = 0; i < n; i++) {
            if (f[i] + g[i] - 1 != L) {
                result.append('1');
            } else if (count[f[i]] == 1) {
                result.append('3');
            } else {
                result.append('2');
            }
        }
        
        return result.toString();
    }

    // 测试方法
    public static void main(String[] args) {
        // 测试用例1：Codeforces示例
        int[] nums1 = {1, 3, 2};
        System.out.println("输入: [1,3,2]");
        System.out.println("优化方法输出: " + lisOfSequence(nums1));
        System.out.println("DP方法输出: " + lisOfSequenceDP(nums1));
        System.out.println("期望: 322");
        System.out.println();
        
        // 测试用例2
        int[] nums2 = {1, 2, 3};
        System.out.println("输入: [1,2,3]");
        System.out.println("优化方法输出: " + lisOfSequence(nums2));
        System.out.println("DP方法输出: " + lisOfSequenceDP(nums2));
        System.out.println("期望: 333");
        System.out.println();
        
        // 测试用例3
        int[] nums3 = {3, 2, 1};
        System.out.println("输入: [3,2,1]");
        System.out.println("优化方法输出: " + lisOfSequence(nums3));
        System.out.println("DP方法输出: " + lisOfSequenceDP(nums3));
        System.out.println("期望: 111");
        System.out.println();
        
        // 测试用例4
        int[] nums4 = {1, 1, 1};
        System.out.println("输入: [1,1,1]");
        System.out.println("优化方法输出: " + lisOfSequence(nums4));
        System.out.println("DP方法输出: " + lisOfSequenceDP(nums4));
        System.out.println();
        
        // 测试用例5：复杂序列
        int[] nums5 = {4, 1, 6, 2, 8, 5, 7, 3};
        System.out.println("输入: [4,1,6,2,8,5,7,3]");
        System.out.println("优化方法输出: " + lisOfSequence(nums5));
        System.out.println("DP方法输出: " + lisOfSequenceDP(nums5));
        System.out.println();
        
        // 性能测试
        int[] largeNums = new int[1000];
        Random random = new Random();
        for (int i = 0; i < 1000; i++) {
            largeNums[i] = random.nextInt(10000);
        }
        
        long startTime = System.currentTimeMillis();
        String result1 = lisOfSequence(largeNums);
        long endTime = System.currentTimeMillis();
        System.out.println("优化方法处理1000个元素耗时: " + (endTime - startTime) + "ms");
        
        startTime = System.currentTimeMillis();
        String result2 = lisOfSequenceDP(largeNums);
        endTime = System.currentTimeMillis();
        System.out.println("DP方法处理1000个元素耗时: " + (endTime - startTime) + "ms");
        System.out.println("两种方法结果是否一致: " + result1.equals(result2));
    }
}

===============================================

文件: Code22_HackerRankLISChallenge.java
===============================================
package class072;

import java.util.*;

/**
 * HackerRank LIS挑战 - 最长递增子序列变种
 * 
 * 题目来源：HackerRank - The Longest Increasing Subsequence
 * 题目链接：https://www.hackerrank.com/challenges/longest-increasing-subsequence/problem
 * 题目描述：给定一个整数序列，找到最长严格递增子序列的长度。
 * 但HackerRank的测试数据规模较大，需要O(n*logn)的解法。
 * 
 * 算法思路：
 * 1. 使用贪心+二分查找的标准解法
 * 2. 维护ends数组，ends[i]表示长度为i+1的递增子序列的最小结尾元素
 * 3. 对于每个元素，在ends中二分查找>=num的最左位置
 * 
 * 时间复杂度：O(n*logn)
 * 空间复杂度：O(n)
 * 是否最优解：是，这是最优解法
 * 
 * 示例：
 * 输入: [2, 7, 4, 3, 8]
 * 输出: 3
 * 解释: 最长递增子序列为[2,4,8]或[2,7,8]，长度为3。
 */

public class Code22_HackerRankLISChallenge {

    /**
     * 计算最长递增子序列的长度（HackerRank标准解法）
     * 
     * @param arr 输入的整数数组
     * @return 最长递增子序列的长度
     */
    public static int longestIncreasingSubsequence(int[] arr) {
        if (arr == null || arr.length == 0) {
            return 0;
        }
        
        int n = arr.length;
        // tails[i]表示长度为i+1的所有递增子序列中结尾元素的最小值
        int[] tails = new int[n];
        int size = 0;
        
        for (int x : arr) {
            // 二分查找x在tails中的插入位置
            int left = 0, right = size;
            while (left < right) {
                int mid = left + (right - left) / 2;
                if (tails[mid] < x) {
                    left = mid + 1;
                } else {
                    right = mid;
                }
            }
            
            tails[left] = x;
            if (left == size) {
                size++;
            }
        }
        
        return size;
    }

    /**
     * 使用ArrayList的简化版本（更易理解）
     * 
     * 算法思路：
     * 1. 使用ArrayList动态维护ends列表
     * 2. 对于每个元素，二分查找插入位置
     * 3. 如果元素大于所有现有元素，添加到末尾；否则替换第一个大于等于它的元素
     * 
     * 时间复杂度：O(n*logn)
     * 空间复杂度：O(n)
     * 是否最优解：是，功能相同但代码更简洁
     * 
     * @param arr 输入的整数数组
     * @return 最长递增子序列的长度
     */
    public static int longestIncreasingSubsequenceSimple(int[] arr) {
        if (arr == null || arr.length == 0) {
            return 0;
        }
        
        List<Integer> list = new ArrayList<>();
        
        for (int num : arr) {
            if (list.isEmpty() || num > list.get(list.size() - 1)) {
                // 如果大于最后一个元素，直接添加到末尾
                list.add(num);
            } else {
                // 二分查找插入位置
                int left = 0, right = list.size() - 1;
                int pos = -1;
                
                while (left <= right) {
                    int mid = left + (right - left) / 2;
                    if (list.get(mid) < num) {
                        left = mid + 1;
                    } else {
                        pos = mid;
                        right = mid - 1;
                    }
                }
                
                if (pos != -1) {
                    list.set(pos, num);
                }
            }
        }
        
        return list.size();
    }

    /**
     * 使用Java内置的二分查找方法
     * 
     * 算法思路：
     * 1. 使用Collections.binarySearch进行二分查找
     * 2. 如果返回负值，说明需要插入新位置
     * 3. 更简洁的实现
     * 
     * 时间复杂度：O(n*logn)
     * 空间复杂度：O(n)
     * 是否最优解：是，代码最简洁
     * 
     * @param arr 输入的整数数组
     * @return 最长递增子序列的长度
     */
    public static int longestIncreasingSubsequenceBuiltIn(int[] arr) {
        if (arr == null || arr.length == 0) {
            return 0;
        }
        
        List<Integer> list = new ArrayList<>();
        
        for (int num : arr) {
            int pos = Collections.binarySearch(list, num);
            if (pos < 0) {
                pos = -pos - 1; // 转换为插入位置
            }
            
            if (pos == list.size()) {
                list.add(num);
            } else {
                list.set(pos, num);
            }
        }
        
        return list.size();
    }

    /**
     * 动态规划解法（用于对比，不适用于大规模数据）
     * 
     * 算法思路：
     * 1. 传统DP方法，计算每个位置结尾的LIS长度
     * 2. 时间复杂度O(n²)，适用于小规模数据
     * 
     * 时间复杂度：O(n²)
     * 空间复杂度：O(n)
     * 是否最优解：否，不适用于大规模数据
     * 
     * @param arr 输入的整数数组
     * @return 最长递增子序列的长度
     */
    public static int longestIncreasingSubsequenceDP(int[] arr) {
        if (arr == null || arr.length == 0) {
            return 0;
        }
        
        int n = arr.length;
        int[] dp = new int[n];
        Arrays.fill(dp, 1);
        int maxLen = 1;
        
        for (int i = 1; i < n; i++) {
            for (int j = 0; j < i; j++) {
                if (arr[j] < arr[i]) {
                    dp[i] = Math.max(dp[i], dp[j] + 1);
                }
            }
            maxLen = Math.max(maxLen, dp[i]);
        }
        
        return maxLen;
    }

    // 测试方法
    public static void main(String[] args) {
        // 测试用例1：HackerRank示例
        int[] arr1 = {2, 7, 4, 3, 8};
        System.out.println("输入: [2,7,4,3,8]");
        System.out.println("标准方法输出: " + longestIncreasingSubsequence(arr1));
        System.out.println("简化方法输出: " + longestIncreasingSubsequenceSimple(arr1));
        System.out.println("内置方法输出: " + longestIncreasingSubsequenceBuiltIn(arr1));
        System.out.println("DP方法输出: " + longestIncreasingSubsequenceDP(arr1));
        System.out.println("期望: 3");
        System.out.println();
        
        // 测试用例2
        int[] arr2 = {10, 9, 2, 5, 3, 7, 101, 18};
        System.out.println("输入: [10,9,2,5,3,7,101,18]");
        System.out.println("标准方法输出: " + longestIncreasingSubsequence(arr2));
        System.out.println("简化方法输出: " + longestIncreasingSubsequenceSimple(arr2));
        System.out.println("内置方法输出: " + longestIncreasingSubsequenceBuiltIn(arr2));
        System.out.println("DP方法输出: " + longestIncreasingSubsequenceDP(arr2));
        System.out.println("期望: 4");
        System.out.println();
        
        // 测试用例3：严格递增
        int[] arr3 = {1, 2, 3, 4, 5};
        System.out.println("输入: [1,2,3,4,5]");
        System.out.println("标准方法输出: " + longestIncreasingSubsequence(arr3));
        System.out.println("简化方法输出: " + longestIncreasingSubsequenceSimple(arr3));
        System.out.println("内置方法输出: " + longestIncreasingSubsequenceBuiltIn(arr3));
        System.out.println("DP方法输出: " + longestIncreasingSubsequenceDP(arr3));
        System.out.println("期望: 5");
        System.out.println();
        
        // 测试用例4：严格递减
        int[] arr4 = {5, 4, 3, 2, 1};
        System.out.println("输入: [5,4,3,2,1]");
        System.out.println("标准方法输出: " + longestIncreasingSubsequence(arr4));
        System.out.println("简化方法输出: " + longestIncreasingSubsequenceSimple(arr4));
        System.out.println("内置方法输出: " + longestIncreasingSubsequenceBuiltIn(arr4));
        System.out.println("DP方法输出: " + longestIncreasingSubsequenceDP(arr4));
        System.out.println("期望: 1");
        System.out.println();
        
        // 性能测试：大规模数据
        int[] largeArr = new int[100000];
        Random random = new Random();
        for (int i = 0; i < 100000; i++) {
            largeArr[i] = random.nextInt(1000000);
        }
        
        // 只测试优化方法（DP方法会超时）
        long startTime = System.currentTimeMillis();
        int result1 = longestIncreasingSubsequence(largeArr);
        long endTime = System.currentTimeMillis();
        System.out.println("标准方法处理100000个元素耗时: " + (endTime - startTime) + "ms");
        
        startTime = System.currentTimeMillis();
        int result2 = longestIncreasingSubsequenceSimple(largeArr);
        endTime = System.currentTimeMillis();
        System.out.println("简化方法处理100000个元素耗时: " + (endTime - startTime) + "ms");
        
        startTime = System.currentTimeMillis();
        int result3 = longestIncreasingSubsequenceBuiltIn(largeArr);
        endTime = System.currentTimeMillis();
        System.out.println("内置方法处理100000个元素耗时: " + (endTime - startTime) + "ms");
        
        System.out.println("三种优化方法结果是否一致: " + 
            (result1 == result2 && result2 == result3));
        
        // 小规模数据测试DP方法
        int[] smallArr = Arrays.copyOf(largeArr, 1000);
        startTime = System.currentTimeMillis();
        int result4 = longestIncreasingSubsequenceDP(smallArr);
        endTime = System.currentTimeMillis();
        System.out.println("DP方法处理1000个元素耗时: " + (endTime - startTime) + "ms");
        System.out.println("DP方法与优化方法结果是否一致: " + (result1 == result4));
    }
}

===============================================

</pre>
</body>
</html>
