# 线段树分治 (Segment Tree Divide and Conquer)

## 概述

线段树分治是一种离线算法技术，主要用于处理带有时间维度的图论问题。它将操作序列按照时间轴建立线段树，然后通过DFS遍历线段树来处理各个时间区间内的操作。

## 补充资料

- [线段树分治题目详解](线段树分治题目详解.md) - 详细解析经典题目
- [线段树分治补充题目详解](线段树分治补充题目详解.md) - 更多平台的题目汇总
- [补充题目汇总](补充题目汇总.md) - 题目链接汇总
- [线段树分治工程化考量](线段树分治工程化考量.md) - 工程实践要点
- [线段树分治思路技巧与题型总结](线段树分治思路技巧与题型总结.md) - 解题技巧总结
- [线段树分治训练题解](线段树分治训练题解.java) - Java实现示例
- [线段树分治_实现示例.cpp](线段树分治_实现示例.cpp) - C++实现示例
- [线段树分治_实现示例.java](线段树分治_实现示例.java) - Java实现示例
- [线段树分治_实现示例.py](线段树分治_实现示例.py) - Python实现示例

## 核心思想

1. **离线处理**：将所有操作和查询离线，按照时间建立线段树
2. **区间操作**：将每个操作的影响时间段映射到线段树的节点上
3. **可撤销数据结构**：使用可撤销并查集等支持回滚操作的数据结构
4. **DFS遍历**：通过DFS遍历线段树，处理每个节点的操作并及时回滚

## 关键技术点

### 1. 可撤销并查集 (Rollback DSU)

```java
class RollbackDSU {
    int[] father, size;
    Stack<int[]> rollbackStack = new Stack<>();
    
    int find(int x) {
        while (x != father[x]) x = father[x];
        return x;
    }
    
    void union(int x, int y) {
        int fx = find(x), fy = find(y);
        if (fx == fy) return;
        // 按秩合并
        if (size[fx] < size[fy]) {
            int temp = fx; fx = fy; fy = temp;
        }
        father[fy] = fx;
        size[fx] += size[fy];
        rollbackStack.push(new int[]{fx, fy});
    }
    
    void rollback() {
        int[] op = rollbackStack.pop();
        int fx = op[0], fy = op[1];
        father[fy] = fy;
        size[fx] -= size[fy];
    }
}
```

### 2. 扩展域并查集 (Extended Union Find)

用于二分图检测：

```java
// 对于节点x，其在左侧的编号为x，右侧的编号为x+n
void union(int x, int y) {
    // x的左侧与y的右侧连接
    // y的左侧与x的右侧连接
    union(x, y + n);
    union(y, x + n);
}
```

## 经典题目

### 1. 动态图连通性 (LOJ #121)

**题目描述**：
- 支持加边、删边操作
- 查询两点间连通性

**解法**：
- 线段树分治 + 可撤销并查集

### 2. 二分图判定 (P5787)

**题目描述**：
- 维护动态图使其为二分图

**解法**：
- 线段树分治 + 扩展域并查集

### 3. 大融合 (P4219)

**题目描述**：
- 支持加边操作
- 查询边的负载（删去该边后两个连通块大小的乘积）

**解法**：
- 线段树分治 + 可撤销并查集

### 4. 连通图 (P5227)

**题目描述**：
- 初始图为连通图
- 每次删除一些边，查询是否仍连通

**解法**：
- 线段树分治 + 可撤销并查集

### 5. 独特事件 (CF1681F)

**题目描述**：
- 给定一棵树，每条边有颜色
- 定义f(u,v)为点u到点v的简单路径上恰好出现一次的颜色的数量
- 求所有点对的f值之和

**解法**：
- 线段树分治 + 可撤销并查集

### 6. 给边涂色 (CF576E)

**题目描述**：
- 给边涂色，要求每种颜色构成的子图都是二分图

**解法**：
- 线段树分治 + 多个扩展域并查集

### 7. 最小mex生成树 (P5631)

**题目描述**：
- 求生成树使得边权集合的mex最小

**解法**：
- 线段树分治 + 可撤销并查集 + 二分

### 8. 最短路径查询 (CF938G)

**题目描述**：
- 支持加边、删边和查询两点间路径异或最小值

**解法**：
- 线段树分治 + 可撤销并查集 + 线性基

### 9. 动态图连通性 (LOJ #121)

**题目描述**：
- 支持加边、删边操作
- 查询两点间连通性

**解法**：
- 线段树分治 + 可撤销并查集

### 10. 二分图检测 (CF813F)

**题目描述**：
- 检查动态加边过程中图是否始终保持二分图

**解法**：
- 线段树分治 + 扩展域并查集

## 算法复杂度

- 时间复杂度：O((n + m) log m)
- 空间复杂度：O(n + m)

其中n为点数，m为操作数。

## 实现要点

1. **不能路径压缩**：为了支持撤销操作，只能使用按秩合并
2. **离线处理**：所有操作必须预先知道
3. **精确回滚**：每次操作后必须准确回滚到操作前状态
4. **时间区间映射**：将操作的生效时间区间正确映射到线段树节点

## 应用场景

1. **动态图问题**：加边、删边操作下的图性质维护
2. **二分图维护**：动态维护图的二分性
3. **连通性查询**：动态图的连通性相关查询
4. **生成树问题**：动态维护生成树相关性质

## 注意事项

1. 可撤销并查集不能使用路径压缩，只能按秩合并
2. 线段树分治是离线算法，不支持在线查询
3. 每个操作的影响时间区间要正确计算
4. 回滚操作必须与合并操作一一对应