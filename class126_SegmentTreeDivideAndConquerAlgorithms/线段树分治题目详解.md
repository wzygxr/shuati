# 线段树分治经典题目详解

## 1. LOJ #121. 动态图连通性

### 题目描述
给定一个n个节点的动态图，支持以下操作：
1. 加边操作：在点x和点y之间增加一条边
2. 删边操作：删除点x和点y之间的边
3. 查询操作：查询点x和点y是否连通

### 解题思路
这是线段树分治的经典应用。我们将每条边的存在时间看作一个区间，然后将这些区间映射到线段树上。

### 核心算法
1. 对于每条边，记录其存在的时间区间[L,R]
2. 将这个区间在线段树上进行标记
3. DFS遍历线段树，在每个节点处处理该节点上的所有边
4. 使用可撤销并查集维护当前的连通性
5. 到达叶子节点时回答查询

### 关键代码片段
```java
// 在线段树上标记边的存在时间
void add(int jobl, int jobr, int jobx, int joby, int l, int r, int i) {
    if (jobl <= l && r <= jobr) {
        addEdge(i, jobx, joby);
    } else {
        int mid = (l + r) >> 1;
        if (jobl <= mid) {
            add(jobl, jobr, jobx, joby, l, mid, i << 1);
        }
        if (jobr > mid) {
            add(jobl, jobr, jobx, joby, mid + 1, r, i << 1 | 1);
        }
    }
}

// DFS处理线段树节点
void dfs(int l, int r, int i) {
    int unionCnt = 0;
    for (int ei = head[i], x, y, fx, fy; ei > 0; ei = next[ei]) {
        x = tox[ei];
        y = toy[ei];
        fx = find(x);
        fy = find(y);
        if (fx != fy) {
            union(fx, fy);
            unionCnt++;
        }
    }
    if (l == r) {
        // 处理叶子节点的查询操作
        if (op[l] == 2) {
            ans[l] = find(u[l]) == find(v[l]);
        }
    } else {
        int mid = (l + r) / 2;
        dfs(l, mid, i << 1);
        dfs(mid + 1, r, i << 1 | 1);
    }
    // 回滚操作
    for (int j = 1; j <= unionCnt; j++) {
        undo();
    }
}
```

### 时间复杂度
O((n + m) log m)，其中n是节点数，m是操作数。

## 2. P5787 二分图 /【模板】线段树分治

### 题目描述
给定一个n个节点的图，每条边有一个存在时间区间[L,R]，对于每个时间点，判断当前图是否为二分图。

### 解题思路
使用扩展域并查集来判断二分图：
1. 对于每个节点x，创建两个节点：x和x+n
2. 如果x和y之间有边，则连接x和y+n，y和x+n
3. 如果x和x+n在同一个连通分量中，则不是二分图

### 核心算法
1. 将每条边的存在时间区间映射到线段树上
2. DFS遍历线段树，使用扩展域并查集维护连通性
3. 如果在某个节点发现矛盾（x和x+n连通），则该子树内所有时间点都不是二分图

### 关键代码片段
```java
void dfs(int l, int r, int i) {
    boolean check = true;
    int unionCnt = 0;
    for (int ei = head[i]; ei > 0; ei = next[ei]) {
        int x = tox[ei], y = toy[ei], fx = find(x), fy = find(y);
        if (fx == fy) {
            check = false;
            break;
        } else {
            union(x, y + n);
            union(y, x + n);
            unionCnt += 2;
        }
    }
    if (check) {
        if (l == r) {
            ans[l] = true;
        } else {
            int mid = (l + r) / 2;
            dfs(l, mid, i << 1);
            dfs(mid + 1, r, i << 1 | 1);
        }
    } else {
        for (int k = l; k <= r; k++) {
            ans[k] = false;
        }
    }
    for (int k = 1; k <= unionCnt; k++) {
        undo();
    }
}
```

### 时间复杂度
O((n + m) log k)，其中n是节点数，m是边数，k是时间范围。

## 3. P4219 大融合

### 题目描述
支持两种操作：
1. 在点x和点y之间加一条边（保证之前不连通）
2. 查询点x和点y之间边的负载（删去该边后两个连通块大小的乘积）

### 解题思路
使用线段树分治处理所有加边操作，对于查询操作，找出对应边的所有存在时间区间。

### 核心算法
1. 对于每条边，找出其所有存在的时间区间
2. 将这些区间映射到线段树上
3. DFS遍历时，对于叶子节点上的查询操作，计算答案

### 关键代码片段
```java
void dfs(int l, int r, int i) {
    int unionCnt = 0;
    for (int ei = head[i]; ei > 0; ei = next[ei]) {
        union(tox[ei], toy[ei]);
        unionCnt++;
    }
    if (l == r) {
        if (op[l] == 2) {
            ans[l] = (long) siz[find(u[l])] * siz[find(v[l])];
        }
    } else {
        int mid = (l + r) >> 1;
        dfs(l, mid, i << 1);
        dfs(mid + 1, r, i << 1 | 1);
    }
    for (int k = 1; k <= unionCnt; k++) {
        undo();
    }
}
```

### 时间复杂度
O((n + q) log q)，其中n是节点数，q是操作数。

## 4. P5227 连通图

### 题目描述
初始时所有点都连通，每次操作删除一些边，查询删除后是否仍连通。

### 解题思路
转换思路：不是删除边，而是找出每条边不存在的时间区间，在这些区间内不使用该边。

### 核心算法
1. 对于每条边，找出其不存在的时间区间
2. 将这些区间映射到线段树上
3. DFS遍历时维护连通性，如果发现整个图连通则标记答案

### 关键代码片段
```java
void dfs(int l, int r, int i) {
    boolean check = false;
    int unionCnt = 0;
    for (int ei = head[i]; ei > 0; ei = next[ei]) {
        int x = tox[ei], y = toy[ei], fx = find(x), fy = find(y);
        if (fx != fy) {
            union(fx, fy);
            unionCnt++;
        }
        if (siz[find(fx)] == n) {
            check = true;
            break;
        }
    }
    if (check) {
        for (int j = l; j <= r; j++) {
            ans[j] = true;
        }
    } else {
        if (l == r) {
            ans[l] = false;
        } else {
            int mid = (l + r) >> 1;
            dfs(l, mid, i << 1);
            dfs(mid + 1, r, i << 1 | 1);
        }
    }
    for (int j = 1; j <= unionCnt; j++) {
        undo();
    }
}
```

### 时间复杂度
O((n + m) log k)，其中n是节点数，m是边数，k是操作数。

## 5. CF1681F Unique Occurrences

### 题目描述
给定一棵树，每条边有颜色，定义f(u,v)为点u到点v的简单路径上恰好出现一次的颜色的数量，求所有点对的f值之和。

### 解题思路
对于每种颜色，找出所有该颜色的边，然后计算删除这些边后各个连通块之间的贡献。

### 核心算法
1. 对于每种颜色，将其作为"不存在"的颜色处理
2. 将颜色不存在的时间区间映射到线段树上
3. DFS遍历时，计算各个连通块之间的贡献

### 关键代码片段
```java
void dfs(int l, int r, int i) {
    int unionCnt = 0;
    for (int ei = headt[i]; ei > 0; ei = nextt[ei]) {
        union(xt[ei], yt[ei]);
        unionCnt++;
    }
    if (l == r) {
        for (int ei = headc[l], fx, fy; ei > 0; ei = nextc[ei]) {
            fx = find(xc[ei]);
            fy = find(yc[ei]);
            ans += (long) siz[fx] * siz[fy];
        }
    } else {
        int mid = (l + r) >> 1;
        dfs(l, mid, i << 1);
        dfs(mid + 1, r, i << 1 | 1);
    }
    for (int k = 1; k <= unionCnt; k++) {
        undo();
    }
}
```

### 时间复杂度
O((n + m) log n)，其中n是节点数，m是边数。

## 6. CF576E Painting Edges

### 题目描述
给边涂色，要求每种颜色构成的子图都是二分图。

### 解题思路
对于每次涂色操作，验证涂色后是否满足条件，如果不满足则撤销操作。

### 核心算法
1. 对于每条边，维护其历史颜色信息
2. 对于每次操作，找出其影响的时间区间
3. 使用多个扩展域并查集分别维护每种颜色的连通性

### 关键代码片段
```java
void dfs(int l, int r, int i) {
    int unionCnt = 0;
    int color, x, y, xn, yn, fx, fy, fxn, fyn;
    for (int ei = head[i]; ei > 0; ei = next[ei]) {
        color = c[qid[ei]];
        x = u[e[qid[ei]]];
        y = v[e[qid[ei]]];
        xn = x + n;
        yn = y + n;
        fx = find(color, x);
        fy = find(color, y);
        fxn = find(color, xn);
        fyn = find(color, yn);
        if (fx != fyn) {
            union(color, fx, fyn);
            unionCnt++;
        }
        if (fy != fxn) {
            union(color, fy, fxn);
            unionCnt++;
        }
    }
    if (l == r) {
        if (find(c[l], u[e[l]]) == find(c[l], v[e[l]])) {
            ans[l] = false;
            c[l] = lastColor[e[l]];
        } else {
            ans[l] = true;
            lastColor[e[l]] = c[l];
        }
    } else {
        int mid = (l + r) >> 1;
        dfs(l, mid, i << 1);
        dfs(mid + 1, r, i << 1 | 1);
    }
    for (int j = 1; j <= unionCnt; j++) {
        undo();
    }
}
```

### 时间复杂度
O(k(n + q) log q)，其中k是颜色数，n是节点数，q是操作数。

## 7. P5631 最小mex生成树

### 题目描述
给定一个n个节点的图，m条边的无向连通图，边有边权，求一个生成树，使得其边权集合的mex最小。

### 解题思路
使用线段树分治结合二分答案的方法：
1. 二分答案，检查是否存在不包含该权值的生成树
2. 对于每个候选答案，将不包含该权值的边的存在时间区间映射到线段树上
3. DFS遍历时维护并查集，检查是否能形成生成树

### 核心算法
1. 对于每条边，如果其权值不等于当前二分的答案，则将其作为"存在"的边处理
2. 将边的存在时间区间映射到线段树上
3. DFS遍历时，计算连通块数量，判断是否能形成生成树

### 关键代码片段
```java
void dfs(int l, int r, int i) {
    int unionCnt = 0;
    for (int ei = head[i], fx, fy; ei > 0; ei = next[ei]) {
        fx = find(tox[ei]);
        fy = find(toy[ei]);
        if (fx != fy) {
            union(fx, fy);
            part--;
            unionCnt++;
        }
    }
    int ans = -1;
    if (l == r) {
        if (part == 1) {
            ans = l;
        }
    } else {
        int mid = (l + r) >> 1;
        ans = dfs(l, mid, i << 1);
        if (ans == -1) {
            ans = dfs(mid + 1, r, i << 1 | 1);
        }
    }
    for (int k = 1; k <= unionCnt; k++) {
        undo();
        part++;
    }
    return ans;
}
```

### 时间复杂度
O((n + m) log m log n)，其中n是节点数，m是边数。

## 8. CF938G Shortest Path Queries

### 题目描述
支持三种操作：
1. 加边操作：在点x和点y之间增加一条边权为d的边
2. 删边操作：删除点x和点y之间的边
3. 查询操作：查询点x到点y的路径异或最小值

### 解题思路
结合线段树分治、可撤销并查集和线性基：
1. 使用线段树分治处理边的存在时间区间
2. 使用可撤销并查集维护连通性
3. 使用线性基维护路径异或值

### 核心算法
1. 对于每条边，记录其存在的时间区间[L,R]
2. 将区间映射到线段树上
3. DFS遍历时，维护并查集和线性基
4. 对于查询操作，计算两点间路径的异或最小值

### 关键代码片段
```java
void dfs(int l, int r, int i) {
    int unionCnt = 0;
    for (int ei = head[i]; ei > 0; ei = next[ei]) {
        int x = tox[ei], y = toy[ei], d = weight[ei];
        int fx = find(x), fy = find(y);
        if (fx != fy) {
            union(fx, fy);
            // 将环的异或值加入线性基
            linearBase.insert(getXorPath(x, y) ^ d);
            unionCnt++;
        }
    }
    if (l == r) {
        if (op[l] == 3) {
            if (find(u[l]) != find(v[l])) {
                ans[l] = -1; // 不连通
            } else {
                ans[l] = linearBase.queryMin(getXorPath(u[l], v[l]));
            }
        }
    } else {
        int mid = (l + r) >> 1;
        dfs(l, mid, i << 1);
        dfs(mid + 1, r, i << 1 | 1);
    }
    for (int j = 1; j <= unionCnt; j++) {
        undo();
    }
}
```

### 时间复杂度
O((n + m) log m log n)，其中n是节点数，m是操作数。