package class057;

import java.util.Arrays;

/**
 * 尽量减少恶意软件的传播 II
 * 给定一个由 n 个节点组成的网络，用 n x n 个邻接矩阵 graph 表示
 * 在节点网络中，只有当 graph[i][j] = 1 时，节点 i 能够直接连接到另一个节点 j。
 * 一些节点 initial 最初被恶意软件感染。只要两个节点直接连接，
 * 且其中至少一个节点受到恶意软件的感染，那么两个节点都将被恶意软件感染。
 * 这种恶意软件的传播将继续，直到没有更多的节点可以被这种方式感染。
 * 假设 M(initial) 是在恶意软件停止传播之后，整个网络中感染恶意软件的最终节点数。
 * 我们可以从 initial 中删除一个节点，
 * 并完全移除该节点以及从该节点到任何其他节点的任何连接。
 * 请返回移除后能够使 M(initial) 最小化的节点。
 * 如果有多个节点满足条件，返回索引 最小的节点 。
 * initial 中每个整数都不同
 * 
 * 测试链接 : https://leetcode.cn/problems/minimize-malware-spread-ii/
 * 
 * 算法思路：
 * 1. 首先将所有非病毒节点进行并查集合并，形成连通分量
 * 2. 然后分析每个病毒节点能够感染哪些连通分量
 * 3. 统计每个病毒节点作为唯一感染源的连通分量大小之和
 * 4. 返回能够拯救最多节点的病毒节点索引
 * 
 * 算法思路深度解析：
 * - 该问题的核心挑战在于确定删除哪个初始感染节点能够最有效地减少最终感染范围
 * - 直接模拟删除每个节点后的病毒传播过程会导致较高的时间复杂度(O(k*n²)，k为初始感染节点数)
 * - 创新点：
 *   1. 预合并所有非病毒节点，形成稳定的连通分量
 *   2. 跟踪每个连通分量被哪些病毒节点感染（单感染源、多感染源或无感染源）
 *   3. 对于每个病毒节点，只统计那些仅由它感染的连通分量大小之和
 * - 算法正确性保证：
 *   1. 由于病毒节点之间不会相互感染（已被标记为病毒节点），可以独立分析每个病毒节点的影响
 *   2. 一个连通分量如果被多个病毒节点感染，删除单个病毒节点无法拯救该连通分量
 *   3. 只有那些仅由一个病毒节点感染的连通分量，删除该病毒节点才能拯救整个连通分量
 * 
 * 时间复杂度分析：
 * - 预处理阶段：O(n² α(n))，需要遍历整个邻接矩阵进行并查集合并操作
 * - 感染分析阶段：O(n²)，遍历每个病毒节点和其邻居
 * - 统计阶段：O(n)，遍历所有节点统计拯救节点数
 * - 寻找最优节点：O(k log k)，k为初始感染节点数
 * - 总体时间复杂度：O(n² α(n))
 * 
 * 空间复杂度分析：
 * - 五个全局数组：O(n)
 * - 额外空间：O(1)
 * - 总体空间复杂度：O(n)
 * 
 * 是否为最优解：是，该方法通过巧妙的预处理和感染源追踪，将时间复杂度降低到O(n² α(n))，避免了暴力枚举
 * 
 * 工程化考量：
 * 1. 异常处理：
 *    - 检查输入参数的有效性，如空矩阵、空初始感染数组
 *    - 验证初始感染节点的索引在有效范围内
 *    - 处理图的边界情况，如单节点图
 * 2. 内存优化：
 *    - 使用静态全局数组预分配空间，避免频繁的内存分配
 *    - MAXN常量可以根据题目约束灵活调整
 * 3. 可扩展性：
 *    - 该算法模式可以应用于类似的网络传播和阻断问题
 *    - 可以扩展处理加权图或动态网络
 * 4. 线程安全：
 *    - 当前实现不是线程安全的
 *    - 在多线程环境中需要添加同步机制或使用线程本地存储
 * 5. 性能优化：
 *    - 使用路径压缩优化并查集查找操作
 *    - 优化感染源追踪逻辑，减少不必要的重复计算
 * 
 * 与其他算法的对比：
 * 1. 暴力模拟法：
 *    - 对每个初始感染节点，模拟删除它后病毒的传播过程
 *    - 时间复杂度：O(k*n²)，当k较大时效率低下
 *    - 不适合大规模网络
 * 2. 贪心算法：
 *    - 基于度数或感染范围的启发式贪心选择
 *    - 可能无法找到全局最优解
 * 3. 并查集优化法（本方法）：
 *    - 通过一次预处理和感染源分析，高效计算每个节点的影响
 *    - 时间复杂度稳定在O(n² α(n))，远优于暴力方法
 * 
 * 极端情况分析：
 * 1. 所有初始感染节点都不连接到任何非病毒节点：删除任意节点结果相同，返回索引最小的
 * 2. 所有初始感染节点连接到同一个连通分量：删除任意节点都不能拯救该连通分量
 * 3. 每个连通分量只被一个唯一的病毒节点感染：删除对应的病毒节点能拯救整个连通分量
 * 4. 网络中没有非病毒节点：删除任意节点都不会改变感染范围
 * 5. 单节点网络且被感染：返回该节点
 * 
 * 调试技巧：
 * 1. 打印每个连通分量的感染状态（infect数组）以验证感染源追踪的正确性
 * 2. 验证每个病毒节点能拯救的节点数计算是否正确
 * 3. 使用小规模测试用例手动模拟算法执行过程
 * 4. 检查并查集合并是否正确处理了所有非病毒节点的连接
 * 
 * 问题迁移能力：
 * 掌握此问题的解法后，可以解决类似的网络阻断和传播控制问题：
 * - 疾病传播模型中的隔离策略优化
 * - 计算机网络中的病毒防护策略
 * - 社交网络中的信息传播控制
 * - 供应链中的风险控制
 * 
 * 与高级数据结构的结合：
 * 该问题展示了如何将并查集与感染源追踪结合使用，
 * 这种组合在解决网络传播和阻断问题时非常有效
 */
public class Code04_MinimizeMalwareSpreadII {

	// 最大节点数量常量，根据题目约束设置
	public static int MAXN = 301;

	// 标记节点是否为病毒节点
	// virus[i] = true 表示节点i是初始感染节点
	public static boolean[] virus = new boolean[MAXN];

	// 记录每个病毒节点被删除后能拯救的节点数量
	// cnts[v] 表示删除病毒节点v后，可以拯救的节点数
	public static int[] cnts = new int[MAXN];

	// 标记连通分量的感染源
	// infect[a] = -1: 该连通分量还未被任何病毒感染
	// infect[a] >= 0: 该连通分量被指定索引的病毒节点感染（唯一感染源）
	// infect[a] = -2: 该连通分量被多个病毒节点感染，删除单个病毒节点无法拯救
	// 注意：这里a是连通分量的代表节点
	public static int[] infect = new int[MAXN];

	// 并查集父节点数组
	// 用于管理非病毒节点的连通性
	public static int[] father = new int[MAXN];

	// 记录每个连通分量的大小
	// size[a] 表示以a为代表节点的连通分量中的节点数
	public static int[] size = new int[MAXN];

	/**
	 * 初始化所有数据结构
	 * 
	 * @param n 节点数量
	 * @param initial 初始感染节点数组
	 * @throws IllegalArgumentException 当输入参数无效时抛出异常
	 * @throws IndexOutOfBoundsException 当初始感染节点索引超出范围时抛出异常
	 */
	public static void build(int n, int[] initial) {
		if (n <= 0 || n > MAXN) {
			throw new IllegalArgumentException("节点数量必须在1到" + MAXN + "之间");
		}
		if (initial == null) {
			throw new NullPointerException("初始感染节点数组不能为null");
		}
		
		// 初始化所有节点为非病毒、无感染源状态
		for (int i = 0; i < n; i++) {
			virus[i] = false; // 初始为非病毒节点
			cnts[i] = 0;     // 初始拯救数量为0
			infect[i] = -1;  // 初始无感染源
			size[i] = 1;     // 初始连通分量大小为1（自身）
			father[i] = i;   // 初始父节点为自身
		}
		
		// 标记初始病毒节点
		for (int i : initial) {
			if (i < 0 || i >= n) {
				throw new IndexOutOfBoundsException("初始感染节点索引" + i + "超出范围");
			}
			virus[i] = true; // 标记为病毒节点
		}
	}

	/**
	 * 并查集查找操作，带路径压缩优化
	 * 
	 * @param i 要查找的节点
	 * @return 节点所在连通分量的代表元素
	 * @throws IndexOutOfBoundsException 当节点索引超出范围时抛出异常
	 */
	public static int find(int i) {
		if (i < 0 || i >= MAXN) {
			throw new IndexOutOfBoundsException("节点索引" + i + "超出范围");
		}
		
		// 路径压缩：将查找路径上的所有节点直接连接到根节点
		// 这大大减少了后续查找操作的时间复杂度，使并查集操作接近O(1)
		if (i != father[i]) {
			father[i] = find(father[i]);
		}
		return father[i];
	}

	/**
	 * 并查集合并操作
	 * 
	 * @param x 第一个节点
	 * @param y 第二个节点
	 * @throws IndexOutOfBoundsException 当节点索引超出范围时抛出异常
	 */
	public static void union(int x, int y) {
		// 查找两个节点的代表元素
		int fx = find(x);
		int fy = find(y);
		
		// 如果两个节点不在同一连通分量中，则合并
		if (fx != fy) {
			// 将较小的连通分量合并到较大的连通分量
			// 注意：这里的实现总是将fx合并到fy，没有根据size进行优化
			// 这是因为在本题中，我们只关心连通性，而不是平衡树结构
			father[fx] = fy;
			// 更新连通分量大小
			size[fy] += size[fx];
		}
	}

	/**
	 * 找出删除后能使感染节点数最少的病毒节点
	 * 
	 * @param graph 邻接矩阵表示的网络，graph[i][j] = 1 表示节点i和j直接相连
	 * @param initial 初始感染节点数组
	 * @return 最优的删除节点索引
	 * @throws NullPointerException 当输入数组为null时抛出异常
	 * @throws IllegalArgumentException 当输入参数无效时抛出异常
	 * 
	 * 算法核心步骤：
	 * 1. 预处理：合并所有非病毒节点，形成连通分量
	 * 2. 感染分析：确定每个连通分量的感染源情况（单感染源、多感染源或无感染源）
	 * 3. 统计计算：计算删除每个病毒节点能拯救的节点数量
	 * 4. 选择最优：找到能拯救最多节点的病毒节点（如果有多个，选择索引最小的）
	 */
	public static int minMalwareSpread(int[][] graph, int[] initial) {
		// 参数验证
		if (graph == null) {
			throw new NullPointerException("图矩阵不能为null");
		}
		if (initial == null || initial.length == 0) {
			throw new IllegalArgumentException("初始感染节点数组不能为null或空");
		}
		
		int n = graph.length;
		// 验证图的有效性
		if (n == 0) {
			throw new IllegalArgumentException("图不能为空");
		}
		for (int i = 0; i < n; i++) {
			if (graph[i] == null || graph[i].length != n) {
				throw new IllegalArgumentException("图矩阵必须是n×n的方阵");
			}
		}
		
		// 初始化数据结构
		build(n, initial);
		
		// 第一步：合并所有非病毒节点形成连通分量
		// 这一步构建了病毒传播的基础网络结构
		for (int i = 0; i < n; i++) {
			for (int j = 0; j < n; j++) {
				// 只有当两个节点都是非病毒节点且直接相连时才合并
				if (graph[i][j] == 1 && !virus[i] && !virus[j]) {
					union(i, j);
				}
			}
		}
		
		// 第二步：分析每个病毒节点对周围连通分量的感染情况
		// 这是算法的核心步骤，确定每个连通分量的感染源
		for (int sick : initial) {
			// 遍历病毒节点的所有邻居
			for (int neighbor = 0; neighbor < n; neighbor++) {
				// 只处理非病毒的直接邻居
				if (sick != neighbor && !virus[neighbor] && graph[sick][neighbor] == 1) {
					// 找到邻居所在连通分量的代表节点
					int fn = find(neighbor);
					
					// 根据感染源状态进行不同处理
					if (infect[fn] == -1) {
						// 该连通分量首次被感染，记录感染源为当前病毒节点
						infect[fn] = sick;
					} else if (infect[fn] != -2 && infect[fn] != sick) {
						// 该连通分量被多个不同的病毒节点感染
						// 标记为不可拯救（删除单个病毒节点无法拯救）
						infect[fn] = -2;
					}
					// 如果infect[fn] == sick，说明该连通分量已经被当前病毒节点感染过，不需要处理
				}
			}
		}
		
		// 第三步：统计每个病毒节点作为唯一感染源能拯救的节点数
		// 只有那些被单个病毒节点感染的连通分量，删除该病毒节点才能拯救
		for (int i = 0; i < n; i++) {
			// 只处理连通分量的代表节点且该连通分量有唯一感染源
			if (i == find(i) && infect[i] >= 0) {
				// 该连通分量的大小就是删除对应病毒节点能拯救的节点数
				cnts[infect[i]] += size[i];
			}
		}
		
		// 第四步：找到能拯救最多节点的病毒节点（索引最小的）
		// 先排序以确保返回索引最小的节点
		Arrays.sort(initial);
		int bestNode = initial[0]; // 默认选择索引最小的节点
		int maxSaved = cnts[bestNode]; // 初始化为第一个节点能拯救的数量
		
		// 遍历所有初始感染节点，找到拯救数量最多的
		for (int node : initial) {
			if (cnts[node] > maxSaved) {
				bestNode = node;
				maxSaved = cnts[node];
			}
		}
		
		return bestNode;
	}
	
	/**
	 * 主测试方法
	 */
	public static void main(String[] args) {
		// 测试用例1：基本情况
		testCase1();
		
		// 测试用例2：多感染源情况
		testCase2();
		
		// 测试用例3：链式结构
		testCase3();
		
		// 测试用例4：每个连通分量只被一个病毒感染
		testCase4();
		
		// 测试用例5：所有连通分量被多个病毒感染
		testCase5();
		
		// 测试用例6：边界情况 - 单节点
		testCase6();
	}
	
	/**
	 * 测试用例1：基本情况
	 * 两个病毒节点，有一个独立的连通分量
	 */
	private static void testCase1() {
		System.out.println("测试用例1：基本情况");
		int[][] graph = {
			{1, 1, 0},
			{1, 1, 0},
			{0, 0, 1}
		};
		int[] initial = {0, 1};
		int expected = 0; // 删除任意节点都能拯救0个节点，但返回索引较小的
		int result = minMalwareSpread(graph, initial);
		System.out.println("  结果: " + result);
		System.out.println("  预期: " + expected);
		System.out.println("  测试" + (result == expected ? "通过" : "失败"));
		System.out.println();
	}
	
	/**
	 * 测试用例2：多感染源情况
	 * 两个病毒节点，其中一个病毒节点连接到一个大的连通分量
	 */
	private static void testCase2() {
		System.out.println("测试用例2：多感染源情况");
		int[][] graph = {
			{1, 1, 0},
			{1, 1, 1},
			{0, 1, 1}
		};
		int[] initial = {0, 1};
		int expected = 1; // 删除节点1能拯救更多节点
		int result = minMalwareSpread(graph, initial);
		System.out.println("  结果: " + result);
		System.out.println("  预期: " + expected);
		System.out.println("  测试" + (result == expected ? "通过" : "失败"));
		System.out.println();
	}
	
	/**
	 * 测试用例3：链式结构
	 * 链式网络结构，测试算法在长链上的表现
	 */
	private static void testCase3() {
		System.out.println("测试用例3：链式结构");
		int[][] graph = {
			{1, 1, 0, 0},
			{1, 1, 1, 0},
			{0, 1, 1, 1},
			{0, 0, 1, 1}
		};
		int[] initial = {0, 1};
		int expected = 1; // 删除节点1能拯救更多节点
		int result = minMalwareSpread(graph, initial);
		System.out.println("  结果: " + result);
		System.out.println("  预期: " + expected);
		System.out.println("  测试" + (result == expected ? "通过" : "失败"));
		System.out.println();
	}
	
	/**
	 * 测试用例4：每个连通分量只被一个病毒感染
	 * 测试当每个连通分量只有一个感染源时的情况
	 */
	private static void testCase4() {
		System.out.println("测试用例4：每个连通分量只被一个病毒感染");
		int[][] graph = {
			{1, 1, 0, 0, 0},
			{1, 1, 0, 0, 0},
			{0, 0, 1, 1, 0},
			{0, 0, 1, 1, 0},
			{0, 0, 0, 0, 1}
		};
		int[] initial = {0, 2, 4}; // 每个病毒节点连接不同的连通分量
		int expected = 2; // 删除节点2能拯救2个节点（最多）
		int result = minMalwareSpread(graph, initial);
		System.out.println("  结果: " + result);
		System.out.println("  预期: " + expected);
		System.out.println("  测试" + (result == expected ? "通过" : "失败"));
		System.out.println();
	}
	
	/**
	 * 测试用例5：所有连通分量被多个病毒感染
	 * 测试当删除任意病毒节点都无法拯救节点的情况
	 */
	private static void testCase5() {
		System.out.println("测试用例5：所有连通分量被多个病毒感染");
		int[][] graph = {
			{1, 0, 1},
			{0, 1, 1},
			{1, 1, 1}
		};
		int[] initial = {0, 1}; // 两个病毒节点都连接到中心节点
		int expected = 0; // 删除任意节点都无法拯救，但返回索引较小的
		int result = minMalwareSpread(graph, initial);
		System.out.println("  结果: " + result);
		System.out.println("  预期: " + expected);
		System.out.println("  测试" + (result == expected ? "通过" : "失败"));
		System.out.println();
	}
	
	/**
	 * 测试用例6：边界情况 - 单节点
	 * 测试只有一个节点的边界情况
	 */
	private static void testCase6() {
		System.out.println("测试用例6：边界情况 - 单节点");
		int[][] graph = {{1}}; // 单节点图
		int[] initial = {0}; // 该节点被感染
		int expected = 0; // 只能删除这个节点
		int result = minMalwareSpread(graph, initial);
		System.out.println("  结果: " + result);
		System.out.println("  预期: " + expected);
		System.out.println("  测试" + (result == expected ? "通过" : "失败"));
		System.out.println();
	}
}

/* C++ 实现
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

class Solution {
private:
    const int MAXN = 301;
    vector<bool> virus; // 标记节点是否为病毒节点
    vector<int> cnts;   // 每个病毒节点删除后能拯救的节点数
    vector<int> infect; // 标记连通分量的感染源
    vector<int> father; // 并查集父节点数组
    vector<int> size;   // 连通分量大小
    
    // 初始化数据结构
    void build(int n, vector<int>& initial) {
        virus.assign(n, false);
        cnts.assign(n, 0);
        infect.assign(n, -1);
        size.assign(n, 1);
        father.resize(n);
        for (int i = 0; i < n; ++i) {
            father[i] = i;
        }
        // 标记初始病毒节点
        for (int i : initial) {
            virus[i] = true;
        }
    }
    
    // 并查集查找操作
    int find(int i) {
        if (father[i] != i) {
            father[i] = find(father[i]);
        }
        return father[i];
    }
    
    // 并查集合并操作
    void unite(int x, int y) {
        int fx = find(x);
        int fy = find(y);
        if (fx != fy) {
            father[fx] = fy;
            size[fy] += size[fx];
        }
    }
    
public:
    int minMalwareSpread(vector<vector<int>>& graph, vector<int>& initial) {
        int n = graph.size();
        build(n, initial);
        
        // 合并所有非病毒节点
        for (int i = 0; i < n; ++i) {
            for (int j = 0; j < n; ++j) {
                if (graph[i][j] == 1 && !virus[i] && !virus[j]) {
                    unite(i, j);
                }
            }
        }
        
        // 分析病毒感染情况
        for (int sick : initial) {
            for (int neighbor = 0; neighbor < n; ++neighbor) {
                if (sick != neighbor && !virus[neighbor] && graph[sick][neighbor] == 1) {
                    int fn = find(neighbor);
                    if (infect[fn] == -1) {
                        infect[fn] = sick;
                    } else if (infect[fn] != -2 && infect[fn] != sick) {
                        infect[fn] = -2;
                    }
                }
            }
        }
        
        // 统计每个病毒节点能拯救的节点数
        for (int i = 0; i < n; ++i) {
            if (i == find(i) && infect[i] >= 0) {
                cnts[infect[i]] += size[i];
            }
        }
        
        // 找到最优删除节点
        sort(initial.begin(), initial.end());
        int bestNode = initial[0];
        int maxSaved = cnts[bestNode];
        
        for (int node : initial) {
            if (cnts[node] > maxSaved) {
                bestNode = node;
                maxSaved = cnts[node];
            }
        }
        
        return bestNode;
    }
};

int main() {
    Solution solution;
    
    // 测试用例1
    vector<vector<int>> graph1 = {
        {1, 1, 0},
        {1, 1, 0},
        {0, 0, 1}
    };
    vector<int> initial1 = {0, 1};
    cout << "测试用例1结果: " << solution.minMalwareSpread(graph1, initial1) << endl; // 预期输出: 0
    
    // 测试用例2
    vector<vector<int>> graph2 = {
        {1, 1, 0},
        {1, 1, 1},
        {0, 1, 1}
    };
    vector<int> initial2 = {0, 1};
    cout << "测试用例2结果: " << solution.minMalwareSpread(graph2, initial2) << endl; // 预期输出: 1
    
    return 0;
}
*/

/* Python 实现
class Solution:
    def minMalwareSpread(self, graph, initial):
        """
        找出删除后能使感染节点数最少的病毒节点
        
        Args:
            graph: 邻接矩阵表示的网络
            initial: 初始感染节点列表
            
        Returns:
            最优的删除节点索引
        """
        n = len(graph)
        # 初始化数据结构
        virus = [False] * n  # 标记节点是否为病毒
        cnts = [0] * n       # 每个病毒节点删除后能拯救的节点数
        infect = [-1] * n    # 连通分量的感染源
        size = [1] * n       # 连通分量大小
        parent = list(range(n))  # 并查集父节点
        
        # 标记初始病毒节点
        for node in initial:
            virus[node] = True
        
        def find(x):
            """查找操作，带路径压缩"""
            if parent[x] != x:
                parent[x] = find(parent[x])
            return parent[x]
        
        def union(x, y):
            """合并操作"""
            fx = find(x)
            fy = find(y)
            if fx != fy:
                parent[fx] = fy
                size[fy] += size[fx]
        
        # 第一步：合并所有非病毒节点
        for i in range(n):
            for j in range(n):
                if graph[i][j] == 1 and not virus[i] and not virus[j]:
                    union(i, j)
        
        # 第二步：分析病毒感染情况
        for sick in initial:
            for neighbor in range(n):
                if sick != neighbor and not virus[neighbor] and graph[sick][neighbor] == 1:
                    fn = find(neighbor)
                    if infect[fn] == -1:
                        infect[fn] = sick
                    elif infect[fn] != -2 and infect[fn] != sick:
                        infect[fn] = -2
        
        # 第三步：统计每个病毒节点能拯救的节点数
        for i in range(n):
            if i == find(i) and infect[i] >= 0:
                cnts[infect[i]] += size[i]
        
        # 第四步：找到最优删除节点（先排序以确保返回索引最小的）
        initial.sort()
        best_node = initial[0]
        max_saved = cnts[best_node]
        
        for node in initial:
            if cnts[node] > max_saved:
                best_node = node
                max_saved = cnts[node]
        
        return best_node

# 测试代码
solution = Solution()

# 测试用例1
graph1 = [
    [1, 1, 0],
    [1, 1, 0],
    [0, 0, 1]
]
initial1 = [0, 1]
print("测试用例1结果:", solution.minMalwareSpread(graph1, initial1))  # 预期输出: 0

# 测试用例2
graph2 = [
    [1, 1, 0],
    [1, 1, 1],
    [0, 1, 1]
]
initial2 = [0, 1]
print("测试用例2结果:", solution.minMalwareSpread(graph2, initial2))  # 预期输出: 1

# 测试用例3
graph3 = [
    [1, 1, 0, 0],
    [1, 1, 1, 0],
    [0, 1, 1, 1],
    [0, 0, 1, 1]
]
initial3 = [0, 1]
print("测试用例3结果:", solution.minMalwareSpread(graph3, initial3))  # 预期输出: 1
*/
