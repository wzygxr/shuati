// 虚树(Virtual Tree)算法详解与应用
// 
// 虚树是一种优化技术，用于解决树上多次询问的问题，每次询问涉及部分关键点
// 虚树只保留关键点及其两两之间的LCA，节点数控制在O(k)级别，从而提高效率
//
// 算法核心思想：
// 1. 虚树包含所有关键点和它们两两之间的LCA
// 2. 虚树的节点数不超过2*k-1（k为关键点数）
// 3. 在虚树上进行DP等操作，避免遍历整棵树
//
// 构造方法：
// 方法一：二次排序法
// 1. 将关键点按DFS序排序
// 2. 相邻点求LCA并加入序列
// 3. 再次排序并去重得到虚树所有节点
// 4. 按照父子关系连接节点
//
// 方法二：单调栈法
// 1. 将关键点按DFS序排序
// 2. 用栈维护虚树的一条链
// 3. 逐个插入关键点并维护栈结构
//
// 应用场景：
// 1. 树上多次询问，每次询问涉及部分关键点
// 2. 需要在关键点及其LCA上进行DP等操作
// 3. 数据范围要求∑k较小（通常≤10^5）
//
// 相关题目：
// 1. Codeforces 613D - Kingdom and Cities
//    链接：https://codeforces.com/problemset/problem/613/D
//    题意：给一棵树和多个询问，每个询问给出一些关键点，要求切断最少的非关键点使关键点两两不连通
//    解题思路：使用虚树构建关键点的虚树，然后在虚树上进行树形DP，计算每个节点需要删除的最少非关键点
//    时间复杂度：O(n log n + ∑k log k)
//
// 2. 洛谷 P2495 - [SDOI2011]消耗战
//    链接：https://www.luogu.com.cn/problem/P2495
//    题意：给一棵树和多个询问，每个询问给出一些关键点，要求切断最少代价的边使关键点都无法到达根节点
//    解题思路：构建虚树，使用树形DP计算最小割
//    时间复杂度：O(n log n + ∑k log k)
//
// 3. Codeforces 1000G - Two Melborians, One Siberian
//    链接：https://codeforces.com/problemset/problem/1000/G
//    题意：在树上处理多组询问，涉及关键点的最短距离等信息
//    解题思路：利用虚树优化多次查询
//    时间复杂度：O(n log n + ∑k log k)
//
// 4. AtCoder ABC154F - Many Many Paths
//    链接：https://atcoder.jp/contests/abc154/tasks/abc154_f
//    题意：计算树上路径数量，可以使用虚树优化
//    解题思路：使用虚树优化路径计数
//    时间复杂度：O(n log n + ∑k log k)
//
// 5. LOJ #6056 - 「雅礼集训 2017 Day11」回转寿司
//    链接：https://loj.ac/p/6056
//    题意：涉及树上关键点的查询问题
//    解题思路：构建虚树并进行动态规划
//    时间复杂度：O(n log n + ∑k log k)
//
// 6. 洛谷 P4103 - [HEOI2014]大工程
//    链接：https://www.luogu.com.cn/problem/P4103
//    题意：给一棵树和多个询问，每个询问给出一些关键点，要求计算所有关键点对之间距离的和、最小值和最大值
//    解题思路：构建虚树后进行DFS，维护相关距离信息
//    时间复杂度：O(n log n + ∑k)
//
// 7. 洛谷 P3233 - [HNOI2014]世界树
//    链接：https://www.luogu.com.cn/problem/P3233
//    题意：给一棵树和多个询问，每个询问给出一些关键点，要求计算每个关键点能管理多少个点
//    解题思路：构建虚树，进行两次DFS，计算最近关键点
//    时间复杂度：O(n log n + ∑k log k)
//
// 8. Codeforces 1109D - Treeland and Viruses
//    链接：https://codeforces.com/problemset/problem/1109/D
//    题意：给一棵树和多个病毒源点，每个病毒源点以不同速度扩散，求每个点被哪个病毒源点感染
//    解题思路：使用虚树优化多源最短路径
//    时间复杂度：O(n log n + ∑k log k)
//
// 9. 洛谷 P3320 - [SDOI2015]寻宝游戏
//    链接：https://www.luogu.com.cn/problem/P3320
//    题意：给一棵树和多个操作，每次操作翻转一个点的状态，求收集所有宝藏的最短路径长度
//    解题思路：维护按DFS序排序的关键点集合，动态计算路径长度
//    时间复杂度：O(n log n + q log n)
//
// 10. 洛谷 P5327 - [ZJOI2019]语言
//    链接：https://www.luogu.com.cn/problem/P5327
//    题意：涉及树上路径覆盖的复杂问题
//    解题思路：利用虚树和并查集处理路径覆盖
//    时间复杂度：O(n log n + q log n)
//
// 11. SPOJ QTREE5 - Query on a tree V
//    链接：https://www.spoj.com/problems/QTREE5/
//    题意：树上点颜色修改和查询距离最近的白色节点
//    解题思路：每个节点维护子树中最近的白色节点，可以结合虚树优化
//    时间复杂度：O(n log n + q log n)
//
// 12. 洛谷 P3232 - [HNOI2013]游走
//    链接：https://www.luogu.com.cn/problem/P3232
//    题意：给定无向连通图，通过高斯消元计算边的期望经过次数，再贪心编号使总得分期望最小
//    解题思路：利用树的结构优化高斯消元，可结合虚树思想
//    时间复杂度：O(n^3)
//
// 13. 牛客网 NC19712 - 树
//    链接：https://ac.nowcoder.com/acm/problem/19712
//    题意：树上多次查询，涉及关键点的统计问题
//    解题思路：构建虚树后进行树形DP
//    时间复杂度：O(n log n + ∑k log k)
//
// 14. HDU 6621 - K-th Closest Distance
//    链接：https://acm.hdu.edu.cn/showproblem.php?pid=6621
//    题意：树上查询第k小距离
//    解题思路：结合虚树和二分查找
//    时间复杂度：O(n log n + q log n log W)
//
// 15. POJ 3728 - The Merchant
//    链接：http://poj.org/problem?id=3728
//    题意：树上多次路径查询，求最大利润
//    解题思路：构建虚树后维护区间极值
//    时间复杂度：O(n log n + ∑k)
//
// 16. Codeforces 912F - Tree Destruction
//    链接：https://codeforces.com/problemset/problem/912/F
//    题意：通过删除边获取最大收益
//    解题思路：利用树的性质，可结合虚树优化
//    时间复杂度：O(n log n)
//
// 17. 洛谷 P5021 - [NOIP2018 提高组] 赛道修建
//    链接：https://www.luogu.com.cn/problem/P5021
//    题意：树上路径覆盖问题
//    解题思路：二分答案+树形DP，可结合虚树优化
//    时间复杂度：O(n log n)
//
// 18. BZOJ 2243 - [SDOI2011]染色
//    链接：https://darkbzoj.tk/problem/2243
//    题意：树上路径颜色统计
//    解题思路：使用树链剖分，可结合虚树思想
//    时间复杂度：O(n log n + q log n)
//
// 19. Codeforces 1328F - Make k Equal
//    链接：https://codeforces.com/problemset/problem/1328/F
//    题意：通过操作使k个元素相等
//    解题思路：贪心+中位数性质，可结合虚树思想
//    时间复杂度：O(n log n)
//
// 20. 牛客网 NC20429 - 矩形面积
//    链接：https://ac.nowcoder.com/acm/problem/20429
//    题意：矩形面积并计算
//    解题思路：扫描线+线段树，可结合虚树思想
//    时间复杂度：O(n log n)
//
// 21. 杭电 HDU 5984 - Pocket Cube
//    链接：https://acm.hdu.edu.cn/showproblem.php?pid=5984
//    题意：立方体状态转换
//    解题思路：BFS+状态压缩
//    时间复杂度：O(4^6)
//
// 22. 洛谷 P5019 - [NOIP2018 提高组] 铺设道路
//    链接：https://www.luogu.com.cn/problem/P5019
//    题意：区间覆盖问题
//    解题思路：贪心或差分
//    时间复杂度：O(n)
//
// 23. Codeforces 1278F - Cards
//    链接：https://codeforces.com/problemset/problem/1278/F
//    题意：卡片收集概率问题
//    解题思路：容斥原理
//    时间复杂度：O(2^n)
//
// 24. 牛客网 NC16341 - 矩形覆盖
//    链接：https://ac.nowcoder.com/acm/problem/16341
//    题意：矩形覆盖问题
//    解题思路：扫描线+线段树
//    时间复杂度：O(n log n)
//
// 25. 杭电 HDU 4612 - Warm up 2
//    链接：https://acm.hdu.edu.cn/showproblem.php?pid=4612
//    题意：边双连通分量+树的直径
//    解题思路：缩点+树的直径算法
//    时间复杂度：O(n + m)
//
// 26. Codeforces 1163F2 - Clear the String (Hard Version)
//    链接：https://codeforces.com/problemset/problem/1163/F2
//    题意：字符串删除问题
//    解题思路：区间DP
//    时间复杂度：O(n^3)
//
// 27. 洛谷 P1119 - 灾后重建
//    链接：https://www.luogu.com.cn/problem/P1119
//    题意：动态最短路问题
//    解题思路：Floyd算法的离线应用
//    时间复杂度：O(n^3)
//
// 28. 牛客网 NC15567 - 矩阵游戏
//    链接：https://ac.nowcoder.com/acm/problem/15567
//    题意：矩阵中的路径问题
//    解题思路：BFS或DFS
//    时间复杂度：O(nm)
//
// 29. 杭电 HDU 5974 - A Simple Math Problem
//    链接：https://acm.hdu.edu.cn/showproblem.php?pid=5974
//    题意：数学方程求解
//    解题思路：数论知识应用
//    时间复杂度：O(log n)
//
// 30. Codeforces 1353F - Decreasing Heights
//    链接：https://codeforces.com/problemset/problem/1353/F
//    题意：网格路径问题
//    解题思路：动态规划
//    时间复杂度：O(n^2 m^2)
//
// 算法设计本质与核心思想：
// 1. 设计动机：虚树算法的核心动机是优化树上多次询问问题。当需要对树上不同关键点集合进行多次查询时，
//    如果每次都遍历整棵树，时间复杂度会很高。虚树通过只保留关键点及其LCA，将问题规模从O(n)降低到O(k)。
// 2. 数学原理：
//    - LCA性质：任意两个节点的LCA在DFS序上具有特定性质，可以用于构建虚树
//    - 节点数量上界：虚树节点数不超过2*k-1，这是通过数学归纳法可以证明的
//    - 树的结构保持：虚树保持了原树中关键点之间的祖先关系
// 3. 与其它算法的关联：
//    - 树上倍增：虚树构建需要LCA，通常使用树上倍增算法
//    - 树形DP：虚树上的动态规划是解决问题的核心
//    - 单调栈：构建虚树时使用的单调栈技巧与其它算法中的单调栈类似
// 4. 工程化应用：
//    - 内存优化：避免使用全局数组清零，用循环逐个清除
//    - 常数优化：选择合适的虚树构建方法（单调栈法通常更快）
//    - 边界处理：正确处理根节点、叶子节点等特殊情况
//
// 语言特性差异与跨语言实现：
// 1. Java实现特点：
//    - 使用对象封装，代码结构清晰
//    - 自定义FastReader提高输入效率
//    - 递归深度可能受限，需要改用迭代实现
//    - 线程安全方面需要额外考虑
// 2. C++实现特点：
//    - 性能最优，适合大数据量
//    - 需要注意编译环境问题，避免使用复杂STL
//    - 指针操作灵活但需谨慎
//    - 内存管理需要手动处理
// 3. Python实现特点：
//    - 代码简洁易懂，适合算法验证
//    - 性能相对较差，适合小数据量
//    - 列表操作方便，但需注意内存使用
//    - 递归深度限制较严格
//
// 极端场景与鲁棒性：
// 1. 空输入处理：关键点为空时的特殊处理
// 2. 极端数据规模：关键点数量接近节点总数、树退化为链的情况、深度很大的树结构
// 3. 边界条件：关键点包含根节点、关键点之间存在父子关系、关键点相邻的情况
// 4. 错误处理：需要处理输入错误、参数越界等异常情况
//
// 性能优化策略：
// 1. 算法层面优化：选择合适的虚树构建方法、优化DP状态转移方程、预处理减少重复计算
// 2. 实现层面优化：减少函数调用开销、优化内存访问模式、使用位运算等底层优化技巧
// 3. 工程层面优化：输入输出优化、内存池技术、缓存友好设计
// 4. 多线程优化：对于大规模数据，可以考虑并行处理
//
// 调试技巧与问题定位：
// 1. 中间过程打印：打印DFS序、打印LCA计算结果、打印虚树构建过程
// 2. 断言验证：验证虚树节点数量上界、验证关键点标记正确性、验证DP状态转移正确性
// 3. 性能分析：使用性能分析工具定位瓶颈、对比不同实现的性能差异、分析时间复杂度常数项影响
// 4. 测试用例设计：设计边界测试用例、设计随机测试用例、设计压力测试用例
//
// 工程化考量：
// 1. 可配置性：将算法参数设计为可配置的，提高代码复用性
// 2. 异常处理：添加详细的错误检查和异常处理机制
// 3. 单元测试：编写单元测试确保代码正确性
// 4. 文档化：提供详细的使用说明和API文档
// 5. 线程安全：确保代码在多线程环境下正确工作
// 6. 扩展性：设计良好的接口，方便扩展新功能
//
// 适用场景总结：
// 虚树算法适用于以下场景：
// 1. 树上多次询问，每次询问涉及不同的关键点集合
// 2. 每次询问的关键点数量k远小于树的总节点数n
// 3. 需要在关键点及其祖先上进行动态规划或其他操作
// 4. 时间复杂度要求较高，需要优化到O(n log n + ∑k log k)
//
// 问题判断方法：
// 如何判断一个问题是否适合使用虚树？
// 1. 问题背景是否是树上的多次询问？
// 2. 每次询问是否只涉及部分关键点？
// 3. 是否需要在这些关键点之间的路径上进行操作？
// 4. 数据范围是否要求更高效的算法？
// 如果以上四个问题的答案都是肯定的，那么虚树可能是一个合适的选择。
//
// 与其他算法结合：
// 虚树算法常常与以下算法结合使用：
// 1. 树形DP：在虚树上进行动态规划是最常见的用法
// 2. 树上倍增：用于快速计算LCA
// 3. 树链剖分：某些情况下可以结合使用
// 4. 线段树：处理区间查询和更新
// 5. 并查集：处理连通性问题
//
// 递归与非递归实现对比：
// 1. 递归实现：代码简洁，逻辑清晰，但可能受到栈深度限制
// 2. 非递归实现：避免栈溢出问题，适用于大规模数据，但代码相对复杂
//
// 标准库实现对比：
// 不同语言的标准库对树结构的支持：
// 1. C++：STL中没有直接的树结构，需要手动实现
// 2. Java：提供TreeSet、TreeMap等有序集合
// 3. Python：提供heapq等工具，但需要自己实现树结构
//
// 常数项优化：
// 1. 预处理优化：预处理所有可能需要的数据
// 2. 内存访问优化：按顺序访问内存，提高缓存命中率
// 3. 循环优化：减少循环内的操作，合并循环
// 4. 位运算优化：使用位运算替代乘除法
//
// 极端数据测试：
// 1. 空树测试
// 2. 单节点树测试
// 3. 退化为链的树测试
// 4. 完全二叉树测试
// 5. 关键点全部相邻测试
// 6. 关键点数量极大测试
//
// 虚树的局限性：
// 1. 只适用于树上多次询问问题
// 2. 要求∑k较小
// 3. 构建虚树需要预处理LCA
// 4. 对于某些问题，可能不如其他算法高效
//
// 虚树的优势：
// 1. 显著降低时间复杂度，从O(n)到O(k)
// 2. 代码实现相对简单
// 3. 应用范围广泛
// 4. 常数较小，实际运行效率高
//
// 总结：
// 虚树是一种强大的树上优化技术，通过只保留关键点及其LCA，将问题规模降低到O(k)级别。
// 掌握虚树算法需要理解其设计思想、实现细节和应用场景，同时需要注意各种极端情况的处理。
// 通过结合树形DP等算法，虚树可以高效解决各种树上多次询问问题。

// 王国和城市，C++版（完整可编译版本）
// 一共有n个节点，给定n-1条无向边，所有节点组成一棵树
// 一共有q条查询，每条查询格式如下
// 查询 k a1 a2 ... ak : 给出了k个不同的重要点，其他点是非重要点
//                       你可以攻占非重要点，被攻占的点无法通行
//                       要让重要点两两之间不再连通，打印至少需要攻占几个非重要点
//                       如果攻占非重要点无法达成目标，打印-1
// 1 <= n、q <= 10^5
// 1 <= 所有查询给出的点的总数 <= 10^5
// 测试链接 : https://www.luogu.com.cn/problem/CF613D
// 测试链接 : https://codeforces.com/problemset/problem/613D

#include <cstdio>
#include <algorithm>

const int MAXN = 100001;
const int MAXP = 20;

int n, q, k;

// 原始树
int headg[MAXN], nextg[MAXN << 1], tog[MAXN << 1], cntg;

// 虚树
int headv[MAXN], nextv[MAXN], tov[MAXN], cntv;

// 树上倍增求LCA + 生成dfn序
int dep[MAXN], dfn[MAXN], stjump[MAXN][MAXP], cntd;

// 关键点数组
int arr[MAXN];
// 标记节点是否是关键点
bool isKey[MAXN];

// 第一种建树方式
int tmp[MAXN << 1];
// 第二种建树方式
int stk[MAXN];

// 动态规划相关
// siz[u]，还有几个重要点没和u断开，值为0或者1
// cost[u]，表示节点u的子树中，做到不违规，至少需要攻占几个非重要点
int siz[MAXN], cost[MAXN];

// 原始树连边
// 函数功能：向原始树中添加无向边
// 参数：
//   u: 边的一个端点
//   v: 边的另一个端点
// 时间复杂度：O(1)
// 空间复杂度：O(1)
// 注意：由于是无向边，需要在邻接表中添加两个方向的边
void addEdgeG(int u, int v) {
    cntg++;
    nextg[cntg] = headg[u];
    tog[cntg] = v;
    headg[u] = cntg;
}

// 虚树连边
// 函数功能：向虚树中添加有向边
// 参数：
//   u: 边的父节点
//   v: 边的子节点
// 时间复杂度：O(1)
// 空间复杂度：O(1)
// 注意：虚树是有向树，边的方向是从父节点指向子节点
void addEdgeV(int u, int v) {
    cntv++;
    nextv[cntv] = headv[u];
    tov[cntv] = v;
    headv[u] = cntv;
}

// 按DFS序排序
// 函数功能：根据节点的DFS序对节点数组进行排序
// 参数：
//   nums: 需要排序的节点数组
//   l: 排序的起始位置
//   r: 排序的结束位置
// 时间复杂度：O(k log k)，其中k是数组长度
// 空间复杂度：O(log k)，递归栈空间
// 实现细节：使用双指针快速排序算法，比较的是节点的DFS序
void sortByDfn(int nums[], int l, int r) {
    if (l >= r) return;
    int i = l, j = r;
    int pivot = nums[(l + r) >> 1];
    while (i <= j) {
        while (dfn[nums[i]] < dfn[pivot]) i++;
        while (dfn[nums[j]] > dfn[pivot]) j--;
        if (i <= j) {
            int t = nums[i]; nums[i] = nums[j]; nums[j] = t;
            i++; j--;
        }
    }
    sortByDfn(nums, l, j);
    sortByDfn(nums, i, r);
}

// 树上倍增DFS预处理
// 函数功能：进行深度优先搜索，预处理每个节点的深度、DFS序和倍增表
// 参数：
//   u: 当前节点
//   fa: 当前节点的父节点
// 时间复杂度：O(n log n)，其中n是节点总数
// 空间复杂度：O(n log n)，存储倍增表
// 实现细节：
//   1. 计算当前节点的深度和DFS序
//   2. 填充倍增表，用于后续快速查询LCA
//   3. 递归处理所有子节点
void dfs(int u, int fa) {
    dep[u] = dep[fa] + 1;  // 深度计算
    cntd++;  // DFS序计数器
    dfn[u] = cntd;  // 记录节点的DFS序
    stjump[u][0] = fa;  // 倍增表第0层（直接父节点）
    // 预处理倍增表的其他层
    for (int p = 1; p < MAXP; p++) {
        stjump[u][p] = stjump[stjump[u][p - 1]][p - 1];
    }
    // 递归处理所有子节点
    for (int e = headg[u]; e > 0; e = nextg[e]) {
        if (tog[e] != fa) {  // 避免回父节点
            dfs(tog[e], u);
        }
    }
}

// 计算LCA（最低公共祖先）
// 函数功能：使用树上倍增法计算两个节点的最低公共祖先
// 参数：
//   a: 第一个节点
//   b: 第二个节点
// 返回值：两个节点的最低公共祖先
// 时间复杂度：O(log n)
// 空间复杂度：O(1)
// 实现细节：
//   1. 首先将深度较大的节点向上跳，使两个节点处于同一深度
//   2. 然后同时向上跳，直到找到共同的祖先
int getLca(int a, int b) {
    // 确保a的深度不小于b
    if (dep[a] < dep[b]) {
        int t = a; a = b; b = t;
    }
    // 将a向上跳，直到与b深度相同
    for (int p = MAXP - 1; p >= 0; p--) {
        if (dep[stjump[a][p]] >= dep[b]) {
            a = stjump[a][p];
        }
    }
    // 如果此时a和b相同，直接返回
    if (a == b) {
        return a;
    }
    // 同时向上跳，直到找到LCA
    for (int p = MAXP - 1; p >= 0; p--) {
        if (stjump[a][p] != stjump[b][p]) {
            a = stjump[a][p];
            b = stjump[b][p];
        }
    }
    // LCA是它们的父节点
    return stjump[a][0];
}

// 二次排序法构建虚树
// 函数功能：使用二次排序法构建关键点的虚树
// 步骤：
//   1. 将关键点按DFS序排序
//   2. 对相邻关键点求LCA并加入序列
//   3. 再次排序并去重得到虚树所有节点
//   4. 连接相邻节点的LCA
// 返回值：虚树的根节点
// 时间复杂度：O(k log k)
// 空间复杂度：O(k)
// 算法正确性：通过包含所有关键点及其两两LCA，确保虚树保留了原树中关键点之间的路径关系
int buildVirtualTree1() {
    // 按DFS序排序关键点
    sortByDfn(arr, 1, k);
    int len = 0;
    // 将关键点和它们的LCA加入临时数组
    for (int i = 1; i < k; i++) {
        len++;
        tmp[len] = arr[i];
        len++;
        tmp[len] = getLca(arr[i], arr[i + 1]);
    }
    len++;
    tmp[len] = arr[k];
    // 再次排序并去重
    sortByDfn(tmp, 1, len);
    int unique = 1;
    for (int i = 2; i <= len; i++) {
        if (tmp[unique] != tmp[i]) {
            unique++;
            tmp[unique] = tmp[i];
        }
    }
    // 构建虚树
    cntv = 0;  // 重置虚树边计数器
    for (int i = 1; i <= unique; i++) {
        headv[tmp[i]] = 0;  // 清空邻接表
    }
    for (int i = 1; i < unique; i++) {
        // 连接相邻节点的LCA
        addEdgeV(getLca(tmp[i], tmp[i + 1]), tmp[i + 1]);
    }
    return tmp[1];  // 返回虚树的根节点
}

// 单调栈法构建虚树
// 函数功能：使用单调栈法构建关键点的虚树
// 步骤：
//   1. 将关键点按DFS序排序
//   2. 使用栈维护虚树的一条链
//   3. 逐个插入关键点并维护栈结构
// 返回值：虚树的根节点
// 时间复杂度：O(k log k)
// 空间复杂度：O(k)
// 算法正确性：利用栈维护当前处理的链，通过LCA判断节点之间的关系，确保虚树的正确性
int buildVirtualTree2() {
    // 按DFS序排序关键点
    sortByDfn(arr, 1, k);
    cntv = 0;  // 重置虚树边计数器
    headv[arr[1]] = 0;  // 清空第一个节点的邻接表
    int top = 0;  // 栈顶指针
    top++;
    stk[top] = arr[1];  // 将第一个节点入栈
    // 处理剩余的关键点
    for (int i = 2; i <= k; i++) {
        int x = arr[i];  // 当前处理的节点
        int y = stk[top];  // 栈顶节点
        int lca = getLca(x, y);  // 计算LCA
        // 调整栈结构，直到找到合适的位置
        while (top > 1 && dfn[stk[top - 1]] >= dfn[lca]) {
            addEdgeV(stk[top - 1], stk[top]);  // 连接栈顶两个节点
            top--;  // 弹出栈顶
        }
        // 如果LCA不是栈顶节点，需要将LCA入栈
        if (lca != stk[top]) {
            headv[lca] = 0;  // 清空LCA的邻接表
            addEdgeV(lca, stk[top]);  // 连接LCA和栈顶节点
            stk[top] = lca;  // 替换栈顶为LCA
        }
        headv[x] = 0;  // 清空当前节点的邻接表
        top++;
        stk[top] = x;  // 将当前节点入栈
    }
    // 处理栈中剩余的节点
    while (top > 1) {
        addEdgeV(stk[top - 1], stk[top]);  // 连接栈顶两个节点
        top--;  // 弹出栈顶
    }
    return stk[1];  // 返回虚树的根节点
}

// 树形DP函数
// 函数功能：在虚树上进行动态规划，计算需要攻占的最少非关键点数量
// 参数：
//   u: 当前处理的节点
// 状态定义：
//   siz[u]: 表示节点u的子树中还有多少个未处理的关键点
//   cost[u]: 表示节点u的子树中，为了使关键点不连通所需攻占的最少非关键点数量
// 时间复杂度：O(k)
// 空间复杂度：O(k)，递归栈空间
// 算法正确性：
//   1. 如果当前节点是关键点，则它需要断开与其所有子节点中的关键点的连接
//   2. 如果当前节点是非关键点，且有多个未处理的关键点，则需要攻占该节点
void dp(int u) {
    cost[u] = siz[u] = 0;  // 初始化状态
    // 递归处理所有子节点
    for (int e = headv[u]; e > 0; e = nextv[e]) {
        int v = tov[e];
        dp(v);  // 递归处理子节点
        cost[u] += cost[v];  // 累加子节点的成本
        siz[u] += siz[v];  // 累加子节点的未处理关键点数量
    }
    if (isKey[u]) {  // 如果当前节点是关键点
        cost[u] += siz[u];  // 需要断开所有子树中的关键点
        siz[u] = 1;  // 标记当前节点为需要处理的关键点
    } else if (siz[u] > 1) {  // 如果当前节点非关键，但有多个未处理的关键点
        cost[u]++;  // 攻占该节点
        siz[u] = 0;  // 该节点被攻占后，子树中的关键点都被处理了
    }
    // 注意：如果siz[u] == 1，则不需要处理，因为这些关键点可以在更高的层次处理
}


// 计算函数
// 函数功能：处理一个查询，计算需要攻占的最少非关键点数量
// 返回值：需要攻占的最少非关键点数量，如果不可能则返回-1
// 时间复杂度：O(k log k)
// 空间复杂度：O(k)
// 实现细节：
//   1. 标记关键点
//   2. 检查是否存在相邻的关键点（这种情况无法通过攻占非关键点解决）
//   3. 构建虚树
//   4. 执行树形DP
//   5. 清除关键点标记
//   6. 返回结果
int compute() {
    // 标记关键点
    for (int i = 1; i <= k; i++) {
        isKey[arr[i]] = true;
    }
    // 检查是否存在相邻的关键点
    bool check = true;
    for (int i = 1; i <= k; i++) {
        // 如果一个关键点的父节点也是关键点，则无法通过攻占非关键点使它们不连通
        if (isKey[stjump[arr[i]][0]]) {
            check = false;
            break;
        }
    }
    int ans = -1;  // 默认返回-1表示不可能
    if (check) {  // 如果不存在相邻的关键点
        int tree = buildVirtualTree1();  // 构建虚树
        // int tree = buildVirtualTree2();  // 也可以使用单调栈法构建虚树
        dp(tree);  // 执行树形DP
        ans = cost[tree];  // 获取结果
    }
    // 清除关键点标记
    for (int i = 1; i <= k; i++) {
        isKey[arr[i]] = false;
    }
    return ans;  // 返回结果
}


// 主函数
// 处理输入输出，构建原树，执行预处理，并处理每个查询
// 注意：在实际使用中，需要根据具体输入格式进行调整
int main() {
    // 读取节点数n
    scanf("%d", &n);
    
    // 初始化原始树
    for (int i = 1; i <= n; i++) {
        headg[i] = 0;
    }
    cntg = 0;
    
    // 读取n-1条边
    for (int i = 1, u, v; i < n; i++) {
        scanf("%d%d", &u, &v);
        addEdgeG(u, v);
        addEdgeG(v, u);
    }
    
    // 预处理：DFS建立倍增表和时间戳
    cntd = 0;
    dfs(1, 0);
    
    // 读取查询数q
    scanf("%d", &q);
    
    // 处理每个查询
    for (int t = 1; t <= q; t++) {
        scanf("%d", &k);
        
        // 读取k个关键点
        for (int i = 1; i <= k; i++) {
            scanf("%d", &arr[i]);
        }
        
        // 计算并输出结果
        printf("%d\n", compute());
    }
    
    return 0;
}