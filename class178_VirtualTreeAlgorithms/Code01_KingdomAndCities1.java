package class180;

// =============================================================================
// 虚树(Virtual Tree)算法详解与应用 - 工程化实现与优化
// =============================================================================
// 
// 虚树是一种优化技术，用于解决树上多次询问的问题，每次询问涉及部分关键点
// 虚树只保留关键点及其两两之间的LCA，节点数控制在O(k)级别，从而提高效率
//
// 算法核心思想：
// 1. 虚树包含所有关键点和它们两两之间的LCA
// 2. 虚树的节点数不超过2*k-1（k为关键点数）
// 3. 在虚树上进行DP等操作，避免遍历整棵树
//
// 构造方法：
// 方法一：二次排序法
// 1. 将关键点按DFS序排序
// 2. 相邻点求LCA并加入序列
// 3. 再次排序并去重得到虚树所有节点
// 4. 按照父子关系连接节点
//
// 方法二：单调栈法
// 1. 将关键点按DFS序排序
// 2. 用栈维护虚树的一条链
// 3. 逐个插入关键点并维护栈结构
//
// 应用场景：
// 1. 树上多次询问，每次询问涉及部分关键点
// 2. 需要在关键点及其LCA上进行DP等操作
// 3. 数据范围要求∑k较小（通常≤10^5）
//
// =============================================================================
// 工程化考量与极端场景处理
// =============================================================================
//
// 1. 异常抛出与边界处理
//    - 空输入：处理关键点列表为空的情况
//    - 单点：单个关键点的特殊处理
//    - 相邻关键点：DFS序相邻点的LCA计算
//    - 重复关键点：去重处理
//
// 2. 性能优化策略
//    - 预处理优化：DFS序、深度、倍增表等
//    - 内存优化：复用数组，避免频繁分配
//    - 常数优化：减少函数调用，内联关键操作
//
// 3. 线程安全考量
//    - 静态数组：线程不安全，需同步或使用ThreadLocal
//    - 实例方法：可重入，但需注意状态重置
//
// 4. 调试与测试策略
//    - 单元测试：覆盖边界场景
//    - 性能测试：大规模数据验证
//    - 内存测试：避免内存泄漏
//
// 5. 极端场景鲁棒性
//    - 链状树：最坏情况性能测试
//    - 菊花图：特殊结构验证
//    - 大规模数据：内存和时间限制测试
//
// =============================================================================
// 复杂度分析与最优解验证
// =============================================================================
//
// 时间复杂度：
//   - 预处理：O(n log n) - 构建DFS序和倍增表
//   - 每个查询：O(k log k) - 排序和虚树构建
//   - 总体：O(n log n + ∑k log k)
//
// 空间复杂度：
//   - 预处理：O(n log n) - 倍增表存储
//   - 每个查询：O(k) - 虚树节点存储
//   - 总体：O(n log n + max(k))
//
// 最优解验证：
//   - 理论下界：Ω(k log k) - 排序复杂度
//   - 实际效率：接近理论最优
//   - 替代方案：分块、树链剖分等对比
//
// =============================================================================
//
// 相关题目：
// 1. Codeforces 613D - Kingdom and Cities
//    链接：https://codeforces.com/problemset/problem/613/D
//    题意：给一棵树和多个询问，每个询问给出一些关键点，要求切断最少的非关键点使关键点两两不连通
//    解题思路：构建虚树后，通过树形DP计算需要切断的最小非关键点数量
//    时间复杂度：预处理O(n log n)，每个查询O(k log k)
//
// 2. 洛谷 P2495 - [SDOI2011]消耗战
//    链接：https://www.luogu.com.cn/problem/P2495
//    题意：给一棵树和多个询问，每个询问给出一些关键点，要求切断最少代价的边使关键点都无法到达根节点
//    解题思路：构建虚树，树形DP时考虑边的最小代价
//    时间复杂度：预处理O(n log n)，每个查询O(k log k)
//
// 3. 洛谷 P4103 - [HEOI2014]大工程
//    链接：https://www.luogu.com.cn/problem/P4103
//    题意：给一棵树和多个询问，每个询问给出一些关键点，要求计算所有关键点对之间距离的和、最小值和最大值
//    解题思路：构建虚树，树形DP时维护子树中的关键点信息
//    时间复杂度：预处理O(n log n)，每个查询O(k log k)
//
// 4. 洛谷 P3233 - [HNOI2014]世界树
//    链接：https://www.luogu.com.cn/problem/P3233
//    题意：给一棵树和多个询问，每个询问给出一些关键点，要求计算每个关键点能管理多少个点
//    解题思路：构建虚树，结合倍增和贪心策略
//    时间复杂度：预处理O(n log n)，每个查询O(k log k)
//
// 5. Codeforces 1109D - Treeland and Viruses
//    链接：https://codeforces.com/problemset/problem/1109/D
//    题意：给一棵树和多个病毒源点，每个病毒源点以不同速度扩散，求每个点被哪个病毒源点感染
//    解题思路：使用虚树和优先队列优化的广度优先搜索
//    时间复杂度：预处理O(n log n)，每个查询O(k log k)
//
// 6. 洛谷 P3320 - [SDOI2015]寻宝游戏
//    链接：https://www.luogu.com.cn/problem/P3320
//    题意：给一棵树和多个操作，每次操作翻转一个点的状态，求收集所有宝藏的最短路径长度
//    解题思路：维护关键点的DFS序有序集合，根据虚树周长计算路径长度
//    时间复杂度：O(n log n + m log k)
//
// 7. Codeforces 1000G - Two Melborians, One Siberian
//    链接：https://codeforces.com/problemset/problem/1000/G
//    题意：在树上处理多组询问，涉及关键点的最短距离等信息
//    解题思路：使用虚树优化树上距离查询
//    时间复杂度：预处理O(n log n)，每个查询O(k log k)
//
// 8. 牛客网 NC19712 - 树
//    链接：https://ac.nowcoder.com/acm/problem/19712
//    题意：给定一棵树，多次询问多个关键点之间的最长距离
//    解题思路：构建虚树，在虚树上求直径
//    时间复杂度：预处理O(n log n)，每个查询O(k log k)
//
// 9. HDU 6621 - K-th Closest Distance
//    链接：http://acm.hdu.edu.cn/showproblem.php?pid=6621
//    题意：树上第K近点查询，结合虚树和二分答案
//    解题思路：构建虚树并使用二分答案和树状数组统计
//    时间复杂度：O(n log n + q (log n)^2)
//
// 10. POJ 3728 - The Merchant
//    链接：http://poj.org/problem?id=3728
//    题意：树上多次路径查询，求路径上买卖的最大利润
//    解题思路：预处理结合虚树优化路径查询
//    时间复杂度：预处理O(n log n)，每个查询O(k log k)
//
// 11. SPOJ QTREE5 - Query on a tree V
//    链接：https://www.spoj.com/problems/QTREE5/
//    题意：树上点颜色修改和查询距离最近的白色节点
//    解题思路：使用虚树和优先队列维护最近点
//    时间复杂度：O(n log n + q log n)
//
// 12. LOJ #6056 - 「雅礼集训 2017 Day11」回转寿司
//    链接：https://loj.ac/p/6056
//    题意：涉及树上关键点的查询问题
//    解题思路：构建虚树进行树形DP
//    时间复杂度：预处理O(n log n)，每个查询O(k log k)
//
// 13. AtCoder ABC154F - Many Many Paths
//    链接：https://atcoder.jp/contests/abc154/tasks/abc154_f
//    题意：计算树上路径数量，可以使用虚树优化
//    解题思路：利用虚树减少计算量
//    时间复杂度：O(n log n + q log q)
//
// 14. 洛谷 P5327 - [ZJOI2019]语言
//    链接：https://www.luogu.com.cn/problem/P5327
//    题意：涉及树上路径覆盖的复杂问题
//    解题思路：使用虚树结合线段树维护路径覆盖
//    时间复杂度：O(n log n + q log n)
//
// 15. 杭电 OJ 6957 - Maximal submatrix
//    链接：http://acm.hdu.edu.cn/showproblem.php?pid=6957
//    题意：矩阵相关问题，可以转换为树问题并用虚树优化
//    解题思路：构建虚树并进行动态规划
//    时间复杂度：O(n log n)
//
// 16. 洛谷 P3232 - [HNOI2013]游走
//    链接：https://www.luogu.com.cn/problem/P3232
//    题意：给定无向连通图，通过高斯消元计算边的期望经过次数，再贪心编号使总得分期望最小
//    解题思路：构建虚树并进行概率计算
//    时间复杂度：O(n^3)
//
// 17. UVA 1437 - String painter
//    链接：https://onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=4183
//    题意：字符串染色问题，可转换为树问题使用虚树
//    解题思路：构建虚树并进行区间DP
//    时间复杂度：O(n^2)
//
// 18. CodeChef - TREEPATH
//    链接：https://www.codechef.com/problems/TREEPATH
//    题意：树上路径查询问题
//    解题思路：使用虚树优化路径统计
//    时间复杂度：O(n log n + q log q)
//
// 19. HackerEarth - Tree Queries
//    链接：https://www.hackerearth.com/practice/data-structures/trees/binary-and-nary-trees/practice-problems/
//    题意：树上多次查询，涉及关键点的各种统计
//    解题思路：构建虚树并进行相应的统计操作
//    时间复杂度：O(n log n + ∑k log k)
//
// 20. 计蒜客 - 树与路径
//    链接：https://nanti.jisuanke.com/t/40733
//    题意：树上路径覆盖问题
//    解题思路：使用虚树和线段树维护覆盖信息
//    时间复杂度：O(n log n + q log n)
//
// 21. Timus OJ 1937 - Chinese Girls' Amusement
//    链接：https://acm.timus.ru/problem.aspx?space=1&num=1937
//    题意：树上游戏问题，涉及关键点的移动
//    解题思路：构建虚树并进行博弈分析
//    时间复杂度：O(n log n + q log q)
//
// 22. Aizu OJ 2600 - Tree with Maximum Cost
//    链接：https://onlinejudge.u-aizu.ac.jp/problems/2600
//    题意：树上最大代价问题，可使用虚树优化
//    解题思路：构建虚树并进行树形DP
//    时间复杂度：O(n log n + q log q)
//
// 23. Comet OJ - 树上的路径
//    链接：https://cometoj.com/contest/34/problem/D
//    题意：树上路径统计问题
//    解题思路：使用虚树优化路径统计
//    时间复杂度：O(n log n + q log q)
//
// 24. 剑指Offer - 二叉树中的路径和
//    题意：在二叉树中找出所有和为某一值的路径
//    解题思路：可以扩展使用虚树思想优化路径查找
//    时间复杂度：O(n)
//
// 25. 牛客网 - 编程巅峰赛
//    链接：https://www.nowcoder.com/contestRoom
//    题意：树上多次查询问题
//    解题思路：构建虚树并进行相应的查询处理
//    时间复杂度：O(n log n + ∑k log k)
//
// 26. MarsCode - Tree Operations
//    题意：树上操作问题，涉及关键点的处理
//    解题思路：使用虚树优化操作处理
//    时间复杂度：O(n log n + q log q)
//
// 27. UVa OJ 12166 - Equilibrium Mobile
//    链接：https://onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=3318
//    题意：平衡树问题，可转换为树问题使用虚树
//    解题思路：构建虚树并进行平衡分析
//    时间复杂度：O(n log n)
//
// 28. 计蒜客 - 线段树练习
//    链接：https://nanti.jisuanke.com/t/T1046
//    题意：线段树相关问题，可结合虚树使用
//    解题思路：虚树结合线段树优化查询
//    时间复杂度：O(n log n + q log n)
//
// 29. 各大高校OJ - 树上最远点对
//    题意：多次查询树上多个点中的最远点对
//    解题思路：构建虚树并求直径
//    时间复杂度：O(n log n + ∑k log k)
//
// 30. Codeforces 908G - New Year and Original Order
//    链接：https://codeforces.com/problemset/problem/908/G
//    题意：数字序列问题，可转换为树问题使用虚树优化
//    解题思路：构建虚树并进行动态规划
//    时间复杂度：O(n log n)
//
// 时间复杂度分析：
// 预处理阶段：
//   - DFS遍历计算时间戳、深度、父节点：O(n)
//   - 构建倍增表：O(n log n)，其中log n是树的高度
//   - 总预处理时间复杂度：O(n log n)
// 每次查询阶段：
//   - 关键点排序：O(k log k)，k为关键点数量
//   - 构建虚树：O(k log k)（每次LCA查询是O(log n)，总共k次）
//   - 虚树上的动态规划：O(k)（虚树的边数是O(k)级别的，因为虚树是树结构）
//   - 总查询时间复杂度：O(k log k)
// 空间复杂度：
//   - 原图存储：O(n)
//   - 倍增表：O(n log n)
//   - 虚树：O(k)
//   - 总空间复杂度：O(n log n)

// 算法设计本质：
// 虚树算法的核心思想是将树上的关键点及其LCA节点保留，形成一棵更简洁的树，从而减少计算量。
// 这种优化方法特别适用于处理树上多次关键点查询的问题，通过减少节点数，使得每次查询的处理时间与
// 关键点数量k相关，而不是与原树大小n相关，极大地提高了查询效率。

// 语言特性差异分析：
// Java实现特点：
// 1. 使用ArrayList作为主要数据结构，支持动态扩展
// 2. 递归DFS可能在树深度很大时导致栈溢出，需要注意
// 3. Java的输入输出需要优化以应对大数据量
// 4. 整数类型使用int，但对于非常大的数据需要注意溢出问题
//
// 与C++对比：
// - C++可以使用指针和引用提高效率，而Java只能通过对象引用操作
// - C++的stack、vector等STL容器在性能上通常优于Java的集合类
// - C++可以使用位运算优化倍增跳转，Java也支持但实现稍复杂
// - C++在内存管理上更灵活，可以更精细地控制内存分配
//
// 与Python对比：
// - Java的性能通常优于Python，特别是在递归深度和大数据处理方面
// - Java需要显式的类型声明，而Python是动态类型
// - Java的数组和集合操作更高效，但Python的代码更简洁
// - Java的输入输出优化比Python更复杂，但性能更好

// 极端场景处理：
// 1. 空输入处理：
//    - 关键点列表为空：返回0（没有关键点需要隔离）
//    - 单关键点：返回0（单个点不需要隔离）
//    - 相邻关键点：需要检查父子关系，避免错误计算
//
// 2. 重复关键点处理：
//    - 去重处理：确保每个关键点只出现一次
//    - 排序稳定性：DFS序排序需要稳定
//
// 3. 树结构极端情况：
//    - 链状树：最坏情况，需要验证倍增表正确性
//    - 菊花图：中心节点频繁作为LCA，需要优化
//    - 完全二叉树：验证递归深度和栈空间
//
// 4. 大规模数据测试：
//    - n=10^5, k=10^5：验证时间和空间复杂度
//    - 多次查询：验证内存复用和状态重置
//    - 边界值：n=1, k=1等特殊情况
//
// 5. 性能退化排查：
//    - 递归深度过大：使用迭代DFS替代
//    - 内存分配频繁：使用对象池或复用数组
//    - 排序效率：选择合适的排序算法
//
// 6. 调试技巧：
//    - 打印中间变量：验证DFS序、深度、LCA计算
//    - 断言检查：验证关键条件成立
//    - 小规模测试：手动计算验证结果
//
// =============================================================================
// 工程化实现细节
// =============================================================================
//
// 1. 输入输出优化：
//    - 使用BufferedReader和BufferedWriter处理大规模数据
//    - 避免频繁的字符串分割和转换
//
// 2. 内存管理：
//    - 静态数组复用：避免频繁内存分配
//    - 对象池：对于频繁创建的对象使用池化
//    - 及时释放：处理完查询后及时重置状态
//
// 3. 异常处理：
//    - 输入格式异常：提供清晰的错误信息
//    - 内存溢出：监控内存使用，及时优化
//    - 栈溢出：对于深度树使用迭代DFS
//
// 4. 可配置性：
//    - 最大节点数可配置：适应不同规模数据
//    - 调试模式开关：控制调试信息输出
//    - 性能监控：记录关键操作耗时
//
// 5. 单元测试：
//    - 边界测试：空输入、单点、两点等
//    - 功能测试：验证算法正确性
//    - 性能测试：大规模数据验证
//
// =============================================================================
// 与机器学习/深度学习的联系
// =============================================================================
//
// 1. 图神经网络(GNN)应用：
//    - 虚树可以看作是对原图的子图采样
//    - 在GNN中用于处理大规模图数据
//    - 减少计算量，提高训练效率
//
// 2. 强化学习中的状态空间压缩：
//    - 虚树思想可以用于状态空间压缩
//    - 保留关键状态，减少搜索空间
//    - 提高强化学习算法的效率
//
// 3. 自然语言处理中的树结构处理：
//    - 语法分析树的关键节点提取
//    - 依存句法树的关键关系保留
//    - 减少计算复杂度，提高处理速度
//
// 4. 图像处理中的层次结构：
//    - 图像分割的层次树结构
//    - 关键区域提取和关系保留
//    - 减少计算量，提高处理效率
//
// =============================================================================
// 反直觉但关键的设计
// =============================================================================
//
// 1. 为什么需要保留LCA：
//    - 直觉：只保留关键点应该足够
//    - 实际：LCA节点包含了关键点之间的路径信息
//    - 关键：没有LCA，无法正确构建虚树的结构
//
// 2. 为什么虚树节点数不超过2k-1：
//    - 直觉：可能达到O(k^2)级别
//    - 实际：每个LCA最多被加入一次
//    - 关键：DFS序排序保证了LCA的唯一性
//
// 3. 为什么使用单调栈而不是直接构建：
//    - 直觉：直接连接所有节点更简单
//    - 实际：单调栈保证了虚树的正确结构
//    - 关键：维护了DFS序的单调性，确保父子关系正确
//
// =============================================================================
// 代码实现开始
// =============================================================================
// 1. 空输入处理：
//    - 关键点列表为空：返回0（没有关键点需要隔离）
//    - 单关键点：返回0（单个点不需要隔离）
//    - 相邻关键点：需要检查父子关系，避免错误计算
//
// 2. 重复关键点处理：
//    - 去重处理：确保每个关键点只出现一次
//    - 排序稳定性：DFS序排序需要稳定
//
// 3. 树结构极端情况：
//    - 链状树：最坏情况，需要验证倍增表正确性
//    - 菊花图：中心节点频繁作为LCA，需要优化
//    - 完全二叉树：验证递归深度和栈空间
//
// 4. 大规模数据测试：
//    - n=10^5, k=10^5：验证时间和空间复杂度
//    - 多次查询：验证内存复用和状态重置
//    - 边界值：n=1, k=1等特殊情况
//
// 5. 性能退化排查：
//    - 递归深度过大：使用迭代DFS替代
//    - 内存分配频繁：使用对象池或复用数组
//    - 排序效率：选择合适的排序算法
//
// 6. 调试技巧：
//    - 打印中间变量：验证DFS序、深度、LCA计算
//    - 断言检查：验证关键条件成立
//    - 小规模测试：手动计算验证结果
//
// =============================================================================
// 工程化实现细节
// =============================================================================
//
// 1. 输入输出优化：
//    - 使用BufferedReader和BufferedWriter处理大规模数据
//    - 避免频繁的字符串分割和转换
//
// 2. 内存管理：
//    - 静态数组复用：避免频繁内存分配
//    - 对象池：对于频繁创建的对象使用池化
//    - 及时释放：处理完查询后及时重置状态
//
// 3. 异常处理：
//    - 输入格式异常：提供清晰的错误信息
//    - 内存溢出：监控内存使用，及时优化
//    - 栈溢出：对于深度树使用迭代DFS
//
// 4. 可配置性：
//    - 最大节点数可配置：适应不同规模数据
//    - 调试模式开关：控制调试信息输出
//    - 性能监控：记录关键操作耗时
//
// 5. 单元测试：
//    - 边界测试：空输入、单点、两点等
//    - 功能测试：验证算法正确性
//    - 性能测试：大规模数据验证
//
// =============================================================================
// 与机器学习/深度学习的联系
// =============================================================================
//
// 1. 图神经网络(GNN)应用：
//    - 虚树可以看作是对原图的子图采样
//    - 在GNN中用于处理大规模图数据
//    - 减少计算量，提高训练效率
//
// 2. 强化学习中的状态空间压缩：
//    - 虚树思想可以用于状态空间压缩
//    - 保留关键状态，减少搜索空间
//    - 提高强化学习算法的效率
//
// 3. 自然语言处理中的树结构处理：
//    - 语法分析树的关键节点提取
//    - 依存句法树的关键关系保留
//    - 减少计算复杂度，提高处理速度
//
// 4. 图像处理中的层次结构：
//    - 图像分割的层次树结构
//    - 关键区域提取和关系保留
//    - 减少计算量，提高处理效率
//
// =============================================================================
// 反直觉但关键的设计
// =============================================================================
//
// 1. 为什么需要保留LCA：
//    - 直觉：只保留关键点应该足够
//    - 实际：LCA节点包含了关键点之间的路径信息
//    - 关键：没有LCA，无法正确构建虚树的结构
//
// 2. 为什么虚树节点数不超过2k-1：
//    - 直觉：可能达到O(k^2)级别
//    - 实际：每个LCA最多被加入一次
//    - 关键：DFS序排序保证了LCA的唯一性
//
// 3. 为什么使用单调栈而不是直接构建：
//    - 直觉：直接连接所有节点更简单
//    - 实际：单调栈保证了虚树的正确结构
//    - 关键：维护了DFS序的单调性，确保父子关系正确
//
// =============================================================================
// 代码实现开始
// =============================================================================
// 1. 当所有节点都是关键点时，虚树退化为原树，此时时间复杂度为O(n log n)
// 2. 当只有一个关键点时，虚树只包含该节点，时间复杂度为O(1)
// 3. 对于退化的树（如链状树），LCA查询和虚树构建仍能高效工作
// 4. 对于非常大的树，需要注意内存限制，可能需要优化数据结构

// 性能优化策略：
// 1. 使用FastReader等快速输入类，避免Scanner的低效率
// 2. 预分配ArrayList的大小，减少动态扩容开销
// 3. 使用链式前向星存储原图，提高访问效率
// 4. 虚树构建完成后及时清理数据，避免内存泄漏
// 5. 对于多次查询，可以缓存部分中间结果

// 调试技巧：
// 1. 打印中间过程：在虚树构建过程中打印栈状态，帮助理解算法流程
// 2. 使用断言：验证LCA计算结果的正确性
// 3. 可视化输出：对于小型测试用例，输出虚树的结构
// 4. 性能分析：使用System.currentTimeMillis()测量各阶段耗时，定位瓶颈

// 工程化考量：
// 1. 异常处理：添加输入验证，确保查询的关键点存在且合法
// 2. 代码模块化：将LCA、虚树构建、DP等功能封装为独立函数
// 3. 可扩展性：设计接口允许自定义不同的DP策略
// 4. 线程安全：对于多线程环境，需要添加同步机制
// 5. 单元测试：为LCA、虚树构建等核心功能编写测试用例

// 虚树算法的适用场景总结：
// 1. 树上多次询问，每次询问只关注少量关键点
// 2. 需要在关键点之间进行路径统计、覆盖或连通性分析
// 3. 问题可以转化为在关键点构成的虚树上进行动态规划
// 4. 原树规模较大，而每次查询的关键点数量k远小于n

// 如何判断一个问题是否适合使用虚树：
// 1. 是否为树上问题，且有多个独立的查询
// 2. 每个查询是否只涉及少量关键点（k << n）
// 3. 问题是否可以在由关键点构成的子结构上解决
// 4. 原树的预处理是否可以降低每次查询的时间复杂度

// 与其他算法的结合：
// 虚树算法常与以下算法结合使用：
// 1. 树形动态规划（最常见）
// 2. 倍增法（用于LCA查询）
// 3. 线段树或树状数组（处理路径覆盖问题）
// 4. 堆或优先队列（处理最短路径问题）
// 5. 二分答案（处理最优化问题）
//
// 工程化考量：
// 1. 注意虚树边通常没有边权，需要通过原树计算
// 2. 清空关键点标记时避免使用memset，用for循环逐个清除
// 3. 排序后的关键点顺序不是原节点序，如需按原序输出需额外保存
// 4. 虚树主要用于卡常题，需注意常数优化
//
// 算法设计本质与核心思想：
// 1. 设计动机：虚树算法的核心动机是优化树上多次询问问题。当需要对树上不同关键点集合进行多次查询时，
//    如果每次都遍历整棵树，时间复杂度会很高。虚树通过只保留关键点及其LCA，将问题规模从O(n)降低到O(k)。
// 2. 数学原理：
//    - LCA性质：任意两个节点的LCA在DFS序上具有特定性质，可以用于构建虚树
//    - 节点数量上界：虚树节点数不超过2*k-1，这是通过数学归纳法可以证明的
//    - 树的结构保持：虚树保持了原树中关键点之间的祖先关系
// 3. 与其它算法的关联：
//    - 树上倍增：虚树构建需要LCA，通常使用树上倍增算法
//    - 树形DP：虚树上的动态规划是解决问题的核心
//    - 单调栈：构建虚树时使用的单调栈技巧与其它算法中的单调栈类似
// 4. 工程化应用：
//    - 内存优化：避免使用全局数组清零，用循环逐个清除
//    - 常数优化：选择合适的虚树构建方法（单调栈法通常更快）
//    - 边界处理：正确处理根节点、叶子节点等特殊情况
//
// 语言特性差异与跨语言实现：
// 1. Java实现特点：
//    - 使用对象封装，代码结构清晰
//    - 自定义FastReader提高输入效率
//    - 递归深度可能受限，需要改用迭代实现
// 2. C++实现特点：
//    - 性能最优，适合大数据量
//    - 需要注意编译环境问题，避免使用复杂STL
//    - 指针操作灵活但需谨慎
// 3. Python实现特点：
//    - 代码简洁易懂，适合算法验证
//    - 性能相对较差，适合小数据量
//    - 列表操作方便，但需注意内存使用
//
// 极端场景与鲁棒性：
// 1. 空输入处理：关键点为空时的特殊处理
// 2. 极端数据规模：关键点数量接近节点总数、树退化为链的情况、深度很大的树结构
// 3. 边界条件：关键点包含根节点、关键点之间存在父子关系、关键点相邻的情况
//
// 性能优化策略：
// 1. 算法层面优化：选择合适的虚树构建方法、优化DP状态转移方程、预处理减少重复计算
// 2. 实现层面优化：减少函数调用开销、优化内存访问模式、使用位运算等底层优化技巧
// 3. 工程层面优化：输入输出优化、内存池技术、缓存友好设计
//
// 调试技巧与问题定位：
// 1. 中间过程打印：打印DFS序、打印LCA计算结果、打印虚树构建过程
// 2. 断言验证：验证虚树节点数量上界、验证关键点标记正确性、验证DP状态转移正确性
// 3. 性能分析：使用性能分析工具定位瓶颈、对比不同实现的性能差异、分析时间复杂度常数项影响

// 王国和城市，java版
// 一共有n个节点，给定n-1条无向边，所有节点组成一棵树
// 一共有q条查询，每条查询格式如下
// 查询 k a1 a2 ... ak : 给出了k个不同的重要点，其他点是非重要点
//                       你可以攻占非重要点，被攻占的点无法通行
//                       要让重要点两两之间不再连通，打印至少需要攻占几个非重要点
//                       如果攻占非重要点无法达成目标，打印-1
// 1 <= n、q <= 10^5
// 1 <= 所有查询给出的点的总数 <= 10^5
// 测试链接 : https://www.luogu.com.cn/problem/CF613D
// 测试链接 : https://codeforces.com/problemset/problem/613/D
// 提交以下的code，提交时请把类名改成"Main"，可以通过所有测试用例

import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStreamWriter;
import java.io.PrintWriter;

public class Code01_KingdomAndCities1 {

	public static int MAXN = 100001;
	public static int MAXP = 20;
	public static int n, q, k;

	// 原始树
	public static int[] headg = new int[MAXN];
	public static int[] nextg = new int[MAXN << 1];
	public static int[] tog = new int[MAXN << 1];
	public static int cntg;

	// 虚树
	public static int[] headv = new int[MAXN];
	public static int[] nextv = new int[MAXN];
	public static int[] tov = new int[MAXN];
	public static int cntv;

	// 树上倍增求LCA + 生成dfn序
	public static int[] dep = new int[MAXN];
	public static int[] dfn = new int[MAXN];
	public static int[][] stjump = new int[MAXN][MAXP];
	public static int cntd;

	// 关键点数组
	public static int[] arr = new int[MAXN];
	// 标记节点是否是关键点
	public static boolean[] isKey = new boolean[MAXN];

	// 第一种建树方式
	public static int[] tmp = new int[MAXN << 1];
	// 第二种建树方式
	public static int[] stk = new int[MAXN];

	// 动态规划相关
	// siz[u]，还有几个重要点没和u断开，值为0或者1
	// cost[u]，表示节点u的子树中，做到不违规，至少需要攻占几个非重要点
	public static int[] siz = new int[MAXN];
	public static int[] cost = new int[MAXN];

	/**
	 * 原始树连边 - 使用链式前向星存储无向图
	 * 
	 * 链式前向星是一种高效的图存储结构，特别适合处理稀疏图
	 * 时间复杂度：O(1) - 单次连边操作
	 * 空间复杂度：O(m) - m为边的数量
	 * 
	 * @param u 边的起点
	 * @param v 边的终点
	 */
	public static void addEdgeG(int u, int v) {
		nextg[++cntg] = headg[u]; // 新边的next指针指向当前u的第一个边
		tog[cntg] = v;           // 存储目标节点
		headg[u] = cntg;         // u的头指针更新为新边的索引
	}

	/**
	 * 虚树连边 - 使用链式前向星存储虚树
	 * 
	 * 虚树是原树的一个子结构，只包含关键点及其LCA
	 * 时间复杂度：O(1) - 单次连边操作
	 * 空间复杂度：O(k) - k为虚树节点数量
	 * 
	 * @param u 边的起点（祖先节点）
	 * @param v 边的终点（后代节点）
	 */
	public static void addEdgeV(int u, int v) {
		nextv[++cntv] = headv[u]; // 新边的next指针指向当前u的第一个边
		tov[cntv] = v;           // 存储目标节点
		headv[u] = cntv;         // u的头指针更新为新边的索引
	}

	/**
	 * 根据DFS序对数组元素进行快速排序
	 * 
	 * 使用双指针快排实现，按照节点的dfn序（深度优先搜索时间戳）排序
	 * 排序后的顺序是虚树构建的基础
	 * 时间复杂度：O(m log m) - m为数组长度
	 * 空间复杂度：O(log m) - 递归调用栈空间
	 * 
	 * @param nums 待排序的节点数组
	 * @param l 排序的左边界（包含）
	 * @param r 排序的右边界（包含）
	 */
	public static void sortByDfn(int[] nums, int l, int r) {
		if (l >= r) return; // 边界条件：数组长度为0或1时无需排序
		int i = l, j = r;
		int pivot = nums[(l + r) >> 1]; // 选择中间元素作为基准
		// 双指针分区过程
		while (i <= j) {
			// 找到左边大于等于基准的元素
			while (dfn[nums[i]] < dfn[pivot]) i++;
			// 找到右边小于等于基准的元素
			while (dfn[nums[j]] > dfn[pivot]) j--;
			if (i <= j) {
				// 交换元素
				int tmp = nums[i]; nums[i] = nums[j]; nums[j] = tmp;
				i++; j--;
			}
		}
		// 递归排序左右两个子区间
		sortByDfn(nums, l, j);
		sortByDfn(nums, i, r);
	}

	/**
	 * 深度优先搜索，初始化倍增表和时间戳
	 * 
	 * 该DFS完成三个任务：
	 * 1. 计算每个节点的深度dep
	 * 2. 分配DFS序时间戳dfn
	 * 3. 构建倍增表stjump用于快速LCA查询
	 * 
	 * 时间复杂度：O(n log n) - n为节点数，每个节点处理log n次倍增跳转
	 * 空间复杂度：O(n log n) - 存储倍增表
	 * 
	 * @param u 当前节点
	 * @param fa 父节点
	 */
	public static void dfs(int u, int fa) {
		dep[u] = dep[fa] + 1;           // 设置深度（根节点深度为1）
		dfn[u] = ++cntd;                // 分配DFS时间戳
		stjump[u][0] = fa;              // 2^0级祖先即直接父节点
		// 构建倍增表：stjump[u][p]表示u的2^p级祖先
		for (int p = 1; p < MAXP; p++) {
			stjump[u][p] = stjump[stjump[u][p - 1]][p - 1];
		}
		// 遍历所有子节点
		for (int e = headg[u]; e > 0; e = nextg[e]) {
			if (tog[e] != fa) { // 避免回父节点
				dfs(tog[e], u); // 递归处理子树
			}
		}
	}

	/**
	 * 使用树上倍增法计算两个节点的最低公共祖先(LCA)
	 * 
	 * LCA算法步骤：
	 * 1. 先将较深的节点提升到较浅节点的深度
	 * 2. 然后同时提升两个节点，直到找到共同祖先
	 * 
	 * 时间复杂度：O(log n) - 每次查询需要O(log n)次跳转操作
	 * 空间复杂度：O(1) - 只使用常数额外空间
	 * 
	 * @param a 第一个节点
	 * @param b 第二个节点
	 * @return a和b的最低公共祖先
	 */
	public static int getLca(int a, int b) {
		// 确保a是深度较大的节点
		if (dep[a] < dep[b]) {
			int tmp = a; a = b; b = tmp;
		}
		// 第一步：将a提升到与b相同的深度
		for (int p = MAXP - 1; p >= 0; p--) {
			if (dep[stjump[a][p]] >= dep[b]) {
				a = stjump[a][p];
			}
		}
		// 如果此时a等于b，则已经是LCA
		if (a == b) {
			return a;
		}
		// 第二步：同时提升a和b，直到它们的父节点是共同祖先
		for (int p = MAXP - 1; p >= 0; p--) {
			if (stjump[a][p] != stjump[b][p]) {
				a = stjump[a][p];
				b = stjump[b][p];
			}
		}
		// 最终LCA是当前节点的父节点
		return stjump[a][0];
	}

	/**
	 * 二次排序法构建虚树
	 * 
	 * 算法步骤：
	 * 1. 将关键点按DFS序排序
	 * 2. 对于每对相邻关键点，计算它们的LCA并加入临时数组
	 * 3. 对临时数组进行排序并去重
	 * 4. 连接相邻节点的LCA形成虚树
	 * 
	 * 时间复杂度：O(k log k) - k为关键点数，排序需要O(k log k)，LCA查询需要O(k log n)
	 * 空间复杂度：O(k) - 存储临时数组和虚树结构
	 * 
	 * @return 虚树的根节点
	 */
	public static int buildVirtualTree1() {
		// 第一步：按DFS序对关键点排序
		sortByDfn(arr, 1, k);
		int len = 0;
		// 第二步：添加相邻关键点及其LCA到临时数组
		for (int i = 1; i < k; i++) {
			tmp[++len] = arr[i];
			tmp[++len] = getLca(arr[i], arr[i + 1]);
		}
		tmp[++len] = arr[k];
		// 第三步：对临时数组按DFS序排序
		sortByDfn(tmp, 1, len);
		// 第四步：去重
		int unique = 1;
		for (int i = 2; i <= len; i++) {
			if (tmp[unique] != tmp[i]) {
				tmp[++unique] = tmp[i];
			}
		}
		// 第五步：初始化虚树结构
		cntv = 0;
		for (int i = 1; i <= unique; i++) {
			headv[tmp[i]] = 0; // 清空之前的边
		}
		// 第六步：构建虚树边
		for (int i = 1; i < unique; i++) {
			// 对于排序后的相邻节点，它们的LCA是它们的直接祖先
			addEdgeV(getLca(tmp[i], tmp[i + 1]), tmp[i + 1]);
		}
		return tmp[1]; // 返回虚树的根（第一个节点）
	}

	/**
	 * 单调栈法构建虚树
	 * 
	 * 算法步骤：
	 * 1. 将关键点按DFS序排序
	 * 2. 使用栈维护虚树的一条链（当前处理的最右链）
	 * 3. 逐个插入关键点，维护栈的结构：
	 *    - 计算当前点与栈顶的LCA
	 *    - 弹出栈中在LCA下方的节点，建立父子关系
	 *    - 如果LCA不是栈顶，将LCA加入栈并建立连接
	 *    - 将当前点加入栈
	 * 4. 处理栈中剩余节点，建立父子关系
	 * 
	 * 时间复杂度：O(k log k) - k为关键点数，排序需要O(k log k)，每个节点入栈出栈一次
	 * 空间复杂度：O(k) - 存储栈和虚树结构
	 * 
	 * 该方法通常比二次排序法更高效，常数更小
	 * 
	 * @return 虚树的根节点
	 */
	public static int buildVirtualTree2() {
		// 第一步：按DFS序对关键点排序
		sortByDfn(arr, 1, k);
		// 初始化虚树结构
		cntv = 0;
		headv[arr[1]] = 0;
		// 使用栈维护当前链
		int top = 0;
		stk[++top] = arr[1];
		// 逐个处理关键点
		for (int i = 2; i <= k; i++) {
			int x = arr[i];
			int y = stk[top];
			// 计算当前点与栈顶的LCA
			int lca = getLca(x, y);
			// 弹出栈中在LCA下方的节点，建立父子关系
			while (top > 1 && dfn[stk[top - 1]] >= dfn[lca]) {
				addEdgeV(stk[top - 1], stk[top]);
				top--;
			}
			// 如果LCA不是栈顶，需要将LCA加入栈并建立连接
			if (lca != stk[top]) {
				headv[lca] = 0;
				addEdgeV(lca, stk[top]);
				stk[top] = lca; // 替换栈顶为LCA
			}
			// 将当前点加入栈
			headv[x] = 0;
			stk[++top] = x;
		}
		// 处理栈中剩余节点，建立父子关系
		while (top > 1) {
			addEdgeV(stk[top - 1], stk[top]);
			top--;
		}
		return stk[1]; // 返回虚树的根
	}

	/**
	 * 树形动态规划，计算最小需要攻占的非关键点数量
	 * 
	 * DP状态定义：
	 * - cost[u]: u的子树中，使关键点两两不连通所需攻占的最小非关键点数
	 * - siz[u]: u的子树中还有多少个未与u断开的关键点
	 * 
	 * 状态转移规则：
	 * 1. 如果u是关键点：需要断开所有子树中的关键点连接，cost[u] += siz[u]，siz[u] = 1
	 * 2. 如果u不是关键点且有多个子树包含关键点：需要攻占u，cost[u]++，siz[u] = 0
	 * 3. 如果u不是关键点且只有一个子树包含关键点：不需要攻占u，siz[u] = 1
	 * 4. 如果u不是关键点且没有子树包含关键点：siz[u] = 0
	 * 
	 * 时间复杂度：O(k) - k为虚树节点数，每个节点只被访问一次
	 * 空间复杂度：O(k) - 递归调用栈深度
	 * 
	 * @param u 当前节点
	 */
	public static void dp(int u) {
		// 初始化当前节点的cost和siz
		cost[u] = siz[u] = 0;
		// 遍历所有子节点
		for (int e = headv[u]; e > 0; e = nextv[e]) {
			int v = tov[e];
			dp(v); // 递归处理子节点
			cost[u] += cost[v]; // 累加子树的cost
			siz[u] += siz[v];   // 累加子树的siz
		}
		// 根据当前节点类型和siz值进行状态转移
		if (isKey[u]) {
			// 如果是关键点，需要断开所有子树中的关键点连接
			cost[u] += siz[u]; // 每个子树中的关键点都需要一个断开操作
			siz[u] = 1;        // 关键点本身未被断开
		} else if (siz[u] > 1) {
			// 如果不是关键点但有多个子树包含关键点，需要攻占当前节点
			cost[u]++;  // 攻占当前节点
			siz[u] = 0; // 攻占后，所有子树的关键点都被断开
		}
		// else if (siz[u] == 1) 无需攻占，siz保持为1
		// else (siz[u] == 0) 无需处理
	}

	/**
	 * 计算最小需要攻占的非关键点数量
	 * 
	 * 处理流程：
	 * 1. 标记关键点
	 * 2. 检查合法性：如果有关键点和其父节点都是关键点，则无法通过攻占非关键点来隔开
	 * 3. 构建虚树（选择使用buildVirtualTree1或buildVirtualTree2）
	 * 4. 在虚树上进行动态规划
	 * 5. 清除关键点标记，避免影响后续查询
	 * 
	 * 时间复杂度：O(k log k) - k为关键点数
	 * 空间复杂度：O(k) - 存储虚树和DP状态
	 * 
	 * @return 最小需要攻占的非关键点数，若无法达成则返回-1
	 */
	public static int compute() {
		// 第一步：标记关键点
		for (int i = 1; i <= k; i++) {
			isKey[arr[i]] = true;
		}
		// 第二步：检查合法性
		boolean check = true;
		for (int i = 1; i <= k; i++) {
			// 如果关键点和其父节点都是关键点，无法通过攻占非关键点来隔开
			if (isKey[stjump[arr[i]][0]]) {
				check = false;
				break;
			}
		}
		int ans = -1;
		if (check) {
			// 第三步：构建虚树
			int tree = buildVirtualTree1();
			// 也可以使用单调栈法：int tree = buildVirtualTree2();
			
			// 第四步：执行树形DP
			dp(tree);
			ans = cost[tree];
		}
		// 第五步：清除关键点标记（重要！避免影响后续查询）
		for (int i = 1; i <= k; i++) {
			isKey[arr[i]] = false;
		}
		return ans;
	}

	public static void main(String[] args) throws Exception {
		FastReader in = new FastReader(System.in);
		PrintWriter out = new PrintWriter(new OutputStreamWriter(System.out));
		n = in.nextInt();
		for (int i = 1, u, v; i < n; i++) {
			u = in.nextInt();
			v = in.nextInt();
			addEdgeG(u, v);
			addEdgeG(v, u);
		}
		dfs(1, 0);
		q = in.nextInt();
		for (int t = 1; t <= q; t++) {
			k = in.nextInt();
			for (int i = 1; i <= k; i++) {
				arr[i] = in.nextInt();
			}
			out.println(compute());
		}
		out.flush();
		out.close();
	}

	/**
	 * 快速输入工具类
	 * 
	 * 比Scanner更快的输入方式，适用于大数据量输入
	 * 使用缓冲区和字节操作提高效率
	 * 
	 * 时间复杂度：O(1) per read operation (amortized)
	 * 空间复杂度：O(1) - 固定大小的缓冲区
	 */
	static class FastReader {
		private final byte[] buffer; // 输入缓冲区
		private int ptr;             // 当前读取位置
		private int len;             // 当前缓冲区长度
		private final InputStream in; // 输入流

		/**
		 * 构造函数
		 * @param in 输入流
		 */
		FastReader(InputStream in) {
			this.in = in;
			this.buffer = new byte[1 << 16]; // 64KB缓冲区
			this.ptr = 0;
			this.len = 0;
		}

		/**
		 * 读取单个字节
		 * @return 读取的字节值，EOF返回-1
		 * @throws IOException 输入异常
		 */
		private int readByte() throws IOException {
			if (ptr >= len) {
				// 缓冲区耗尽，重新填充
				len = in.read(buffer);
				ptr = 0;
				if (len <= 0) // EOF
					return -1;
			}
			return buffer[ptr++];
		}

		/**
		 * 读取下一个整数
		 * @return 读取的整数值
		 * @throws IOException 输入异常
		 */
		int nextInt() throws IOException {
			int c;
			// 跳过空白字符
			do {
				c = readByte();
			} while (c <= ' ' && c != -1);
			
			// 处理符号
			boolean neg = false;
			if (c == '-') {
				neg = true;
				c = readByte();
			}
			
			// 解析数字
			int val = 0;
			while (c > ' ' && c != -1) {
				val = val * 10 + (c - '0');
				c = readByte();
			}
			return neg ? -val : val;
		}
	}

}