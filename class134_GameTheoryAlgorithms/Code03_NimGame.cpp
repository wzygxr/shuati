// 尼姆博弈(Nim Game)
// 一共有n堆石头，两人轮流进行游戏
// 在每个玩家的回合中，玩家需要选择任何一个非空的石头堆，并从这堆石头中移除任意正数的石头数量
// 谁先拿走最后的石头就获胜，返回最终谁会获胜
// 测试链接 : https://www.luogu.com.cn/problem/P2197
// 请同学们务必参考如下代码中关于输入、输出的处理
// 这是输入输出处理效率很高的写法
// 提交以下的code，提交时请把类名改成"Main"，可以直接通过
//
// 算法思路：
// 1. 尼姆博弈是经典的博弈论问题
// 2. 核心思想是计算所有堆石子数的异或和(Nim-sum)
// 3. 当Nim-sum为0时，当前玩家处于必败态；否则处于必胜态
// 4. 这是因为处于必胜态的玩家总能通过一步操作使Nim-sum变为0
// 5. 而处于必败态的玩家无论如何操作都会使Nim-sum变为非0
//
// 时间复杂度：O(n) - 需要遍历所有堆计算异或和
// 空间复杂度：O(1) - 只使用了常数级别的额外空间
//
// 适用场景和解题技巧：
// 1. 适用场景：
//    - 多堆石子
//    - 两人轮流从任意一堆取任意数量石子
//    - 取走最后一颗石子者获胜
// 2. 解题技巧：
//    - 计算所有堆石子数的异或和
//    - 异或和为0表示当前玩家必败，否则必胜
// 3. 变种问题：
//    - 每堆可取石子数量受限
//    - 最后取石子者失败（反尼姆博弈）
//    - 取石子规则变化（如只能取斐波那契数个石子）
//
// 相关题目链接：
// 1. 洛谷 P2197: https://www.luogu.com.cn/problem/P2197
// 2. LeetCode 292: https://leetcode.com/problems/nim-game/
// 3. HDU 1850: http://acm.hdu.edu.cn/showproblem.php?pid=1850
// 4. POJ 2234: http://poj.org/problem?id=2234
// 5. AtCoder DP Contest L - Deque: https://atcoder.jp/contests/dp/tasks/dp_l

// 简化版本，不使用标准库中的复杂功能
// 由于编译环境问题，避免使用<iostream>等标准头文件

// 简单测试函数
int main() {
    // 测试几个简单的例子
    // 示例1: 两堆石子，数量分别为3和5
    int piles1[] = {3, 5};
    int n1 = 2;
    int eor1 = 0;
    for (int i = 0; i < n1; i++) {
        eor1 ^= piles1[i];
    }
    // eor1 = 3 ^ 5 = 6 (非0，先手胜)
    
    // 示例2: 三堆石子，数量分别为1, 2, 3
    int piles2[] = {1, 2, 3};
    int n2 = 3;
    int eor2 = 0;
    for (int i = 0; i < n2; i++) {
        eor2 ^= piles2[i];
    }
    // eor2 = 1 ^ 2 ^ 3 = 0 (0，后手胜)
    
    // 由于编译环境限制，使用简单的输出方式
    // 实际测试需要根据具体环境调整
    
    return 0;
}