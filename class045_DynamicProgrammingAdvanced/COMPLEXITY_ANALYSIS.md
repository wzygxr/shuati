# Class067: 动态规划进阶专题 - 复杂度分析与最优解验证

## 1. 最小路径和 (Minimum Path Sum)

### 时间复杂度分析
- **暴力递归**: O(2^(m+n)) - 每次递归有两种选择（向右或向下），最坏情况下需要遍历所有可能的路径
- **记忆化搜索**: O(m*n) - 每个状态只计算一次
- **动态规划**: O(m*n) - 需要填充整个DP表
- **空间优化DP**: O(m*n) - 需要遍历整个网格

### 空间复杂度分析
- **暴力递归**: O(m+n) - 递归栈深度
- **记忆化搜索**: O(m*n) - DP数组 + 递归栈
- **动态规划**: O(m*n) - DP数组
- **空间优化DP**: O(min(m,n)) - 只使用一维数组

### 最优解验证
**结论：是** - 动态规划是解决此类最优路径问题的标准方法，时间复杂度O(m*n)已经是最优的，因为需要至少访问每个单元格一次。

## 2. 单词搜索 (Word Search)

### 时间复杂度分析
- **暴力递归**: O(m*n*4^L) - 其中L为单词长度，最坏情况下需要从每个位置开始搜索，每个位置有4个方向选择

### 空间复杂度分析
- **暴力递归**: O(m*n) - 递归栈深度和标记数组

### 最优解验证
**结论：是** - 回溯法是解决此类路径搜索问题的标准方法。由于需要检查所有可能的路径，时间复杂度O(m*n*4^L)已经是最优的。

## 3. 最长公共子序列 (Longest Common Subsequence)

### 时间复杂度分析
- **暴力递归**: O(2^(m+n)) - 存在大量重复计算
- **记忆化搜索**: O(m*n) - 每个状态只计算一次
- **动态规划**: O(m*n) - 需要填充整个DP表
- **空间优化DP**: O(m*n) - 需要遍历整个DP表

### 空间复杂度分析
- **暴力递归**: O(m+n) - 递归栈深度
- **记忆化搜索**: O(m*n) - DP数组 + 递归栈
- **动态规划**: O(m*n) - DP数组
- **空间优化DP**: O(min(m,n)) - 只使用一维数组

### 最优解验证
**结论：是** - 动态规划是解决此类字符串匹配问题的标准方法，时间复杂度O(m*n)已经是最优的，因为需要至少比较每对字符一次。

## 4. 最长回文子序列 (Longest Palindromic Subsequence)

### 时间复杂度分析
- **暴力递归**: O(2^n) - 存在大量重复计算
- **记忆化搜索**: O(n²) - 每个状态只计算一次
- **动态规划**: O(n²) - 需要填充整个DP表
- **空间优化DP**: O(n²) - 需要遍历所有可能的子串区间

### 空间复杂度分析
- **暴力递归**: O(n) - 递归栈深度
- **记忆化搜索**: O(n²) - DP数组 + 递归栈
- **动态规划**: O(n²) - DP数组
- **空间优化DP**: O(n) - 只使用一维数组

### 最优解验证
**结论：是** - 区间动态规划是解决此类回文问题的标准方法，时间复杂度O(n²)已经是最优的，因为需要至少考虑每对字符一次。

## 5. 节点数为n高度不大于m的二叉树个数 (Node Height Not Larger Than m)

### 时间复杂度分析
- **记忆化搜索**: O(n²*m) - 每个状态只计算一次
- **动态规划**: O(n²*m) - 需要遍历所有可能的节点数和高度组合
- **空间优化DP**: O(n²*m) - 需要遍历所有可能的节点数和高度组合

### 空间复杂度分析
- **记忆化搜索**: O(n*m) - DP数组 + 递归栈
- **动态规划**: O(n*m) - DP数组
- **空间优化DP**: O(n) - 只使用一维数组

### 最优解验证
**结论：是** - 树形动态规划是解决此类问题的标准方法，时间复杂度O(n²*m)已经是最优的，因为需要考虑所有可能的节点分配方案。

## 6. 矩阵中的最长递增路径 (Longest Increasing Path in a Matrix)

### 时间复杂度分析
- **暴力递归**: O(m*n*4^(m*n)) - 存在大量重复计算
- **记忆化搜索**: O(m*n) - 每个单元格只计算一次

### 空间复杂度分析
- **暴力递归**: O(m*n) - 递归栈深度
- **记忆化搜索**: O(m*n) - DP数组 + 递归栈

### 最优解验证
**结论：是** - 记忆化搜索是解决此类图中路径问题的标准方法，时间复杂度O(m*n)已经是最优的，因为每个单元格只需要计算一次。

## 总结

所有实现都采用了最优算法，时间复杂度和空间复杂度均已达到理论下限。通过动态规划、记忆化搜索等技术，我们避免了重复计算，显著提升了算法效率。