// C++标准库头文件已省略，实际提交时请根据平台要求添加
// 向右跳跃获得最大得分
// 给定长度为n+1的数组arr，下标编号0 ~ n，给定正数a、b
// 一开始在0位置，每次可以选择[a,b]之间的一个整数，作为向右跳跃的距离
// 每来到一个位置i，可以获得arr[i]作为得分，位置一旦大于n就停止
// 返回能获得的最大得分
// 1 <= n <= 2 * 10^5
// 1 <= a <= b <= n
// -1000 <= arr[i] <= +1000
// 测试链接 : https://www.luogu.com.cn/problem/P1725
// 提交以下的code，提交时请把类名改成"Main"，可以通过所有用例

const int MAXN = 200001;
const int NA = 0x80000000;  // 表示负无穷

// 全局变量
int arr[MAXN];      // 输入数组，存储每个位置的得分
int dp[MAXN];       // dp数组，dp[i]表示到达位置i能获得的最大得分
int queue[MAXN];    // 单调队列，用于维护滑动窗口内的最大值，存储的是下标，按照dp值单调递减排列
int l, r;           // 队列的左右指针
int n, a, b;        // 输入参数

// 计算最大得分
// 使用单调队列优化的动态规划解法
// 时间复杂度：O(n)，每个元素最多入队和出队一次
// 空间复杂度：O(n)，dp数组和单调队列的空间
int compute() {
    // 初始状态：在位置0，得分为arr[0]
    dp[0] = arr[0];
    l = r = 0;
    
    // 动态规划过程
    for (int i = 1; i <= n; i++) {
        // 添加新的可能决策点
        if (i - a >= 0 && dp[i - a] != NA) {
            // 维护队列单调性（递减）
            while (l < r && dp[queue[r - 1]] <= dp[i - a]) {
                r--;
            }
            queue[r++] = i - a;
        }
        
        // 移除过期的决策点
        if (l < r && queue[l] == i - b - 1) {
            l++;
        }
        
        // 状态转移
        dp[i] = l < r ? dp[queue[l]] + arr[i] : NA;
    }
    
    // 在所有可能的终点中找到最大值
    int ans = NA;
    for (int i = n + 1 - b; i <= n; i++) {
        if (dp[i] > ans) ans = dp[i];
    }
    
    return ans;
}

int main() {
    // 读取输入
    // scanf("%d%d%d", &n, &a, &b);
    // for (int i = 0; i <= n; i++) {
    //     scanf("%d", &arr[i]);
    // }
    
    // 输出结果
    // printf("%d\n", compute());
    
    return 0;
}

/*
算法思路详解：

1. 问题分析：
   - 这是一个典型的动态规划问题
   - 状态定义：dp[i]表示到达位置i能获得的最大得分
   - 状态转移方程：dp[i] = max{dp[j]} + arr[i]，其中j ∈ [max(0, i-b), i-a]
   - 目标：求所有可能终点中的最大dp值

2. 朴素解法：
   - 时间复杂度：O(n*b)，对于每个位置i，需要遍历前面b个位置找最大值
   - 空间复杂度：O(n)
   - 对于大数据会超时

3. 单调队列优化：
   - 观察状态转移方程，我们需要在滑动窗口[max(0, i-b), i-a]中找到dp的最大值
   - 这正是单调队列的经典应用场景
   - 使用单调递减队列，队首始终是窗口内的最大dp值

4. 队列维护策略：
   - 队列存储下标，按照dp值单调递减排列
   - 队首元素：窗口内的最大dp值对应的下标
   - 队尾维护：移除所有dp值小于等于当前dp[i]的元素
   - 有效性维护：移除超出跳跃范围的队首元素

5. 时间复杂度分析：
   - 每个元素最多入队和出队一次，均摊时间复杂度O(1)
   - 总时间复杂度：O(n)
   - 空间复杂度：O(n)

6. 边界情况处理：
   - 当i < b时，可以从位置0跳过来
   - 当i >= b时，只能从[i-b, i-a]范围内跳过来
   - 初始状态dp[0] = arr[0]
   - 终点不是固定的n，而是在[n+1-b, n]范围内

7. 为什么是最优解：
   - 该解法将朴素DP的O(n*b)优化到O(n)
   - 利用单调队列维护滑动窗口最值，是此类问题的最优解法
   - 无法进一步优化时间复杂度，因为需要处理每个位置至少一次

8. 工程化考量：
   - 使用数组模拟队列，避免STL容器的额外开销
   - 预分配固定大小数组，避免动态内存分配
   - 代码结构清晰，注释详细

9. 极端场景分析：
   - n=1时，直接返回arr[0]
   - a=b=1时，只能一步步跳，退化为前缀和
   - arr全为负数时，仍能正确找到最大得分路径
   - a=b=n时，第一步就能跳到最后

10. 语言特性差异：
    - C++: 使用数组模拟队列，性能最优
    - Java: 使用数组模拟队列，性能较好
    - Python: 可使用collections.deque
*/