// 粉刷木板的最大收益
// 一共有n个木板，每个木板长度为1，最多粉刷一次，也可以不刷
// 一共有m个工人，每个工人用(li, pi, si)表示：
// 该工人必须刷连续区域的木板，并且连续的长度不超过li
// 该工人每刷一块木板可以得到pi的钱
// 该工人刷的连续区域必须包含si位置的木板
// 返回所有工人最多能获得多少钱
// 1 <= n <= 16000
// 1 <= m <= 100
// 1 <= pi <= 10000
// 测试链接 : http://poj.org/problem?id=1821
// 提交以下的code，提交时请把类名改成"Main"，可以通过所有用例

#include <iostream>
#include <vector>
#include <algorithm>
#include <climits>
#include <deque>
using namespace std;

// 最大木板数常量
const int MAXN = 16001;

// 最大工人数常量
const int MAXM = 101;

// 工人信息结构体
struct Worker {
    int li;  // 工人能刷的最大连续长度
    int pi;  // 工人每刷一块木板的收益
    int si;  // 工人必须刷到的木板位置
};

// 工人信息数组
vector<Worker> workers(MAXM);

// dp数组，dp[i][j]表示前i个工人刷前j块木板能获得的最大收益
vector<vector<int>> dp(MAXM, vector<int>(MAXN, 0));

// 单调队列，用于维护滑动窗口内的最优决策点
// 存储的是木板下标，按照value值单调递增排列
deque<int> dq;

// 输入参数
int n, m;

/**
 * 计算工人i从位置j开始刷木板时的指标值
 * 指标值用于比较不同起始位置的优劣
 * 
 * @param i 工人编号
 * @param pi 工人i每刷一块木板的收益
 * @param j 起始位置
 * @return 位置j对应的指标值
 */
int value(int i, int pi, int j) {
    // 指标值为：前i-1个工人刷前j块木板的最大收益 - pi * j
    // 这个值越大，说明从位置j开始刷越有利
    return dp[i - 1][j] - pi * j;
}

/**
 * 计算粉刷木板的最大收益
 * 使用单调队列优化的动态规划解法
 * 时间复杂度：O(m*n)，每个位置最多入队和出队一次
 * 空间复杂度：O(m*n)，dp数组和单调队列的空间
 * 
 * @return 所有工人最多能获得的钱数
 */
int compute() {
    // 按照工人必须刷到的木板位置si排序
    // 这样可以确保在处理工人i时，前面的工人已经处理完毕
    sort(workers.begin() + 1, workers.begin() + m + 1, 
         [](const Worker& a, const Worker& b) {
             return a.si < b.si;
         });
    
    // 动态规划过程
    for (int i = 1; i <= m; i++) {
        int li = workers[i].li;  // 工人i能刷的最大连续长度
        int pi = workers[i].pi;  // 工人i每刷一块木板的收益
        int si = workers[i].si;  // 工人i必须刷到的木板位置
        
        // 清空队列
        dq.clear();
        
        // 初始化单调队列，将工人i可以刷到的起始位置加入队列
        // 起始位置范围：[max(0, si-li), si-1]
        for (int j = max(0, si - li); j < si; j++) {
            // 维护队列单调性（递增）
            // 移除所有value值大于等于当前value(i, pi, j)的队尾元素
            while (!dq.empty() && value(i, pi, dq.back()) <= value(i, pi, j)) {
                dq.pop_back();
            }
            // 将位置j加入队列
            dq.push_back(j);
        }
        
        // 计算前i个工人刷前j块木板的最大收益
        for (int j = 1; j <= n; j++) {
            // 不选择工人i的情况：继承前i-1个工人的结果或前j-1块木板的结果
            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);
            
            // 如果当前木板位置j >= 工人i必须刷到的位置si
            if (j >= si) {
                // 移除过期的决策点（超出工人i能刷的最大长度）
                if (!dq.empty() && dq.front() == j - li - 1) {
                    dq.pop_front();
                }
                
                // 如果队列不为空，尝试选择工人i来刷木板
                if (!dq.empty()) {
                    // 选择工人i的收益：value(最优起始位置) + pi * j
                    dp[i][j] = max(dp[i][j], value(i, pi, dq.front()) + pi * j);
                }
            }
        }
    }
    
    return dp[m][n];
}

int main() {
    // 使用C++标准输入输出
    ios::sync_with_stdio(false);
    cin.tie(0);
    
    // 读取输入参数（可能有多组测试数据）
    while (cin >> n >> m) {
        // 读取工人信息
        for (int i = 1; i <= m; i++) {
            cin >> workers[i].li >> workers[i].pi >> workers[i].si;
        }
        
        // 输出计算结果
        cout << compute() << endl;
    }
    
    return 0;
}

/*
 * 算法思路详解：
 * 
 * 1. 问题分析：
 *    - 这是一个二维动态规划问题，涉及工人选择和木板粉刷
 *    - 状态定义：dp[i][j]表示前i个工人刷前j块木板能获得的最大收益
 *    - 状态转移方程较为复杂，需要考虑工人是否参与粉刷
 *    - 目标：求dp[m][n]
 * 
 * 2. 朴素解法：
 *    - 时间复杂度：O(m*n^2)，对于每个工人和每块木板，需要遍历可能的起始位置
 *    - 空间复杂度：O(m*n)
 *    - 对于大数据会超时
 * 
 * 3. 优化思路：
 *    - 按照工人必须刷到的木板位置排序，确保处理顺序正确
 *    - 对于每个工人，使用单调队列优化起始位置的选择
 *    - 将问题转化为在滑动窗口内找最优起始位置
 * 
 * 4. 单调队列优化：
 *    - 对于工人i，我们需要在起始位置范围[max(0, si-li), si-1]内找到最优起始位置
 *    - 使用单调递增队列，队首始终是窗口内的最优起始位置
 *    - 通过value函数比较不同起始位置的优劣
 * 
 * 5. 队列维护策略：
 *    - 队列存储起始位置下标，按照value值单调递增排列
 *    - 队首元素：窗口内的最优起始位置
 *    - 队尾维护：移除所有value值大于等于当前value的元素
 *    - 有效性维护：移除超出工人能力范围的队首元素
 * 
 * 6. 时间复杂度分析：
 *    - 每个起始位置最多入队和出队一次，均摊时间复杂度O(1)
 *    - 总时间复杂度：O(m*n)
 *    - 空间复杂度：O(m*n)
 * 
 * 7. 边界情况处理：
 *    - 没有工人参与：收益为0
 *    - 没有木板可刷：收益为0
 *    - 工人能力不足：无法刷到必须刷到的位置
 * 
 * 8. 为什么是最优解：
 *    - 该解法将朴素DP的O(m*n^2)优化到O(m*n)
 *    - 利用单调队列维护最优决策点，是此类问题的最优解法
 *    - 无法进一步优化时间复杂度，因为需要处理每个工人和每块木板
 * 
 * 9. 工程化考量：
 *    - 按照工人必须刷到的位置排序，确保处理顺序正确
 *    - 输入输出使用高效IO，避免超时
 *    - 使用结构体存储工人信息，提高代码可读性
 *    - 处理多组测试数据的情况
 * 
 * 10. 极端场景分析：
 *     - m=1时，只有一个工人，退化为单工人问题
 *     - n=1时，只有一块木板，工人能力足够就能刷
 *     - 工人能力很强：可以刷很多木板
 *     - 工人能力很弱：可能无法完成任务
 * 
 * 11. 语言特性差异：
 *     - C++: 使用deque实现双端队列，性能较好
 *     - Java: 使用数组模拟队列
 *     - Python: 使用collections.deque
 * 
 * 12. 调试技巧：
 *     - 打印dp数组验证计算正确性
 *     - 检查队列维护的单调性
 *     - 验证边界情况的处理
 */