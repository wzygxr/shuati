# 单调队列优化动态规划补充题目详解

## 1. POJ 2823 Sliding Window

### 题目来源
POJ 2823 Sliding Window

### 题目描述
给定一个长度为N的整数序列a(i)，i=0,1,...,N-1和窗口长度k。
要求：f(i) = max{a(i-k+1),a(i-k+2),..., a(i)}, i = 0,1,...,N-1
同时求出最小值。

### 解题思路
这是单调队列的经典模板题。我们需要维护两个单调队列：
1. 单调递减队列：用于求解窗口最大值
2. 单调递增队列：用于求解窗口最小值

### 时间复杂度
- 时间复杂度：O(n)，每个元素最多入队和出队一次
- 空间复杂度：O(k)，队列最多存储k个元素

### Java实现
```java
import java.util.*;
import java.io.*;

public class SlidingWindow {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StreamTokenizer in = new StreamTokenizer(br);
        PrintWriter out = new PrintWriter(new OutputStreamWriter(System.out));
        
        in.nextToken();
        int n = (int) in.nval;
        in.nextToken();
        int k = (int) in.nval;
        
        int[] arr = new int[n];
        for (int i = 0; i < n; i++) {
            in.nextToken();
            arr[i] = (int) in.nval;
        }
        
        // 求最小值
        int[] minResult = slidingWindowMin(arr, k);
        // 求最大值
        int[] maxResult = slidingWindowMax(arr, k);
        
        for (int i = 0; i < minResult.length; i++) {
            out.print(minResult[i]);
            if (i < minResult.length - 1) out.print(" ");
        }
        out.println();
        
        for (int i = 0; i < maxResult.length; i++) {
            out.print(maxResult[i]);
            if (i < maxResult.length - 1) out.print(" ");
        }
        out.println();
        
        out.flush();
        out.close();
        br.close();
    }
    
    // 滑动窗口最小值
    public static int[] slidingWindowMin(int[] arr, int k) {
        int n = arr.length;
        int[] result = new int[n - k + 1];
        Deque<Integer> deque = new LinkedList<>(); // 存储下标
        
        for (int i = 0; i < n; i++) {
            // 移除队列中超出窗口范围的元素
            while (!deque.isEmpty() && deque.peekFirst() < i - k + 1) {
                deque.pollFirst();
            }
            
            // 维护队列单调性（递增）
            while (!deque.isEmpty() && arr[deque.peekLast()] >= arr[i]) {
                deque.pollLast();
            }
            
            // 将当前元素下标加入队列
            deque.offerLast(i);
            
            // 当窗口形成后，记录当前窗口的最小值
            if (i >= k - 1) {
                result[i - k + 1] = arr[deque.peekFirst()];
            }
        }
        
        return result;
    }
    
    // 滑动窗口最大值
    public static int[] slidingWindowMax(int[] arr, int k) {
        int n = arr.length;
        int[] result = new int[n - k + 1];
        Deque<Integer> deque = new LinkedList<>(); // 存储下标
        
        for (int i = 0; i < n; i++) {
            // 移除队列中超出窗口范围的元素
            while (!deque.isEmpty() && deque.peekFirst() < i - k + 1) {
                deque.pollFirst();
            }
            
            // 维护队列单调性（递减）
            while (!deque.isEmpty() && arr[deque.peekLast()] <= arr[i]) {
                deque.pollLast();
            }
            
            // 将当前元素下标加入队列
            deque.offerLast(i);
            
            // 当窗口形成后，记录当前窗口的最大值
            if (i >= k - 1) {
                result[i - k + 1] = arr[deque.peekFirst()];
            }
        }
        
        return result;
    }
}
```

### C++实现
```cpp
#include <iostream>
#include <deque>
#include <vector>
using namespace std;

// 滑动窗口最小值
vector<int> slidingWindowMin(vector<int>& arr, int k) {
    int n = arr.size();
    vector<int> result(n - k + 1);
    deque<int> dq; // 存储下标
    
    for (int i = 0; i < n; i++) {
        // 移除队列中超出窗口范围的元素
        while (!dq.empty() && dq.front() < i - k + 1) {
            dq.pop_front();
        }
        
        // 维护队列单调性（递增）
        while (!dq.empty() && arr[dq.back()] >= arr[i]) {
            dq.pop_back();
        }
        
        // 将当前元素下标加入队列
        dq.push_back(i);
        
        // 当窗口形成后，记录当前窗口的最小值
        if (i >= k - 1) {
            result[i - k + 1] = arr[dq.front()];
        }
    }
    
    return result;
}

// 滑动窗口最大值
vector<int> slidingWindowMax(vector<int>& arr, int k) {
    int n = arr.size();
    vector<int> result(n - k + 1);
    deque<int> dq; // 存储下标
    
    for (int i = 0; i < n; i++) {
        // 移除队列中超出窗口范围的元素
        while (!dq.empty() && dq.front() < i - k + 1) {
            dq.pop_front();
        }
        
        // 维护队列单调性（递减）
        while (!dq.empty() && arr[dq.back()] <= arr[i]) {
            dq.pop_back();
        }
        
        // 将当前元素下标加入队列
        dq.push_back(i);
        
        // 当窗口形成后，记录当前窗口的最大值
        if (i >= k - 1) {
            result[i - k + 1] = arr[dq.front()];
        }
    }
    
    return result;
}

int main() {
    int n, k;
    cin >> n >> k;
    vector<int> arr(n);
    for (int i = 0; i < n; i++) {
        cin >> arr[i];
    }
    
    vector<int> minResult = slidingWindowMin(arr, k);
    vector<int> maxResult = slidingWindowMax(arr, k);
    
    for (int i = 0; i < minResult.size(); i++) {
        cout << minResult[i];
        if (i < minResult.size() - 1) cout << " ";
    }
    cout << endl;
    
    for (int i = 0; i < maxResult.size(); i++) {
        cout << maxResult[i];
        if (i < maxResult.size() - 1) cout << " ";
    }
    cout << endl;
    
    return 0;
}
```

### Python实现
```python
from collections import deque

def sliding_window_min(arr, k):
    """
    滑动窗口最小值
    
    Args:
        arr: List[int] - 输入数组
        k: int - 窗口大小
    
    Returns:
        List[int] - 每个窗口的最小值
    """
    n = len(arr)
    result = []
    dq = deque()  # 存储下标
    
    for i in range(n):
        # 移除队列中超出窗口范围的元素
        while dq and dq[0] < i - k + 1:
            dq.popleft()
        
        # 维护队列单调性（递增）
        while dq and arr[dq[-1]] >= arr[i]:
            dq.pop()
        
        # 将当前元素下标加入队列
        dq.append(i)
        
        # 当窗口形成后，记录当前窗口的最小值
        if i >= k - 1:
            result.append(arr[dq[0]])
    
    return result

def sliding_window_max(arr, k):
    """
    滑动窗口最大值
    
    Args:
        arr: List[int] - 输入数组
        k: int - 窗口大小
    
    Returns:
        List[int] - 每个窗口的最大值
    """
    n = len(arr)
    result = []
    dq = deque()  # 存储下标
    
    for i in range(n):
        # 移除队列中超出窗口范围的元素
        while dq and dq[0] < i - k + 1:
            dq.popleft()
        
        # 维护队列单调性（递减）
        while dq and arr[dq[-1]] <= arr[i]:
            dq.pop()
        
        # 将当前元素下标加入队列
        dq.append(i)
        
        # 当窗口形成后，记录当前窗口的最大值
        if i >= k - 1:
            result.append(arr[dq[0]])
    
    return result

# 主函数
if __name__ == "__main__":
    n, k = map(int, input().split())
    arr = list(map(int, input().split()))
    
    min_result = sliding_window_min(arr, k)
    max_result = sliding_window_max(arr, k)
    
    print(" ".join(map(str, min_result)))
    print(" ".join(map(str, max_result)))
```

## 2. LeetCode 1425 Constrained Subsequence Sum

### 题目来源
LeetCode 1425. Constrained Subsequence Sum

### 题目描述
给你一个整数数组 nums 和一个整数 k ，请你返回非空子序列元素和的最大值，子序列需要满足：子序列中每两个相邻的整数 nums[i] 和 nums[j] ，它们在原数组中的下标 i 和 j 满足 i < j 且 j - i <= k 。

### 解题思路
使用动态规划 + 单调队列优化。定义 dp[i] 表示以第 i 个元素结尾的满足约束条件的子序列的最大和。

状态转移方程：
```
dp[i] = max(0, max{dp[j] | max(0, i-k) <= j <= i-1}) + nums[i]
```

使用单调递减队列维护 dp 值，队首始终是窗口内的最大值。

### 时间复杂度
- 时间复杂度：O(n)
- 空间复杂度：O(n)

### Java实现
```java
import java.util.*;

public class ConstrainedSubsequenceSum {
    public int constrainedSubsetSum(int[] nums, int k) {
        int n = nums.length;
        int[] dp = new int[n];
        int ans = Integer.MIN_VALUE;
        
        // 双端队列存储下标，维护单调递减队列
        Deque<Integer> deque = new LinkedList<>();
        
        for (int i = 0; i < n; i++) {
            // 移除队列中超出窗口范围的元素
            while (!deque.isEmpty() && i - deque.peekFirst() > k) {
                deque.pollFirst();
            }
            
            // 状态转移
            dp[i] = Math.max(0, deque.isEmpty() ? 0 : dp[deque.peekFirst()]) + nums[i];
            
            // 维护队列单调性
            while (!deque.isEmpty() && dp[deque.peekLast()] <= dp[i]) {
                deque.pollLast();
            }
            
            // 将当前下标加入队列
            deque.offerLast(i);
            
            // 更新全局最大值
            ans = Math.max(ans, dp[i]);
        }
        
        return ans;
    }
}
```

### C++实现
```cpp
#include <vector>
#include <deque>
#include <algorithm>
using namespace std;

class Solution {
public:
    int constrainedSubsetSum(vector<int>& nums, int k) {
        int n = nums.size();
        vector<int> dp(n);
        int ans = INT_MIN;
        
        // 双端队列存储下标，维护单调递减队列
        deque<int> dq;
        
        for (int i = 0; i < n; i++) {
            // 移除队列中超出窗口范围的元素
            while (!dq.empty() && i - dq.front() > k) {
                dq.pop_front();
            }
            
            // 状态转移
            dp[i] = max(0, dq.empty() ? 0 : dp[dq.front()]) + nums[i];
            
            // 维护队列单调性
            while (!dq.empty() && dp[dq.back()] <= dp[i]) {
                dq.pop_back();
            }
            
            // 将当前下标加入队列
            dq.push_back(i);
            
            // 更新全局最大值
            ans = max(ans, dp[i]);
        }
        
        return ans;
    }
};
```

### Python实现
```python
from collections import deque

def constrainedSubsetSum(nums, k):
    """
    带限制的子序列和
    
    Args:
        nums: List[int] - 输入数组
        k: int - 限制距离
    
    Returns:
        int - 最大子序列和
    """
    n = len(nums)
    dp = [0] * n
    ans = float('-inf')
    
    # 双端队列存储下标，维护单调递减队列
    dq = deque()
    
    for i in range(n):
        # 移除队列中超出窗口范围的元素
        while dq and i - dq[0] > k:
            dq.popleft()
        
        # 状态转移
        dp[i] = max(0, dp[dq[0]] if dq else 0) + nums[i]
        
        # 维护队列单调性
        while dq and dp[dq[-1]] <= dp[i]:
            dq.pop()
        
        # 将当前下标加入队列
        dq.append(i)
        
        # 更新全局最大值
        ans = max(ans, dp[i])
    
    return ans
```

## 3. LeetCode 862 Shortest Subarray with Sum at Least K

### 题目来源
LeetCode 862. Shortest Subarray with Sum at Least K

### 题目描述
返回 nums 的最短非空子数组，该子数组的和至少为 k。如果没有这样的子数组，返回 -1。

### 解题思路
使用前缀和 + 单调队列优化。首先计算前缀和数组 prefixSum，问题转化为找到最小的 j-i，使得 prefixSum[j] - prefixSum[i] >= k。

维护一个单调递增的队列存储前缀和的下标，这样队首始终是最小的前缀和。

### 时间复杂度
- 时间复杂度：O(n)
- 空间复杂度：O(n)

### Java实现
```java
import java.util.*;

public class ShortestSubarray {
    public int shortestSubarray(int[] nums, int k) {
        int n = nums.length;
        // 计算前缀和
        long[] prefixSum = new long[n + 1];
        for (int i = 0; i < n; i++) {
            prefixSum[i + 1] = prefixSum[i] + nums[i];
        }
        
        int result = n + 1;
        // 双端队列存储前缀和下标，维护单调递增队列
        Deque<Integer> deque = new LinkedList<>();
        
        for (int i = 0; i <= n; i++) {
            // 检查是否满足条件
            while (!deque.isEmpty() && prefixSum[i] - prefixSum[deque.peekFirst()] >= k) {
                result = Math.min(result, i - deque.pollFirst());
            }
            
            // 维护队列单调性
            while (!deque.isEmpty() && prefixSum[deque.peekLast()] >= prefixSum[i]) {
                deque.pollLast();
            }
            
            // 将当前下标加入队列
            deque.offerLast(i);
        }
        
        return result <= n ? result : -1;
    }
}
```

### C++实现
```cpp
#include <vector>
#include <deque>
#include <climits>
using namespace std;

class Solution {
public:
    int shortestSubarray(vector<int>& nums, int k) {
        int n = nums.size();
        // 计算前缀和
        vector<long long> prefixSum(n + 1, 0);
        for (int i = 0; i < n; i++) {
            prefixSum[i + 1] = prefixSum[i] + nums[i];
        }
        
        int result = n + 1;
        // 双端队列存储前缀和下标，维护单调递增队列
        deque<int> dq;
        
        for (int i = 0; i <= n; i++) {
            // 检查是否满足条件
            while (!dq.empty() && prefixSum[i] - prefixSum[dq.front()] >= k) {
                result = min(result, i - dq.front());
                dq.pop_front();
            }
            
            // 维护队列单调性
            while (!dq.empty() && prefixSum[dq.back()] >= prefixSum[i]) {
                dq.pop_back();
            }
            
            // 将当前下标加入队列
            dq.push_back(i);
        }
        
        return result <= n ? result : -1;
    }
};
```

### Python实现
```python
from collections import deque

def shortestSubarray(nums, k):
    """
    和至少为 K 的最短子数组
    
    Args:
        nums: List[int] - 输入数组
        k: int - 目标和
    
    Returns:
        int - 最短子数组长度，不存在则返回-1
    """
    n = len(nums)
    # 计算前缀和
    prefix_sum = [0]
    for num in nums:
        prefix_sum.append(prefix_sum[-1] + num)
    
    result = n + 1
    # 双端队列存储前缀和下标，维护单调递增队列
    dq = deque()
    
    for i in range(len(prefix_sum)):
        # 检查是否满足条件
        while dq and prefix_sum[i] - prefix_sum[dq[0]] >= k:
            result = min(result, i - dq.popleft())
        
        # 维护队列单调性
        while dq and prefix_sum[dq[-1]] >= prefix_sum[i]:
            dq.pop()
        
        # 将当前下标加入队列
        dq.append(i)
    
    return result if result <= n else -1
```

## 4. LeetCode 1687 Delivering Boxes from Storage to Ports

### 题目来源
LeetCode 1687. Delivering Boxes from Storage to Ports

### 题目描述
你有一辆货运卡车，你需要用这一辆车把一些箱子从仓库运送到码头。这辆卡车每次运输有箱子数目的限制和总重量的限制。

### 解题思路
这是一个复杂的动态规划问题，可以使用单调队列优化。定义 dp[i] 表示运输前 i 个箱子所需的最少行程次数。

状态转移方程：
```
dp[i] = min{dp[j] + cost(j+1, i)} for all valid j
```

其中 cost(j+1, i) 表示一趟运输箱子 [j+1, i] 所需的行程次数。

### 时间复杂度
- 时间复杂度：O(n)
- 空间复杂度：O(n)

### Java实现
```java
import java.util.*;

public class DeliveringBoxes {
    public int boxDelivering(int[][] boxes, int portsCount, int maxBoxes, int maxWeight) {
        int n = boxes.length;
        // dp[i] 表示运输前 i 个箱子的最少行程次数
        int[] dp = new int[n + 1];
        // neg[i] 表示前 i 个箱子中相邻箱子港口不同的次数
        int[] neg = new int[n + 1];
        // weightSum[i] 表示前 i 个箱子的重量和
        long[] weightSum = new long[n + 1];
        
        // 预处理
        for (int i = 1; i <= n; i++) {
            weightSum[i] = weightSum[i - 1] + boxes[i - 1][1];
            if (i > 1) {
                neg[i] = neg[i - 1] + (boxes[i - 2][0] != boxes[i - 1][0] ? 1 : 0);
            }
        }
        
        // g[i] = dp[i] - neg[i + 1]，用于单调队列优化
        int[] g = new int[n + 1];
        // 双端队列存储下标，维护g值的单调递增队列
        Deque<Integer> deque = new LinkedList<>();
        deque.offerLast(0);
        g[0] = 0;
        
        for (int i = 1; i <= n; i++) {
            // 移除不满足约束条件的队首元素
            while (!deque.isEmpty() && 
                   (i - deque.peekFirst() > maxBoxes || 
                    weightSum[i] - weightSum[deque.peekFirst()] > maxWeight)) {
                deque.pollFirst();
            }
            
            // 状态转移
            dp[i] = g[deque.peekFirst()] + neg[i] + 2;
            
            // 更新g值
            if (i != n) {
                g[i] = dp[i] - neg[i + 1];
                
                // 维护队列单调性
                while (!deque.isEmpty() && g[deque.peekLast()] >= g[i]) {
                    deque.pollLast();
                }
                
                // 将当前下标加入队列
                deque.offerLast(i);
            }
        }
        
        return dp[n];
    }
}
```

## 5. USACO 2010 Open Gold Cow Hopscotch

### 题目来源
USACO 2010 Open Gold Cow Hopscotch

### 题目描述
奶牛们重新回到了童年，正在玩一种类似于人类跳房子的游戏。他们的跳房子游戏有一排N个格子(3 <= N <= 250,000)，每个格子都有一个价值。一头牛从第0个格子开始，每次可以向前跳最多K个格子，每当它跳到某个格子上，它就能够获得该格子的价值。求能获得的最大价值。

### 解题思路
这是一个动态规划问题，可以使用单调队列优化。定义 dp[i] 表示到达第 i 个格子能获得的最大价值。

状态转移方程：
```
dp[i] = max{dp[j]} + value[i]，其中 j ∈ [max(0, i-k), i-1]
```

使用单调递减队列维护 dp 值，队首始终是窗口内的最大值。

### 时间复杂度
- 时间复杂度：O(n)
- 空间复杂度：O(n)

### Java实现
```java
import java.util.*;

public class CowHopscotch {
    public static long maxProfit(int[] values, int k) {
        int n = values.length;
        long[] dp = new long[n];
        dp[0] = values[0];
        
        // 单调递减队列，存储下标
        Deque<Integer> deque = new LinkedList<>();
        deque.offerLast(0);
        
        for (int i = 1; i < n; i++) {
            // 移除队列中超出跳跃范围的元素
            while (!deque.isEmpty() && deque.peekFirst() < i - k) {
                deque.pollFirst();
            }
            
            // 状态转移
            dp[i] = dp[deque.peekFirst()] + values[i];
            
            // 维护队列单调性
            while (!deque.isEmpty() && dp[deque.peekLast()] <= dp[i]) {
                deque.pollLast();
            }
            
            // 将当前位置加入队列
            deque.offerLast(i);
        }
        
        return dp[n - 1];
    }
}
```

## 6. HDU 3415 Max Sum of Max-K-sub-sequence

### 题目来源
HDU 3415 Max Sum of Max-K-sub-sequence

### 题目描述
给定一个循环数组和一个整数k，求长度不超过k的连续子序列的最大和，并输出起始和结束位置。

### 解题思路
使用前缀和 + 单调队列优化。首先将循环数组展开，然后计算前缀和数组。问题转化为找到最大的 prefixSum[j] - prefixSum[i]，其中 j - i <= k。

维护一个单调递增的队列存储前缀和的下标，这样队首始终是最小的前缀和。

### 时间复杂度
- 时间复杂度：O(n)
- 空间复杂度：O(n)

### Java实现
```java
import java.util.*;

public class MaxSumOfMaxKSubsequence {
    public static int[] maxSumSubsequence(int[] arr, int k) {
        int n = arr.length;
        // 计算前缀和
        long[] prefixSum = new long[2 * n + 1];
        for (int i = 1; i <= 2 * n; i++) {
            prefixSum[i] = prefixSum[i - 1] + arr[(i - 1) % n];
        }
        
        long maxSum = Long.MIN_VALUE;
        int start = 0, end = 0;
        // 双端队列存储前缀和下标，维护单调递增队列
        Deque<Integer> deque = new LinkedList<>();
        deque.offerLast(0);
        
        for (int i = 1; i <= 2 * n; i++) {
            // 移除队列中超出长度限制的元素
            while (!deque.isEmpty() && i - deque.peekFirst() > k) {
                deque.pollFirst();
            }
            
            // 更新最大和及位置
            if (!deque.isEmpty()) {
                long currentSum = prefixSum[i] - prefixSum[deque.peekFirst()];
                if (currentSum > maxSum) {
                    maxSum = currentSum;
                    start = deque.peekFirst() % n;
                    end = (i - 1) % n;
                }
            }
            
            // 维护队列单调性
            while (!deque.isEmpty() && prefixSum[deque.peekLast()] >= prefixSum[i]) {
                deque.pollLast();
            }
            
            // 将当前下标加入队列
            deque.offerLast(i);
        }
        
        return new int[]{start + 1, end + 1}; // 返回1-indexed位置
    }
}
```

## 总结

单调队列优化动态规划是解决特定形式DP问题的重要技巧，主要应用场景包括：

1. **滑动窗口最值问题**：如LeetCode 239、POJ 2823
2. **带约束的DP问题**：如LeetCode 1425、1687
3. **前缀和优化问题**：如LeetCode 862、HDU 3415
4. **区间决策优化问题**：如POJ 1821
5. **跳跃类问题**：如LeetCode 1696、USACO Cow Hopscotch
6. **切分序列问题**：如POJ 3017
7. **多重背包问题**：如洛谷P1776

掌握单调队列的关键在于：
1. 理解何时可以使用单调队列优化
2. 正确维护队列的单调性
3. 及时处理队列中过期的元素
4. 根据具体问题选择合适的队列存储内容（下标或值）