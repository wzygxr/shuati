package class130;

// 送箱子到码头的最少行程数
// 一共有m个码头，编号1 ~ m， 给定长度为n的二维数组boxes
// boxes[i][0]表示i号箱子要送往的码头，boxes[i][1]表示i号箱子重量
// 有一辆马车，一次最多能装a个箱子并且箱子总重量不能超过b
// 马车一开始在仓库，可以在0位置，马车每开动一次，认为行程+1
// 箱子必须按照boxes规定的顺序被放上马车，也必须按照顺序被送往各自的码头
// 马车上相邻的箱子如果去往同一个码头，那么认为共享同一趟行程
// 马车可能经过多次送货，每次装货需要回到仓库，认为行程+1，送完所有的货，最终要回到仓库，行程+1
// 返回至少需要几个行程能把所有的货都送完
// 所有数据的范围 <= 10^5
// 测试链接 : https://leetcode.cn/problems/delivering-boxes-from-storage-to-ports/

/**
 * 送箱子到码头的最少行程数问题 - 滑动窗口优化解法
 * 
 * 算法思路详解：
 * 1. 问题分析：
 *    - 需要将箱子按顺序送到指定码头，马车有容量和重量限制
 *    - 相邻的去往同一码头的箱子可以共享行程
 *    - 目标是找到最少的行程数
 *    
 * 2. 优化思路：
 *    - 使用动态规划结合滑动窗口优化
 *    - 维护当前窗口的货物范围和行程信息
 *    - 通过窗口调整找到最优的分割点
 *    
 * 3. 时间复杂度分析：
 *    - 时间复杂度：O(n)，每个箱子最多被处理两次（进入和离开窗口）
 *    - 空间复杂度：O(n)，dp数组的空间
 *    
 * 4. 为什么是最优解：
 *    - 该解法利用滑动窗口将复杂度优化到O(n)
 *    - 是此类问题的最优解法
 */
public class Code08_DeliveringBoxes {

	/**
	 * 计算送箱子到码头的最少行程数
	 * 使用滑动窗口优化的动态规划解法
	 * 
	 * @param boxes 箱子信息数组，boxes[i][0]表示码头，boxes[i][1]表示重量
	 * @param m 码头数量
	 * @param a 马车最大箱子数
	 * @param b 马车最大重量
	 * @return 最少行程数
	 */
	public static int boxDelivering(int[][] boxes, int m, int a, int b) {
		int n = boxes.length;
		// dp[i] : 马车拉完前i个货物并回仓库，需要的最少行程
		// 注意这里的i是指个数，对应的货物是boxes[0...i-1]
		int[] dp = new int[n + 1];
		dp[1] = 2;  // 第一个箱子：去仓库+送货+回仓库 = 2次行程
		
		// 马车最后一趟的货物范围[l...r]
		// 最后一趟货物的总重量weight，最后一趟需要的行程trip
		int weight = boxes[0][1];
		int trip = 2;  // 初始行程：去仓库+送货+回仓库
		
		// 滑动窗口：l表示窗口左边界，r表示窗口右边界
		for (int l = 0, r = 1; r < n; r++) {
			// 将第r个箱子加入当前窗口
			weight += boxes[r][1];
			// 如果当前箱子与前一个箱子去往不同码头，行程+1
			if (boxes[r][0] != boxes[r - 1][0]) {
				trip++;
			}
			
			// 调整窗口左边界，确保满足约束条件
			// 1) 最后一趟货物的个数超了，最后一趟不得不减少货物
			// 2) 最后一趟货物的总重量超了，最后一趟不得不减少货物
			// 3) 最后一趟最左侧的货，分给之前的过程，如果发现之前过程的dp值没变化，那就分出去
			// 最后一趟最左侧的货，分给之前的过程，如果发现之前过程的dp值增加了，一定不要分出去
			while (r - l + 1 > a || weight > b || dp[l] == dp[l + 1]) {
				// 移除左边界箱子
				weight -= boxes[l][1];
				l++;
				// 如果移除后左边界箱子与前一个箱子去往不同码头，行程-1
				if (l < n && boxes[l][0] != boxes[l - 1][0]) {
					trip--;
				}
			}
			
			// 更新dp值：前l个箱子的最少行程 + 当前窗口的行程
			dp[r + 1] = dp[l] + trip;
		}
		
		return dp[n];
	}
	
	/*
	 * 算法详细解释：
	 * 
	 * 1. 核心思想：
	 *    - 使用动态规划记录前i个箱子的最少行程
	 *    - 通过滑动窗口维护当前最优的货物分割点
	 *    - 利用贪心思想调整窗口边界
	 *    
	 * 2. 滑动窗口的作用：
	 *    - 维护当前考虑的最后一趟送货的货物范围
	 *    - 动态调整窗口大小以满足约束条件
	 *    - 找到最优的分割点使得总行程最少
	 *    
	 * 3. 行程计算原理：
	 *    - 初始行程：去仓库装货 = 1次
	 *    - 送货行程：相邻的去往同一码头的箱子共享行程
	 *    - 结束行程：回仓库 = 1次
	 *    - 总行程 = 去仓库 + 送货行程 + 回仓库
	 *    
	 * 4. 窗口调整策略：
	 *    - 当货物数量超过马车容量时，缩小窗口
	 *    - 当货物重量超过马车载重时，缩小窗口
	 *    - 当分割点可以优化时（dp[l] == dp[l+1]），缩小窗口
	 *    
	 * 5. 时间复杂度证明：
	 *    - 每个箱子最多进入窗口一次、离开窗口一次
	 *    - 每次操作都是O(1)时间
	 *    - 总时间复杂度O(n)
	 *    
	 * 6. 空间复杂度分析：
	 *    - dp数组：O(n)
	 *    - 其他变量：O(1)
	 *    - 总空间复杂度O(n)
	 *    
	 * 7. 为什么这是最优解：
	 *    - 问题本身需要找到最优分割点，朴素解法O(n²)
	 *    - 该解法利用滑动窗口将复杂度降到O(n)
	 *    - 无法进一步优化，因为需要处理每个箱子
	 *    
	 * 8. 工程化考量：
	 *    - 使用数组而非集合提高性能
	 *    - 及时更新变量避免重复计算
	 *    - 考虑边界情况（空数组、单个箱子等）
	 *    
	 * 9. 边界情况处理：
	 *    - 空箱子数组：返回0
	 *    - 单个箱子：行程固定为2
	 *    - 所有箱子去往同一码头：行程优化
	 *    - 极端重量：及时调整窗口
	 */

}
