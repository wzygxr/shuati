# 单调队列优化动态规划补充题目详解

## 1. 滑动窗口最大值 (LeetCode 239)

### 题目描述
给你一个整数数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。返回滑动窗口中的最大值。

### 解题思路
这是单调队列的经典模板题。我们需要维护一个单调递减的双端队列，队列中存储数组元素的下标。

### 时间复杂度
- 时间复杂度：O(n)，每个元素最多入队和出队一次
- 空间复杂度：O(k)，队列最多存储k个元素

### 代码实现

#### Java版本
```java
import java.util.*;

public class Solution {
    public int[] maxSlidingWindow(int[] nums, int k) {
        if (nums == null || nums.length == 0) {
            return new int[0];
        }
        
        int n = nums.length;
        int[] result = new int[n - k + 1];
        // 双端队列存储数组下标，维护单调递减队列
        Deque<Integer> deque = new ArrayDeque<>();
        
        for (int i = 0; i < n; i++) {
            // 移除队列中超出窗口范围的元素
            while (!deque.isEmpty() && deque.peekFirst() < i - k + 1) {
                deque.pollFirst();
            }
            
            // 维护队列单调性，移除所有小于当前元素的队尾元素
            while (!deque.isEmpty() && nums[deque.peekLast()] < nums[i]) {
                deque.pollLast();
            }
            
            // 将当前元素下标加入队列
            deque.offerLast(i);
            
            // 当窗口形成后，记录当前窗口的最大值
            if (i >= k - 1) {
                result[i - k + 1] = nums[deque.peekFirst()];
            }
        }
        
        return result;
    }
}
```

#### C++版本
```cpp
#include <vector>
#include <deque>
using namespace std;

class Solution {
public:
    vector<int> maxSlidingWindow(vector<int>& nums, int k) {
        if (nums.empty()) return {};
        
        vector<int> result;
        deque<int> dq; // 存储下标
        
        for (int i = 0; i < nums.size(); i++) {
            // 移除队列中超出窗口范围的元素
            while (!dq.empty() && dq.front() < i - k + 1) {
                dq.pop_front();
            }
            
            // 维护队列单调性
            while (!dq.empty() && nums[dq.back()] < nums[i]) {
                dq.pop_back();
            }
            
            // 将当前元素下标加入队列
            dq.push_back(i);
            
            // 当窗口形成后，记录当前窗口的最大值
            if (i >= k - 1) {
                result.push_back(nums[dq.front()]);
            }
        }
        
        return result;
    }
};
```

#### Python版本
```python
from collections import deque

def maxSlidingWindow(nums, k):
    """
    滑动窗口最大值
    
    Args:
        nums: List[int] - 输入数组
        k: int - 窗口大小
    
    Returns:
        List[int] - 每个窗口的最大值
    """
    if not nums:
        return []
    
    # 双端队列存储数组下标，维护单调递减队列
    dq = deque()
    result = []
    
    for i in range(len(nums)):
        # 移除队列中超出窗口范围的元素
        while dq and dq[0] < i - k + 1:
            dq.popleft()
        
        # 维护队列单调性，移除所有小于当前元素的队尾元素
        while dq and nums[dq[-1]] < nums[i]:
            dq.pop()
        
        # 将当前元素下标加入队列
        dq.append(i)
        
        # 当窗口形成后，记录当前窗口的最大值
        if i >= k - 1:
            result.append(nums[dq[0]])
    
    return result
```

## 2. 带限制的子序列和 (LeetCode 1425)

### 题目描述
给你一个整数数组 nums 和一个整数 k，请你返回非空子序列元素和的最大值，子序列需要满足：子序列中每两个相邻的整数 nums[i] 和 nums[j]，它们在原数组中的下标 i 和 j 满足 i < j 且 j - i <= k。

### 解题思路
使用动态规划 + 单调队列优化。定义 dp[i] 表示以第 i 个元素结尾的满足约束条件的子序列的最大和。

状态转移方程：
```
dp[i] = max(0, max{dp[j] | max(0, i-k) <= j <= i-1}) + nums[i]
```

使用单调递减队列维护 dp 值，队首始终是窗口内的最大值。

### 时间复杂度
- 时间复杂度：O(n)
- 空间复杂度：O(n)

### 代码实现

#### Java版本
```java
import java.util.*;

public class Solution {
    public int constrainedSubsetSum(int[] nums, int k) {
        int n = nums.length;
        int[] dp = new int[n];
        int ans = Integer.MIN_VALUE;
        
        // 双端队列存储下标，维护单调递减队列
        Deque<Integer> deque = new ArrayDeque<>();
        
        for (int i = 0; i < n; i++) {
            // 移除队列中超出窗口范围的元素
            while (!deque.isEmpty() && i - deque.peekFirst() > k) {
                deque.pollFirst();
            }
            
            // 状态转移
            dp[i] = Math.max(0, deque.isEmpty() ? 0 : dp[deque.peekFirst()]) + nums[i];
            
            // 维护队列单调性
            while (!deque.isEmpty() && dp[deque.peekLast()] <= dp[i]) {
                deque.pollLast();
            }
            
            // 将当前下标加入队列
            deque.offerLast(i);
            
            // 更新全局最大值
            ans = Math.max(ans, dp[i]);
        }
        
        return ans;
    }
}
```

#### C++版本
```cpp
#include <vector>
#include <deque>
#include <algorithm>
using namespace std;

class Solution {
public:
    int constrainedSubsetSum(vector<int>& nums, int k) {
        int n = nums.size();
        vector<int> dp(n);
        int ans = INT_MIN;
        
        // 双端队列存储下标，维护单调递减队列
        deque<int> dq;
        
        for (int i = 0; i < n; i++) {
            // 移除队列中超出窗口范围的元素
            while (!dq.empty() && i - dq.front() > k) {
                dq.pop_front();
            }
            
            // 状态转移
            dp[i] = max(0, dq.empty() ? 0 : dp[dq.front()]) + nums[i];
            
            // 维护队列单调性
            while (!dq.empty() && dp[dq.back()] <= dp[i]) {
                dq.pop_back();
            }
            
            // 将当前下标加入队列
            dq.push_back(i);
            
            // 更新全局最大值
            ans = max(ans, dp[i]);
        }
        
        return ans;
    }
};
```

#### Python版本
```python
from collections import deque

def constrainedSubsetSum(nums, k):
    """
    带限制的子序列和
    
    Args:
        nums: List[int] - 输入数组
        k: int - 限制距离
    
    Returns:
        int - 最大子序列和
    """
    n = len(nums)
    dp = [0] * n
    ans = float('-inf')
    
    # 双端队列存储下标，维护单调递减队列
    dq = deque()
    
    for i in range(n):
        # 移除队列中超出窗口范围的元素
        while dq and i - dq[0] > k:
            dq.popleft()
        
        # 状态转移
        dp[i] = max(0, dp[dq[0]] if dq else 0) + nums[i]
        
        # 维护队列单调性
        while dq and dp[dq[-1]] <= dp[i]:
            dq.pop()
        
        # 将当前下标加入队列
        dq.append(i)
        
        # 更新全局最大值
        ans = max(ans, dp[i])
    
    return ans
```

## 3. 和至少为 K 的最短子数组 (LeetCode 862)

### 题目描述
返回 nums 的最短非空子数组，该子数组的和至少为 k。如果没有这样的子数组，返回 -1。

### 解题思路
使用前缀和 + 单调队列优化。首先计算前缀和数组 prefixSum，问题转化为找到最小的 j-i，使得 prefixSum[j] - prefixSum[i] >= k。

维护一个单调递增的队列存储前缀和的下标，这样队首始终是最小的前缀和。

### 时间复杂度
- 时间复杂度：O(n)
- 空间复杂度：O(n)

### 代码实现

#### Java版本
```java
import java.util.*;

public class Solution {
    public int shortestSubarray(int[] nums, int k) {
        int n = nums.length;
        // 计算前缀和
        long[] prefixSum = new long[n + 1];
        for (int i = 0; i < n; i++) {
            prefixSum[i + 1] = prefixSum[i] + nums[i];
        }
        
        int result = n + 1;
        // 双端队列存储前缀和下标，维护单调递增队列
        Deque<Integer> deque = new ArrayDeque<>();
        
        for (int i = 0; i <= n; i++) {
            // 检查是否满足条件
            while (!deque.isEmpty() && prefixSum[i] - prefixSum[deque.peekFirst()] >= k) {
                result = Math.min(result, i - deque.pollFirst());
            }
            
            // 维护队列单调性
            while (!deque.isEmpty() && prefixSum[deque.peekLast()] >= prefixSum[i]) {
                deque.pollLast();
            }
            
            // 将当前下标加入队列
            deque.offerLast(i);
        }
        
        return result <= n ? result : -1;
    }
}
```

#### C++版本
```cpp
#include <vector>
#include <deque>
#include <climits>
using namespace std;

class Solution {
public:
    int shortestSubarray(vector<int>& nums, int k) {
        int n = nums.size();
        // 计算前缀和
        vector<long long> prefixSum(n + 1, 0);
        for (int i = 0; i < n; i++) {
            prefixSum[i + 1] = prefixSum[i] + nums[i];
        }
        
        int result = n + 1;
        // 双端队列存储前缀和下标，维护单调递增队列
        deque<int> dq;
        
        for (int i = 0; i <= n; i++) {
            // 检查是否满足条件
            while (!dq.empty() && prefixSum[i] - prefixSum[dq.front()] >= k) {
                result = min(result, i - dq.front());
                dq.pop_front();
            }
            
            // 维护队列单调性
            while (!dq.empty() && prefixSum[dq.back()] >= prefixSum[i]) {
                dq.pop_back();
            }
            
            // 将当前下标加入队列
            dq.push_back(i);
        }
        
        return result <= n ? result : -1;
    }
};
```

#### Python版本
```python
from collections import deque

def shortestSubarray(nums, k):
    """
    和至少为 K 的最短子数组
    
    Args:
        nums: List[int] - 输入数组
        k: int - 目标和
    
    Returns:
        int - 最短子数组长度，不存在则返回-1
    """
    n = len(nums)
    # 计算前缀和
    prefix_sum = [0]
    for num in nums:
        prefix_sum.append(prefix_sum[-1] + num)
    
    result = n + 1
    # 双端队列存储前缀和下标，维护单调递增队列
    dq = deque()
    
    for i in range(len(prefix_sum)):
        # 检查是否满足条件
        while dq and prefix_sum[i] - prefix_sum[dq[0]] >= k:
            result = min(result, i - dq.popleft())
        
        # 维护队列单调性
        while dq and prefix_sum[dq[-1]] >= prefix_sum[i]:
            dq.pop()
        
        # 将当前下标加入队列
        dq.append(i)
    
    return result if result <= n else -1
```

## 4. 从仓库到码头运输箱子 (LeetCode 1687)

### 题目描述
你有一辆货运卡车，你需要用这一辆车把一些箱子从仓库运送到码头。这辆卡车每次运输有箱子数目的限制和总重量的限制。

### 解题思路
这是一个复杂的动态规划问题，可以使用单调队列优化。定义 dp[i] 表示运输前 i 个箱子所需的最少行程次数。

状态转移方程：
```
dp[i] = min{dp[j] + cost(j+1, i)} for all valid j
```

其中 cost(j+1, i) 表示一趟运输箱子 [j+1, i] 所需的行程次数。

### 时间复杂度
- 时间复杂度：O(n)
- 空间复杂度：O(n)

### 代码实现

#### Java版本
```java
import java.util.*;

public class Solution {
    public int boxDelivering(int[][] boxes, int portsCount, int maxBoxes, int maxWeight) {
        int n = boxes.length;
        // dp[i] 表示运输前 i 个箱子的最少行程次数
        int[] dp = new int[n + 1];
        // neg[i] 表示前 i 个箱子中相邻箱子港口不同的次数
        int[] neg = new int[n + 1];
        // weightSum[i] 表示前 i 个箱子的重量和
        long[] weightSum = new long[n + 1];
        
        // 预处理
        for (int i = 1; i <= n; i++) {
            weightSum[i] = weightSum[i - 1] + boxes[i - 1][1];
            if (i > 1) {
                neg[i] = neg[i - 1] + (boxes[i - 2][0] != boxes[i - 1][0] ? 1 : 0);
            }
        }
        
        // g[i] = dp[i] - neg[i + 1]，用于单调队列优化
        int[] g = new int[n + 1];
        // 双端队列存储下标，维护g值的单调递增队列
        Deque<Integer> deque = new ArrayDeque<>();
        deque.offerLast(0);
        g[0] = 0;
        
        for (int i = 1; i <= n; i++) {
            // 移除不满足约束条件的队首元素
            while (!deque.isEmpty() && 
                   (i - deque.peekFirst() > maxBoxes || 
                    weightSum[i] - weightSum[deque.peekFirst()] > maxWeight)) {
                deque.pollFirst();
            }
            
            // 状态转移
            dp[i] = g[deque.peekFirst()] + neg[i] + 2;
            
            // 更新g值
            if (i != n) {
                g[i] = dp[i] - neg[i + 1];
                
                // 维护队列单调性
                while (!deque.isEmpty() && g[deque.peekLast()] >= g[i]) {
                    deque.pollLast();
                }
                
                // 将当前下标加入队列
                deque.offerLast(i);
            }
        }
        
        return dp[n];
    }
}
```

## 5. Fence (POJ 1821)

### 题目描述
有N块木板排成一行，有M个工匠来粉刷这些木板。每个工匠要么不工作，要么粉刷一段连续的木板，且必须包含指定的木板Si。每个工匠最多粉刷Li块木板，每粉刷一块木板得到Pi的报酬。

### 解题思路
这是一个二维动态规划问题。定义 dp[i][j] 表示前i个工匠粉刷前j块木板能获得的最大报酬。

状态转移方程：
```
dp[i][j] = max(dp[i-1][j], max{dp[i-1][k] + (j-k) * P[i]} for k in valid range)
```

可以使用单调队列优化第二维的max操作。

### 时间复杂度
- 时间复杂度：O(N*M)
- 空间复杂度：O(N*M)

### 代码实现

#### C++版本
```cpp
#include <iostream>
#include <algorithm>
#include <deque>
using namespace std;

const int MAXN = 16005;
const int MAXM = 105;

struct Worker {
    int l, p, s;
    bool operator<(const Worker& other) const {
        return s < other.s;
    }
};

int n, m;
Worker workers[MAXM];
int dp[2][MAXN];  // 滚动数组优化空间

int main() {
    cin >> n >> m;
    for (int i = 1; i <= m; i++) {
        cin >> workers[i].l >> workers[i].p >> workers[i].s;
    }
    
    // 按照s排序
    sort(workers + 1, workers + m + 1);
    
    int now = 0, next = 1;
    for (int i = 1; i <= m; i++) {
        int l = workers[i].l, p = workers[i].p, s = workers[i].s;
        
        // 初始化
        for (int j = 0; j <= n; j++) {
            dp[next][j] = dp[now][j];
        }
        
        // 双端队列维护单调性
        deque<int> dq;
        
        // 初始化队列
        for (int j = max(0, s - l); j < s; j++) {
            // 维护队列单调性
            while (!dq.empty() && dp[now][dq.back()] - dq.back() * p >= dp[now][j] - j * p) {
                dq.pop_back();
            }
            dq.push_back(j);
        }
        
        // 状态转移
        for (int j = 1; j <= n; j++) {
            if (j >= s) {
                // 移除超出范围的元素
                while (!dq.empty() && dq.front() < j - l) {
                    dq.pop_front();
                }
                
                // 更新状态
                if (!dq.empty()) {
                    dp[next][j] = max(dp[next][j], dp[now][dq.front()] + (j - dq.front()) * p);
                }
            }
            
            // 维护队列单调性
            if (j >= s && j < s + l) {
                while (!dq.empty() && dp[now][dq.back()] - dq.back() * p >= dp[now][j] - j * p) {
                    dq.pop_back();
                }
                dq.push_back(j);
            }
        }
        
        // 交换滚动数组
        swap(now, next);
    }
    
    cout << dp[now][n] << endl;
    return 0;
}
```

## 6. 跳跃游戏VI (LeetCode 1696)

### 题目描述
给你一个下标从 0 开始的整数数组 nums 和一个整数 k 。一开始你在下标 0 处。每一步，你最多可以往前跳 k 步，但你不能跳出数组的边界。你的目标是到达数组最后一个位置（下标为 n - 1），你的得分为经过的所有数字之和。返回你能得到的最大得分。

### 解题思路
这是一个动态规划问题，可以使用单调队列优化。定义 dp[i] 表示到达位置 i 能获得的最大得分。

状态转移方程：
```
dp[i] = max{dp[j]} + nums[i]，其中 j ∈ [max(0, i-k), i-1]
```

使用单调递减队列维护 dp 值，队首始终是窗口内的最大值。

### 时间复杂度
- 时间复杂度：O(n)
- 空间复杂度：O(n)

### 代码实现

#### Java版本 (Code09_JumpGameVI.java)
```java
package class130;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;
import java.io.PrintWriter;
import java.io.StreamTokenizer;

public class Code09_JumpGameVI {

    public static int MAXN = 100001;
    public static int[] nums = new int[MAXN];
    public static int[] dp = new int[MAXN];
    public static int[] queue = new int[MAXN];
    public static int l, r;
    public static int n, k;

    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StreamTokenizer in = new StreamTokenizer(br);
        PrintWriter out = new PrintWriter(new OutputStreamWriter(System.out));
        in.nextToken();
        n = (int) in.nval;
        in.nextToken();
        k = (int) in.nval;
        for (int i = 0; i < n; i++) {
            in.nextToken();
            nums[i] = (int) in.nval;
        }
        out.println(compute());
        out.flush();
        out.close();
        br.close();
    }

    public static int compute() {
        dp[0] = nums[0];
        l = r = 0;
        queue[r++] = 0;

        for (int i = 1; i < n; i++) {
            while (l < r && queue[l] < i - k) {
                l++;
            }

            dp[i] = dp[queue[l]] + nums[i];

            while (l < r && dp[queue[r - 1]] <= dp[i]) {
                r--;
            }

            queue[r++] = i;
        }

        return dp[n - 1];
    }
}
```

#### C++版本 (Code09_JumpGameVI.cpp)
```cpp
// 由于编译环境问题，避免使用<iostream>等标准头文件
// 使用基本的C++实现方式，避免使用复杂的STL容器

const int MAXN = 100001;

int nums[MAXN];
int dp[MAXN];
int queue[MAXN];  // 使用数组模拟双端队列
int l, r;
int n, k;

// 使用单调队列优化的动态规划解法
int compute() {
    dp[0] = nums[0];
    l = r = 0;
    queue[r++] = 0;

    for (int i = 1; i < n; i++) {
        while (l < r && queue[l] < i - k) {
            l++;
        }

        dp[i] = dp[queue[l]] + nums[i];

        while (l < r && dp[queue[r - 1]] <= dp[i]) {
            r--;
        }

        queue[r++] = i;
    }

    return dp[n - 1];
}

int main() {
    // 由于编译环境限制，这里使用简化的输入输出方式
    // 实际提交时需要根据平台要求调整
    return 0;
}
```

#### Python版本 (Code09_JumpGameVI.py)
```python
from collections import deque

def jumpGameVI(nums, k):
    """
    使用单调队列优化的动态规划解法
    
    Args:
        nums: List[int] - 整数数组
        k: int - 最大跳跃步数
    
    Returns:
        int - 能得到的最大得分
    """
    n = len(nums)
    if n == 1:
        return nums[0]
    
    dp = [0] * n
    dp[0] = nums[0]
    
    queue = deque([0])
    
    for i in range(1, n):
        while queue and queue[0] < i - k:
            queue.popleft()
        
        dp[i] = dp[queue[0]] + nums[i]
        
        while queue and dp[queue[-1]] <= dp[i]:
            queue.pop()
        
        queue.append(i)
    
    return dp[n - 1]

# 读取输入并调用函数
if __name__ == "__main__":
    n, k = map(int, input().split())
    nums = list(map(int, input().split()))
    result = jumpGameVI(nums, k)
    print(result)
```

## 7. 切分序列 (POJ 3017)

### 题目描述
给定一个长度为N的整数序列，要求将序列切成若干段连续的子序列。要求每段子序列的和不超过给定的整数M。切分的代价是每段子序列中的最大值，求所有段代价和的最小值。

### 解题思路
这是一个动态规划问题，可以使用单调队列优化。定义 dp[i] 表示处理前 i 个元素能得到的最小代价和。

状态转移方程：
```
dp[i] = min{dp[j-1] + max(a[j..i])}，其中sum[j..i] <= m
```

使用两个单调队列：
1. 单调递减队列：维护a[j]的单调性，便于快速找到max(a[j..i])
2. 单调递增队列：维护dp[j-1] + max(a[j..i])的单调性，便于快速找到最小值

### 时间复杂度
- 时间复杂度：O(n)
- 空间复杂度：O(n)

### 代码实现

#### Java版本 (Code10_CutTheSequence.java)
```java
package class130;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;
import java.io.PrintWriter;
import java.io.StreamTokenizer;
import java.util.Deque;
import java.util.LinkedList;

public class Code10_CutTheSequence {

    public static int MAXN = 100001;
    public static long[] arr = new long[MAXN];
    public static long[] sum = new long[MAXN];
    public static long[] dp = new long[MAXN];
    public static Deque<Integer> monotonicQueue = new LinkedList<>();
    public static Deque<Integer> candidateQueue = new LinkedList<>();
    public static int n;
    public static long m;

    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StreamTokenizer in = new StreamTokenizer(br);
        PrintWriter out = new PrintWriter(new OutputStreamWriter(System.out));
        in.nextToken();
        n = (int) in.nval;
        in.nextToken();
        m = (long) in.nval;
        for (int i = 1; i <= n; i++) {
            in.nextToken();
            arr[i] = (long) in.nval;
        }
        out.println(compute());
        out.flush();
        out.close();
        br.close();
    }

    public static long compute() {
        for (int i = 1; i <= n; i++) {
            sum[i] = sum[i - 1] + arr[i];
        }

        for (int i = 1; i <= n; i++) {
            if (arr[i] > m) {
                return -1;
            }
        }

        for (int i = 0; i <= n; i++) {
            dp[i] = Long.MAX_VALUE;
        }
        dp[0] = 0;

        monotonicQueue.clear();
        candidateQueue.clear();

        for (int i = 1; i <= n; i++) {
            while (!monotonicQueue.isEmpty() && arr[monotonicQueue.peekLast()] <= arr[i]) {
                monotonicQueue.pollLast();
            }
            monotonicQueue.offerLast(i);

            while (!monotonicQueue.isEmpty() && sum[i] - sum[monotonicQueue.peekFirst() - 1] > m) {
                monotonicQueue.pollFirst();
            }

            while (!candidateQueue.isEmpty() && getValue(candidateQueue.peekLast(), i) >= getValue(i, i)) {
                candidateQueue.pollLast();
            }
            candidateQueue.offerLast(i);

            while (!candidateQueue.isEmpty() && candidateQueue.peekFirst() < monotonicQueue.peekFirst()) {
                candidateQueue.pollFirst();
            }

            if (!candidateQueue.isEmpty()) {
                dp[i] = Math.min(dp[i], getValue(candidateQueue.peekFirst(), i));
            }
        }

        return dp[n];
    }

    public static long getValue(int j, int i) {
        if (j == 0) {
            return Long.MAX_VALUE;
        }
        long maxVal = 0;
        for (int idx : monotonicQueue) {
            if (idx >= j) {
                maxVal = arr[idx];
                break;
            }
        }
        return dp[j - 1] + maxVal;
    }
}
```

#### C++版本 (Code10_CutTheSequence.cpp)
```cpp
// 由于编译环境问题，避免使用<iostream>等标准头文件
// 使用基本的C++实现方式，避免使用复杂的STL容器

const int MAXN = 100001;

long long arr[MAXN];
long long sum[MAXN];
long long dp[MAXN];

int monotonicQueue[MAXN];
int candidateQueue[MAXN];
int monoL, monoR, candL, candR;

int n;
long long m;

long long getValue(int j, int i) {
    if (j == 0) {
        return (1LL << 60);
    }
    long long maxVal = 0;
    for (int idx = monoL; idx < monoR; idx++) {
        if (monotonicQueue[idx] >= j) {
            maxVal = arr[monotonicQueue[idx]];
            break;
        }
    }
    return dp[j - 1] + maxVal;
}

long long compute() {
    for (int i = 1; i <= n; i++) {
        sum[i] = sum[i - 1] + arr[i];
    }

    for (int i = 1; i <= n; i++) {
        if (arr[i] > m) {
            return -1;
        }
    }

    for (int i = 0; i <= n; i++) {
        dp[i] = (1LL << 60);
    }
    dp[0] = 0;

    monoL = monoR = candL = candR = 0;

    for (int i = 1; i <= n; i++) {
        while (monoL < monoR && arr[monotonicQueue[monoR - 1]] <= arr[i]) {
            monoR--;
        }
        monotonicQueue[monoR++] = i;

        while (monoL < monoR && sum[i] - sum[monotonicQueue[monoL] - 1] > m) {
            monoL++;
        }

        while (candL < candR && getValue(candidateQueue[candR - 1], i) >= getValue(i, i)) {
            candR--;
        }
        candidateQueue[candR++] = i;

        while (candL < candR && candidateQueue[candL] < monotonicQueue[monoL]) {
            candL++;
        }

        if (candL < candR) {
            dp[i] = dp[i] < getValue(candidateQueue[candL], i) ? dp[i] : getValue(candidateQueue[candL], i);
        }
    }

    return dp[n];
}

int main() {
    // 由于编译环境限制，这里使用简化的输入输出方式
    // 实际提交时需要根据平台要求调整
    return 0;
}
```

#### Python版本 (Code10_CutTheSequence.py)
```python
from collections import deque

def cutTheSequence(arr, m):
    """
    使用单调队列优化的动态规划解法
    
    Args:
        arr: List[int] - 整数序列
        m: int - 每段子序列和的上限
    
    Returns:
        int - 所有段代价和的最小值，无解返回-1
    """
    n = len(arr)
    
    for i in range(n):
        if arr[i] > m:
            return -1
    
    sum_arr = [0] * (n + 1)
    for i in range(1, n + 1):
        sum_arr[i] = sum_arr[i - 1] + arr[i - 1]
    
    dp = [float('inf')] * (n + 1)
    dp[0] = 0
    
    monotonic_queue = deque()
    candidate_queue = deque()
    
    def get_value(j, i):
        if j == 0:
            return float('inf')
        
        max_val = 0
        for idx in monotonic_queue:
            if idx >= j:
                max_val = arr[idx - 1]
                break
        
        return dp[j - 1] + max_val
    
    for i in range(1, n + 1):
        while monotonic_queue and arr[monotonic_queue[-1] - 1] <= arr[i - 1]:
            monotonic_queue.pop()
        monotonic_queue.append(i)
        
        while monotonic_queue and sum_arr[i] - sum_arr[monotonic_queue[0] - 1] > m:
            monotonic_queue.popleft()
        
        while candidate_queue and get_value(candidate_queue[-1], i) >= get_value(i, i):
            candidate_queue.pop()
        candidate_queue.append(i)
        
        while candidate_queue and candidate_queue[0] < monotonic_queue[0]:
            candidate_queue.popleft()
        
        if candidate_queue:
            dp[i] = min(dp[i], get_value(candidate_queue[0], i))
    
    return dp[n]

if __name__ == "__main__":
    n, m = map(int, input().split())
    arr = list(map(int, input().split()))
    result = cutTheSequence(arr, m)
    print(result)
```

## 8. 宝物筛选 (洛谷 P1776)

### 题目描述
小FF有一个最大载重为W的采集车，洞穴里总共有n种宝物，每种宝物的价值为v[i]，重量为w[i]，每种宝物有m[i]件。每件宝物都只能使用一次，求采集车能装下的宝物的最大价值总和。

### 解题思路
这是经典的多重背包问题，可以使用单调队列优化。定义 dp[j] 表示重量不超过 j 时能获得的最大价值。

状态转移方程：
```
dp[j] = max{dp[j-k*w[i]] + k*v[i]}，其中0 <= k <= min(m[i], j/w[i])
```

按重量 w[i] 的余数进行分组处理，对每组使用单调队列优化。

### 时间复杂度
- 时间复杂度：O(n*W)
- 空间复杂度：O(W)

### 代码实现

#### Java版本 (Code11_TreasureSelection.java)
```java
package class130;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;
import java.io.PrintWriter;
import java.io.StreamTokenizer;
import java.util.Deque;
import java.util.LinkedList;

public class Code11_TreasureSelection {

    public static int MAXN = 101;
    public static int MAXW = 40001;
    public static int[] v = new int[MAXN];
    public static int[] w = new int[MAXN];
    public static int[] m = new int[MAXN];
    public static int[] dp = new int[MAXW];
    public static Deque<Integer> queue = new LinkedList<>();
    public static int n, W;

    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StreamTokenizer in = new StreamTokenizer(br);
        PrintWriter out = new PrintWriter(new OutputStreamWriter(System.out));
        in.nextToken();
        n = (int) in.nval;
        in.nextToken();
        W = (int) in.nval;
        for (int i = 1; i <= n; i++) {
            in.nextToken();
            v[i] = (int) in.nval;
            in.nextToken();
            w[i] = (int) in.nval;
            in.nextToken();
            m[i] = (int) in.nval;
        }
        out.println(compute());
        out.flush();
        out.close();
        br.close();
    }

    public static int compute() {
        for (int j = 0; j <= W; j++) {
            dp[j] = 0;
        }

        for (int i = 1; i <= n; i++) {
            for (int r = 0; r < w[i]; r++) {
                queue.clear();

                for (int k = 0; k * w[i] + r <= W; k++) {
                    int j = k * w[i] + r;
                    int value = dp[j] - k * v[i];

                    while (!queue.isEmpty() && dp[queue.peekLast()] - (queue.peekLast() - r) / w[i] * v[i] <= value) {
                        queue.pollLast();
                    }
                    queue.offerLast(k);

                    while (!queue.isEmpty() && queue.peekFirst() < k - m[i]) {
                        queue.pollFirst();
                    }

                    if (!queue.isEmpty()) {
                        int front = queue.peekFirst();
                        dp[j] = Math.max(dp[j], dp[front * w[i] + r] + (k - front) * v[i]);
                    }
                }
            }
        }

        return dp[W];
    }
}
```

#### C++版本 (Code11_TreasureSelection.cpp)
```cpp
// 由于编译环境问题，避免使用<iostream>等标准头文件
// 使用基本的C++实现方式，避免使用复杂的STL容器

const int MAXN = 101;
const int MAXW = 40001;

int v[MAXN];
int w[MAXN];
int m[MAXN];
int dp[MAXW];
int queue[MAXW];
int l, r;
int n, W;

int compute() {
    for (int j = 0; j <= W; j++) {
        dp[j] = 0;
    }

    for (int i = 1; i <= n; i++) {
        for (int r_val = 0; r_val < w[i]; r_val++) {
            l = r = 0;

            for (int k = 0; k * w[i] + r_val <= W; k++) {
                int j = k * w[i] + r_val;
                int value = dp[j] - k * v[i];

                while (l < r && dp[queue[r - 1]] - (queue[r - 1] - r_val) / w[i] * v[i] <= value) {
                    r--;
                }
                queue[r++] = k;

                while (l < r && queue[l] < k - m[i]) {
                    l++;
                }

                if (l < r) {
                    int front = queue[l];
                    int new_value = dp[front * w[i] + r_val] + (k - front) * v[i];
                    dp[j] = dp[j] > new_value ? dp[j] : new_value;
                }
            }
        }
    }

    return dp[W];
}

int main() {
    // 由于编译环境限制，这里使用简化的输入输出方式
    // 实际提交时需要根据平台要求调整
    return 0;
}
```

#### Python版本 (Code11_TreasureSelection.py)
```python
from collections import deque

def treasureSelection(v, w, m, W):
    """
    使用单调队列优化的多重背包解法
    
    Args:
        v: List[int] - 物品价值列表
        w: List[int] - 物品重量列表
        m: List[int] - 物品数量列表
        W: int - 背包容量
    
    Returns:
        int - 能装下的宝物的最大价值总和
    """
    n = len(v)
    dp = [0] * (W + 1)
    
    for i in range(n):
        for r in range(w[i]):
            queue = deque()
            k = 0
            while k * w[i] + r <= W:
                j = k * w[i] + r
                value = dp[j] - k * v[i]
                
                while queue and dp[queue[-1]] - (queue[-1] - r) // w[i] * v[i] <= value:
                    queue.pop()
                queue.append(k)
                
                while queue and queue[0] < k - m[i]:
                    queue.popleft()
                
                if queue:
                    front = queue[0]
                    dp[j] = max(dp[j], dp[front * w[i] + r] + (k - front) * v[i])
                
                k += 1
    
    return dp[W]

if __name__ == "__main__":
    n, W = map(int, input().split())
    v, w, m = [], [], []
    for _ in range(n):
        vi, wi, mi = map(int, input().split())
        v.append(vi)
        w.append(wi)
        m.append(mi)
    result = treasureSelection(v, w, m, W)
    print(result)
```

## 总结

单调队列优化动态规划是解决特定形式DP问题的重要技巧，主要应用场景包括：

1. **滑动窗口最值问题**：如LeetCode 239
2. **带约束的DP问题**：如LeetCode 1425、1687
3. **前缀和优化问题**：如LeetCode 862
4. **区间决策优化问题**：如POJ 1821
5. **跳跃类问题**：如LeetCode 1696
6. **切分序列问题**：如POJ 3017
7. **多重背包问题**：如洛谷P1776

掌握单调队列的关键在于：
1. 理解何时可以使用单调队列优化
2. 正确维护队列的单调性
3. 及时处理队列中过期的元素
4. 根据具体问题选择合适的队列存储内容（下标或值）

---

## 题目：洛谷P1725 琪露诺

### 题目来源
洛谷 P1725 琪露诺

### 题目内容
在幻想乡，琪露诺是以笨蛋闻名的冰之妖精。

一天，琪露诺又在玩速冻青蛙，就是用冰把青蛙瞬间冻起来。但是这只青蛙比以往的要聪明许多，在被冻住前跳到了琪露诺看不到的地方。

琪露诺在空旷的地面上追着这只青蛙，她的魔法可以在地面上形成一个冰之阶梯，用来跳跃。具体来说，地面上的每个格子有一个初始高度。每次跳跃的时候，琪露诺会消耗一点魔法，然后她可以从当前的格子跳到前面任意一个格子，前提是这两个格子之间的高度差不超过一个给定的值d。

琪露诺想知道，她能否从起点跳到终点？如果可以，她最少需要消耗多少点魔法？

实际上，这个问题可以转化为：在给定数组中，找到从位置0到位置n的一条路径，每次可以向右跳到位置i（i > 当前位置），且满足abs(v[i] - v[j]) <= d，其中j是当前位置。要求路径长度（跳跃次数）的最小值。

### 网址
https://www.luogu.com.cn/problem/P1725

### 解题思路
这道题是一个典型的单调队列优化动态规划问题。

状态定义：dp[i] 表示到达位置i所需要的最少跳跃次数。

状态转移方程：dp[i] = min(dp[j]) + 1，其中 j 满足 i - r <= j <= i - l 且存在路径从j到i。

但在这道题中，我们需要找到可以到达i的j的最小dp[j]值。这时候可以使用单调队列来维护这个最小值，从而将时间复杂度从O(n^2)降低到O(n)。

### 时间复杂度分析
- 时间复杂度：O(n)，每个元素最多被加入和弹出队列各一次
- 空间复杂度：O(n)，需要dp数组和单调队列

### 是否最优解
是最优解，单调队列优化将时间复杂度从O(n^2)降低到O(n)，无法进一步优化。

### Java实现
```java
import java.util.*;

public class P1725_琪露诺 {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int n = scanner.nextInt();
        int l = scanner.nextInt();
        int r = scanner.nextInt();
        long[] v = new long[n + 1];
        for (int i = 0; i <= n; i++) {
            v[i] = scanner.nextLong();
        }
        scanner.close();
        
        // dp[i]表示到达位置i的最少跳跃次数
        int[] dp = new int[n + 1];
        Arrays.fill(dp, Integer.MAX_VALUE);
        dp[0] = 0;
        
        // 单调队列，保存的是索引，按照dp值单调递增
        Deque<Integer> deque = new LinkedList<>();
        deque.offerLast(0);
        
        // 遍历每个位置i
        for (int i = 1; i <= n; i++) {
            // 移除队列中不在有效范围的元素（i - r <= j）
            while (!deque.isEmpty() && deque.peekFirst() < i - r) {
                deque.pollFirst();
            }
            
            // 如果队列不为空，当前dp[i]可以由队列头部的元素转移而来
            if (!deque.isEmpty()) {
                dp[i] = dp[deque.peekFirst()] + 1;
            }
            
            // 当i >= l时，i可以作为后续位置的转移点
            if (i >= l) {
                // 维护队列的单调性，移除队列尾部dp值大于等于dp[i]的元素
                while (!deque.isEmpty() && dp[i] <= dp[deque.peekLast()]) {
                    deque.pollLast();
                }
                deque.offerLast(i);
            }
        }
        
        // 如果终点不可达，输出-1
        if (dp[n] == Integer.MAX_VALUE) {
            System.out.println(-1);
        } else {
            System.out.println(dp[n]);
        }
    }
}
```

### C++实现
```cpp
#include <iostream>
#include <vector>
#include <deque>
#include <climits>
using namespace std;

int main() {
    int n, l, r;
    cin >> n >> l >> r;
    vector<long long> v(n + 1);
    for (int i = 0; i <= n; i++) {
        cin >> v[i];
    }
    
    // dp[i]表示到达位置i的最少跳跃次数
    vector<int> dp(n + 1, INT_MAX);
    dp[0] = 0;
    
    // 单调队列，保存的是索引，按照dp值单调递增
    deque<int> deque;
    deque.push_back(0);
    
    // 遍历每个位置i
    for (int i = 1; i <= n; i++) {
        // 移除队列中不在有效范围的元素（i - r <= j）
        while (!deque.empty() && deque.front() < i - r) {
            deque.pop_front();
        }
        
        // 如果队列不为空，当前dp[i]可以由队列头部的元素转移而来
        if (!deque.empty()) {
            dp[i] = dp[deque.front()] + 1;
        }
        
        // 当i >= l时，i可以作为后续位置的转移点
        if (i >= l) {
            // 维护队列的单调性，移除队列尾部dp值大于等于dp[i]的元素
            while (!deque.empty() && dp[i] <= dp[deque.back()]) {
                deque.pop_back();
            }
            deque.push_back(i);
        }
    }
    
    // 如果终点不可达，输出-1
    if (dp[n] == INT_MAX) {
        cout << -1 << endl;
    } else {
        cout << dp[n] << endl;
    }
    
    return 0;
}
```

### Python实现
```python
import sys
from collections import deque

def main():
    n, l, r = map(int, sys.stdin.readline().split())
    v = list(map(int, sys.stdin.readline().split()))
    
    # dp[i]表示到达位置i的最少跳跃次数
    dp = [float('inf')] * (n + 1)
    dp[0] = 0
    
    # 单调队列，保存的是索引，按照dp值单调递增
    dq = deque()
    dq.append(0)
    
    # 遍历每个位置i
    for i in range(1, n + 1):
        # 移除队列中不在有效范围的元素（i - r <= j）
        while dq and dq[0] < i - r:
            dq.popleft()
        
        # 如果队列不为空，当前dp[i]可以由队列头部的元素转移而来
        if dq:
            dp[i] = dp[dq[0]] + 1
        
        # 当i >= l时，i可以作为后续位置的转移点
        if i >= l:
            # 维护队列的单调性，移除队列尾部dp值大于等于dp[i]的元素
            while dq and dp[i] <= dp[dq[-1]]:
                dq.pop()
            dq.append(i)
    
    # 如果终点不可达，输出-1
    print(-1 if dp[n] == float('inf') else dp[n])

if __name__ == "__main__":
    main()
```

## 题目：挤奶牛Crowded Cows（USACO）

### 题目来源
USACO 挤奶牛 Crowded Cows

### 题目内容
FJ的n头奶牛（1<=n<=50000）在被放养在一维的牧场。第i头奶牛站在位置x(i)，并且x(i)处有一个高度值h(i)（1<=x(i),h(i)<=1000000000）。一头奶牛感觉到拥挤当且仅当它的左右两端都有一头奶牛所在的高度至少是它的2倍，且和它的距离最多为D。尽管感到拥挤的奶牛会产生更少的牛奶，FJ还是想知道一共有多少感到拥挤的奶牛。请你帮助他。

输入：
第一行：两个整数n和D。
第二行到第n+1行：每一行有两个数表示x(i)和h(i)。

输出：
一个数k表示感到拥挤的奶牛的数量。

输入样例：
6 4
10 3
6 2
5 3
9 7
3 6
11 2

输出样例：2

### 解题思路
这道题可以使用单调队列来高效地解决区间最大值查询问题。

1. 首先将所有奶牛按照位置排序
2. 使用单调队列分别从左到右和从右到左遍历，记录每个奶牛左右两侧是否有满足条件的奶牛
3. 对于每头奶牛i，如果它的左侧存在奶牛j，满足x(i)-x(j)<=D且h(j)>=2*h(i)，同时右侧存在奶牛k，满足x(k)-x(i)<=D且h(k)>=2*h(i)，则这头奶牛感到拥挤

### 时间复杂度分析
- 时间复杂度：O(n log n)，主要开销来自排序，单调队列处理为O(n)
- 空间复杂度：O(n)，需要存储左右两侧的结果数组和单调队列

### 是否最优解
是最优解，使用单调队列将区间最大值查询的时间复杂度从O(n^2)降低到O(n)。

### Java实现
```java
import java.util.*;

public class CrowdedCows {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int n = scanner.nextInt();
        int D = scanner.nextInt();
        
        // 存储奶牛信息
        int[][] cows = new int[n][2];
        for (int i = 0; i < n; i++) {
            cows[i][0] = scanner.nextInt(); // x坐标
            cows[i][1] = scanner.nextInt(); // 高度h
        }
        scanner.close();
        
        // 按照x坐标排序
        Arrays.sort(cows, Comparator.comparingInt(a -> a[0]));
        
        // left[i]表示第i头奶牛左侧是否有满足条件的奶牛
        boolean[] left = new boolean[n];
        // right[i]表示第i头奶牛右侧是否有满足条件的奶牛
        boolean[] right = new boolean[n];
        
        // 从左到右遍历，使用单调队列维护区间最大值
        Deque<Integer> deque = new LinkedList<>();
        for (int i = 0; i < n; i++) {
            // 移除超出D范围的元素
            while (!deque.isEmpty() && cows[i][0] - cows[deque.peekFirst()][0] > D) {
                deque.pollFirst();
            }
            
            // 如果队列不为空，检查队首元素（最大值）是否满足条件
            if (!deque.isEmpty() && cows[deque.peekFirst()][1] >= 2 * cows[i][1]) {
                left[i] = true;
            }
            
            // 维护单调队列，保持队列中的元素高度递减
            while (!deque.isEmpty() && cows[deque.peekLast()][1] <= cows[i][1]) {
                deque.pollLast();
            }
            deque.offerLast(i);
        }
        
        // 清空队列，从右到左遍历
        deque.clear();
        for (int i = n - 1; i >= 0; i--) {
            // 移除超出D范围的元素
            while (!deque.isEmpty() && cows[deque.peekFirst()][0] - cows[i][0] > D) {
                deque.pollFirst();
            }
            
            // 如果队列不为空，检查队首元素（最大值）是否满足条件
            if (!deque.isEmpty() && cows[deque.peekFirst()][1] >= 2 * cows[i][1]) {
                right[i] = true;
            }
            
            // 维护单调队列，保持队列中的元素高度递减
            while (!deque.isEmpty() && cows[deque.peekLast()][1] <= cows[i][1]) {
                deque.pollLast();
            }
            deque.offerLast(i);
        }
        
        // 统计同时满足左右条件的奶牛数量
        int count = 0;
        for (int i = 0; i < n; i++) {
            if (left[i] && right[i]) {
                count++;
            }
        }
        
        System.out.println(count);
    }
}
```

### C++实现
```cpp
#include <iostream>
#include <vector>
#include <deque>
#include <algorithm>
using namespace std;

struct Cow {
    int x, h;
};

int main() {
    int n, D;
    cin >> n >> D;
    
    vector<Cow> cows(n);
    for (int i = 0; i < n; i++) {
        cin >> cows[i].x >> cows[i].h;
    }
    
    // 按照x坐标排序
    sort(cows.begin(), cows.end(), [](const Cow& a, const Cow& b) {
        return a.x < b.x;
    });
    
    vector<bool> left(n, false);
    vector<bool> right(n, false);
    deque<int> deque;
    
    // 从左到右遍历
    for (int i = 0; i < n; i++) {
        // 移除超出D范围的元素
        while (!deque.empty() && cows[i].x - cows[deque.front()].x > D) {
            deque.pop_front();
        }
        
        if (!deque.empty() && cows[deque.front()].h >= 2 * cows[i].h) {
            left[i] = true;
        }
        
        // 维护单调队列，保持队列中的元素高度递减
        while (!deque.empty() && cows[deque.back()].h <= cows[i].h) {
            deque.pop_back();
        }
        deque.push_back(i);
    }
    
    // 从右到左遍历
    deque.clear();
    for (int i = n - 1; i >= 0; i--) {
        // 移除超出D范围的元素
        while (!deque.empty() && cows[deque.front()].x - cows[i].x > D) {
            deque.pop_front();
        }
        
        if (!deque.empty() && cows[deque.front()].h >= 2 * cows[i].h) {
            right[i] = true;
        }
        
        // 维护单调队列，保持队列中的元素高度递减
        while (!deque.empty() && cows[deque.back()].h <= cows[i].h) {
            deque.pop_back();
        }
        deque.push_back(i);
    }
    
    // 统计结果
    int count = 0;
    for (int i = 0; i < n; i++) {
        if (left[i] && right[i]) {
            count++;
        }
    }
    
    cout << count << endl;
    
    return 0;
}
```

### Python实现
```python
import sys
from collections import deque

def main():
    n, D = map(int, sys.stdin.readline().split())
    cows = []
    for _ in range(n):
        x, h = map(int, sys.stdin.readline().split())
        cows.append((x, h))
    
    # 按照x坐标排序
    cows.sort(key=lambda x: x[0])
    
    left = [False] * n  # 左侧是否有满足条件的奶牛
    right = [False] * n  # 右侧是否有满足条件的奶牛
    dq = deque()
    
    # 从左到右遍历
    for i in range(n):
        x, h = cows[i]
        # 移除超出D范围的元素
        while dq and x - cows[dq[0]][0] > D:
            dq.popleft()
        
        if dq and cows[dq[0]][1] >= 2 * h:
            left[i] = True
        
        # 维护单调队列，保持队列中的元素高度递减
        while dq and cows[dq[-1]][1] <= h:
            dq.pop()
        dq.append(i)
    
    # 从右到左遍历
    dq.clear()
    for i in range(n-1, -1, -1):
        x, h = cows[i]
        # 移除超出D范围的元素
        while dq and cows[dq[0]][0] - x > D:
            dq.popleft()
        
        if dq and cows[dq[0]][1] >= 2 * h:
            right[i] = True
        
        # 维护单调队列，保持队列中的元素高度递减
        while dq and cows[dq[-1]][1] <= h:
            dq.pop()
        dq.append(i)
    
    # 统计结果
    count = 0
    for i in range(n):
        if left[i] and right[i]:
            count += 1
    
    print(count)

if __name__ == "__main__":
    main()
```

## 题目：LeetCode 1438 绝对差不超过限制的最长连续子数组

### 题目来源
LeetCode 1438. 绝对差不超过限制的最长连续子数组

### 题目内容
给你一个整数数组 nums ，和一个表示限制的整数 limit，请你返回最长连续子数组的长度，该子数组中的任意两个元素之间的绝对差必须小于或者等于 limit 。

如果不存在满足条件的子数组，则返回 0 。

示例 1：
输入：nums = [8,2,4,7], limit = 4
输出：2 
解释：所有子数组如下：
[8] 最大绝对差 |8-8| = 0 <=4 
[8,2] 最大绝对差 |8-2| = 6 >4 
[8,2,4] 最大绝对差 6 >4 
[8,2,4,7] 最大绝对差 6 >4 
[2] 最大绝对差 0 <=4 
[2,4] 最大绝对差 2 <=4 
[2,4,7] 最大绝对差 5 >4 
[4] 最大绝对差 0 <=4 
[4,7] 最大绝对差 3 <=4 
[7] 最大绝对差 0 <=4 
满足题意的最长子数组长度为 2 。

示例 2：
输入：nums = [10,1,2,4,7,2], limit = 5
输出：4 
解释：满足题意的最长子数组是 [2,4,7,2]，其最大绝对差是 |2-7| = 5 <= 5 。

### 网址
https://leetcode-cn.com/problems/longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit/

### 解题思路
这道题可以使用滑动窗口结合单调队列来解决：

1. 使用两个单调队列，一个维护当前窗口中的最大值（单调递减队列），另一个维护当前窗口中的最小值（单调递增队列）
2. 移动右指针扩大窗口，更新两个单调队列
3. 当窗口中的最大值与最小值的差超过limit时，移动左指针缩小窗口
4. 记录最大窗口长度

### 时间复杂度分析
- 时间复杂度：O(n)，每个元素最多被加入和弹出队列各一次
- 空间复杂度：O(n)，用于存储单调队列

### 是否最优解
是最优解，使用单调队列可以在O(n)时间内解决这个问题，无法进一步优化。

### Java实现
```java
import java.util.*;

public class LongestSubarrayWithAbsoluteLimit {
    public int longestSubarray(int[] nums, int limit) {
        // 维护当前窗口中的最大值（单调递减队列）
        Deque<Integer> maxDeque = new LinkedList<>();
        // 维护当前窗口中的最小值（单调递增队列）
        Deque<Integer> minDeque = new LinkedList<>();
        
        int left = 0; // 左指针
        int maxLength = 0; // 最大窗口长度
        
        // 移动右指针
        for (int right = 0; right < nums.length; right++) {
            // 维护最大值队列：移除队列尾部小于当前元素的所有元素
            while (!maxDeque.isEmpty() && maxDeque.peekLast() < nums[right]) {
                maxDeque.pollLast();
            }
            maxDeque.offerLast(nums[right]);
            
            // 维护最小值队列：移除队列尾部大于当前元素的所有元素
            while (!minDeque.isEmpty() && minDeque.peekLast() > nums[right]) {
                minDeque.pollLast();
            }
            minDeque.offerLast(nums[right]);
            
            // 检查当前窗口是否满足条件
            while (maxDeque.peekFirst() - minDeque.peekFirst() > limit) {
                // 如果左指针指向的元素是队列头部元素，需要移除
                if (nums[left] == maxDeque.peekFirst()) {
                    maxDeque.pollFirst();
                }
                if (nums[left] == minDeque.peekFirst()) {
                    minDeque.pollFirst();
                }
                left++; // 移动左指针
            }
            
            // 更新最大窗口长度
            maxLength = Math.max(maxLength, right - left + 1);
        }
        
        return maxLength;
    }
}
```

### C++实现
```cpp
#include <iostream>
#include <vector>
#include <deque>
using namespace std;

class Solution {
public:
    int longestSubarray(vector<int>& nums, int limit) {
        // 维护当前窗口中的最大值（单调递减队列）
        deque<int> maxDeque;
        // 维护当前窗口中的最小值（单调递增队列）
        deque<int> minDeque;
        
        int left = 0; // 左指针
        int maxLength = 0; // 最大窗口长度
        
        // 移动右指针
        for (int right = 0; right < nums.size(); right++) {
            // 维护最大值队列：移除队列尾部小于当前元素的所有元素
            while (!maxDeque.empty() && maxDeque.back() < nums[right]) {
                maxDeque.pop_back();
            }
            maxDeque.push_back(nums[right]);
            
            // 维护最小值队列：移除队列尾部大于当前元素的所有元素
            while (!minDeque.empty() && minDeque.back() > nums[right]) {
                minDeque.pop_back();
            }
            minDeque.push_back(nums[right]);
            
            // 检查当前窗口是否满足条件
            while (maxDeque.front() - minDeque.front() > limit) {
                // 如果左指针指向的元素是队列头部元素，需要移除
                if (nums[left] == maxDeque.front()) {
                    maxDeque.pop_front();
                }
                if (nums[left] == minDeque.front()) {
                    minDeque.pop_front();
                }
                left++; // 移动左指针
            }
            
            // 更新最大窗口长度
            maxLength = max(maxLength, right - left + 1);
        }
        
        return maxLength;
    }
};
```

### Python实现
```python
from collections import deque

class Solution:
    def longestSubarray(self, nums, limit):
        # 维护当前窗口中的最大值（单调递减队列）
        max_deque = deque()
        # 维护当前窗口中的最小值（单调递增队列）
        min_deque = deque()
        
        left = 0  # 左指针
        max_length = 0  # 最大窗口长度
        
        # 移动右指针
        for right in range(len(nums)):
            # 维护最大值队列：移除队列尾部小于当前元素的所有元素
            while max_deque and max_deque[-1] < nums[right]:
                max_deque.pop()
            max_deque.append(nums[right])
            
            # 维护最小值队列：移除队列尾部大于当前元素的所有元素
            while min_deque and min_deque[-1] > nums[right]:
                min_deque.pop()
            min_deque.append(nums[right])
            
            # 检查当前窗口是否满足条件
            while max_deque[0] - min_deque[0] > limit:
                # 如果左指针指向的元素是队列头部元素，需要移除
                if nums[left] == max_deque[0]:
                    max_deque.popleft()
                if nums[left] == min_deque[0]:
                    min_deque.popleft()
                left += 1  # 移动左指针
            
            # 更新最大窗口长度
            max_length = max(max_length, right - left + 1)
        
        return max_length
```

## 题目：LeetCode 1499 满足不等式的最大值

### 题目来源
LeetCode 1499. 满足不等式的最大值

### 题目内容
给你一个数组 points 和一个整数 k 。数组中每个元素都表示二维平面上的点的坐标，并按照 x 坐标排序。也就是说 points[i] = [xi, yi] ，并且在 1 <= i < j <= points.length 的情况下， xi < xj 总成立。

请你找出 yi + yj + |xi - xj| 的最大值，其中 |xi - xj| <= k 且 1 <= i < j <= points.length。

你可以假设对于所有的 i ， yi 都是整数，并且存在 j > i 使得 |xi - xj| <= k 。

示例 1：
输入：points = [[1,3],[2,0],[5,10],[6,-10]], k = 1
输出：4
解释：前两个点满足 |xi - xj| <= 1 ，代入方程计算，则得到 3 + 0 + |1 - 2| = 4 。第三个和第四个点也满足条件，得到 10 + (-10) + |5 - 6| = 1 。所以答案就是 4 。

示例 2：
输入：points = [[0,0],[3,0],[9,2]], k = 3
输出：3
解释：只有前两个点满足 |xi - xj| <= 3 ，代入方程得到 0 + 0 + |0 - 3| = 3 。

### 网址
https://leetcode-cn.com/problems/max-value-of-equation/

### 解题思路
这道题可以转化为单调队列优化问题：

首先，由于点是按照x坐标排序的，所以对于i < j，有xi < xj，因此|xi - xj| = xj - xi。

我们可以将目标函数yi + yj + |xi - xj|转化为：(yj + xj) + (yi - xi)

问题转化为：对于每个j，我们需要找到i满足j - i <= k且xj - xi <= k（由于x排序，这等价于xj - xi <= k），使得(yi - xi)最大。

使用单调队列来维护可能的i值，队列中的元素按照(yi - xi)单调递减排序。

### 时间复杂度分析
- 时间复杂度：O(n)，每个点最多被加入和弹出队列各一次
- 空间复杂度：O(n)，用于存储单调队列

### 是否最优解
是最优解，使用单调队列将时间复杂度从O(n^2)降低到O(n)。

### Java实现
```java
import java.util.*;

public class MaxValueOfEquation {
    public int findMaxValueOfEquation(int[][] points, int k) {
        // 单调队列，存储的是索引，按照(yi - xi)单调递减排序
        Deque<Integer> deque = new LinkedList<>();
        int maxValue = Integer.MIN_VALUE;
        
        for (int j = 0; j < points.length; j++) {
            int xj = points[j][0];
            int yj = points[j][1];
            
            // 移除不满足xj - xi <= k的元素
            while (!deque.isEmpty() && xj - points[deque.peekFirst()][0] > k) {
                deque.pollFirst();
            }
            
            // 如果队列不为空，计算当前的最大值
            if (!deque.isEmpty()) {
                int i = deque.peekFirst();
                maxValue = Math.max(maxValue, (yj + xj) + (points[i][1] - points[i][0]));
            }
            
            // 维护队列的单调性，移除队列尾部(yi - xi)小于等于当前(yj - xj)的元素
            while (!deque.isEmpty() && (points[j][1] - xj) >= (points[deque.peekLast()][1] - points[deque.peekLast()][0])) {
                deque.pollLast();
            }
            
            deque.offerLast(j);
        }
        
        return maxValue;
    }
}
```

### C++实现
```cpp
#include <iostream>
#include <vector>
#include <deque>
#include <climits>
using namespace std;

class Solution {
public:
    int findMaxValueOfEquation(vector<vector<int>>& points, int k) {
        // 单调队列，存储的是索引，按照(yi - xi)单调递减排序
        deque<int> deque;
        int maxValue = INT_MIN;
        
        for (int j = 0; j < points.size(); j++) {
            int xj = points[j][0];
            int yj = points[j][1];
            
            // 移除不满足xj - xi <= k的元素
            while (!deque.empty() && xj - points[deque.front()][0] > k) {
                deque.pop_front();
            }
            
            // 如果队列不为空，计算当前的最大值
            if (!deque.empty()) {
                int i = deque.front();
                maxValue = max(maxValue, (yj + xj) + (points[i][1] - points[i][0]));
            }
            
            // 维护队列的单调性，移除队列尾部(yi - xi)小于等于当前(yj - xj)的元素
            while (!deque.empty() && (points[j][1] - xj) >= (points[deque.back()][1] - points[deque.back()][0])) {
                deque.pop_back();
            }
            
            deque.push_back(j);
        }
        
        return maxValue;
    }
};
```

### Python实现
```python
from collections import deque

class Solution:
    def findMaxValueOfEquation(self, points, k):
        # 单调队列，存储的是索引，按照(yi - xi)单调递减排序
        dq = deque()
        max_value = float('-inf')
        
        for j in range(len(points)):
            xj, yj = points[j]
            
            # 移除不满足xj - xi <= k的元素
            while dq and xj - points[dq[0]][0] > k:
                dq.popleft()
            
            # 如果队列不为空，计算当前的最大值
            if dq:
                i = dq[0]
                max_value = max(max_value, (yj + xj) + (points[i][1] - points[i][0]))
            
            # 维护队列的单调性，移除队列尾部(yi - xi)小于等于当前(yj - xj)的元素
            while dq and (yj - xj) >= (points[dq[-1]][1] - points[dq[-1]][0]):
                dq.pop()
            
            dq.append(j)
        
        return max_value