# 跳跃游戏VI
# 给你一个下标从 0 开始的整数数组 nums 和一个整数 k 。
# 一开始你在下标 0 处。每一步，你最多可以往前跳 k 步，但你不能跳出数组的边界。
# 也就是说，你可以从下标 i 跳到 [i + 1, min(n - 1, i + k)] 包含两个端点的任意位置。
# 你的目标是到达数组最后一个位置（下标为 n - 1），你的得分为经过的所有数字之和。
# 返回你能得到的最大得分。
# 1 <= nums.length, k <= 10^5
# -10^4 <= nums[i] <= 10^4
# 测试链接 : https://leetcode.cn/problems/jump-game-vi/
# 提交以下的code，提交时请把类名改成"Main"，可以通过所有用例

from collections import deque

def jumpGameVI(nums, k):
    """
    使用单调队列优化的动态规划解法
    
    Args:
        nums: List[int] - 整数数组
        k: int - 最大跳跃步数
    
    Returns:
        int - 能得到的最大得分
    
    时间复杂度：O(n)，每个元素最多入队和出队一次
    空间复杂度：O(n)，dp数组和单调队列的空间
    """
    n = len(nums)
    if n == 1:
        return nums[0]
    
    # dp[i]表示到达位置i能获得的最大得分
    dp = [0] * n
    # 初始状态：在位置0，得分为nums[0]
    dp[0] = nums[0]
    
    # 使用单调递减双端队列，存储下标
    # 队首始终是窗口内的最大dp值对应的下标
    queue = deque([0])
    
    # 从位置1开始计算每个位置的最大得分
    for i in range(1, n):
        # 移除队列中超出跳跃范围的元素
        # 当前位置i最多能从i-k位置跳过来
        while queue and queue[0] < i - k:
            queue.popleft()
        
        # 状态转移：dp[i] = max{dp[j]} + nums[i]，其中j在[i-k, i-1]范围内
        dp[i] = dp[queue[0]] + nums[i]
        
        # 维护队列单调性，移除所有小于等于当前dp值的队尾元素
        # 因为如果dp[j] <= dp[i]，那么j永远不可能成为后续位置的最优选择
        while queue and dp[queue[-1]] <= dp[i]:
            queue.pop()
        
        # 将当前位置加入队列
        queue.append(i)
    
    # 返回到达最后一个位置的最大得分
    return dp[n - 1]

# 读取输入并调用函数
if __name__ == "__main__":
    # 读取n和k
    n, k = map(int, input().split())
    # 读取nums数组
    nums = list(map(int, input().split()))
    # 计算并输出结果
    result = jumpGameVI(nums, k)
    print(result)

"""
算法思路详解：

1. 问题分析：
   - 这是一个典型的动态规划问题
   - 状态定义：dp[i]表示到达位置i能获得的最大得分
   - 状态转移方程：dp[i] = max{dp[j]} + nums[i]，其中j ∈ [max(0, i-k), i-1]
   - 目标：求dp[n-1]

2. 朴素解法：
   - 时间复杂度：O(n*k)，对于每个位置i，需要遍历前面k个位置找最大值
   - 空间复杂度：O(n)
   - 对于k较大时会超时

3. 单调队列优化：
   - 观察状态转移方程，我们需要在滑动窗口[max(0, i-k), i-1]中找到dp的最大值
   - 这正是单调队列的经典应用场景
   - 使用单调递减队列，队首始终是窗口内的最大dp值

4. 队列维护策略：
   - 队列存储下标，按照dp值单调递减排列
   - 队首元素：窗口内的最大dp值对应的下标
   - 队尾维护：移除所有dp值小于等于当前dp[i]的元素
   - 有效性维护：移除超出跳跃范围的队首元素

5. 时间复杂度分析：
   - 每个元素最多入队和出队一次，均摊时间复杂度O(1)
   - 总时间复杂度：O(n)
   - 空间复杂度：O(n)

6. 边界情况处理：
   - 当i < k时，可以从位置0跳过来
   - 当i >= k时，只能从[i-k, i-1]范围内跳过来
   - 初始状态dp[0] = nums[0]
   - n=1时，直接返回nums[0]

7. 为什么是最优解：
   - 该解法将朴素DP的O(n*k)优化到O(n)
   - 利用单调队列维护滑动窗口最值，是此类问题的最优解法
   - 无法进一步优化时间复杂度，因为需要处理每个位置至少一次

8. 工程化考量：
   - 使用collections.deque实现双端队列，性能较好
   - 代码结构清晰，注释详细
   - 函数式编程风格，易于测试和复用

9. 极端场景分析：
   - n=1时，直接返回nums[0]
   - k=1时，只能一步步跳，退化为前缀和
   - nums全为负数时，仍能正确找到最大得分路径
   - k>=n-1时，第一步就能跳到最后，但仍需考虑中间路径

10. 语言特性差异：
    - Python: 使用collections.deque实现双端队列
    - Java: 使用ArrayDeque实现双端队列
    - C++: 使用数组模拟队列，性能最优
"""