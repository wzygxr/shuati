#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

// 送箱子到码头的最少行程数
// 一共有m个码头，编号1 ~ m， 给定长度为n的二维数组boxes
// boxes[i][0]表示i号箱子要送往的码头，boxes[i][1]表示i号箱子重量
// 有一辆马车，一次最多能装a个箱子并且箱子总重量不能超过b
// 马车一开始在仓库，可以在0位置，马车每开动一次，认为行程+1
// 箱子必须按照boxes规定的顺序被放上马车，也必须按照顺序被送往各自的码头
// 马车上相邻的箱子如果去往同一个码头，那么认为共享同一趟行程
// 马车可能经过多次送货，每次装货需要回到仓库，认为行程+1，送完所有的货，最终要回到仓库，行程+1
// 返回至少需要几个行程能把所有的货都送完
// 所有数据的范围 <= 10^5
// 测试链接 : https://leetcode.cn/problems/delivering-boxes-from-storage-to-ports/

/**
 * 送箱子到码头的最少行程数问题 - 滑动窗口优化解法
 * 
 * 算法思路详解：
 * 1. 问题分析：
 *    - 需要将箱子按顺序送到指定码头，马车有容量和重量限制
 *    - 相邻的去往同一码头的箱子可以共享行程
 *    - 目标是找到最少的行程数
 *    
 * 2. 优化思路：
 *    - 使用动态规划结合滑动窗口优化
 *    - 维护当前窗口的货物范围和行程信息
 *    - 通过窗口调整找到最优的分割点
 *    
 * 3. 时间复杂度分析：
 *    - 时间复杂度：O(n)，每个箱子最多被处理两次（进入和离开窗口）
 *    - 空间复杂度：O(n)，dp数组的空间
 *    
 * 4. 为什么是最优解：
 *    - 该解法利用滑动窗口将复杂度优化到O(n)
 *    - 是此类问题的最优解法
 */
class Code08_DeliveringBoxes {
public:
    /**
     * 计算送箱子到码头的最少行程数
     * 使用滑动窗口优化的动态规划解法
     * 
     * @param boxes 箱子信息数组，boxes[i][0]表示码头，boxes[i][1]表示重量
     * @param m 码头数量
     * @param a 马车最大箱子数
     * @param b 马车最大重量
     * @return 最少行程数
     */
    static int boxDelivering(vector<vector<int>>& boxes, int m, int a, int b) {
        int n = boxes.size();
        if (n == 0) return 0;
        
        // dp[i] : 马车拉完前i个货物并回仓库，需要的最少行程
        // 注意这里的i是指个数，对应的货物是boxes[0...i-1]
        vector<int> dp(n + 1, 0);
        dp[1] = 2;  // 第一个箱子：去仓库+送货+回仓库 = 2次行程
        
        // 马车最后一趟的货物范围[l...r]
        // 最后一趟货物的总重量weight，最后一趟需要的行程trip
        int weight = boxes[0][1];
        int trip = 2;  // 初始行程：去仓库+送货+回仓库
        
        // 滑动窗口：l表示窗口左边界，r表示窗口右边界
        int l = 0;
        for (int r = 1; r < n; r++) {
            // 将第r个箱子加入当前窗口
            weight += boxes[r][1];
            // 如果当前箱子与前一个箱子去往不同码头，行程+1
            if (boxes[r][0] != boxes[r - 1][0]) {
                trip++;
            }
            
            // 调整窗口左边界，确保满足约束条件
            // 1) 最后一趟货物的个数超了，最后一趟不得不减少货物
            // 2) 最后一趟货物的总重量超了，最后一趟不得不减少货物
            // 3) 最后一趟最左侧的货，分给之前的过程，如果发现之前过程的dp值没变化，那就分出去
            while (r - l + 1 > a || weight > b || (l < n && dp[l] == dp[l + 1])) {
                // 移除左边界箱子
                weight -= boxes[l][1];
                l++;
                // 如果移除后左边界箱子与前一个箱子去往不同码头，行程-1
                if (l < n && l > 0 && boxes[l][0] != boxes[l - 1][0]) {
                    trip--;
                }
            }
            
            // 更新dp值：前l个箱子的最少行程 + 当前窗口的行程
            dp[r + 1] = dp[l] + trip;
        }
        
        return dp[n];
    }
    
    /*
     * 算法详细解释：
     * 
     * 1. 核心思想：
     *    - 使用动态规划记录前i个箱子的最少行程
     *    - 通过滑动窗口维护当前最优的货物分割点
     *    - 利用贪心思想调整窗口边界
     *    
     * 2. 滑动窗口的作用：
     *    - 维护当前考虑的最后一趟送货的货物范围
     *    - 动态调整窗口大小以满足约束条件
     *    - 找到最优的分割点使得总行程最少
     *    
     * 3. 行程计算原理：
     *    - 初始行程：去仓库装货 = 1次
     *    - 送货行程：相邻的去往同一码头的箱子共享行程
     *    - 结束行程：回仓库 = 1次
     *    - 总行程 = 去仓库 + 送货行程 + 回仓库
     *    
     * 4. 窗口调整策略：
     *    - 当货物数量超过马车容量时，缩小窗口
     *    - 当货物重量超过马车载重时，缩小窗口
     *    - 当分割点可以优化时（dp[l] == dp[l+1]），缩小窗口
     *    
     * 5. 时间复杂度证明：
     *    - 每个箱子最多进入窗口一次、离开窗口一次
     *    - 每次操作都是O(1)时间
     *    - 总时间复杂度O(n)
     *    
     * 6. 空间复杂度分析：
     *    - dp数组：O(n)
     *    - 其他变量：O(1)
     *    - 总空间复杂度O(n)
     *    
     * 7. 为什么这是最优解：
     *    - 问题本身需要找到最优分割点，朴素解法O(n²)
     *    - 该解法利用滑动窗口将复杂度降到O(n)
     *    - 无法进一步优化，因为需要处理每个箱子
     *    
     * 8. 工程化考量：
     *    - 使用vector而非链表提高性能
     *    - 及时更新变量避免重复计算
     *    - 考虑边界情况（空数组、单个箱子等）
     *    
     * 9. 边界情况处理：
     *    - 空箱子数组：返回0
     *    - 单个箱子：行程固定为2
     *    - 所有箱子去往同一码头：行程优化
     *    - 极端重量：及时调整窗口
     *    
     * 10. 语言特性差异：
     *     - C++: 使用vector，需要手动管理内存
     *     - Java: 使用数组，有垃圾回收机制
     *     - Python: 使用列表，动态类型
     */
};

// 测试函数
int main() {
    Code08_DeliveringBoxes solution;
    
    // 测试用例1
    vector<vector<int>> boxes1 = {{1, 1}, {2, 1}, {1, 1}};
    int result1 = solution.boxDelivering(boxes1, 2, 3, 3);
    cout << "测试用例1结果: " << result1 << endl;  // 期望输出: 4
    
    // 测试用例2
    vector<vector<int>> boxes2 = {{1, 2}, {3, 3}, {3, 1}, {3, 1}, {3, 3}};
    int result2 = solution.boxDelivering(boxes2, 3, 3, 6);
    cout << "测试用例2结果: " << result2 << endl;  // 期望输出: 6
    
    // 测试用例3：边界情况，空数组
    vector<vector<int>> boxes3 = {};
    int result3 = solution.boxDelivering(boxes3, 0, 0, 0);
    cout << "测试用例3结果: " << result3 << endl;  // 期望输出: 0
    
    // 测试用例4：单个箱子
    vector<vector<int>> boxes4 = {{1, 5}};
    int result4 = solution.boxDelivering(boxes4, 1, 1, 10);
    cout << "测试用例4结果: " << result4 << endl;  // 期望输出: 2
    
    return 0;
}