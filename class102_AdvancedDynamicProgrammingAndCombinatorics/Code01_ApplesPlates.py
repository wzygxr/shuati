# 苹果和盘子（球盒模型）
# 有m个苹果，认为苹果之间无差别，有n个盘子，认为盘子之间无差别
# 比如5个苹果如果放进3个盘子，那么(1, 3, 1) (1, 1, 3) (3, 1, 1)认为是同一种方法
# 允许有些盘子是空的，返回有多少种放置方法
# 
# 算法思路：
# 这是一个经典的组合数学问题，属于球盒模型（n个相同的球放入m个相同的盒子）
# 使用动态规划解决，状态定义为f(m, n)表示m个苹果放入n个盘子的方法数
# 状态转移方程：
# 1. 当n > m时，f(m, n) = f(m, m)（盘子比苹果多时，多余的盘子无意义）
# 2. 当n <= m时，f(m, n) = f(m, n-1) + f(m-n, n)
#    - f(m, n-1)：至少有一个盘子为空的情况
#    - f(m-n, n)：所有盘子都不为空的情况（每个盘子先放一个苹果）
#
# 边界条件：
# 1. f(0, n) = 1（0个苹果放入任意多个盘子只有1种方法：都不放）
# 2. f(m, 0) = 0（有苹果但没有盘子，无法放置）
#
# 时间复杂度：O(m*n)
# 空间复杂度：O(m*n)
# 
# 测试链接 : https://www.nowcoder.com/practice/bfd8234bb5e84be0b493656e390bdebf

# 注意：该问题属于整数分拆的一种特殊情况，与整数分拆的区别是这里不考虑顺序
# 例如，将5分成3个部分的分拆方式，但要求每个部分可以为0（相当于允许空盘子）
# 实际上，这等价于将m个苹果分拆成最多n个非递增的正整数之和（加上空盘子）

# 整数分拆在组合数学中有重要应用，涉及到生成函数、递推关系和Partition函数
# 该问题的动态规划解法可以扩展到更一般的整数分拆问题，例如不允许空盘子、限制每个盘子最多放k个苹果等

# 记忆化搜索是动态规划的一种实现方式，特别适合这类状态转移关系清晰、有大量重复子问题的情况
# 相比迭代方式，记忆化搜索实现更直观，但在Python中对于大规模数据可能会有栈溢出的风险

# 对于m和n较大的情况，可以考虑使用迭代的动态规划实现，或者优化递归深度
# 此外，还可以使用滚动数组优化空间复杂度至O(min(m, n))

# 该问题的另一种思考方式是：将问题转化为整数m的最多n个部分的分拆数
# 这与著名的Partition函数相关，但这里有最多n个部分的限制

# 相关数学公式：
# 整数分拆的生成函数为：P(x) = Π(1/(1 - x^k)) ，其中k从1到∞
# 但对于有限个部分的情况，生成函数为：P(x, n) = Π(1/(1 - x^k)) ，其中k从1到n

# 在实际应用中，该问题可以模拟：
# - 资源分配问题（相同资源分配到相同的容器中）
# - 组合计数问题（统计不同的组合方式）
# - 库存分配问题（相同商品分配到相同的仓库）

# 输入输出示例：
# 输入：7 3
# 输出：8
# 解释：有7个苹果，3个盘子，放置方法有：
# (0, 0, 7), (0, 1, 6), (0, 2, 5), (0, 3, 4), (1, 1, 5), (1, 2, 4), (1, 3, 3), (2, 2, 3)
# 注意：因为盘子无差别，所以顺序不同视为同一种方法

import sys

# 全局DP数组
MAXM = 11
MAXN = 11
dp = [[-1 for _ in range(MAXN)] for _ in range(MAXM)]

def f(m, n):
    """
    动态规划核心函数
    
    Args:
        m (int): 苹果数量
        n (int): 盘子数量
    
    Returns:
        int: 放置方法数
    """
    # 边界条件1：没有苹果，只有一种方法（都不放）
    if m == 0:
        return 1
    # 边界条件2：没有盘子，无法放置
    if n == 0:
        return 0
    # 记忆化搜索，避免重复计算
    if dp[m][n] != -1:
        return dp[m][n]
    
    # 如果盘子数大于苹果数，则多余的盘子无意义
    if n > m:
        ans = f(m, m)
    else:
        # 状态转移方程：
        # f(m, n-1)：至少有一个盘子为空的情况
        # f(m-n, n)：所有盘子都不为空的情况（每个盘子先放一个苹果）
        ans = f(m, n - 1) + f(m - n, n)
    
    dp[m][n] = ans
    return ans

def compute(m, n):
    """
    计算m个苹果放入n个盘子的方法数
    
    Args:
        m (int): 苹果数量
        n (int): 盘子数量
    
    Returns:
        int: 放置方法数
    
    时间复杂度：O(m*n)
    空间复杂度：O(m*n)
    
    算法优化说明：
    1. 使用记忆化搜索避免重复计算子问题
    2. 对于大规模输入，可考虑使用迭代方式的动态规划
    3. 空间优化：可以只保留两行或两列来更新状态，将空间复杂度降至O(min(m, n))
    """
    # 初始化dp数组，-1表示未计算
    global dp
    for i in range(m + 1):
        for j in range(n + 1):
            dp[i][j] = -1
    return f(m, n)

# 测试用例设计
# 1. 基本情况：m=0, n=任意值 -> 1
# 2. 基本情况：n=0, m>0 -> 0
# 3. 特殊情况：m=n -> 1（每个盘子放一个苹果）
# 4. 特殊情况：n=1 -> 1（所有苹果放在一个盘子）
# 5. 一般情况：m=7, n=3 -> 8
# 6. 一般情况：m=5, n=3 -> 5
# 7. 边界情况：m=10, n=10 -> 42

# 类似题目与训练拓展：
# 1. LeetCode 343 - Integer Break
#    链接：https://leetcode.cn/problems/integer-break/
#    区别：将整数拆分为至少两个正整数的和，求乘积的最大值
#    算法：动态规划或数学推导
#
# 2. LeetCode 279 - Perfect Squares
#    链接：https://leetcode.cn/problems/perfect-squares/
#    区别：求将整数n表示为完全平方数之和的最少项数
#    算法：BFS或动态规划
#
# 3. LeetCode 322 - Coin Change
#    链接：https://leetcode.cn/problems/coin-change/
#    区别：求用最少的硬币数量组成指定金额
#    算法：动态规划或BFS
#
# 4. LeetCode 518 - Coin Change II
#    链接：https://leetcode.cn/problems/coin-change-ii/
#    区别：求用不同面额硬币组成指定金额的组合数
#    算法：动态规划
#
# 5. 牛客网 NC104 - 求正数数组的最小不可组成和
#    链接：https://www.nowcoder.com/practice/3350d379a5d44054b219de7af6708894
#    区别：求数组中无法组成的最小正整数和
#    算法：贪心或动态规划
#
# 6. Codeforces 460B - Little Dima and Equation
#    链接：https://codeforces.com/problemset/problem/460/B
#    区别：解方程问题，涉及数字位数和
#    算法：数学分析
#
# 7. 洛谷 P1025 - 数的划分
#    链接：https://www.luogu.com.cn/problem/P1025
#    区别：将整数划分为k个正整数的和，顺序不同视为同一种方法
#    算法：动态规划
#
# 8. 牛客网 NC14138 - 整数分拆
#    链接：https://www.nowcoder.com/practice/38b6d26b18bf49bc9fae3a3e2322a471
#    区别：将整数分拆成若干个不同的正整数之和
#    算法：动态规划
#
# 9. 牛客网 NC16313 - 分巧克力
#    链接：https://www.nowcoder.com/practice/351192348a6746d98a23a91155529fca
#    区别：二分答案+贪心策略
#    算法：二分查找
#
# 10. 牛客网 NC16531 - 硬币面值组合
#     链接：https://www.nowcoder.com/practice/2b7995aa4f7949d99674d975489cb7da
#     区别：求硬币面值组合的方式数，允许无限使用每个面值
#     算法：动态规划
#
# 11. 牛客网 NC16745 - 最少砝码
#     链接：https://www.nowcoder.com/practice/e3531a87aedf4d2aacb370396f4f0845
#     区别：求最少砝码数量使能称量1到N的所有重量
#     算法：数学分析
#
# 12. 牛客网 NC17583 - 分割数组的方案数
#     链接：https://www.nowcoder.com/practice/16b21975862345a298a6c7b3f1b2516f
#     区别：将数组分割为k个非空连续子数组
#     算法：动态规划
#
# 13. HDU 1028 - Ignatius and the Princess III
#     链接：http://acm.hdu.edu.cn/showproblem.php?pid=1028
#     区别：整数分拆问题，求分拆方式数
#     算法：动态规划
#
# 14. Codeforces 1132E - Knapsack
#     链接：https://codeforces.com/problemset/problem/1132/E
#     区别：优化的背包问题，物品重量很大但种类少
#     算法：分治优化的背包问题
#
# 15. 牛客网 NC19153 - 砝码称重
#     链接：https://www.nowcoder.com/practice/67984bd528844622b4b85562269dc706
#     区别：求不同砝码组合可以称量的重量数
#     算法：动态规划或位运算

# 算法本质与技巧总结：
#
# 1. 整数分拆思想：
#    - 本问题是整数分拆的一个特例，不考虑顺序且允许空盘子
#    - 整数分拆在组合数学中有重要应用，涉及到生成函数等高级概念
#
# 2. 动态规划的状态定义：
#    - 状态定义要清晰，能够准确描述子问题
#    - 本题的状态f(m, n)定义为m个苹果放入n个盘子的方法数
#    - 状态定义的好坏直接影响动态规划的复杂度和实现难度
#
# 3. 状态转移方程的推导：
#    - 通过将问题分解为互斥且完备的子问题来推导转移方程
#    - 本题通过是否允许空盘子将问题分为两种情况
#    - 转移方程的推导需要深入理解问题的性质
#
# 4. 边界条件的处理：
#    - 边界条件是动态规划的基础，需要仔细考虑所有特殊情况
#    - 本题的边界条件包括没有苹果或没有盘子的情况
#
# 5. 记忆化搜索的实现：
#    - 记忆化搜索是动态规划的递归实现方式
#    - 可以避免重复计算子问题，提高效率
#    - 在Python中需要注意递归深度的限制
#
# 6. 空间优化技巧：
#    - 对于某些动态规划问题，可以使用滚动数组优化空间复杂度
#    - 本题可以将空间复杂度从O(m*n)优化到O(min(m, n))

# Python工程化实战建议：
#
# 1. 代码结构优化：
#    - 将全局变量改为函数内部变量，提高代码的可维护性
#    - 使用类封装相关功能，更好地组织代码
#    - 考虑使用装饰器（如lru_cache）来简化记忆化搜索的实现
#
# 2. 输入输出处理：
#    - 对于大规模数据，可以使用sys.stdin.read()一次性读取所有输入
#    - 使用生成器表达式或列表推导式处理批量输入
#    - 考虑添加输入验证和错误处理
#
# 3. 性能优化策略：
#    - 对于大规模输入，考虑使用迭代版的动态规划而不是递归
#    - 使用预计算的方式处理多个查询
#    - 考虑使用numpy等库进行矩阵运算，提高效率
#
# 4. 代码健壮性提升：
#    - 添加输入参数检查，确保m和n为非负整数
#    - 处理可能的边界情况，如m=0或n=0
#    - 添加日志记录关键步骤，便于调试
#
# 5. Python特有优化技巧：
#    - 使用functools.lru_cache装饰器实现自动记忆化
#    - 使用默认参数避免重复创建dp数组
#    - 对于小规模问题，使用生成器表达式可能比列表推导式更节省内存
#
# 6. 调试与问题定位：
#    - 添加调试信息输出中间计算结果
#    - 使用单元测试验证算法的正确性
#    - 考虑使用pdb进行交互式调试
#
# 7. 跨语言实现对比：
#    - Python实现简洁但在处理大规模数据时可能不如C++高效
#    - 在C++中可以使用数组或vector来实现动态规划
#    - 在Java中需要注意处理可能的栈溢出问题
#
# 8. 算法扩展与应用：
#    - 可以扩展到不允许空盘子的情况
#    - 可以扩展到每个盘子最多放k个苹果的情况
#    - 可以扩展到不同类型的苹果或盘子的情况

# 为了测试
if __name__ == "__main__":
    # 读取输入
    line = sys.stdin.readline().strip()
    m, n = map(int, line.split())
    # 输出结果
    print(compute(m, n))