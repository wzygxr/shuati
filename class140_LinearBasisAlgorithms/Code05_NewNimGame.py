# 新Nim游戏
# 传统的Nim游戏是这样的：有一些火柴堆，每堆都有若干根火柴（不同堆的火柴数量可以不同）
# 两个游戏者轮流操作，每次可以选一个火柴堆拿走若干根火柴。可以只拿一根，也可以拿走整堆火柴，
# 但不能同时从超过一堆火柴中拿。拿走最后一根火柴的游戏者胜利。
# 本题的游戏稍微有些不同：在第一个回合中，双方可以直接拿走若干个整堆的火柴。
# 可以一堆都不拿，但不可以全部拿走。从第二个回合（又轮到第一个游戏者）开始，规则和Nim游戏一样。
# 如果你先拿，怎样才能保证获胜？如果可以获胜的话，还要让第一回合拿的火柴总数尽量小。
# 1 <= k <= 100
# 1 <= a_i <= 10^9
# 测试链接 : https://www.luogu.com.cn/problem/P4301
# 请务必在原有代码基础上增加详细注释，确保代码可以编译运行且没有错误

MAXN = 101
BIT = 31

# 存储火柴堆的数量
arr = [0] * MAXN
# 线性基数组
basis = [0] * (BIT + 1)
# 火柴堆数
k = 0

def insert(num):
    """
    将数字插入线性基
    算法思路：
    1. 从高位到低位扫描
    2. 如果当前位为1且线性基中该位为空，则直接插入
    3. 否则用线性基中该位的数异或当前数，继续处理
    @param num: 要插入的数字
    @return: 如果成功插入返回True，否则返回False
    """
    for i in range(BIT, -1, -1):
        if (num >> i) & 1:
            if basis[i] == 0:
                basis[i] = num
                return True
            num ^= basis[i]
    return False

def compute():
    """
    计算第一回合拿走火柴数目的最小值
    算法思路：
    1. 要保证在第二个回合开始时，剩下的火柴堆异或和不为0
    2. 这等价于选出一些火柴堆，使得剩下的火柴堆线性无关
    3. 为了拿走的火柴总数最小，应该保留尽可能多的火柴堆
    4. 按火柴数量从大到小排序，贪心地构建线性基
    5. 不能插入线性基的火柴堆需要被拿走
    时间复杂度：O(k * BIT * log k)
    空间复杂度：O(BIT)
    @return: 第一回合拿走火柴数目的最小值，如果不能保证取胜返回-1
    """
    # 按火柴数量从大到小排序
    global arr
    arr[1:k+1] = sorted(arr[1:k+1], reverse=True)
    
    # 清空线性基
    for i in range(BIT + 1):
        basis[i] = 0
    
    sum_total = 0  # 总火柴数
    keep = 0       # 保留的火柴数
    
    # 计算总火柴数
    for i in range(1, k + 1):
        sum_total += arr[i]
    
    # 贪心构建线性基
    for i in range(1, k + 1):
        if insert(arr[i]):
            keep += arr[i]
    
    # 如果线性基的大小等于k，说明所有火柴堆线性无关，无法保证获胜
    # 因为对手可以拿走一个火柴堆，使得剩余火柴堆异或和为0
    count = 0
    for i in range(BIT + 1):
        if basis[i] != 0:
            count += 1
    
    if count == k:
        return -1
    
    # 返回拿走的火柴数
    return sum_total - keep

def main():
    """
    主函数
    读取输入数据，调用计算函数，输出结果
    """
    global k
    
    # 读取火柴堆数
    k = int(input())
    
    # 读取各堆火柴数量
    temp = list(map(int, input().split()))
    for i in range(1, k + 1):
        arr[i] = temp[i - 1]
    
    # 计算并输出结果
    print(compute())

if __name__ == "__main__":
    """
    线性基算法详解
    
    线性基（Linear Basis）是一种处理异或问题的重要数据结构，主要用于解决以下几类问题：
    1. 求n个数中选取任意个数异或能得到的最大值
    2. 求n个数中选取任意个数异或能得到的第k小值
    3. 判断一个数是否能由给定数组中的数异或得到
    4. 求能异或得到的数的个数
    
    核心思想
    
    线性基类似于线性代数中的基向量概念，它是一组线性无关的向量集合，
    能够表示原集合中所有数的异或组合。线性基有以下重要性质：
    
    1. 原序列中的任意一个数都可以由线性基中的某些数异或得到
    2. 线性基中的任意一些数异或起来都不能得到0
    3. 在保持性质1的前提下，线性基中的数的个数是最少的
    4. 线性基中每个元素的二进制最高位互不相同
    
    线性基的构建方法
    
    线性基的构建主要有两种方法：普通消元法和高斯消元法。
    
    普通消元法
    
    普通消元法是最常用的构建线性基的方法，其基本思路是：
    
    1. 从最高位开始扫描
    2. 对于每个数，尝试将其插入到线性基中
    3. 插入过程：从高位到低位扫描，如果当前位为1且线性基中该位为空，
       则直接插入；否则用线性基中该位的数异或当前数，继续处理
       
    新Nim游戏解题思路
    
    本题的关键在于理解Nim游戏的获胜条件和线性基的关系：
    
    1. 传统Nim游戏的获胜条件：所有火柴堆异或和不为0时先手必胜，为0时后手必胜
    2. 在新Nim游戏中，第一回合双方都可以拿走整堆火柴
    3. 第二回合开始才是传统Nim游戏
    4. 为了保证获胜，第一回合结束后剩余火柴堆的异或和必须不为0
    5. 这等价于选出一些火柴堆，使得剩下的火柴堆线性相关（即存在非空子集异或和为0）
    6. 为了拿走的火柴总数最小，应该保留尽可能多的火柴堆
    7. 按火柴数量从大到小排序，贪心地构建线性基
    8. 不能插入线性基的火柴堆需要被拿走
    """
    main()