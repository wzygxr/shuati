# 排序算法总结与模式识别

## 🎯 算法选择指南

### 根据数据特性选择算法

| 数据特性 | 推荐算法 | 理由 |
|----------|----------|------|
| 小规模数据 (n ≤ 50) | 插入排序 | 常数项小，实际效率高 |
| 中等规模数据 | 快速排序 | 平均性能最优 |
| 大规模数据 | 归并排序 | 稳定且性能可靠 |
| 内存受限 | 堆排序 | 原地排序，空间复杂度O(1) |
| 需要稳定排序 | 归并排序 | 唯一稳定的O(n log n)算法 |
| 大量重复元素 | 三路快排 | 专门优化重复元素 |
| 数据基本有序 | 插入排序 | 接近O(n)时间复杂度 |
| 数据范围有限 | 计数排序 | O(n + k)线性时间 |
| 数字位数固定 | 基数排序 | O(dn)线性时间 |

### 根据应用场景选择算法

**面试场景**:
- 快速选择算法 (Top K问题)
- 归并排序 (链表排序、逆序对)
- 堆排序 (优先级队列)

**工程应用**:
- 快速排序 (通用排序)
- 计数排序 (小范围整数)
- 基数排序 (大整数排序)

**特殊需求**:
- 稳定排序: 归并排序
- 原地排序: 堆排序、快速排序
- 外部排序: 归并排序

## 💡 解题模式识别

### 模式1: Top K问题
**特征**: 寻找前K大/小元素
**解法选择**:
- K较小: 最小堆 O(n log k)
- K接近n: 快速选择 O(n)
- 需要稳定: 排序后取 O(n log n)

**相关题目**:
- 215. 数组中的第K个最大元素: https://leetcode.cn/problems/kth-largest-element-in-an-array/
- 973. 最接近原点的K个点: https://leetcode.cn/problems/k-closest-points-to-origin/
- 347. 前K个高频元素: https://leetcode.cn/problems/top-k-frequent-elements/

### 模式2: 区间合并
**特征**: 重叠区间合并
**解法**: 按起点排序后合并 O(n log n)

**相关题目**:
- 56. 合并区间: https://leetcode.cn/problems/merge-intervals/
- 986. 区间列表的交集: https://leetcode.cn/problems/interval-list-intersections/

### 模式3: 颜色分类
**特征**: 有限种类排序
**解法**: 多指针法 O(n)

**相关题目**:
- 75. 颜色分类: https://leetcode.cn/problems/sort-colors/
- 280. 摆动排序: https://leetcode.cn/problems/wiggle-sort/

### 模式4: 逆序对统计
**特征**: 统计逆序对数量
**解法**: 归并排序 O(n log n)

**相关题目**:
- 493. 翻转对: https://leetcode.cn/problems/reverse-pairs/
- 面试题51. 数组中的逆序对: https://leetcode.cn/problems/shu-zu-zhong-de-ni-xu-dui-lcof/

## 🔧 工程化考量

### 异常处理策略
```java
public void sort(int[] nums) {
    // 输入验证
    if (nums == null) throw new IllegalArgumentException("数组不能为null");
    if (nums.length <= 1) return;
    
    // 边界检查
    if (nums.length > MAX_SIZE) {
        throw new IllegalArgumentException("数据规模过大");
    }
    
    // 实际排序逻辑
    // ...
}
```

### 性能优化技巧

**快速排序优化**:
1. 随机化基准选择
2. 三路划分处理重复元素
3. 小数组使用插入排序
4. 尾递归优化

**归并排序优化**:
1. 迭代实现避免递归深度
2. 小数组使用插入排序
3. 原地归并减少空间使用

**堆排序优化**:
1. 减少交换次数
2. 使用siftDown优化建堆

### 内存使用优化

**空间优化策略**:
- 优先选择原地排序算法
- 避免不必要的数组拷贝
- 及时释放临时内存

**缓存友好性**:
- 顺序访问模式
- 减少随机内存访问
- 利用局部性原理

## 📊 复杂度分析深度

### 归并排序复杂度推导
```
T(n) = 2T(n/2) + O(n)
     = 2[2T(n/4) + O(n/2)] + O(n)
     = 4T(n/4) + 2O(n/2) + O(n)
     = 4T(n/4) + 2O(n)
     = ...
     = 2^k T(n/2^k) + kO(n)
     
当 n/2^k = 1 => k = log₂n
T(n) = nT(1) + O(n log n) = O(n log n)
```

### 快速排序复杂度分析
**最好情况** (每次划分均衡):
```
T(n) = 2T(n/2) + O(n) = O(n log n)
```

**最坏情况** (每次划分极端不平衡):
```
T(n) = T(n-1) + O(n) = O(n²)
```

**平均情况** (随机化达到O(n log n)):
```
E[T(n)] = O(n log n)
```

### 堆排序复杂度分析
**建堆过程**:
```
T(n) = O(n)  // 线性时间建堆
```

**排序过程**:
```
T(n) = O(n log n)  // 每次调整O(log n)，共n次
```

## 🎓 面试技巧总结

### 算法原理理解
1. **能够白板写出算法**
   - 归并排序的分治思想
   - 快速排序的划分过程
   - 堆排序的建堆和调整

2. **复杂度分析能力**
   - 推导时间复杂度
   - 分析空间复杂度
   - 理解常数项影响

3. **算法比较能力**
   - 各种排序算法的优缺点
   - 适用场景分析
   - 性能对比

### 代码实现要点
1. **清晰的代码结构**
   - 模块化设计
   - 清晰的变量命名
   - 适当的注释

2. **边界条件处理**
   - 空数组
   - 单元素
   - 已排序/逆序
   - 重复元素

3. **异常情况考虑**
   - 输入验证
   - 内存限制
   - 性能退化

### 问题分析能力
1. **快速识别问题类型**
   - Top K问题 → 快速选择/堆排序
   - 区间合并 → 排序+合并
   - 颜色分类 → 多指针法

2. **选择合适的算法**
   - 根据数据规模选择
   - 根据内存限制选择
   - 根据稳定性要求选择

3. **优化策略思考**
   - 常数项优化
   - 空间优化
   - 缓存友好性

## 🚀 进阶学习方向

### 算法理论深入
1. **排序网络理论**
2. **比较排序的下界**
3. **线性时间排序的局限性**

### 工程应用扩展
1. **并行排序算法**
   - 多线程归并排序
   - MapReduce排序

2. **外部排序**
   - 多路归并
   - 败者树优化

3. **数据库排序优化**
   - 索引排序
   - 多字段排序

### 特殊数据类型排序
1. **字符串排序**
   - 字典序排序
   - 后缀数组

2. **对象排序**
   - 多关键字排序
   - 自定义比较器

3. **流数据排序**
   - 在线算法
   - 近似排序

---

**持续学习和实践是掌握排序算法的关键！**