# 01背包问题深度总结

## 一、基本概念

01背包问题是动态规划中的经典问题，描述如下：
- 有N个物品和一个容量为W的背包
- 每个物品有两个属性：重量w[i]和价值v[i]
- 每个物品只能选择一次（0表示不选，1表示选）
- 目标是在不超过背包容量的前提下，使得装入背包的物品价值总和最大

## 二、解题思路

### 1. 状态定义
- dp[i][j] 表示前i个物品，在背包容量为j时能获得的最大价值

### 2. 状态转移方程
```
dp[i][j] = max(dp[i-1][j], dp[i-1][j-w[i]] + v[i])  (当j >= w[i]时)
dp[i][j] = dp[i-1][j]  (当j < w[i]时)
```

### 3. 初始状态
- dp[0][j] = 0 （没有物品时价值为0）
- dp[i][0] = 0 （背包容量为0时价值为0）

### 4. 空间优化
使用滚动数组，倒序遍历背包容量：
```
for (int i = 1; i <= n; i++) {
    for (int j = W; j >= w[i]; j--) {
        dp[j] = max(dp[j], dp[j - w[i]] + v[i]);
    }
}
```

## 三、常见题型及解法

### 1. 经典01背包
**特征**：直接给出物品重量和价值，求最大价值
**解法**：标准01背包模板
**典型题目**：洛谷P1048采药、AtCoder DP Contest D

### 2. 目标和问题
**特征**：给定数组和目标值，通过添加+/-符号使表达式等于目标值
**解法**：转化为01背包，选择一些数使其和为特定值
**公式推导**：设正数和为P，负数和为N，则sum = P + N，target = P - N，解得P = (sum + target) / 2，问题转化为求有多少种方式选出元素和为P
**典型题目**：LeetCode 494. 目标和

### 3. 分割等和子集
**特征**：判断是否能将数组分割成两个和相等的子集
**解法**：转化为01背包，判断是否能装满容量为sum/2的背包
**注意事项**：需要先判断总和是否为偶数
**典型题目**：LeetCode 416. 分割等和子集
  - **解题思路**: 将问题转化为01背包问题，判断是否存在一个子集，其和为数组总和的一半
  - **核心代码**: 使用一维DP数组，dp[j]表示是否可以选择一些元素使其和为j
  - **优化点**: 提前剪枝（判断总和奇偶性、最大值是否超过target）

### 4. 二维费用背包
**特征**：每个物品有两个限制条件（如0和1的个数）
**解法**：使用二维dp数组，dp[i][j][k]表示前i个物品，使用j个0和k个1的最大价值
**空间优化**：可以使用滚动数组优化到O(W1 * W2)
**典型题目**：LeetCode 474. 一和零

### 5. 三维费用背包
**特征**：每个物品有三个限制条件（如人数、利润等）
**解法**：使用三维dp数组，或根据具体问题进行状态设计
**典型题目**：LeetCode 879. 盈利计划

### 6. 多重背包
**特征**：每个物品有指定数量
**解法**：二进制优化转化为01背包
**二进制优化原理**：将数量s分解为2^0, 2^1, ..., 2^k, s-2^{k+1}+1，每个二进制项代表一个物品
**典型题目**：POJ 1276 Cash Machine、牛客NC15411

### 7. 分组背包
**特征**：物品分组，每组只能选一个物品
**解法**：每组内遍历物品，组间使用01背包
**注意遍历顺序**：先遍历组，再遍历容量（逆序），最后遍历组内物品
**典型题目**：HDU 3535 AreYouBusy

### 8. 完全背包
**特征**：每个物品可以选无限次
**解法**：正序遍历背包容量
**与01背包的区别**：01背包逆序遍历，完全背包正序遍历
**典型题目**：LeetCode 322. 零钱兑换、LeetCode 518. 零钱兑换 II

### 9. 背包变形题
**最后一块石头的重量**：转化为最小化两堆石头的重量差
**砝码称重**：转化为正负背包问题
**力矩平衡**：转化为中心对称的背包问题
**概率背包**：使用概率作为价值
**模数背包**：结合模运算的特殊背包问题

### 10. 混合背包
**特征**：同时包含01背包、完全背包、多重背包的元素
**解法**：根据不同类型的物品采用不同的处理方式
**典型题目**：Codeforces 1132E Knapsack

## 四、解题技巧

### 1. 识别01背包特征
- 有"选"或"不选"的决策
- 有容量或资源限制
- 求最优值（最大/最小）
- 每个物品只能使用一次

### 2. 状态设计技巧
- **一维DP**：适用于单约束条件的背包问题
- **二维DP**：适用于双约束条件的背包问题
- **三维DP**：适用于三约束条件的背包问题
- **布尔型DP**：适用于判断可行性问题
- **计数型DP**：适用于求方案数问题

### 3. 转化技巧
- **目标和转背包**：通过数学推导将目标和转化为01背包问题
- **分割等和子集**：转化为容量为sum/2的装满问题
- **最小差值**：转化为容量为sum/2的最接近问题
- **多维限制**：使用多维DP数组处理多个限制条件

### 4. 优化技巧
- **滚动数组**：将二维DP优化为一维DP，节省空间
- **二进制拆分**：将多重背包转化为01背包
- **坐标平移**：处理负数状态，如砝码称重问题
- **初始状态优化**：根据问题特点设置合理的初始状态
- **剪枝**：对不可能达到的状态提前终止计算

### 5. 遍历顺序的重要性
- **01背包**：物品正序，容量逆序
- **完全背包**：物品正序，容量正序
- **分组背包**：组正序，容量逆序，组内物品正序
- **混合背包**：根据物品类型调整容量遍历顺序

### 6. 数学模型建立
- **状态定义**：明确dp数组的含义
- **转移方程**：根据选或不选的决策建立转移关系
- **边界条件**：正确设置初始状态
- **结果提取**：从最终状态中获取答案

## 五、复杂度分析

### 时间复杂度
- **标准01背包**：O(N * W)，其中N是物品数量，W是背包容量
- **二维费用背包**：O(N * W1 * W2)，W1和W2是两个费用维度
- **三维费用背包**：O(N * W1 * W2 * W3)，W1、W2和W3是三个费用维度
- **多重背包（普通）**：O(N * W * s)，s是物品数量上限
- **多重背包（二进制优化）**：O(N * W * log s)
- **分组背包**：O(G * W * K)，G是组数，K是每组的物品数

### 空间复杂度
- **未优化二维DP**：O(N * W)
- **滚动数组优化一维DP**：O(W)
- **二维费用背包**：O(W1 * W2)
- **三维费用背包**：O(W1 * W2 * W3)

### 时间复杂度优化技巧
1. **剪枝优化**：提前过滤不可能达到的状态
2. **状态压缩**：使用位运算等方式优化状态表示
3. **数学优化**：利用问题的数学性质减少计算量
4. **预处理优化**：提前计算某些中间结果

### 空间复杂度优化技巧
1. **滚动数组**：只保留必要的状态
2. **状态压缩**：使用位掩码等方式减少空间占用
3. **原地更新**：在某些情况下可以原地更新DP数组
4. **稀疏矩阵**：对于稀疏状态，可以使用哈希表等数据结构

## 六、边界场景处理

### 1. 空输入处理
- **空数组**：当输入数组为空时，返回合理的默认值（如0或false）
- **零容量**：当背包容量为0时，只能选择0个物品
- **零物品**：当没有物品时，能获得的价值为0

### 2. 极端值处理
- **超大容量**：当背包容量远大于物品总重量时，可以直接返回所有物品的价值和
- **物品重量超过容量**：需要跳过无法放入的物品
- **负数价值/重量**：根据问题描述判断如何处理负数输入
- **零价值/重量**：需要正确处理零值物品

### 3. 特殊数据分布
- **有序数据**：验证算法结果不受数据顺序影响
- **重复数据**：确保算法能正确处理重复的物品
- **极端分布**：如物品重量全部相同、价值全部相同等情况

### 4. 边界条件测试用例
- **最小输入**：n=1, w=1, v=1, capacity=1
- **临界情况**：总和正好为奇数（分割等和子集问题）
- **目标无法达到**：如目标和问题中target无法通过数组元素组合得到
- **全部选中**：所有物品都能放入背包的情况
- **全部无法选中**：所有物品都无法放入背包的情况

## 七、工程化考虑

### 1. 异常处理
- **输入验证**：检查参数合法性，如非负数、空指针等
- **异常抛出**：对非法输入明确抛出异常并提供详细错误信息
- **防御性编程**：使用try-catch或条件检查避免程序崩溃

### 2. 性能优化
- **内存优化**：使用滚动数组减少内存占用
- **计算优化**：避免重复计算，使用预处理技术
- **数据结构选择**：根据实际问题选择合适的数据结构
- **并行计算**：对于大规模数据，考虑并行优化的可能性

### 3. 可配置性
- **参数化设计**：将关键参数提取为可配置项
- **接口设计**：提供清晰的API，支持灵活调用
- **扩展性**：设计时考虑未来可能的扩展需求

### 4. 测试覆盖
- **单元测试**：为核心函数编写全面的单元测试
- **集成测试**：测试完整的调用流程
- **边界测试**：覆盖各种边界情况
- **性能测试**：评估在大数据量下的性能表现

### 5. 代码质量
- **可读性**：使用清晰的命名和注释
- **模块化**：将复杂问题分解为可管理的模块
- **代码复用**：提取公共功能为可复用组件
- **文档完善**：提供详细的使用说明和API文档

## 八、面试要点

### 1. 算法本质理解
- **选择问题本质**：01背包是典型的选择问题，每个物品有选或不选两种状态
- **动态规划思想**：通过状态定义和转移方程，避免重复计算
- **贪心 vs 动态规划**：解释为什么贪心算法不适用（物品不可分割的情况下）

### 2. 状态转移分析
- **状态定义的思考过程**：如何想到定义dp[i][j]表示前i个物品容量为j时的最大价值
- **转移方程推导**：基于选或不选的决策推导出转移方程
- **状态优化思路**：从二维到一维的优化过程和数学证明

### 3. 空间优化原理
- **倒序遍历的必要性**：为什么01背包需要逆序遍历容量
- **滚动数组的工作原理**：如何复用一维数组来存储状态
- **不同背包问题的遍历顺序差异**：01背包vs完全背包的遍历顺序区别

### 4. 变种问题转化能力
- **模型抽象能力**：如何将实际问题抽象为背包模型
- **多维度扩展**：从一维到多维费用的扩展思路
- **目标函数转化**：最大化、最小化、计数、判断可行性等不同目标的处理

### 5. 复杂度分析深度
- **时间复杂度详细计算**：为什么是O(N*W)，常数项的影响
- **空间复杂度优化路径**：从O(N*W)到O(W)的优化过程
- **大数据量处理思路**：当W非常大时的替代算法考虑

### 6. 代码实现细节
- **边界条件处理**：如何正确初始化dp数组
- **数组越界防护**：如何避免数组访问越界
- **效率优化技巧**：如预处理、剪枝等优化手段

### 7. 问题迁移能力
- **相似问题识别**：能够快速识别背包问题的变形题
- **算法迁移应用**：将背包思想应用到新的问题场景
- **跨语言实现差异**：不同编程语言实现时的注意事项

## 九、常见误区

### 1. 遍历顺序错误
- **01背包逆序遍历**：容量必须逆序遍历，否则会导致物品被重复选择
- **完全背包正序遍历**：容量需要正序遍历，允许物品被多次选择
- **分组背包顺序**：组、容量、组内物品的三重循环顺序不能随意调换

### 2. 状态转移方程错误
- **边界条件遗漏**：未考虑物品重量超过当前容量的情况
- **初始化错误**：未正确初始化dp数组，如可行性问题初始化为false
- **转移逻辑错误**：混淆最大/最小/计数等不同类型问题的转移方程

### 3. 空间优化错误
- **滚动数组使用不当**：在多维背包问题中未正确应用滚动数组
- **越界访问**：未检查数组索引的有效性
- **状态覆盖**：在需要保留之前状态时错误地进行了覆盖

### 4. 问题转化错误
- **数学推导错误**：如目标和问题中的公式推导错误
- **条件判断遗漏**：如分割等和子集问题中未检查总和是否为偶数
- **模型抽象偏差**：错误地将问题抽象为不适合的背包模型

### 5. 性能优化误区
- **过度优化**：在不必要的情况下过度追求优化
- **忽略实际约束**：未考虑问题的实际约束条件
- **优化方向错误**：选择了错误的优化方向，如时间换空间还是空间换时间

## 十、扩展应用

### 1. 与机器学习的联系
- **特征选择**：在特征选择中，选择重要特征可以建模为01背包问题
- **模型压缩**：神经网络剪枝可以看作选择重要神经元的背包问题
- **资源分配**：在强化学习中，资源分配问题可以用背包模型解决
- **集成学习**：选择基模型的问题可以转化为背包问题

### 2. 与图像处理的联系
- **图像分割**：能量最小化分割问题可以用背包模型近似
- **特征匹配**：在资源限制下选择最优匹配点的问题
- **压缩感知**：信号重构中的采样点选择问题

### 3. 与自然语言处理的联系
- **文本摘要**：选择重要句子生成摘要的问题
- **关键词提取**：在预算限制下选择最重要的关键词
- **机器翻译**：词汇选择和资源分配问题

### 4. 工程实践应用
- **项目管理**：在时间和资源限制下选择最优项目组合
- **投资组合优化**：在风险约束下选择最优投资组合
- **资源调度**：云计算中的资源分配问题
- **供应链优化**：库存管理和订单选择问题

### 5. 与其他算法的结合
- **背包+图论**：如最短路径中的资源限制问题
- **背包+数论**：模数约束下的背包问题
- **背包+贪心**：混合策略解决复杂优化问题
- **背包+搜索**：在组合优化中的应用

通过系统学习和练习这些01背包问题，可以深入理解动态规划的思想，提高算法设计和问题解决能力。

## 十一、具体问题实现

### 15. LeetCode 416. 分割等和子集
**核心思路**：将问题转化为「01背包」问题，判断是否能从数组中选择一些数字，使其和恰好等于整个数组和的一半。
**实现要点**：使用1D DP数组优化空间，逆序遍历容量避免重复计算。
**时间复杂度**：O(n * target)，其中n是数组长度，target是数组和的一半。
**空间复杂度**：O(target)，使用1D DP数组。

### 16. LeetCode 494. 目标和
**核心思路**：将问题转化为「01背包」问题，通过数学推导，找到和为特定值的子集数目。
**实现要点**：利用sum_pos = (sum + target) / 2将问题转化为统计满足特定和的子集数目。
**时间复杂度**：O(n * target)，其中n是数组长度，target是转换后的目标和。
**空间复杂度**：O(target)，使用1D DP数组。

### 17. LeetCode 474. 一和零
**核心思路**：将问题转化为「二维费用01背包」问题，每个字符串的0和1数量作为两个维度的费用。
**实现要点**：使用二维DP数组，dp[i][j]表示最多使用i个0和j个1时能组成的最大子集长度。
**时间复杂度**：O(l * m * n)，其中l是字符串数组的长度，m和n是背包的两个容量维度。
**空间复杂度**：O(m * n)，使用二维DP数组。

### 18. LeetCode 879. 盈利计划
**核心思路**：将问题转化为「三维费用01背包」问题，分别考虑员工数量、利润要求和工作数量三个维度。
**实现要点**：使用dp[j][k]表示使用j个员工，获得至少k的利润的方案数，通过空间优化减少维度。
**时间复杂度**：O(N * minProfit * n)，其中N是工作数量，n是员工人数，minProfit是最小利润要求。
**空间复杂度**：O(n * minProfit)，使用二维DP数组。



### 19. Code43 零钱兑换 (Coin Change)
**题目链接**: [LeetCode 322. 零钱兑换](https://leetcode.cn/problems/coin-change/)
**题目难度**: Medium
**核心算法**: 动态规划，完全背包问题
**实现语言**: Java, C++, Python (均已完成)
**题目大意**: 给你一个整数数组 coins ，表示不同面额的硬币；以及一个整数 amount ，表示总金额。计算并返回可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1 。
**核心思路**：这是一个典型的完全背包问题，每种硬币可以无限次使用，目标是找出凑成总金额所需的最少硬币个数。
**实现要点**：使用dp[i]表示凑成金额i所需的最少硬币个数，状态转移方程为dp[i] = min(dp[i], dp[i-coin] + 1)，需要正序遍历金额以允许重复使用硬币。
**时间复杂度**：O(amount * n)，其中amount是总金额，n是硬币种类数。
**空间复杂度**：O(amount)，使用一维DP数组。

**扩展方法**:
1. **基础DP方法**：标准的完全背包问题解法
2. **替代遍历顺序**：先遍历金额，再遍历硬币
3. **广度优先搜索(BFS)**：将问题视为图的最短路径问题
4. **贪心+回溯**：通过贪心策略优化回溯过程
5. **记忆化搜索**：优化的回溯方法
6. **优化策略**：提前过滤掉大于amount的硬币，提高效率

### 20. LeetCode 518. 零钱兑换 II
**核心思路**：这是一个完全背包问题的计数变种，目标是计算凑成总金额的硬币组合数，每种硬币可以无限次使用。
**实现要点**：使用dp[i]表示凑成金额i的硬币组合数，通过先遍历硬币再遍历金额来确保计算的是组合数而非排列数。
**时间复杂度**：O(amount * n)，其中amount是总金额，n是硬币种类数。
**空间复杂度**：O(amount)，使用一维DP数组。

### 21. LeetCode 416. 分割等和子集
**核心思路**：将问题转化为01背包问题，判断是否存在一个子集，其和等于数组总和的一半。
**实现要点**：使用dp[i]表示是否可以组成和为i的子集，逆序遍历容量以确保每个元素只使用一次。
**时间复杂度**：O(n * target)，其中n是数组长度，target是数组总和的一半。
**空间复杂度**：O(target)，使用一维DP数组。

### 22. LeetCode 1049. 最后一块石头的重量 II
**核心思路**：将石头分成两堆，使两堆重量尽可能接近，转化为01背包问题，寻找不超过总重量一半的最大子集和。
**实现要点**：使用dp[i]表示是否可以组成和为i的石头堆，最终结果为总重量减去两倍的最大可达到和。
**时间复杂度**：O(n * target)，其中n是石头数量，target是总重量的一半。
**空间复杂度**：O(target)，使用一维DP数组。

### 23. LeetCode 474. 一和零
**核心思路**：这是一个多维背包问题，我们需要同时考虑两种资源限制：0的数量和1的数量。每个字符串相当于一个物品，占用的空间是它包含的0和1的数量，价值为1。
**实现要点**：使用二维dp数组dp[i][j]表示使用i个0和j个1时可以选择的最大字符串数量，通过逆序遍历两个维度避免重复选择同一物品。
**时间复杂度**：O(l * m * n)，其中l是字符串数组的长度，m和n是给定的整数。
**空间复杂度**：O(m * n)，使用二维DP数组。

### 24. LeetCode 377. 组合总和 Ⅳ
**核心思路**：这是一个完全背包问题的排列变种，需要计算总和为目标值的所有排列数，顺序不同的序列视为不同的组合。
**实现要点**：为了计算排列数而非组合数，需要先遍历容量（target）再遍历物品（nums数组），使用dp[i]表示总和为i的元素组合个数。
**时间复杂度**：O(target * n)，其中n是nums数组的长度。
**空间复杂度**：O(target)，使用一维DP数组。

### 25. 单词拆分 (Word Break)
**核心思路**：这是一个完全背包问题的变种，判断是否能用字典中的单词（可重复使用）拼接成目标字符串。
**实现要点**：使用dp[i]表示字符串前i个字符是否可以被拆分，对于每个位置i，检查所有j < i，如果dp[j]为true且子串s[j:i]在字典中，则dp[i] = true。
**时间复杂度**：O(n³)，其中n是字符串长度，因为每次检查子串需要O(n)时间。
**空间复杂度**：O(n)，使用一维DP数组。
**优化技巧**：将字典转换为哈希集合以提高查找效率，可以记录字典中单词的最大长度减少不必要的子串检查。
**其他实现方法**：DFS+记忆化、BFS、Trie树优化

### 26. 零钱兑换 II (Coin Change 2)
**核心思路**：这是一个完全背包问题，计算凑成总金额的硬币组合数，每种硬币可以使用无限次。
**实现要点**：使用dp[i]表示凑成总金额i的硬币组合数，状态转移方程为dp[i] += dp[i - coin]（当i >= coin时）。为了计算组合数而非排列数，需要先遍历硬币再遍历金额。
**时间复杂度**：O(amount * n)，其中amount是总金额，n是硬币种类数。
**空间复杂度**：O(amount)，使用一维DP数组。
**关键技巧**：完全背包问题中，正序遍历容量允许物品被重复使用；先遍历物品再遍历容量确保计算的是组合数而非排列数。

### 27. 目标和 (Target Sum)
**核心思路**：这是一个0-1背包问题的变种，通过添加正负号将问题转化为找一个子集和，使得该子集和与其余元素和的差等于目标值。
**实现要点**：将问题转化为求子集和为(subsetSum)的数目，其中subsetSum = (sum + target) / 2，使用dp[i]表示和为i的子集数目。
**时间复杂度**：O(n * subsetSum)，其中n是数组长度，subsetSum是转化后的目标子集和。
**空间复杂度**：O(subsetSum)，使用一维DP数组。
**关键技巧**：问题转化是关键，需要判断sum + target是否为非负偶数，否则无解。

### 28. 分割等和子集 (Partition Equal Subset Sum)
**核心思路**：这是一个0-1背包问题的经典应用，将原问题转化为是否存在一个子集，其和等于数组总和的一半。
**实现要点**：首先检查数组总和是否为偶数，然后使用dp[i]表示是否可以组成和为i的子集，状态转移方程为dp[i] = dp[i] || dp[i - num]。
**时间复杂度**：O(n * target)，其中n是数组长度，target是数组和的一半。
**空间复杂度**：O(target)，使用一维DP数组。
**关键技巧**：
1. 使用逆序遍历容量来避免重复使用同一个元素
2. 提前剪枝：如果数组总和是奇数或最大元素大于目标和，可以直接返回false
3. 可以使用位运算进一步优化，每个二进制位表示是否可以组成对应索引的和

### 29. 最后一块石头的重量 II (Last Stone Weight II)
**核心思路**：这是一个0-1背包问题的变种，将石头分成两组，使得两组的重量差最小，这样最后剩下的石头重量也会最小。
**实现要点**：将问题转化为找到一组石头，使其和尽可能接近总重量的一半，使用dp[i]表示是否可以组成和为i的子集。
**时间复杂度**：O(n * target)，其中n是石头数量，target是总重量的一半。
**空间复杂度**：O(target)，使用一维DP数组。
**关键技巧**：
1. 最终结果是总重量减去两倍的最大可达子集和
2. 逆序遍历容量确保每个石头只能使用一次
3. 位运算优化可以更高效地表示所有可能的子集和

### 30. 一和零 (Ones and Zeroes)
**核心思路**：这是一个二维费用的0-1背包问题，每个字符串作为物品，其0和1的个数作为两个维度的重量，m和n作为两个维度的背包容量。
**实现要点**：使用dp[i][j]表示最多使用i个0和j个1时，可以组成的最大子集长度，状态转移方程为dp[i][j] = max(dp[i][j], dp[i-zeros][j-ones] + 1)。
**时间复杂度**：O(l * m * n)，其中l是字符串数组的长度，m和n是给定的两个整数。
**空间复杂度**：O(m * n)，使用二维DP数组。
**关键技巧**：
1. 需要逆序遍历两个维度，以确保每个字符串只被选择一次
2. 可以预处理每个字符串的0和1的个数，提高效率
3. 可以提前剪枝，过滤掉那些0或1的个数超过限制的字符串

### 31. 零钱兑换 (Coin Change)
**核心思路**：这是一个典型的完全背包问题，硬币可以重复使用，目标是找到凑成总金额所需的最少硬币个数。
**实现要点**：使用dp[i]表示凑成金额i所需的最少硬币个数，状态转移方程为dp[i] = min(dp[i], dp[i-coin] + 1)，需要正序遍历金额以允许重复使用硬币。
**时间复杂度**：O(amount * n)，其中n是硬币的种类数。
**空间复杂度**：O(amount)，使用一维DP数组。
**关键技巧**：
1. 正序遍历金额（完全背包的特点）
2. 初始化为一个不可能达到的值（如amount + 1）
3. 除了动态规划，还可以使用BFS或贪心+DFS剪枝的方法解决
4. 可以提前排序硬币，在某些情况下进行剪枝优化

### 32. 零钱兑换 II (Coin Change II)
**核心思路**：这是一个完全背包问题的变种，目标不是求最少硬币个数，而是求凑成总金额的不同组合数。
**实现要点**：使用dp[i]表示凑成金额i的不同组合数，状态转移方程为dp[i] += dp[i-coin]，必须将硬币循环放在外层，金额循环放在内层，以避免计算不同顺序的重复组合。
**时间复杂度**：O(amount * n)，其中n是硬币的种类数。
**空间复杂度**：O(amount)，使用一维DP数组。
**关键技巧**：
1. 必须将硬币放在外层循环，金额放在内层循环，以避免计算重复的组合
2. 初始状态dp[0] = 1，表示凑成金额0只有一种方式（不使用任何硬币）
3. 注意整数溢出问题，在C++等语言中可能需要使用long long类型
4. 递归实现需要进行排序并使用剪枝策略，避免重复计算

### 33. 组合总和 IV (Combination Sum IV)
**核心思路**：这是一个与完全背包相关但关注排列而非组合的问题，顺序不同的序列被视为不同的组合。
**实现要点**：使用dp[i]表示凑成目标值i的不同排列数，状态转移方程为dp[i] += dp[i-num]，与零钱兑换II不同的是，这里需要将目标值循环放在外层，数组元素循环放在内层，以考虑不同顺序的排列。
**时间复杂度**：O(target * n)，其中n是数组nums的长度。
**空间复杂度**：O(target)，使用一维DP数组。
**关键技巧**：
1. 必须将目标值放在外层循环，数组元素放在内层循环，以计算所有可能的排列
2. 初始状态dp[0] = 1，表示凑成目标值0只有一种方式（不选择任何数字）
3. 对于较大的target，需要注意整数溢出问题
4. 可以通过排序数组进行剪枝优化，当当前元素大于剩余目标值时提前退出内层循环

### 34. 掷骰子的N种方法 (Number of Dice Rolls With Target Sum)
**核心思路**：这是一个典型的分组背包问题，每个骰子可以看作一组，每组有k个选项（1到k的点数），我们需要从每组中选择一个选项，使得它们的总和等于target。
**实现要点**：使用dp[i][j]表示使用i个骰子能得到点数和为j的方案数，状态转移方程为dp[i][j] = sum(dp[i-1][j-m])，其中m从1到k且j-m >= i-1。可以通过滚动数组优化空间复杂度。
**时间复杂度**：O(n * k * target)，其中n是骰子数量，k是每个骰子的面数。
**空间复杂度**：O(n * target)，优化后为O(target)。
**关键技巧**：
1. 注意边界条件：当target小于n或大于n*k时，直接返回0
2. 初始状态dp[0][0] = 1，表示使用0个骰子得到点数和为0只有一种方式
3. 计算时需要对结果取模10^9+7，避免整数溢出
4. 使用记忆化搜索也可以解决此问题，但动态规划方法更高效

### 35. 最后一块石头的重量 II (Last Stone Weight II)
**核心思路**：这是一个0-1背包问题的变种，目标是将石头分成两组，使得两组的重量差最小。可以转化为寻找一个子集，其总重量尽可能接近总重量的一半。
**实现要点**：使用dp[j]表示是否能组成重量为j的子集，状态转移方程为dp[j] = dp[j] || dp[j - stones[i]]。最后找到最大的j，使得dp[j]为true且j不超过总重量的一半。
**时间复杂度**：O(n * target)，其中n是石头数量，target是总重量的一半。
**空间复杂度**：O(target)，使用一维DP数组。
**关键技巧**：
1. 初始状态dp[0] = true，表示空子集的重量为0是可以组成的
2. 在更新DP数组时需要逆序遍历重量，避免重复使用同一块石头
3. 最终结果为总重量减去两倍的最大子集和
4. 对于较大的输入，可以使用位集合来优化空间，但在实际实现中一维布尔数组更为直观

### 36. 一和零 (Ones and Zeroes)
**核心思路**：这是一个二维费用的0-1背包问题。每个字符串可以看作是一个物品，它有两个费用（0的数量和1的数量），我们的背包有两个容量限制（最多可以使用m个0和n个1），目标是选择尽可能多的物品。
**实现要点**：使用dp[i][j]表示使用i个0和j个1时，最多可以选择的字符串数量。状态转移方程为dp[i][j] = max(dp[i][j], dp[i - zeros][j - ones] + 1)，其中zeros和ones是当前字符串的0和1的数量。
**时间复杂度**：O(l * m * n)，其中l是字符串数组的长度。
**空间复杂度**：O(m * n)，使用二维DP数组。
**关键技巧**：
1. 在更新DP数组时需要逆序遍历两个维度，避免重复使用同一个字符串
2. 可以预先统计所有字符串中0和1的数量，避免重复计算
3. 初始状态时所有dp[i][j]都为0，不需要特别初始化
4. 也可以使用三维DP数组（dp[k][i][j]）表示前k个字符串的状态，更容易理解但空间效率较低

### 37. 分割等和子集 (Partition Equal Subset Sum)
**核心思路**：这是一个0-1背包问题的变种。问题可以转化为是否存在一个子集，其和等于整个数组和的一半。
**实现要点**：使用dp[j]表示是否能组成和为j的子集。状态转移方程为dp[j] = dp[j] || dp[j - nums[i]]。初始状态dp[0] = true，表示空子集的和为0是可以组成的。
**时间复杂度**：O(n * target)，其中n是数组长度，target是数组和的一半。
**空间复杂度**：O(target)，使用一维DP数组。
**关键技巧**：
1. 如果数组总和是奇数，直接返回false，因为无法分成两个和相等的子集
2. 如果数组中最大的数字大于总和的一半，也直接返回false
3. 在更新DP数组时需要逆序遍历，避免重复使用同一个元素
4. 可以使用位操作优化，对于元素值不大的情况效率更高

### 38. 单词拆分 (Word Break)
**核心思路**：这是一个完全背包问题的变种。我们可以将字符串s看作是背包，将字典中的单词看作是物品。问题转化为：是否可以从字典中选择一些单词（可以重复选择），使得它们的拼接恰好等于字符串s。
**实现要点**：使用dp[i]表示字符串s的前i个字符是否可以被拆分成字典中的单词。状态转移方程为对于每个i，我们检查所有j < i，如果dp[j]为true且s.substring(j, i)在字典中，则dp[i]为true。初始状态dp[0] = true，表示空字符串可以被拆分。
**时间复杂度**：O(n^3)，其中n是字符串s的长度。
**空间复杂度**：O(n + m)，其中m是字典中所有单词的字符总数。
**关键技巧**：
1. 将字典转换为哈希集合，提高查找效率
2. 限制j的范围为最大单词长度，避免不必要的检查
3. 可以使用动态规划、递归+记忆化、BFS或前缀树来实现
4. 在动态规划中，只要找到一个可行的拆分方式就可以提前结束内层循环

### 39. 单词拆分 II (Word Break II)
**核心思路**：这是单词拆分的进阶版本，要求返回所有可能的拆分方案。这是一个完全背包问题的变种，同时也是一个组合问题。
**实现要点**：使用递归+记忆化搜索来找出所有可能的拆分方案。对于每个位置i，我们尝试所有可能的单词，如果s.substring(i, j)在字典中，我们递归处理剩余部分，然后将当前单词与剩余部分的结果组合。
**时间复杂度**：O(n^2 * 2^n)，其中n是字符串s的长度。在最坏情况下，每个字符之间都可以拆分，会产生2^(n-1)种拆分方式。
**空间复杂度**：O(n^2)，用于存储记忆化缓存。
**关键技巧**：
1. 先使用动态规划检查字符串是否可以拆分，如果不能拆分直接返回空列表，避免不必要的递归
2. 使用记忆化缓存避免重复计算
3. 限制搜索范围为最大单词长度，避免不必要的检查
4. 可以使用回溯算法或动态规划来实现，存储所有可能的拆分方案

### 40. 完全平方数 (Perfect Squares)
**核心思路**：这是一个完全背包问题。我们可以将问题转化为：使用最少数量的物品（每个物品是一个完全平方数），恰好装满容量为n的背包。
**实现要点**：使用dp[i]表示和为i的完全平方数的最少数量。状态转移方程为dp[i] = min(dp[i], dp[i - j^2] + 1)，其中j^2 <= i。初始状态dp[0] = 0，表示和为0的完全平方数的最少数量为0。
**时间复杂度**：O(n * sqrt(n))，其中n是给定的整数。
**空间复杂度**：O(n)，使用一维DP数组。
**关键技巧**：
1. 预先生成所有可能的完全平方数，避免重复计算
2. 可以使用广度优先搜索(BFS)将问题转化为最短路径问题
3. 利用数学定理（拉格朗日四平方定理）进行优化，最多只需4个平方数
4. 对于DP实现，可以从目标数或完全平方数两个角度考虑状态转移

### 41. 零钱兑换 II (Coin Change II)
**核心思路**：这是一个完全背包问题的变种。我们需要计算使用不同面额的硬币（可以重复使用）恰好凑出总金额的方式数。
**实现要点**：使用dp[j]表示凑成总金额j的硬币组合数。状态转移方程为dp[j] += dp[j - coin]，其中coin是当前硬币的面额。初始状态dp[0] = 1，表示凑成总金额0的方式有一种（不使用任何硬币）。
**时间复杂度**：O(amount * n)，其中amount是总金额，n是硬币的种类数。
**空间复杂度**：O(amount)，使用一维DP数组。
**关键技巧**：
1. 先遍历硬币，再遍历金额，确保计算的是组合数而不是排列数
2. 提前过滤掉大于amount的硬币，优化计算
3. 可以通过回溯或动态规划方法打印出所有可能的组合
4. 在实际应用中，可以使用模运算避免整数溢出

### 42. 目标和 (Target Sum)
**核心思路**：这是一个0-1背包问题的变种。将问题转化为找到一个子集P，使得sum(P) - sum(N) = target，其中N是数组中不在P中的元素。通过数学推导，可以将问题转化为子集和问题。
**实现要点**：计算目标和：sum(P) = (total_sum + target) / 2，然后使用动态规划计算有多少个子集的和等于这个目标值。使用dp[j]表示和为j的子集数目。
**时间复杂度**：O(n * sum)，其中n是数组的长度，sum是数组元素的和。
**空间复杂度**：O(sum)，使用一维DP数组。
**关键技巧**：
1. 使用数学推导将问题转化为标准的子集和问题
2. 注意处理特殊情况（无解的条件判断）
3. 对于包含0的数组可以进行优化
4. 可以使用回溯法、记忆化递归或BFS等多种方法实现