// POJ 1837 Balance
// 题目描述：有一个天平，有两个臂长为15的臂，上面有C个挂钩，位置在-15到15之间。
// 有G个重量不同的砝码，重量在1到25之间。要求将所有砝码都挂在挂钩上，求有多少种方法使天平平衡。
// 链接：http://poj.org/problem?id=1837
// 
// 解题思路：
// 这是一个01背包问题的变形。
// 1. 每个砝码是物品，每个挂钩位置是费用
// 2. 状态定义：dp[i][j] 表示前i个砝码，达到力矩平衡值为j的方法数
// 3. 力矩平衡值的计算：左边为负，右边为正，平衡时总和为0
// 4. 由于力矩可能为负数，需要平移坐标轴，将-7500~7500映射到0~15000
// 5. 状态转移方程：
//    dp[i][j + weight[i] * hook[k]] += dp[i-1][j]
// 6. 初始状态：dp[0][7500] = 1 (平移后的0点)
//
// 时间复杂度：O(G * C * 15000)
// 空间复杂度：O(G * 15000)

#define MAX_SUM 15001
#define OFFSET 7500

/**
 * 计算使天平平衡的方法数
 * 
 * 解题思路：
 * 这是一个01背包问题的变形。
 * 1. 每个砝码是物品，每个挂钩位置是费用
 * 2. 状态定义：dp[i][j] 表示前i个砝码，达到力矩平衡值为j的方法数
 * 3. 力矩平衡值的计算：左边为负，右边为正，平衡时总和为0
 * 4. 由于力矩可能为负数，需要平移坐标轴，将-7500~7500映射到0~15000
 * 5. 状态转移方程：
 *    dp[i][j + weight[i] * hook[k]] += dp[i-1][j]
 * 6. 初始状态：dp[0][7500] = 1 (平移后的0点)
 * 
 * 参数:
 *   C: 挂钩数量
 *   G: 砝码数量
 *   hooks: 挂钩位置数组
 *   weights: 砝码重量数组
 * 返回值:
 *   使天平平衡的方法数
 */
int balanceWays(int C, int G, int* hooks, int* weights) {
    // dp[i][j] 表示前i个砝码，达到力矩平衡值为j-OFFSET的方法数
    // 这里j-OFFSET是实际的力矩值，j是平移后的索引
    // 最多20个砝码
    int dp[21][MAX_SUM];
    
    // 初始化dp数组
    for (int i = 0; i <= G; i++) {
        for (int j = 0; j < MAX_SUM; j++) {
            dp[i][j] = 0;
        }
    }
    
    // 初始状态：不放任何砝码，平衡值为0（平移后为OFFSET）
    // 这是动态规划的边界条件
    dp[0][OFFSET] = 1;
    
    // 遍历每个砝码（物品）
    for (int i = 1; i <= G; i++) {
        // 获取当前砝码的重量
        int weight = weights[i - 1];
        
        // 遍历前一个状态的所有可能平衡值
        for (int j = 0; j < MAX_SUM; j++) {
            // 如果前一个状态有方法能达到平衡值j
            if (dp[i - 1][j] > 0) {
                // 尝试将当前砝码挂在每个挂钩上
                for (int k = 0; k < C; k++) {
                    // 获取当前挂钩的位置
                    int hookPos = hooks[k];
                    // 计算放置当前砝码后的新平衡值
                    // 力矩 = 重量 * 位置，左边为负，右边为正
                    // 使用long long防止溢出
                    long long newBalance = (long long)j + (long long)weight * hookPos;
                    
                    // 检查新的平衡值是否在有效范围内
                    if (newBalance >= 0 && newBalance < MAX_SUM) {
                        // 状态转移：将前一个状态的方法数累加到新状态
                        dp[i][newBalance] += dp[i - 1][j];
                    }
                }
            }
        }
    }
    
    // 返回所有砝码放完后平衡值为0（平移后为OFFSET）的方法数
    // 平衡值为0表示天平平衡
    return dp[G][OFFSET];
}

/*
 * 示例:
 * 输入: C = 2, G = 4
 * hooks = [-2, 3]
 * weights = [3, 4, 5, 8]
 * 输出: 2
 * 解释: 有两种方法可以使天平平衡
 *
 * 时间复杂度: O(G * C * 15000)
 *   - 外层循环遍历所有砝码：O(G)
 *   - 中层循环遍历所有可能的平衡值：O(15000)
 *   - 内层循环遍历所有挂钩：O(C)
 * 空间复杂度: O(G * 15000)
 *   - 二维DP数组的空间消耗
 */