# 洛谷P1049 [NOIP2001 普及组] 装箱问题
# 题目描述：有一个箱子容量为V，同时有n个物品，每个物品有一个体积。
# 现在从n个物品中，任取若干个装入箱内（也可以不取），使箱子的剩余空间最小。输出这个最小值。
# 链接：https://www.luogu.com.cn/problem/P1049
# 
# 解题思路：
# 这是01背包问题的变形。
# 1. 目标是使箱子剩余空间最小，等价于使装入物品的总体积最大
# 2. 每个物品的"价值"等于其体积
# 3. dp[i][j] 表示前i个物品，背包容量为j时能装入的最大体积
# 4. 状态转移方程：
#    dp[i][j] = max(dp[i-1][j], dp[i-1][j-volume[i]] + volume[i])  (当j >= volume[i]时)
#    dp[i][j] = dp[i-1][j]  (当j < volume[i]时)
# 5. 最终答案是 V - dp[n][V]
#
# 时间复杂度：O(n * V)
# 空间复杂度：O(V)

def minRemainingSpace(V, n, volumes):
    """
    计算箱子的最小剩余空间
    
    解题思路：
    这是01背包问题的变形。
    1. 目标是使箱子剩余空间最小，等价于使装入物品的总体积最大
    2. 每个物品的"价值"等于其体积
    3. dp[i][j] 表示前i个物品，背包容量为j时能装入的最大体积
    4. 状态转移方程：
       dp[i][j] = max(dp[i-1][j], dp[i-1][j-volume[i]] + volume[i])  (当j >= volume[i]时)
       dp[i][j] = dp[i-1][j]  (当j < volume[i]时)
    5. 最终答案是 V - dp[n][V]
    
    Args:
        V: 箱子容量
        n: 物品数量
        volumes: 物品体积数组
    
    Returns:
        箱子的最小剩余空间
    """
    # dp[j] 表示背包容量为j时能装入的最大体积
    # 这里使用了空间优化的一维DP数组，相当于dp[i][j]压缩为dp[j]
    dp = [0] * (V + 1)
    
    # 遍历每个物品（01背包的物品遍历）
    for i in range(n):
        # 获取当前物品的体积
        volume = volumes[i]
        
        # 01背包需要倒序遍历，确保每个物品只使用一次
        # j表示当前背包的容量
        for j in range(V, volume - 1, -1):
            # 状态转移方程：
            # dp[j] = max(不选择当前物品, 选择当前物品)
            # 不选择当前物品：dp[j]（保持原值）
            # 选择当前物品：dp[j - volume] + volume（前一个状态+当前物品体积）
            dp[j] = max(dp[j], dp[j - volume] + volume)
    
    # 箱子剩余空间 = 总容量 - 装入物品的最大体积
    return V - dp[V]

'''
示例:
输入: V = 24, n = 6
volumes = [8, 3, 12, 7, 9, 7]
输出: 0
解释: 可以恰好装满箱子，剩余空间为0

输入: V = 10, n = 3
volumes = [3, 4, 5]
输出: 1
解释: 最多装入体积为9的物品，剩余空间为1

时间复杂度: O(n * V)
  - 外层循环遍历所有物品：O(n)
  - 内层循环遍历背包容量：O(V)
空间复杂度: O(V)
  - 一维DP数组的空间消耗
'''