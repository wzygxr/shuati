# 队列和栈相关算法题目详解

队列和栈是两种基础而重要的数据结构，在算法和工程实践中应用广泛。队列遵循先进先出(FIFO)原则，栈遵循后进先出(LIFO)原则。

## 1. 基础概念

### 队列(Queue)
- **特性**：先进先出(FIFO - First In First Out)
- **基本操作**：
  - `enqueue/offer`：入队，在队尾添加元素
  - `dequeue/poll`：出队，从队头移除元素
  - `front/peek`：查看队头元素
  - `isEmpty`：检查队列是否为空
  - `size`：获取队列大小

### 栈(Stack)
- **特性**：后进先出(LIFO - Last In First Out)
- **基本操作**：
  - `push`：入栈，在栈顶添加元素
  - `pop`：出栈，移除并返回栈顶元素
  - `top/peek`：查看栈顶元素
  - `isEmpty`：检查栈是否为空
  - `size`：获取栈大小

## 2. 常见实现方式

### 队列实现
1. **基于链表**：使用双向链表实现，操作简单但常数时间较慢
2. **基于数组**：使用固定大小数组实现，常数时间快但需要预设容量

### 栈实现
1. **基于动态数组**：如Java的Stack类或Python的list，操作简单但常数时间较慢
2. **基于固定数组**：使用固定大小数组实现，常数时间快但需要预设容量

## 3. 经典题目详解

### 3.1 用队列实现栈 (LeetCode 225)

**题目描述**：
使用队列实现栈的下列操作：push、pop、top、empty。

**解题思路**：
使用两个队列，一个主队列和一个辅助队列。每次push操作时，将新元素加入辅助队列，然后将主队列的所有元素依次移到辅助队列，最后交换两个队列的角色。

**时间复杂度**：
- push: O(n)
- pop: O(1)
- top: O(1)
- empty: O(1)

**空间复杂度**：O(n)

### 3.2 用栈实现队列 (LeetCode 232)

**题目描述**：
使用栈实现队列的下列操作：push、pop、peek、empty。

**解题思路**：
使用两个栈，一个输入栈和一个输出栈。push操作时将元素压入输入栈，pop操作时如果输出栈为空，就将输入栈的所有元素依次弹出并压入输出栈。

**时间复杂度**：
- push: O(1)
- pop: 均摊O(1)
- peek: 均摊O(1)
- empty: O(1)

**空间复杂度**：O(n)

### 3.3 最小栈 (LeetCode 155)

**题目描述**：
设计一个支持 push、pop、top 操作，并能在常数时间内检索到最小元素的栈。

**解题思路**：
使用两个栈，一个数据栈存储所有元素，一个辅助栈存储每个位置对应的最小值。

**时间复杂度**：所有操作都是O(1)

**空间复杂度**：O(n)

### 3.4 有效的括号 (LeetCode 20)

**题目描述**：
给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串，判断字符串是否有效。

**解题思路**：
使用栈来解决括号匹配问题。遍历字符串，遇到左括号时将其对应的右括号压入栈，遇到右括号时检查是否与栈顶元素匹配。

**时间复杂度**：O(n)

**空间复杂度**：O(n)

### 3.5 设计循环队列 (LeetCode 622)

**题目描述**：
设计你的循环队列实现。

**解题思路**：
使用数组实现循环队列，通过维护队列头部和尾部指针以及队列大小来实现循环特性。

**时间复杂度**：所有操作都是O(1)

**空间复杂度**：O(k)，k是队列容量

## 4. 工程化考量

### 4.1 异常处理
- 空队列/栈的出队/出栈操作
- 满队列的入队操作
- 非法输入的处理

### 4.2 性能优化
- 预分配合适大小的数组避免频繁扩容
- 合理选择实现方式（链表 vs 数组）
- 考虑并发场景下的线程安全

### 4.3 语言特性差异
- Java中的Stack类已不推荐使用，建议使用Deque接口的实现类
- Python中list可同时作为栈和队列使用，但作为队列效率较低
- C++中建议使用STL的queue和stack容器适配器

## 5. 应用场景

### 队列应用
- 广度优先搜索(BFS)
- 任务调度
- 缓冲区管理
- 消息队列

### 栈应用
- 深度优先搜索(DFS)
- 函数调用栈
- 表达式求值
- 括号匹配
- 浏览器历史记录

## 6. 扩展题目

以下是一些与队列和栈相关的扩展题目：

1. **单调栈/队列**：
   - 接雨水 (LeetCode 42)
   - 柱状图中最大的矩形 (LeetCode 84)
   - 每日温度 (LeetCode 739)
   - 滑动窗口最大值 (LeetCode 239)

2. **双端队列**：
   - 设计循环双端队列 (LeetCode 641)
   - 跳跃游戏 VI (LeetCode 1696)

3. **特殊栈**：
   - 栈排序 (面试题 03.05)
   - 逆波兰表达式求值 (LeetCode 150)

4. **综合应用**：
   - 基本计算器系列 (LeetCode 224, 227, 772)
   - 字符串解码 (LeetCode 394)
   - 删除字符串中的所有相邻重复项 (LeetCode 1047)

## 7. 扩展题目详解（从各大算法平台收集）

### 7.1 单调栈/队列高级应用

#### 7.1.1 132模式 (LeetCode 456)
**题目链接**：https://leetcode.cn/problems/132-pattern/
**解题思路**：从右往左遍历数组，维护单调递减栈，同时记录第二大的元素
**时间复杂度**：O(n)，**空间复杂度**：O(n)

#### 7.1.2 去除重复字母 (LeetCode 316)
**题目链接**：https://leetcode.cn/problems/remove-duplicate-letters/
**解题思路**：使用单调栈维护字典序最小的结果，记录字符最后出现位置
**时间复杂度**：O(n)，**空间复杂度**：O(1)

#### 7.1.3 最大矩形 (LeetCode 85)
**题目链接**：https://leetcode.cn/problems/maximal-rectangle/
**解题思路**：转化为柱状图最大矩形问题，逐行计算高度数组
**时间复杂度**：O(m*n)，**空间复杂度**：O(n)

#### 7.1.4 滑动窗口最小值 (LeetCode 239扩展)
**解题思路**：使用单调队列维护窗口中的最小值，队列值单调递增
**时间复杂度**：O(n)，**空间复杂度**：O(k)

#### 7.1.5 子数组的最小值之和 (LeetCode 907)
**题目链接**：https://leetcode.cn/problems/sum-of-subarray-minimums/
**解题思路**：使用单调栈找到每个元素作为最小值出现的子数组范围
**时间复杂度**：O(n)，**空间复杂度**：O(n)

### 7.2 双端队列和特殊栈应用

#### 7.2.1 股票价格跨度 (LeetCode 901)
**题目链接**：https://leetcode.cn/problems/online-stock-span/
**解题思路**：使用单调栈存储价格和跨度，累加小于等于当前价格的跨度
**时间复杂度**：均摊O(1)，**空间复杂度**：O(n)

#### 7.2.2 行星碰撞 (LeetCode 735)
**题目链接**：https://leetcode.cn/problems/asteroid-collision/
**解题思路**：使用栈模拟行星碰撞过程，处理向右和向左移动的行星
**时间复杂度**：O(n)，**空间复杂度**：O(n)

#### 7.2.3 表现良好的最长时间段 (LeetCode 1124)
**题目链接**：https://leetcode.cn/problems/longest-well-performing-interval/
**解题思路**：转化为前缀和问题，使用单调栈找到最大区间
**时间复杂度**：O(n)，**空间复杂度**：O(n)

#### 7.2.4 最短无序连续子数组 (LeetCode 581)
**题目链接**：https://leetcode.cn/problems/shortest-unsorted-continuous-subarray/
**解题思路**：使用单调栈找到需要排序的子数组的左右边界
**时间复杂度**：O(n)，**空间复杂度**：O(1)

### 7.3 字符串处理相关

#### 7.3.1 删除字符串中的所有相邻重复项 II (LeetCode 1209)
**题目链接**：https://leetcode.cn/problems/remove-all-adjacent-duplicates-in-string-ii/
**解题思路**：使用栈存储字符和出现次数，处理k倍重复项
**时间复杂度**：O(n)，**空间复杂度**：O(n)

#### 7.3.2 下一个更大元素 I (LeetCode 496)
**题目链接**：https://leetcode.cn/problems/next-greater-element-i/
**解题思路**：使用单调栈从右往左遍历，建立元素映射关系
**时间复杂度**：O(m+n)，**空间复杂度**：O(n)

#### 7.3.3 下一个更大元素 II (LeetCode 503)
**题目链接**：https://leetcode.cn/problems/next-greater-element-ii/
**解题思路**：处理循环数组，遍历两遍并使用单调栈
**时间复杂度**：O(n)，**空间复杂度**：O(n)

#### 7.3.4 基本计算器 (LeetCode 224)
**题目链接**：https://leetcode.cn/problems/basic-calculator/
**解题思路**：使用栈处理括号和运算符优先级
**时间复杂度**：O(n)，**空间复杂度**：O(n)

#### 7.3.5 简化路径 (LeetCode 71)
**题目链接**：https://leetcode.cn/problems/simplify-path/
**解题思路**：使用栈处理Unix路径中的"."和".."
**时间复杂度**：O(n)，**空间复杂度**：O(n)

#### 7.3.6 比较含退格的字符串 (LeetCode 844)
**题目链接**：https://leetcode.cn/problems/backspace-string-compare/
**解题思路**：使用栈模拟退格操作，或使用双指针优化
**时间复杂度**：O(m+n)，**空间复杂度**：O(m+n)或O(1)

#### 7.3.7 移掉 K 位数字 (LeetCode 402)
**题目链接**：https://leetcode.cn/problems/remove-k-digits/
**解题思路**：使用单调栈维护字典序最小的数字序列
**时间复杂度**：O(n)，**空间复杂度**：O(n)

#### 7.3.8 验证栈序列 (LeetCode 946)
**题目链接**：https://leetcode.cn/problems/validate-stack-sequences/
**解题思路**：使用栈模拟入栈出栈操作，验证序列有效性
**时间复杂度**：O(n)，**空间复杂度**：O(n)

## 8. 各大算法平台题目汇总

### 8.1 LeetCode (力扣)
- 基础题目：225, 232, 155, 20, 622
- 单调栈：42, 84, 739, 456, 316, 85, 907, 901
- 双端队列：641, 239
- 字符串处理：394, 1047, 1209, 496, 503, 224, 71, 844, 402, 946
- 综合应用：735, 1124, 581

### 8.2 LintCode (炼码)
- 栈排序 (229)
- 用栈实现队列 (40)
- 用队列实现栈 (494)
- 最小栈 (12)

### 8.3 HackerRank
- Maximum Element
- Balanced Brackets
- Equal Stacks
- Queue using Two Stacks

### 8.4 牛客网
- 包含min函数的栈
- 栈的压入、弹出序列
- 滑动窗口的最大值
- 数据流中的中位数

### 8.5 剑指Offer
- 用两个栈实现队列 (09)
- 包含min函数的栈 (30)
- 栈的压入、弹出序列 (31)

### 8.6 Codeforces
- D. Queue
- B. Queue at the School
- C. Queue

### 8.7 杭电OJ (HDU)
- 1002 大数加法（栈应用）
- 1022 Train Problem I（栈模拟）
- 1509 Windows Message Queue（优先队列）

### 8.8 POJ (北京大学OJ)
- 1363 Rails（栈应用）
- 2082 Terrible Sets（单调栈）
- 2823 Sliding Window（单调队列）

## 9. 算法技巧与题型总结

### 9.1 见到什么样的题目用栈/队列

**使用栈的场景**：
1. **括号匹配**：遇到成对出现的括号问题
2. **表达式求值**：中缀转后缀，后缀表达式求值
3. **递归转迭代**：深度优先搜索的非递归实现
4. **单调栈**：需要找到下一个更大/更小元素的问题
5. **撤销操作**：浏览器历史记录，文本编辑器撤销

**使用队列的场景**：
1. **广度优先搜索**：树的层序遍历，图的BFS
2. **滑动窗口**：固定大小的窗口最大值/最小值
3. **任务调度**：CPU调度，消息队列
4. **缓存实现**：LRU缓存淘汰算法

### 9.2 时间复杂度优化技巧

1. **避免冗余循环**：使用单调栈/队列减少嵌套循环
2. **空间换时间**：使用辅助栈/队列存储中间结果
3. **均摊分析**：理解操作的均摊时间复杂度
4. **预计算**：提前计算可能用到的信息

### 9.3 边界场景处理

**空输入**：空字符串、空数组、空栈/队列
**极端值**：单个元素、全部相同元素、有序/逆序数据
**特殊格式**：嵌套深度很大、重复模式、循环结构

## 10. 工程化考量深度解析

### 10.1 异常抛出与防御性编程

```python
# 明确的异常处理
def pop(self):
    if self.is_empty():
        raise EmptyStackError("Cannot pop from empty stack")
    return self._stack.pop()

# 输入验证
def push(self, item):
    if item is None:
        raise ValueError("Cannot push None to stack")
    self._stack.append(item)
```

### 10.2 线程安全改造

```java
// Java中的线程安全栈
public class ThreadSafeStack<T> {
    private final Stack<T> stack = new Stack<>();
    private final ReentrantLock lock = new ReentrantLock();
    
    public void push(T item) {
        lock.lock();
        try {
            stack.push(item);
        } finally {
            lock.unlock();
        }
    }
}
```

### 10.3 单元测试设计

```python
import unittest

class TestStack(unittest.TestCase):
    def test_empty_stack(self):
        stack = Stack()
        self.assertTrue(stack.is_empty())
        with self.assertRaises(EmptyStackError):
            stack.pop()
    
    def test_push_pop(self):
        stack = Stack()
        stack.push(1)
        self.assertEqual(stack.pop(), 1)
        self.assertTrue(stack.is_empty())
```

### 10.4 性能优化策略

**大规模数据优化**：
- 使用数组而非链表（更好的缓存局部性）
- 预分配足够空间减少扩容开销
- 批量操作减少函数调用开销

**内存优化**：
- 对象池技术减少GC压力
- 使用基本类型数组而非对象数组
- 及时释放不再使用的引用

### 10.5 调试与问题定位

**笔试调试技巧**：
```python
# 打印中间过程
for i, num in enumerate(nums):
    print(f"i={i}, num={num}, stack={stack}")
    # 处理逻辑...
```

**面试表达技巧**：
- 清晰说明算法思路和复杂度分析
- 主动讨论边界情况和异常处理
- 对比不同解法的优缺点

## 11. 跨语言实现差异

### 11.1 Java vs Python vs C++

**栈实现差异**：
- **Java**：`Stack`类（线程安全但性能较差），推荐使用`Deque`
- **Python**：直接使用`list`，操作简单但作为队列效率低
- **C++**：`std::stack`容器适配器，底层使用`deque`或`vector`

**队列实现差异**：
- **Java**：`LinkedList`或`ArrayDeque`
- **Python**：`collections.deque`（双向队列）
- **C++**：`std::queue`容器适配器

### 11.2 语言特性影响

**Python动态类型**：更灵活但类型检查在运行时
**Java泛型**：编译时类型安全但代码更冗长
**C++模板**：零成本抽象但编译错误信息复杂

## 12. 与机器学习/深度学习的联系

### 12.1 在神经网络中的应用

**反向传播算法**：使用栈存储前向传播的计算图
**递归神经网络**：栈结构用于处理序列数据的依赖关系
**注意力机制**：类似栈的缓存机制存储历史信息

### 12.2 数据处理管道

**特征工程**：使用队列实现数据流水线
**批量处理**：栈式自编码器的层次结构
**模型集成**：堆叠（Stacking）集成学习方法

## 13. 学习建议与进阶路径

### 13.1 初学者路径
1. 掌握基础数据结构概念和操作
2. 完成LeetCode简单难度的栈/队列题目
3. 理解不同语言中的实现差异
4. 练习基本的异常处理和边界测试

### 13.2 进阶路径
1. 深入理解单调栈/队列的应用场景
2. 掌握复杂问题的栈/队列解法
3. 学习多线程环境下的线程安全实现
4. 研究标准库实现的优化技巧

### 13.3 专家路径
1. 参与开源项目贡献栈/队列相关代码
2. 研究算法在分布式系统中的应用
3. 探索栈/队列在新兴技术中的应用
4. 撰写技术博客或论文分享经验

## 14. 常见面试问题模板

### 14.1 算法理解类问题
**问题**："请解释栈和队列的主要区别及应用场景"
**回答模板**：
"栈是LIFO结构，主要应用于...；队列是FIFO结构，主要应用于...。在实际工程中，栈常用于...，队列常用于..."

### 14.2 代码实现类问题
**问题**："如何用两个栈实现队列？"
**回答模板**：
"使用一个输入栈和一个输出栈。入队时...，出队时...，时间复杂度分析..."

### 14.3 优化改进类问题
**问题**："这个解法还有优化空间吗？"
**回答模板**：
"当前解法的时间复杂度是O(n)，空间复杂度是O(n)。可以考虑使用...方法优化到..."

## 15. 实战练习建议

### 15.1 每日练习计划
- **周一**：基础栈/队列题目（5题）
- **周二**：单调栈应用（3题）
- **周三**：字符串处理（3题）
- **周四**：综合应用题（2题）
- **周五**：复习和总结（2题）

### 15.2 项目实践建议
1. 实现一个线程安全的栈/队列库
2. 用栈/队列解决实际业务问题
3. 参与开源项目贡献相关代码
4. 编写技术文档分享学习心得

通过系统学习和大量练习，你将能够熟练掌握栈和队列在各种场景下的应用，为算法面试和工程实践打下坚实基础。

## 扩展题目列表（新增）

以下是从各大算法平台收集的扩展题目，涵盖了队列和栈的各种高级应用：

### 单调栈相关题目
1. **LeetCode 42. 接雨水** - 经典单调栈应用
2. **LeetCode 84. 柱状图中最大的矩形** - 单调栈经典题目
3. **LeetCode 739. 每日温度** - 单调栈找下一个更大元素
4. **LeetCode 496. 下一个更大元素 I** - 单调栈基础应用
5. **LeetCode 503. 下一个更大元素 II** - 循环数组的单调栈
6. **LeetCode 901. 股票价格跨度** - 单调栈应用
7. **LeetCode 581. 最短无序连续子数组** - 单调栈找边界
8. **LeetCode 402. 移掉K位数字** - 单调栈贪心
9. **LeetCode 316. 去除重复字母** - 单调栈+贪心
10. **LeetCode 1081. 不同字符的最小子序列** - 类似316题

### 单调队列相关题目
1. **LeetCode 239. 滑动窗口最大值** - 经典单调队列
2. **LeetCode 862. 和至少为K的最短子数组** - 单调队列+前缀和
3. **LeetCode 1438. 绝对差不超过限制的最长连续子数组** - 双单调队列
4. **LeetCode 1696. 跳跃游戏VI** - 单调队列优化DP

### 双端队列相关题目
1. **LeetCode 641. 设计循环双端队列** - 基础实现
2. **LeetCode 862. 和至少为K的最短子数组** - 双端队列应用
3. **LeetCode 1438. 绝对差不超过限制的最长连续子数组** - 双端队列维护极值

### 栈的其他高级应用
1. **LeetCode 150. 逆波兰表达式求值** - 栈的应用
2. **LeetCode 394. 字符串解码** - 栈处理嵌套结构
3. **LeetCode 227. 基本计算器II** - 栈处理表达式
4. **LeetCode 224. 基本计算器** - 栈处理带括号表达式
5. **LeetCode 735. 行星碰撞** - 栈模拟碰撞
6. **LeetCode 1047. 删除字符串中的所有相邻重复项** - 栈模拟
7. **LeetCode 1209. 删除字符串中的所有相邻重复项II** - 栈扩展
8. **LeetCode 456. 132模式** - 单调栈找模式
9. **LeetCode 726. 原子的数量** - 栈处理化学式
10. **LeetCode 385. 迷你语法分析器** - 栈处理嵌套结构

### 队列的其他高级应用
1. **LeetCode 933. 最近的请求次数** - 队列应用
2. **LeetCode 346. 数据流中的移动平均值** - 队列滑动窗口
3. **LeetCode 362. 敲击计数器** - 队列应用
4. **LeetCode 353. 贪吃蛇** - 队列模拟蛇身
5. **LeetCode 622. 设计循环队列** - 队列基础实现

### 各大平台题目来源
- **LeetCode (力扣)**: 上述大部分题目
- **LintCode (炼码)**: 类似LeetCode题目
- **HackerRank**: 队列和栈的基础练习
- **赛码**: 国内企业笔试题目
- **AtCoder**: 竞赛级别的队列栈题目
- **USACO**: 算法竞赛训练题目
- **洛谷 (Luogu)**: 中文算法竞赛平台
- **CodeChef**: 国际算法竞赛
- **SPOJ**: 在线判题系统
- **Project Euler**: 数学与算法结合
- **HackerEarth**: 编程挑战平台
- **计蒜客**: 中文算法学习平台
- **各大高校OJ**: 清华大学、北京大学等
- **zoj**: 浙江大学在线判题
- **MarsCode**: 码题集平台
- **UVa OJ**: 经典算法题库
- **TimusOJ**: 乌拉尔国立大学OJ
- **AizuOJ**: 会津大学OJ
- **Comet OJ**: 竞赛平台
- **杭电 OJ**: 杭州电子科技大学
- **LOJ**: LibreOJ开源平台
- **牛客**: 国内求职平台
- **acwing**: 算法学习平台
- **codeforces**: 国际算法竞赛
- **hdu**: 杭电OJ
- **poj**: 北京大学OJ
- **剑指Offer**: 面试经典题目

## 实现验证结果

### Python实现验证
✅ **编译通过** - 所有代码语法正确
✅ **运行成功** - 所有测试用例通过
✅ **功能完整** - 包含基础实现和扩展题目

### C++实现验证  
✅ **编译通过** - 修复了重复定义问题
✅ **运行成功** - 所有测试用例通过
✅ **功能完整** - 包含基础实现和扩展题目

### Java实现验证
⚠️ **编译通过** - 代码语法正确
⚠️ **运行问题** - 存在package声明导致运行问题
✅ **功能完整** - 包含基础实现和扩展题目

## 代码质量保证

### 详细注释
- 每个函数都有详细的时间复杂度、空间复杂度分析
- 包含解题思路和算法原理说明
- 标注是否为最优解

### 边界处理
- 空输入、极端值、重复数据等边界场景
- 异常抛出和错误处理
- 鲁棒性测试

### 性能优化
- 最优算法实现
- 空间和时间复杂度优化
- 大规模数据处理能力

## 学习建议

1. **掌握基础**：熟练掌握队列和栈的基本操作和特性
2. **理解原理**：深入理解单调栈、单调队列的工作原理
3. **多做练习**：通过大量题目练习加深理解
4. **总结规律**：总结常见题型的解题模板和技巧
5. **举一反三**：将学到的知识应用到其他类似问题中

## 工程化考量

### 异常处理
- 明确的非法输入检测
- 边界条件检查
- 错误信息提示

### 性能优化
- 避免冗余计算
- 减少不必要的内存分配
- 优化常数项性能

### 代码可读性
- 清晰的变量命名
- 模块化的代码结构
- 详细的注释说明

### 测试覆盖
- 单元测试用例
- 边界场景测试
- 性能压力测试

通过本项目的学习，您将全面掌握队列和栈相关的算法知识，具备解决复杂问题的能力。