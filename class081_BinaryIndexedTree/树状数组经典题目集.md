# 树状数组（Fenwick Tree）经典题目集

本文档收集了各大数据结构与算法平台上以树状数组为最优解的经典题目，每个题目都配有详细的解答代码和解析。

## 1. 基础题目：单点更新与区间查询

### 1.1 LeetCode 307. 区域和检索 - 数组可修改

**题目描述**：给定一个整数数组 nums，处理以下两种类型的操作：
1. 更新数组下标 i 处的值为 val
2. 返回数组中索引 left 和索引 right 之间的元素和（包含 left 和 right）

**题目链接**：https://leetcode.cn/problems/range-sum-query-mutable/

**难度**：中等

**解答思路**：
- 使用基础的单点更新+区间查询树状数组
- 维护原数组和树状数组，通过差分进行更新

**Java代码**：
```java
class NumArray {
    private int[] tree;  // 树状数组
    private int[] nums;  // 原始数组
    private int n;       // 数组长度
    
    public NumArray(int[] nums) {
        this.nums = nums;
        n = nums.length;
        tree = new int[n + 1];  // 树状数组索引从1开始
        
        // 初始化树状数组
        for (int i = 0; i < n; i++) {
            updateTree(i + 1, nums[i]);
        }
    }
    
    // lowbit函数
    private int lowbit(int x) {
        return x & -x;
    }
    
    // 更新树状数组
    private void updateTree(int index, int val) {
        while (index <= n) {
            tree[index] += val;
            index += lowbit(index);
        }
    }
    
    // 查询前缀和
    private int prefixSum(int index) {
        int sum = 0;
        while (index > 0) {
            sum += tree[index];
            index -= lowbit(index);
        }
        return sum;
    }
    
    // 更新原数组值并调整树状数组
    public void update(int index, int val) {
        int diff = val - nums[index];
        nums[index] = val;
        updateTree(index + 1, diff);  // 转换为树状数组索引（+1）
    }
    
    // 查询区间和
    public int sumRange(int left, int right) {
        // 区间和 = 右边界前缀和 - 左边界-1的前缀和
        return prefixSum(right + 1) - prefixSum(left);
    }
}
```

**C++代码**：
```cpp
class NumArray {
private:
    vector<int> tree;  // 树状数组
    vector<int> nums;  // 原始数组
    int n;             // 数组长度
    
    // lowbit函数
    int lowbit(int x) {
        return x & -x;
    }
    
    // 更新树状数组
    void updateTree(int index, int val) {
        while (index <= n) {
            tree[index] += val;
            index += lowbit(index);
        }
    }
    
    // 查询前缀和
    int prefixSum(int index) {
        int sum = 0;
        while (index > 0) {
            sum += tree[index];
            index -= lowbit(index);
        }
        return sum;
    }
    
public:
    NumArray(vector<int>& nums) {
        this->nums = nums;
        n = nums.size();
        tree.resize(n + 1, 0);  // 树状数组索引从1开始
        
        // 初始化树状数组
        for (int i = 0; i < n; i++) {
            updateTree(i + 1, nums[i]);
        }
    }
    
    // 更新原数组值并调整树状数组
    void update(int index, int val) {
        int diff = val - nums[index];
        nums[index] = val;
        updateTree(index + 1, diff);  // 转换为树状数组索引（+1）
    }
    
    // 查询区间和
    int sumRange(int left, int right) {
        return prefixSum(right + 1) - prefixSum(left);
    }
};
```

**Python代码**：
```python
class NumArray:
    def __init__(self, nums):
        self.nums = nums
        self.n = len(nums)
        self.tree = [0] * (self.n + 1)  # 树状数组索引从1开始
        
        # 初始化树状数组
        for i in range(self.n):
            self._update_tree(i + 1, nums[i])
    
    # lowbit函数
    def _lowbit(self, x):
        return x & -x
    
    # 更新树状数组
    def _update_tree(self, index, val):
        while index <= self.n:
            self.tree[index] += val
            index += self._lowbit(index)
    
    # 查询前缀和
    def _prefix_sum(self, index):
        sum_val = 0
        while index > 0:
            sum_val += self.tree[index]
            index -= self._lowbit(index)
        return sum_val
    
    # 更新原数组值并调整树状数组
    def update(self, index, val):
        diff = val - self.nums[index]
        self.nums[index] = val
        self._update_tree(index + 1, diff)  # 转换为树状数组索引（+1）
    
    # 查询区间和
    def sumRange(self, left, right):
        return self._prefix_sum(right + 1) - self._prefix_sum(left)
```

## 2. 进阶题目：区间更新与单点查询

### 2.1 洛谷 P3368 【模板】树状数组 2

**题目描述**：给定一个长度为n的数组，支持两种操作：
1. 将区间[l, r]加上k
2. 输出第x个数的值

**题目链接**：https://www.luogu.com.cn/problem/P3368

**难度**：普及+

**解答思路**：
- 使用差分思想结合树状数组
- 树状数组维护差分数组，单点查询即差分数组的前缀和

**Java代码**：
```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;
import java.io.PrintWriter;
import java.io.StreamTokenizer;

public class Main {
    static int MAXN = 500001;
    static int[] tree = new int[MAXN];  // 树状数组，维护差分数组
    static int[] original;  // 原始数组
    static int n, m;
    
    public static int lowbit(int x) {
        return x & -x;
    }
    
    // 更新树状数组中某个位置的值
    public static void update(int pos, int val) {
        while (pos <= n) {
            tree[pos] += val;
            pos += lowbit(pos);
        }
    }
    
    // 查询差分数组前缀和（即原数组某个位置的值）
    public static int query(int pos) {
        int res = 0;
        while (pos > 0) {
            res += tree[pos];
            pos -= lowbit(pos);
        }
        return res;
    }
    
    // 区间更新，将[l,r]增加val
    public static void rangeUpdate(int l, int r, int val) {
        update(l, val);       // 在差分数组的l位置加val
        update(r + 1, -val);  // 在差分数组的r+1位置减val
    }
    
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        PrintWriter out = new PrintWriter(new OutputStreamWriter(System.out));
        StreamTokenizer st = new StreamTokenizer(br);
        
        // 读取n和m
        st.nextToken();
        n = (int) st.nval;
        st.nextToken();
        m = (int) st.nval;
        
        original = new int[n + 1];
        // 读取原始数组
        for (int i = 1; i <= n; i++) {
            st.nextToken();
            original[i] = (int) st.nval;
        }
        
        // 构建差分数组的树状数组表示
        for (int i = 1; i <= n; i++) {
            rangeUpdate(i, i, original[i]);
        }
        
        // 处理操作
        for (int i = 0; i < m; i++) {
            st.nextToken();
            int op = (int) st.nval;
            
            if (op == 1) {
                // 区间更新操作
                st.nextToken();
                int l = (int) st.nval;
                st.nextToken();
                int r = (int) st.nval;
                st.nextToken();
                int val = (int) st.nval;
                rangeUpdate(l, r, val);
            } else {
                // 单点查询操作
                st.nextToken();
                int pos = (int) st.nval;
                out.println(query(pos));
            }
        }
        
        out.flush();
        out.close();
        br.close();
    }
}
```

## 3. 高级题目：区间更新与区间查询

### 3.1 洛谷 P3372 【模板】树状数组 1

**题目描述**：给定一个长度为n的数组，支持两种操作：
1. 将区间[l, r]加上k
2. 查询区间[l, r]的和

**题目链接**：https://www.luogu.com.cn/problem/P3372

**难度**：提高+/省选-

**解答思路**：
- 使用两个树状数组维护，结合数学推导实现区间更新和区间查询
- 树状数组1维护差分数组d[i]
- 树状数组2维护d[i]*(i-1)

**Java代码**：
```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;
import java.io.PrintWriter;
import java.io.StreamTokenizer;

public class Main {
    static int MAXN = 100001;
    static long[] tree1 = new long[MAXN];  // 维护d[i]
    static long[] tree2 = new long[MAXN];  // 维护d[i]*(i-1)
    static int n, m;
    
    public static int lowbit(int x) {
        return x & -x;
    }
    
    // 更新树状数组
    public static void update(long[] tree, int pos, long val) {
        while (pos <= n) {
            tree[pos] += val;
            pos += lowbit(pos);
        }
    }
    
    // 查询树状数组前缀和
    public static long query(long[] tree, int pos) {
        long res = 0;
        while (pos > 0) {
            res += tree[pos];
            pos -= lowbit(pos);
        }
        return res;
    }
    
    // 区间更新，将[l,r]增加val
    public static void rangeUpdate(int l, int r, long val) {
        // 更新tree1：d[l] += val, d[r+1] -= val
        update(tree1, l, val);
        update(tree1, r + 1, -val);
        
        // 更新tree2：d[l]*(l-1) += val*(l-1), d[r+1]*r -= val*r
        update(tree2, l, val * (l - 1));
        update(tree2, r + 1, -val * r);
    }
    
    // 前缀和查询，计算[1,pos]的和
    public static long prefixSum(int pos) {
        return pos * query(tree1, pos) - query(tree2, pos);
    }
    
    // 区间查询，计算[l,r]的和
    public static long rangeQuery(int l, int r) {
        return prefixSum(r) - prefixSum(l - 1);
    }
    
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        PrintWriter out = new PrintWriter(new OutputStreamWriter(System.out));
        StreamTokenizer st = new StreamTokenizer(br);
        
        // 读取n和m
        st.nextToken();
        n = (int) st.nval;
        st.nextToken();
        m = (int) st.nval;
        
        // 初始化数组
        long[] a = new long[n + 1];
        for (int i = 1; i <= n; i++) {
            st.nextToken();
            a[i] = (long) st.nval;
            // 通过区间更新[i,i]来设置初始值
            rangeUpdate(i, i, a[i]);
        }
        
        // 处理操作
        for (int i = 0; i < m; i++) {
            st.nextToken();
            int op = (int) st.nval;
            
            if (op == 1) {
                // 区间更新操作
                st.nextToken();
                int l = (int) st.nval;
                st.nextToken();
                int r = (int) st.nval;
                st.nextToken();
                long val = (long) st.nval;
                rangeUpdate(l, r, val);
            } else {
                // 区间查询操作
                st.nextToken();
                int l = (int) st.nval;
                st.nextToken();
                int r = (int) st.nval;
                out.println(rangeQuery(l, r));
            }
        }
        
        out.flush();
        out.close();
        br.close();
    }
}
```

## 4. 二维树状数组题目

### 4.1 LeetCode 308. 二维区域和检索 - 可变

**题目描述**：给定一个二维矩阵，支持两种操作：
1. 更新矩阵中某个位置的值
2. 计算子矩阵元素的和

**题目链接**：https://leetcode.cn/problems/range-sum-query-2d-mutable/

**难度**：困难

**解答思路**：
- 使用二维树状数组实现单点更新和区域查询
- 树状数组索引从1开始，注意与原始矩阵索引的转换

**Java代码**：
```java
class NumMatrix {
    private int[][] tree;  // 二维树状数组
    private int[][] nums;  // 原始矩阵
    private int n;         // 行数
    private int m;         // 列数
    
    public NumMatrix(int[][] matrix) {
        if (matrix == null || matrix.length == 0 || matrix[0].length == 0) {
            return;
        }
        
        n = matrix.length;
        m = matrix[0].length;
        tree = new int[n + 1][m + 1];  // 树状数组索引从1开始
        nums = new int[n + 1][m + 1];  // 原始数组也从1开始存储
        
        // 初始化树状数组
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++) {
                update(i, j, matrix[i][j]);
            }
        }
    }
    
    // lowbit函数
    private int lowbit(int x) {
        return x & -x;
    }
    
    // 更新树状数组中的某个位置
    private void updateTree(int row, int col, int val) {
        for (int i = row; i <= n; i += lowbit(i)) {
            for (int j = col; j <= m; j += lowbit(j)) {
                tree[i][j] += val;
            }
        }
    }
    
    // 查询从(1,1)到(row,col)的前缀和
    private int queryTree(int row, int col) {
        int sum = 0;
        for (int i = row; i > 0; i -= lowbit(i)) {
            for (int j = col; j > 0; j -= lowbit(j)) {
                sum += tree[i][j];
            }
        }
        return sum;
    }
    
    // 更新原始矩阵中的值
    public void update(int row, int col, int val) {
        int diff = val - nums[row + 1][col + 1];  // 计算差值
        nums[row + 1][col + 1] = val;  // 更新原始数组
        updateTree(row + 1, col + 1, diff);  // 更新树状数组
    }
    
    // 查询子矩阵和
    public int sumRegion(int row1, int col1, int row2, int col2) {
        // 转换为树状数组索引并应用容斥原理
        return queryTree(row2 + 1, col2 + 1) 
             - queryTree(row1, col2 + 1) 
             - queryTree(row2 + 1, col1) 
             + queryTree(row1, col1);
    }
}
```

## 5. 逆序对统计题目

### 5.1 LeetCode 315. 计算右侧小于当前元素的个数

**题目描述**：给你一个整数数组 nums ，按要求返回一个新数组 counts 。数组 counts 有该性质： counts[i] 的值是 nums[i] 右侧小于 nums[i] 的元素的数量。

**题目链接**：https://leetcode.cn/problems/count-of-smaller-numbers-after-self/

**难度**：困难

**解答思路**：
- 将问题转化为逆序对统计
- 使用树状数组 + 离散化处理重复元素
- 从右到左遍历，统计比当前元素小的已处理元素数量

**Java代码**：
```java
import java.util.*;

class Solution {
    public List<Integer> countSmaller(int[] nums) {
        int n = nums.length;
        List<Integer> result = new ArrayList<>(n);
        
        // 离散化处理
        Set<Integer> set = new HashSet<>();
        for (int num : nums) {
            set.add(num);
        }
        List<Integer> sortedNums = new ArrayList<>(set);
        Collections.sort(sortedNums);
        Map<Integer, Integer> valueToIndex = new HashMap<>();
        for (int i = 0; i < sortedNums.size(); i++) {
            valueToIndex.put(sortedNums.get(i), i + 1);  // 树状数组索引从1开始
        }
        
        // 初始化树状数组
        FenwickTree tree = new FenwickTree(sortedNums.size());
        
        // 从右向左遍历数组
        for (int i = n - 1; i >= 0; i--) {
            int index = valueToIndex.get(nums[i]);
            // 查询比当前元素小的已处理元素数量
            result.add(0, tree.query(index - 1));
            // 将当前元素插入树状数组
            tree.update(index, 1);
        }
        
        return result;
    }
    
    // 树状数组类
    class FenwickTree {
        private int[] tree;
        private int n;
        
        public FenwickTree(int size) {
            n = size;
            tree = new int[n + 1];
        }
        
        private int lowbit(int x) {
            return x & -x;
        }
        
        public void update(int index, int delta) {
            while (index <= n) {
                tree[index] += delta;
                index += lowbit(index);
            }
        }
        
        public int query(int index) {
            int sum = 0;
            while (index > 0) {
                sum += tree[index];
                index -= lowbit(index);
            }
            return sum;
        }
    }
}
```

## 6. 高维树状数组应用

### 6.1 Codeforces 61E Enemy is weak

**题目描述**：给定一个数列，求满足 i<j<k 且 a[i]>a[j]>a[k] 的三元组数目。

**题目链接**：https://codeforces.com/problemset/problem/61/E

**难度**：高级

**解答思路**：
- 使用两个树状数组分别统计每个元素左边有多少比它大的元素，右边有多少比它小的元素
- 对于每个元素a[j]，其贡献为left[j] * right[j]
- 总和即为所有满足条件的三元组数目

**C++代码**：
```cpp
#include <iostream>
#include <vector>
#include <algorithm>
#include <map>
using namespace std;

class FenwickTree {
private:
    vector<long long> tree;
    int n;
    
    int lowbit(int x) {
        return x & -x;
    }
    
public:
    FenwickTree(int size) {
        n = size;
        tree.resize(n + 1, 0);
    }
    
    void update(int index, long long delta) {
        while (index <= n) {
            tree[index] += delta;
            index += lowbit(index);
        }
    }
    
    long long query(int index) {
        long long sum = 0;
        while (index > 0) {
            sum += tree[index];
            index -= lowbit(index);
        }
        return sum;
    }
};

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    
    int n;
    cin >> n;
    vector<long long> a(n);
    for (int i = 0; i < n; i++) {
        cin >> a[i];
    }
    
    // 离散化
    vector<long long> sorted_a(a);
    sort(sorted_a.begin(), sorted_a.end());
    sorted_a.erase(unique(sorted_a.begin(), sorted_a.end()), sorted_a.end());
    map<long long, int> value_to_index;
    for (int i = 0; i < sorted_a.size(); i++) {
        value_to_index[sorted_a[i]] = i + 1;  // 树状数组索引从1开始
    }
    
    // 计算每个元素右边比它小的元素个数
    vector<long long> right(n, 0);
    FenwickTree right_tree(sorted_a.size());
    for (int i = n - 1; i >= 0; i--) {
        int index = value_to_index[a[i]];
        right[i] = right_tree.query(index - 1);
        right_tree.update(index, 1);
    }
    
    // 计算每个元素左边比它大的元素个数
    vector<long long> left(n, 0);
    FenwickTree left_tree(sorted_a.size());
    for (int i = 0; i < n; i++) {
        int index = value_to_index[a[i]];
        left[i] = left_tree.query(sorted_a.size()) - left_tree.query(index);
        left_tree.update(index, 1);
    }
    
    // 计算总贡献
    long long result = 0;
    for (int i = 0; i < n; i++) {
        result += left[i] * right[i];
    }
    
    cout << result << endl;
    
    return 0;
}
```

## 7. 实际应用题目

### 7.1 HackerRank Reverse Shuffle Merge

**题目描述**：给定一个字符串s，找到一个字典序最小的字符串a，使得s可以通过将a的一个排列与a的逆序排列合并得到。

**题目链接**：https://www.hackerrank.com/challenges/reverse-shuffle-merge/problem

**难度**：中等

**解答思路**：
- 使用贪心算法结合树状数组来高效地选择字符
- 树状数组用于快速查询剩余可用字符的数量

**Python代码**：
```python
def reverseShuffleMerge(s):
    from collections import defaultdict
    
    # 统计每个字符出现的总次数
    char_count = defaultdict(int)
    for char in s:
        char_count[char] += 1
    
    # 每个字符在结果中出现的次数应为总次数的一半
    required = {char: cnt // 2 for char, cnt in char_count.items()}
    remaining = char_count.copy()
    
    # 用于跟踪结果中已使用的字符数量
    used = defaultdict(int)
    
    # 树状数组类，用于查询剩余字符中最小字符的位置
    class FenwickTree:
        def __init__(self, size):
            self.n = size
            self.tree = [0] * (self.n + 1)
        
        def update(self, index, delta):
            while index <= self.n:
                self.tree[index] += delta
                index += index & -index
        
        def query(self, index):
            res = 0
            while index > 0:
                res += self.tree[index]
                index -= index & -index
            return res
    
    # 字符到索引的映射（a=1, b=2, ..., z=26）
    char_to_idx = {chr(ord('a') + i): i + 1 for i in range(26)}
    idx_to_char = {i + 1: chr(ord('a') + i) for i in range(26)}
    
    # 初始化树状数组，初始时所有字符都可用
    ft = FenwickTree(26)
    for char, cnt in remaining.items():
        if cnt > 0:
            ft.update(char_to_idx[char], cnt)
    
    result = []
    # 从后往前遍历s的逆序（相当于从s的开头开始处理）
    for char in reversed(s):
        # 如果当前字符已经达到需要的数量，跳过
        if used[char] == required[char]:
            remaining[char] -= 1
            ft.update(char_to_idx[char], -1)
            continue
        
        # 尝试跳过当前字符，但需要确保后面还有足够的字符来构成结果
        while result and result[-1] > char and used[result[-1]] + remaining[result[-1]] > required[result[-1]]:
            # 可以丢弃最后一个字符，回退使用计数
            last_char = result.pop()
            used[last_char] -= 1
            ft.update(char_to_idx[last_char], 1)
        
        # 使用当前字符
        result.append(char)
        used[char] += 1
        remaining[char] -= 1
        ft.update(char_to_idx[char], -1)
    
    return ''.join(result)
```

## 8. 总结与学习建议

树状数组是一种非常强大的数据结构，尤其适合处理前缀和相关的查询和更新操作。通过以上题目的练习，可以全面掌握树状数组的各种应用场景：

1. **单点更新 + 区间查询**：基础操作，适用于动态维护数组和查询区间和
2. **区间更新 + 单点查询**：利用差分数组思想，将区间更新转换为两个单点更新
3. **区间更新 + 区间查询**：使用两个树状数组维护，结合数学推导实现复杂操作
4. **二维树状数组**：将一维树状数组扩展到二维平面，处理二维区域查询
5. **逆序对统计**：结合离散化技术，高效统计逆序对或相关问题
6. **组合问题**：与其他算法（如贪心）结合，解决更复杂的问题

**学习建议**：
1. 先掌握一维树状数组的基本操作和差分数组思想
2. 理解区间更新和区间查询的数学推导过程
3. 尝试实现二维树状数组，理解其在二维平面上的工作原理
4. 通过逆序对问题，学习树状数组结合离散化的应用
5. 尝试解决一些综合性问题，如Codeforces上的题目
6. 对比树状数组与线段树的优劣，在实际问题中选择最合适的数据结构

通过系统学习和大量练习，树状数组将成为解决各类区间操作问题的有力工具。