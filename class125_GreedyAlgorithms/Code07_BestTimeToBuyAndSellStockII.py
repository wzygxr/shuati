# 买卖股票的最佳时机 II (Best Time to Buy and Sell Stock II)
# 给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。
# 设计一个算法来计算你所能获取的最大利润。
# 你可以尽可能地完成更多的交易（多次买卖一支股票）。
# 注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。
# 
# 算法标签: 贪心算法(Greedy Algorithm)、数组遍历(Array Traversal)
# 时间复杂度: O(n)，其中n是价格数组长度
# 空间复杂度: O(1)，仅使用常数额外空间
# 测试链接 : https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/
# 相关题目: LeetCode 121. 买卖股票的最佳时机、LeetCode 123. 买卖股票的最佳时机 III
# 贪心算法专题 - 补充题目收集与详解

"""
算法思路详解：
1. 贪心策略：只要明天价格比今天高，就在今天买入明天卖出
   - 这个策略的核心思想是抓住每一个上涨的机会
   - 将所有正的价格差累加就是最大利润
   - 等价于在所有局部最低点买入，在所有局部最高点卖出

2. 遍历价格数组，计算相邻两天的价格差
   - 通过一次遍历完成所有计算
   - 只需要比较相邻两天的价格

3. 如果价格差为正，则累加到总利润中
   - 正的价格差表示可以获利
   - 累加所有正的价格差得到最大利润

时间复杂度分析：
- 遍历时间复杂度：O(n)，其中n是价格数组长度
- 总体时间复杂度：O(n)

空间复杂度分析：
- 只使用了常数额外空间存储变量
- 空间复杂度：O(1)

是否最优解：
- 是，这是处理此类问题的最优解法
- 贪心策略保证了局部最优解能导致全局最优解

工程化最佳实践：
1. 异常处理：检查输入是否为空或长度不足
2. 边界条件：处理空数组、单个元素等特殊情况
3. 性能优化：一次遍历完成计算，避免重复操作
4. 可读性：清晰的变量命名和详细注释，便于维护

极端场景与边界情况处理：
1. 空输入：prices为空数组或长度为0
2. 极端值：只有一个价格、所有价格相同
3. 重复数据：多个价格相同的情况
4. 有序/逆序数据：价格持续上涨或下跌的情况

跨语言实现差异与优化：
1. Java：使用增强for循环遍历数组，代码更简洁
2. C++：使用传统for循环或范围for循环，性能更优
3. Python：使用for循环或列表推导式，语法更灵活

调试与测试策略：
1. 打印中间过程：在循环中打印每天的价格和利润变化
2. 用断言验证中间结果：确保利润不为负
3. 性能退化排查：检查是否只遍历了一次数组
4. 边界测试：测试空数组、单元素等边界情况

实际应用场景与拓展：
1. 金融数据分析：在简单的交易策略中应用贪心算法
2. 时间序列预测：作为基线策略进行对比分析
3. 强化学习：作为初始策略提供给智能体

算法深入解析：
贪心算法在股票交易问题中的应用体现了其核心思想：
1. 局部最优选择：每次选择当前能获得的最大利润
2. 无后效性：当前的选择不会影响之前的状态
3. 最优子结构：问题的最优解包含子问题的最优解
这个问题的关键洞察是，多次交易的最大利润等于所有正的价格差之和。
"""


def maxProfit(prices):
    """
    买卖股票的最佳时机 II 主函数 - 使用贪心算法计算最大利润
    
    算法思路：
    1. 遍历价格数组，计算相邻两天的价格差
    2. 如果价格差为正，则累加到总利润中
    
    Args:
        prices (List[int]): 股票价格列表，prices[i]表示第i天的股票价格
    
    Returns:
        int: 能够获得的最大利润
    
    时间复杂度: O(n)，其中n是价格数组长度
    空间复杂度: O(1)，仅使用常数额外空间
    
    Examples:
        >>> maxProfit([7, 1, 5, 3, 6, 4])
        7
        >>> maxProfit([1, 2, 3, 4, 5])
        4
    """
    # 异常处理：检查输入是否为空或长度不足
    if not prices or len(prices) <= 1:
        return 0
    
    max_profit = 0  # 存储最大利润
    
    # 遍历价格数组，计算相邻两天的价格差
    # 时间复杂度：O(n)
    for i in range(1, len(prices)):
        # 如果明天价格比今天高，则累加利润
        # 这体现了贪心策略：抓住每一个上涨的机会
        if prices[i] > prices[i - 1]:
            max_profit += prices[i] - prices[i - 1]
    
    return max_profit  # 返回最大利润


# 补充题目1: LeetCode 55. 跳跃游戏
# 题目描述: 给定一个非负整数数组 nums ，你最初位于数组的 第一个下标 。
# 数组中的每个元素代表你在该位置可以跳跃的最大长度。
# 判断你是否能够到达最后一个下标。
# 链接: https://leetcode.cn/problems/jump-game/
# 时间复杂度: O(n) - 仅遍历数组一次
# 空间复杂度: O(1) - 只使用常量级额外空间

def can_jump(nums):
    """
    判断是否能到达数组的最后一个下标 - 使用贪心算法
    
    算法思路：
    1. 维护能到达的最远位置
    2. 遍历数组，更新最远位置
    3. 如果当前位置超过了最远位置，无法继续前进
    
    Args:
        nums (List[int]): 整数列表，其中每个元素表示在该位置可以跳跃的最大长度
    
    Returns:
        bool: 如果能到达最后一个下标返回True，否则返回False
    
    时间复杂度: O(n)，其中n是数组长度
    空间复杂度: O(1)，只使用常量级额外空间
    
    贪心策略：维护能到达的最远位置，如果最远位置超过或等于数组最后一个位置，则可以到达
    
    工程化考量：
    1. 异常处理：检查输入是否为空
    2. 边界条件：处理空数组等特殊情况
    3. 性能优化：提前终止条件避免不必要的计算
    """
    # 异常处理：检查输入是否为空
    if not nums:
        return True  # 空数组视为可以到达
    
    max_reach = 0  # 当前能到达的最远位置
    
    # 贪心策略：维护能到达的最远位置
    # 时间复杂度：O(n)
    for i in range(len(nums)):
        # 如果当前位置超过了能到达的最远位置，无法继续前进
        if i > max_reach:
            return False
        # 更新能到达的最远位置
        max_reach = max(max_reach, i + nums[i])
        # 如果已经能到达或超过最后一个位置，直接返回True
        if max_reach >= len(nums) - 1:
            return True
    
    return max_reach >= len(nums) - 1


# 补充题目2: LeetCode 45. 跳跃游戏 II
# 题目描述: 给定一个非负整数数组，你最初位于数组的第一个位置。
# 数组中的每个元素代表你在该位置可以跳跃的最大长度。
# 你的目标是使用最少的跳跃次数到达数组的最后一个位置。
# 假设你总是可以到达数组的最后一个位置。
# 链接: https://leetcode.cn/problems/jump-game-ii/
# 时间复杂度: O(n) - 仅遍历数组一次
# 空间复杂度: O(1) - 只使用常量级额外空间

def jump(nums):
    """
    使用最少的跳跃次数到达数组的最后一个位置 - 使用贪心算法
    
    算法思路：
    1. 每次在可到达范围内选择能跳得最远的位置
    2. 维护当前跳跃能到达的边界和最远位置
    
    Args:
        nums (List[int]): 整数列表，其中每个元素表示在该位置可以跳跃的最大长度
    
    Returns:
        int: 到达最后一个位置所需的最少跳跃次数
    
    时间复杂度: O(n)，其中n是数组长度
    空间复杂度: O(1)，只使用常量级额外空间
    
    贪心策略：每次在可到达范围内选择能跳得最远的位置作为下一个跳跃点
    
    工程化考量：
    1. 异常处理：检查输入是否为空或长度不足
    2. 边界条件：处理空数组、单元素等情况
    3. 性能优化：提前终止条件避免不必要的计算
    """
    # 异常处理：检查输入是否为空或长度不足
    if not nums or len(nums) <= 1:
        return 0  # 空数组或只有一个元素不需要跳跃
    
    jumps = 0        # 跳跃次数
    current_end = 0  # 当前跳跃能到达的边界
    farthest = 0     # 在进行下次跳跃前能到达的最远位置
    
    # 贪心策略：每次在可到达范围内选择能跳得最远的位置
    # 时间复杂度：O(n)
    for i in range(len(nums) - 1):
        # 更新能到达的最远位置
        farthest = max(farthest, i + nums[i])
        
        # 到达当前跳跃的边界，需要进行一次跳跃
        if i == current_end:
            jumps += 1
            current_end = farthest
            
            # 如果已经能到达最后位置，可以提前结束
            if current_end >= len(nums) - 1:
                break
    
    return jumps


# 补充题目3: LeetCode 605. 种花问题
# 题目描述: 假设有一个很长的花坛，一部分地块种植了花，另一部分却没有。
# 可是，花不能种植在相邻的地块上，它们会争夺水源，两者都会死去。
# 给你一个整数数组 flowerbed 表示花坛，由若干 0 和 1 组成，其中 0 表示没种植花，1 表示种植了花。
# 另有一个数 n ，能否在不打破种植规则的情况下种入 n 朵花？
# 能则返回 True ，不能则返回 False 。
# 链接: https://leetcode.cn/problems/can-place-flowers/
# 时间复杂度: O(n) - 仅遍历数组一次
# 空间复杂度: O(1) - 只使用常量级额外空间

def can_place_flowers(flowerbed, n):
    """
    判断能否在不打破种植规则的情况下种入n朵花 - 使用贪心算法
    
    算法思路：
    1. 遍历花坛，尽可能多地种花
    2. 检查当前位置是否可以种花
    
    Args:
        flowerbed (List[int]): 整数列表，表示花坛，0表示没种花，1表示种了花
        n (int): 整数，表示要种的花的数量
    
    Returns:
        bool: 如果能种入n朵花返回True，否则返回False
    
    时间复杂度: O(n)，其中n是花坛长度
    空间复杂度: O(1)，只使用常量级额外空间
    
    贪心策略：遍历花坛，尽可能多地种花
    
    工程化考量：
    1. 异常处理：检查输入是否为空
    2. 边界条件：处理空数组等特殊情况
    3. 性能优化：提前终止条件避免不必要的计算
    """
    # 异常处理：检查输入是否为空
    if not flowerbed:
        return n == 0
    
    count = 0  # 可以种的花的数量
    length = len(flowerbed)
    
    # 贪心策略：遍历花坛，尽可能多地种花
    # 时间复杂度：O(n)
    for i in range(length):
        # 检查当前位置是否可以种花：当前位置为0，且前后都不是1
        can_plant = flowerbed[i] == 0
        if i > 0:
            can_plant = can_plant and (flowerbed[i - 1] == 0)
        if i < length - 1:
            can_plant = can_plant and (flowerbed[i + 1] == 0)
        
        if can_plant:
            flowerbed[i] = 1  # 在当前位置种花
            count += 1
            
            # 如果已经能满足n朵花，提前返回
            if count >= n:
                return True
    
    return count >= n


# 补充题目4: LeetCode 435. 无重叠区间
# 题目描述: 给定一个区间的集合 intervals ，其中 intervals[i] = [starti, endi] 。
# 返回需要移除区间的最小数量，使剩余区间互不重叠。
# 链接: https://leetcode.cn/problems/non-overlapping-intervals/
# 时间复杂度: O(n log n) - 排序需要O(n log n)，遍历需要O(n)
# 空间复杂度: O(1) - 只使用常量级额外空间

def erase_overlap_intervals(intervals):
    """
    计算需要移除的区间的最小数量，使剩余区间互不重叠 - 使用贪心算法
    
    算法思路：
    1. 按区间结束位置排序
    2. 优先保留结束早的区间
    
    Args:
        intervals (List[List[int]]): 区间列表，每个区间是包含两个整数的列表 [start, end]
    
    Returns:
        int: 需要移除的区间的最小数量
    
    时间复杂度: O(n log n)，排序需要O(n log n)，遍历需要O(n)
    空间复杂度: O(1)，只使用常量级额外空间
    
    贪心策略：优先保留结束早的区间，这样可以保留更多的区间
    
    工程化考量：
    1. 异常处理：检查输入是否为空或长度不足
    2. 边界条件：处理空数组、单元素等情况
    3. 性能优化：排序后使用贪心策略避免重复计算
    """
    # 异常处理：检查输入是否为空或长度不足
    if not intervals or len(intervals) <= 1:
        return 0
    
    # 按区间结束位置排序
    # 关键点：按结束位置排序保证了贪心策略的正确性
    intervals.sort(key=lambda x: x[1])
    
    count = 0       # 保留的区间数量
    end = float('-inf')  # 上一个保留的区间的结束位置
    
    # 贪心策略：优先保留结束早的区间
    # 时间复杂度：O(n)
    for interval in intervals:
        # 如果当前区间的开始位置大于等于上一个保留区间的结束位置，则不重叠
        if interval[0] >= end:
            count += 1
            end = interval[1]
        # 否则，该区间与上一个保留区间重叠，需要移除
    
    # 需要移除的区间数量 = 总区间数量 - 保留的区间数量
    return len(intervals) - count


# 补充题目5: LeetCode 121. 买卖股票的最佳时机
# 题目描述: 给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。
# 你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。
# 设计一个算法来计算你所能获取的最大利润。
# 返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。
# 链接: https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/
# 时间复杂度: O(n) - 仅遍历数组一次
# 空间复杂度: O(1) - 只使用常量级额外空间

def max_profit_single(prices):
    """
    计算单次买卖股票能获得的最大利润 - 使用贪心算法
    
    算法思路：
    1. 记录到目前为止的最低价格
    2. 计算当前价格卖出能获得的最大利润
    
    Args:
        prices (List[int]): 整数列表，表示股票每天的价格
    
    Returns:
        int: 最大利润，如果不能获利返回0
    
    时间复杂度: O(n)，其中n是价格数组长度
    空间复杂度: O(1)，只使用常量级额外空间
    
    贪心策略：每次记录到目前为止的最低价格，计算当前价格卖出能获得的最大利润
    
    工程化考量：
    1. 异常处理：检查输入是否为空或长度不足
    2. 边界条件：处理空数组、单元素等情况
    3. 性能优化：一次遍历完成计算
    """
    # 异常处理：检查输入是否为空或长度不足
    if not prices or len(prices) <= 1:
        return 0
    
    min_price = float('inf')  # 记录到目前为止的最低价格
    max_profit = 0            # 记录最大利润
    
    # 贪心策略：每次记录到目前为止的最低价格，计算当前价格卖出能获得的最大利润
    # 时间复杂度：O(n)
    for price in prices:
        # 更新最低价格
        if price < min_price:
            min_price = price
        # 计算当前价格卖出能获得的利润，并更新最大利润
        elif price - min_price > max_profit:
            max_profit = price - min_price
    
    return max_profit


# 测试函数
if __name__ == "__main__":
    # 测试用例1：一般情况
    prices1 = [7, 1, 5, 3, 6, 4]
    print("测试用例1结果:", maxProfit(prices1))  # 期望输出: 7
    
    # 测试用例2：持续上涨
    prices2 = [1, 2, 3, 4, 5]
    print("测试用例2结果:", maxProfit(prices2))  # 期望输出: 4
    
    # 测试用例3：持续下跌
    prices3 = [7, 6, 4, 3, 1]
    print("测试用例3结果:", maxProfit(prices3))  # 期望输出: 0
    
    # 测试用例4：边界情况 - 单个价格
    prices4 = [1]
    print("测试用例4结果:", maxProfit(prices4))  # 期望输出: 0
    
    # 测试用例5：波动价格
    prices5 = [1, 2, 1, 2, 1, 2]
    print("测试用例5结果:", maxProfit(prices5))  # 期望输出: 3