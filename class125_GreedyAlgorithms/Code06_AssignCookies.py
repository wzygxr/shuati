# 分发饼干 (Assign Cookies)
# 假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。
# 对每个孩子 i，都有一个胃口值 g[i]，这是能让孩子们满足胃口的饼干的最小尺寸；
# 并且每块饼干 j，都有一个尺寸 s[j] 。
# 如果 s[j] >= g[i]，我们可以将这个饼干 j 分配给孩子 i ，这个孩子会得到满足。
# 你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。
# 
# 算法标签: 贪心算法(Greedy Algorithm)、双指针(Two Pointers)、排序(Sorting)
# 时间复杂度: O(m*log(m) + n*log(n))，其中m是孩子数量，n是饼干数量
# 空间复杂度: O(1)，仅使用常数额外空间
# 测试链接 : https://leetcode.cn/problems/assign-cookies/
# 相关题目: LeetCode 452. 用最少数量的箭引爆气球、LeetCode 763. 划分字母区间
# 贪心算法专题 - 补充题目收集与详解

"""
算法思路详解：
1. 贪心策略：优先满足胃口小的孩子
   - 这样可以最大化满足的孩子数量
   - 小胃口的孩子更容易被满足，应该优先处理

2. 将孩子胃口数组和饼干尺寸数组都排序
   - 排序后可以使用双指针技术
   - 保证了贪心策略的正确性

3. 用双指针分别遍历两个数组
   - child指针遍历孩子数组
   - cookie指针遍历饼干数组

4. 当前饼干能满足当前孩子时，两个指针都后移
   - 表示这个孩子已经被满足
   - 可以尝试满足下一个孩子

5. 当前饼干不能满足当前孩子时，饼干指针后移，寻找更大的饼干
   - 当前饼干无法满足当前孩子
   - 需要寻找更大的饼干来尝试满足

时间复杂度分析：
- 排序时间复杂度：O(m*log(m) + n*log(n))，其中m是孩子数量，n是饼干数量
- 遍历时间复杂度：O(m + n)
- 总体时间复杂度：O(m*log(m) + n*log(n))

空间复杂度分析：
- 只使用了常数额外空间存储指针和临时变量
- 空间复杂度：O(1)

是否最优解：
- 是，这是处理此类问题的最优解法
- 贪心策略保证了局部最优解能导致全局最优解

工程化最佳实践：
1. 异常处理：检查输入是否为空，避免空指针异常
2. 边界条件：处理空数组、单个元素等特殊情况
3. 性能优化：使用双指针避免重复遍历，提高效率
4. 可读性：清晰的变量命名和详细注释，便于维护

极端场景与边界情况处理：
1. 空输入：g或s为空数组时返回0
2. 极端值：只有一个孩子或一块饼干的情况
3. 重复数据：多个孩子胃口相同或多个饼干尺寸相同
4. 有序/逆序数据：孩子胃口和饼干尺寸都已排序的情况

跨语言实现差异与优化：
1. Java：使用Arrays.sort进行排序，时间复杂度稳定
2. C++：使用std::sort进行排序，底层实现可能更优化
3. Python：使用内置sort()方法或sorted()函数，基于Timsort算法

调试与测试策略：
1. 打印中间过程：在循环中打印指针位置和当前匹配情况
2. 用断言验证中间结果：确保每次匹配都满足s[j] >= g[i]
3. 性能退化排查：检查排序和遍历的时间复杂度
4. 边界测试：测试空数组、单元素等边界情况

实际应用场景与拓展：
1. 资源分配问题：在有限资源下最大化满足的请求数量
2. 任务调度：在有限时间内完成尽可能多的任务
3. 匹配系统：在供需匹配中最大化匹配数量

算法深入解析：
贪心算法的核心思想是每一步都做出当前看起来最好的选择，希望通过局部最优解达到全局最优解。
在分发饼干问题中，我们的贪心策略是优先满足胃口小的孩子，这样可以保证：
1. 小胃口的孩子更容易被满足，应该优先处理
2. 大饼干可以留给大胃口的孩子，避免浪费
3. 通过排序和双指针技术，我们可以高效地实现这个策略
"""


def findContentChildren(g, s):
    """
    分发饼干主函数 - 使用贪心算法最大化满足的孩子数量
    
    算法思路：
    1. 对孩子胃口数组和饼干尺寸数组进行排序
    2. 使用双指针技术分别遍历两个数组
    3. 贪心策略：优先满足胃口小的孩子
    
    Args:
        g (List[int]): 孩子们的胃口值列表，g[i]表示第i个孩子的最小满足饼干尺寸
        s (List[int]): 饼干的尺寸列表，s[j]表示第j块饼干的尺寸
    
    Returns:
        int: 能够满足的孩子数量
    
    时间复杂度: O(m*log(m) + n*log(n))，其中m是孩子数量，n是饼干数量
    空间复杂度: O(1)，仅使用常数额外空间
    
    Examples:
        >>> findContentChildren([1, 2, 3], [1, 1])
        1
        >>> findContentChildren([1, 2], [1, 2, 3])
        2
    """
    # 异常处理：检查输入是否为空，避免后续操作出现异常
    if not g or not s:
        return 0
    
    # 排序孩子胃口数组和饼干尺寸数组
    # 时间复杂度：O(m*log(m) + n*log(n))
    g.sort()
    s.sort()
    
    child = 0    # 孩子指针，指向当前待满足的孩子
    cookie = 0   # 饼干指针，指向当前待分配的饼干
    
    # 双指针遍历
    # 时间复杂度：O(m + n)
    while child < len(g) and cookie < len(s):
        # 如果当前饼干能满足当前孩子
        if s[cookie] >= g[child]:
            child += 1   # 满足的孩子数加1，指向下一个孩子
        cookie += 1      # 饼干指针后移，指向下一个饼干
    
    return child  # 返回满足的孩子数


# 补充题目1: LeetCode 452. 用最少数量的箭引爆气球
# 题目描述: 有一些球形气球贴在一堵用XY平面表示的墙面上。墙面上的气球记录在整数数组points，
# 其中points[i] = [xstart, xend]表示水平直径在xstart和xend之间的气球。
# 你不知道气球的确切y坐标。一支弓箭可以沿着x轴从不同点完全垂直地射出。
# 在坐标x处射出一支箭，若有一个气球的直径的开始和结束坐标为xstart，xend，
# 且满足xstart ≤ x ≤ xend，则该气球会被引爆。
# 可以射出的弓箭的数量没有限制。弓箭一旦被射出之后，可以无限地前进。
# 我们想找到使得所有气球全部被引爆，所需的弓箭的最小数量。
# 链接: https://leetcode.cn/problems/minimum-number-of-arrows-to-burst-balloons/

def find_min_arrow_shots(points):
    """
    计算引爆所有气球所需的最少弓箭数量 - 使用贪心算法
    
    算法思路：
    1. 按气球结束位置排序
    2. 贪心策略：尽可能用一支箭射更多的气球
    3. 当前气球的开始位置大于箭的位置时，需要新的箭
    
    Args:
        points (List[List[int]]): 包含气球起始和结束坐标的列表，每个元素为[xstart, xend]
    
    Returns:
        int: 所需的最少弓箭数量
    
    时间复杂度: O(n log n)，其中n是气球数量，主要开销来自排序
    空间复杂度: O(log n)，排序所需的空间
    
    工程化考量：
    1. 异常处理：检查输入是否为空
    2. 边界条件：处理空数组、单个元素等情况
    3. 性能优化：排序后使用贪心策略避免重复计算
    """
    # 异常处理：检查输入是否为空
    if not points:
        return 0
    
    # 按气球结束位置排序
    # 关键点：按结束位置排序保证了贪心策略的正确性
    points.sort(key=lambda x: x[1])
    
    arrows = 1  # 至少需要一支箭
    end = points[0][1]  # 第一支箭的位置设为第一个气球的结束位置
    
    # 贪心策略：尽可能用一支箭射更多的气球
    for i in range(1, len(points)):
        # 如果当前气球的开始位置大于箭的位置，说明需要新的箭
        if points[i][0] > end:
            # 需要新的箭
            arrows += 1
            end = points[i][1]  # 更新箭的位置为当前气球的结束位置
    
    return arrows


# 补充题目2: LeetCode 763. 划分字母区间
# 题目描述: 字符串 S 由小写字母组成。我们要把这个字符串划分为尽可能多的片段，
# 同一字母最多出现在一个片段中。返回一个表示每个字符串片段的长度的列表。
# 链接: https://leetcode.cn/problems/partition-labels/

def partition_labels(s):
    """
    将字符串划分为尽可能多的片段，同一字母最多出现在一个片段中 - 使用贪心算法
    
    算法思路：
    1. 记录每个字符最后出现的位置
    2. 贪心策略：扩展片段直到包含所有字符的最后出现位置
    3. 当前索引等于结束位置时，找到一个完整片段
    
    Args:
        s (str): 输入字符串，仅包含小写字母
    
    Returns:
        List[int]: 每个片段的长度列表
    
    时间复杂度: O(n)，其中n是字符串长度，需要两次遍历
    空间复杂度: O(1)，只使用了固定大小的数组（26个字母）
    
    工程化考量：
    1. 异常处理：检查输入是否为空
    2. 边界条件：处理空字符串、单字符等情况
    3. 性能优化：使用哈希表快速查找字符最后位置
    """
    # 异常处理：检查输入是否为空
    if not s:
        return []
    
    # 记录每个字符最后出现的位置
    # 时间复杂度：O(n)
    last_pos = {}
    for i, c in enumerate(s):
        last_pos[c] = i
    
    result = []  # 存储结果
    start = 0    # 当前片段的开始位置
    end = 0      # 当前片段的结束位置
    
    # 贪心策略：扩展片段直到包含所有字符的最后出现位置
    # 时间复杂度：O(n)
    for i, c in enumerate(s):
        # 更新当前片段的结束位置为当前字符最后出现位置和当前结束位置的最大值
        end = max(end, last_pos[c])
        # 如果当前索引等于结束位置，说明找到了一个完整片段
        if i == end:
            # 找到一个完整片段
            result.append(end - start + 1)
            start = end + 1  # 更新下一个片段的开始位置
    
    return result


# 补充题目3: LeetCode 135. 分发糖果
# 题目描述: n 个孩子站成一排。给你一个整数数组 ratings 表示每个孩子的评分。
# 你需要按照以下要求，给这些孩子分发糖果：
# 1. 每个孩子至少分配到 1 个糖果。
# 2. 相邻两个孩子评分更高的孩子会获得更多的糖果。
# 请你给每个孩子分发糖果，计算并返回需要准备的最少糖果数目。
# 链接: https://leetcode.cn/problems/candy/

def candy(ratings):
    """
    计算满足条件的最少糖果数目 - 使用贪心算法
    
    算法思路：
    1. 从左到右：处理右孩子评分高于左孩子的情况
    2. 从右到左：处理左孩子评分高于右孩子的情况，取较大值
    3. 计算总和
    
    Args:
        ratings (List[int]): 每个孩子的评分数组
    
    Returns:
        int: 需要准备的最少糖果数目
    
    时间复杂度: O(n)，其中n是孩子数量，需要两次遍历
    空间复杂度: O(n)，需要额外数组存储每个孩子的糖果数
    
    工程化考量：
    1. 异常处理：检查输入是否为空
    2. 边界条件：处理空数组、单元素等情况
    3. 性能优化：两次遍历确保满足所有约束条件
    """
    # 异常处理：检查输入是否为空
    if not ratings:
        return 0
    
    n = len(ratings)
    # 初始化：每个孩子至少1个糖果
    candies = [1] * n
    
    # 从左到右：处理右孩子评分高于左孩子的情况
    # 时间复杂度：O(n)
    for i in range(1, n):
        if ratings[i] > ratings[i - 1]:
            candies[i] = candies[i - 1] + 1
    
    # 从右到左：处理左孩子评分高于右孩子的情况，取较大值
    # 时间复杂度：O(n)
    for i in range(n - 2, -1, -1):
        if ratings[i] > ratings[i + 1]:
            candies[i] = max(candies[i], candies[i + 1] + 1)
    
    # 计算总和
    # 时间复杂度：O(n)
    return sum(candies)


# 补充题目4: LeetCode 406. 根据身高重建队列
# 题目描述: 假设有打乱顺序的一群人站成一个队列，数组 people 表示队列中一些人的属性（不一定按顺序）。
# 每个 people[i] = [hi, ki] 表示第 i 个人的身高为 hi ，前面 正好 有 ki 个身高大于或等于 hi 的人。
# 请你重新构造并返回输入数组 people 所表示的队列。
# 返回的队列应该格式化为数组 queue ，其中 queue[j] = [hj, kj] 是队列中第 j 个人的属性（queue[0] 是排在队列前面的人）。
# 链接: https://leetcode.cn/problems/queue-reconstruction-by-height/

def reconstruct_queue(people):
    """
    根据身高和前面人的数量重建队列 - 使用贪心算法
    
    算法思路：
    1. 按身高降序，k升序排序
    2. 贪心策略：按排序后的顺序插入到指定位置
    3. 高个子先插入，不会影响后续插入的矮个子
    
    Args:
        people (List[List[int]]): 包含每个人身高和前面人数的列表，每个元素为[h, k]
    
    Returns:
        List[List[int]]: 重建后的队列
    
    时间复杂度: O(n²)，排序O(n log n)，插入操作O(n²)
    空间复杂度: O(n)，存储结果数组
    
    工程化考量：
    1. 异常处理：检查输入是否为空
    2. 边界条件：处理空数组、单元素等情况
    3. 性能优化：排序后使用插入策略保证正确性
    """
    # 异常处理：检查输入是否为空
    if not people:
        return []
    
    # 按身高降序，k升序排序
    # 关键点：身高高的先处理，不会影响后续插入的矮个子
    people.sort(key=lambda x: (-x[0], x[1]))
    
    result = []
    # 贪心策略：按排序后的顺序插入到指定位置
    for p in people:
        # 在索引p[1]处插入当前人
        result.insert(p[1], p)
    
    return result


# 补充题目5: LeetCode 871. 最低加油次数
# 题目描述: 汽车从起点出发驶向目的地，该目的地位于出发位置东面 target 英里处。
# 沿途有加油站，每个 station[i] 代表一个加油站，位于出发位置东面 station[i][0] 英里处，
# 并且有 station[i][1] 升汽油。
# 假设汽车油箱的容量是无限的，其中最初有 startFuel 升燃料。
# 它每行驶 1 英里就会用掉 1 升汽油。
# 当汽车到达加油站时，它可能停下来加油，将所有汽油从加油站转移到汽车中。
# 为了到达目的地，汽车所必要的最低加油次数是多少？如果无法到达目的地，则返回 -1。
# 链接: https://leetcode.cn/problems/minimum-number-of-refueling-stops/

import heapq

def min_refuel_stops(target, start_fuel, stations):
    """
    计算到达目的地所需的最少加油次数 - 使用贪心算法+最大堆
    
    算法思路：
    1. 使用最大堆存储经过的加油站的汽油量
    2. 如果油量不足，从堆中选择油量最多的加油站加油
    3. 处理从最后一个加油站到目的地的情况
    
    Args:
        target (int): 目的地距离起点的英里数
        start_fuel (int): 初始燃料量
        stations (List[List[int]]): 加油站列表，每个元素为[位置, 汽油量]
    
    Returns:
        int: 所需的最少加油次数，如果无法到达返回-1
    
    时间复杂度: O(n log n)，其中n是加油站数量，堆操作的复杂度
    空间复杂度: O(n)，堆存储加油站油量
    
    工程化考量：
    1. 异常处理：检查输入参数有效性
    2. 边界条件：处理无加油站、单加油站等情况
    3. 性能优化：使用最大堆快速获取最大油量加油站
    """
    # 最大堆，存储经过的加油站的汽油量（Python的heapq是最小堆，所以存负数）
    max_heap = []
    fuel = start_fuel  # 当前油量
    stops = 0  # 加油次数
    prev = 0  # 上一个位置
    
    # 处理所有加油站
    # 时间复杂度：O(n)
    for i in range(len(stations)):
        location, gas = stations[i]
        
        # 从当前位置到加油站需要的油量
        fuel -= location - prev
        
        # 如果油量不足，需要从之前经过的加油站中选择油量最多的加油
        # 时间复杂度：O(log n)（堆操作）
        while fuel < 0 and max_heap:
            fuel += -heapq.heappop(max_heap)  # 弹出最大的油量并加到当前油量
            stops += 1
        
        # 如果无法到达当前加油站，返回-1
        if fuel < 0:
            return -1
        
        # 将当前加油站的油量加入堆中（存负数）
        heapq.heappush(max_heap, -gas)
        prev = location
    
    # 处理从最后一个加油站到目的地
    fuel -= target - prev
    while fuel < 0 and max_heap:
        fuel += -heapq.heappop(max_heap)
        stops += 1
    
    return stops if fuel >= 0 else -1


# 测试函数
if __name__ == "__main__":
    # 测试用例1：基本情况
    g1 = [1, 2, 3]
    s1 = [1, 1]
    print("测试用例1结果:", findContentChildren(g1, s1))  # 期望输出: 1
    
    # 测试用例2：能够满足所有孩子
    g2 = [1, 2]
    s2 = [1, 2, 3]
    print("测试用例2结果:", findContentChildren(g2, s2))  # 期望输出: 2
    
    # 测试用例3：边界情况 - 空孩子数组
    g3 = []
    s3 = [1, 2, 3]
    print("测试用例3结果:", findContentChildren(g3, s3))  # 期望输出: 0
    
    # 测试用例4：极端情况 - 饼干都不够满足任何孩子
    g4 = [1, 2, 3, 4, 5]
    s4 = [1, 1, 1, 1]
    print("测试用例4结果:", findContentChildren(g4, s4))  # 期望输出: 1