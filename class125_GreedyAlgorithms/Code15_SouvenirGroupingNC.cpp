// 纪念品分组（牛客网版本）
// 与洛谷版本类似，但可能输入输出格式略有不同。
// 测试链接 : https://ac.nowcoder.com/acm/problem/16722

/*
 * 算法思路：
 * 1. 贪心策略：排序后使用双指针，最小价格和最大价格配对
 * 2. 将纪念品价格数组排序
 * 3. 使用双指针，左指针指向最小价格，右指针指向最大价格
 * 4. 如果两件纪念品价格之和不超过上限，则分为一组，两个指针都移动
 * 5. 如果超过上限，则最大价格的纪念品单独分为一组，只移动右指针
 *
 * 时间复杂度：O(n * logn) - 主要是排序的时间复杂度
 * 空间复杂度：O(1) - 只使用了常数额外空间
 * 是否最优解：是，这是处理此类问题的最优解法
 *
 * 工程化考量：
 * 1. 异常处理：检查输入是否为空
 * 2. 边界条件：处理空数组、单个元素等特殊情况
 * 3. 性能优化：使用双指针避免重复遍历
 * 4. 可读性：清晰的变量命名和注释
 *
 * 极端场景与边界场景：
 * 1. 空输入：prices为空数组
 * 2. 极端值：只有一件纪念品、所有纪念品价格相同
 * 3. 重复数据：多件纪念品价格相同
 * 4. 有序/逆序数据：纪念品价格按顺序排列
 *
 * 跨语言场景与语言特性差异：
 * 1. Java：使用Arrays.sort进行排序
 * 2. C++：使用std::sort进行排序
 * 3. Python：使用sorted函数或list.sort()方法
 *
 * 调试能力构建：
 * 1. 打印中间过程：在循环中打印当前配对的纪念品和分组情况
 * 2. 用断言验证中间结果：确保每组价格之和不超过上限
 * 3. 性能退化排查：检查排序和遍历的时间复杂度
 *
 * 与机器学习、图像处理、自然语言处理的联系与应用：
 * 1. 在资源分配问题中，贪心算法可用于优化分组策略
 * 2. 在推荐系统中，可用于物品配对推荐
 * 3. 在数据挖掘中，可用于相似物品聚类
 */

// 简单的排序函数实现（冒泡排序）
void bubbleSort(int arr[], int n) {
    for (int i = 0; i < n - 1; i++) {
        for (int j = 0; j < n - i - 1; j++) {
            if (arr[j] > arr[j + 1]) {
                // 交换元素
                int temp = arr[j];
                arr[j] = arr[j + 1];
                arr[j + 1] = temp;
            }
        }
    }
}

// 纪念品分组主函数
int souvenirGrouping(int w, int prices[], int pricesSize) {
    // 异常处理：检查输入是否为空
    if (prices == 0 || pricesSize == 0) {
        return 0;
    }
    
    // 边界条件：只有一件纪念品
    if (pricesSize == 1) {
        return 1;
    }
    
    // 使用冒泡排序对纪念品价格数组排序
    bubbleSort(prices, pricesSize);
    
    int left = 0;          // 左指针，指向最小价格
    int right = pricesSize - 1;  // 右指针，指向最大价格
    int groups = 0;        // 分组数
    
    // 双指针遍历
    while (left <= right) {
        // 如果两件纪念品价格之和不超过上限
        if (prices[left] + prices[right] <= w) {
            left++;   // 最小价格纪念品被分组
        }
        // 最大价格纪念品被分组（无论是否与最小价格纪念品配对）
        right--;
        groups++;     // 分组数加1
    }
    
    return groups;
}