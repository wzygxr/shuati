# 排队接水 (Queue Water)
# 有 n 个人在一个水龙头前排队接水，假如每个人接水的时间为 Ti，
# 请编程找出这 n 个人排队的一种顺序，使得 n 个人的平均等待时间最小。
# 一个人的等待时间不包括他的接水时间。
# 如果两个人接水的时间相同，编号更小的人应当排在前面。
# 
# 算法标签: 贪心算法(Greedy Algorithm)、排序(Sorting)
# 时间复杂度: O(n * logn)，其中n是人数
# 空间复杂度: O(n)，存储排序后的索引
# 测试链接 : https://www.luogu.com.cn/problem/P1223
# 相关题目: 任务调度、进程调度
# 贪心算法专题 - 排序与调度问题集合

"""
算法思路详解：
1. 贪心策略：按接水时间升序排列
   - 这个策略的核心思想是让接水时间短的人先接水
   - 这样可以减少后面人的等待时间，从而最小化平均等待时间
   - 符合直觉：短任务优先原则

2. 接水时间短的人排在前面，可以减少后面人的等待时间
   - 这是问题的关键洞察
   - 通过数学证明可以验证这个贪心策略的正确性
   - 如果有两个人i和j，ti < tj，那么i排在j前面能得到更小的平均等待时间

3. 计算排列后的平均等待时间
   - 等待时间是前面所有人接水时间的总和
   - 平均等待时间是所有人等待时间的平均值

时间复杂度分析：
- 排序时间复杂度：O(n * logn)，其中n是人数
- 计算等待时间时间复杂度：O(n)
- 总体时间复杂度：O(n * logn)

空间复杂度分析：
- 存储人员信息空间：O(n)
- 其他变量存储空间：O(1)
- 总体空间复杂度：O(n)

是否最优解：
- 是，这是处理此类问题的最优解法
- 贪心策略保证了局部最优解能导致全局最优解
- 可以通过交换论证法证明其正确性

工程化最佳实践：
1. 异常处理：检查输入是否为空或格式不正确
2. 边界条件：处理空数组、单个元素等特殊情况
3. 性能优化：使用贪心策略避免穷举所有排列
4. 可读性：清晰的变量命名和详细注释，便于维护

极端场景与边界情况处理：
1. 空输入：times为空数组
2. 极端值：只有一人、所有人的接水时间相同
3. 重复数据：多人接水时间相同
4. 有序/逆序数据：接水时间按顺序排列

跨语言实现差异与优化：
1. Java：使用Arrays.sort进行排序，性能稳定
2. C++：使用std::sort进行排序，底层实现可能更优化
3. Python：使用sorted函数或list.sort()方法，基于Timsort算法

调试与测试策略：
1. 打印中间过程：在循环中打印当前排列顺序和等待时间
2. 用断言验证中间结果：确保排列后等待时间最小
3. 性能退化排查：检查排序和遍历的时间复杂度
4. 边界测试：测试空数组、单元素等边界情况

实际应用场景与拓展：
1. 任务调度问题：在操作系统中优化平均等待时间
2. 进程调度：在操作系统中用于进程调度算法设计
3. 网络通信：在网络通信中用于数据包调度优化

算法深入解析：
贪心算法在排队接水问题中的应用体现了其核心思想：
1. 局部最优选择：每次选择接水时间最短的人
2. 无后效性：当前的选择不会影响之前的状态
3. 最优子结构：问题的最优解包含子问题的最优解
这个问题的关键洞察是，短任务优先策略能最小化平均等待时间，这可以通过数学证明验证。
"""


def queueWater(times):
    """
    排队接水主函数 - 使用贪心算法计算最优排队顺序和平均等待时间
    
    算法思路：
    1. 贪心策略：按接水时间升序排列
    2. 接水时间短的人排在前面，可以减少后面人的等待时间
    3. 计算排列后的平均等待时间
    
    Args:
        times (List[int]): 接水时间列表
        times[i]表示第i+1个人的接水时间（编号从1开始）
    
    Returns:
        tuple: (排列顺序列表, 平均等待时间)
        - 排列顺序列表：最优排队顺序中每个人的编号
        - 平均等待时间：所有人等待时间的平均值，保留两位小数
    
    时间复杂度: O(n * logn)，其中n是人数
    空间复杂度: O(n)，存储排序后的索引
    
    Examples:
        >>> queueWater([1, 2, 3])
        ([1, 2, 3], 1.33)
        >>> queueWater([5, 1, 3, 2])
        ([2, 4, 3, 1], 2.75)
    """
    # 异常处理：检查输入是否为空
    if not times:
        return ([], 0.0)
    
    # 边界条件：只有一个人
    if len(times) == 1:
        return ([1], 0.0)
    
    n = len(times)
    
    # 创建人员列表，保存编号和接水时间
    # 时间复杂度：O(n)
    people = [(i + 1, times[i]) for i in range(n)]  # 编号从1开始
    
    # 按接水时间升序排序，时间相同时按编号升序排序
    # 关键点：贪心策略的实现，短任务优先
    # 时间复杂度：O(n * logn)
    people.sort(key=lambda x: (x[1], x[0]))
    
    # 计算平均等待时间
    total_wait_time = 0
    wait_time = 0
    
    # 计算每个人的等待时间
    # 等待时间是前面所有人接水时间的总和
    # 时间复杂度：O(n)
    for i in range(n - 1):  # 最后一个人没有等待时间
        wait_time += people[i][1]
        total_wait_time += wait_time
    
    # 返回排列顺序和平均等待时间
    order = [person[0] for person in people]
    avg_wait_time = total_wait_time / n
    
    return (order, round(avg_wait_time, 2))


# 测试函数
if __name__ == "__main__":
    # 测试用例1：一般情况
    times1 = [1, 2, 3]
    order1, avg_time1 = queueWater(times1)
    print("测试用例1排列顺序:", order1)
    print("测试用例1平均等待时间:", avg_time1)  # 期望输出: [1, 2, 3], 平均等待时间: 1.33
    
    # 测试用例2：无序时间
    times2 = [5, 1, 3, 2]
    order2, avg_time2 = queueWater(times2)
    print("测试用例2排列顺序:", order2)
    print("测试用例2平均等待时间:", avg_time2)  # 期望输出: [2, 4, 3, 1], 平均等待时间: 2.75
    
    # 测试用例3：边界情况 - 只有一人
    times3 = [10]
    order3, avg_time3 = queueWater(times3)
    print("测试用例3排列顺序:", order3)
    print("测试用例3平均等待时间:", avg_time3)  # 期望输出: [1], 平均等待时间: 0.0
    
    # 测试用例4：相同时间 - 验证编号排序
    times4 = [3, 3, 3]
    order4, avg_time4 = queueWater(times4)
    print("测试用例4排列顺序:", order4)
    print("测试用例4平均等待时间:", avg_time4)  # 期望输出: [1, 2, 3], 平均等待时间: 4.0