# Class094 贪心算法专题

## 概述

Class094主要涵盖了贪心算法相关的经典问题。贪心算法是一种在每一步选择中都采取在当前状态下最好或最优（即最有利）的选择，从而希望导致结果是最好或最优的算法策略。这类算法在很多情况下能得到最优解或者近似最优解。

## 题目列表

### 核心题目

1. [Code01_EliminateMaximumMonsters.java](Code01_EliminateMaximumMonsters.java) - 消灭怪物的最大数量 (LeetCode 1921)
2. [Code02_LargestPalindromicNumber.java](Code02_LargestPalindromicNumber.java) - 最大回文数字 (LeetCode 2384)
3. [Code03_MaximumAveragePassRatio.java](Code03_MaximumAveragePassRatio.java) - 最大平均通过率 (LeetCode 1792)
4. [Code04_MinimumCostToHireWorkers.java](Code04_MinimumCostToHireWorkers.java) - 雇佣K名工人的最低成本 (LeetCode 857)
5. [Code05_CuttingTree.java](Code05_CuttingTree.java) - 砍树 (ZOJ 3211)

### 补充题目

6. [Code06_AssignCookies.java](Code06_AssignCookies.java) - 分发饼干 (LeetCode 455)
7. [Code07_BestTimeToBuyAndSellStockII.java](Code07_BestTimeToBuyAndSellStockII.java) - 买卖股票的最佳时机 II (LeetCode 122)
8. [Code08_JumpGame.java](Code08_JumpGame.java) - 跳跃游戏 (LeetCode 55)
9. [Code09_NonOverlappingIntervals.java](Code09_NonOverlappingIntervals.java) - 无重叠区间 (LeetCode 435)
10. [Code10_LemonadeChange.java](Code10_LemonadeChange.java) - 柠檬水找零 (LeetCode 860)
11. [Code11_MergeFruits.java](Code11_MergeFruits.java) - 合并果子 (洛谷 P1090)
12. [Code12_QueueWater.java](Code12_QueueWater.java) - 排队接水 (洛谷 P1223)
13. [Code13_SouvenirGrouping.java](Code13_SouvenirGrouping.java) - 纪念品分组 (洛谷 P1094)
14. [Code14_MinimumAbsoluteDifference.java](Code14_MinimumAbsoluteDifference.java) - 最小绝对差 (HackerRank)
15. [Code15_SouvenirGroupingNC.java](Code15_SouvenirGroupingNC.java) - 纪念品分组 (牛客网)

### 扩展题目（新增）

16. [Code16_GreedyAdditionalProblems.java](Code16_GreedyAdditionalProblems.java) - 贪心算法补充题目集合（多平台）
17. [Code17_GreedyAdvancedProblems.java](Code17_GreedyAdvancedProblems.java) - 贪心算法高级题目集合
18. [Code18_GreedyMathematicalProblems.java](Code18_GreedyMathematicalProblems.java) - 贪心算法数学相关问题集合
19. [Code19_GreedySummaryAndPractice.java](Code19_GreedySummaryAndPractice.java) - 贪心算法总结与实战练习

### 多语言版本

每个核心题目都提供了Java、C++、Python三种语言的实现：

- **Java版本**: `.java` 文件，使用标准库和面向对象特性
- **C++版本**: `.cpp` 文件，使用STL容器和算法
- **Python版本**: `.py` 文件，使用内置函数和简洁语法

## 算法详解

### 1. 消灭怪物的最大数量

**题目描述**：
你正在玩一款电子游戏，在游戏中你需要保护城市免受怪物侵袭。给定两个大小为n的整数数组dist、speed，其中dist[i]是第i个怪物与城市的初始距离，其中speed[i]是第i个怪物的速度。你有一种武器，一旦充满电，就可以消灭一个怪物，但是，武器需要1的时间才能充电完成。武器在游戏开始时是充满电的状态，怪物从0时刻开始移动，一旦任何怪物到达城市，就输掉了这场游戏。如果某个怪物恰好在某一分钟开始时到达城市，这也会被视为输掉游戏。返回在你输掉游戏前可以消灭的怪物的最大数量，如果消灭所有怪兽了返回n。

**算法思路**：
1. 贪心策略：优先消灭最早到达城市的怪物
2. 计算每个怪物到达城市的时间：time[i] = ceil(dist[i] / speed[i])
3. 将时间排序，按顺序消灭怪物
4. 在第i分钟（从0开始），如果第i个怪物还未到达城市，则可以消灭它
5. 一旦发现第i分钟时第i个怪物已经到达城市，则游戏失败

**时间复杂度**：O(n * logn) - 主要是排序的时间复杂度
**空间复杂度**：O(n) - 存储到达时间数组
**是否最优解**：是，这是处理此类问题的最优解法

### 2. 最大回文数字

**题目描述**：
给你一个仅由数字（0 - 9）组成的字符串num，请你找出能够使用num中数字形成的最大回文整数，并以字符串形式返回，该整数不含前导零。你无需使用num中的所有数字，但你必须使用至少一个数字，数字可以重新排列。

**算法思路**：
1. 贪心策略：要构造最大的回文数，应该从高位到低位选择尽可能大的数字
2. 统计每个数字的出现次数
3. 构造回文数的左半部分：
   - 从数字9到1，尽可能多地使用数字（每次使用2个）
   - 特殊处理数字0：只有在左半部分已经有其他数字时才使用0
4. 确定中心数字：
   - 从9到0，选择剩余数量为奇数的最大数字作为中心
   - 如果没有奇数个的数字，且左半部分为空，则使用0作为中心
5. 构造完整的回文数：左半部分 + 中心 + 左半部分的逆序

**时间复杂度**：O(n) - n是字符串长度，统计和构造都是线性时间
**空间复杂度**：O(n) - 存储结果字符数组
**是否最优解**：是，这是处理此类问题的最优解法

### 3. 最大平均通过率

**题目描述**：
一所学校里有一些班级，每个班级里有一些学生，现在每个班都会进行一场期末考试。给你一个二维数组classes，其中classes[i]=[passi, totali]，表示你提前知道了第i个班级总共有totali个学生，其中只有 passi 个学生可以通过考试。给你一个整数extraStudents，表示额外有extraStudents个聪明的学生，一定能通过期末考。你需要给这extraStudents个学生每人都安排一个班级，使得所有班级的平均通过率最大。一个班级的通过率等于这个班级通过考试的学生人数除以这个班级的总人数。平均通过率是所有班级的通过率之和除以班级数目。请你返回在安排这extraStudents个学生去对应班级后的最大平均通过率。

**算法思路**：
1. 贪心策略：每次分配一个学生时，选择能使得通过率提升最大的班级
2. 通过率提升计算：对于班级(a,b)，增加一个学生后通过率提升为 (a+1)/(b+1) - a/b
3. 使用优先队列维护所有班级，按通过率提升量排序
4. 每次取出提升量最大的班级，分配一个学生，然后重新计算提升量并放回队列
5. 重复extraStudents次，最后计算平均通过率

**时间复杂度**：O((n + m) * logn) - n是班级数，m是额外学生数
**空间复杂度**：O(n) - 优先队列的空间
**是否最优解**：是，这是处理此类问题的最优解法

### 4. 雇佣K名工人的最低成本

**题目描述**：
有n名工人，给定两个数组quality和wage，其中quality[i]表示第i名工人的工作质量，其最低期望工资为wage[i]。现在我们想雇佣k名工人组成一个工资组。在雇佣一组k名工人时，我们必须按照下述规则向他们支付工资：对工资组中的每名工人，应当按其工作质量与同组其他工人的工作质量的比例来支付工资。工资组中的每名工人至少应当得到他们的最低期望工资。给定整数k，返回组成满足上述条件的付费群体所需的最小金额。

**算法思路**：
1. 关键洞察：在一组工人中，实际支付比例必须是这组工人中最大的比例（以满足最低期望工资要求）
2. 贪心策略：
   - 按照薪水/质量比例排序
   - 枚举每个工人作为基准（具有最大比例）
   - 在该工人之前选择质量总和最小的k-1个工人
3. 使用最大堆维护当前质量最小的k个工人
4. 遍历排序后的工人，维护堆并计算最小成本

**时间复杂度**：O(n * logn) - 主要是排序和堆操作的复杂度
**空间复杂度**：O(n) - 存储员工数组和堆
**是否最优解**：是，这是处理此类问题的最优解法

### 5. 砍树

**题目描述**：
一共有n棵树，每棵树都有两个信息：第一天这棵树的初始重量、这棵树每天的增长重量。你每天最多能砍1棵树，砍下这棵树的收益为：这棵树的初始重量 + 这棵树增长到这一天的总增重。从第1天开始，你一共有m天可以砍树，返回m天内你获得的最大收益。

**算法思路**：
1. 贪心策略：根据增长速度排序，增长量小的在前，增长量大的在后
2. 动态规划：01背包问题的变种
   - 状态定义：dp[i][j] 表示在j天内，从前i棵树中选若干棵树进行砍伐，最大收益是多少
   - 状态转移：dp[i][j] = max(dp[i-1][j], dp[i-1][j-1] + tree[i][0] + tree[i][1] * (j-1))
   - 初始条件：dp[0][...] = 0, dp[...][0] = 0

**时间复杂度**：O(n * logn + n * m) - 排序和DP的时间复杂度
**空间复杂度**：O(n * m) - DP数组的空间复杂度
**是否最优解**：是，这是处理此类问题的最优解法

### 6. 分发饼干

**题目描述**：
假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。对每个孩子 i，都有一个胃口值 g[i]，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 j，都有一个尺寸 s[j] 。如果 s[j] >= g[i]，我们可以将这个饼干 j 分配给孩子 i，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。

**算法思路**：
1. 贪心策略：优先满足胃口小的孩子
2. 将孩子胃口数组和饼干尺寸数组都排序
3. 用双指针分别遍历两个数组
4. 当前饼干能满足当前孩子时，两个指针都后移
5. 当前饼干不能满足当前孩子时，饼干指针后移，寻找更大的饼干

**时间复杂度**：O(m * logm + n * logn) - m是孩子数量，n是饼干数量，主要是排序的时间复杂度
**空间复杂度**：O(1) - 只使用了常数额外空间
**是否最优解**：是，这是处理此类问题的最优解法

### 7. 买卖股票的最佳时机 II

**题目描述**：
给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

**算法思路**：
1. 贪心策略：只要明天价格比今天高，就在今天买入明天卖出
2. 遍历价格数组，计算相邻两天的价格差
3. 如果价格差为正，则累加到总利润中

**时间复杂度**：O(n) - n是价格数组长度
**空间复杂度**：O(1) - 只使用了常数额外空间
**是否最优解**：是，这是处理此类问题的最优解法

### 8. 跳跃游戏

**题目描述**：
给定一个非负整数数组 nums ，你最初位于数组的第一个下标。数组中的每个元素代表你在该位置可以跳跃的最大长度。判断你是否能够到达最后一个下标。

**算法思路**：
1. 贪心策略：维护能到达的最远位置
2. 遍历数组，更新能到达的最远位置
3. 如果当前位置超过了能到达的最远位置，则无法到达终点
4. 如果能到达的最远位置大于等于最后一个下标，则能到达终点

**时间复杂度**：O(n) - n是数组长度
**空间复杂度**：O(1) - 只使用了常数额外空间
**是否最优解**：是，这是处理此类问题的最优解法

### 9. 无重叠区间

**题目描述**：
给定一个区间的集合，找到需要移除区间的最小数量，使剩余区间互不重叠。

**算法思路**：
1. 贪心策略：按区间结束位置排序，优先选择结束位置早的区间
2. 排序后遍历区间，统计不重叠的区间数量
3. 总区间数减去不重叠区间数就是需要移除的区间数

**时间复杂度**：O(n * logn) - 主要是排序的时间复杂度
**空间复杂度**：O(1) - 只使用了常数额外空间
**是否最优解**：是，这是处理此类问题的最优解法

### 10. 柠檬水找零

**题目描述**：
在柠檬水摊上，每一杯柠檬水的售价为 5 美元。顾客排队购买你的产品，（按账单 bills 支付的顺序）一次购买一杯。每位顾客只买一杯柠檬水，然后向你付 5 美元、10 美元或 20 美元。你必须给每个顾客正确找零，也就是说净交易是每位顾客向你支付 5 美元。注意，一开始你手头没有任何零钱。给你一个整数数组 bills ，其中 bills[i] 是第 i 位顾客付的账。如果你能给每位顾客正确找零，返回 true，否则返回 false。

**算法思路**：
1. 贪心策略：找零时优先使用大面额纸币
2. 维护5美元和10美元纸币的数量
3. 收到5美元：5美元数量加1
4. 收到10美元：5美元数量减1，10美元数量加1
5. 收到20美元：优先用一张10美元和一张5美元找零，如果没有10美元则用三张5美元找零

**时间复杂度**：O(n) - n是数组长度
**空间复杂度**：O(1) - 只使用了常数额外空间
**是否最优解**：是，这是处理此类问题的最优解法

### 11. 合并果子

**题目描述**：
在一个果园里，多多已经将所有的果子打了下来，而且按果子的不同种类分成了不同的堆。多多决定把所有的果子合成一堆。每一次合并，多多可以把两堆果子合并到一起，消耗的体力等于两堆果子的重量之和。可以看出，所有的果子经过 n-1 次合并之后，就只剩下一堆了。多多在合并果子时总共消耗的体力等于每次合并所耗体力之和。因为还要花大力气把这些果子搬回家，所以多多在合并果子时要尽可能地节省体力。假定每个果子重量都为 1，并且已知果子的种类数和每种果子的数目，你的任务是设计出合并的次序方案，使多多耗费的体力最少，并输出这个最小的体力耗费值。

**算法思路**：
1. 贪心策略：哈夫曼编码思想，每次选择重量最小的两堆果子合并
2. 使用最小堆维护所有果子堆
3. 每次取出重量最小的两堆果子合并，合并后的重量重新放入堆中
4. 重复直到只剩下一堆果子，累加合并过程中的体力消耗

**时间复杂度**：O(n * logn) - n是果子种类数
**空间复杂度**：O(n) - 最小堆的空间
**是否最优解**：是，这是处理此类问题的最优解法

### 12. 排队接水

**题目描述**：
有 n 个人在一个水龙头前排队接水，假如每个人接水的时间为 Ti，请编程找出这 n 个人排队的一种顺序，使得 n 个人的平均等待时间最小。一个人的等待时间不包括他的接水时间。

**算法思路**：
1. 贪心策略：按接水时间升序排列
2. 接水时间短的人排在前面，可以减少后面人的等待时间
3. 计算排列后的平均等待时间

**时间复杂度**：O(n * logn) - 主要是排序的时间复杂度
**空间复杂度**：O(n) - 存储排序后的索引
**是否最优解**：是，这是处理此类问题的最优解法

### 13. 纪念品分组

**题目描述**：
元旦快到了，校学生会让乐乐负责新年晚会的纪念品发放工作。为使得参加晚会的同学所获得的纪念品价值相对均衡，他要把购来的纪念品根据价格进行分组，但每组最多只能包括两件纪念品，并且每组纪念品的价格之和不能超过一个给定的整数。为了保证在尽量短的时间内发完所有纪念品，乐乐希望分组的数目最少。你的任务是写一个程序，找出所有分组方案中分组数最少的一种，输出最少的分组数目。

**算法思路**：
1. 贪心策略：排序后使用双指针，最小价格和最大价格配对
2. 将纪念品价格数组排序
3. 使用双指针，左指针指向最小价格，右指针指向最大价格
4. 如果两件纪念品价格之和不超过上限，则分为一组，两个指针都移动
5. 如果超过上限，则最大价格的纪念品单独分为一组，只移动右指针

**时间复杂度**：O(n * logn) - 主要是排序的时间复杂度
**空间复杂度**：O(1) - 只使用了常数额外空间
**是否最优解**：是，这是处理此类问题的最优解法

### 14. 最小绝对差

**题目描述**：
给定一个整数数组，找出数组中任意两个元素之间的最小绝对差。

**算法思路**：
1. 贪心策略：排序后相邻元素的差值最小
2. 将数组排序
3. 遍历相邻元素，计算差值，找出最小值

**时间复杂度**：O(n * logn) - 主要是排序的时间复杂度
**空间复杂度**：O(1) - 只使用了常数额外空间
**是否最优解**：是，这是处理此类问题的最优解法

### 15. 纪念品分组（牛客网版本）

**题目描述**：
与洛谷版本类似，但可能输入输出格式略有不同。

**算法思路**：
与洛谷版本相同，使用贪心策略和双指针。

**时间复杂度**：O(n * logn) - 主要是排序的时间复杂度
**空间复杂度**：O(1) - 只使用了常数额外空间
**是否最优解**：是，这是处理此类问题的最优解法

## 贪心算法深度总结

### 适用场景与核心性质
贪心算法适用于具有以下性质的问题：
1. **贪心选择性质**：所求问题的整体最优解可以通过一系列局部最优的选择得到
2. **最优子结构**：问题的最优解包含其子问题的最优解
3. **无后效性**：当前选择不会影响后续选择的最优性

### 常见题型分类

#### 1. 区间调度类问题
- **特征**：需要选择不重叠的区间或活动
- **解题模板**：按结束时间排序，贪心选择结束最早的
- **典型题目**：
  - 无重叠区间 (LeetCode 435)
  - 用最少数量的箭引爆气球 (LeetCode 452)
  - 合并区间 (LeetCode 56)

#### 2. 资源分配类问题  
- **特征**：有限资源分配给多个任务，最大化收益
- **解题模板**：按单位资源收益排序，贪心分配
- **典型题目**：
  - 分发饼干 (LeetCode 455)
  - 卡车上的最大单元数 (LeetCode 1710)
  - 课程表 III (LeetCode 630)

#### 3. 路径优化类问题
- **特征**：在路径上选择最优停留点或加油点
- **解题模板**：维护当前可达范围，贪心选择最远可达点
- **典型题目**：
  - 跳跃游戏 (LeetCode 55)
  - 加油站 (LeetCode 134)
  - 可以到达的最远建筑 (LeetCode 1642)

#### 4. 字符串处理类问题
- **特征**：重新排列字符串满足特定条件
- **解题模板**：使用单调栈或自定义排序
- **典型题目**：
  - 最大数 (LeetCode 179)
  - 去除重复字母 (LeetCode 316)
  - 移掉K位数字 (LeetCode 402)

#### 5. 数学优化类问题
- **特征**：涉及数值计算和数学性质
- **解题模板**：利用数学性质进行贪心选择
- **典型题目**：
  - 数组拆分 I (LeetCode 561)
  - 最小差值 II (LeetCode 910)
  - 坏了的计算器 (LeetCode 991)

### 工程化考量与优化技巧

#### 1. 异常处理与边界条件
```java
// 输入验证
if (input == null || input.length == 0) return defaultValue;
// 边界条件处理
if (input.length == 1) return specialCaseValue;
```

#### 2. 性能优化策略
- **时间复杂度优化**：选择合适的排序算法（O(n log n)）
- **空间复杂度优化**：使用原地操作或有限额外空间
- **常数项优化**：减少不必要的对象创建和函数调用

#### 3. 调试与测试技巧
- **打印中间过程**：在关键步骤输出变量值
- **小规模测试**：验证算法在简单情况下的正确性
- **边界测试**：测试空输入、极值等特殊情况

### 跨语言实现差异

#### Java语言特性
- 使用 `Arrays.sort()` 进行排序
- 使用 `PriorityQueue` 实现堆
- 面向对象设计，代码结构清晰

#### C++语言特性  
- 使用 `std::sort()` 和 STL算法
- 使用 `priority_queue` 实现堆
- 内存管理需要特别注意

#### Python语言特性
- 使用 `sorted()` 或 `list.sort()` 排序
- 使用 `heapq` 模块实现堆
- 代码简洁，开发效率高

### 算法正确性证明方法

#### 1. 交换论证法
证明任何非贪心选择都可以通过有限次交换转换为贪心选择，且不会降低解的质量。

#### 2. 归纳法证明
- **基础情况**：证明问题规模最小时贪心选择最优
- **归纳步骤**：假设规模为n-1时最优，证明规模为n时也最优

#### 3. 反证法
假设存在更优解，推导出矛盾，从而证明贪心解最优。

### 实战经验总结

#### 1. 题型识别技巧
- 看到"最多"、"最少"、"最大"、"最小"等关键词，考虑贪心
- 问题可以分解为多个相似的子问题，考虑贪心
- 局部最优选择明显且不会影响后续选择，考虑贪心

#### 2. 常见陷阱避免
- **贪心不一定最优**：需要严格证明正确性
- **边界条件遗漏**：特别注意空输入和极端值
- **性能退化**：避免不必要的重复计算

#### 3. 调试定位方法
- **打印关键变量**：在循环中输出中间结果
- **对比暴力解法**：小规模数据下验证正确性
- **性能分析**：使用工具分析时间空间复杂度

### 与其它算法的关系

#### 1. 与动态规划的关系
- **相同点**：都要求问题具有最优子结构
- **不同点**：贪心算法不需要保存所有子问题的解
- **选择依据**：如果贪心选择性质成立，优先选择贪心算法

#### 2. 与分治法的关系
- **相同点**：都将问题分解为子问题
- **不同点**：贪心算法每次选择当前最优，分治法平等处理子问题

#### 3. 与回溯法的关系
- **相同点**：都尝试多种选择
- **不同点**：贪心算法不回溯，回溯法会尝试所有可能

### 高级应用场景

#### 1. 机器学习中的贪心算法
- 决策树构建中的特征选择
- 聚类算法中的初始中心选择
- 神经网络中的层数选择

#### 2. 图像处理中的应用
- 图像分割中的区域生长算法
- 边缘检测中的阈值选择
- 特征提取中的关键点选择

#### 3. 自然语言处理中的应用
- 文本摘要中的句子选择
- 机器翻译中的词汇选择
- 信息检索中的文档排序

### 学习路径建议

#### 初级阶段（掌握基础）
1. 理解贪心算法的核心思想
2. 掌握常见题型的解题模板
3. 完成LeetCode简单和中等级别的题目

#### 中级阶段（深入理解）
1. 学习正确性证明方法
2. 掌握工程化实现技巧
3. 完成LeetCode困难级别的题目

#### 高级阶段（融会贯通）
1. 理解贪心算法的局限性
2. 掌握与其他算法的结合使用
3. 解决实际工程问题

通过系统学习和大量练习，可以熟练掌握贪心算法的设计和应用，为解决复杂问题提供有效的工具。

## 工程化考量

### 异常处理
1. **输入验证**：检查输入参数的有效性
2. **边界条件**：处理空输入、单元素等特殊情况
3. **资源限制**：考虑时间和空间复杂度限制

### 性能优化
1. **排序优化**：选择合适的排序算法
2. **堆优化**：使用优先队列维护动态数据
3. **缓存优化**：避免重复计算

### 可读性
1. **变量命名**：使用有意义的变量名
2. **注释说明**：详细解释算法思路和关键步骤
3. **模块化设计**：将复杂逻辑分解为独立函数

## 相关题目扩展

### LeetCode题目
1. **LeetCode 455. 分发饼干** - https://leetcode.cn/problems/assign-cookies/
2. **LeetCode 122. 买卖股票的最佳时机 II** - https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/
3. **LeetCode 55. 跳跃游戏** - https://leetcode.cn/problems/jump-game/
4. **LeetCode 435. 无重叠区间** - https://leetcode.cn/problems/non-overlapping-intervals/
5. **LeetCode 452. 用最少数量的箭引爆气球** - https://leetcode.cn/problems/minimum-number-of-arrows-to-burst-balloons/
6. **LeetCode 763. 划分字母区间** - https://leetcode.cn/problems/partition-labels/
7. **LeetCode 860. 柠檬水找零** - https://leetcode.cn/problems/lemonade-change/
8. **LeetCode 135. 分发糖果** - https://leetcode.cn/problems/candy/
9. **LeetCode 406. 根据身高重建队列** - https://leetcode.cn/problems/queue-reconstruction-by-height/
10. **LeetCode 871. 最低加油次数** - https://leetcode.cn/problems/minimum-number-of-refueling-stops/

### HackerRank题目
1. **HackerRank - Mark and Toys** - https://www.hackerrank.com/challenges/mark-and-toys
2. **HackerRank - Luck Balance** - https://www.hackerrank.com/challenges/luck-balance
3. **HackerRank - Greedy Florist** - https://www.hackerrank.com/challenges/greedy-florist
4. **HackerRank - Max Min** - https://www.hackerrank.com/challenges/angry-children
5. **HackerRank - Jim and the Orders** - https://www.hackerrank.com/challenges/jim-and-the-orders
6. **HackerRank - Minimum Absolute Difference in an Array** - https://www.hackerrank.com/challenges/minimum-absolute-difference-in-an-array/problem

### 牛客网题目
1. **牛客网 - 疯狂的采药** - https://ac.nowcoder.com/acm/problem/16557
2. **牛客网 - 纪念品分组** - https://ac.nowcoder.com/acm/problem/16722
3. **牛客网 - 均分纸牌** - https://ac.nowcoder.com/acm/problem/16736

### 洛谷题目
1. **洛谷 P1090 - 合并果子** - https://www.luogu.com.cn/problem/P1090
2. **洛谷 P1223 - 排队接水** - https://www.luogu.com.cn/problem/P1223
3. **洛谷 P1094 - 纪念品分组** - https://www.luogu.com.cn/problem/P1094
4. **洛谷 P1803 - 凌乱的yyy / 线段覆盖** - https://www.luogu.com.cn/problem/P1803

### Codeforces题目
1. **Codeforces 1360B - Honest Coach** - https://codeforces.com/problemset/problem/1360/B
2. **Codeforces 1367B - Even Array** - https://codeforces.com/problemset/problem/1367/B
3. **Codeforces 1374B - Multiply by 2, divide by 6** - https://codeforces.com/problemset/problem/1374/B

### ZOJ题目
1. **ZOJ 3211 - Dream City (砍树)** - https://zoj.pintia.cn/problem-sets/91827364500/problems/91827367873

## 复杂度分析

在分析贪心算法的复杂度时，需要考虑：
1. **时间复杂度** - 算法执行所需的时间
2. **空间复杂度** - 算法执行所需的额外空间
3. **是否为最优解** - 是否存在更优的算法

对于本专题中的问题，大多数都已达到理论最优复杂度。

## 总结

贪心算法是算法设计中的一种重要思想，通过局部最优选择来达到全局最优解。在实际应用中，需要仔细分析问题是否满足贪心选择性质和最优子结构性质，并严格证明算法的正确性。通过系统学习和大量练习，可以熟练掌握贪心算法的设计和应用技巧。