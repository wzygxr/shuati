# 纪念品分组 (Souvenir Grouping)
# 元旦快到了，校学生会让乐乐负责新年晚会的纪念品发放工作。
# 为使得参加晚会的同学所获得的纪念品价值相对均衡，他要把购来的纪念品根据价格进行分组，
# 但每组最多只能包括两件纪念品，并且每组纪念品的价格之和不能超过一个给定的整数。
# 为了保证在尽量短的时间内发完所有纪念品，乐乐希望分组的数目最少。
# 你的任务是写一个程序，找出所有分组方案中分组数最少的一种，输出最少的分组数目。
# 
# 算法标签: 贪心算法(Greedy Algorithm)、双指针(Two Pointers)、排序(Sorting)
# 时间复杂度: O(n * logn)，其中n是纪念品数量
# 空间复杂度: O(1)，仅使用常数额外空间
# 测试链接 : https://www.luogu.com.cn/problem/P1094
# 相关题目: LeetCode 11. 盛最多水的容器、LeetCode 167. 两数之和 II
# 贪心算法专题 - 双指针与配对问题集合

"""
算法思路详解：
1. 贪心策略：排序后使用双指针，最小价格和最大价格配对
   - 这个策略的核心思想是让价格差异最大的纪念品配对
   - 如果最便宜和最贵的纪念品能配对，那么其他配对方案都不会更优
   - 这样可以最大化每组的利用效率，从而最小化分组数

2. 将纪念品价格数组排序
   - 排序是应用双指针技术的前提
   - 排序后可以使用左指针指向最小价格，右指针指向最大价格

3. 使用双指针，左指针指向最小价格，右指针指向最大价格
   - 左指针从数组开始向右移动
   - 右指针从数组末尾向左移动
   - 双指针技术能高效地处理配对问题

4. 如果两件纪念品价格之和不超过上限，则分为一组，两个指针都移动
   - 这体现了贪心策略：尽可能让两个纪念品配对
   - 配对成功后，两个指针都向中间移动

5. 如果超过上限，则最大价格的纪念品单独分为一组，只移动右指针
   - 最大价格的纪念品无法与任何其他纪念品配对
   - 只能单独分为一组，右指针向左移动

时间复杂度分析：
- 排序时间复杂度：O(n * logn)，其中n是纪念品数量
- 双指针遍历时间复杂度：O(n)
- 总体时间复杂度：O(n * logn)

空间复杂度分析：
- 排序空间复杂度：O(logn)（取决于排序算法实现）
- 其他变量存储空间：O(1)
- 总体空间复杂度：O(1)

是否最优解：
- 是，这是处理此类问题的最优解法
- 贪心策略保证了局部最优解能导致全局最优解
- 可以通过交换论证法证明其正确性

工程化最佳实践：
1. 异常处理：检查输入是否为空或格式不正确
2. 边界条件：处理空数组、单个元素等特殊情况
3. 性能优化：使用双指针避免重复遍历
4. 可读性：清晰的变量命名和详细注释，便于维护

极端场景与边界情况处理：
1. 空输入：prices为空数组
2. 极端值：只有一件纪念品、所有纪念品价格相同
3. 重复数据：多件纪念品价格相同
4. 有序/逆序数据：纪念品价格按顺序排列

跨语言实现差异与优化：
1. Java：使用Arrays.sort进行排序，性能稳定
2. C++：使用std::sort进行排序，底层实现可能更优化
3. Python：使用sorted函数或list.sort()方法，基于Timsort算法

调试与测试策略：
1. 打印中间过程：在循环中打印当前配对的纪念品和分组情况
2. 用断言验证中间结果：确保每组价格之和不超过上限
3. 性能退化排查：检查排序和遍历的时间复杂度
4. 边界测试：测试空数组、单元素等边界情况

实际应用场景与拓展：
1. 资源分配问题：在资源分配中优化分组策略
2. 推荐系统：用于物品配对推荐
3. 数据挖掘：用于相似物品聚类

算法深入解析：
贪心算法在纪念品分组问题中的应用体现了其核心思想：
1. 局部最优选择：每次选择价格差异最大的纪念品配对
2. 无后效性：当前的选择不会影响之前的状态
3. 最优子结构：问题的最优解包含子问题的最优解
这个问题的关键洞察是，最小价格和最大价格的配对策略能最小化分组数，这可以通过数学证明验证。
"""


def souvenirGrouping(w, prices):
    """
    纪念品分组主函数 - 使用贪心算法和双指针技术计算最少分组数目
    
    算法思路：
    1. 贪心策略：排序后使用双指针，最小价格和最大价格配对
    2. 将纪念品价格数组排序
    3. 使用双指针配对纪念品
    
    Args:
        w (int): 每组纪念品价格之和的上限
        prices (List[int]): 纪念品价格列表
        prices[i]表示第i件纪念品的价格
    
    Returns:
        int: 最少的分组数目
    
    时间复杂度: O(n * logn)，其中n是纪念品数量
    空间复杂度: O(1)，仅使用常数额外空间
    
    Examples:
        >>> souvenirGrouping(10, [1, 2, 3, 4, 5, 6, 7, 8, 9])
        5
        >>> souvenirGrouping(5, [1, 2, 3, 4, 5])
        3
    """
    # 异常处理：检查输入是否为空
    if not prices:
        return 0
    
    # 边界条件：只有一件纪念品
    if len(prices) == 1:
        return 1
    
    # 排序纪念品价格数组
    # 时间复杂度：O(n * logn)
    prices.sort()
    
    left = 0              # 左指针，指向最小价格
    right = len(prices) - 1  # 右指针，指向最大价格
    groups = 0            # 分组数
    
    # 双指针遍历
    # 时间复杂度：O(n)
    while left <= right:
        # 如果两件纪念品价格之和不超过上限
        if prices[left] + prices[right] <= w:
            left += 1     # 最小价格纪念品被分组
        
        # 最大价格纪念品被分组（无论是否与最小价格纪念品配对）
        right -= 1
        groups += 1       # 分组数加1
    
    return groups


# 测试函数
if __name__ == "__main__":
    # 测试用例1：一般情况
    w1 = 10
    prices1 = [1, 2, 3, 4, 5, 6, 7, 8, 9]
    print("测试用例1结果:", souvenirGrouping(w1, prices1))  # 期望输出: 5
    
    # 测试用例2：较小的上限
    w2 = 5
    prices2 = [1, 2, 3, 4, 5]
    print("测试用例2结果:", souvenirGrouping(w2, prices2))  # 期望输出: 3
    
    # 测试用例3：相同价格的纪念品
    w3 = 100
    prices3 = [50, 50, 50, 50]
    print("测试用例3结果:", souvenirGrouping(w3, prices3))  # 期望输出: 2
    
    # 测试用例4：边界情况 - 只有一件纪念品
    w4 = 10
    prices4 = [5]
    print("测试用例4结果:", souvenirGrouping(w4, prices4))  # 期望输出: 1
    
    # 测试用例5：极端情况 - 价格差异很大
    w5 = 15
    prices5 = [1, 1, 1, 1, 1, 10, 10, 10, 10]
    print("测试用例5结果:", souvenirGrouping(w5, prices5))  # 期望输出: 6