# 最小绝对差 (Minimum Absolute Difference)
# 给你一个整数数组，其中数组中任意两个元素之间的绝对差的最小值。
# 
# 算法标签: 贪心算法(Greedy Algorithm)、排序(Sorting)
# 时间复杂度: O(n * logn)，其中n是数组长度
# 空间复杂度: O(1)，仅使用常数额外空间
# 测试链接 : https://www.hackerrank.com/challenges/minimum-absolute-difference-in-an-array/problem
# 相关题目: LeetCode 532. 数组中的K-diff数对、LeetCode 1200. 最小绝对差
# 贪心算法专题 - 排序与差值问题集合

"""
算法思路详解：
1. 贪心策略：排序后相邻元素的差值最小
   - 这个策略的核心思想是经过排序后，最小的绝对差一定出现在相邻元素之间
   - 这是因为对于任意三个元素a ≤ b ≤ c，有|a - c| ≥ |a - b|且|a - c| ≥ |b - c|
   - 因此只需要检查相邻元素的差值即可

2. 将数组排序
   - 排序是应用这个贪心策略的前提
   - 排序后可以保证元素的有序性

3. 遍历相邻元素，计算差值，找出最小值
   - 通过一次遍历完成所有计算
   - 只需要比较相邻元素的差值

时间复杂度分析：
- 排序时间复杂度：O(n * logn)，其中n是数组长度
- 遍历时间复杂度：O(n)
- 总体时间复杂度：O(n * logn)

空间复杂度分析：
- 排序空间复杂度：O(logn)（取决于排序算法实现）
- 其他变量存储空间：O(1)
- 总体空间复杂度：O(1)

是否最优解：
- 是，这是处理此类问题的最优解法
- 贪心策略保证了局部最优解能导致全局最优解
- 可以通过数学证明验证其正确性

工程化最佳实践：
1. 异常处理：检查输入是否为空或格式不正确
2. 边界条件：处理空数组、单个元素等特殊情况
3. 性能优化：一次遍历完成计算，避免重复操作
4. 可读性：清晰的变量命名和详细注释，便于维护

极端场景与边界情况处理：
1. 空输入：arr为空数组
2. 极端值：只有一个元素、所有元素相同
3. 重复数据：多个元素相同
4. 有序/逆序数据：元素按顺序排列

跨语言实现差异与优化：
1. Java：使用Arrays.sort进行排序，性能稳定
2. C++：使用std::sort进行排序，底层实现可能更优化
3. Python：使用sorted函数或list.sort()方法，基于Timsort算法

调试与测试策略：
1. 打印中间过程：在循环中打印相邻元素和差值
2. 用断言验证中间结果：确保差值不为负
3. 性能退化排查：检查排序和遍历的时间复杂度
4. 边界测试：测试空数组、单元素等边界情况

实际应用场景与拓展：
1. 聚类算法：用于计算数据点之间的最小距离
2. 异常检测：用于识别异常值
3. 推荐系统：用于计算用户或物品之间的相似度

算法深入解析：
贪心算法在最小绝对差问题中的应用体现了其核心思想：
1. 局部最优选择：只检查相邻元素的差值
2. 无后效性：当前的选择不会影响之前的状态
3. 最优子结构：问题的最优解包含子问题的最优解
这个问题的关键洞察是，排序后最小绝对差一定出现在相邻元素之间，这可以通过三角不等式证明。
"""


def minimumAbsoluteDifference(arr):
    """
    最小绝对差主函数 - 使用贪心算法计算数组中任意两个元素之间的绝对差的最小值
    
    算法思路：
    1. 贪心策略：排序后相邻元素的差值最小
    2. 将数组排序
    3. 遍历相邻元素，计算差值，找出最小值
    
    Args:
        arr (List[int]): 整数数组
        arr[i]表示数组中的第i个元素
    
    Returns:
        int: 数组中任意两个元素之间的绝对差的最小值
    
    时间复杂度: O(n * logn)，其中n是数组长度
    空间复杂度: O(1)，仅使用常数额外空间
    
    Examples:
        >>> minimumAbsoluteDifference([3, -7, 0])
        3
        >>> minimumAbsoluteDifference([-59, -36, -13, 1, -53, -92, -2, -96, -54, 75])
        1
    """
    # 异常处理：检查输入是否为空
    if not arr:
        return 0
    
    # 边界条件：只有一个元素
    if len(arr) == 1:
        return 0
    
    # 排序数组
    # 时间复杂度：O(n * logn)
    arr.sort()
    
    # 初始化最小绝对差为最大值
    min_diff = float('inf')
    
    # 遍历相邻元素，计算差值，找出最小值
    # 时间复杂度：O(n)
    for i in range(1, len(arr)):
        diff = arr[i] - arr[i - 1]
        if diff < min_diff:
            min_diff = diff
    
    return min_diff


# 测试函数
if __name__ == "__main__":
    # 测试用例1：一般情况
    arr1 = [3, -7, 0]
    print("测试用例1结果:", minimumAbsoluteDifference(arr1))  # 期望输出: 3
    
    # 测试用例2：负数数组
    arr2 = [-59, -36, -13, 1, -53, -92, -2, -96, -54, 75]
    print("测试用例2结果:", minimumAbsoluteDifference(arr2))  # 期望输出: 1
    
    # 测试用例3：正数数组
    arr3 = [1, -3, 71, 68, 17]
    print("测试用例3结果:", minimumAbsoluteDifference(arr3))  # 期望输出: 3
    
    # 测试用例4：边界情况 - 只有一个元素
    arr4 = [5]
    print("测试用例4结果:", minimumAbsoluteDifference(arr4))  # 期望输出: 0
    
    # 测试用例5：相同元素 - 最小差值为0
    arr5 = [1, 1, 1, 1]
    print("测试用例5结果:", minimumAbsoluteDifference(arr5))  # 期望输出: 0