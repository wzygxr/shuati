package class094;

import java.util.Arrays;

// 分发饼干 (Assign Cookies)
// 假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。
// 对每个孩子 i，都有一个胃口值 g[i]，这是能让孩子们满足胃口的饼干的最小尺寸；
// 并且每块饼干 j，都有一个尺寸 s[j] 。
// 如果 s[j] >= g[i]，我们可以将这个饼干 j 分配给孩子 i ，这个孩子会得到满足。
// 你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。
// 
// 算法标签: 贪心算法(Greedy Algorithm)、双指针(Two Pointers)、排序(Sorting)
// 时间复杂度: O(m*log(m) + n*log(n))，其中m是孩子数量，n是饼干数量
// 空间复杂度: O(1)，仅使用常数额外空间
// 测试链接 : https://leetcode.cn/problems/assign-cookies/
// 相关题目: LeetCode 452. 用最少数量的箭引爆气球、LeetCode 763. 划分字母区间
// 贪心算法专题 - 补充题目收集与详解

/*
 * 题目解析：
 * 这是一个经典的贪心算法应用场景——资源分配问题。要求在有限的资源（饼干）下满足尽可能多的需求（孩子）。
 * 问题的核心在于如何制定最优的分配策略以最大化满足的孩子数。
 * 
 * 关键约束条件：
 * 1. 每个孩子最多只能分配一块饼干
 * 2. 饼干尺寸必须大于等于孩子胃口值才能满足该孩子
 * 3. 目标是最优化满足的孩子总数
 *
 * 解题思路与策略：
 * 1. 贪心策略核心思想：优先满足胃口小的孩子，这样能够节省大饼干去满足胃口大的孩子
 * 2. 排序预处理：对孩子胃口数组g和饼干尺寸数组s都进行升序排序
 * 3. 双指针匹配：使用双指针技术分别遍历孩子和饼干数组，实现高效的匹配过程
 * 4. 资源优化利用：通过贪心策略避免资源浪费，确保每块饼干都能发挥最大价值
 *
 * 算法正确性证明：
 * 贪心选择性质：对于胃口最小的孩子，选择能满足他的最小饼干是最优选择
 * 最优子结构：在满足了一个孩子后，剩余问题仍具有相同的最优子结构性质
 */
public class Code06_AssignCookies {

	/*
	 * 算法思路详解：
	 * 1. 贪心策略核心：优先满足胃口小的孩子，这样能够保留大饼干给胃口大的孩子
	 * 2. 排序预处理：对两个数组进行升序排序，为贪心策略实施奠定基础
	 * 3. 双指针遍历：使用child指针遍历孩子数组，cookie指针遍历饼干数组
	 * 4. 匹配逻辑：当s[cookie] >= g[child]时，当前饼干可满足当前孩子
	 * 5. 指针更新规则：
	 *    - 若能匹配：child和cookie指针都向前移动一位
	 *    - 若不能匹配：仅cookie指针向前移动，寻找更大尺寸的饼干
	 *
	 * 时间复杂度分析：
	 * - 排序阶段：O(m*log(m) + n*log(n))，其中m是孩子数量，n是饼干数量
	 * - 遍历阶段：O(m + n)，双指针只需各遍历一次
	 * - 总体时间复杂度：O(m*log(m) + n*log(n))
	 * 空间复杂度分析：
	 * - O(1)，仅使用了常数级别的额外空间存储指针和临时变量
	 * 是否最优解：是，基于贪心策略和排序的解决方案是处理此类问题的最优方法
	 *
	 * 工程化最佳实践：
	 * 1. 输入验证：严格检查输入参数的有效性，防止空指针异常
	 * 2. 边界处理：妥善处理各种边界情况，如空数组、单元素等
	 * 3. 性能优化：采用双指针技术避免不必要的重复遍历
	 * 4. 代码可读性：使用语义明确的变量名和详尽的注释
	 * 5. 内存管理：避免创建不必要的对象和数组
	 *
	 * 极端场景与边界情况处理：
	 * 1. 空输入场景：g或s为空数组时直接返回0
	 * 2. 极值场景：只有一个孩子或一块饼干的特殊情况
	 * 3. 重复数据场景：多个孩子胃口相同或多个饼干尺寸相同时的处理
	 * 4. 特殊序列场景：孩子胃口和饼干尺寸均为有序或逆序的情况
	 * 5. 不均匀分布场景：孩子胃口跨度大而饼干尺寸集中的情况
	 *
	 * 跨语言实现差异与优化：
	 * 1. Java实现：使用Arrays.sort进行原地排序，时间复杂度稳定
	 * 2. C++实现：使用std::sort，通常采用内省排序(Introsort)算法
	 * 3. Python实现：使用内置sorted函数或list.sort()方法，基于Timsort算法
	 * 4. 内存管理：不同语言的垃圾回收机制对性能的影响
	 *
	 * 调试与测试策略：
	 * 1. 过程可视化：在关键节点打印指针状态和匹配结果
	 * 2. 断言验证：在循环体内添加断言确保算法不变式成立
	 * 3. 性能监控：跟踪排序和遍历的实际执行时间
	 * 4. 边界测试：设计覆盖所有边界条件的测试用例
	 * 5. 压力测试：使用大规模数据验证算法稳定性
	 *
	 * 实际应用场景与拓展：
	 * 1. 资源调度：CPU任务分配、内存分配等系统级资源调度问题
	 * 2. 电商推荐：商品库存与用户需求的最佳匹配
	 * 3. 教育资源分配：课程容量与学生选课偏好的合理安排
	 * 4. 医疗资源分配：病床数量与患者病情紧急程度的匹配
	 * 5. 交通运输：车辆载重与货物重量的最优装载方案
	 *
	 * 算法深入解析：
	 * 1. 排序策略原理：升序排列确保优先处理小胃口和小尺寸
	 * 2. 匹配原则依据：小饼干优先满足小胃口避免资源浪费
	 * 3. 指针移动逻辑：
	 *    - 成功匹配：child++, cookie++（当前孩子已被满足）
	 *    - 匹配失败：仅cookie++（寻找更大饼干满足当前孩子）
	 * 4. 结果统计机制：child指针的位置即为满足的孩子数量
	 */
	public static int findContentChildren(int[] g, int[] s) {
		// 异常处理：检查输入是否为空
		if (g == null || s == null) {
			return 0;
		}
		
		// 边界条件：没有孩子或没有饼干
		if (g.length == 0 || s.length == 0) {
			return 0;
		}
		
		// 排序孩子胃口数组和饼干尺寸数组
		// 贪心策略的基础：排序后优先满足小胃口和使用小饼干
		Arrays.sort(g); // 对孩子胃口值升序排列
		Arrays.sort(s); // 对饼干尺寸升序排列
		
		int child = 0;    // 孩子指针，指向当前待满足的孩子
		int cookie = 0;   // 饼干指针，指向当前待分配的饼干
		
		// 双指针遍历
		// 当还有孩子未尝试满足且还有饼干未尝试分配时继续循环
		while (child < g.length && cookie < s.length) {
			// 如果当前饼干能满足当前孩子
			// 贪心策略：优先满足能用当前饼干满足的孩子
			if (s[cookie] >= g[child]) {
				child++;   // 满足的孩子数加1，移动到下一个孩子
			}
			cookie++;      // 饼干指针后移，尝试下一块饼干
		}
		
		return child;      // 返回满足的孩子数
	}
	
	// 测试函数
	public static void main(String[] args) {
		// 测试用例1：基本情况
		// 3个孩子胃口值为[1,2,3]，2块饼干尺寸为[1,1]
		// 只能满足胃口为1的孩子
		int[] g1 = {1, 2, 3};
		int[] s1 = {1, 1};
		System.out.println("测试用例1结果: " + findContentChildren(g1, s1)); // 期望输出: 1
		
		// 测试用例2：资源充足
		// 2个孩子胃口值为[1,2]，3块饼干尺寸为[1,2,3]
		// 能满足所有孩子
		int[] g2 = {1, 2};
		int[] s2 = {1, 2, 3};
		System.out.println("测试用例2结果: " + findContentChildren(g2, s2)); // 期望输出: 2
		
		// 测试用例3：边界情况
		// 没有孩子，有饼干
		// 应该返回0
		int[] g3 = {};
		int[] s3 = {1, 2, 3};
		System.out.println("测试用例3结果: " + findContentChildren(g3, s3)); // 期望输出: 0
		
		// 测试用例4：极端情况
		// 孩子胃口都很大，饼干尺寸相对较小
		// 只能满足胃口为7和8的孩子
		int[] g4 = {10, 9, 8, 7};
		int[] s4 = {5, 6, 7, 8};
		System.out.println("测试用例4结果: " + findContentChildren(g4, s4)); // 期望输出: 2
	}

	// 补充题目1: LeetCode 452. 用最少数量的箭引爆气球 (Minimum Number of Arrows to Burst Balloons)
	// 题目描述: 有一些球形气球贴在一堵用XY平面表示的墙面上。墙面上的气球记录在整数数组points，
	// 其中points[i] = [xstart, xend]表示水平直径在xstart和xend之间的气球。
	// 你不知道气球的确切y坐标。一支弓箭可以沿着x轴从不同点完全垂直地射出。
	// 在坐标x处射出一支箭，若有一个气球的直径的开始和结束坐标为xstart，xend，
	// 且满足xstart ≤ x ≤ xend，则该气球会被引爆。
	// 可以射出的弓箭的数量没有限制。弓箭一旦被射出之后，可以无限地前进。
	// 我们想找到使得所有气球全部被引爆，所需的弓箭的最小数量。
	// 
	// 算法标签: 贪心算法(Greedy Algorithm)、区间问题(Interval Problem)、排序(Sorting)
	// 时间复杂度: O(n*log(n))，其中n是气球数量
	// 空间复杂度: O(1)，仅使用常数额外空间
	// 链接: https://leetcode.cn/problems/minimum-number-of-arrows-to-burst-balloons/
	/*
	 * 算法详解与策略分析：
	 * 1. 贪心策略核心思想：按结束位置排序，优先处理结束位置早的气球，
	 *    这样可以保证箭射出的位置尽可能多地引爆重叠的气球
	 * 2. 区间覆盖原理：通过一支箭引爆多个重叠区间，实现资源的最大化利用
	 * 3. 优化选择机制：当遇到不重叠的气球区间时，必须使用新箭
	 * 4. 结果统计方法：通过计数器记录所需箭的数量
	 *
	 * 算法步骤详解：
	 * 1. 预处理：按气球结束位置升序排序
	 * 2. 初始化：设置箭数计数器为1，记录第一支箭的最远射程
	 * 3. 遍历过程：
	 *    - 若当前气球起始位置超出箭的最远射程：需要新箭
	 *    - 若当前气球起始位置在箭的射程内：当前箭可引爆
	 * 4. 结果返回：返回累计的箭数
	 *
	 * 算法正确性证明：
	 * 贪心选择性质：选择结束位置最早的气球作为当前处理对象是最优的
	 * 最优子结构：在确定一支箭的位置后，剩余问题仍具有相同的最优子结构
	 */
	public static int findMinArrowShots(int[][] points) {
		// 异常处理：检查输入是否为空
		if (points == null || points.length == 0) {
			return 0;
		}
		
		// 按气球结束位置排序
		// 贪心策略的基础：按结束位置升序排列
		Arrays.sort(points, (a, b) -> Integer.compare(a[1], b[1]));
		
		int arrows = 1;     // 箭数计数器，至少需要1支箭
		int end = points[0][1]; // 当前箭能射到的最远位置
		
		// 贪心策略：尽可能用一支箭射更多的气球
		// 遍历所有气球
		for (int i = 1; i < points.length; i++) {
			// 如果当前气球的起始位置大于箭的最远射程
			// 说明需要新的箭来射这个气球
			if (points[i][0] > end) {
				// 需要新的箭
				arrows++;           // 箭数加1
				end = points[i][1]; // 更新箭的最远射程
			}
			// 如果当前气球的起始位置小于等于箭的最远射程
			// 说明当前箭可以射到这个气球，不需要额外操作
		}
		
		return arrows; // 返回需要的最少箭数
	}

	// 补充题目2: LeetCode 763. 划分字母区间 (Partition Labels)
	// 题目描述: 字符串 S 由小写字母组成。我们要把这个字符串划分为尽可能多的片段，
	// 同一字母最多出现在一个片段中。返回一个表示每个字符串片段的长度的列表。
	// 
	// 算法标签: 贪心算法(Greedy Algorithm)、字符串处理(String Processing)、哈希表(HashMap)
	// 时间复杂度: O(n)，其中n是字符串长度
	// 空间复杂度: O(1)，使用固定大小数组存储字符位置
	// 链接: https://leetcode.cn/problems/partition-labels/
	/*
	 * 算法详解与策略分析：
	 * 1. 预处理优化：通过一次遍历记录每个字符最后出现的位置，
	 *    为后续贪心决策提供数据支持
	 * 2. 贪心策略核心：动态扩展当前片段边界，确保包含所有相关字符
	 * 3. 分段判断条件：当遍历到当前位置等于当前片段最远边界时进行分段
	 * 4. 结果收集机制：计算并记录每个片段的长度
	 *
	 * 算法步骤详解：
	 * 1. 预处理阶段：遍历字符串，记录每个字符最后出现的位置
	 * 2. 贪心扩展过程：
	 *    - 维护当前片段的起始和结束位置
	 *    - 动态更新结束位置为当前字符最后位置与当前结束位置的最大值
	 *    - 当遍历位置等于结束位置时，完成一个片段的划分
	 * 3. 结果生成：计算片段长度(end-start+1)并添加到结果列表
	 *
	 * 算法正确性分析：
	 * 贪心选择性质：每次选择能包含所有相关字符的最短片段是最优的
	 * 最优子结构：划分完一个片段后，剩余字符串的最优划分仍保持最优性
	 */
	public static java.util.List<Integer> partitionLabels(String s) {
		// 结果列表，存储每个片段的长度
		java.util.List<Integer> result = new java.util.ArrayList<>();
		// 异常处理：检查输入是否为空
		if (s == null || s.isEmpty()) {
			return result;
		}
		
		// 记录每个字符最后出现的位置
		// 数组索引对应字母a-z，值为该字母最后出现的位置
		int[] lastPos = new int[26];
		for (int i = 0; i < s.length(); i++) {
			// 记录字符s.charAt(i)最后出现的位置
			lastPos[s.charAt(i) - 'a'] = i;
		}
		
		int start = 0, end = 0; // 当前片段的起始和结束位置
		// 贪心策略：扩展片段直到包含所有字符的最后出现位置
		// 遍历字符串中的每个字符
		for (int i = 0; i < s.length(); i++) {
			// 更新当前片段的结束位置
			// 选择当前片段结束位置和当前字符最后位置的最大值
			end = Math.max(end, lastPos[s.charAt(i) - 'a']);
			
			// 如果当前位置等于当前片段的结束位置
			// 说明当前片段已经包含了所有需要的字符
			if (i == end) {
				// 找到一个完整片段
				// 添加片段长度到结果列表
				result.add(end - start + 1);
				// 更新下一个片段的起始位置
				start = end + 1;
			}
		}
		
		return result; // 返回每个片段的长度列表
	}

	// 补充题目3: LeetCode 135. 分发糖果 (Candy)
	// 题目描述: n 个孩子站成一排。给你一个整数数组 ratings 表示每个孩子的评分。
	// 你需要按照以下要求，给这些孩子分发糖果：
	// 1. 每个孩子至少分配到 1 个糖果。
	// 2. 相邻两个孩子评分更高的孩子会获得更多的糖果。
	// 请你给每个孩子分发糖果，计算并返回需要准备的最少糖果数目。
	// 
	// 算法标签: 贪心算法(Greedy Algorithm)、两次遍历(Two Pass)、动态规划思想(DP Thinking)
	// 时间复杂度: O(n)，其中n是孩子数量
	// 空间复杂度: O(n)，需要额外数组存储每个孩子的糖果数
	// 链接: https://leetcode.cn/problems/candy/
	/*
	 * 算法详解与策略分析：
	 * 1. 两次遍历策略：通过从左到右和从右到左两次遍历，
	 *    分别处理左右相邻约束条件
	 * 2. 左遍历目的：确保评分高的右孩子比左孩子获得更多糖果
	 * 3. 右遍历目的：确保评分高的左孩子比右孩子获得更多糖果
	 * 4. 结果合并方法：对每个孩子取两次遍历结果的最大值
	 *
	 * 算法步骤详解：
	 * 1. 初始化阶段：为每个孩子分配1个糖果作为基础
	 * 2. 左遍历过程：
	 *    - 从左到右检查相邻孩子
	 *    - 若右孩子评分高于左孩子，则右孩子糖果数=左孩子糖果数+1
	 * 3. 右遍历过程：
	 *    - 从右到左检查相邻孩子
	 *    - 若左孩子评分高于右孩子，则左孩子糖果数=max(当前值, 右孩子糖果数+1)
	 * 4. 结果统计：累加所有孩子的糖果数
	 *
	 * 算法优化与正确性：
	 * 贪心策略有效性：每次只考虑局部最优约束，最终达到全局最优
	 * 空间优化可能：可优化为O(1)空间复杂度的单次遍历算法
	 */
	public static int candy(int[] ratings) {
		// 异常处理：检查输入是否为空
		if (ratings == null || ratings.length == 0) {
			return 0;
		}
		
		int n = ratings.length; // 孩子数量
		// 糖果数组，存储每个孩子分到的糖果数
		int[] candies = new int[n];
		
		// 初始化：每个孩子至少1个糖果
		for (int i = 0; i < n; i++) {
			candies[i] = 1;
		}
		
		// 从左到右：处理右孩子评分高于左孩子的情况
		// 确保评分高的右孩子比左孩子获得更多糖果
		for (int i = 1; i < n; i++) {
			// 如果右孩子评分高于左孩子
			if (ratings[i] > ratings[i - 1]) {
				// 右孩子糖果数 = 左孩子糖果数 + 1
				candies[i] = candies[i - 1] + 1;
			}
		}
		
		// 从右到左：处理左孩子评分高于右孩子的情况，取较大值
		// 确保评分高的左孩子比右孩子获得更多糖果
		for (int i = n - 2; i >= 0; i--) {
			// 如果左孩子评分高于右孩子
			if (ratings[i] > ratings[i + 1]) {
				// 左孩子糖果数 = max(当前糖果数, 右孩子糖果数 + 1)
				// 取较大值确保同时满足左右两个方向的约束
				candies[i] = Math.max(candies[i], candies[i + 1] + 1);
			}
		}
		
		// 计算总和
		// 统计所有孩子分到的糖果总数
		int total = 0;
		for (int candy : candies) {
			total += candy;
		}
		
		return total; // 返回需要准备的最少糖果数目
	}

	// 补充题目4: LeetCode 406. 根据身高重建队列 (Queue Reconstruction by Height)
	// 题目描述: 假设有打乱顺序的一群人站成一个队列，数组 people 表示队列中一些人的属性（不一定按顺序）。
	// 每个 people[i] = [hi, ki] 表示第 i 个人的身高为 hi ，前面 正好 有 ki 个身高大于或等于 hi 的人。
	// 请你重新构造并返回输入数组 people 所表示的队列。
	// 返回的队列应该格式化为数组 queue ，其中 queue[j] = [hj, kj] 是队列中第 j 个人的属性（queue[0] 是排在队列前面的人）。
	// 
	// 算法标签: 贪心算法(Greedy Algorithm)、排序(Sorting)、链表插入(Linked List Insertion)
	// 时间复杂度: O(n²)，其中n是人数
	// 空间复杂度: O(n)，使用List存储结果
	// 链接: https://leetcode.cn/problems/queue-reconstruction-by-height/
	/*
	 * 算法详解与策略分析：
	 * 1. 排序策略原理：身高降序确保先处理高个子，k值升序确保相同身高时正确插入
	 * 2. 贪心策略核心：按排序后的顺序依次插入，利用高个子对矮个子不可见的特性
	 * 3. 插入位置确定：k值即为在当前队列中的插入位置
	 * 4. 数据结构选择：使用List支持动态插入操作
	 *
	 * 算法步骤详解：
	 * 1. 排序阶段：
	 *    - 按身高降序排列
	 *    - 身高相同时按k值升序排列
	 * 2. 插入过程：
	 *    - 依次处理排序后的人群
	 *    - 将当前人插入到结果列表的p[1]位置
	 *    - p[1]表示前面应该有p[1]个身高大于或等于当前人的人
	 * 3. 结果生成：将List转换为数组返回
	 *
	 * 算法正确性证明：
	 * 贪心选择性质：先处理高个子可以确保后续插入的矮个子不影响前面的排列
	 * 最优子结构：每一步插入都保持了当前队列的正确性
	 */
	public static int[][] reconstructQueue(int[][] people) {
		// 异常处理：检查输入是否为空
		if (people == null || people.length == 0) {
			return new int[0][0];
		}
		
		// 按身高降序，k升序排序
		// 贪心策略的基础：先处理高个子，再处理矮个子
		Arrays.sort(people, (a, b) -> {
			if (a[0] != b[0]) {
				return b[0] - a[0]; // 身高降序排列
			} else {
				return a[1] - b[1]; // k值升序排列
			}
		});
		
		// 结果列表，使用List支持动态插入操作
		java.util.List<int[]> result = new java.util.ArrayList<>();
		
		// 贪心策略：按排序后的顺序插入到指定位置
		// 遍历排序后的人群
		for (int[] p : people) {
			// 将当前人插入到结果列表的p[1]位置
			// p[1]表示前面应该有p[1]个身高大于或等于当前人的人
			result.add(p[1], p);
		}
		
		// 将List转换为数组并返回
		return result.toArray(new int[result.size()][]);
	}

	// 补充题目5: LeetCode 871. 最低加油次数 (Minimum Number of Refueling Stops)
	// 题目描述: 汽车从起点出发驶向目的地，该目的地位于出发位置东面 target 英里处。
	// 沿途有加油站，每个 station[i] 代表一个加油站，位于出发位置东面 station[i][0] 英里处，
	// 并且有 station[i][1] 升汽油。
	// 假设汽车油箱的容量是无限的，其中最初有 startFuel 升燃料。
	// 它每行驶 1 英里就会用掉 1 升汽油。
	// 当汽车到达加油站时，它可能停下来加油，将所有汽油从加油站转移到汽车中。
	// 为了到达目的地，汽车所必要的最低加油次数是多少？如果无法到达目的地，则返回 -1。
	// 
	// 算法标签: 贪心算法(Greedy Algorithm)、优先队列(Priority Queue)、过程模拟(Simulation)
	// 时间复杂度: O(n*log(n))，其中n是加油站数量
	// 空间复杂度: O(n)，最大堆存储经过的加油站
	// 链接: https://leetcode.cn/problems/minimum-number-of-refueling-stops/
	/*
	 * 算法详解与策略分析：
	 * 1. 贪心策略核心：在油不够时选择油量最多的加油站进行加油，
	 *    这样可以最大化单次加油带来的行驶距离
	 * 2. 数据结构选择：使用最大堆维护经过但未加油的加油站，
	 *    便于快速获取油量最多的加油站
	 * 3. 过程模拟机制：模拟汽车行驶过程，动态管理油量和加油决策
	 * 4. 优化选择原理：优先选择油量最多的加油站，减少加油次数
	 *
	 * 算法步骤详解：
	 * 1. 初始化阶段：
	 *    - 创建最大堆存储经过的加油站油量
	 *    - 初始化当前油量、加油次数和上一个位置
	 * 2. 遍历过程：
	 *    - 计算到达当前加油站需要消耗的油量
	 *    - 若油量不足，从堆中取出油量最多的加油站加油
	 *    - 将当前加油站油量加入堆中
	 * 3. 目的地处理：
	 *    - 计算从最后一个加油站到目的地的油耗
	 *    - 若油量不足继续从堆中加油
	 * 4. 结果返回：
	 *    - 若能到达目的地返回加油次数
	 *    - 否则返回-1
	 *
	 * 算法正确性与优化：
	 * 贪心选择性质：每次选择油量最多的加油站是最优决策
	 * 算法优化：可使用动态规划方法作为替代方案进行对比
	 */
	public static int minRefuelStops(int target, int startFuel, int[][] stations) {
		// 最大堆，存储经过的加油站的汽油量
		// 使用自定义比较器(a, b) -> b - a实现最大堆
		java.util.PriorityQueue<Integer> maxHeap = new java.util.PriorityQueue<>((a, b) -> b - a);
		
		int fuel = startFuel; // 当前油量，初始值为起始油量
		int stops = 0;        // 加油次数计数器
		int prev = 0;         // 上一个位置，初始为起点
		
		// 处理所有加油站
		// 遍历所有加油站，模拟行驶过程
		for (int i = 0; i < stations.length; i++) {
			int location = stations[i][0]; // 当前加油站位置
			int gas = stations[i][1];      // 当前加油站油量
			
			// 从当前位置到加油站需要的油量
			// 消耗的油量 = 距离 = 当前加油站位置 - 上一个位置
			fuel -= location - prev;
			
			// 如果油量不足，需要从之前经过的加油站中选择油量最多的加油
			// 贪心策略：在油不够时选择油量最多的加油站
			while (fuel < 0 && !maxHeap.isEmpty()) {
				// 从堆中取出油量最多的加油站加油
				fuel += maxHeap.poll();
				stops++; // 加油次数加1
			}
			
			// 如果无法到达当前加油站，返回-1
			// 说明即使把所有经过的加油站都加了油也不够
			if (fuel < 0) {
				return -1;
			}
			
			// 将当前加油站的油量加入堆中
			// 表示经过了这个加油站，可以在需要时加油
			maxHeap.offer(gas);
			prev = location; // 更新上一个位置
		}
		
		// 处理从最后一个加油站到目的地
		// 消耗从最后一个加油站到目的地的油量
		fuel -= target - prev;
		
		// 如果油量不足，继续从堆中选择加油站加油
		while (fuel < 0 && !maxHeap.isEmpty()) {
			fuel += maxHeap.poll();
			stops++;
		}
		
		// 如果最终油量非负，返回加油次数；否则返回-1
		return fuel >= 0 ? stops : -1;
	}
}