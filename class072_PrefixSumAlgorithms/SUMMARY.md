# 前缀和算法全面总结

## 核心思想

前缀和是一种重要的算法技巧，通过预处理数组的累积和，可以快速回答区间查询问题。其核心思想是空间换时间，通过预计算来加速查询。

## 基本形式

### 一维前缀和
```
prefix[i] = nums[0] + nums[1] + ... + nums[i]
// 或者
prefix[0] = 0
prefix[i] = nums[0] + nums[1] + ... + nums[i-1]
```

区间和计算：
```
sum(i, j) = prefix[j+1] - prefix[i]  // 对应第二种定义
// 或者
sum(i, j) = prefix[j] - prefix[i-1]  // 对应第一种定义
```

### 二维前缀和
```
prefix[i][j] = sum of all elements in rectangle from (0,0) to (i-1,j-1)
```

区域和计算（容斥原理）：
```
sum((r1,c1), (r2,c2)) = prefix[r2+1][c2+1] - prefix[r1][c2+1] - prefix[r2+1][c1] + prefix[r1][c1]
```

## 常见题型及解法

### 1. 基础前缀和
**特点**：直接计算区间和
**技巧**：预处理前缀和数组，O(1)时间查询
**代表题目**：
- 区域和检索 - 数组不可变 (LeetCode 303)
- 一维数组的动态和 (LeetCode 1480)
- 找到数组中心索引 (LeetCode 724)
- 区间和查询 - 不可变 (LeetCode 303)
- 二维区域和检索 - 不可变 (LeetCode 304)

### 2. 哈希表 + 前缀和
**特点**：查找满足特定条件的子数组
**技巧**：用哈希表记录前缀和的状态，通过数学变换找到目标条件
**关键变换**：
- 和为k的子数组：sum[j] - sum[i] = k → sum[i] = sum[j] - k
- 和为0的子数组：sum[j] = sum[i]
- 和可被K整除：(sum[j] - sum[i]) % K = 0 → sum[j] % K = sum[i] % K

**代表题目**：
- 和为K的子数组 (LeetCode 560)
- 连续数组 (LeetCode 525)
- 和可被K整除的子数组 (LeetCode 974)
- 找到和为零的子数组 (LintCode 138)
- 连续的子数组和 (LeetCode 523)

### 3. 特殊映射 + 前缀和
**特点**：需要将原问题转换为前缀和问题
**技巧**：通过适当的映射将问题转化为前缀和形式
**常见映射**：
- 0/1数组 → -1/1数组（便于处理相等数量问题）
- 字符状态 → 位运算状态（处理奇偶性问题）

**代表题目**：
- 连续数组 (LeetCode 525)：0→-1, 1→1
- 每个元音包含偶数次的最长子字符串 (LeetCode 1371)：元音状态用位运算表示
- 表现良好的最长时间段 (LeetCode 1124)：>8→1, ≤8→-1

### 4. 前缀积及其他运算
**特点**：使用乘法或其他运算替代加法
**技巧**：左右扫描分别计算前缀和后缀，避免使用除法
**代表题目**：
- 除自身以外数组的乘积 (LeetCode 238)

## 关键技巧总结

### 1. 哈希表的初始化
```
// 和相关问题
map.put(0, 1);  // 表示空前缀和为0出现1次

// 位置相关问题
map.put(0, -1); // 表示前缀和0最早出现在位置-1
```

### 2. 负数取模处理
```java
int remainder = sum % K;
if (remainder < 0) {
    remainder += K;
}
```

### 3. 状态压缩
对于有限状态问题（如元音字母奇偶性），使用位运算压缩状态：
```java
// 5个元音字母用5位二进制表示奇偶性
int status = 0;
status ^= (1 << k);  // 切换第k位的状态
```

## 时间与空间复杂度

| 类型 | 时间复杂度 | 空间复杂度 |
|------|------------|------------|
| 基础前缀和 | O(n)预处理，O(1)查询 | O(n) |
| 哈希表+前缀和 | O(n) | O(n) |
| 前缀积 | O(n) | O(1)（不计输出数组） |

## 工程化考虑

### 1. 边界条件处理
- 空数组/空指针检查
- 单元素数组处理
- 整数溢出检查

### 2. 优化技巧
- 复用输出数组减少空间使用
- 使用静态数组避免动态内存分配（在大小确定的情况下）
- 选择合适的数据结构（HashMap vs Array）

### 3. 可读性增强
- 详细注释说明数学变换过程
- 变量命名清晰表达含义
- 分步骤实现，便于调试

## 面试要点

### 1. 本质理解
- 前缀和本质上是缓存思想的应用
- 通过预计算避免重复计算
- 哈希表用于快速查找历史状态

### 2. 问题识别
能在以下场景中识别出前缀和的适用性：
- 区间查询问题
- 子数组和相关问题
- 需要统计满足特定和条件的子数组个数或长度

### 3. 变体处理
- 能处理一维到二维的扩展
- 能处理加法到其他运算的扩展
- 能处理直接计算到需要数学变换的扩展

## 学习路径建议

1. **基础掌握**：熟练实现一维、二维前缀和，理解其原理
2. **典型应用**：掌握和为K的子数组、找到数组中心索引、连续的子数组和等经典题目
3. **变体练习**：练习各种变体，如和可被K整除、状态压缩等
4. **综合应用**：在更复杂问题中识别和应用前缀和技巧
5. **工程实践**：关注边界处理、性能优化等工程化细节

## 常见误区

1. **忽略边界**：忘记处理空数组、单元素等情况
2. **负数取模**：Java中负数取模结果为负，需要特殊处理
3. **状态表示**：状态压缩时位运算使用错误
4. **初始化错误**：哈希表初始化值不正确导致结果错误
5. **溢出问题**：大数运算时未考虑整数溢出

通过系统学习和练习这些前缀和相关题目，可以建立起对这一重要算法技巧的全面理解，并能在实际面试和工程中灵活应用。