#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""
分成k份的最大乘积 - 贪心算法

题目描述：
一个数字n一定要分成k份，得到的乘积尽量大是多少。
数字n和k，可能非常大，到达10^12规模，结果可能更大，所以返回结果对 1000000007 取模。

解题思路：
1. 要使乘积最大，各份数字应尽可能接近
2. 最优策略是让每份的值尽可能相等
3. 当n不能被k整除时，余数部分需要分配给某些份数，使其值为n/k+1

数学原理：
- 设每份的基础值为 a = n/k
- 余数为 b = n%k
- 则有b份的值为a+1，有k-b份的值为a
- 最大乘积为 (a+1)^b * a^(k-b)

时间复杂度：O(log n) - 快速幂的时间复杂度
空间复杂度：O(1)

相关题目：
- 类似于均值不等式的应用
- 大厂笔试真题
"""


def power(x, n, mod):
    """
    快速幂运算，用于计算大数幂次方并取模
    
    Args:
        x: 底数
        n: 指数
        mod: 模数
    
    Returns:
        (x^n) % mod 的结果
    """
    ans = 1
    while n > 0:
        # 如果n的最低位为1，则将当前x乘入结果
        if (n & 1) == 1:
            ans = (ans * x) % mod
        # x自乘，相当于指数翻倍
        x = (x * x) % mod
        # n右移一位，相当于指数除以2
        n >>= 1
    return ans


def max_value2(n, k):
    """
    贪心解法（最优解）
    
    Args:
        n: 总数
        k: 要分成的份数
    
    Returns:
        最大乘积对1000000007取模的结果
    """
    mod = 1000000007
    a = n // k  # 每份的基础值
    b = n % k   # 余数
    
    # b份的值为a+1，k-b份的值为a
    part1 = power(a + 1, b, mod)  # (a+1)的b次方
    part2 = power(a, k - b, mod)  # a的(k-b)次方
    
    # 返回结果：(a+1)^b * a^(k-b) 对mod取模
    return (part1 * part2) % mod


# 测试代码
if __name__ == "__main__":
    # 测试用例
    print(max_value2(10, 3))  # 应该输出 36 (4*3*3)
    print(max_value2(15, 4))  # 应该输出 162 (4*4*4*3)