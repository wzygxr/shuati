# Class090 贪心算法专题

## 概述

Class090主要涵盖贪心算法相关的经典问题和解法。贪心算法是一种在每一步选择中都采取在当前状态下最好或最优（即最有利）的选择，从而希望导致结果是全局最好或最优的算法策略。

## 已有题目

### 1. 砍竹子 II (Code01_CuttingBamboo.java)
- **问题描述**: 将一根长为正整数bamboo_len的竹子砍为若干段，每段长度均为正整数，返回每段竹子长度的最大乘积
- **解法**: 数学优化 + 快速幂
- **时间复杂度**: O(log n)
- **空间复杂度**: O(1)

### 2. 分成k份的最大乘积 (Code02_MaximumProduct.java)
- **问题描述**: 一个数字n一定要分成k份，得到的乘积尽量大是多少
- **解法**: 贪心策略，尽可能平均分配
- **时间复杂度**: O(log k)
- **空间复杂度**: O(1)

### 3. 会议安排问题 (Code03_MeetingMonopoly1.java, Code03_MeetingMonopoly2.java)
- **问题描述**: 给定若干会议的开始、结束时间，你参加某个会议的期间，不能参加其他会议，返回你能参加的最大会议数量
- **解法**: 贪心策略，按结束时间排序，优先选择结束时间早的会议
- **时间复杂度**: O(n log n) (普通情况) / O(n) (特殊大数据情况)
- **空间复杂度**: O(1) (特殊大数据情况)

### 4. 会议只占一天的最大会议数量 (Code04_MeetingOneDay.java)
- **问题描述**: 给定若干会议的开始、结束时间，任何会议的召开期间，你只需要抽出1天来参加
- **解法**: 贪心策略 + 堆，按开始时间排序，使用最小堆维护结束时间
- **时间复杂度**: O(n log n)
- **空间复杂度**: O(n)

### 5. IPO问题 (Code05_IPO.java)
- **问题描述**: 从给定项目中选择最多k个不同项目的列表，以最大化最终资本
- **解法**: 贪心策略 + 双堆，一个小根堆维护被锁住的项目，一个大根堆维护被解锁的项目
- **时间复杂度**: O(n log n)
- **空间复杂度**: O(n)

### 6. 加入差值绝对值直到长度固定 (Code06_AbsoluteValueAddToArray.java)
- **问题描述**: 给定一个非负数组arr，计算任何两个数差值的绝对值，如果arr中没有，都要加入到arr里
- **解法**: 数学优化，利用最大公约数性质
- **时间复杂度**: O(n log(max))
- **空间复杂度**: O(n)

## 新增题目

### 7. 分发饼干 (Code07_AssignCookies.java, Code07_AssignCookies.py, Code07_AssignCookies.cpp)
- **问题描述**: 每个孩子都有一个胃口值，每块饼干都有一个尺寸，如果饼干尺寸大于等于孩子胃口值，可以满足该孩子
- **解法**: 贪心策略，对孩子胃口值和饼干尺寸都按升序排序，使用双指针技术
- **时间复杂度**: O(m log m + n log n)
- **空间复杂度**: O(1)

### 8. 跳跃游戏 (Code08_JumpGame.java, Code08_JumpGame.py)
- **问题描述**: 给定一个非负整数数组，判断是否能够到达最后一个下标
- **解法**: 贪心策略，维护能到达的最远位置
- **时间复杂度**: O(n)
- **空间复杂度**: O(1)

### 9. 柠檬水找零 (Code09_LemonadeChange.java, Code09_LemonadeChange.py)
- **问题描述**: 每杯柠檬水售价5美元，顾客支付5、10或20美元，需要正确找零
- **解法**: 贪心策略，维护手中5美元和10美元的数量，找零时优先使用10美元+5美元组合
- **时间复杂度**: O(n)
- **空间复杂度**: O(1)

### 10. 买卖股票的最佳时机 II (Code10_BestTimeToBuyAndSellStockII.java, Code10_BestTimeToBuyAndSellStockII.py)
- **问题描述**: 给你一个整数数组 prices ，其中 prices[i] 表示某支股票第 i 天的价格。在每一天，你可以决定是否购买和/或出售股票。你在任何时候 最多 只能持有 一股 股票。你也可以先购买，然后在 同一天 出售。返回 你能获得的最大利润。
- **解法**: 贪心策略，只要第二天的价格比今天高，就在今天买入明天卖出
- **时间复杂度**: O(n)
- **空间复杂度**: O(1)

### 11. 跳跃游戏 II (Code11_JumpGameII.java, Code11_JumpGameII.py)
- **问题描述**: 给你一个长度为 n 的 0 索引整数数组 nums。初始位置为 nums[0]。每个元素 nums[i] 表示从索引 i 向前跳转的最大长度。返回到达 nums[n - 1] 的最小跳跃次数。
- **解法**: 贪心策略，在当前能到达的范围内，选择下一步能跳得最远的位置
- **时间复杂度**: O(n)
- **空间复杂度**: O(1)

### 12. 最大子数组和 (Code12_MaximumSubarray.java, Code12_MaximumSubarray.py)
- **问题描述**: 给你一个整数数组 nums ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。
- **解法**: 贪心策略，维护当前子数组的和，如果为负数则舍弃
- **时间复杂度**: O(n)
- **空间复杂度**: O(1)

### 13. 无重叠区间 (Code13_NonOverlappingIntervals.java, Code13_NonOverlappingIntervals.py)
- **问题描述**: 给定一个区间的集合 intervals ，其中 intervals[i] = [starti, endi] 。返回需要移除区间的最小数量，使剩余区间互不重叠。
- **解法**: 贪心策略，按区间右端点升序排序，优先选择右边界小的区间
- **时间复杂度**: O(n log n)
- **空间复杂度**: O(1)

### 14. 种花问题 (Code14_CanPlaceFlowers.java, Code14_CanPlaceFlowers.py)
- **问题描述**: 假设有一个很长的花坛，一部分地块种植了花，另一部分却没有。可是，花不能种植在相邻的地块上，它们会争夺水源，两者都会死去。给你一个整数数组 flowerbed 表示花坛，由若干 0 和 1 组成，其中 0 表示没种植花，1 表示种植了花。另有一个数 n ，能否在不打破种植规则的情况下种入 n 朵花？
- **解法**: 贪心策略，从左到右遍历花坛，在可以种花的位置就种一朵
- **时间复杂度**: O(n)
- **空间复杂度**: O(1)

### 15. 用最少数量的箭引爆气球 (Code15_MinimumNumberOfArrowsToBurstBalloons.java, Code15_MinimumNumberOfArrowsToBurstBalloons.py)
- **问题描述**: 有一些球形气球贴在一堵用 XY 平面表示的墙面上。墙面上的气球记录在整数数组 points ，其中 points[i] = [xstart, xend] 表示水平直径在 xstart 和 xend 之间的气球。你不知道气球的确切 y 坐标。一支弓箭可以沿着 x 轴从不同点完全垂直地射出。在坐标 x 处射出一支箭，若有一个气球的直径的开始和结束坐标为 xstart，xend，且满足 xstart ≤ x ≤ xend，则该气球会被引爆。给你一个数组 points ，返回引爆所有气球所必须射出的最小弓箭数。
- **解法**: 贪心策略，将气球按右端点升序排序，尽可能多地引爆重叠的气球
- **时间复杂度**: O(n log n)
- **空间复杂度**: O(1)

### 16. 根据身高重建队列 (Code16_QueueReconstructionByHeight.java, Code16_QueueReconstructionByHeight.py)
- **问题描述**: 假设有打乱顺序的一群人站成一个队列，数组 people 表示队列中一些人的属性（不一定按顺序）。每个 people[i] = [hi, ki] 表示第 i 个人的身高为 hi ，前面正好有 ki 个身高大于或等于 hi 的人。请你重新构造并返回输入数组 people 所表示的队列。
- **解法**: 贪心策略，先安排身高高的人，再安排身高矮的人
- **时间复杂度**: O(n^2)
- **空间复杂度**: O(n)

### 17. 划分字母区间 (Code17_PartitionLabels.java, Code17_PartitionLabels.py)
- **问题描述**: 字符串 S 由小写字母组成。我们要把这个字符串划分为尽可能多的片段，同一字母最多出现在一个片段中。返回一个表示每个字符串片段的长度的列表。
- **解法**: 贪心策略，记录每个字母最后出现的位置，尽可能早地划分区间
- **时间复杂度**: O(n)
- **空间复杂度**: O(1)

### 18. 分发糖果 (Code18_Candy.java, Code18_Candy.py)
- **问题描述**: n 个孩子站成一排。给你一个整数数组 ratings 表示每个孩子的评分。你需要按照以下要求，给这些孩子分发糖果：每个孩子至少分配到 1 个糖果。相邻两个孩子评分更高的孩子会获得更多的糖果。请你给每个孩子分发糖果，计算并返回需要准备的最少糖果数目。
- **解法**: 贪心策略，两次遍历分别处理左右邻居的约束
- **时间复杂度**: O(n)
- **空间复杂度**: O(n)

### 19. 合并果子 (Code19_MergeFruits.java, Code19_MergeFruits.py, Code19_MergeFruits.cpp)
- **问题描述**: 在一个果园里，多多已经将所有的果子打了下来，而且按果子的不同种类分成了不同的堆。多多决定把所有的果子合成一堆。每一次合并，多多可以把两堆果子合并到一起，消耗的体力等于两堆果子的重量之和。多多想尽可能节省体力，让你计算出最小的体力消耗值。
- **解法**: 贪心策略 + 优先队列，每次选择最小的两堆果子进行合并
- **时间复杂度**: O(n log n)
- **空间复杂度**: O(n)

### 20. 加油站 (Code20_GasStation.java, Code20_GasStation.py, Code20_GasStation.cpp)
- **问题描述**: 在一条环路上有 n 个加油站，其中第 i 个加油站有汽油 gas[i] 升。你有一辆油箱容量无限的汽车，从第 i 个加油站开往第 i+1 个加油站需要消耗汽油 cost[i] 升。你从其中一个加油站出发，开始时油箱为空。给定两个整数数组 gas 和 cost，如果你可以按顺序绕环路行驶一周，则返回出发时加油站的编号，否则返回 -1。
- **解法**: 贪心策略，计算总油量和总消耗，同时维护当前油箱状态和起始站点
- **时间复杂度**: O(n)
- **空间复杂度**: O(1)

### 21. 移除K个数字 (Code21_RemoveKDigits.java, Code21_RemoveKDigits.py, Code21_RemoveKDigits.cpp)
- **问题描述**: 给定一个以字符串表示的非负整数 num，移除这个数中的 k 位数字，使得剩下的数字最小。输出不能含有前导零，但如果结果为0，必须保留这个零。
- **解法**: 贪心策略 + 栈，维护一个递增序列，遇到较小数字时移除前面较大的数字
- **时间复杂度**: O(n)
- **空间复杂度**: O(n)

### 22. 摆动序列 (Code22_WiggleSubsequence.java, Code22_WiggleSubsequence.py, Code22_WiggleSubsequence.cpp)
- **问题描述**: 如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为摆动序列。给定一个整数数组 nums ，返回 nums 中作为摆动序列的最长子序列的长度。
- **解法**: 贪心策略，统计波峰和波谷的数量，波峰和波谷的数量加1就是最长摆动序列的长度
- **时间复杂度**: O(n)
- **空间复杂度**: O(1)

### 23. 单调递增的数字 (Code23_MonotoneIncreasingDigits.java, Code23_MonotoneIncreasingDigits.py, Code23_MonotoneIncreasingDigits.cpp)
- **问题描述**: 当且仅当每个相邻位数上的数字 x 和 y 满足 x <= y 时，我们称这个整数是单调递增的。给定一个整数 n ，返回 小于或等于 n 的最大数字，且数字呈单调递增。
- **解法**: 贪心策略，从右向左遍历数字，找到第一个不满足单调递增的位置，将该位置减1，并将后面的所有数字都设为9
- **时间复杂度**: O(d)，其中d是数字的位数
- **空间复杂度**: O(d)

### 24. 任务调度器 (Code24_TaskScheduler.java, Code24_TaskScheduler.py, Code24_TaskScheduler.cpp)
- **问题描述**: 给定一个用字符数组 tasks 表示的 CPU 需要执行的任务列表。每个字母表示一种不同种类的任务。两个相同种类的任务之间必须有长度为整数 n 的冷却时间。返回完成所有任务所需要的最短时间。
- **解法**: 贪心策略，优先安排出现次数最多的任务，使用最大堆来存储任务频率
- **时间复杂度**: O(n log k)，其中k是任务种类数
- **空间复杂度**: O(k)

### 25. 救生艇 (Code25_BoatsToSavePeople.java, Code25_BoatsToSavePeople.py, Code25_BoatsToSavePeople.cpp)
- **问题描述**: 给定数组 people ，people[i]表示第 i 个人的体重，船的数量不限，每艘船可以承载的最大重量为 limit。每艘船最多可同时载两人，但条件是这些人的重量之和最多为 limit。返回承载所有人所需的最小船数。
- **解法**: 贪心策略，将人的体重按升序排序，使用双指针，让最重的人尽量和最轻的人配对
- **时间复杂度**: O(n log n)
- **空间复杂度**: O(1)

### 26. 最低加油次数 (Code26_MinimumNumberOfRefuelingStops.java, Code26_MinimumNumberOfRefuelingStops.py, Code26_MinimumNumberOfRefuelingStops.cpp)
- **问题描述**: 汽车从起点出发驶向目的地，该目的地位于起点正东 target 英里处。沿途有加油站，每个加油站有汽油。假设汽车油箱的容量是无限的，其中最初有 startFuel 升燃料。它每行驶 1 英里就会用掉 1 升汽油。为了到达目的地，汽车所必要的最低加油次数是多少？
- **解法**: 贪心策略，使用最大堆来存储经过的加油站的油量，当油量不足以到达下一个加油站时，从堆中取出最大的油量进行加油
- **时间复杂度**: O(n log n)
- **空间复杂度**: O(n)

### 27. 重构字符串 (Code27_ReorganizeString.java, Code27_ReorganizeString.py, Code27_ReorganizeString.cpp)
- **问题描述**: 给定一个字符串 s ，检查是否能重新排布其中的字母，使得两相邻的字符不同。如果可以，输出任意可行的结果。如果不可行，返回空字符串。
- **解法**: 贪心策略，使用最大堆存储字符及其频率，每次取出频率最高的两个字符交替放置
- **时间复杂度**: O(n log k)，其中k是字符种类数
- **空间复杂度**: O(k)

### 28. 最大交换 (Code28_MaximumSwap.java, Code28_MaximumSwap.py, Code28_MaximumSwap.cpp)
- **问题描述**: 给定一个非负整数，你至多可以交换一次数字中的任意两位。返回你能得到的最大值。
- **解法**: 贪心策略，记录每个数字最后出现的位置，从左到右遍历，对于每个位置尝试用后面最大的数字替换
- **时间复杂度**: O(n)，其中n是数字的位数
- **空间复杂度**: O(n)

## 贪心算法特点

### 适用场景
1. **最优子结构**: 问题的最优解包含子问题的最优解
2. **贪心选择性质**: 全局最优解可通过局部贪心选择得到
3. **无后效性**: 状态转移后，历史信息不会影响后续决策

### 经典题型
1. **区间问题**: 会议安排、跳跃游戏等
2. **分配问题**: 分发饼干、任务调度等
3. **找零问题**: 柠檬水找零、硬币找零等
4. **数学优化**: 砍竹子、最大乘积等
5. **序列问题**: 最大子数组和、股票买卖等
6. **图论相关**: 最小生成树、最短路径等

### 贪心策略
1. **选择排序码**: 按照某种顺序排序后处理
2. **优先队列**: 使用堆维护当前最优选择
3. **双指针**: 在两个有序序列中进行匹配
4. **数学规律**: 利用数学性质直接计算结果
5. **局部最优**: 在每一步选择中都采取当前状态下最好或最优的选择

## 工程化考虑

### 异常处理
1. **边界条件**: 空数组、单元素等特殊情况
2. **非法输入**: 检查输入数据的合法性
3. **溢出处理**: 大数运算时注意整数溢出

### 性能优化
1. **提前终止**: 满足条件时提前返回结果
2. **数据预处理**: 排序等操作为贪心策略做准备
3. **空间优化**: 尽量使用常数额外空间
4. **算法选择**: 根据数据规模选择合适的贪心策略

### 代码质量
1. **变量命名**: 见名知意，提高代码可读性
2. **注释完整**: 详细解释算法思路和关键步骤
3. **模块化**: 将复杂逻辑拆分为独立函数
4. **测试覆盖**: 包含正常、边界和异常情况的测试用例

## 复杂度分析

### 时间复杂度
- **排序相关**: O(n log n)
- **线性遍历**: O(n)
- **堆操作**: O(log n)每次操作
- **数学运算**: O(log n)快速幂等
- **嵌套循环**: O(n^2)

### 空间复杂度
- **原地操作**: O(1)
- **辅助数组**: O(n)
- **递归深度**: O(log n)到O(n)

## 测试验证

所有Java、C++和Python代码均已通过测试用例验证，包括:
1. **正常情况**: 标准输入输出测试
2. **边界情况**: 空数组、单元素等
3. **复杂情况**: 大数据量、特殊数据分布
4. **极端情况**: 极值输入、重复数据等

## 学习建议

1. **掌握经典题型**: 熟练解决区间、分配、找零等经典问题
2. **理解贪心策略**: 深入理解每种贪心策略的适用场景和正确性证明
3. **多语言实现**: 通过Java、C++、Python等不同语言实现加深理解
4. **复杂度分析**: 准确分析算法的时间和空间复杂度
5. **工程化实践**: 注重代码质量、异常处理和性能优化
6. **举一反三**: 通过练习相似题目加深理解