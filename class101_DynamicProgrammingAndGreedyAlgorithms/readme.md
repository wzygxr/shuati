# Class087 算法专题：动态规划与贪心算法综合应用

## 目录
- [题目概览](#题目概览)
- [算法核心思想](#算法核心思想)
- [时间复杂度分析](#时间复杂度分析)
- [空间复杂度分析](#空间复杂度分析)
- [最优解证明](#最优解证明)
- [类似题目扩展](#类似题目扩展)
- [工程化考量](#工程化考量)
- [调试技巧](#调试技巧)
- [面试要点](#面试要点)

## 题目概览

### 1. 贿赂怪兽问题 (Code01_BuyMonster)
**题目来源**: 牛客网
**题目链接**: https://www.nowcoder.com/practice/736e12861f9746ab8ae064d4aae2d5a9

**问题描述**:
- 开始时你的能力是0，目标是从0号怪兽开始，通过所有的n只怪兽
- 如果当前能力小于i号怪兽的能力，必须付出b[i]的钱贿赂这个怪兽
- 如果当前能力大于等于i号怪兽的能力，可以选择直接通过或贿赂
- 返回通过所有怪兽需要花的最小钱数

**核心算法**: 动态规划
- 方法1: 基于金钱数的DP，时间复杂度O(n×∑b[i])
- 方法2: 基于能力值的DP，时间复杂度O(n×∑a[i])

### 2. 选择数字使集合和相差最小 (Code02_PickNumbersClosedSum)
**题目来源**: 大厂笔试真题

**问题描述**:
- 给定正数n和k，从1~n中选择k个数字组成集合A，剩下数字组成集合B
- 希望集合A和集合B的累加和相差不超过1
- 返回集合A选择的数字，如果无法做到返回空数组

**核心算法**: 数学构造 + 贪心算法
- 时间复杂度: O(k)
- 空间复杂度: O(k)

### 3. 两个排列的最长公共子序列 (Code03_PermutationLCS)
**题目来源**: 洛谷P1439
**题目链接**: https://www.luogu.com.cn/problem/P1439

**问题描述**:
- 给出由1~n这些数字组成的两个排列
- 求它们的最长公共子序列长度

**核心算法**: 最长递增子序列(LIS)的变形
- 时间复杂度: O(n log n)
- 空间复杂度: O(n)

### 4. 使数组严格递增的最小操作数 (Code04_MakeArrayStrictlyIncreasing)
**题目来源**: LeetCode 1187
**题目链接**: https://leetcode.cn/problems/make-array-strictly-increasing/

**问题描述**:
- 给定两个整数数组arr1和arr2
- 通过将arr1中的元素替换为arr2中的元素，使arr1严格递增
- 返回最小操作数，如果无法做到返回-1

**核心算法**: 动态规划 + 二分查找
- 时间复杂度: O(n² log m)
- 空间复杂度: O(n)

## 算法核心思想

### 动态规划的关键思路
1. **状态定义**: 明确dp数组的含义
2. **状态转移**: 找到状态之间的递推关系
3. **边界条件**: 处理初始状态和终止状态
4. **空间优化**: 使用滚动数组或一维数组优化

### 贪心算法的适用场景
1. **最优子结构**: 问题可以分解为子问题
2. **贪心选择性质**: 局部最优解能导致全局最优解
3. **无后效性**: 当前选择不影响后续选择

## 时间复杂度分析

| 题目 | 最优时间复杂度 | 空间复杂度 | 是否最优解 |
|------|---------------|------------|------------|
| 贿赂怪兽 | O(min(n×∑b[i], n×∑a[i])) | O(min(∑b[i], ∑a[i])) | 是 |
| 选择数字 | O(k) | O(k) | 是 |
| 排列LCS | O(n log n) | O(n) | 是 |
| 数组递增 | O(n² log m) | O(n) | 是 |

## 空间复杂度分析

所有算法都进行了空间优化：
- 使用一维数组代替二维数组
- 及时释放不需要的内存
- 利用滚动数组技术

## 最优解证明

### 贿赂怪兽问题
**最优性证明**:
- 方法1和方法2分别针对不同的数据范围
- 当b[i]范围较小时，方法1更优
- 当a[i]范围较小时，方法2更优
- 两种方法覆盖了所有可能的数据分布

### 选择数字问题
**最优性证明**:
- 基于数学构造，直接给出最优解
- 通过贪心选择确保和差最小
- 构造方法的时间复杂度达到理论下界

## 类似题目扩展

### 1. 分割等和子集 (LeetCode 416)
**题目链接**: https://leetcode.com/problems/partition-equal-subset-sum/
**核心算法**: 0-1背包问题

### 2. 目标和 (LeetCode 494)
**题目链接**: https://leetcode.com/problems/target-sum/
**核心算法**: 动态规划求方案数

### 3. 最长公共子序列 (LeetCode 1143)
**题目链接**: https://leetcode.com/problems/longest-common-subsequence/
**核心算法**: 经典LCS问题

### 4. 编辑距离 (LeetCode 72)
**题目链接**: https://leetcode.com/problems/edit-distance/
**核心算法**: 字符串编辑动态规划

## 工程化考量

### 1. 异常处理
```java
// 边界条件检查
if (arr1 == null || arr1.length == 0) {
    return 0;
}
```

### 2. 内存优化
- 使用基本数据类型代替包装类
- 及时释放大数组
- 避免不必要的对象创建

### 3. 性能优化
- 预处理排序操作
- 使用二分查找加速搜索
- 空间换时间策略

## 调试技巧

### 1. 打印中间变量
```java
System.out.println("i=" + i + ", j=" + j + ", dp=" + dp[i][j]);
```

### 2. 断言验证
```java
assert i >= 0 && i < n : "索引越界";
```

### 3. 单元测试
```java
@Test
public void testCase1() {
    int[] arr1 = {1, 5, 3, 6, 7};
    int[] arr2 = {1, 3, 2, 4};
    int result = makeArrayIncreasing(arr1, arr2);
    assertEquals(1, result);
}
```

## 面试要点

### 1. 算法理解深度
- 能够解释状态转移方程的含义
- 理解时间复杂度的推导过程
- 掌握空间优化的方法

### 2. 代码实现能力
- 写出简洁高效的代码
- 处理边界条件和异常情况
- 进行必要的优化

### 3. 问题扩展能力
- 能够将问题扩展到类似场景
- 理解算法的局限性
- 提出改进方案

## 总结

本专题涵盖了动态规划和贪心算法的核心应用场景，通过四个经典问题展示了算法设计的精髓。掌握这些算法不仅有助于解决具体问题，更能培养系统的算法思维和工程实现能力。

**关键收获**:
1. 理解不同DP状态定义对性能的影响
2. 掌握贪心算法的证明方法
3. 学会根据数据特征选择最优算法
4. 培养工程化的代码实现习惯

通过大量练习和深入思考，可以真正掌握这些算法的本质，并在实际工程和面试中灵活应用。