# 贪心算法专题 (Class 091)

## 专题概述

贪心算法是一种在每一步选择中都采取在当前状态下最好或最优（即最有利）的选择，从而希望导致结果是全局最好或最优的算法。贪心算法在有最优子结构的问题中尤为有效。

## 核心算法题目

### 1. 最短无序连续子数组 (Code01)
- **题目**: 找到需要排序的最短子数组
- **来源**: LeetCode 581
- **算法**: 贪心 + 双指针
- **复杂度**: O(n) 时间, O(1) 空间

### 2. 最小范围 (Code02)
- **题目**: 在k个列表中找到最小范围
- **来源**: LeetCode 632
- **算法**: 贪心 + 堆
- **复杂度**: O(nlogk) 时间, O(k) 空间

### 3. 团体购票问题 (Code03)
- **题目**: 团体购票最优策略
- **算法**: 贪心选择
- **复杂度**: O(nlogn) 时间, O(n) 空间

## 补充贪心算法题目

### 27. 任务调度器 (Code27)
- **题目**: CPU任务调度，相同任务需要间隔n个时间单位
- **来源**: LeetCode 621
- **算法**: 贪心 + 频率统计
- **复杂度**: O(n) 时间, O(1) 空间
- **关键点**: 频率最高的任务决定最小时间

### 28. 柠檬水找零 (Code28)
- **题目**: 柠檬水摊找零问题
- **来源**: LeetCode 860
- **算法**: 贪心找零策略
- **复杂度**: O(n) 时间, O(1) 空间
- **关键点**: 优先使用大面额找零

### 29. 重构字符串 (Code29)
- **题目**: 重新排列字符串使相邻字符不同
- **来源**: LeetCode 767
- **算法**: 贪心 + 最大堆
- **复杂度**: O(n) 时间, O(1) 空间
- **关键点**: 频率最高的字符间隔放置

### 30. 视频拼接 (Code30)
- **题目**: 用最少的视频片段覆盖整个时间段
- **来源**: LeetCode 1024
- **算法**: 贪心区间覆盖
- **复杂度**: O(nlogn) 时间, O(1) 空间
- **关键点**: 按起点排序，选择能覆盖最远的片段

### 31. 划分数组为连续子序列 (Code31)
- **题目**: 判断数组是否能被划分为连续递增子序列
- **来源**: LeetCode 659
- **算法**: 贪心 + 哈希表
- **复杂度**: O(n) 时间, O(n) 空间
- **关键点**: 维护以每个数字结尾的序列

### 32. 单调递增的数字 (Code32)
- **题目**: 找到不大于N的最大单调递增数字
- **来源**: LeetCode 738
- **算法**: 贪心 + 数字处理
- **复杂度**: O(d) 时间, O(d) 空间 (d为数字位数)
- **关键点**: 从右向左找到第一个递减的位置

### 33. 移掉K位数字 (Code33)
- **题目**: 移除k位数字使剩下的数字最小
- **来源**: LeetCode 402
- **算法**: 贪心 + 单调栈
- **复杂度**: O(n) 时间, O(n) 空间
- **关键点**: 维护单调递增栈

### 34. 加油站 (Code34)
- **题目**: 环形路线上找到能绕行一周的加油站
- **来源**: LeetCode 134
- **算法**: 贪心 + 一次遍历
- **复杂度**: O(n) 时间, O(1) 空间
- **关键点**: 总油量必须大于总消耗

### 35. 摆动序列 (Code35)
- **题目**: 找到最长摆动子序列长度
- **来源**: LeetCode 376
- **算法**: 贪心 + 状态机
- **复杂度**: O(n) 时间, O(1) 空间
- **关键点**: 统计趋势变化的次数

### 36. 跳跃游戏 (Code36)
- **题目**: 判断是否能从起点跳到终点
- **来源**: LeetCode 55
- **算法**: 贪心 + 最远可达位置
- **复杂度**: O(n) 时间, O(1) 空间
- **关键点**: 维护当前能到达的最远位置

## 贪心算法核心思想

### 1. 贪心选择性质
- 每一步都做出在当前看来最好的选择
- 不依赖于未来的选择，也不依赖于子问题的解

### 2. 最优子结构
- 问题的最优解包含其子问题的最优解
- 贪心算法通常以自顶向下的方式解决问题

## 适用场景识别

### 适合使用贪心算法的问题特征：
1. **最优子结构**: 问题可以分解为子问题
2. **贪心选择性质**: 局部最优导致全局最优
3. **无后效性**: 当前选择不影响后续选择

### 典型问题类型：
- **区间调度问题**: 选择不重叠的区间
- **背包问题**: 分数背包（物品可分割）
- **哈夫曼编码**: 数据压缩
- **最小生成树**: Prim和Kruskal算法
- **最短路径**: Dijkstra算法

## 算法实现技巧

### 1. 排序预处理
- 很多贪心问题需要先对数据进行排序
- 排序依据：开始时间、结束时间、权重等

### 2. 优先队列使用
- 动态获取当前最优选择
- 适用于需要频繁获取最小/最大值的场景

### 3. 双指针技巧
- 处理区间或数组问题时常用
- 一个指针遍历，另一个指针标记关键位置

## 复杂度分析模式

### 时间复杂度：
- **排序主导**: O(nlogn)
- **线性扫描**: O(n)
- **堆操作**: O(nlogk)

### 空间复杂度：
- **原地操作**: O(1)
- **辅助数据结构**: O(n)
- **递归调用**: O(n)

## 边界情况处理

### 常见边界：
1. **空输入**: 返回默认值
2. **单元素**: 直接返回结果
3. **全相同元素**: 特殊处理
4. **极端值**: 大数、负数、零值

### 错误处理：
- 输入验证
- 数组越界检查
- 数值溢出防护

## 测试策略

### 单元测试覆盖：
1. **正常用例**: 典型输入
2. **边界用例**: 最小/最大输入
3. **特殊用例**: 全相同、有序、逆序
4. **性能测试**: 大规模数据

### 验证方法：
- 多解法对比验证
- 边界值测试
- 随机数据测试

## 工程化考量

### 1. 代码可读性
- 清晰的变量命名
- 适当的注释说明
- 模块化的函数设计

### 2. 性能优化
- 避免不必要的计算
- 使用合适的数据结构
- 提前终止条件

### 3. 可维护性
- 易于扩展的架构
- 清晰的错误处理
- 完整的测试覆盖

## 学习资源

### 推荐练习平台：
- LeetCode (力扣)
- LintCode (炼码)
- HackerRank
- AtCoder
- Codeforces

### 经典教材：
- 《算法导论》
- 《编程珠玑》
- 《算法竞赛入门经典》

## 总结

贪心算法是解决最优化问题的重要工具，掌握其核心思想和适用场景对于算法能力的提升至关重要。通过大量练习和总结，能够更好地识别何时使用贪心算法以及如何设计有效的贪心策略。