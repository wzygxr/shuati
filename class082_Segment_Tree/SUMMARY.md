# Class109 算法题目总结

## 主要算法和数据结构

Class109主要涉及以下算法和数据结构：

1. **树状数组（Fenwick Tree/Binary Indexed Tree）**
2. **归并排序及其应用**
3. **离散化技术**
4. **动态规划优化**

## 题目列表及解析

### 1. 逆序对问题
- **相关文件**: Code01_NumberOfReversePair1.java, Code01_NumberOfReversePair2.java
- **题目**: 给定一个数组，求逆序对的数量
- **解法**: 归并排序
- **时间复杂度**: O(n log n)
- **空间复杂度**: O(n)

### 2. 升序三元组数量
- **相关文件**: Code02_IncreasingTriples.java
- **题目**: 求升序三元组(i,j,k)满足i<j<k且arr[i]<arr[j]<arr[k]的数量
- **解法**: 树状数组
- **时间复杂度**: O(n log n)
- **空间复杂度**: O(n)

### 3. 最长递增子序列的个数
- **相关文件**: Code03_NumberOfLIS.java
- **题目**: 求最长递增子序列的个数
- **解法**: 树状数组优化动态规划
- **时间复杂度**: O(n log n)
- **空间复杂度**: O(n)

### 4. HH的项链（区间不同元素个数查询）
- **相关文件**: Code04_DifferentColors.java
- **题目**: 多次查询区间内不同元素的个数
- **解法**: 树状数组 + 离线处理
- **时间复杂度**: O((n + m) log n)
- **空间复杂度**: O(n + m)

### 5. 得到回文串的最少操作次数
- **相关文件**: Code05_MinimumNumberOfMovesToMakePalindrome.java
- **题目**: 通过相邻元素交换得到回文串的最少操作次数
- **解法**: 树状数组 + 归并排序
- **时间复杂度**: O(n log n)
- **空间复杂度**: O(n)

### 6. 翻转对
- **相关文件**: Code06_ReversePairs.java, Code06_ReversePairs.cpp, Code06_ReversePairs.py
- **题目**: 求满足i<j且nums[i]>2*nums[j]的重要翻转对数量
- **解法**: 归并排序
- **时间复杂度**: O(n log n)
- **空间复杂度**: O(n)

### 7. 最长递增子序列
- **相关文件**: Code07_LIS_BIT.java, Code07_LIS_BIT.cpp, Code07_LIS_BIT.py
- **题目**: 求最长递增子序列的长度
- **解法**: 树状数组优化动态规划
- **时间复杂度**: O(n log n)
- **空间复杂度**: O(n)

### 8. 最长递增子序列的个数（进阶）
- **相关文件**: Code08_NumberOfLISAdvanced.java, Code08_NumberOfLISAdvanced.cpp, Code08_NumberOfLISAdvanced.py
- **题目**: 求最长递增子序列的个数
- **解法**: 树状数组优化动态规划
- **时间复杂度**: O(n log n)
- **空间复杂度**: O(n)

### 9. 统计数组中好三元组数目
- **相关文件**: Code09_GoodTriplets.java, Code09_GoodTriplets.cpp, Code09_GoodTriplets.py
- **题目**: 求两个数组中位置顺序一致的三元组数量
- **解法**: 树状数组
- **时间复杂度**: O(n log n)
- **空间复杂度**: O(n)

## 算法思路与技巧

### 树状数组应用场景
1. **前缀和查询与单点更新**: 最基础的应用
2. **区间和查询与单点更新**: 通过前缀和差分实现
3. **优化动态规划**: 维护以某值结尾的最优解
4. **离线处理**: 结合排序和扫描线思想

### 归并排序应用场景
1. **逆序对计数**: 在合并过程中统计
2. **翻转对计数**: 类似逆序对的变形
3. **小和问题**: 计算每个元素左边比它小的元素之和

### 离散化技术
1. **处理大数值**: 将大数值映射到连续的小范围
2. **去重**: 去除重复元素，减少空间消耗
3. **排序映射**: 保持原有大小关系

## 工程化考量

### 异常处理
1. **空输入处理**: 检查数组是否为空
2. **边界条件**: 处理数组长度为1或2的情况
3. **数值溢出**: 使用long类型处理大数运算

### 性能优化
1. **IO优化**: 使用快速IO读写
2. **内存复用**: 复用数组空间，减少内存分配
3. **常数优化**: 减少不必要的计算和比较

### 代码可读性
1. **命名规范**: 变量命名见名知意
2. **注释完整**: 详细解释算法思路和关键步骤
3. **模块化**: 将功能拆分为独立的方法

## 语言特性差异

### Java
1. **静态数组**: 预分配固定大小数组提高性能
2. **IO优化**: 使用StreamTokenizer和BufferedReader

### C++
1. **STL容器**: vector、algorithm等标准库
2. **内存管理**: 手动管理内存，注意初始化

### Python
1. **列表操作**: 列表推导式和内置函数
2. **动态类型**: 灵活但需注意类型转换

## 面试技巧

### 解题思路
1. **问题分析**: 理解题目要求，提取关键约束
2. **算法选择**: 根据数据规模和时间要求选择合适算法
3. **边界处理**: 考虑特殊情况和边界条件
4. **复杂度分析**: 准确计算时间和空间复杂度

### 代码实现
1. **模板复用**: 准备常用算法模板
2. **调试技巧**: 使用打印语句跟踪变量变化
3. **测试用例**: 准备典型和边界测试用例

## 扩展学习

### 相关算法
1. **线段树**: 更强大的区间数据结构
2. **平衡二叉搜索树**: 动态维护有序序列
3. **分块**: 平衡时间复杂度和实现复杂度

### 应用领域
1. **机器学习**: 特征选择和排序算法
2. **图像处理**: 像素排序和滤波
3. **自然语言处理**: 文本排序和匹配