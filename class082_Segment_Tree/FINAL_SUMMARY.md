# Class109 算法题目完全指南

## 概述

Class109专注于高级数据结构和算法，特别是树状数组（Fenwick Tree）和归并排序的应用。这些算法在处理各种计数问题、优化动态规划和解决复杂查询问题方面具有重要作用。

## 核心算法详解

### 1. 树状数组（Binary Indexed Tree/Fenwick Tree）

#### 基本概念
树状数组是一种高效维护前缀和的数据结构，支持单点更新和前缀查询操作，时间复杂度均为O(log n)。

#### 核心操作
1. **lowbit操作**: `i & -i` 获取最低位的1
2. **单点更新**: 沿着父节点路径向上更新
3. **前缀查询**: 沿着子节点路径向下累加

#### 应用场景
- 前缀和维护
- 逆序对计数
- 动态规划优化
- 离线查询处理

### 2. 归并排序及其应用

#### 基本思想
分治策略，将数组不断二分直到单个元素，然后合并有序数组。

#### 核心应用
- 逆序对计数：在合并过程中统计
- 翻转对计数：类似逆序对的变形
- 小和问题：计算每个元素左边比它小的元素之和

### 3. 离散化技术

#### 应用目的
处理大数值范围的问题，将大数值映射到连续的小范围，减少空间消耗。

#### 实现步骤
1. 收集所有需要离散化的数值
2. 排序并去重
3. 建立原值到排名的映射关系

## 题目详解

### 基础题目（原文件）

#### 1. 逆序对问题 (Code01_NumberOfReversePair1.java, Code01_NumberOfReversePair2.java)
- **问题描述**: 求满足i<j且arr[i]>arr[j]的数对个数
- **解法**: 归并排序
- **关键点**: 在合并过程中统计左半部分大于右半部分元素的个数

#### 2. 升序三元组数量 (Code02_IncreasingTriples.java)
- **问题描述**: 求满足i<j<k且arr[i]<arr[j]<arr[k]的三元组个数
- **解法**: 树状数组
- **关键点**: 维护一元组和二元组的数量，递推计算三元组

#### 3. 最长递增子序列的个数 (Code03_NumberOfLIS.java)
- **问题描述**: 求最长递增子序列的个数
- **解法**: 树状数组优化动态规划
- **关键点**: 维护以每个值结尾的最长长度和对应数量

#### 4. HH的项链 (Code04_DifferentColors.java)
- **问题描述**: 多次查询区间内不同元素的个数
- **解法**: 树状数组 + 离线处理
- **关键点**: 离线排序查询，维护每个颜色最后出现位置

#### 5. 得到回文串的最少操作次数 (Code05_MinimumNumberOfMovesToMakePalindrome.java)
- **问题描述**: 通过相邻元素交换得到回文串的最少操作次数
- **解法**: 树状数组 + 归并排序
- **关键点**: 构建位置映射数组，计算逆序对数量

### 扩展题目（新增文件）

#### 6. 翻转对 (Code06_ReversePairs.*)
- **问题描述**: 求满足i<j且nums[i]>2*nums[j]的重要翻转对数量
- **解法**: 归并排序
- **关键点**: 注意整数溢出，使用long类型

#### 7. 最长递增子序列 (Code07_LIS_BIT.*)
- **问题描述**: 求最长递增子序列的长度
- **解法**: 树状数组优化动态规划
- **关键点**: 离散化处理大数值

#### 8. 最长递增子序列的个数（进阶） (Code08_NumberOfLISAdvanced.*)
- **问题描述**: 求最长递增子序列的个数
- **解法**: 树状数组优化动态规划
- **关键点**: 同时维护长度和数量信息

#### 9. 统计数组中好三元组数目 (Code09_GoodTriplets.*)
- **问题描述**: 求两个数组中位置顺序一致的三元组数量
- **解法**: 树状数组
- **关键点**: 转换为公共递增子序列问题

## 算法技巧总结

### 1. 树状数组使用技巧
1. **前缀和维护**: 最基础应用
2. **区间更新**: 通过差分数组实现
3. **多维信息维护**: 使用多个树状数组
4. **离散化结合**: 处理大数值范围

### 2. 归并排序应用技巧
1. **分治思想**: 将复杂问题分解为简单子问题
2. **合并统计**: 在合并过程中统计所需信息
3. **逆序处理**: 从后往前处理优化性能

### 3. 离散化技巧
1. **排序去重**: 标准离散化流程
2. **二分查找**: 快速定位排名
3. **映射维护**: 建立双向映射关系

## 工程化实践

### 1. 性能优化
1. **IO优化**: 使用快速读写
2. **内存复用**: 预分配数组空间
3. **常数优化**: 减少重复计算

### 2. 代码质量
1. **命名规范**: 变量命名见名知意
2. **注释完整**: 详细解释算法思路
3. **模块化设计**: 功能拆分为独立方法

### 3. 异常处理
1. **空输入检查**: 处理边界情况
2. **数值溢出**: 使用合适的数据类型
3. **内存管理**: 注意数组边界

## 面试准备指南

### 1. 知识点掌握
1. **基础概念**: 理解各种数据结构的原理
2. **时间复杂度**: 准确分析算法复杂度
3. **空间复杂度**: 合理使用内存空间

### 2. 解题思路
1. **问题分析**: 提取关键约束条件
2. **算法选择**: 根据数据规模选择合适算法
3. **边界处理**: 考虑特殊情况

### 3. 编码实践
1. **模板准备**: 准备常用算法模板
2. **调试技巧**: 使用打印语句跟踪变量
3. **测试用例**: 准备典型和边界测试

## 学习建议

### 1. 循序渐进
1. **掌握基础**: 先理解基本概念和操作
2. **练习应用**: 通过题目加深理解
3. **总结规律**: 归纳常见解题模式

### 2. 多语言实践
1. **Java**: 熟悉静态数组和IO优化
2. **C++**: 掌握STL容器和内存管理
3. **Python**: 利用列表操作和内置函数

### 3. 持续提升
1. **定期复习**: 巩固已学知识点
2. **扩展学习**: 了解相关算法和数据结构
3. **实战应用**: 将算法应用到实际项目中

## 相关资源

### 1. 在线平台
- LeetCode
- 洛谷
- Codeforces
- AtCoder

### 2. 学习资料
- 算法导论
- 剑指Offer
- 各大OJ题解

### 3. 进阶方向
- 线段树
- 平衡二叉搜索树
- 分块算法