# 二项式反演补充题目

## 概述

二项式反演是一种重要的组合数学技巧，常用于解决"恰好"与"至少/至多"之间的转换问题。在算法竞赛中，它经常用于处理计数问题。

## 基本公式

### 形式1
$$f(n) = \sum_{i=0}^n (-1)^i \binom{n}{i} g(i) \Leftrightarrow g(n) = \sum_{i=0}^n (-1)^i \binom{n}{i} f(i)$$

### 形式2
$$g(n) = \sum_{i=0}^n \binom{n}{i} f(i) \Leftrightarrow f(n) = \sum_{i=0}^n (-1)^{n-i} \binom{n}{i} g(i)$$

### 形式3
$$g(k) = \sum_{i=k}^n \binom{i}{k} f(i) \Leftrightarrow f(k) = \sum_{i=k}^n (-1)^{i-k} \binom{i}{k} g(i)$$

## 解题思路

二项式反演通常用于解决以下类型的问题：
1. 恰好k个满足条件的方案数
2. 至少k个满足条件的方案数
3. 至多k个满足条件的方案数

通常"至少"或"至多"的情况比较容易计算，而"恰好"的情况较难直接计算，这时可以考虑使用二项式反演。

## 题目列表

### 1. 错排问题
- **题目**：洛谷 P1595 信封问题
- **链接**：https://www.luogu.com.cn/problem/P1595
- **描述**：n个人写信，求所有人都没有收到自己信的方案数
- **文件**：Code01_Derangement.java/.cpp/.py

### 2. 集合计数
- **题目**：洛谷 P10596 集合计数 / BZOJ2839 集合计数
- **链接**：https://www.luogu.com.cn/problem/P10596
- **描述**：从2^n个子集中选出若干个集合，使交集恰好包含k个元素的方案数
- **文件**：Code02_SetCounting.java/.cpp/.py

### 3. 排列计数
- **题目**：洛谷 P4071 [SDOI2016]排列计数
- **链接**：https://www.luogu.com.cn/problem/P4071
- **描述**：求有多少种1到n的排列a，满足序列恰好有m个位置i，使得a_i = i
- **文件**：Code03_PermutationCounting.java/.cpp/.py, Code07_SDOI2016Permutation.java/.cpp/.py

### 4. 分特产
- **题目**：洛谷 P5505 [JSOI2011]分特产
- **链接**：https://www.luogu.com.cn/problem/P5505
- **描述**：将m种特产分给n个同学，每个同学至少得到一个特产的方案数
- **文件**：Code03_DistributeSpecialties.java

### 5. 已经没有什么好害怕的了
- **题目**：洛谷 P4859 已经没有什么好害怕的了
- **链接**：https://www.luogu.com.cn/problem/P4859
- **描述**：将两个数组两两配对，使糖果大的配对数比药片大的配对数多k的方案数
- **文件**：Code04_NothingFear.java

### 6. 游戏
- **题目**：洛谷 P6478 [NOI Online #2 提高组] 游戏
- **链接**：https://www.luogu.com.cn/problem/P6478
- **描述**：在树上进行游戏，求恰好出现k次非平局的方案数
- **文件**：Code05_Game1.java, Code05_Game2.java

### 7. Placing Rooks
- **题目**：Codeforces 1342E Placing Rooks
- **链接**：https://codeforces.com/problemset/problem/1342/E
- **描述**：在棋盘上放置车，使每个格子都被攻击且恰好有k对车互相攻击
- **文件**：Code06_CF1342E.java/.py

### 8. 染色
- **题目**：洛谷 P4491 [HAOI2018]染色
- **链接**：https://www.luogu.com.cn/problem/P4491
- **描述**：有一个长度为N的序列和M种颜色，对于一种染色方案，假设其中有k种颜色恰好出现了S次，则其价值为W_k，求所有染色方案的价值和
- **文件**：Code08_HAOI2018Dyeing.java/.cpp/.py

### 9. NEQ
- **题目**：AtCoder ABC172E NEQ
- **链接**：https://atcoder.jp/contests/abc172/tasks/abc172_e
- **描述**：构造两个长度为N的序列A和B，满足元素范围在[1,M]之间，对应位置元素不相等，各自序列内元素互不相等，求满足条件的序列对个数
- **文件**：Code09_ABC172E_NEQ.java/.cpp/.py

### 10. 情侣？给我烧了！
- **题目**：洛谷 P4921 [MtOI2018]情侣？给我烧了！
- **链接**：https://www.luogu.com.cn/problem/P4921
- **描述**：有n对情侣来到电影院观看电影，求恰好有k对情侣是和睦的就坐方案数
- **文件**：Code10_CouplesBurned.java/.cpp/.py

### 11. 幼儿园篮球题
- **题目**：洛谷 P2791 幼儿园篮球题
- **链接**：https://www.luogu.com.cn/problem/P2791
- **描述**：蔡徐坤投篮，求期望失败度E[x^L]
- **文件**：Code11_KindergartenBasketball.java/.cpp/.py

## 补充题目来源平台

1. **洛谷 (Luogu)**: https://www.luogu.com.cn/
2. **Codeforces**: https://codeforces.com/
3. **AtCoder**: https://atcoder.jp/
4. **BZOJ**: http://www.lydsy.com/JudgeOnline/
5. **其他平台**: LeetCode, HackerRank, SPOJ, Project Euler, HackerEarth, 计蒜客, 各大高校OJ, ZOJ, MarsCode, UVa OJ, TimusOJ, AizuOJ, Comet OJ, 杭电OJ, LOJ, 牛客, 杭州电子科技大学, acwing, hdu, poj, 剑指Offer等

## 二项式反演的应用技巧

### 什么时候使用二项式反演？

1. **排列问题中的限制条件**：当我们需要计算满足某些限制条件的排列数时（如错排问题）
2. **集合计数问题**：当问题涉及到计算某些集合的交集、并集或其他组合属性时
3. **容斥原理的优化**：二项式反演可以将容斥原理的计算转化为更高效的形式
4. **恰好与至少的转换**：当直接计算"恰好k个"比较困难，但计算"至少k个"相对容易时
5. **组合数学中的递推关系**：用于推导和优化组合数学中的递推公式
6. **概率问题**：在概率论中，计算恰好k个事件发生的概率时，常使用二项式反演
7. **动态规划优化**：某些动态规划问题可以通过二项式反演进行状态优化

### 解题步骤

1. **定义状态**：明确问题中的"恰好k个"和"至少k个"的概念
   - 通常，设f[k]表示"恰好有k个满足条件"的情况数
   - 设g[k]表示"至少有k个满足条件"的情况数

2. **建立联系**：找到这两种状态之间的二项式系数关系
   - 通常有：g[k] = Σ_{i=k}^{n} C(i, k) * f[i]
   - 这表示从恰好i个满足条件的情况中选择k个的组合数

3. **应用公式**：根据二项式反演公式进行转换计算
   - 反演得到：f[k] = Σ_{i=k}^{n} (-1)^(i-k) * C(i, k) * g[i]
   - 这样就可以通过计算g[i]来间接得到f[k]

4. **预处理**：提前计算组合数、阶乘、逆元等常用值以优化计算效率
   - 预处理阶乘数组fact[]和逆元数组inv[]
   - 预处理组合数数组C[n][k]或使用公式C(n,k) = fact[n] * inv[k] * inv[n-k] % MOD

5. **取模运算**：注意大数问题中的模运算，避免溢出
   - 选择合适的模数，通常为1e9+7或998244353
   - 使用快速幂计算逆元

## 常用的二项式反演形式

1. **标准形式**：
   ```
   f(n) = Σ_{k=0}^{n} (-1)^k * C(n, k) * g(k)
   ```
   反演为：
   ```
   g(n) = Σ_{k=0}^{n} (-1)^k * C(n, k) * f(k)
   ```

2. **另一种常用形式**：
   ```
   f(n) = Σ_{k=n}^{m} C(k, n) * g(k)
   ```
   反演为：
   ```
   g(n) = Σ_{k=n}^{m} (-1)^{k-n} * C(k, n) * f(k)
   ```

3. **容斥形式**：
   ```
   f(n) = Σ_{k=0}^{n} C(n, k) * g(k)
   ```
   反演为：
   ```
   g(n) = Σ_{k=0}^{n} (-1)^{n-k} * C(n, k) * f(k)
   ```

## 经典问题类型总结

1. **错排问题**：
   - 特点：求n个元素中没有元素出现在原来位置上的排列数
   - 解法：使用递推公式D(n) = (n-1)*(D(n-1)+D(n-2))或二项式反演公式D(n) = n! * Σ_{k=0}^{n} (-1)^k / k!
   - 应用场景：排列计数、概率计算

2. **集合计数问题**：
   - 特点：计算满足特定条件的集合数量，如交集大小、子集选择等
   - 解法：先计算至少k个元素满足条件的情况，再通过二项式反演得到恰好k个的情况
   - 应用场景：组合数学、离散数学

3. **排列中的固定点问题**：
   - 特点：计算恰好有m个元素在原来位置上的排列数
   - 解法：使用二项式反演，结合错排数计算
   - 应用场景：排列统计、组合优化

4. **容斥原理应用问题**：
   - 特点：需要排除不符合条件的情况，计算符合条件的情况数
   - 解法：利用二项式反演将容斥原理形式化，简化计算
   - 应用场景：多重限制条件下的计数问题

5. **分物品问题**：
   - 特点：将物品分给若干人，满足特定条件
   - 解法：使用二项式反演结合生成函数或组合数计算
   - 应用场景：资源分配、组合优化

## 工程化考量

1. **预处理优化**：
   - 对于大n值，预处理阶乘和逆元可以显著提高计算效率
   - 预处理组合数表格在多次查询时更高效

2. **模运算注意事项**：
   - 选择合适的模数，避免中间结果溢出
   - 注意负数取模的处理，通常使用(x % MOD + MOD) % MOD

3. **边界条件处理**：
   - 处理n=0、k=0等特殊情况
   - 注意组合数C(n,k)在n<k时为0的情况

4. **数据类型选择**：
   - 在Java中使用long类型避免溢出
   - 在C++中可以使用long long或__int128处理大数
   - 在Python中无需担心整数溢出，但需注意效率

5. **测试用例**：
   - 编写小规模测试用例验证算法正确性
   - 测试边界情况如n=0、n=1等
   - 与已知的数学结果进行对比验证

## 跨语言实现差异

1. **Java**：
   - 优势：面向对象，代码结构清晰
   - 劣势：整数类型有范围限制，需要频繁处理溢出
   - 技巧：使用BigInteger处理非常大的数，或采用模运算

2. **C++**：
   - 优势：执行效率高，支持位运算
   - 劣势：内存管理需要注意
   - 技巧：使用long long和模运算，预处理阶乘和逆元

3. **Python**：
   - 优势：内置大整数支持，语法简洁
   - 劣势：对于大规模计算效率较低
   - 技巧：使用列表推导式和生成器提高效率，利用math模块的组合函数

## 进阶技巧

1. **生成函数结合**：二项式反演与生成函数结合可以解决更复杂的组合计数问题
2. **多项式乘法优化**：对于某些问题，可以使用快速傅里叶变换(FFT)加速多项式乘法
3. **莫比乌斯反演结合**：在数论问题中，二项式反演常与莫比乌斯反演结合使用
4. **动态规划状态优化**：利用二项式反演优化动态规划的状态转移方程
5. **矩阵快速幂加速**：对于线性递推关系，可以使用矩阵快速幂加速计算

## 学习资源推荐

1. **经典教材**：《组合数学》(Richard A. Brualdi)
2. **在线资源**：OI Wiki、知乎专栏、各类算法竞赛博客
3. **练习平台**：洛谷、Codeforces、AtCoder等
4. **进阶内容**：生成函数、容斥原理、莫比乌斯反演等相关知识