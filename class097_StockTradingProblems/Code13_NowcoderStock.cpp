// 牛客网股票交易问题
// 题目链接: https://blog.csdn.net/m0_48554728/article/details/120830277
// 题目描述:
// 假设你有一个数组，其中第i个元素是股票在第i天的价格。
// 你可以买入一次股票和卖出一次股票（并非每天都可以买入或卖出一次，总共只能买入和卖出一次），
// 问能获得的最大收益是多少。
//
// 解题思路:
// 这是一个经典的动态规划问题，核心思想是"一次遍历"。
// 我们维护两个变量：
// 1. minPrice - 到目前为止遇到的最低价格
// 2. maxProfit - 到目前为止能获得的最大利润
//
// 算法步骤:
// 1. 初始化minPrice为第一天的价格，maxProfit为0
// 2. 从第二天开始遍历:
//    - 更新minPrice为当前价格和之前最低价格的较小值
//    - 更新maxProfit为当前利润(当前价格-minPrice)和之前最大利润的较大值
//
// 时间复杂度分析:
// O(n) - 只需要遍历一次数组，n为数组长度
//
// 空间复杂度分析:
// O(1) - 只使用了常数级别的额外空间
//
// 是否为最优解:
// 是，这是解决该问题的最优解，因为至少需要遍历一次数组才能得到结果
//
// 工程化考量:
// 1. 边界条件处理: 空数组或只有一个元素的情况
// 2. 异常处理: 输入参数校验
// 3. 可读性: 变量命名清晰，注释详细

#define MAX_N 10000

// 计算最大利润
// 参数说明:
// prices: 股票价格数组
// n: 数组长度
// 返回值: 最大利润
int maxProfit(int prices[], int n) {
    // 边界条件处理：空数组或只有一个元素的情况
    // 如果数组为空或元素个数小于等于1，则无法进行交易，利润为0
    if (prices == 0 || n <= 1) {
        return 0;
    }
    
    // minPrice: 到目前为止遇到的最低价格
    // 初始化为第一天的价格，因为我们只能从第一天开始交易
    int minPrice = prices[0];
    
    // maxProfit: 到目前为止能获得的最大利润
    // 初始化为0，表示如果后续没有更好的交易机会，至少不会亏损
    int maxProfit = 0;
    
    // 一次遍历：从第二天开始遍历数组
    // 这是因为我们需要比较当前价格与之前的价格来计算利润
    for (int i = 1; i < n; i++) {
        // 更新到目前为止的最小价格
        // 如果当前价格比之前记录的最低价格更低，则更新最低价格
        // 这确保我们始终知道到目前为止的最优买入时机
        if (prices[i] < minPrice) {
            minPrice = prices[i];
        }
        
        // 更新到目前为止的最大利润
        // 计算如果今天卖出股票能获得的利润（当前价格 - 最低买入价格）
        // 如果这个利润比之前记录的最大利润更高，则更新最大利润
        int currentProfit = prices[i] - minPrice;
        if (currentProfit > maxProfit) {
            maxProfit = currentProfit;
        }
    }
    
    // 返回计算得到的最大利润
    return maxProfit;
}

// 由于编译环境限制，不提供测试函数
// 可以通过牛客网平台进行测试