// LeetCode 901. 股票价格跨度
// 题目链接: https://leetcode.cn/problems/online-stock-span/
// 题目描述:
// 设计一个算法收集某些股票的每日报价，并返回该股票当日价格的跨度。
// 当日股票价格的跨度被定义为股票价格小于或等于今天价格的最大连续日数（从今天开始往回数，包括今天）。
// 例如，如果未来7天股票的价格是 [100,80,60,70,60,75,85]，那么股票跨度将是 [1,1,1,2,1,4,6]。
//
// 解题思路:
// 这是一个典型的单调栈问题。我们需要找到左边第一个比当前元素大的位置。
// 使用单调递减栈来解决这个问题，栈中存储索引。
// 对于每个新来的价格，我们弹出所有小于等于当前价格的元素，然后计算跨度。
//
// 算法步骤:
// 1. 使用一个栈来存储股票价格的索引
// 2. 对于每个新价格，弹出栈中所有小于等于当前价格的索引
// 3. 如果栈为空，说明当前价格是目前为止最大的，跨度为当前天数+1
// 4. 如果栈不为空，跨度为当前索引减去栈顶索引
// 5. 将当前索引压入栈中
//
// 时间复杂度分析:
// O(n) - 每个元素最多入栈和出栈一次
//
// 空间复杂度分析:
// O(n) - 栈的空间复杂度
//
// 是否为最优解:
// 是，这是解决该问题的最优解，因为每个元素最多被处理两次（一次入栈，一次出栈）
//
// 工程化考量:
// 1. 边界条件处理: 空栈情况
// 2. 异常处理: 输入参数校验
// 3. 可读性: 变量命名清晰，注释详细

// 由于编译环境限制，使用简单的数组实现
#define MAX_N 10000

class StockSpanner {
private:
    int stack[MAX_N];      // 存储索引的单调栈
    int prices[MAX_N];     // 存储价格的数组
    int stack_top;         // 栈顶指针
    int index;             // 当前索引

public:
    StockSpanner() {
        stack_top = 0;
        index = 0;
    }

    /*
     * 计算股票价格跨度
     * @param price 当天股票价格
     * @return 股票价格跨度
     */
    int next(int price) {
        // 将价格添加到数组中
        prices[index] = price;
        
        // 弹出栈中所有小于等于当前价格的索引
        while (stack_top > 0 && prices[stack[stack_top - 1]] <= price) {
            stack_top--;
        }
        
        // 计算跨度
        int span;
        if (stack_top == 0) {
            // 如果栈为空，说明当前价格是目前为止最大的
            span = index + 1;
        } else {
            // 跨度为当前索引减去栈顶索引
            span = index - stack[stack_top - 1];
        }
        
        // 将当前索引压入栈中
        stack[stack_top] = index;
        stack_top++;
        index++;
        
        return span;
    }
};

// 由于编译环境限制，不提供测试函数
// 可以通过LeetCode平台进行测试