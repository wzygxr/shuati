# 递归与回溯算法 - 详细题解

## 概述

本文档提供了class038目录中所有递归与回溯算法题目的详细解答，包括算法思路、复杂度分析、关键技巧和工程化考虑。

## 基础题目

### Code01_Subsequences - 字符串的所有子序列

**题目描述**：生成字符串的所有子序列（去重）

**算法思路**：
1. 使用回溯算法生成所有子序列
2. 每个字符有两种选择：选择或不选择
3. 使用Set去重，确保结果唯一

**时间复杂度**：O(2^n * n)，其中n是字符串长度
**空间复杂度**：O(n)，递归栈深度

**关键技巧**：
- 使用Set自动去重
- 每个字符的选择/不选择决策

### Code02_Combinations - 数组组合去重

**题目描述**：给定可能包含重复元素的数组，返回所有不重复的组合

**算法思路**：
1. 先排序使相同元素相邻
2. 回溯生成所有组合
3. 跳过重复元素避免重复组合

**时间复杂度**：O(2^n * n)
**空间复杂度**：O(n)

**关键技巧**：
- 排序后跳过重复元素
- 控制起始位置避免重复

### Code03_Permutations - 无重复数字全排列

**题目描述**：生成无重复数字的所有全排列

**算法思路**：
1. 回溯算法生成所有排列
2. 使用布尔数组标记已使用的元素
3. 每次选择一个未使用的元素

**时间复杂度**：O(n * n!)
**空间复杂度**：O(n)

**关键技巧**：
- 使用used数组标记已使用元素
- 递归回溯选择路径

## 经典题目

### Code08_LetterCombinations - 电话号码的字母组合 (LeetCode 17)

**题目描述**：给定数字字符串，返回所有可能的字母组合

**算法思路**：
1. 建立数字到字母的映射表
2. 回溯生成所有组合
3. 每个数字对应多个字母选择

**时间复杂度**：O(3^m * 4^n)，其中m是3字母数字个数，n是4字母数字个数
**空间复杂度**：O(m+n)

**关键技巧**：
- 数字到字母的映射处理
- 字符串拼接优化

### Code09_GenerateParentheses - 括号生成 (LeetCode 22)

**题目描述**：生成所有有效的括号组合

**算法思路**：
1. 回溯生成所有括号组合
2. 使用计数器确保括号有效性
3. 左括号数≥右括号数

**时间复杂度**：O(4^n / sqrt(n))
**空间复杂度**：O(n)

**关键技巧**：
- 左右括号计数控制
- 提前剪枝无效组合

### Code10_SudokuSolver - 解数独 (LeetCode 37)

**题目描述**：解决9×9数独问题

**算法思路**：
1. 回溯尝试每个空格的数字
2. 检查行、列、3×3宫格的数字有效性
3. 找到解后立即返回

**时间复杂度**：O(9^(n×n))，最坏情况
**空间复杂度**：O(n×n)

**关键技巧**：
- 有效性检查优化
- 提前终止找到解

## 新增题目详细解答

### Code18_SubsetsII - 子集 II (LeetCode 90)

**题目链接**：https://leetcode.cn/problems/subsets-ii/

**问题描述**：给定可能包含重复元素的数组，返回所有不重复的子集

**算法思路**：
1. 排序数组使相同元素相邻
2. 回溯生成所有子集
3. 跳过重复元素避免重复子集

**关键代码**：
```java
if (i > start && nums[i] == nums[i - 1]) {
    continue; // 跳过重复元素
}
```

**复杂度分析**：
- 时间复杂度：O(n × 2^n)
- 空间复杂度：O(n)

**工程化考虑**：
- 输入验证：空数组处理
- 边界条件：单个元素数组
- 性能优化：排序后剪枝

### Code19_Combinations - 组合 (LeetCode 77)

**题目链接**：https://leetcode.cn/problems/combinations/

**问题描述**：从1到n中选出k个数的所有组合

**算法思路**：
1. 回溯生成所有组合
2. 控制起始位置避免重复
3. 剪枝优化：剩余数字不足时提前终止

**关键代码**：
```java
for (int i = start; i <= n - (k - path.size()) + 1; i++) {
    // 剪枝优化
}
```

**复杂度分析**：
- 时间复杂度：O(C(n,k) × k)
- 空间复杂度：O(k)

**面试技巧**：
- 解释剪枝优化的数学原理
- 对比组合与排列的区别

### Code20_PermutationsII - 全排列 II (LeetCode 47)

**题目链接**：https://leetcode.cn/problems/permutations-ii/

**问题描述**：生成包含重复元素数组的所有不重复全排列

**算法思路**：
1. 排序使相同元素相邻
2. 回溯生成排列
3. 跳过重复排列：相同元素且前一个未使用时跳过

**关键代码**：
```java
if (i > 0 && nums[i] == nums[i - 1] && !used[i - 1]) {
    continue;
}
```

**复杂度分析**：
- 时间复杂度：O(n × n!)
- 空间复杂度：O(n)

**去重原理**：
- 确保相同元素的相对顺序
- 避免生成重复排列

### Code21_CombinationSumII - 组合总和 II (LeetCode 40)

**题目链接**：https://leetcode.cn/problems/combination-sum-ii/

**问题描述**：找出数组中所有和为target的组合，每个数字只能使用一次

**算法思路**：
1. 排序数组
2. 回溯生成组合
3. 跳过重复元素
4. 剪枝：当前和超过target时终止

**复杂度分析**：
- 时间复杂度：O(2^n)
- 空间复杂度：O(n)

**关键区别**：
- 与组合总和I的区别：数字不能重复使用
- 去重处理更复杂

### Code22_CombinationSumIII - 组合总和 III (LeetCode 216)

**题目链接**：https://leetcode.cn/problems/combination-sum-iii/

**问题描述**：从1-9中找出k个数的组合，和为n

**算法思路**：
1. 数字范围限制在1-9
2. 回溯生成组合
3. 双重约束：个数k与和n

**复杂度分析**：
- 时间复杂度：O(C(9,k))
- 空间复杂度：O(k)

**特殊约束**：
- 数字范围固定
- 个数与和的双重限制

### Code23_PermutationSequence - 排列序列 (LeetCode 60)

**题目链接**：https://leetcode.cn/problems/permutation-sequence/

**问题描述**：直接计算第k个排列，而不生成所有排列

**算法思路**：
1. 数学方法：康托展开
2. 计算阶乘数组
3. 逐位确定数字

**关键代码**：
```python
index = k // factorial[i]
result.append(str(numbers[index]))
numbers.pop(index)
k %= factorial[i]
```

**复杂度分析**：
- 时间复杂度：O(n²)
- 空间复杂度：O(n)

**算法优势**：
- 避免生成所有排列
- 直接定位目标排列

### Code24_RestoreIPAddresses - 复原 IP 地址 (LeetCode 93)

**题目链接**：https://leetcode.cn/problems/restore-ip-addresses/

**问题描述**：将数字字符串分割成有效的IP地址

**算法思路**：
1. 回溯分割字符串
2. 检查每段有效性：0-255，无前导0
3. 确保分成4段

**复杂度分析**：
- 时间复杂度：O(3⁴) = O(81)
- 空间复杂度：O(n)

**有效性检查**：
- 数值范围：0-255
- 前导0处理
- 段数限制：必须4段

### Code25_WordBreakII - 单词拆分 II (LeetCode 140)

**题目链接**：https://leetcode.cn/problems/word-break-ii/

**问题描述**：将字符串分割成字典中的单词，返回所有可能的分割

**算法思路**：
1. 回溯分割字符串
2. 记忆化搜索优化
3. 检查单词是否在字典中

**复杂度分析**：
- 时间复杂度：O(2^n × n)
- 空间复杂度：O(n²)

**优化技巧**：
- 记忆化搜索避免重复计算
- 提前终止无效分割

### Code26_BeautifulArrangement - 优美的排列 (LeetCode 526)

**题目链接**：https://leetcode.cn/problems/beautiful-arrangement/

**问题描述**：计算满足特定条件的排列数量

**算法思路**：
1. 回溯生成排列
2. 提前剪枝：不满足条件时跳过
3. 条件：数字能被位置整除或位置能被数字整除

**复杂度分析**：
- 时间复杂度：O(n!)
- 空间复杂度：O(n)

**剪枝优化**：
- 提前检查排列条件
- 减少无效搜索

### Code27_MatchsticksToSquare - 火柴拼正方形 (LeetCode 473)

**题目链接**：https://leetcode.cn/problems/matchsticks-to-square/

**问题描述**：用所有火柴拼成正方形

**算法思路**：
1. 计算总长度，检查是否能被4整除
2. 排序火柴，优先使用长火柴
3. 回溯分配到四条边

**复杂度分析**：
- 时间复杂度：O(4^n)
- 空间复杂度：O(n)

**剪枝策略**：
- 边长超过目标时终止
- 跳过相同长度的边

### Code28_PartitionToKEqualSumSubsets - 划分为k个相等的子集 (LeetCode 698)

**题目链接**：https://leetcode.cn/problems/partition-to-k-equal-sum-subsets/

**问题描述**：将数组分成k个和相等的子集

**算法思路**：
1. 计算目标和 = 总和 / k
2. 排序数组，优先使用大数字
3. 回溯分配到k个子集

**复杂度分析**：
- 时间复杂度：O(k^n)
- 空间复杂度：O(n)

**与火柴问题的区别**：
- 子集数量k可变
- 数字范围更大

### Code29_AdditiveNumber - 累加数 (LeetCode 306)

**题目链接**：https://leetcode.cn/problems/additive-number/

**问题描述**：验证字符串是否是累加序列

**算法思路**：
1. 尝试所有可能的前两个数字分割
2. 验证剩余部分是否满足累加关系
3. 处理大数字符串加法

**复杂度分析**：
- 时间复杂度：O(n³)
- 空间复杂度：O(n)

**大数处理**：
- 字符串加法实现
- 避免整数溢出

## 算法技巧总结

### 1. 回溯算法模板
```python
def backtrack(路径, 选择列表):
    if 满足结束条件:
        结果.add(路径)
        return
    
    for 选择 in 选择列表:
        if 不满足条件: continue  # 剪枝
        
        做选择
        backtrack(路径, 选择列表)
        撤销选择
```

### 2. 常见优化技巧

**剪枝优化**：
- 提前终止无效分支
- 排序后优先处理大元素
- 跳过重复计算

**记忆化搜索**：
- 存储中间结果
- 避免重复计算子问题

**数学优化**：
- 利用数学性质减少搜索空间
- 康托展开直接计算排列

### 3. 工程化考虑

**异常处理**：
- 空输入处理
- 边界条件检查
- 非法输入验证

**性能优化**：
- 选择合适的数据结构
- 减少不必要的复制
- 利用语言特性优化

**代码可读性**：
- 清晰的变量命名
- 模块化函数设计
- 详细的注释说明

## 面试准备建议

### 1. 掌握核心算法
- 理解回溯算法的本质
- 熟练应用剪枝技巧
- 掌握复杂度分析方法

### 2. 问题分析能力
- 快速识别问题类型
- 设计合适的算法方案
- 分析时间空间复杂度

### 3. 编码实现能力
- 熟练编写回溯代码
- 处理边界条件
- 进行代码优化

### 4. 沟通表达能力
- 清晰解释算法思路
- 分析算法优缺点
- 讨论优化方案

通过系统学习这些题目，您将能够熟练掌握递归与回溯算法的各种应用场景，为算法面试和实际开发工作打下坚实基础。