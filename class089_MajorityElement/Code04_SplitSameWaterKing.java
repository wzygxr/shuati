import java.util.List;

/**
 * 划分左右使其水王数相同
 * 给定一个大小为n的数组nums
 * 水王数是指在数组中出现次数大于n/2的数
 * 返回其中的一个划分点下标，使得左侧水王数等于右侧水王数
 * 如果数组不存在这样的划分返回-1
 *
 * 相关题目来源：
 * 1. LeetCode 2780. Minimum Index of a Valid Split - https://leetcode.com/problems/minimum-index-of-a-valid-split/
 * 2. LeetCode 2780. 合法分割的最小下标（中文版）- https://leetcode.cn/problems/minimum-index-of-a-valid-split/
 * 3. GeeksforGeeks Minimum Index of a Valid Split - https://www.geeksforgeeks.org/minimum-index-of-a-valid-split/
 * 4. 牛客网 NC145 - 合法分割的最小下标 - https://www.nowcoder.com/practice/5f3c9f8d4ba44525b3eb961de1910611
 * 5. 洛谷 P3932 SAC E#1 - 二道难题Tree - https://www.luogu.com.cn/problem/P3932 (相关思想应用)
 *
 * 题目解析：
 * 需要找到一个最小的分割点，使得分割后的两部分都有支配元素，且都等于原数组的支配元素
 * 
 * 解题思路：
 * 1. 首先找出原数组的支配元素（使用Boyer-Moore投票算法）
 * 2. 统计该元素在整个数组中的出现次数
 * 3. 遍历所有可能的分割点，检查分割后的两部分是否都满足支配元素条件
 * 
 * 算法正确性证明：
 * 1. 如果原数组存在支配元素，那么分割后的两部分也必须包含该支配元素
 * 2. 通过遍历所有可能的分割点，可以找到满足条件的最小分割点
 * 3. 如果不存在有效分割点，则返回-1
 * 
 * 时间复杂度分析：
 * - 时间复杂度：O(n) - 需要遍历数组两次
 *   - 第一次遍历用于找到候选元素和统计次数：O(n)
 *   - 第二次遍历用于检查所有可能的分割点：O(n)
 * - 空间复杂度：O(1) - 只使用了常数级别的额外空间
 * 
 * 该解法是最优解，因为：
 * 1. 时间复杂度已经是最优的，因为至少需要遍历一次数组才能确定每个元素的信息
 * 2. 空间复杂度也是最优的，只使用了常数级别的额外空间
 * 
 * 工程化考量：
 * 1. 异常处理：处理空数组、单元素数组等边界情况
 * 2. 性能优化：在实际应用中，可以根据数据分布情况优化验证步骤
 * 3. 线程安全：在多线程环境中需要注意变量的可见性和原子性
 * 4. 代码可读性：使用清晰的变量名和注释提高可维护性
 * 
 * 与其他领域的联系：
 * 1. 数据分析：用于数据分割和一致性分析
 * 2. 机器学习：可以用于数据集划分和模型验证
 * 3. 分布式系统：在分布式计算中用于数据分片和一致性检查
 * 4. 图像处理：在图像分割和特征提取中用于确定主要特征
 * 5. 自然语言处理：用于文本分割和主题一致性分析
 */

public class Code04_SplitSameWaterKing {

	/**
	 * 查找合法分割的最小下标，使得左右两部分的水王数相同
	 * 
	 * 算法思路：
	 * 1. 使用Boyer-Moore投票算法找出原数组的候选元素
	 * 2. 统计候选元素在整个数组中的出现次数
	 * 3. 遍历所有可能的分割点，检查分割后的两部分是否都满足支配元素条件
	 * 
	 * 时间复杂度：O(n) - 需要遍历数组两次（找候选元素和统计次数、检查分割点）
	 * 空间复杂度：O(1) - 只使用了常数级别的额外空间
	 * 
	 * @param nums 输入列表
	 * @return 满足条件的最小分割下标，如果不存在有效分割返回-1
	 */
	public static int minimumIndex(List<Integer> nums) {
		// 第一步：使用Boyer-Moore投票算法找出候选元素
		int cand = 0;
		int hp = 0;
		
		// 投票阶段：找出可能的支配元素
		for (int num : nums) {
			if (hp == 0) {
				cand = num;
				hp = 1;
			} else if (cand == num) {
				hp++;
			} else {
				hp--;
			}
		}
		
		// 第二步：统计候选元素在整个数组中的出现次数
		hp = 0;
		for (int num : nums) {
			if (num == cand) {
				hp++;
			}
		}
		
		int n = nums.size();
		// lc : 水王数左侧出现的词频
		// rc : 水王数右侧出现的词频
		for (int i = 0, lc = 0, rc = hp; i < n - 1; i++) {
			if (nums.get(i) == cand) {
				lc++;
				rc--;
			}
			// 检查左半部分是否满足支配元素条件
			// 左半部分长度为 i+1，需要候选元素出现次数 > (i+1)/2
			// 检查右半部分是否满足支配元素条件
			// 右半部分长度为 n-i-1，需要候选元素出现次数 > (n-i-1)/2
			if (lc > (i + 1) / 2 && rc > (n - i - 1) / 2) {
				// 找到了划分点直接返回
				return i;
			}
		}
		// 不存在这样的划分点返回-1
		return -1;
	}

}