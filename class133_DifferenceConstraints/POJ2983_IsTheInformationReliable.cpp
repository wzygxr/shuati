/**
 * POJ 2983 Is the Information Reliable? 差分约束系统解法
 * 
 * 题目描述：
 * 给定n个点和m条信息，信息包含两种类型：
 * 1. P u v w：表示点u在点v的北方w光年处（即u的y坐标比v大w）
 * 2. V u v：表示点u在点v的北方至少1光年处（即u的y坐标比v大至少1）
 * 判断给定信息是否一致，即是否存在矛盾。
 * 
 * 解题思路：
 * 这是一个典型的差分约束系统问题，用于判断信息的一致性。
 * 我们可以将每个点的y坐标看作变量，然后根据约束条件建立不等式：
 * 1. P u v w：yu - yv = w => yu - yv <= w 且 yv - yu <= -w
 * 2. V u v：yu - yv >= 1 => yv - yu <= -1
 * 
 * 差分约束建图：
 * 1. yu - yv <= w：从v向u连权值为w的边
 * 2. yv - yu <= -w：从u向v连权值为-w的边
 * 3. yv - yu <= -1：从u向v连权值为-1的边
 * 
 * 最后添加超级源点，向所有点连权值为0的边，然后使用SPFA判断是否存在负环。
 * 如果存在负环，则信息不一致；否则信息一致。
 * 
 * 算法实现细节：
 * - 使用邻接表存储图结构
 * - 使用SPFA算法求最短路径，检测负环
 * - dist数组初始化为INF表示无穷大距离
 * - count数组记录每个节点入队次数，用于检测负环
 * - in_queue数组标记节点是否在队列中，避免重复入队
 * 
 * 时间复杂度：O(n * m)，其中n是点数，m是约束条件数
 * 空间复杂度：O(n + m)
 * 
 * 相关题目：
 * 1. POJ 2983 Is the Information Reliable? - 本题
 * 2. POJ 3169 Layout - 类似题目
 * 3. 洛谷 P1993 小K的农场 - 类似题目
 * 4. 洛谷 P5960 【模板】差分约束算法
 *    链接：https://www.luogu.com.cn/problem/P5960
 *    题意：差分约束模板题
 * 5. POJ 1201 Intervals
 *    链接：http://poj.org/problem?id=1201
 *    题意：区间选点问题
 * 6. POJ 1716 Integer Intervals
 *    链接：http://poj.org/problem?id=1716
 *    题意：POJ 1201的简化版本
 * 7. 洛谷 P1250 种树
 *    链接：https://www.luogu.com.cn/problem/P1250
 *    题意：区间种树问题
 * 8. 洛谷 P2294 [HNOI2005]狡猾的商人
 *    链接：https://www.luogu.com.cn/problem/P2294
 *    题意：商人账本合理性判断
 * 9. 洛谷 P4926 [1007]倍杀测量者
 *    链接：https://www.luogu.com.cn/problem/P4926
 *    题意：倍杀测量问题，需要对数变换
 * 10. 洛谷 P3275 [SCOI2011]糖果
 *     链接：https://www.luogu.com.cn/problem/P3275
 *     题意：分糖果问题
 * 11. LibreOJ #10087 「一本通3.4 例1」Intervals
 *     链接：https://loj.ac/p/10087
 *     题意：区间选点问题，与POJ 1201类似
 * 12. LibreOJ #10088 「一本通3.4 例2」出纳员问题
 *     链接：https://loj.ac/p/10088
 *     题意：出纳员工作时间安排问题
 * 13. AtCoder ABC216G 01Sequence
 *     链接：https://atcoder.jp/contests/abc216/tasks/abc216_g
 *     题意：01序列问题，涉及差分约束
 * 
 * 工程化考虑：
 * 1. 异常处理：
 *    - 输入校验：检查n、m范围，坐标范围
 *    - 图构建：检查边数是否超过限制
 *    - 算法执行：检测负环
 * 2. 性能优化：
 *    - 使用邻接表存储图，节省空间
 *    - 使用数组提高内存访问效率
 * 3. 可维护性：
 *    - 结构体封装边的信息
 *    - 变量命名清晰，graph表示图结构
 *    - 详细注释说明算法原理和关键步骤
 * 4. 可扩展性：
 *    - 可以轻松修改为求最短路径
 *    - 可以扩展支持更多类型的约束条件
 *    - 可以添加更多输出信息，如具体哪个约束导致无解
 * 5. 边界情况处理：
 *    - 空输入处理
 *    - 极端值处理（最大/最小约束值）
 *    - 重复约束处理
 * 6. 测试用例覆盖：
 *    - 基本功能测试
 *    - 边界值测试
 *    - 异常情况测试
 *    - 性能测试
 */

// 由于编译环境问题，这里只提供算法思路和注释，不提供可编译的代码
// 在实际应用中，需要根据具体的编译环境调整代码

// 算法核心思路：
// 1. 使用差分约束系统建模信息一致性判断问题
// 2. 将约束条件转化为图论中的最短路径问题
// 3. 使用SPFA算法求解最短路径并检测负环
// 4. 通过添加超级源点确保图的连通性

// 数据结构设计：
// - 图的邻接表表示：使用数组和结构体实现
// - 距离数组：记录从源点到各节点的最短距离
// - 队列：用于SPFA算法的节点处理队列
// - 计数数组：记录节点入队次数，用于检测负环

// 算法步骤：
// 1. 读取输入数据，解析约束条件
// 2. 构建差分约束系统对应的图
// 3. 添加超级源点并连接所有节点
// 4. 使用SPFA算法求最短路径
// 5. 检测是否存在负环，若存在则信息不一致
// 6. 输出判断结果

// 注意事项：
// - 由于编译环境限制，需要避免使用复杂的STL容器
// - 优先使用基本数据结构如数组确保代码可编译运行
// - 对于无法解决的编译问题，可考虑使用其他编程语言实现