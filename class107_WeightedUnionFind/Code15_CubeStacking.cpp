// 由于环境限制，不使用标准库头文件
// 使用基本C++实现，手动实现所需功能

/**
 * 带权并查集解决立方体积木叠放问题 (C++版本)
 * 
 * 问题分析：
 * 维护立方体积木列的合并和查询操作，需要支持：
 * 1. 将一个积木列整体移动到另一个积木列顶部
 * 2. 查询某个积木下方的积木数量
 * 
 * 核心思想：
 * 1. 使用带权并查集维护积木之间的相对位置关系
 * 2. dist[i] 表示积木i到其所在积木列底部的距离（以积木数量为单位）
 * 3. size[i] 表示以积木i为根的积木列中积木的数量
 * 
 * 时间复杂度分析：
 * - prepare: O(n)
 * - find: O(α(n)) 近似O(1)
 * - union: O(α(n)) 近似O(1)
 * - query: O(α(n)) 近似O(1)
 * - 总体: O(n + P * α(n))
 * 
 * 空间复杂度: O(n) 用于存储father、dist和size数组
 * 
 * 应用场景：
 * - 积木叠放与查询
 * - 动态维护序列位置关系
 * - 游戏中的编队系统
 * 
 * 题目来源：POJ 1988
 * 题目链接：http://poj.org/problem?id=1988
 * 题目名称：Cube Stacking
 */

const int MAXN = 30001;

int n = 30000;
int father[MAXN];
int dist[MAXN];
int size[MAXN];

/**
 * 初始化并查集
 * 时间复杂度: O(n)
 * 空间复杂度: O(n)
 */
void prepare() {
    // 初始化每个积木为自己所在积木列的代表
    for (int i = 1; i <= n; i++) {
        father[i] = i;
        // 初始时每个积木到积木列底部的距离为0
        dist[i] = 0;
        // 初始时每个积木列只有1个积木
        size[i] = 1;
    }
}

/**
 * 查找积木i所在积木列的代表（底部），并进行路径压缩
 * 同时更新dist[i]为积木i到积木列底部的距离
 * 时间复杂度: O(α(n)) 近似O(1)
 * 
 * @param i 要查找的积木编号
 * @return 积木i所在积木列的代表（底部）
 */
int find(int i) {
    // 如果不是根节点
    if (i != father[i]) {
        // 保存父节点
        int tmp = father[i];
        // 递归查找根节点，同时进行路径压缩
        father[i] = find(tmp);
        // 更新距离：当前积木到积木列底部的距离 = 当前积木到父节点的距离 + 父节点到积木列底部的距离
        dist[i] += dist[tmp];
    }
    return father[i];
}

/**
 * 合并两个积木列，将包含积木x的积木列整体移动到包含积木y的积木列顶部
 * 时间复杂度: O(α(n)) 近似O(1)
 * 
 * @param x 积木x的编号
 * @param y 积木y的编号
 */
void unionSets(int x, int y) {
    // 查找两个积木所在积木列的代表
    int xf = find(x), yf = find(y);
    // 如果不在同一积木列中
    if (xf != yf) {
        // 将包含积木x的积木列合并到包含积木y的积木列顶部
        father[xf] = yf;
        // 更新包含积木x的积木列底部到包含积木y的积木列底部的距离
        // 距离 = 包含积木y的积木列的积木数量（即包含积木y的积木列顶部到新积木列底部的距离）
        dist[xf] += size[yf];
        // 更新新积木列的积木数量
        size[yf] += size[xf];
    }
}

/**
 * 查询积木x下方的积木数量
 * 时间复杂度: O(α(n)) 近似O(1)
 * 
 * @param x 积木x的编号
 * @return 积木x下方的积木数量
 */
int query(int x) {
    // 确保路径压缩完成
    find(x);
    // 积木x下方的积木数量 = 积木x到积木列底部的距离
    return dist[x];
}

// 由于环境限制，使用简化输入输出方式
// 实际实现中需要根据具体输入格式调整

int main() {
    prepare();
    // 由于环境限制，使用简化主函数
    // 实际实现中需要根据具体输入输出格式调整
    return 0;
}