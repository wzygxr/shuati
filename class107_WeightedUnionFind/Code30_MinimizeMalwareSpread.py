/**
 * LeetCode 924 - 尽量减少恶意软件的传播
 * https://leetcode-cn.com/problems/minimize-malware-spread/
 * 
 * 题目描述：
 * 在节点网络中，只有当 graph[i][j] = 1 时，节点 i 和节点 j 之间才有一条边。
 * 
 * 一些节点 initial 最初被恶意软件感染。只要两个节点直接相连，且其中至少一个节点是恶意软件，那么两个节点都将被恶意软件感染。
 * 这种恶意软件的传播将继续，直到没有更多的节点可以被感染。
 * 
 * 假设 M(initial) 是在恶意软件停止传播后的恶意软件感染的最终节点数。
 * 
 * 我们可以从 initial 中删除一个节点。如果移除这一节点将最小化 M(initial)， 则返回该节点的编号。
 * 如果有多个节点满足条件，就返回编号最小的节点。
 * 
 * 解题思路：
 * 1. 使用并查集找出图中的所有连通分量
 * 2. 统计每个连通分量中的节点数量
 * 3. 统计每个连通分量中的初始感染节点数量
 * 4. 对于每个初始感染节点，如果它所在的连通分量中只有它一个初始感染节点，那么移除它可以避免该连通分量中的所有节点被感染
 * 5. 选择可以避免最多节点被感染的初始感染节点；如果有多个，则选择编号最小的
 * 
 * 时间复杂度分析：
 * - 初始化并查集：O(n)
 * - 构建并查集（连接所有相连的节点）：O(n² * α(n))，其中α是阿克曼函数的反函数，近似为常数
 * - 统计连通分量信息：O(n)
 * - 遍历初始感染节点：O(m)，其中m是初始感染节点的数量
 * - 总体时间复杂度：O(n² * α(n)) ≈ O(n²)
 * 
 * 空间复杂度分析：
 * - 并查集数组：O(n)
 * - 连通分量信息数组：O(n)
 * - 总体空间复杂度：O(n)
 */

class MinimizeMalwareSpread:
    def __init__(self):
        # 并查集的父节点数组
        self.parent = []
        # 并查集的秩数组，用于按秩合并优化
        self.rank = []
    
    def find(self, x):
        """
        查找元素所在集合的根节点，并进行路径压缩
        
        参数:
            x (int): 要查找的节点
            
        返回:
            int: 根节点
        """
        if self.parent[x] != x:
            # 路径压缩：将x的父节点直接设置为根节点
            self.parent[x] = self.find(self.parent[x])
        return self.parent[x]
    
    def init_union_find(self, n):
        """
        初始化并查集
        
        参数:
            n (int): 节点数量
        """
        # 初始化，每个节点的父节点是自己，秩为0
        self.parent = list(range(n))
        self.rank = [0] * n
    
    def min_malware_spread(self, graph, initial):
        """
        尽量减少恶意软件的传播
        
        参数:
            graph (List[List[int]]): 图的邻接矩阵
            initial (List[int]): 初始感染节点数组
            
        返回:
            int: 应该删除的节点编号
        """
        n = len(graph)
        
        # 初始化并查集
        self.init_union_find(n)
        
        # 合并所有相连的节点
        for i in range(n):
            for j in range(i + 1, n):
                if graph[i][j] == 1:
                    root_i = self.find(i)
                    root_j = self.find(j)
                    
                    if root_i != root_j:
                        # 按秩合并：将秩小的树连接到秩大的树下
                        if self.rank[root_i] < self.rank[root_j]:
                            self.parent[root_i] = root_j
                        elif self.rank[root_i] > self.rank[root_j]:
                            self.parent[root_j] = root_i
                        else:
                            # 秩相同时，任选一个作为根，并增加其秩
                            self.parent[root_j] = root_i
                            self.rank[root_i] += 1
        
        # 统计每个连通分量中的节点数量
        size = [0] * n
        for i in range(n):
            size[self.find(i)] += 1
        
        # 统计每个连通分量中的初始感染节点数量
        malware_count = [0] * n
        for node in initial:
            malware_count[self.find(node)] += 1
        
        # 按照编号排序初始感染节点，以便在相同情况下选择编号最小的
        initial_sorted = sorted(initial)
        
        result = initial_sorted[0]  # 默认选择第一个初始感染节点
        max_saved = 0  # 可以避免感染的最大节点数量
        
        # 遍历每个初始感染节点
        for node in initial_sorted:
            root = self.find(node)
            
            # 如果该连通分量中只有一个初始感染节点，移除它可以避免该连通分量中的所有节点被感染
            if malware_count[root] == 1:
                saved = size[root]
                if saved > max_saved:
                    max_saved = saved
                    result = node
        
        return result

# 测试代码
def test_min_malware_spread():
    solution = MinimizeMalwareSpread()
    
    # 测试用例1
    graph1 = [
        [1, 1, 0],
        [1, 1, 0],
        [0, 0, 1]
    ]
    initial1 = [0, 1]
    print("测试用例1结果：", solution.min_malware_spread(graph1, initial1))
    # 预期输出：0
    
    # 测试用例2
    graph2 = [
        [1, 0, 0],
        [0, 1, 0],
        [0, 0, 1]
    ]
    initial2 = [0, 2]
    print("测试用例2结果：", solution.min_malware_spread(graph2, initial2))
    # 预期输出：0
    
    # 测试用例3
    graph3 = [
        [1, 1, 1],
        [1, 1, 1],
        [1, 1, 1]
    ]
    initial3 = [1, 2]
    print("测试用例3结果：", solution.min_malware_spread(graph3, initial3))
    # 预期输出：1
    
    # 测试用例4
    graph4 = [
        [1, 1, 0, 0],
        [1, 1, 1, 0],
        [0, 1, 1, 1],
        [0, 0, 1, 1]
    ]
    initial4 = [0, 3]
    print("测试用例4结果：", solution.min_malware_spread(graph4, initial4))
    # 预期输出：0

if __name__ == "__main__":
    test_min_malware_spread()

'''
Python特定优化：
1. 使用列表推导式初始化parent数组，提高代码简洁性
2. 使用sorted函数对初始感染节点进行排序
3. 只遍历矩阵的上三角部分，避免重复处理

算法思路详解：
1. 问题本质：找到删除一个初始感染节点后，可以避免最多节点被感染的节点
2. 并查集应用：并查集是找出连通分量的高效数据结构
3. 贪心策略：优先删除那些所在连通分量中只有一个初始感染节点的节点，这样可以避免整个连通分量被感染

工程化考量：
1. 输入验证：在实际应用中，需要验证输入图和初始感染节点的有效性
2. 性能优化：使用路径压缩和按秩合并优化并查集的性能
3. 可扩展性：可以将并查集抽象成一个独立的类，以便在其他问题中复用
4. 边界情况：需要处理空图、单个节点等情况

时间复杂度分析深入：
- 并查集的find和union操作的平均时间复杂度为O(α(n))，其中α是阿克曼函数的反函数
- 对于n个节点和O(n²)个可能的连接，总体时间复杂度为O(n² * α(n))
- 在实际应用中，α(n)增长极其缓慢，对于任何可能的n值，α(n)不超过4，因此可以近似认为是O(n²)

空间复杂度分析深入：
- 并查集需要两个长度为n的数组，因此空间复杂度为O(n)
- 统计数组的空间复杂度也为O(n)
- 总体空间复杂度为O(n)
'''