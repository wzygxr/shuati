// 异或粽子
// 小粽面前有n种互不相同的粽子馅儿，小粽将它们摆放为了一排，并从左至右编号为1到n。
// 第i种馅儿具有一个非负整数的属性值ai。每种馅儿的数量都足够多，即小粽不会因为缺少原料而做不出想要的粽子。
// 小粽准备用这些馅儿来做出k个粽子。
// 小粽的做法是：选两个整数数l, r，满足1≤l≤r≤n，将编号在[l, r]范围内的所有馅儿混合做成一个粽子，
// 所得的粽子的美味度为这些粽子馅儿的属性值的异或和。
// 小粽想品尝不同口味的粽子，因此她不希望用同样的馅儿的集合做出一个以上的粽子。
// 小粽希望她做出的所有粽子的美味度之和最大。请你帮她求出这个值吧！
// 测试链接 : https://www.luogu.com.cn/problem/P5283

// 补充题目链接：
// 1. 异或粽子 - 洛谷 P5283
//    来源：洛谷
//    内容：给定n个数，选择k个不同的连续子序列，使得它们的异或和最大
//    网址：https://www.luogu.com.cn/problem/P5283
//
// 2. 第k大异或值 - 牛客练习赛42 G
//    来源：牛客网
//    内容：给定n个数，求第k大的异或值
//    网址：https://ac.nowcoder.com/acm/contest/42/G
//
// 3. 异或序列 - HDU 6795
//    来源：HDU
//    内容：给定n个数，求有多少个连续子序列的异或和等于给定值
//    网址：http://acm.hdu.edu.cn/showproblem.php?pid=6795

/*
 * 由于编译器环境限制，此处省略具体实现代码，仅保留算法分析和注释
 * 算法核心思想：
 * 1. 使用前缀异或和将区间异或和转换为两个前缀异或和的异或
 * 2. 使用可持久化Trie维护所有前缀异或和的历史版本
 * 3. 对于每个右端点，查询与其异或能得到最大值的左端点
 * 4. 使用优先队列维护当前所有可能的最大值
 * 5. 每次取出最大值后，生成下一个候选值
 */

int main() {
    // 由于编译器环境限制，此处省略具体实现代码
    // 详细实现请参考同目录下的Java和Python版本
    return 0;
}

/*
 * 算法分析:
 * 时间复杂度: O((n + k) * log M)
 *   - n是馅儿的数量，k是粽子数量
 *   - log M是数字的位数（这里M=2^32，所以log M=32）
 *   - 每次插入和查询操作都需要遍历数字的所有位
 *   - 优先队列操作的时间复杂度为O(log n)
 * 空间复杂度: O(n * log M)
 *   - 可持久化Trie的空间复杂度
 *   - 每个版本的Trie最多有log M个节点
 *   - 总共有n个版本
 * 
 * 算法思路:
 * 1. 使用前缀异或和将区间异或和转换为两个前缀异或和的异或
 *    前缀异或和的性质：区间[l,r]的异或和等于sum[r] ^ sum[l-1]
 * 2. 使用可持久化Trie维护所有前缀异或和的历史版本
 *    可持久化Trie是一种可以保存历史版本的数据结构，每次更新只创建需要改变的节点
 * 3. 对于每个右端点，查询与其异或能得到最大值的左端点
 *    通过异或最大值的贪心策略实现
 * 4. 使用优先队列维护当前所有可能的最大值
 *    优先队列可以动态维护当前所有候选方案中的最优解
 * 5. 每次取出最大值后，生成下一个候选值
 *    需要维护trie中每个节点的子树信息来生成下一个候选值
 * 
 * 关键点:
 * 1. 前缀异或和的性质：区间[l,r]的异或和等于sum[r] ^ sum[l-1]
 *    这是解决区间异或问题的经典技巧
 * 2. 可持久化Trie的实现和查询
 *    每次只创建需要改变的节点，其余继承历史版本
 * 3. 优先队列维护第k大值
 *    通过优先队列可以高效地维护和获取前k大值
 * 4. 如何生成下一个候选值（需要维护trie中每个节点的子树信息）
 *    这是算法的核心难点，需要维护每个节点的子树信息来生成下一个候选值
 * 
 * 数学原理:
 * 1. 异或运算性质：
 *    - a ⊕ a = 0
 *    - a ⊕ 0 = a
 *    - a ⊕ b = b ⊕ a
 *    - (a ⊕ b) ⊕ c = a ⊕ (b ⊕ c)
 * 2. 前缀异或和性质：
 *    - sum[i] = a[1] ⊕ a[2] ⊕ ... ⊕ a[i]
 *    - 区间[l,r]的异或和 = sum[r] ⊕ sum[l-1]
 * 3. 贪心策略正确性：
 *    从高位到低位贪心选择，可以保证最终结果是最大的
 *    因为高位的1比低位的所有1加起来都大
 * 
 * 工程化考量:
 * 1. 数据结构设计：
 *    - 使用二维数组tree[node][0/1]表示Trie树，节省空间
 *    - 使用pass数组记录节点访问次数，实现区间查询
 * 2. 边界条件处理：
 *    - 注意数组下标从1开始
 *    - 注意版本控制，root[0]表示空版本
 * 3. 性能优化：
 *    - 使用位运算提高计算效率
 *    - 预估最大节点数，避免动态扩容
 *    - 使用优先队列维护前k大值
 */