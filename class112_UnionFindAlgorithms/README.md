# Class165 - 可持久化并查集、可撤销并查集和扩展域并查集

本目录包含以下几种高级并查集算法的实现，这些是普通并查集的扩展版本，用于解决更复杂的问题：

> 本文档详细介绍了三种高级并查集的原理、实现和应用场景，并提供了丰富的练习题和详细的代码解答。所有代码均提供Java、C++和Python三种语言实现，并包含详细的注释和复杂度分析。

## 1. 可持久化并查集 (Persistent Union-Find)

### 算法原理
可持久化并查集是支持版本回退操作的并查集，通过使用主席树（可持久化线段树）来维护父节点数组和秩数组，实现对历史版本的访问。可持久化并查集允许我们访问数据结构的历史版本，而不仅仅是当前状态。

### 核心特点
1. 支持合并操作（Union）
2. 支持查询操作（Find）
3. 支持版本回退（Version Rollback）
4. 不使用路径压缩，而是使用按秩合并来保证效率
5. 使用主席树维护可持久化数组

### 时间复杂度
- 合并操作：O(log²n)
- 查询操作：O(log²n)
- 空间复杂度：O(n log n)

### 相关题目及详细解析

#### 1. [洛谷 P3402 - 可持久化并查集](https://www.luogu.com.cn/problem/P3402)
- **题目大意**：实现支持版本回退的并查集，支持合并、查询和回退操作
- **解题思路**：使用主席树维护可持久化数组，实现可持久化并查集
- **时间复杂度**：O(m log²n)
- **空间复杂度**：O(n log n)
- **实现细节**：
  - 使用主席树维护父节点数组和秩数组
  - 每个版本保存父数组和秩数组的根节点
  - 合并时生成新的版本，查询时基于特定版本

#### 2. [NOI 2018 - 归程](https://www.luogu.com.cn/problem/P4768)
- **题目大意**：在一张图上进行多次询问，每次询问从某点开始，通过特定条件到达另一点的最短路径
- **解题思路**：可以使用可持久化并查集维护不同条件下的连通性，结合最短路算法解决
- **时间复杂度**：O((n + m) log n)
- **空间复杂度**：O(n log n)
- **实现细节**：
  - 先用Dijkstra算法计算各点到终点的最短距离
  - 将边按权值降序排序
  - 使用可持久化并查集维护不同水位下的连通性
  - 对于每个查询，找到最大的满足条件的水位，查询连通性

#### 3. [USACO 2018 Jan - MooTube](https://www.luogu.com.cn/problem/P4185)
- **题目大意**：在视频推荐系统中，根据相关性值查询两个视频是否相关
- **解题思路**：可以使用可持久化并查集维护不同相关性阈值下的连通性
- **时间复杂度**：O((n + m) log n)
- **空间复杂度**：O(n log n)
- **实现细节**：
  - 将边按相关性降序排序
  - 使用可持久化并查集维护不同阈值下的连通性
  - 对于每个查询，找到对应的版本并查询连通性

#### 4. [BZOJ 3674 - 可持久化并查集加强版](https://www.lydsy.com/JudgeOnline/problem.php?id=3674)
- **题目大意**：实现支持版本回退的并查集，支持合并、查询和回退操作，但数据规模更大
- **解题思路**：使用主席树维护可持久化数组，实现可持久化并查集
- **时间复杂度**：O(m log²n)
- **空间复杂度**：O(n log n)

#### 5. [HDU 6620 - Just an Old Puzzle](http://acm.hdu.edu.cn/showproblem.php?pid=6620)
- **题目大意**：判断一个数字拼图是否可以还原
- **解题思路**：可以使用可持久化并查集维护拼图的状态变化
- **时间复杂度**：O(n² log n)
- **空间复杂度**：O(n² log n)

#### 6. [Codeforces 1401F - Reverse and Swap](https://codeforces.com/problemset/problem/1401/F)
- **题目大意**：支持反转和交换操作的数据结构问题
- **解题思路**：可以使用可持久化并查集维护元素的位置关系
- **时间复杂度**：O(n log²n)
- **空间复杂度**：O(n log n)

## 2. 可撤销并查集 (Undo Union-Find)

### 算法原理
可撤销并查集支持撤销最近一次合并操作，通过记录每次合并时的状态变化，使用栈结构来实现撤销操作。这种数据结构在需要回溯状态的场景中非常有用，比如DFS搜索过程中的状态维护。

### 核心特点
1. 支持合并操作（Union）
2. 支持查询操作（Find）
3. 支持撤销操作（Undo）
4. 不使用路径压缩，只使用按秩合并
5. 使用栈记录操作历史，支持精确回退

### 时间复杂度
- 合并操作：O(log n)
- 查询操作：O(log n)
- 撤销操作：O(1)
- 空间复杂度：O(n)

### 相关题目及详细解析

#### 1. [AtCoder ABC302 H - Ball Collector](https://atcoder.jp/contests/abc302/tasks/abc302_h)
- **题目大意**：在一棵树上，每个节点有两个球，要求从根节点到每个节点的路径上收集球，使得收集的球编号各不相同
- **解题思路**：使用可撤销并查集维护连通性，在DFS过程中合并节点，回溯时撤销操作
- **时间复杂度**：O(n log n)
- **空间复杂度**：O(n)
- **实现细节**：
  - 每个球作为并查集中的一个节点
  - 对于每个节点，将其两个球合并到当前路径的集合中
  - 使用DFS遍历树，进入节点时执行合并，离开时执行撤销
  - 使用edgeCnt数组记录每个集合中的边数，当边数小于节点数时可以添加一个新球

#### 2. [Codeforces 891C - Envy](https://codeforces.com/problemset/problem/891/C)
- **题目大意**：给定一个图和一些边的集合，判断这些边是否可以同时出现在一个最小生成树中
- **解题思路**：使用可撤销并查集，按照Kruskal算法的思想，先加入权重小于当前查询边的边，然后尝试加入查询的边，如果会形成环则不能同时出现在MST中
- **时间复杂度**：O(m log m + q * k * log n)
- **空间复杂度**：O(n + m)
- **实现细节**：
  - 将所有边按权值排序
  - 将查询按最大边权分组
  - 对于每组查询，先加入所有权值小于查询组最大边权的边
  - 对查询组内的边，尝试用可撤销并查集合并，如果有环则该查询不可行
  - 处理完查询后撤销合并操作

#### 3. [Codeforces 1681F - Unique Occurrences](https://codeforces.com/problemset/problem/1681/F)
- **题目大意**：在树上处理路径查询问题，统计某些路径上唯一出现的颜色数量
- **解题思路**：可以使用可撤销并查集维护路径的连通性信息
- **时间复杂度**：O(n log n)
- **空间复杂度**：O(n)
- **实现细节**：
  - 使用离线处理方法，将查询按右端点排序
  - 使用颜色首次出现的位置记录
  - 使用可撤销并查集维护区间内的连通性

#### 4. [Codeforces 1291F - Coffee Varieties (hard version)](https://codeforces.com/problemset/problem/1291/F)
- **题目大意**：交互题，需要通过特定操作识别咖啡品种
- **解题思路**：可以使用可撤销并查集维护品种的等价关系
- **时间复杂度**：O(n log n)
- **空间复杂度**：O(n)
- **实现细节**：
  - 使用可撤销并查集记录品种之间的等价关系
  - 根据交互结果动态调整等价关系
  - 利用可撤销操作回溯到之前的状态

#### 5. [AtCoder ABC126 F - XOR Matching](https://atcoder.jp/contests/abc126/tasks/abc126_f)
- **题目大意**：构造满足特定异或条件的序列
- **解题思路**：可以使用可撤销并查集处理异或关系
- **时间复杂度**：O(2^m)
- **空间复杂度**：O(2^m)
- **实现细节**：
  - 使用可撤销并查集维护异或关系
  - 通过枚举可能的异或值构造满足条件的序列

#### 6. [Codeforces 1401F - Reverse and Swap](https://codeforces.com/problemset/problem/1401/F)
- **题目大意**：支持反转和交换操作的数据结构问题
- **解题思路**：可以结合可撤销并查集维护元素之间的关系
- **时间复杂度**：O(n log n)
- **空间复杂度**：O(n)

#### 7. [Codeforces 915F - Imbalance Value of a Tree](https://codeforces.com/problemset/problem/915/F)
- **题目大意**：计算树中所有路径的最大值与最小值之差的和
- **解题思路**：使用可撤销并查集，按边权排序后逐步合并，统计贡献
- **时间复杂度**：O(n log n)
- **空间复杂度**：O(n)
- **实现细节**：
  - 将边分别按权值升序和降序排序
  - 使用可撤销并查集统计不同权值范围内的连通块大小
  - 通过容斥原理计算所有路径的贡献

## 3. 扩展域并查集 (Extended Union-Find)

### 算法原理
扩展域并查集通过扩展节点域来处理元素之间的复杂关系，常用于解决种类并查集问题，如食物链问题。它通过为每个元素创建多个节点来表示不同的关系状态，从而能够处理更复杂的关系约束。

### 核心特点
1. 通过扩展节点域来表示不同种类的关系
2. 支持常规的合并和查询操作
3. 常用于解决敌我关系、食物链等复杂关系问题
4. 可以与可撤销并查集结合使用解决复杂问题

### 时间复杂度
- 合并操作：O(α(n))，其中α是阿克曼函数的反函数，近似于常数
- 查询操作：O(α(n))
- 空间复杂度：O(n)，其中n是元素数量

### 相关题目及详细解析

#### 1. [Codeforces 1444C - Team Building](https://codeforces.com/problemset/problem/1444/C)
- **题目大意**：给定一些人和他们的组别，以及一些矛盾关系，判断两个组是否可以组成一个二分图
- **解题思路**：使用扩展域并查集，对于同一组内的矛盾关系，先判断该组是否能构成二分图，对于不同组之间的矛盾关系，使用可撤销并查集判断两个组合并后是否能构成二分图
- **时间复杂度**：O((m + k) * log n)
- **空间复杂度**：O(n)
- **实现细节**：
  - 对于每个组，使用二分图染色的扩展域并查集
  - 对于矛盾关系(u, v)，将u与v的敌人合并
  - 使用可撤销并查集处理不同组之间的合并

#### 2. [洛谷 P2024 - 食物链（经典种类并查集）](https://www.luogu.com.cn/problem/P2024)
- **题目大意**：动物有三种关系：同类、捕食、被捕食，根据一些描述判断哪些描述是假的
- **解题思路**：使用扩展域并查集，为每个动物创建3个节点分别表示其作为同类、捕食者、被捕食者的关系
- **时间复杂度**：O(n + m)
- **空间复杂度**：O(n)
- **实现细节**：
  - 对于每个动物x，创建三个节点：x（同类）、x+n（捕食者）、x+2n（被捕食者）
  - 如果x和y是同类，则合并x与y，x+n与y+n，x+2n与y+2n
  - 如果x吃y，则合并x与y+n，x+n与y+2n，x+2n与y
  - 每次操作前检查是否存在矛盾

#### 3. [HDU 3038 - How Many Answers Are Wrong](http://acm.hdu.edu.cn/showproblem.php?pid=3038)
- **题目大意**：给出一些区间和的描述，判断哪些描述是错误的
- **解题思路**：使用扩展域并查集维护前缀和关系，将区间和转化为前缀和的差
- **时间复杂度**：O(n + m)
- **空间复杂度**：O(n)
- **实现细节**：
  - 使用带权并查集，权值表示从当前节点到根节点的和
  - 对于区间[l, r]的和为s，转化为前缀和sum[r] - sum[l-1] = s
  - 在合并时检查是否存在矛盾

#### 4. [AtCoder ABC126 F - XOR Matching](https://atcoder.jp/contests/abc126/tasks/abc126_f)
- **题目大意**：构造满足特定异或条件的序列
- **解题思路**：可以使用扩展域并查集处理异或关系
- **时间复杂度**：O(2^m)
- **空间复杂度**：O(2^m)
- **实现细节**：
  - 使用带权并查集维护异或关系
  - 权值表示两个节点之间的异或值
  - 通过枚举可能的异或值构造满足条件的序列

#### 5. [洛谷 P1955 - 程序自动分析](https://www.luogu.com.cn/problem/P1955)
- **题目大意**：判断一些约束条件是否能被同时满足
- **解题思路**：使用扩展域并查集维护变量之间的相等关系
- **时间复杂度**：O(n log n)
- **空间复杂度**：O(n)
- **实现细节**：
  - 先处理所有相等约束，将相等的变量合并
  - 再检查所有不等约束，判断是否存在矛盾

#### 6. [POJ 1733 - Parity game](http://poj.org/problem?id=1733)
- **题目大意**：判断一个01序列的某些子区间的奇偶性描述是否一致
- **解题思路**：使用扩展域并查集维护前缀和的奇偶关系
- **时间复杂度**：O(n log n)
- **空间复杂度**：O(n)
- **实现细节**：
  - 使用带权并查集，权值表示前缀和的奇偶性
  - 对于区间[l, r]有偶数个1，转化为sum[r] ≡ sum[l-1] (mod 2)
  - 对于区间[l, r]有奇数个1，转化为sum[r] ≡ sum[l-1] + 1 (mod 2)

#### 7. [洛谷 P1525 - 关押罪犯](https://www.luogu.com.cn/problem/P1525)
- **题目大意**：将罪犯分配到两个监狱，使得冲突值最大的一对罪犯的冲突值最小
- **解题思路**：使用扩展域并查集维护罪犯之间的敌对关系
- **时间复杂度**：O(n log n)
- **空间复杂度**：O(n)
- **实现细节**：
  - 将冲突按强度从大到小排序
  - 对于每个冲突(u, v)，检查u和v是否已经在同一个集合
  - 如果是，则这是当前最大的无法避免的冲突
  - 否则，将u与v的敌人合并，v与u的敌人合并

#### 8. [LeetCode 721 - 账户合并](https://leetcode.cn/problems/accounts-merge/)
- **题目大意**：将具有相同邮箱的账户合并
- **解题思路**：使用扩展域并查集维护邮箱和账户之间的关系
- **时间复杂度**：O(n log n)
- **空间复杂度**：O(n)
- **实现细节**：
  - 将每个邮箱映射到唯一的ID
  - 使用并查集合并同一账户的所有邮箱
  - 最后按账户分组收集所有邮箱

#### 9. [Codeforces 1380D - Berserk And Fireball](https://codeforces.com/problemset/problem/1380/D)
- **题目大意**：通过特定操作将数组转换为目标数组，计算最小成本
- **解题思路**：使用扩展域并查集维护区间的连通性
- **时间复杂度**：O(n log n)
- **空间复杂度**：O(n)
- **实现细节**：
  - 识别需要保留的元素位置
  - 使用并查集将连续的可操作区间合并
  - 对每个区间计算最小操作成本

#### 10. [HDU 4496 - D-City](http://acm.hdu.edu.cn/showproblem.php?pid=4496)
- **题目大意**：逐步删除边，每次删除后查询连通块数量
- **解题思路**：使用扩展域并查集，反向处理问题
- **时间复杂度**：O(m log n)
- **空间复杂度**：O(n + m)
- **实现细节**：
  - 初始时所有边都被删除
  - 按删除顺序的逆序添加边
  - 使用并查集维护连通块数量

## 文件说明

- `Code01_PersistentUnionFind1.java` - 可持久化并查集的Java实现
- `Code01_PersistentUnionFind2.cpp` - 可持久化并查集的C++实现
- `Code01_PersistentUnionFind3.py` - 可持久化并查集的Python实现
- `Code02_UndoUnionFind1.java` - 可撤销并查集的Java实现
- `Code02_UndoUnionFind2.cpp` - 可撤销并查集的C++实现
- `Code02_UndoUnionFind3.py` - 可撤销并查集的Python实现
- `Code03_Envy1.java` - 使用可撤销并查集解决Codeforces 891C问题的Java实现
- `Code03_Envy2.cpp` - 使用可撤销并查集解决Codeforces 891C问题的C++实现
- `Code03_Envy3.py` - 使用可撤销并查集解决Codeforces 891C问题的Python实现
- `Code04_TeamBuilding1.java` - 使用扩展域并查集解决Codeforces 1444C问题的Java实现
- `Code04_TeamBuilding2.cpp` - 使用扩展域并查集解决Codeforces 1444C问题的C++实现
- `Code04_TeamBuilding3.py` - 使用扩展域并查集解决Codeforces 1444C问题的Python实现
- `Code05_FoodChain.java` - 使用扩展域并查集解决食物链问题的Java实现
- `Code05_FoodChain.cpp` - 使用扩展域并查集解决食物链问题的C++实现
- `Code05_FoodChain.py` - 使用扩展域并查集解决食物链问题的Python实现
- `ADDITIONAL_PROBLEMS.md` - 补充题目列表
- `SUMMARY.md` - 三种并查集的详细对比与应用总结

## 算法技巧总结

### 可持久化并查集技巧
1. 使用主席树维护父节点数组和秩数组
2. 不使用路径压缩，使用按秩合并
3. 通过版本号管理历史状态
4. 适用于需要访问历史版本的场景

### 可撤销并查集技巧
1. 不使用路径压缩，只使用按秩合并
2. 用栈记录每次合并操作的关键信息
3. 撤销时恢复合并前的状态
4. 适用于需要回溯状态的场景，如DFS搜索

### 扩展域并查集技巧
1. 通过扩展节点域来表示不同种类的关系
2. 常用于处理敌我关系、食物链等问题
3. 可以与可撤销并查集结合使用解决复杂问题
4. 适用于需要维护多种关系状态的场景

## 工程化考量

1. **异常处理**：在实际应用中，应增加输入验证和异常处理
2. **性能优化**：合理使用按秩合并和路径压缩（在可持久化场景中不使用路径压缩）
3. **内存管理**：注意控制空间复杂度，避免内存溢出
4. **代码复用**：可以将并查集的通用操作封装成类或模块
5. **版本控制**：可持久化并查集需要良好的版本管理机制
6. **状态恢复**：可撤销并查集需要精确的状态恢复机制