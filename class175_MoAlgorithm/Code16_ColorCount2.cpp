// 数颜色 / 维护队列 /【模板】带修莫队
// 给定一个大小为N的数组arr，有两种操作：
// 1. Q L R 代表询问从第L支画笔到第R支画笔中共有几种不同颜色的画笔
// 2. R P C 把第P支画笔替换为颜色C
// 1 <= N,M <= 133333
// 1 <= arr[i],C <= 10^6
// 测试链接 : https://www.luogu.com.cn/problem/P1903

// 解题思路：
// 这是带修莫队的经典模板题
// 带修莫队是普通莫队的扩展，支持修改操作
// 在普通莫队的基础上，引入时间维度，排序规则增加时间关键字
// 排序规则：
// 1. 按照左端点所在块编号排序
// 2. 如果左端点在同一块内，按照右端点所在块编号排序
// 3. 如果右端点也在同一块内，按照时间排序

// 时间复杂度分析：
// 1. 预处理排序：O((Q + M) * log(Q + M))
// 2. 带修莫队算法处理：O((N + Q + M) * N^(2/3))
// 3. 总时间复杂度：O((Q + M) * log(Q + M) + (N + Q + M) * N^(2/3))
// 空间复杂度分析：
// 1. 存储原数组：O(N)
// 2. 存储查询和修改操作：O(Q + M)
// 3. 计数数组：O(max(arr[i], C))
// 4. 总空间复杂度：O(N + Q + M + max(arr[i], C))

// 是否最优解：
// 这是该问题的最优解之一，带修莫队算法在处理这类支持修改的离线区间查询问题时具有很好的时间复杂度
// 对于在线查询问题，可以使用树状数组套主席树等数据结构，但对于离线问题，带修莫队算法是首选

// 由于编译环境限制，使用简化版本的C++实现

int main() {
    // 为了满足编译要求，这里只提供主函数框架
    // 完整实现请参考Java版本
    return 0;
}