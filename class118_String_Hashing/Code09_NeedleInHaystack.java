package class105;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;
import java.io.PrintWriter;

/**
 * SPOJ 32 - A Needle in the Haystack 问题实现
 * <p>
 * 题目链接：https://www.spoj.com/problems/NHAY/
 * 题目链接(洛谷)：https://www.luogu.com.cn/problem/SP32
 * <p>
 * 题目描述：
 * 编写一个程序，在给定的输入字符串(haystack)中找到所有给定模式(needle)的出现位置。
 * 程序必须检测到干草堆中的所有针。它应该将针和干草堆作为输入，并输出每个出现的位置。
 * 字符从0开始编号，输出应该按升序排列。
 * <p>
 * 算法核心思想：
 * 1. 多项式滚动哈希：使用哈希函数将字符串转换为数值，实现高效比较
 * 2. 前缀哈希预处理：预先计算文本串的前缀哈希数组，支持O(1)时间查询任意子串哈希
 * 3. 滑动窗口比较：遍历文本串，比较每个可能位置的子串哈希值与模式串哈希值
 * 4. 预计算幂次数组：避免重复计算，提高哈希值计算效率
 * <p>
 * 多项式滚动哈希数学原理详解：
 * - 哈希函数定义：对于字符串s[0...n-1]，哈希值H(s) = s[0]*base^(n-1) + s[1]*base^(n-2) + ... + s[n-1]
 * - 前缀哈希公式：hash[i] = s[0]*base^i + s[1]*base^(i-1) + ... + s[i]
 * - 递推关系：hash[i] = hash[i-1] * base + s[i]
 * - 子串哈希公式：hash(l,r) = hash[r] - hash[l-1] * base^(r-l+1)（当l>0时）
 * - 数学原理：多项式展开和重组，确保可以通过前缀哈希值快速计算任意子串哈希值
 * <p>
 * 算法详细步骤：
 * 1. 预处理阶段：
 *    - 预计算幂次数组pow[i] = base^i，用于后续快速计算
 *    - 计算文本串haystack的前缀哈希数组，建立子串哈希计算基础
 *    - 计算模式串needle的完整哈希值，作为匹配比较的标准
 * 2. 匹配阶段：
 *    - 遍历haystack中所有可能的起始位置i，范围是0 <= i <= haystackLen - needleLen
 *    - 对于每个位置i，计算以i为起点、长度为needleLen的子串哈希值
 *    - 比较子串哈希值与needle哈希值，若相等则认为找到匹配位置
 * 3. 输出阶段：按升序输出所有匹配位置，每个测试用例间输出空行
 * <p>
 * 算法正确性证明：
 * - 假设哈希函数是完美的（无冲突），则哈希值相等意味着字符串相等
 * - 多项式哈希函数的线性性质保证了子串哈希计算的正确性
 * - 算法通过滑动窗口遍历所有可能位置，确保不会漏掉任何匹配
 * - 时间复杂度分析：
 *   - 预处理阶段：O(n + m)，其中n是haystack的长度，m是needle的长度
 *     - 幂次数组计算：O(n)，线性时间
 *     - 前缀哈希计算：O(n)，线性时间
 *     - 模式串哈希计算：O(m)，线性时间
 *   - 匹配阶段：O(n)，只需遍历haystack一次，每次哈希计算O(1)
 *   - 总体时间复杂度：O(n + m)，与KMP算法相同
 * <p>
 * 空间复杂度分析：
 * - 前缀哈希数组：O(n)，存储每个前缀的哈希值
 * - 幂次数组：O(n)，存储base的各次幂
 * - 模式串哈希值：O(1)，单个变量存储
 * - 总体空间复杂度：O(n)，主要受文本串长度影响
 * <p>
 * 哈希冲突概率分析与处理策略：
 * - 冲突概率：对于长度为L的字符串，使用base=499且不使用模数时，理论冲突概率约为1/L
 * - 单哈希方案：当前实现使用单个哈希函数，对于大多数测试用例足够安全
 * - 双哈希优化：使用两个不同的哈希函数（不同base和mod）可将冲突概率降低到接近零
 * - 模数选择：在生产环境中应使用大质数模数（如10^9+7或10^9+9）来防止溢出并减少冲突
 * - 冲突验证：哈希值匹配后可进行字符串实际比较，确保绝对正确性
 * <p>
 * 与KMP算法的详细比较：
 * - 时间复杂度：两者均为O(n+m)，理论上相同
 * - 实现复杂度：哈希方法实现更简单直观，KMP需要构建前缀函数
 * - 内存占用：哈希方法需要O(n)额外空间，KMP仅需O(m)额外空间
 * - 性能特点：
 *   - 哈希方法：预处理时间稍长，但代码简洁，常数较小
 *   - KMP算法：预处理更复杂，但在长模式串和重复比较场景下更有优势
 *   - 哈希方法在实际应用中通常更易于实现和调试
 * <p>
 * 实现优化建议：
 * 1. 添加模数运算：使用大质数模数防止long类型溢出
 * 2. 实现双哈希：同时使用两个不同的哈希函数，只有当两个哈希值都匹配时才认为匹配
 * 3. 添加冲突验证：哈希值匹配后进行实际字符串比较
 * 4. 优化字符映射：根据实际字符集范围调整映射方式，提高哈希分布均匀性
 * 5. 使用BigInteger：对于非常长的字符串，考虑使用BigInteger避免溢出
 * <p>
 * 算法应用场景：
 * - 文本搜索引擎的关键词匹配
 * - 病毒特征码检测
 * - 生物信息学中的DNA序列匹配
 * - 代码编辑器中的查找功能
 * - 网络入侵检测系统中的模式匹配
 * <p>
 * 相似题目：
 * 1. LeetCode 28: Find the Index of the First Occurrence in a String - 字符串匹配基础题
 * 2. Codeforces 471D: MUH and Cube Walls - 变种字符串匹配问题
 * 3. UVa 10298: Power Strings - 重复子串检测
 * 4. POJ 3461: Oulipo - 模式串匹配次数统计
 * 5. HDU 1711: Number Sequence - 数字序列匹配
 * 6. AtCoder ABC141E: Who Says a Pun? - 重复子串查找
 * 7. HackerRank: String Similarity - 字符串相似度计算
 * <p>
 * 测试链接：https://www.spoj.com/problems/NHAY/
 * <p>
 * 多语言实现计划：
 * - Java实现：当前文件
 * - Python实现：Code09_NeedleInHaystack.py（待实现）
 * - C++实现：Code09_NeedleInHaystack.cpp（待实现）
 * - Go实现：Code09_NeedleInHaystack.go（待实现）
 * 
 * @author Algorithm Journey
 * @version 1.0
 * @since 2024-01-01
 */

public class Code09_NeedleInHaystack {

	/**
 * 最大字符串长度，根据题目约束设置
 * SPOJ题目中haystack长度可能很大，设置为100万+10以容纳最长的输入
 * 注意：在实际应用中，可能需要根据内存限制和题目要求调整此值
 */
public static int MAXN = 1000010;

	/**
 * 哈希基数，选择一个较大的质数以减少哈希冲突
 * 使用质数499作为基数可以使哈希分布更均匀，减少碰撞概率
 * 注意：基数的选择会影响哈希函数的性能和冲突概率
 * 常用的基数还包括911、1009、1231等较大的质数
 */
public static int base = 499;

	/**
 * 存储base的幂次，用于快速计算子串哈希值
 * pow[i] = base^i，预计算避免重复计算
 * 这是多项式滚动哈希算法的关键组成部分，确保子串哈希计算的O(1)时间复杂度
 */
public static long[] pow = new long[MAXN];

	/**
 * 存储haystack的前缀哈希值
 * hash[i]表示haystack前i+1个字符（haystack[0...i]）的哈希值
 * 使用多项式滚动哈希算法计算，支持O(1)时间内推导出任意子串的哈希值
 */
public static long[] hash = new long[MAXN];

	/**
 * 存储needle的哈希值
 * 预先计算整个模式串的哈希值，用于与文本串子串进行比较
 * 使用与文本串相同的哈希函数，确保比较的一致性
 */
public static long needleHash;

	/**
 * 存储needle的长度
 * 用于确定子串长度和有效起始位置范围
 * 限制遍历范围为0 <= i <= haystackLen - needleLen，避免越界访问
 */
public static int needleLen;

	/**
 * 主方法，处理输入输出并执行字符串匹配算法
 * <p>
 * 该方法实现了完整的字符串匹配流程，从输入处理、预处理计算到匹配查找和结果输出。
 * 使用多项式滚动哈希技术实现高效的模式串匹配，能够处理多个测试用例。
 * <p>
 * 详细处理流程：
 * 1. 输入输出初始化：
 *    - 使用BufferedReader和PrintWriter提高大规模数据的读写效率
 *    - 避免使用Scanner和System.out.println以优化性能
 * 2. 测试用例处理循环：
 *    a. 循环读取输入直到结束（EOF）
 *    b. 读取模式串长度needleLen
 *    c. 读取模式串needle并转换为字符数组，提高访问效率
 *    d. 读取文本串haystack并转换为字符数组
 * 3. 预处理阶段：
 *    a. 预计算幂次数组：pow[i] = base^i，为子串哈希计算做准备
 *    b. 计算文本串前缀哈希数组：建立哈希值快速查询基础
 *    c. 计算模式串哈希值：作为匹配比较的基准
 * 4. 匹配查找阶段：
 *    a. 遍历文本串中所有可能的起始位置
 *    b. 对每个位置计算子串哈希并与模式串哈希比较
 *    c. 发现匹配时输出位置并标记found为true
 * 5. 结果输出与资源清理：
 *    a. 每个测试用例后输出空行
 *    b. 刷新输出缓冲区
 *    c. 关闭输入输出流，释放资源
 * <p>
 * 输入输出格式详解：
 * - 输入格式：每个测试用例包含三行
 *   1. 第一行：模式串的长度（整数）
 *   2. 第二行：模式串内容（字符串）
 *   3. 第三行：文本串内容（字符串）
 * - 输出格式：
 *   1. 按升序输出所有匹配位置（从0开始计数），每个位置占一行
 *   2. 各测试用例之间用一个空行分隔
 * <p>
 * 性能优化策略：
 * 1. 使用字符数组而非字符串直接访问，减少方法调用开销
 * 2. 预计算所有必要数据，避免重复计算
 * 3. 使用高效的输入输出流处理大规模数据
 * 4. 使用long类型存储哈希值，延迟溢出问题
 * 
 * @param args 命令行参数（未使用）
 * @throws IOException 当输入输出过程中发生异常时抛出
 * 
 * 时间复杂度分析：
 * - 单个测试用例：O(n + m)，其中n是文本串长度，m是模式串长度
 * - 总时间复杂度：O(T*(n+m))，其中T是测试用例数量
 * 
 * 空间复杂度分析：
 * - 固定数组空间：O(MAXN)，用于存储哈希数组和幂次数组
 * - 字符数组：O(n + m)，用于存储输入的字符串
 * - 总体空间复杂度：O(MAXN + n + m)
 */
	public static void main(String[] args) throws IOException {
		// 创建高效的输入输出流，适用于大规模数据处理
		BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
		PrintWriter out = new PrintWriter(new OutputStreamWriter(System.out));

		String line;
		// 持续读取输入直到结束（处理多个测试用例）
		while ((line = in.readLine()) != null && !line.isEmpty()) {
			// 读取needle的长度
			needleLen = Integer.valueOf(line);

			// 读取needle（模式串）并转换为字符数组
			char[] needle = in.readLine().toCharArray();

			// 读取haystack（文本串）并转换为字符数组
			char[] haystack = in.readLine().toCharArray();
			int haystackLen = haystack.length;

			// 预处理阶段1：预计算base的幂次数组
		// 这是多项式滚动哈希的基础，用于后续O(1)时间计算子串哈希值
		// 递推公式：pow[i] = pow[i-1] * base
		pow[0] = 1; // 基础情况：base^0 = 1
		for (int i = 1; i < haystackLen; i++) {
			// 递推计算各次幂，避免重复计算
			// 注意：在实际应用中，可能需要考虑溢出问题，添加模数运算
			pow[i] = pow[i - 1] * base; 
		}

			// 预处理阶段2：计算haystack的前缀哈希值数组
		// 使用多项式滚动哈希算法构建前缀哈希
		// hash[i]表示子串haystack[0...i]的哈希值
		hash[0] = haystack[0] - 'a' + 1; // 第一个字符的哈希值，加1避免0值
		// 字符加1的目的：
		// 1. 避免字符'a'被映射为0，失去区分度
		// 2. 确保空字符串和包含'a'的字符串有不同的哈希值
		for (int i = 1; i < haystackLen; i++) {
			// 哈希值递推公式：hash[i] = hash[i-1] * base + s[i]的映射值
			// 这个公式实际上构建了多项式：hash[i] = s[0]*base^i + s[1]*base^(i-1) + ... + s[i]
			hash[i] = hash[i - 1] * base + (haystack[i] - 'a' + 1);
		}

			// 预处理阶段3：计算needle的完整哈希值
		// 使用与文本串完全相同的哈希函数，确保比较的一致性
		// 这样可以保证当且仅当子串与模式串相同时哈希值才相等（假设无冲突）
		needleHash = needle[0] - 'a' + 1;
		for (int i = 1; i < needleLen; i++) {
			// 使用相同的递推公式：needleHash = needleHash * base + s[i]的映射值
			needleHash = needleHash * base + (needle[i] - 'a' + 1);
		}

			// 匹配阶段：遍历haystack，查找所有模式串的出现位置
		boolean found = false; // 标记是否找到匹配，虽然本算法总是输出找到的位置
		// 遍历所有可能的起始位置i
		// 起始位置范围是0 <= i <= haystackLen - needleLen
		// 这样可以确保子串i到i+needleLen-1不会越界
		for (int i = 0; i <= haystackLen - needleLen; i++) {
			// 计算以i为起点、长度为needleLen的子串哈希值
			// 调用substringHash方法，O(1)时间计算
			// 与预先计算好的needle哈希值进行比较
			if (substringHash(i, i + needleLen - 1) == needleHash) {
				// 哈希值匹配，认为找到了一个匹配位置
				// 注意：这里假设没有哈希冲突，实际应用中可能需要额外的字符串比较验证
				out.println(i); // 输出匹配位置（从0开始计数）
				found = true;
			}
		}

			// 每个测试用例之间输出一个空行
			out.println();
		}

		// 刷新输出缓冲区并关闭资源
		out.flush();
		out.close();
		in.close();
	}

	/**
 * 计算haystack中子串[l...r]的哈希值
 * <p>
 * 这是多项式滚动哈希算法的核心方法，通过巧妙的数学变换，利用预处理好的前缀哈希数组
 * 和幂次数组，在O(1)时间内计算任意子串的哈希值，无需重新扫描子串字符。
 * <p>
 * 数学原理详细推导：
 * 1. 前缀哈希定义：hash[r] = s[0]*base^r + s[1]*base^(r-1) + ... + s[r-1]*base + s[r]
 * 2. 子串哈希目标：计算hash(l,r) = s[l]*base^(r-l) + s[l+1]*base^(r-l-1) + ... + s[r]
 * 3. 观察到：hash[l-1] = s[0]*base^(l-1) + s[1]*base^(l-2) + ... + s[l-1]
 * 4. 计算hash[l-1] * base^(r-l+1)：
 *    = s[0]*base^r + s[1]*base^(r-1) + ... + s[l-1]*base^(r-l+1)
 * 5. 因此：hash[r] - hash[l-1] * base^(r-l+1)
 *    = s[l]*base^(r-l) + s[l+1]*base^(r-l-1) + ... + s[r]
 *    = hash(l,r)，即我们要求的子串哈希值
 * <p>
 * 数学示例计算：
 * 假设字符串为"abc"，base=10：
 * - hash[0] = 1
 * - hash[1] = 1*10 + 2 = 12
 * - hash[2] = 12*10 + 3 = 123
 * - 计算子串"bc"的哈希值 (l=1, r=2)：
 *   hash(1,2) = hash[2] - hash[0] * 10^(2-1+1)
 *             = 123 - 1*100
 *             = 23
 *   而直接计算：2*10 + 3 = 23，验证了公式的正确性
 * <p>
 * 实现细节解析：
 * - 当l=0时，子串即为前缀s[0...r]，直接返回hash[r]
 * - 当l>0时，需要从hash[r]中移除前缀s[0...l-1]的影响
 * - 移除方式是减去hash[l-1] * pow[r-l+1]，其中pow[r-l+1]是base的(r-l+1)次幂
 * - 这里的乘法操作实际上是将前缀哈希值提升到与hash[r]中对应部分相同的量级
 * <p>
 * 潜在问题与解决方案：
 * 1. 整数溢出问题：
 *    - Java中long类型最大值约为9.2×10^18，对于长字符串和大基数可能溢出
 *    - 解决方案：添加大质数模数，如10^9+7或10^9+9
 *    - 在模数运算中，需要注意负数处理：ans = (ans % mod + mod) % mod
 * <p>
 * 2. 哈希冲突问题：
 *    - 不同的子串可能产生相同的哈希值，导致误判
 *    - 解决方案：
 *      a. 使用双哈希（两个不同的哈希函数）
 *      b. 对哈希值相同的情况进行实际字符串比较
 *      c. 选择合适的base和mod值，减少冲突概率
 * <p>
 * 优化建议：
 * - 添加模数运算防止溢出
 * - 实现双哈希机制提高可靠性
 * - 考虑添加一个辅助方法用于实际字符串比较，在哈希值相等时调用
 * 
 * @param l 子串的起始位置（包含，从0开始）
 * @param r 子串的结束位置（包含，从0开始）
 * @return 子串[l...r]的哈希值
 * 
 * 时间复杂度：O(1) - 只需几次算术运算，与子串长度无关
 * 空间复杂度：O(1) - 不使用额外空间，仅依赖预计算的数组
 */
	public static long substringHash(int l, int r) {
		// 初始值为hash[r]（从0到r的前缀哈希值）
		long ans = hash[r];
		
		// 如果起始位置不是0，则需要减去前面部分的影响
		if (l > 0) {
			// 减去0到l-1的前缀哈希值乘以base^(r-l+1)
			// 这一步是为了移除子串前面部分的影响，确保只保留子串[l...r]的哈希值
			ans -= hash[l - 1] * pow[r - l + 1];
		}
		
		// 返回子串[l...r]的哈希值
		return ans;
	}
	
	/*
	 * ============================================================================
	 * 哈希冲突概率数学分析
	 * ============================================================================
	 * 哈希冲突是指不同的字符串产生相同哈希值的现象，这在所有哈希算法中都可能发生。
	 * 对于多项式滚动哈希，冲突概率的分析对于评估算法的可靠性至关重要。
	 * 
	 * 1. 基数选择的影响：
	 *    - 基数过小：哈希值空间较小，容易发生碰撞
	 *    - 基数过大：计算开销增加，但碰撞概率降低
	 *    - 最佳实践：选择较大的质数（如499、911、1009）作为基数
	 *    - 理论分析：当基数b大于字符集大小时，单字符哈希不会冲突
	 * 
	 * 2. 模数选择的影响：
	 *    - 无模数情况：使用64位整数存储，哈希空间大小为2^64
	 *    - 有模数情况：哈希空间大小为mod值
	 *    - 模数选择原则：使用大质数模数（如10^9+7、10^9+9）
	 *    - 冲突概率：近似为1/mod，使用双模数可进一步降低
	 * 
	 * 3. 哈希空间大小对冲突概率的影响：
	 *    - 无模数64位哈希：空间大小约9.2×10^18
	 *    - 单模数10^9+7：空间大小约1×10^9
	 *    - 双模数组合：空间大小约1×10^18（10^9+7 × 10^9+9）
	 *    - 理论保障：更大的空间意味着更低的冲突概率
	 * 
	 * 4. 生日悖论在字符串哈希中的应用：
	 *    - 问题描述：当哈希空间大小为M，随机选择k个元素时，至少有一对碰撞的概率
	 *    - 计算公式：P(k) ≈ 1 - e^(-k²/(2M))
	 *    - 实际应用：
	 *      - 64位无模数哈希，1亿个字符串：P ≈ 1 - e^(-(10^8)²/(2×9.2×10^18)) ≈ 5.4×10^-4
	 *      - 单模数10^9+7，1亿个字符串：P ≈ 1 - e^(-(10^8)²/(2×10^9)) ≈ 1（几乎必然冲突）
	 *      - 双模数组合，1亿个字符串：P ≈ 1 - e^(-(10^8)²/(2×10^18)) ≈ 5×10^-4
	 * 
	 * 5. 安全界限评估：
	 *    - 生产环境安全阈值：碰撞概率应低于10^-9
	 *    - 64位无模数哈希的安全使用量：k < sqrt(2M×ln(1/(1-10^-9))) ≈ 1.3×10^10
	 *    - 单模数10^9+7的安全使用量：k < sqrt(2M×ln(1/(1-10^-9))) ≈ 4.5×10^4
	 *    - 结论：对于大规模应用，必须使用双哈希或64位哈希
	 * 
	 * 6. 实际应用中的最佳实践：
	 *    - 对于中小规模应用：使用64位无模数哈希或单模数哈希即可
	 *    - 对于大规模应用：必须使用双哈希或更大模数
	 *    - 安全第一场景：哈希值匹配后进行字符串实际比较
	 *    - 性能与安全平衡：根据数据规模选择合适的哈希方案
	 */
	
	/*
	 * ============================================================================
	 * 双哈希实现示例
	 * ============================================================================
	 * 双哈希是一种通过同时使用两个独立哈希函数来降低冲突概率的技术。
	 * 只有当两个哈希函数都产生相同结果时，才认为字符串相等。
	 * 
	 * 1. 双哈希参数定义：
	 */
	/*
	// 双哈希实现的常量定义
public static final int MAXN = 1000010;
public static final int BASE1 = 499;     // 第一个哈希基数
public static final int BASE2 = 911;     // 第二个哈希基数
public static final long MOD1 = 1000000007; // 第一个模数
public static final long MOD2 = 1000000009; // 第二个模数

// 存储两个哈希函数的幂次数组
public static long[] pow1 = new long[MAXN];
public static long[] pow2 = new long[MAXN];

// 存储两个哈希函数的前缀哈希数组
public static long[] hash1 = new long[MAXN];
public static long[] hash2 = new long[MAXN];

// 存储模式串的两个哈希值
public static long needleHash1;
public static long needleHash2;
	 */
	
	/*
	 * 2. 双哈希预处理方法：
	 */
	/*
	public static void precompute(char[] haystack, char[] needle) {
		int haystackLen = haystack.length;
		int needleLen = needle.length;
		
		// 预计算第一个哈希函数的幂次数组
		pow1[0] = 1;
		for (int i = 1; i < haystackLen; i++) {
			pow1[i] = (pow1[i-1] * BASE1) % MOD1;
		}
		
		// 预计算第二个哈希函数的幂次数组
		pow2[0] = 1;
		for (int i = 1; i < haystackLen; i++) {
			pow2[i] = (pow2[i-1] * BASE2) % MOD2;
		}
		
		// 计算第一个哈希函数的前缀哈希数组
		hash1[0] = (haystack[0] - 'a' + 1) % MOD1;
		for (int i = 1; i < haystackLen; i++) {
			hash1[i] = (hash1[i-1] * BASE1 + (haystack[i] - 'a' + 1)) % MOD1;
		}
		
		// 计算第二个哈希函数的前缀哈希数组
		hash2[0] = (haystack[0] - 'a' + 1) % MOD2;
		for (int i = 1; i < haystackLen; i++) {
			hash2[i] = (hash2[i-1] * BASE2 + (haystack[i] - 'a' + 1)) % MOD2;
		}
		
		// 计算模式串的第一个哈希值
		needleHash1 = (needle[0] - 'a' + 1) % MOD1;
		for (int i = 1; i < needleLen; i++) {
			needleHash1 = (needleHash1 * BASE1 + (needle[i] - 'a' + 1)) % MOD1;
		}
		
		// 计算模式串的第二个哈希值
		needleHash2 = (needle[0] - 'a' + 1) % MOD2;
		for (int i = 1; i < needleLen; i++) {
			needleHash2 = (needleHash2 * BASE2 + (needle[i] - 'a' + 1)) % MOD2;
		}
	}
	 */
	
	/*
	 * 3. 双哈希子串哈希计算方法：
	 */
	/*
	public static long substringHash1(int l, int r) {
		if (l == 0) {
			return hash1[r];
		}
		long ans = (hash1[r] - hash1[l-1] * pow1[r-l+1]) % MOD1;
		return ans < 0 ? ans + MOD1 : ans;
	}
	
	public static long substringHash2(int l, int r) {
		if (l == 0) {
			return hash2[r];
		}
		long ans = (hash2[r] - hash2[l-1] * pow2[r-l+1]) % MOD2;
		return ans < 0 ? ans + MOD2 : ans;
	}
	 */
	
	/*
	 * 4. 双哈希比较方法（在main函数中的应用）：
	 */
	/*
	// 在main函数的匹配循环中使用双哈希
	for (int i = 0; i <= haystackLen - needleLen; i++) {
		long h1 = substringHash1(i, i + needleLen - 1);
		long h2 = substringHash2(i, i + needleLen - 1);
		
		// 只有当两个哈希值都匹配时，才认为找到匹配
		if (h1 == needleHash1 && h2 == needleHash2) {
			// 可选：对于极重要的应用，可以再进行一次字符串实际比较
			// if (verifyEqual(haystack, needle, i)) {
				out.println(i);
				found = true;
			// }
		}
	}
	
	// 字符串实际比较验证函数（哈希冲突概率极低时可选）
	public static boolean verifyEqual(char[] haystack, char[] needle, int start) {
		for (int i = 0; i < needle.length; i++) {
			if (haystack[start + i] != needle[i]) {
				return false;
			}
		}
		return true;
	}
	 */
	
	/*
	 * ============================================================================
	 * 推荐测试用例
	 * ============================================================================
	 * 以下是针对SPOJ 32问题的全面测试用例，覆盖各种边界情况和关键场景。
	 * 
	 * 1. 基本功能测试：
	 *    - 测试用例1：标准匹配
	 *      输入：
	 *      3
	 *      abc
	 *      abcabcabc
	 *      预期输出：0
	 *      3
	 *      6
	 *      
	 *    - 测试用例2：无匹配情况
	 *      输入：
	 *      3
	 *      xyz
	 *      abcabcabc
	 *      预期输出：（空行）
	 * 
	 * 2. 边界情况测试：
	 *    - 测试用例3：模式串长度为1
	 *      输入：
	 *      1
	 *      a
	 *      abac
	 *      预期输出：0
	 *      2
	 *      
	 *    - 测试用例4：模式串等于文本串
	 *      输入：
	 *      5
	 *      hello
	 *      hello
	 *      预期输出：0
	 *      
	 *    - 测试用例5：模式串长于文本串（无解）
	 *      输入：
	 *      5
	 *      hello
	 *      hi
	 *      预期输出：（空行）
	 * 
	 * 3. 特殊模式测试：
	 *    - 测试用例6：重复字符模式
	 *      输入：
	 *      4
	 *      aaaa
	 *      aaaaaaaaaa
	 *      预期输出：0
	 *      1
	 *      2
	 *      3
	 *      4
	 *      5
	 *      6
	 *      
	 *    - 测试用例7：重叠匹配
	 *      输入：
	 *      3
	 *      aba
	 *      abababa
	 *      预期输出：0
	 *      2
	 *      4
	 * 
	 * 4. 大输入性能测试：
	 *    - 测试用例8：大规模文本串（如10^6字符），模式串在末尾
	 *      构造方法：生成10^6-1个'a'，最后一个字符为'a'，模式串为最后10个字符
	 *      预期：应能在合理时间内找到匹配位置999990
	 * 
	 *    - 测试用例9：多测试用例连续处理
	 *      构造方法：连续100个小测试用例，测试程序的连续处理能力
	 *      预期：所有测试用例都能正确处理并输出
	 * 
	 * 5. 测试用例设计原则：
	 *    - 覆盖尽可能多的字符组合和长度范围
	 *    - 包含各种边界条件（空串、最大长度、最小长度等）
	 *    - 设计能够触发哈希冲突的测试用例（如果能找到）
	 *    - 测试多测试用例场景下的正确性
	 *    - 验证性能在大规模输入下的表现
	 */
	
	/*
	 * ============================================================================
	 * 字符串哈希算法比较分析
	 * ============================================================================
	 * 以下是多项式滚动哈希与其他常用字符串匹配算法的详细对比。
	 * 
	 * | 算法类型 | 时间复杂度 | 空间复杂度 | 实现复杂度 | 优势场景 | 劣势场景 |
	 * |---------|----------|-----------|-----------|---------|--------|
	 * | 多项式滚动哈希 | O(n+m) | O(n) | 低 | 实现简单、代码简洁、支持快速子串查询 | 可能有哈希冲突、需要处理溢出 |
	 * | KMP算法 | O(n+m) | O(m) | 中 | 无冲突保证、适合重复模式匹配 | 需要构建前缀数组、实现较复杂 |
	 * | Rabin-Karp | O(n+m) | O(1) | 低-中 | 多个模式串匹配、滚动哈希变种 | 最坏情况O(nm)、依赖哈希质量 |
	 * | Suffix Automaton | O(n) 构建，O(m) 查询 | O(n) | 高 | 多模式匹配、重复子串分析 | 实现复杂、概念抽象 |
	 * | Trie树 | 构建O(m)，查询O(m) | O(m) | 中 | 前缀匹配、自动补全 | 空间占用大、不适合长文本 |
	 * | 暴力匹配 | O(nm) | O(1) | 极低 | 小规模数据、简单场景 | 大规模数据性能极差 |
	 * 
	 * 1. 多项式滚动哈希的关键优势：
	 *    - 实现简单直观，代码量少
	 *    - 支持O(1)时间查询任意子串哈希值
	 *    - 适合需要频繁比较不同子串的场景
	 *    - 常数因子小，实际运行速度快
	 *    - 易于扩展为双哈希，提高可靠性
	 * 
	 * 2. 与KMP算法的深入比较：
	 *    - 时间复杂度：两者均为O(n+m)，理论上等价
	 *    - 空间复杂度：哈希O(n) vs KMP O(m)，KMP略优
	 *    - 实现难度：哈希方法更简单，KMP需要理解前缀函数
	 *    - 可靠性：KMP无冲突，哈希可能有冲突
	 *    - 适用场景：哈希适合需要多次查询不同子串的场景，KMP适合单次匹配
	 * 
	 * 3. 与Suffix Automaton的比较：
	 *    - 构建复杂度：哈希远低于自动机
	 *    - 功能强大性：自动机在复杂字符串分析任务中更强大
	 *    - 空间效率：自动机通常更节省空间
	 *    - 应用场景：哈希适合简单匹配，自动机适合复杂分析
	 * 
	 * 4. 算法选择建议：
	 *    - 竞赛编程：多项式滚动哈希（实现快、代码短）或KMP（无冲突）
	 *    - 工程应用：根据具体需求选择
	 *      - 追求可靠性：KMP或后缀数组
	 *      - 追求开发效率：多项式滚动哈希（加双哈希）
	 *      - 复杂字符串分析：后缀自动机或后缀树
	 *    - 大规模数据：考虑后缀数组或优化的哈希实现
	 * 
	 * 5. 实际应用中的性能考量：
	 *    - 哈希方法在短模式串场景下通常更快
	 *    - KMP在长模式串和重复比较场景下有优势
	 *    - 双哈希会增加约50-100%的计算开销，但大幅提高可靠性
	 *    - 选择合适的哈希参数对性能和冲突概率都有重要影响
	 */
}