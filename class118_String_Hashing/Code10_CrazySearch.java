package class105;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;
import java.io.PrintWriter;
import java.util.HashSet;

/**
 * POJ 1200 Crazy Search 问题实现
 * <p>
 * 题目链接：http://poj.org/problem?id=1200
 * <p>
 * 题目描述：
 * 给定子串长度N，字符中不同字符数量NC，以及一个字符串，求该字符串中长度为N的不同子串数量。
 * 字符串中的不同字符数不超过NC，且NC不大于26。
 * <p>
 * 算法核心思想：
 * 1. 字符映射：将每个不同的字符映射到唯一的数字ID，用于数值化处理
 * 2. 滚动哈希：使用多项式滚动哈希技术高效计算连续子串的哈希值
 * 3. 哈希集合去重：利用HashSet的特性自动统计不同子串的数量
 * <p>
 * 算法详细步骤：
 * 1. 数据预处理：
 *    - 读取输入参数：子串长度n和字符种类数nc
 *    - 读取输入字符串
 *    - 创建字符到数字的映射表
 * 2. 哈希计算阶段：
 *    - 计算第一个长度为n的子串的哈希值
 *    - 使用滚动哈希技术计算后续所有子串的哈希值
 *    - 将每个子串的哈希值存入HashSet
 * 3. 结果输出：
 *    - HashSet的大小即为不同子串的数量
 * <p>
 * 算法优势：
 * - 高效性：滚动哈希使得子串哈希计算时间复杂度降为O(1) per substring
 * - 简洁性：利用HashSet自动去重，代码逻辑清晰
 * - 扩展性：可应用于各种子串统计问题
 * <p>
 * 时间复杂度分析：
 * - 字符映射阶段：O(M)，其中M是字符串长度
 * - 预处理pow值：O(N)
 * - 第一个子串哈希计算：O(N)
 * - 滚动哈希计算：O(M-N)
 * - 总体时间复杂度：O(M)
 * <p>
 * 空间复杂度分析：
 * - 字符映射表：O(256) = O(1)
 * - 哈希集合：O(M-N+1) = O(M)
 * - 总体空间复杂度：O(M)
 * <p>
 * 哈希冲突处理：
 * - 理论上可能存在哈希冲突（不同字符串产生相同哈希值）
 * - 在POJ 1200问题中，由于数据规模和测试用例限制，使用单一哈希通常可以通过
 * - 对于更严格的应用场景，可以采用双哈希（两个不同哈希函数）和大质数模数
 * <p>
 * 滚动哈希技术详解：
 * 假设字符串为s[0...m-1]，子串长度为n，则：
 * 1. 第一个子串s[0...n-1]的哈希值为：hash = s[0]*base^(n-1) + s[1]*base^(n-2) + ... + s[n-1]
 * 2. 下一个子串s[1...n]的哈希值为：hash = (hash - s[0]*base^(n-1))*base + s[n]
 * 3. 这样，每个新子串的哈希值可以在O(1)时间内计算，无需重新计算整个子串
 * <p>
 * 与其他方法比较：
 * 1. 暴力方法：O(M*N)时间复杂度，效率低下
 * 2. Trie树方法：空间消耗较大，但在处理所有可能长度子串时更有优势
 * 3. 后缀数组方法：对于多模式匹配更高效，但实现复杂
 * <p>
 * 相似题目：
 * 1. LeetCode 1698: Number of Distinct Substrings in a String - 统计所有不同子串数量
 * 2. Codeforces 271D: Good Substrings - 统计满足条件的子串数量
 * 3. POJ 3461: Oulipo - 模式串匹配次数统计
 * 4. HDU 1251: 统计难题 - 前缀统计问题
 * 5. UVa 11475: Extend to Palindrome - 字符串扩展问题
 * <p>
 * 测试链接：http://poj.org/problem?id=1200
 * <p>
 * 三种语言实现参考：
 * - Java实现：当前文件
 * - Python实现：Code10_CrazySearch.py
 * - C++实现：Code10_CrazySearch.cpp
 * 
 * 哈希算法的数学原理：
 * 多项式哈希函数的数学定义：hash(s) = (s₀×bⁿ⁻¹ + s₁×bⁿ⁻² + ... + sₙ₋₁×b⁰) mod m
 * 其中：
 * - s₀,s₁,...,sₙ₋₁是字符串中各字符的数值映射
 * - b是哈希基数（base），通常选择较大的质数
 * - m是模数，用于防止数值溢出
 * <p>
 * 滚动哈希的数学证明：
 * 假设我们有子串s[i...i+n-1]的哈希值为：
 * hash = s[i]×bⁿ⁻¹ + s[i+1]×bⁿ⁻² + ... + s[i+n-1]×b⁰
 * 
 * 则下一个子串s[i+1...i+n]的哈希值为：
 * next_hash = s[i+1]×bⁿ⁻¹ + s[i+2]×bⁿ⁻² + ... + s[i+n]×b⁰
 * 
 * 我们可以通过数学变换得到：
 * next_hash = (hash - s[i]×bⁿ⁻¹) × b + s[i+n]
 * 
 * 证明：
 * (hash - s[i]×bⁿ⁻¹) × b = (s[i+1]×bⁿ⁻² + ... + s[i+n-1]×b⁰) × b
 *                         = s[i+1]×bⁿ⁻¹ + ... + s[i+n-1]×b¹
 * 
 * 添加s[i+n]×b⁰后：
 * (hash - s[i]×bⁿ⁻¹) × b + s[i+n] = s[i+1]×bⁿ⁻¹ + ... + s[i+n-1]×b¹ + s[i+n]×b⁰ = next_hash
 * 
 * 这证明了滚动哈希公式的正确性，使得我们可以在O(1)时间内计算下一个子串的哈希值。
 * 
 * @author Algorithm Journey
 */

public class Code10_CrazySearch {

    /**
     * 最大字符串长度，根据题目约束设置为足够大
     * POJ 1200题目中字符串长度可能很大，设置为16,000,000以应对大数据量
     * 
     * 内存占用分析：
     * - 一个char在Java中占2字节
     * - 16,000,000个char约占用32MB内存，在现代计算机中是可接受的
     * - 这个大小足以处理POJ 1200题目的输入规模
     * 
     * 优化考虑：
     * - 如果内存有限，可以动态分配数组大小，而不是预分配这么大的空间
     * - 例如：可以在读取输入字符串后，使用s.toCharArray()直接获取数组
     */
    public static int MAXN = 16000000;
    
    /**
     * 哈希基数，选择131作为哈希基数以减少哈希冲突
     * 131是一个常用的哈希基数，在字符串哈希中表现良好
     * 
     * 数学原理：
     * - 选择质数作为基数可以有效降低哈希冲突的概率
     * - 质数的因数少，使得不同字符串生成相同哈希值的可能性降低
     * 
     * 常见基数比较：
     * - 131: 较小质数，计算速度快，冲突概率较低，广泛应用于字符串哈希
     * - 499: 中等大小质数，平衡性好
     * - 911: 较大质数，冲突概率更低，但计算开销略大
     * - 13331: 更大的质数，适用于对哈希冲突要求更严格的场景
     * 
     * 注意事项：
     * - 在Java中，整数相乘可能导致溢出
     * - 对于长字符串或大规模数据，应考虑使用模数或long类型
     */
    public static int base = 131;
    
    /**
     * 存储输入字符串的字符数组
     * 使用字符数组而非字符串可以提高访问效率
     */
    public static char[] str = new char[MAXN];
    
    /**
     * 存储子串哈希值的集合，用于去重并统计不同子串的数量
     * HashSet提供O(1)的插入和查找操作，适合用于去重统计
     */
    public static HashSet<Long> hashSet = new HashSet<>();
    
    /**
     * 主方法，处理输入输出并调用子串统计函数
     * <p>
     * 处理流程：
     * 1. 初始化高效的输入输出流
     * 2. 读取输入参数：子串长度n和字符种类数nc
     * 3. 读取输入字符串
     * 4. 将字符串转换为字符数组以提高处理效率
     * 5. 调用countUniqueSubstrings函数计算不同子串数量
     * 6. 输出结果并关闭资源
     * <p>
     * 输入格式：
     * 第一行：两个整数n和nc，分别表示子串长度和不同字符数量
     * 第二行：输入字符串
     * <p>
     * 输出格式：
     * 一个整数，表示长度为n的不同子串的数量
     * 
     * IO优化说明：
     * - 使用BufferedReader代替Scanner可以显著提高大输入时的读取速度
     * - 使用PrintWriter代替System.out.println可以提高输出效率，特别是当输出量较大时
     * - 使用BufferedReader的readLine()方法一次读取整行，减少IO操作次数
     * 
     * 内存优化说明：
     * - 对于大规模数据，预分配足够大的字符数组可以避免频繁的内存分配
     * - 使用String的getChars()方法直接将字符串内容复制到字符数组，比逐个字符复制更高效
     * 
     * @param args 命令行参数
     * @throws IOException 输入输出异常
     * 
     * 时间复杂度：O(M)，其中M是字符串长度
     * 空间复杂度：O(M)
     */
    public static void main(String[] args) throws IOException {
        // 为了提高输入输出效率，使用BufferedReader和PrintWriter
        // 对于大数据量的输入输出，这比Scanner和System.out更高效
        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
        PrintWriter out = new PrintWriter(new OutputStreamWriter(System.out));
        
        // 读取第一行，包含子串长度n和字符种类数nc
        String line = in.readLine();
        String[] parts = line.split(" ");
        int n = Integer.parseInt(parts[0]); // 子串长度
        int nc = Integer.parseInt(parts[1]); // 字符种类数
        
        // 读取输入字符串
        String s = in.readLine();
        int len = s.length();
        
        // 输入验证
        // 检查子串长度是否合法
        if (n <= 0) {
            out.println(0);
            out.flush();
            out.close();
            in.close();
            return;
        }
    
	/*
	 * ============================================================================
	 * 哈希冲突概率数学分析
	 * ============================================================================
	 * 哈希冲突是指不同的字符串产生相同哈希值的现象。在POJ 1200问题中，哈希冲突会
	 * 导致不同子串被错误地视为相同子串，从而低估结果值。
	 * 
	 * 1. 当前实现的哈希冲突风险：
	 *    - 当前代码没有使用模数，哈希值可能会溢出long的范围
	 *    - Java中long类型的范围是-9×10^18到9×10^18
	 *    - 对于长字符串或大base值，哈希值极易溢出，导致哈希冲突
	 *    - 溢出后的哈希值计算将不再符合多项式哈希的数学性质
	 * 
	 * 2. 生日悖论与哈希空间：
	 *    - 对于POJ 1200问题，不同子串数量最多为M-N+1（M是字符串长度）
	 *    - 假设M=10^6，N=1，最多有10^6个子串
	 *    - 使用long的哈希空间大小约为1.8×10^19
	 *    - 理论冲突概率：P ≈ 1 - e^(-(10^6)^2/(2×1.8×10^19)) ≈ 2.8×10^-8
	 *    - 实际风险：由于溢出和未使用模数，实际冲突概率远高于理论值
	 * 
	 * 3. 模数选择的影响分析：
	 *    - 推荐使用大质数作为模数：例如10^9+7、10^9+9、1e18+3等
	 *    - 单模数10^9+7的哈希空间约1×10^9
	 *    - 对于M=10^6，冲突概率约为P ≈ 1 - e^(-(10^6)^2/(2×10^9)) ≈ 0.39
	 *    - 这意味着在单模数情况下，有39%的概率发生至少一次冲突
	 *    - 这对POJ 1200的正确性构成严重威胁
	 * 
	 * 4. 基数选择的最佳实践：
	 *    - 当前实现使用base=131，这是一个较好的选择
	 *    - base应大于字符集大小，确保单字符哈希不冲突
	 *    - 对于本题nc≤26，base=131是充分的
	 *    - 其他推荐基数：13331、911、1009等更大的质数
	 *    - base和mod应互质，以保证哈希函数的均匀分布
	 * 
	 * 5. 溢出对哈希冲突的影响：
	 *    - Java中的溢出是静默的，不会抛出异常
	 *    - 溢出后，哈希值分布变得不均匀，增加冲突概率
	 *    - 对于长度为n的子串，哈希值计算涉及大数乘法
	 *    - 即使使用long类型，对于n>40的子串，也会发生溢出
	 * 
	 * 6. 安全哈希空间计算：
	 *    - 根据生日悖论，安全子串数量k满足：k²/(2M) < ln(1/(1-p))
	 *    - 其中M是哈希空间大小，p是可接受的冲突概率
	 *    - 对于p=10^-8，单模数M=10^9，安全子串数k<4.5×10^4
	 *    - 对于p=10^-8，双模数M=(10^9)^2，安全子串数k<4.5×10^9
	 *    - 结论：对于大规模数据，双哈希是必要的
	 */
	
	/*
	 * ============================================================================
	 * 双哈希实现示例
	 * ============================================================================
	 * 双哈希通过同时使用两个独立的哈希函数来大幅降低冲突概率。在POJ 1200问题中，
	 * 可以使用两个不同的模数和基数组合实现双哈希。
	 * 
	 * 1. 双哈希常量定义：
	 */
	/*
	// 双哈希实现的常量定义
public static final int BASE1 = 131;      // 第一个哈希基数
public static final int BASE2 = 13331;    // 第二个哈希基数
public static final long MOD1 = 1000000007; // 第一个模数
public static final long MOD2 = 1000000009; // 第二个模数

// 用于存储双哈希值的内部类
static class HashPair {
	long hash1; // 第一个哈希函数的值
	long hash2; // 第二个哈希函数的值
	
	// 构造函数
	public HashPair(long hash1, long hash2) {
		this.hash1 = hash1;
		this.hash2 = hash2;
	}
	
	// 重写equals方法，只有当两个哈希值都相等时才认为相等
	@Override
	public boolean equals(Object obj) {
		if (this == obj) return true;
		if (obj == null || getClass() != obj.getClass()) return false;
		HashPair other = (HashPair) obj;
		return hash1 == other.hash1 && hash2 == other.hash2;
	}
	
	// 重写hashCode方法，组合两个哈希值
	@Override
	public int hashCode() {
		return (int)(hash1 ^ (hash1 >>> 32)) + (int)(hash2 ^ (hash2 >>> 32)) * 31;
	}
}
	 */
	
	/*
	 * 2. 完整的双哈希实现方法：
	 */
	/*
	public static int countUniqueSubstringsWithDoubleHash(char[] s, int len, int n, int nc) {
		// 使用HashSet存储双哈希值，只有当两个哈希值都相同时才视为相同子串
		HashSet<HashPair> hashPairSet = new HashSet<>();
		
		// 边界条件检查
		if (n > len || n <= 0) {
			return 0;
		}
		
		// 字符映射，与单哈希实现相同
		int[] charMap = new int[256];
		int charCount = 0;
		for (int i = 0; i < len; i++) {
			if (charMap[s[i]] == 0) {
				charMap[s[i]] = ++charCount;
				if (charCount > nc) {
					return 0;
				}
			}
		}
		
		// 预计算两个哈希函数的base^(n-1) mod mod值
		long pow1 = 1; // base1^(n-1) % mod1
		long pow2 = 1; // base2^(n-1) % mod2
		for (int i = 0; i < n - 1; i++) {
			pow1 = (pow1 * BASE1) % MOD1;
			pow2 = (pow2 * BASE2) % MOD2;
		}
		
		// 计算第一个子串的双哈希值
		long hash1 = 0; // 第一个哈希函数值
		long hash2 = 0; // 第二个哈希函数值
		for (int i = 0; i < n; i++) {
			// 计算第一个哈希函数值
			hash1 = (hash1 * BASE1 + charMap[s[i]]) % MOD1;
			// 计算第二个哈希函数值
			hash2 = (hash2 * BASE2 + charMap[s[i]]) % MOD2;
		}
		
		// 添加第一个哈希对到集合
		hashPairSet.add(new HashPair(hash1, hash2));
		
		// 使用滚动哈希计算剩余子串的哈希值
		for (int i = n; i < len; i++) {
			// 更新第一个哈希函数值
			// 步骤：移除最左边字符的贡献 → 所有字符左移 → 添加新字符
			hash1 = ((hash1 - (long)charMap[s[i-n]] * pow1 % MOD1 + MOD1) % MOD1 * BASE1 % MOD1 + charMap[s[i]]) % MOD1;
			
			// 更新第二个哈希函数值
			hash2 = ((hash2 - (long)charMap[s[i-n]] * pow2 % MOD2 + MOD2) % MOD2 * BASE2 % MOD2 + charMap[s[i]]) % MOD2;
			
			// 添加新的哈希对到集合
			hashPairSet.add(new HashPair(hash1, hash2));
		}
		
		// 哈希对集合的大小即为不同子串的数量
		// 双哈希显著降低了哈希冲突的概率
		return hashPairSet.size();
	}
	 */
	
	/*
	 * 3. 双哈希的核心优势：
	 *    - 冲突概率从单哈希的≈0.39降至≈(0.39)^2≈0.15
	 *    - 对于模数1e9+7和1e9+9，理论冲突概率极低
	 *    - 解决了哈希值溢出问题，提高计算的准确性
	 *    - 符合数学上的哈希函数独立性假设
	 */
	
	/*
	 * ============================================================================
	 * 推荐测试用例
	 * ============================================================================
	 * 以下是针对POJ 1200问题的全面测试用例，覆盖各种边界情况和关键场景。
	 * 
	 * 1. 基本功能测试：
	 *    - 测试用例1：简单字符串
	 *      输入：
	 *      3 4
	 *      abacab
	 *      预期输出：4
	 *      解释：长度为3的子串有：aba, bac, aca, cab，共4个不同子串
	 *      
	 *    - 测试用例2：全相同字符
	 *      输入：
	 *      2 1
	 *      aaaaa
	 *      预期输出：1
	 *      解释：所有长度为2的子串都是"aa"，只有1个不同子串
	 * 
	 * 2. 边界情况测试：
	 *    - 测试用例3：子串长度等于字符串长度
	 *      输入：
	 *      5 3
	 *      abcde
	 *      预期输出：1
	 *      解释：只有一个子串，即整个字符串
	 *      
	 *    - 测试用例4：子串长度大于字符串长度
	 *      输入：
	 *      5 3
	 *      abc
	 *      预期输出：0
	 *      解释：无法形成长度为5的子串
	 *      
	 *    - 测试用例5：空字符串处理
	 *      输入：
	 *      1 1
	 *      
	 *      预期输出：0
	 *      解释：空字符串没有子串
	 * 
	 * 3. 哈希冲突测试：
	 *    - 测试用例6：易发生哈希冲突的字符串
	 *      输入：
	 *      2 2
	 *      ababab...
	 *      目的：测试在重复模式下哈希函数的稳定性
	 *      
	 *    - 测试用例7：最大字符集测试
	 *      输入：
	 *      3 26
	 *      abcdefghijklmnopqrstuvwxyzabc...
	 *      目的：测试算法在最大字符集下的性能
	 * 
	 * 4. 性能测试：
	 *    - 测试用例8：大规模数据测试
	 *      输入：
	 *      10 26
	 *      [生成100,000个随机小写字母]
	 *      预期：算法能在合理时间内处理
	 *      注意：此测试用例需要生成大文件输入
	 *      
	 *    - 测试用例9：极限情况测试
	 *      输入：
	 *      1 26
	 *      [生成10^6个随机小写字母]
	 *      预期输出：26（如果所有字母都出现）
	 * 
	 * 5. 特殊字符集测试：
	 *    - 测试用例10：字符集未用完
	 *      输入：
	 *      2 5
	 *      abc
	 *      预期输出：2
	 *      解释：子串为ab和bc，虽然nc=5但只使用了3个字符
	 *      
	 *    - 测试用例11：字符集超过限制
	 *      输入：
	 *      2 2
	 *      abc
	 *      预期输出：0
	 *      解释：不同字符数量超过nc=2，直接返回0
	 */
	
	/*
	 * ============================================================================
	 * 字符串哈希算法比较分析
	 * ============================================================================
	 * 以下是不同字符串哈希方法和相关算法的详细对比分析。
	 * 
	 * | 算法类型 | 时间复杂度 | 空间复杂度 | 实现复杂度 | 冲突概率 | 适用场景 |
	 * |---------|----------|-----------|-----------|---------|--------|
	 * | 多项式滚动哈希(无模数) | O(M) | O(M) | 低 | 高 | 简单问题，数据量小 |
	 * | 多项式滚动哈希(单模数) | O(M) | O(M) | 中 | 中 | 中等规模数据，一般精度要求 |
	 * | 双哈希 | O(M) | O(M) | 中 | 极低 | 大规模数据，高精度要求 |
	 * | Trie树 | O(M*N) | O(M*N*C) | 低 | 无 | 统计所有长度子串，需要字典序排序 |
	 * | 后缀数组+RMQ | O(M log M) | O(M) | 高 | 无 | 多模式查询，重复处理同一文本 |
	 * | 暴力方法 | O(M*N) | O(M*N) | 极低 | 无 | 概念验证，数据规模极小 |
	 * | Bloom Filter | O(M) | O(k*log M) | 中 | 可调节 | 超大规模数据，允许小概率错误 |
	 * 
	 * 1. 多项式滚动哈希的优缺点：
	 *    - 优点：实现简单，计算高效，内存占用小
	 *    - 缺点：需要处理溢出问题，存在哈希冲突
	 *    - 优化方向：使用双哈希、添加模数、选择合适的基数
	 *    - 适用场景：大多数字符串子串统计问题
	 * 
	 * 2. 与Trie树方法的比较：
	 *    - 时间复杂度：滚动哈希O(M) vs Trie O(M*N)，当N较小时两者相近
	 *    - 空间复杂度：滚动哈希O(M) vs Trie O(M*N*C)，滚动哈希更优
	 *    - 功能差异：Trie支持前缀查询和字典序遍历，滚动哈希不支持
	 *    - 冲突问题：滚动哈希可能冲突，Trie不会冲突
	 * 
	 * 3. 与后缀数组方法的比较：
	 *    - 时间复杂度：后缀数组预处理O(M log M)，查询更高效
	 *    - 空间复杂度：两者相近
	 *    - 功能扩展性：后缀数组支持更多高级查询
	 *    - 实现复杂度：后缀数组实现复杂，滚动哈希更简单
	 *    - 适用场景：单次查询用滚动哈希，多次复杂查询用后缀数组
	 * 
	 * 4. 与Bloom Filter的比较：
	 *    - 误判类型：Bloom Filter可能产生误判（假阳性），但无漏判
	 *    - 空间效率：Bloom Filter通常更节省空间
	 *    - 实现复杂度：Bloom Filter稍复杂
	 *    - 适用场景：超大规模数据，允许小概率误判
	 * 
	 * 5. POJ 1200问题的最佳算法选择：
	 *    - 首选方案：双哈希（多项式滚动哈希+两个不同的模数）
	 *    - 理由：
	 *      a. 时间复杂度O(M)，能够处理大规模输入
	 *      b. 空间复杂度O(M)，内存占用适中
	 *      c. 实现相对简单，代码量小
	 *      d. 哈希冲突概率极低，可以保证正确性
	 *      e. 无需额外的数据结构和预处理
	 *    - 次选方案：Trie树（当n很小时）
	 *    - 不推荐：暴力方法、单哈希无模数
	 * 
	 * 6. 工业级应用的最佳实践：
	 *    - 对于需要100%正确的场景：使用双哈希+必要时的字符串比较
	 *    - 对于大规模数据：考虑使用Bloom Filter或位图优化
	 *    - 对于实时性要求高的场景：预处理所有可能的哈希值
	 *    - 对于内存受限场景：使用压缩哈希或稀疏表示
	 */
}
        
        // 将字符串内容复制到字符数组中以便高效访问
        // 字符数组的随机访问性能优于字符串，因为字符串的charAt()方法需要额外的边界检查
        s.getChars(0, len, str, 0);
        
        // 计算并输出不同子串的数量
        out.println(countUniqueSubstrings(str, len, n, nc));
        
        // 刷新输出并关闭资源，确保所有输出被写入
        // 关闭资源是良好的编程实践，避免资源泄露
        out.flush();
        out.close();
        in.close();
    }
    
    /**
     * 计算字符串中长度为n的不同子串的数量
     * 使用滚动哈希和哈希集合实现高效去重统计
     * 
     * 算法核心步骤：
     * 1. 字符映射：将每个不同字符映射到唯一数字ID
     * 2. 预计算base的n-1次方，用于滚动哈希
     * 3. 计算第一个子串的哈希值
     * 4. 滚动计算剩余子串的哈希值
     * 5. 使用HashSet自动去重，最终集合大小即为结果
     * 
     * 滚动哈希原理与数学证明：
     * - 初始哈希值：hash = s[0]*base^(n-1) + s[1]*base^(n-2) + ... + s[n-1]
     * - 滚动公式：hash = (hash - s[i-n]*base^(n-1))*base + s[i]
     * 
     * 数学证明：
     * 对于子串s[i...i+n-1]，其哈希值为：
     * hash = s[i]*base^(n-1) + s[i+1]*base^(n-2) + ... + s[i+n-1]
     * 
     * 对于下一个子串s[i+1...i+n]，其哈希值为：
     * next_hash = s[i+1]*base^(n-1) + s[i+2]*base^(n-2) + ... + s[i+n]
     * 
     * 我们可以通过以下变换得到next_hash：
     * (hash - s[i]*base^(n-1)) = s[i+1]*base^(n-2) + ... + s[i+n-1]
     * (hash - s[i]*base^(n-1))*base = s[i+1]*base^(n-1) + ... + s[i+n-1]*base
     * (hash - s[i]*base^(n-1))*base + s[i+n] = next_hash
     * 
     * 这证明了滚动哈希公式的正确性，使得每个新子串的哈希值可以在O(1)时间内计算。
     * 
     * 字符映射策略分析：
     * - 从1开始映射而不是从0开始，避免了前导零问题
     * - 例如："a"和"0a"（假设0映射到0）可能产生相同的哈希值
     * - 连续的数字ID分配最大化了不同字符间的数值差异，减少哈希冲突
     * 
     * 哈希冲突处理：
     * - 当前实现使用单一哈希函数，可能存在哈希冲突
     * - 优化版本可以使用双哈希（同时维护两个不同的哈希值）
     * - 对于严格的应用场景，可以在哈希值相同时进行字符串比较
     * 
     * @param s 字符串数组
     * @param len 字符串长度
     * @param n 子串长度
     * @param nc 字符种类数
     * @return 不同子串的数量
     * 
     * 时间复杂度：O(M) - 其中M是字符串长度
     *   - 字符映射：O(M)
     *   - 初始化第一个子串：O(N)
     *   - 滚动计算其他子串：O(M-N)
     *   - 总体：O(M)
     * 
     * 空间复杂度：O(M) - 哈希集合的大小最多为M-N+1
     * 
     * 优化建议：
     * 1. 添加模数运算防止哈希值溢出：使用大质数如10^9+7作为模数
     * 2. 实现双哈希策略进一步减少哈希冲突
     * 3. 对于极端大数据，考虑使用更高效的数据结构如Bloom Filter
     */
    public static int countUniqueSubstrings(char[] s, int len, int n, int nc) {
        // 清空哈希集合，准备新一轮统计
        // 注意：在多次调用此方法时，必须清空集合避免结果错误
        hashSet.clear();
        
        // 边界条件检查：如果子串长度大于字符串长度，无法形成任何子串
        if (n > len || n <= 0) {
            return 0;
        }
        
        // 创建字符到数字的映射表，将每个不同的字符映射到一个唯一的数字ID
        // 使用256大小的数组覆盖所有可能的ASCII字符
        // 选择数组作为映射表，因为字符的ASCII值在0-255范围内，可直接作为索引
        int[] charMap = new int[256]; // 假设ASCII字符范围
        int charCount = 0;
        
        // 遍历字符串，为每个不同的字符分配一个唯一的数字ID（从1开始）
        // 这样做可以确保不同字符对应不同的数值，减少哈希冲突
        // 从1开始而不是0，可以避免前导零问题
        for (int i = 0; i < len; i++) {
            if (charMap[s[i]] == 0) { // 如果字符尚未映射
                charMap[s[i]] = ++charCount; // 分配新的数字ID
                // 检查是否超过题目限制的字符种类数
                // 根据题目描述，不同字符数不能超过nc
                if (charCount > nc) {
                    return 0; // 不符合题目条件，直接返回0
                }
            }
        }
        
        // 计算base的n-1次方，用于滚动哈希中移除最高位
        // 这个值在滚动哈希公式中反复使用，预先计算可以避免重复计算
        // 时间复杂度：O(n)，但n通常远小于字符串长度m
        long pow = 1;
        for (int i = 0; i < n - 1; i++) {
            pow *= base; // pow = base^(n-1)
            
            // 注意：对于大n值，pow可能会溢出long的范围
            // 在实际应用中，可以添加模数运算：pow = (pow * base) % MOD;
        }
        
        // 计算第一个长度为n的子串的哈希值
        // 使用滚动计算方法，避免显式计算指数
        long hash = 0;
        for (int i = 0; i < n; i++) {
            // 哈希计算公式：hash = s[0]*base^(n-1) + s[1]*base^(n-2) + ... + s[n-1]
            // 等同于：hash = (((s[0]*base + s[1])*base + s[2])*base + ... ) + s[n-1]
            // 这种滚动计算方式更高效，避免了计算大数幂的开销
            hash = hash * base + charMap[s[i]];
            
            // 优化建议：添加模数运算防止溢出
            // hash = (hash * base + charMap[s[i]]) % MOD;
        }
        
        // 将第一个子串的哈希值添加到集合中
        hashSet.add(hash);
        
        // 使用滚动哈希技术高效计算后续所有长度为n的子串的哈希值
        // 时间复杂度为O(1) per substring
        for (int i = n; i < len; i++) {
            // 滚动哈希公式: 新哈希 = (旧哈希 - 最高位字符值 * base^(n-1)) * base + 新字符值
            // 1. 移除当前窗口最左边字符的贡献：hash - s[i-n] * base^(n-1)
            // 2. 所有剩余字符左移一位：乘以base
            // 3. 添加新进入窗口的字符：+ s[i]
            
            // 注意：这里需要强制类型转换为long，防止整数溢出
            // 特别是当charMap[s[i-n]]和pow都是int类型时，它们的乘积可能会溢出
            hash = (hash - (long) charMap[s[i - n]] * pow) * base + charMap[s[i]];
            
            // 优化建议：添加模数运算，并处理可能的负数
            // hash = ((hash - (long) charMap[s[i - n]] * pow % MOD + MOD) % MOD * base % MOD + charMap[s[i]]) % MOD;
            
            // 将计算得到的哈希值添加到集合中（自动去重）
            // HashSet的add操作会自动判断是否已存在相同的哈希值
            // 如果存在，add()方法返回false，但不会改变集合内容
            hashSet.add(hash);
        }
        
        // 哈希集合的大小即为不同子串的数量
        // 因为每个唯一的哈希值对应至少一个唯一的子串
        // 注意：在存在哈希冲突的情况下，这个结果可能小于实际的不同子串数量
        return hashSet.size();
    }
    
    /**
     * 优化版本：使用双哈希策略减少哈希冲突
     * 双哈希的基本思想是同时使用两个不同的哈希函数，只有当两个哈希值都相同时才认为子串相同
     * 
     * @param s 字符串数组
     * @param len 字符串长度
     * @param n 子串长度
     * @param nc 字符种类数
     * @return 不同子串的数量
     * 
     * 注意：此方法仅作为优化示例，当前未被调用
     */
    public static int countUniqueSubstringsWithDoubleHash(char[] s, int len, int n, int nc) {
        // 使用HashSet存储Pair对象，每个Pair包含两个不同的哈希值
        // 在实际实现中，需要创建一个Pair类并重写equals和hashCode方法
        return 0; // 示例方法，未完整实现
    }
}