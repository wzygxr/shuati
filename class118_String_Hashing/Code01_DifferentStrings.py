#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
统计有多少个不同的字符串

题目来源：洛谷 P3370
题目链接：https://www.luogu.com.cn/problem/P3370

题目描述：
给定N个由大小写字母和数字组成的字符串，请计算其中不同的字符串的个数。

本题的核心思想是使用字符串哈希技术，将每个字符串映射为一个整数，
然后使用Python的集合（set）数据结构自动去重并统计数量。

哈希算法的数学原理：
多项式哈希函数的数学定义：hash(s) = (s₀×bⁿ⁻¹ + s₁×bⁿ⁻² + ... + sₙ₋₁×b⁰) mod m
其中：
- s₀,s₁,...,sₙ₋₁是字符串中各字符的数值映射
- b是哈希基数（base），通常选择较大的质数
- m是模数，用于防止数值溢出

哈希冲突处理方法：
1. 双哈希法：同时使用两个不同的哈希函数，只有当两个哈希值都相同时才认为字符串相同
2. 模数选择：使用大质数作为模数，如10^9+7或10^9+9
3. 基数选择：使用较大的质数作为基数，如911、131或13331
4. 链式地址法：在哈希表实现中，当发生冲突时，使用链表存储多个元素

相似题目：
1. LeetCode 217. 存在重复元素 (https://leetcode.cn/problems/contains-duplicate/)
2. LintCode 387. 最小差 (https://www.lintcode.com/problem/387/)
3. CodeChef STRMRG (https://www.codechef.com/problems/STRMRG)
4. SPOJ DICT (https://www.spoj.com/problems/DICT/)
5. 牛客 NC152 字符串去重 (https://www.nowcoder.com/practice/2d3f6ddd82da445d804c95db22dcc471)
6. HackerRank Hash Tables: Ransom Note (https://www.hackerrank.com/challenges/ctci-ransom-note)
7. 杭电 HDU 1004 Let the Balloon Rise (http://acm.hdu.edu.cn/showproblem.php?pid=1004)

三种语言实现参考：
- Java版本：Code01_DifferentStrings.java
- Python版本：本文件
- C++版本：类似实现可参考Code10_CrazySearch.cpp
"""

# 哈希基数
# 选择499（质数）作为基数，减少哈希冲突
# 
# 数学原理：选择质数作为基数的原因是，质数的因数少，可以降低哈希冲突的概率
# 常见的基数选择比较：
# - 131: 较小质数，计算速度快，但冲突概率相对较高
# - 499: 中等大小质数，平衡性好，适用于大多数场景
# - 911: 较大质数，冲突概率低，但计算开销略大
# - 13331: 更大的质数，适用于大规模数据
# 
# Python中的优势：Python的整数类型没有大小限制，不会发生整数溢出
# 因此在Python中可以使用较大的基数而不需要担心溢出问题
base = 499


def string_hash(s):
    """
    计算字符串的哈希值
    
    使用多项式哈希函数：hash(s) = s[0] * base^(n-1) + s[1] * base^(n-2) + ... + s[n-1]
    这种方法可以将字符串唯一地映射到一个数值（理论上存在哈希冲突但概率极低）
    
    数学原理解析：
    1. 多项式哈希将字符串视为base进制的数字，每个字符对应一个数字位
    2. 使用滚动计算方式：ans = ans * base + val
       - 这等价于将当前哈希值左移（乘以base），然后加上新字符的值
       - 滚动计算避免了计算大数幂的开销
    3. 例如，对于字符串"abc"，计算过程为：
       - 初始 ans = 0
       - 处理 'a': ans = 0 * base + val('a') = val('a')
       - 处理 'b': ans = val('a') * base + val('b')
       - 处理 'c': ans = (val('a') * base + val('b')) * base + val('c') = val('a') * base² + val('b') * base + val('c')
    
    字符映射策略：
    - 所有字符映射为非零正整数，避免前导零问题
    - 不同类型字符映射到不同的数值范围，减少哈希冲突
    
    Python特定优化：
    - Python的整数类型支持任意精度，不会发生整数溢出
    - 因此不需要像其他语言那样使用模数运算
    
    :param s: 输入字符串
    :return: 计算得到的哈希值
    :time complexity: O(n)，其中n是字符串长度
    :space complexity: O(1)
    """
    ans = 0
    for c in s:
        # 将字符映射为数字
        # 数字字符映射为1-10，避免0值以防止哈希冲突
        if '0' <= c <= '9':
            val = ord(c) - ord('0') + 1  # 数字映射：0->1, 1->2, ..., 9->10
        # 大写字母映射为11-36
        elif 'A' <= c <= 'Z':
            val = ord(c) - ord('A') + 11  # 大写字母映射：A->11, B->12, ..., Z->36
        # 小写字母映射为37-62
        else:
            val = ord(c) - ord('a') + 37  # 小写字母映射：a->37, b->38, ..., z->62
        
        # 累加计算哈希值
        # 使用滚动哈希算法，避免显式计算base的幂
        ans = ans * base + val
    return ans


def main():
    """
    主函数
    
    读取输入，计算每个字符串的哈希值，使用集合去重并统计数量
    
    算法步骤：
    1. 读取字符串数量n
    2. 创建一个空集合用于存储不同的哈希值
    3. 对每个输入字符串，计算其哈希值并添加到集合中
    4. 输出集合的大小，即为不同字符串的数量
    
    哈希表工作原理（Python set的内部实现）：
    - Python的set内部使用哈希表实现，通过哈希函数将元素映射到不同的桶中
    - 当添加元素时，首先计算元素的哈希值，然后查找对应的桶
    - 如果桶中已有元素，会进行相等性比较，只有当元素不同时才添加
    - 这保证了集合中的元素是唯一的
    
    数学原理解析：
    - 哈希函数将字符串空间映射到整数空间
    - 集合通过哈希表实现了快速的查找和去重操作
    - 最终集合的大小即为不同字符串的数量
    
    性能分析：
    - 时间复杂度：O(N*M)，其中N是字符串数量，M是字符串的平均长度
      - 计算每个字符串的哈希值需要O(M)时间
      - set的添加操作平均时间复杂度为O(1)
    - 空间复杂度：O(K)，其中K是不同字符串的数量
      - 最坏情况下，所有字符串都不同，空间复杂度为O(N)
    
    Python优化技巧：
    - 使用strip()去除输入字符串两端的空白字符，提高鲁棒性
    - 使用下划线'_'作为循环变量，表示我们不需要使用循环索引
    - 利用Python集合的特性自动处理去重操作
    """
    # 读取字符串数量
    n = int(input())
    
    # 使用Python的set数据结构自动去重
    # set内部使用哈希表实现，添加和查询操作的平均时间复杂度为O(1)
    # 相比Java或C++，Python的set提供了更简洁的去重方式
    hashes = set()
    
    # 处理每个输入字符串
    for _ in range(n):
        s = input().strip()  # 去除字符串两端的空白字符
        
        # 计算字符串的哈希值并添加到集合中
        # 由于集合的特性，重复的哈希值只会被存储一次
        # 注意：这里假设没有哈希冲突，相同哈希值的字符串一定相同
        hashes.add(string_hash(s))
    
    # 集合的大小即为不同字符串的数量
    # 输出结果
    print(len(hashes))


# 优化版本：使用双哈希法减少哈希冲突
# 双哈希法的基本思想是使用两个不同的哈希函数，只有当两个哈希值都相同时才认为字符串相同
def double_hash_string(s):
    """
    计算字符串的双哈希值
    
    使用两个不同的哈希函数，减少哈希冲突的概率
    
    :param s: 输入字符串
    :return: 包含两个哈希值的元组
    """
    # 使用两个不同的基数
    base1 = 499
    base2 = 911
    
    # 使用两个不同的模数
    mod1 = 10**9 + 7
    mod2 = 10**9 + 9
    
    hash1, hash2 = 0, 0
    for c in s:
        # 与单个哈希函数相同的字符映射逻辑
        if '0' <= c <= '9':
            val = ord(c) - ord('0') + 1
        elif 'A' <= c <= 'Z':
            val = ord(c) - ord('A') + 11
        else:
            val = ord(c) - ord('a') + 37
        
        # 分别计算两个哈希值
        hash1 = (hash1 * base1 + val) % mod1
        hash2 = (hash2 * base2 + val) % mod2
    
    # 返回两个哈希值的元组
    return (hash1, hash2)


# 测试用例建议
# 1. 基本测试：包含不同字符串的测试集
# 2. 边界测试：
#    - 空字符串
#    - 最大长度字符串
#    - 只有一个字符串的情况
#    - 所有字符串都相同的情况
#    - 所有字符串都不同的情况
# 3. 哈希冲突测试：构造可能产生相同哈希值的字符串
# 4. 特殊字符测试：测试各种数字、大写字母和小写字母的组合


# 程序入口
if __name__ == "__main__":
    main()