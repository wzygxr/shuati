package class105;

/**
 * 洛谷 P3370 统计不同字符串个数问题的实现
 * <p>
 * 题目链接：https://www.luogu.com.cn/problem/P3370
 * <p>
 * 题目描述：给定N个由大小写字母和数字组成的字符串，请计算其中不同的字符串的个数。
 * <p>
 * 解题思路：
 * 1. 使用多项式哈希算法将每个字符串映射为一个唯一的整数哈希值
 * 2. 采用两种方法统计不同哈希值的数量：
 *    a. 排序去重法：对哈希值排序后比较相邻元素
 *    b. 哈希集合法：使用HashSet自动去重
 * 3. 字符映射策略：将字符映射为非零整数，避免哈希冲突
 *    - 数字字符(0-9)映射为1-10
 *    - 大写字母(A-Z)映射为11-36
 *    - 小写字母(a-z)映射为37-62
 * <p>
 * 时间复杂度分析：
 * - 排序去重法：O(N*L + N log N)，其中N是字符串数量，L是字符串平均长度
 *   - 计算所有哈希值需要O(N*L)时间
 *   - 排序需要O(N log N)时间
 * - 哈希集合法：O(N*L)，假设哈希表操作是O(1)的
 * <p>
 * 空间复杂度分析：O(N + L)，存储哈希值数组和单个字符串处理所需空间
 * <p>
 * 相似题目：
 * 1. LeetCode 217: Contains Duplicate - 判断数组中是否有重复元素
 * 2. LeetCode 128: Longest Consecutive Sequence - 最长连续序列
 * 3. CodeChef STRMRG - 字符串合并问题
 * 4. SPOJ DICT - 字典查询问题
 * 5. 牛客 NC152 - 字符串去重
 * 6. POJ 3349: Snowflake Snow Snowflakes - 雪花唯一标识问题
 * 7. HDU 1267: 下沙的沙子有几粒？- 字符串组合计数
 * <p>
 * 测试链接：https://www.luogu.com.cn/problem/P3370
 * <p>
 * 提交说明：提交时请将类名修改为"Main"以通过在线评测
 * <p>
 * 哈希算法的数学原理：
 * 多项式哈希函数的数学定义：hash(s) = (s₀×bⁿ⁻¹ + s₁×bⁿ⁻² + ... + sₙ₋₁×b⁰) mod m
 * 其中：
 * - s₀,s₁,...,sₙ₋₁是字符串中各字符的数值映射
 * - b是哈希基数（base），通常选择较大的质数
 * - m是模数，用于防止数值溢出
 * <p>
 * 哈希冲突处理：
 * 1. 双哈希法：同时使用两个不同的哈希函数，只有当两个哈希值都相同时才认为字符串相同
 * 2. 模数选择：使用大质数作为模数，如10^9+7或10^9+9
 * 3. 基数选择：使用较大的质数作为基数，如911、131或13331
 * 4. 链式地址法：在实际哈希表实现中，当发生冲突时，可以使用链表存储多个元素
 */

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;
import java.io.PrintWriter;
import java.util.Arrays;
import java.util.HashSet;

/**
 * 字符串去重计数类
 * <p>
 * 实现了两种字符串去重方法：排序去重和哈希集合去重
 * 使用多项式哈希函数将字符串转换为数值表示，便于比较和存储
 */
public class Code01_DifferentStrings {

	/**
	 * 最大字符串数量上限
	 * 题目中可能的最大输入数量
	 * 根据洛谷P3370题目约束，字符串数量可能达到10000个
	 * 这里设置为10001以确保有足够的空间
	 * 
	 * 数组大小选择的数学依据：
	 * - 选择稍大于最大可能输入数量的值
	 * - 预留1个额外空间可以防止数组越界
	 * - 对于动态分配的场景，可以考虑使用ArrayList等动态数据结构
	 */
	public static int MAXN = 10001;

	/**
	 * 哈希基数
	 * 选择499（质数）作为基数，这是一个较大的质数，可以有效减少哈希冲突
	 * 
	 * 数学原理：选择质数作为基数的原因是，质数的因数少，可以降低哈希冲突的概率
	 * 常见的基数选择比较：
	 * - 131: 较小质数，计算速度快，但冲突概率相对较高
	 * - 499: 中等大小质数，平衡性好，适用于大多数场景
	 * - 911: 较大质数，冲突概率低，但计算开销略大
	 * - 13331: 更大的质数，适用于大规模数据，但可能导致整数溢出
	 * 
	 * 数学证明：
	 * 设基数为b，两个不同字符串s和t，若s≠t，则P(s,b)≠P(t,b)的概率随b增大而提高
	 * 其中P(s,b)表示字符串s的多项式哈希值
	 * 
	 * 注意：在实际应用中，为防止溢出，可以使用模数或BigInteger
	 */
	public static int base = 499;

	/**
	 * 存储每个字符串的哈希值数组
	 */
	public static long[] nums = new long[MAXN];

	/**
	 * 输入的字符串数量
	 */
	public static int n;

	/**
	 * 主函数
	 * 处理输入输出，调用核心算法
	 * @param args 命令行参数
	 * @throws IOException 输入输出异常
	 * 
	 * 优化说明：
	 * - 使用BufferedReader和PrintWriter而不是Scanner和System.out.println
	 * - 可以显著提高输入输出效率，特别是对于大数据量
	 * - 典型提升：对于10000条数据，可能从秒级优化到毫秒级
	 */
	public static void main(String[] args) throws IOException {
		// 使用BufferedReader和PrintWriter提高输入输出效率
		BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
		PrintWriter out = new PrintWriter(new OutputStreamWriter(System.out));
		
		// 读取字符串数量
		n = Integer.valueOf(in.readLine());
		
		// 计算每个字符串的哈希值并存储
		for (int i = 0; i < n; i++) {
			nums[i] = value(in.readLine().toCharArray());
		}
		
		// 计算不同字符串的数量并输出
		out.println(cnt());
		
		// 刷新输出缓冲区并关闭资源
		out.flush();
		out.close();
		in.close();
	}

	/**
	 * 计算字符串的哈希值
	 * <p>
	 * 实现多项式哈希函数：hash(s) = s[0] * base^(n-1) + s[1] * base^(n-2) + ... + s[n-1]
	 * 等价于：hash(s) = (((s[0] * base + s[1]) * base + s[2]) * base + ... + s[n-1])
	 * <p>
	 * 数学原理解析：
	 * 1. 多项式哈希将字符串视为base进制的数字，每个字符对应一个数字位
	 * 2. 使用滚动计算方式：ans = ans * base + v(s[i])
	 *    - 这等价于将当前哈希值左移（乘以base），然后加上新字符的值
	 *    - 滚动计算避免了计算大数幂的开销
	 * 3. 例如，对于字符串"abc"，计算过程为：
	 *    - 初始 ans = v('a')
	 *    - 处理 'b': ans = v('a') * base + v('b')
	 *    - 处理 'c': ans = (v('a') * base + v('b')) * base + v('c') = v('a') * base² + v('b') * base + v('c')
	 * <p>
	 * 算法正确性证明：
	 * 对于长度为n的字符串s = s[0]s[1]...s[n-1]，滚动哈希计算过程可以表示为：
	 * hash(0) = v(s[0])
	 * hash(i) = hash(i-1) * base + v(s[i])
	 * 通过数学归纳法可以证明：hash(n-1) = Σ_{i=0}^{n-1} v(s[i]) * base^{n-1-i}
	 * <p>
	 * 边界条件处理：
	 * - 对于空字符串：本实现未处理空字符串情况，实际应用中应添加检查
	 * - 对于超长字符串：可能导致long类型溢出，应使用模数运算
	 * <p>
	 * 时间复杂度：O(L)，L为字符串长度
	 * 空间复杂度：O(1)，只使用常数额外空间
	 * 
	 * @param s 输入字符数组
	 * @return 计算得到的哈希值
	 */
	public static long value(char[] s) {
	// 初始化哈希值为第一个字符的映射值
	// 注意：如果字符串为空，这里会抛出ArrayIndexOutOfBoundsException
	// 在实际应用中，应添加空字符串检查
	long ans = v(s[0]);
	
	// 遍历剩余字符，使用滚动哈希算法计算哈希值
	// 每次将当前哈希值乘以base再加上下一个字符的映射值
	// 这种滚动计算方式避免了显式计算base的幂，提高了效率
	for (int i = 1; i < s.length; i++) {
		ans = ans * base + v(s[i]);
		
		// 优化提示：在处理长字符串时，可以添加模数运算防止溢出
		// 例如：ans = (ans * base + v(s[i])) % MOD;
		// 常用的模数有1000000007(10^9+7)或1000000009(10^9+9)
	}
	return ans;
}

	/**
	 * 将字符映射为整数
	 * <p>
	 * 映射规则设计：
	 * - 数字字符(0-9)映射为1-10，避免映射为0
	 * - 大写字母(A-Z)映射为11-36
	 * - 小写字母(a-z)映射为37-62
	 * <p>
	 * 这样设计的好处是：
	 * 1. 避免任何字符映射到0值，防止哈希计算中的前导零问题
	 *    例如："0a"和"a"如果分别映射为0*base+a和a，可能导致哈希值相同
	 * 2. 确保不同类型字符映射到不同的数值范围，减少哈希冲突
	 * 3. 所有字符映射为正整数，有利于哈希计算的稳定性
	 * <p>
	 * 数学原理解析：
	 * - 映射函数是一个分段线性函数：v(c) = c - offset + startValue
	 * - 选择不同的起始值确保不同字符集之间没有重叠
	 * <p>
	 * 边界条件处理：
	 * - 对于超出题目范围的字符（非字母数字），这里默认视为小写字母处理
	 * - 在严格的应用中，应该添加输入验证
	 * 
	 * @param c 输入字符
	 * @return 映射后的整数值
	 */
	public static int v(char c) {
	if (c >= '0' && c <= '9') {
		// 数字映射：0->1, 1->2, ..., 9->10
		// 添加1是为了避免映射到0值
		return c - '0' + 1;
	} else if (c >= 'A' && c <= 'Z') {
		// 大写字母映射：A->11, B->12, ..., Z->36
		// 从11开始，与数字字符的映射范围不重叠
		return c - 'A' + 11;
	} else {
		// 小写字母映射：a->37, b->38, ..., z->62
		// 从37开始，与前两个范围都不重叠
		return c - 'a' + 37;
	}
}

	/**
	 * 统计不同哈希值的数量（方法一：排序去重）
	 * <p>
	 * 算法步骤：
	 * 1. 对哈希值数组进行排序
	 * 2. 初始化计数器为1（至少有一个不同的字符串）
	 * 3. 遍历排序后的数组，比较相邻元素
	 * 4. 当相邻元素不同时，计数器加1
	 * <p>
	 * 数学原理解析：
	 * - 排序后，相同的哈希值会聚集在一起
	 * - 通过比较相邻元素，可以在一次线性扫描中找出所有不同的值
	 * - 对于n个元素，最多需要n-1次比较
	 * <p>
	 * 边界条件处理：
	 * - 当n=0时，返回0（没有字符串）
	 * - 当n=1时，直接返回1（只有一个字符串，必然不同）
	 * <p>
	 * 时间复杂度分析：
	 * - 排序操作：O(n log n)，这是算法的主要时间开销
	 * - 线性扫描：O(n)，可以忽略不计
	 * - 总体：O(n log n)
	 * <p>
	 * 空间复杂度分析：
	 * - O(1)，原地排序，只使用常数额外空间
	 * - 注意：这里假设nums数组已经分配好了空间
	 * <p>
	 * 优点：不需要额外的数据结构，空间效率高
	 * 缺点：需要修改原数组顺序，时间复杂度较高
	 * <p>
	 * 优化建议：
	 * - 对于大规模数据，可以考虑使用归并排序或堆排序避免快速排序的最坏情况
	 * - 在实际应用中，如果内存允许，可以考虑使用方法二（HashSet）提高效率
	 * 
	 * @return 不同字符串的数量
	 */
	public static int cnt() {
	// 对哈希值数组进行排序，排序范围为[0, n)
	// 使用Java内置的Arrays.sort方法，对于基本类型使用双轴快速排序
	Arrays.sort(nums, 0, n);
	
	// 边界情况：如果没有字符串，返回0
	if (n == 0) {
		return 0;
	}
	
	// 初始化为1（至少有一个不同的字符串）
	int ans = 1;
	
	// 遍历排序后的数组，比较相邻元素是否不同
	// 使用线性扫描算法统计不同元素的个数
	for (int i = 1; i < n; i++) {
		// 当前元素与前一个元素不同时，说明找到了新的不同字符串
		// 这里假设哈希值相同的字符串一定相同（无哈希冲突）
		if (nums[i] != nums[i - 1]) {
			ans++;
		}
	}
	return ans;
}
	
	/**
	 * 统计不同哈希值的数量（方法二：使用HashSet）
	 * <p>
	 * 算法步骤：
	 * 1. 创建一个HashSet用于存储不同的哈希值
	 * 2. 遍历所有字符串，计算每个字符串的哈希值
	 * 3. 将哈希值添加到HashSet中，集合会自动去重
	 * 4. 返回HashSet的大小，即为不同字符串的数量
	 * <p>
	 * 哈希表工作原理：
	 * - HashSet内部使用HashMap实现，通过哈希函数将元素映射到不同的桶中
	 * - 每个桶通常是一个链表或红黑树，用于处理哈希冲突
	 * - 添加元素时，首先计算哈希值，然后查找对应的桶
	 * <p>
	 * 数学原理解析：
	 * - 哈希函数将字符串空间映射到整数空间
	 * - 理想情况下，每个不同的字符串映射到不同的整数
	 * - 集合的大小即为不同字符串的数量
	 * <p>
	 * 实际应用场景：
	 * - 数据去重：在日志处理、数据库导入等场景中去除重复记录
	 * - 缓存系统：跟踪已处理的对象，避免重复计算
	 * - 集合操作：快速判断元素是否存在、计算交集和并集
	 * <p>
	 * 时间复杂度分析：
	 * - 计算每个字符串的哈希值：O(L) per string
	 * - HashSet的添加操作：平均O(1)，最坏O(n)（所有元素哈希冲突）
	 * - 总体：平均O(n*L)，最坏O(n²*L)
	 * <p>
	 * 空间复杂度分析：
	 * - O(k)，其中k是不同字符串的数量
	 * - 最坏情况下，所有字符串都不同，空间复杂度为O(n)
	 * <p>
	 * 优点：
	 * - 实现简单，代码可读性好
	 * - 时间效率高（平均情况下）
	 * - 不需要修改原数据顺序
	 * - 支持动态添加和查询
	 * <p>
	 * 缺点：
	 * - 需要额外的空间来存储HashSet
	 * - 在哈希冲突严重的情况下，性能会下降
	 * - 不保证元素的顺序
	 * <p>
	 * 哈希冲突处理：
	 * - 当两个不同的字符串产生相同的哈希值时，会发生哈希冲突
	 * - 在实际应用中，可以考虑使用双哈希法：
	 *   同时计算两个不同的哈希值，只有当两个值都相同时才认为字符串相同
	 * 
	 * @param strings 输入的字符串数组
	 * @return 不同字符串的数量
	 */
public static int cntUsingHashSet(String[] strings) {
	// 创建HashSet存储不同的哈希值，利用集合的特性自动去重
	HashSet<Long> set = new HashSet<>();
	
	// 遍历每个字符串
	for (String str : strings) {
		// 计算字符串的哈希值并添加到集合中
		// 首先将字符串转换为字符数组，然后计算哈希值
		// 如果哈希值已存在，add()方法会返回false，但不会改变集合内容
		set.add(value(str.toCharArray()));
		
		// 优化建议：在处理大规模数据时，可以添加以下优化：
		// 1. 预先计算字符串长度，避免重复计算
		// 2. 对于非常长的字符串，可以考虑只计算前缀的哈希值，再进行精确比较
	}
	
	// 集合的大小即为不同字符串的数量
	// 这里假设没有哈希冲突，相同哈希值的字符串一定相同
	return set.size();
}

	/**
	 * 哈希冲突概率的数学证明与分析
	 * 
	 * 1. 生日悖论与哈希冲突
	 *    - 给定m个不同的哈希值（哈希空间大小为m）和n个随机元素
	 *    - 发生至少一次冲突的概率约为 1 - e^(-n²/(2m))
	 *    - 当n ≈ √(2m ln(1/(1-p))) 时，冲突概率为p
	 *    - 例如：当m=2^32（32位哈希值），n=77163时，冲突概率约为1%
	 * 
	 * 2. 多项式哈希冲突概率分析
	 *    - 对于两个不同的字符串s和t，其哈希值相等的概率为1/m
	 *    - 当使用模数m时，理论上不同字符串产生相同哈希值的概率为1/m
	 *    - 但在实践中，这个概率会受到字符串分布和哈希函数设计的影响
	 * 
	 * 3. 双哈希法的优势
	 *    - 使用两个独立哈希函数h1和h2
	 *    - 同时冲突的概率为1/(m1*m2)
	 *    - 例如：使用两个32位哈希函数，冲突概率降低到约1/2^64，几乎可以忽略不计
	 * 
	 * 4. 实际应用中的安全界限
	 *    - 对于一般应用：哈希空间大小应至少是元素数量的100倍
	 *    - 对于安全敏感应用：哈希空间大小应至少是元素数量的1000倍以上
	 *    - 在金融等高度敏感领域：应使用强哈希函数和额外的碰撞检测机制
	 */
	
	/**
	 * 推荐的测试用例实现（可以单独作为一个测试类）
	 * 
	 * 测试代码示例：
	 * ```java
	 * public class DifferentStringsTest {
	 *     
	 *     @Test
	 *     public void testBasicCase() {
	 *         // 基本测试：包含不同字符串的情况
	 *         String[] strings = {"abc", "def", "ghi", "jkl", "mno"};
	 *         assertEquals(5, Code01_DifferentStrings.cntUsingHashSet(strings));
	 *     }
	 *     
	 *     @Test
	 *     public void testDuplicateCase() {
	 *         // 重复字符串测试：包含重复字符串的情况
	 *         String[] strings = {"abc", "abc", "def", "def", "ghi"};
	 *         assertEquals(3, Code01_DifferentStrings.cntUsingHashSet(strings));
	 *     }
	 *     
	 *     @Test
	 *     public void testBoundaryCase() {
	 *         // 边界测试：空数组
	 *         String[] strings = {};
	 *         // 注意：需要修改方法以处理空数组情况
	 *         // assertEquals(0, Code01_DifferentStrings.cntUsingHashSet(strings));
	 *         
	 *         // 边界测试：只有一个字符串
	 *         String[] singleString = {"hello"};
	 *         assertEquals(1, Code01_DifferentStrings.cntUsingHashSet(singleString));
	 *     }
	 *     
	 *     @Test
	 *     public void testHashCollision() {
	 *         // 哈希冲突测试：构造可能产生相同哈希值的字符串
	 *         // 注意：这需要针对具体的哈希函数实现进行测试
	 *         // 例如：对于特定的base值，某些字符串组合可能产生相同的哈希值
	 *     }
	 * }
	 * ```
	 */
	
	/**
	 * 与其他哈希算法的比较
	 * 
	 * 1. 多项式哈希 vs MD5/SHA：
	 *    - 多项式哈希：快速，但冲突概率相对较高
	 *    - MD5/SHA：安全，但计算成本高
	 *    - 适用场景：多项式哈希适合非加密场景，如数据去重、字符串匹配
	 * 
	 * 2. 多项式哈希 vs Rabin-Karp：
	 *    - 两者都是滚动哈希算法
	 *    - Rabin-Karp更专注于字符串匹配问题
	 *    - 多项式哈希更通用，可用于多种场景
	 * 
	 * 3. 多项式哈希 vs xxHash/MurmurHash：
	 *    - xxHash/MurmurHash：更现代，速度更快，分布更均匀
	 *    - 多项式哈希：实现简单，容易理解
	 *    - 在Java中，可以考虑使用Objects.hash()或Apache Commons HashCodeBuilder
	 */
}