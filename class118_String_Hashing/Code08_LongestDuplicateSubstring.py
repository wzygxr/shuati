# LeetCode 1044. 最长重复子串
# 题目链接：https://leetcode.com/problems/longest-duplicate-substring/
# 题目大意：
# 给你一个字符串 s ，考虑其所有 重复子串：即 s 的连续子串，在 s 中出现 2 次或更多次。
# 这些出现之间可能存在重叠。返回任意一个可能具有最长长度的重复子串。
# 如果 s 不含重复子串，那么答案为 ""。
#
# 算法核心思想：
# 1. 二分查找优化：利用二分查找确定最长重复子串的可能长度
# 2. 哈希去重技术：使用多项式滚动哈希快速判断子串是否重复
# 3. 集合存储：利用Python的set数据结构高效存储和查询子串哈希值
# 4. 预计算策略：预先计算哈希值和幂次数组，支持O(1)时间子串哈希值查询
#
# 多项式滚动哈希数学原理：
# - 哈希函数定义：对于字符串s[0...n-1]，哈希值H(s) = s[0]*base^(n-1) + s[1]*base^(n-2) + ... + s[n-1]
# - 前缀哈希：hash_arr[i] = s[0]*base^i + s[1]*base^(i-1) + ... + s[i]
# - 子串哈希：hash(l,r) = hash_arr[r] - hash_arr[l-1]*base^(r-l+1)，当l>0时
# - 这种设计使得我们可以在O(1)时间内计算任意子串的哈希值，而无需重新计算
#
# 算法详细步骤：
# 1. 预处理阶段：
#    - 预计算幂次数组pow_arr[i] = base^i，避免重复计算
#    - 计算字符串的前缀哈希数组，为后续子串哈希计算做准备
# 2. 二分查找阶段：
#    - 二分查找范围：0到n-1（n为字符串长度）
#    - 对于每个中间长度m，调用check方法检查是否存在长度为m的重复子串
#    - 如果存在，记录子串并尝试更长的长度；否则尝试更短的长度
# 3. 子串检查阶段（check方法）：
#    - 使用set存储已见过的子串哈希值
#    - 遍历所有长度为len的子串，计算其哈希值并检查是否已经存在
#    - 如果存在重复，返回子串；否则将哈希值加入集合
# 4. 结果构建：根据找到的最长长度和子串，返回最长重复子串
#
# 算法正确性证明：
# - 二分查找的正确性基于单调性质：如果存在长度为m的重复子串，那么对于所有k < m，也存在长度为k的重复子串
# - 因此，二分查找可以找到最大的m值，使得存在长度为m的重复子串
# - 哈希函数假设：在实际应用中，哈希冲突概率极低，可以近似认为哈希值相同意味着子串相同
#
# 哈希冲突处理策略：
# - 单哈希方案：当前实现使用单个哈希函数，对于大多数测试用例足够安全
# - 双哈希优化：可以使用两个不同的哈希函数（不同的base），只有当两个哈希值都匹配时才认为子串相同
# - 冲突验证：当检测到哈希值相同时，可以进行实际的字符串比较来确认是否真的重复
#
# 时间复杂度分析：
# - 预处理阶段：O(n)，计算前缀哈希和幂次数组
# - 二分查找阶段：O(log n)次迭代，每次迭代处理一个中间长度
# - 每次check操作：O(n)，遍历所有长度为len的子串，每次哈希计算为O(1)
# - 集合操作：平均O(1)的插入和查询时间
# - 总体时间复杂度：O(n log n)
#
# 空间复杂度分析：
# - 前缀哈希数组：O(n)，存储每个前缀的哈希值
# - 幂次数组：O(n)，存储base的幂次
# - set存储：O(n)，最坏情况下存储所有子串的哈希值
# - 总体空间复杂度：O(n)
#
# 优化点分析：
# 1. 双哈希方案：使用两个不同的哈希函数可以将冲突概率降低到几乎为零
# 2. 字符串比较：对于哈希冲突的情况进行实际字符串比较，确保正确性
# 3. Rabin-Karp优化：可以利用滑动窗口技术优化哈希计算
#
# 相似题目：
# 1. LeetCode 1392: Longest Happy Prefix - 最长前缀后缀匹配
# 2. LeetCode 686: Repeated String Match - 重复叠加字符串匹配
# 3. LintCode 1360: 重复的DNA序列 - 固定长度重复子串查找
# 4. HackerRank: Longest Repeating Substring - 重复子串查找
# 5. CodeChef SUBINC - 递增子序列问题
# 6. UVa 11475: Extend to Palindrome - 字符串扩展问题
# 7. 牛客 NC132: 最长回文子串 - 回文子串查找
#
# 测试链接: https://leetcode.com/problems/longest-duplicate-substring/
#
# 多语言实现计划：
# - Java实现：Code08_LongestDuplicateSubstring.java
# - Python实现：当前文件
# - C++实现：Code08_LongestDuplicateSubstring.cpp（待实现）

# 哈希基数，选择499作为大质数以减少哈希冲突
# 使用质数作为基数可以使哈希分布更均匀
base = 499

def longest_duplicate_substring(s):
    """
    查找最长重复子串的核心方法
    <p>
    该方法采用二分查找结合多项式滚动哈希技术，高效地找到字符串中的最长重复子串。
    二分查找将求解最长重复子串长度的问题转化为一系列判定性问题，每个判定问题通过哈希技术高效解决。
    <p>
    二分查找原理详解：
    - 定义查找范围：左边界left=0，右边界right=n-1
    - 每次取中间值mid=(left+right)//2，检查是否存在长度为mid的重复子串
    - 如果存在（check(mid)不为None），说明可能还有更长的重复子串：更新结果并将left=mid+1
    - 如果不存在（check(mid)为None），说明当前长度太大，需要减小：将right=mid-1
    - 最终，right即为最长重复子串的长度，result为其中一个子串
    <p>
    预处理阶段详解：
    1. 幂次数组计算：
       - pow_arr[i]表示base的i次幂，用于子串哈希值的快速计算
       - 采用递推方式计算：pow_arr[0]=1，pow_arr[i]=pow_arr[i-1]*base
       - 这样可以避免重复计算，确保O(1)时间访问
    <p>
    2. 前缀哈希数组计算：
       - hash_arr[i]表示字符串前i+1个字符（s[0...i]）的哈希值
       - 递推公式：hash_arr[i] = hash_arr[i-1] * base + (ord(s[i]) - ord('a') + 1)
       - 字符映射加1是为了避免'0'值（当字符为'a'时，如果不加1会被映射为0）
    <p>
    数学原理示例：
    对于字符串"abc"，base=499：
    - pow_arr数组：pow_arr[0]=1, pow_arr[1]=499, pow_arr[2]=499²
    - hash_arr数组：
      - hash_arr[0] = ord('a')-ord('a')+1 = 1
      - hash_arr[1] = 1*499 + (ord('b')-ord('a')+1) = 499 + 2 = 501
      - hash_arr[2] = 501*499 + (ord('c')-ord('a')+1) = 501*499 + 3
    
    :param s: 输入字符串
    :return: 最长重复子串，如果不存在则返回空字符串
    """
    n = len(s)
    
    # 预处理base的幂次
    # 这是多项式滚动哈希算法的关键组成部分，用于快速计算子串哈希
    pow_arr = [1] * n
    pow_arr[0] = 1  # 基础情况：base^0 = 1
    for i in range(1, n):
        # 递推计算：pow_arr[i] = pow_arr[i-1] * base
        # 注意：Python中整数精度不受限制，不会出现整数溢出
        pow_arr[i] = pow_arr[i - 1] * base

    # 计算前缀哈希值
    # 使用多项式滚动哈希算法，计算每个前缀的哈希值
    hash_arr = [0] * n
    hash_arr[0] = ord(s[0]) - ord('a') + 1  # 第一个字符的哈希值，加1避免0值
    # 字符加1的目的是确保不同的空字符串不会产生相同的哈希值
    # 例如，字符'a'会被映射为1而非0
    for i in range(1, n):
        # 哈希值递推公式：hash_arr[i] = hash_arr[i-1] * base + (ord(s[i])的映射值)
        # 这个公式构建了一个多项式表示，确保子串哈希值可以通过前缀哈希计算得到
        hash_arr[i] = hash_arr[i - 1] * base + (ord(s[i]) - ord('a') + 1)

    # 计算子串s[l...r]的哈希值
    # 这是一个内部函数，利用预处理好的前缀哈希数组和幂次数组在O(1)时间内计算任意子串的哈希值
    def substring_hash(l, r):
        """
        在O(1)时间内计算子串s[l...r]的哈希值
        
        数学原理解析：
        - 前缀哈希定义：hash_arr[r] = s[0]*base^r + s[1]*base^(r-1) + ... + s[r]*base^0
        - 子串哈希计算原理：要得到s[l...r]的哈希值，需要从hash_arr[r]中减去s[0...l-1]部分的影响
        - 当l=0时，子串就是前缀本身，直接返回hash_arr[r]
        - 当l>0时，需要将hash_arr[l-1]乘以base^(r-l+1)，然后从hash_arr[r]中减去
        
        数学推导：
        hash_arr[r] = s[0]*base^r + s[1]*base^(r-1) + ... + s[l-1]*base^(r-l+1) + s[l]*base^(r-l) + ... + s[r]
        hash_arr[l-1]*base^(r-l+1) = (s[0]*base^(l-1) + ... + s[l-1]) * base^(r-l+1)
                                   = s[0]*base^r + ... + s[l-1]*base^(r-l+1)
        因此：hash_arr[r] - hash_arr[l-1]*base^(r-l+1) = s[l]*base^(r-l) + ... + s[r]
        这正是子串s[l...r]的哈希值
        
        参数：
            l: 子串起始位置（包含，从0开始）
            r: 子串结束位置（包含，从0开始）
        
        返回：
            子串s[l...r]的哈希值
        """
        if l == 0:
            # 起始位置为0，直接返回前缀哈希值
            return hash_arr[r]
        else:
            # 计算子串哈希值 = 前缀哈希(r) - 前缀哈希(l-1) * base^(r-l+1)
            return hash_arr[r] - hash_arr[l - 1] * pow_arr[r - l + 1]
    
    # 检查是否存在长度为length的重复子串
    # 如果存在，返回其中一个子串；否则返回None
    def check(length):
        """
        检查是否存在长度为length的重复子串
        <p>
        这是二分查找中的关键判定方法，用于检查是否存在指定长度的重复子串。
        通过哈希+集合的方式，实现O(n)时间复杂度的高效检查。
        <p>
        算法原理：
        1. 滑动窗口思想：遍历所有可能的长度为length的子串
        2. 哈希去重：利用多项式滚动哈希计算子串的哈希值
        3. 集合查询：使用set快速判断哈希值是否已存在
        <p>
        边界条件处理：
        - 当length=0时，根据题目要求返回""（空字符串总是重复的）
        - 当length>n时，不存在这样的子串，应返回None
        - 但在二分查找中，length的范围是[0, n-1]，因此第二个条件不会触发
        <p>
        哈希冲突问题详解：
        - 在理想情况下，不同的子串应产生不同的哈希值
        - 但由于哈希函数是压缩映射，可能存在不同子串产生相同哈希值的情况（哈希冲突）
        - 冲突概率与哈希基数和字符串特性有关
        - 为提高正确性，可以采用以下策略：
          a. 双哈希：使用两个不同的哈希函数，只有两个哈希值都匹配时才认为重复
          b. 冲突验证：当哈希值相同时，进行实际字符串比较确认
        
        :param length: 要检查的子串长度
        :return: 如果存在重复子串，返回其中一个子串；否则返回None
        """
        if length == 0:
            return ""  # 长度为0的子串总是存在
        
        # 使用set存储已经出现过的子串哈希值
        # set提供平均O(1)的插入和查询时间复杂度
        seen = set()
        
        # 遍历所有可能的长度为length的子串
        # 起始位置i的取值范围：0 <= i <= n - length
        # 总共有(n - length + 1)个可能的子串
        for i in range(n - length + 1):
            # 计算子串s[i...i+length-1]的哈希值
            # 利用预处理好的前缀哈希数组和幂次数组，实现O(1)时间计算
            h = substring_hash(i, i + length - 1)
            
            # 检查哈希值是否已经存在于集合中
            # 如果存在，说明找到了重复的子串
            # 注意：这里可能存在哈希冲突，导致误判
            if h in seen:
                # 优化建议：在这里可以添加实际字符串比较来验证是否真的重复
                # 例如：if h in seen and s[i:i+length] == last_substring:
                # 找到重复的哈希值，返回子串
                return s[i:i + length]
            
            # 将当前哈希值加入集合，供后续子串检查使用
            seen.add(h)
        
        # 没有找到重复子串
        return None
    
    # 二分查找阶段：寻找最长重复子串的长度
    # 这是算法的核心，通过二分查找将时间复杂度从O(n²)降低到O(n log n)
    left, right = 0, n - 1  # 二分查找的左右边界
    result = ""             # 记录最长重复子串
    
    # 二分查找主循环
    # 循环不变式：在每次迭代开始前，可能的最长重复子串长度在[left, right]范围内
    while left <= right:
        # 计算中间长度mid，避免整数溢出的写法：mid = left + (right - left) // 2
        # 但在本题中，由于n最大为30000，直接相加不会溢出
        mid = (left + right) // 2 
        
        # 检查是否存在长度为mid的重复子串
        # check方法返回第一个找到的重复子串，如果不存在则返回None
        dup = check(mid)

        if dup is not None:
            # 存在长度为mid的重复子串
            # 根据单调性，可能存在更长的重复子串，因此尝试更大的长度
            result = dup      # 更新结果记录
            left = mid + 1    # 左边界右移，搜索更长的可能长度
        else:
            # 不存在长度为mid的重复子串
            # 根据单调性，任何比mid更长的子串也不可能重复，因此尝试更短的长度
            right = mid - 1   # 右边界左移，搜索更短的可能长度
    
    # 二分查找终止时的状态分析：
    # - left > right：搜索区间为空
    # - right是最大的长度，使得存在长度为right的重复子串
    # - result是找到的其中一个重复子串
    # - 如果没有找到任何重复子串，result为""
    
    return result

def main():
    """
    主函数，处理输入输出并执行算法的核心逻辑
    
    处理流程详解：
    1. 输入处理阶段：
       - 读取字符串s
       
    2. 算法执行阶段：
       - 调用longest_duplicate_substring方法查找最长重复子串
       
    3. 结果输出：
       - 输出找到的最长重复子串
    """
    s = input().strip()
    print(longest_duplicate_substring(s))

if __name__ == "__main__":
    main()