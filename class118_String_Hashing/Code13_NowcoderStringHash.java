package class105;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;
import java.io.PrintWriter;
import java.util.HashSet;

/**
 * 牛客网字符串哈希问题实现
 * <p>
 * 题目链接: https://www.nowcoder.com/practice/dadbd37fee7c43f0ae407db11b16b4bf
 * <p>
 * 题目描述:
 * 给定N个字符串，计算其中不同字符串的个数
 * 例如：输入["abc", "def", "abc", "ghi"]，输出3
 * <p>
 * 算法核心思想:
 * 使用多项式滚动哈希（Polynomial Rolling Hash）算法将字符串映射为数值，
 * 利用HashSet的去重特性统计不同字符串的数量
 * <p>
 * 算法详细步骤:
 * 1. 输入阶段：
 *    - 读取字符串数量N
 *    - 读取N个字符串并存储
 * 2. 哈希计算阶段：
 *    - 对每个字符串计算唯一的哈希值
 *    - 使用多项式滚动哈希算法，确保相同字符串产生相同哈希值
 * 3. 去重统计阶段：
 *    - 将所有哈希值存入HashSet
 *    - 利用HashSet自动去重的特性
 * 4. 结果输出：
 *    - HashSet的大小即为不同字符串的个数
 * <p>
 * 哈希算法原理详解:
 * - 多项式滚动哈希函数：hash(s) = (s[0]*base^(len-1) + s[1]*base^(len-2) + ... + s[len-1]) % mod
 * - 滚动计算形式：hash = ((...((s[0]*base) + s[1])*base + ... )*base + s[len-1]) % mod
 * - 基数选择：使用131作为基数，这是一个经验值，可以有效减少哈希冲突
 * - 模数选择：使用1e9+7作为大质数模数，防止整数溢出并提供良好的分布性
 * <p>
 * 算法优势:
 * - 高效性：时间复杂度为O(N*M)，远优于字符串直接比较的O(N²*M)算法
 * - 空间效率：通过哈希压缩，减少了比较时的存储空间需求
 * - 实现简单：算法逻辑清晰，代码实现简洁
 * <p>
 * 时间复杂度分析:
 * - 输入处理：O(N*M)，其中N是字符串数量，M是平均字符串长度
 * - 哈希计算：O(N*M)，每个字符串需要遍历其所有字符
 * - 去重统计：O(N)，HashSet的插入和查询平均时间复杂度为O(1)
 * - 总体时间复杂度：O(N*M)
 * <p>
 * 空间复杂度分析:
 * - 字符串存储：O(N*M)，存储所有输入字符串
 * - 哈希值数组：O(N)，存储每个字符串的哈希值
 * - HashSet：O(N)，存储去重后的哈希值
 * - 总体空间复杂度：O(N*M)
 * <p>
 * 哈希冲突处理:
 * - 单哈希可能产生哈希冲突，导致不同字符串有相同哈希值
 * - 对于题目要求，使用131作为基数和1e9+7作为模数的组合，冲突概率极低
 * - 在实际应用中，可以考虑以下方案进一步降低冲突：
 *   1. 使用双哈希（两个不同的哈希函数）
 *   2. 增大模数（如使用更大的质数或使用长整型）
 *   3. 在哈希值相同时进行字符串直接比较
 * <p>
 * 与其他方法比较:
 * 1. 暴力比较法：O(N²*M)时间复杂度，对于大量字符串效率极低
 * 2. 排序后比较：O(N*M*logN)时间复杂度，需要额外排序步骤
 * 3. Trie树：空间复杂度可能更高，但在某些场景下查找更快
 * 4. 本哈希方法：在时间和空间上都提供了良好的平衡
 * <p>
 * 相似题目:
 * 1. LeetCode 217: Contains Duplicate - 判断数组中是否有重复元素
 * 2. POJ 3349: Snowflake Snow Snowflakes - 判断雪花是否唯一
 * 3. HDU 1267: 下沙的沙子有几粒？- 计算不同字符串组合数目
 * 4. SPOJ DICT: Dictionary - 字典查询问题
 * <p>
 * 测试链接: https://www.nowcoder.com/practice/dadbd37fee7c43f0ae407db11b16b4bf
 * 
 * @author Algorithm Journey
 */

public class Code13_NowcoderStringHash {

    /**
     * 最大字符串数量
     * 根据题目约束设置为10001，确保有足够空间存储所有输入字符串
     */
    public static int MAXN = 10001;
    
    /**
     * 每个字符串的最大长度
     * 设置为1001，确保有足够空间存储单个字符串
     */
    public static int MAXM = 1001;
    
    /**
     * 哈希基数，选择131是因为可以有效减少哈希冲突
     * 131是经验证的良好哈希基数，与1e9+7配合使用时冲突概率极低
     */
    public static int base = 131;
    
    /**
     * 哈希模数，使用1e9+7作为大质数模数
     * 10^9+7是一个常用的大质数，既能有效防止整数溢出，又能提供良好的哈希分布
     */
    public static int mod = 1000000007;
    
    /**
     * 字符串存储数组，二维数组，每行存储一个字符串
     * strings[i]存储第i个字符串的字符数组
     */
    public static char[][] strings = new char[MAXN][MAXM];
    
    /**
     * 存储每个字符串的实际长度
     * lengths[i]表示第i个字符串的长度
     */
    public static int[] lengths = new int[MAXN];
    
    /**
     * 存储每个字符串对应的哈希值
     * hashes[i]存储第i个字符串的哈希值
     */
    public static long[] hashes = new long[MAXN];
    
    /**
     * 主方法，程序入口
     * <p>
     * 处理流程：
     * 1. 初始化高效的输入输出流，处理大量数据输入
     * 2. 读取字符串数量n
     * 3. 循环读取n个字符串并存储到二维字符数组中
     * 4. 对每个字符串计算哈希值并存储
     * 5. 使用HashSet去重并统计不同哈希值的数量
     * 6. 输出统计结果
     * 7. 关闭输入输出流，释放资源
     * <p>
     * 输入格式：
     * 第一行：整数n，表示字符串数量
     * 接下来n行：每行一个字符串
     * <p>
     * 输出格式：
     * 一个整数，表示不同字符串的数量
     * <p>
     * 示例输入：
     * 4
     * abc
     * def
     * abc
     * ghi
     * <p>
     * 示例输出：
     * 3
     * 
     * @param args 命令行参数
     * @throws IOException 输入输出异常
     * 
     * 时间复杂度：O(N*M)，其中N是字符串数量，M是平均字符串长度
     * 空间复杂度：O(N*M + N) = O(N*M)
     */
    public static void main(String[] args) throws IOException {
        // 输入输出流初始化
        // 使用BufferedReader和PrintWriter提高IO效率，处理大数据量
        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
        PrintWriter out = new PrintWriter(new OutputStreamWriter(System.out));
        
        // 读取字符串数量
        int n = Integer.parseInt(in.readLine());
        
        // 读取所有字符串并存储到字符数组中
        for (int i = 0; i < n; i++) {
            String line = in.readLine();
            lengths[i] = line.length();
            // 将String转换为char数组存储，便于后续哈希计算
            // getChars方法高效地将String复制到char数组
            line.getChars(0, lengths[i], strings[i], 0);
        }
        
        // 计算每个字符串的哈希值
        // 对每个字符串调用calculateHash方法计算其哈希值
        for (int i = 0; i < n; i++) {
            hashes[i] = calculateHash(strings[i], lengths[i]);
        }
        
        // 使用HashSet统计不同哈希值的数量，自动去重
        // HashSet的add方法可以在平均O(1)时间内完成插入和去重
        HashSet<Long> uniqueHashes = new HashSet<>();
        for (int i = 0; i < n; i++) {
            uniqueHashes.add(hashes[i]);
        }
        
        // 输出不同字符串的数量
        // HashSet的大小即为不同哈希值的数量，也就是不同字符串的数量（在无冲突的情况下）
        out.println(uniqueHashes.size());
        
        // 关闭输入输出流，确保所有数据都被刷新并释放资源
        out.flush();
        out.close();
        in.close();
    }
    
    /**
     * 计算字符串的哈希值
     * 使用多项式滚动哈希算法将字符串转换为唯一的数值表示
     * <p>
     * 多项式滚动哈希原理：
     * - 将字符串视为base进制数，每个字符的ASCII码值作为数字
     * - 哈希值计算公式：hash(s) = (s[0]*base^(len-1) + s[1]*base^(len-2) + ... + s[len-1]) mod mod
     * - 使用滚动计算优化：hash = ((...((s[0]*base) + s[1])*base + ... )*base + s[len-1]) % mod
     * <p>
     * 数学原理详解：
     * 1. 对于字符串s[0..len-1]，哈希值可以看作是一个多项式：
     *    hash(s) = s[0]*base^(len-1) + s[1]*base^(len-2) + ... + s[len-1]*base^0
     * 2. 滚动计算形式：
     *    - 初始hash=0
     *    - 遍历每个字符c：hash = (hash * base + c) % mod
     * 3. 这样计算的结果与多项式形式完全等价，但计算效率更高
     * <p>
     * 字符处理说明：
     * - 直接使用字符的ASCII码值作为系数，无需额外映射
     * - 例如，字符'a'的ASCII码为97，将直接作为计算的一部分
     * <p>
     * 取模操作的作用：
     * 1. 防止整数溢出
     * 2. 将哈希值限制在一定范围内，便于存储和比较
     * 3. 虽然可能产生哈希冲突，但选择合适的base和mod可以将冲突概率降到极低
     * 
     * @param s 字符串数组
     * @param len 字符串长度
     * @return 字符串的哈希值
     * 
     * 时间复杂度: O(len) - 线性时间，需要遍历字符串的每个字符
     * 空间复杂度: O(1) - 只使用常数级额外空间
     * 
     * 示例：
     * 对于字符串"abc"，base=131，mod=1e9+7
     * hash("abc") = (('a' * 131 + 'b') * 131 + 'c') % 1e9+7
     *              = ((97 * 131 + 98) * 131 + 99) % 1e9+7
     *              = (12705 + 98) * 131 + 99 % 1e9+7
     *              = 12803 * 131 + 99 % 1e9+7
     *              = 1677193 + 99 % 1e9+7
     *              = 1677292
     */
    public static long calculateHash(char[] s, int len) {
        long hash = 0; // 初始化哈希值为0
        
        // 滚动计算哈希值，每次将当前哈希值乘以base再加上当前字符的ASCII码值
        // 这种计算方式等价于多项式展开，但更高效
        for (int i = 0; i < len; i++) {
            // 模运算防止数值溢出，确保结果在整型范围内
            // 注意：使用long类型暂存中间结果，避免在乘法时溢出
            hash = (hash * base + s[i]) % mod;
        }
        
        return hash; // 返回最终的哈希值
    }
	
	/*
	 * ============================================================================
	 * 哈希冲突概率数学分析
	 * ============================================================================
	 * 哈希冲突是指不同字符串产生相同哈希值的现象。在统计不同字符串数量的问题中，
	 * 哈希冲突会导致误判，将不同的字符串视为相同字符串。
	 * 
	 * 1. 当前实现的哈希参数与冲突风险：
	 *    - 基数base=131，模数mod=10^9+7（约10亿）
	 *    - 哈希空间大小M≈10^9
	 *    - 直接使用字符的ASCII码值（如'a'=97）
	 *    - 滚动计算方式：hash = ((...((s[0]*base) + s[1])*base + ... )*base + s[len-1]) % mod
	 * 
	 * 2. 生日悖论下的冲突概率计算：
	 *    - 对于N个不同字符串，计算至少一次冲突的概率
	 *    - 概率近似公式：P ≈ 1 - e^(-N²/(2M))
	 *    - 当N=1e4, M=1e9时，P≈1 - e^(-(1e4)^2/(2×1e9)) ≈ 0.00005
	 *    - 当N=1e5, M=1e9时，P≈1 - e^(-(1e5)^2/(2×1e9)) ≈ 0.39
	 *    - 当N=2e5, M=1e9时，P≈1 - e^(-(2e5)^2/(2×1e9)) ≈ 0.86
	 *    - 结论：当字符串数量增加时，冲突概率急剧上升
	 * 
	 * 3. 模数与基数的选择优化：
	 *    - 模数选择：1e9+7是常用大质数，但在大规模数据下仍有冲突风险
	 *    - 基数选择：131是常用基数，但可能在某些场景下分布不够均匀
	 *    - 推荐组合：
	 *      a. base=131, mod=1e9+7 (当前使用)
	 *      b. base=13331, mod=1e9+9
	 *      c. base=911, mod=1e9+7
	 *      d. 对于关键应用，考虑使用更大模数或双哈希
	 * 
	 * 4. 冲突期望与实际影响：
	 *    - 期望冲突次数：E = N²/(2M)
	 *    - 当N=1e5, M=1e9时，E≈(1e10)/(2×1e9)=5
	 *    - 在编程竞赛中，这可能导致无法通过所有测试用例
	 *    - 在统计问题中，会低估不同字符串的真实数量
	 * 
	 * 5. 安全参数选择指南：
	 *    - 对于小数据（N<1e4）：单哈希+1e9+7通常足够
	 *    - 对于中等数据（1e4≤N<1e5）：考虑使用双哈希或更大模数
	 *    - 对于大数据（N≥1e5）：强烈建议使用双哈希
	 *    - 对于100%正确性要求：哈希值相等后再进行字符串直接比较
	 */
	
	/*
	 * ============================================================================
	 * 双哈希实现示例
	 * ============================================================================
	 * 双哈希通过同时使用两个独立的哈希函数，可以大幅降低冲突概率。在统计不同字符串问题中，
	 * 只有当两个哈希值都相同时才认为字符串相同。
	 * 
	 * 1. 双哈希常量定义：
	 */
	/*
	// 第一个哈希函数的参数
public static int BASE1 = 131;
public static long MOD1 = 1000000007;

// 第二个哈希函数的参数
public static int BASE2 = 13331;
public static long MOD2 = 1000000009;

// 存储每个字符串对应的双哈希值
public static long[] hashes1 = new long[MAXN]; // 第一个哈希函数的哈希值
public static long[] hashes2 = new long[MAXN]; // 第二个哈希函数的哈希值
	 */
	
	/*
	 * 2. 双哈希计算函数：
	 */
	/*
	// 计算第一个哈希值
public static long calculateHash1(char[] s, int len) {
	long hash = 0;
	for (int i = 0; i < len; i++) {
		hash = (hash * BASE1 + s[i]) % MOD1;
	}
	return hash;
}

// 计算第二个哈希值
public static long calculateHash2(char[] s, int len) {
	long hash = 0;
	for (int i = 0; i < len; i++) {
		hash = (hash * BASE2 + s[i]) % MOD2;
	}
	return hash;
}
	 */
	
	/*
	 * 3. 内部类定义用于存储双哈希值：
	 */
	/*
	// 定义哈希对类，用于存储双哈希值
public static class HashPair {
	public long hash1; // 第一个哈希值
	public long hash2; // 第二个哈希值
	
	// 构造函数
	public HashPair(long hash1, long hash2) {
		this.hash1 = hash1;
		this.hash2 = hash2;
	}
	
	// 重写equals方法，确保两个哈希对只有在两个哈希值都相等时才相等
	@Override
	public boolean equals(Object obj) {
		if (this == obj) return true;
		if (obj == null || getClass() != obj.getClass()) return false;
		HashPair other = (HashPair) obj;
		return hash1 == other.hash1 && hash2 == other.hash2;
	}
	
	// 重写hashCode方法，为HashSet存储提供支持
	@Override
	public int hashCode() {
		// 结合两个哈希值生成一个新的哈希码
		return (int) (hash1 ^ (hash2 >>> 32));
	}
}
	 */
	
	/*
	 * 4. 双哈希去重实现：
	 */
	/*
	// 使用双哈希计算所有字符串的哈希值
for (int i = 0; i < n; i++) {
	hashes1[i] = calculateHash1(strings[i], lengths[i]);
	hashes2[i] = calculateHash2(strings[i], lengths[i]);
}

// 使用HashSet存储双哈希值，自动去重
HashSet<HashPair> uniqueHashPairs = new HashSet<>();
for (int i = 0; i < n; i++) {
	uniqueHashPairs.add(new HashPair(hashes1[i], hashes2[i]));
}

// 输出不同字符串的数量
out.println(uniqueHashPairs.size());
	 */
	
	/*
	 * 5. 双哈希的优势分析：
	 *    - 冲突概率：从单哈希的P降低到P²级别
	 *    - 当N=1e5, M=1e9时，单哈希冲突概率≈0.39，双哈希≈0.15
	 *    - 使用两个大质数模数时，理论冲突概率极低
	 *    - 在编程竞赛中，双哈希通常可以通过所有测试用例
	 *    - 时间开销：只比单哈希多约50%的计算量
	 *    - 空间开销：需要存储两个哈希数组和一个HashPair类
	 */
	
	/*
	 * ============================================================================
	 * 推荐测试用例
	 * ============================================================================
	 * 以下测试用例覆盖了牛客网字符串哈希问题的各种场景，有助于验证算法正确性。
	 * 
	 * 1. 基本功能测试：
	 *    - 测试用例1：简单重复字符串
	 *      输入：
	 *      4
	 *      abc
	 *      def
	 *      abc
	 *      ghi
	 *      预期输出：3
	 *      解释：有3个不同的字符串
	 *      
	 *    - 测试用例2：无重复字符串
	 *      输入：
	 *      3
	 *      apple
	 *      banana
	 *      cherry
	 *      预期输出：3
	 *      解释：所有字符串都不相同
	 *      
	 *    - 测试用例3：全重复字符串
	 *      输入：
	 *      5
	 *      same
	 *      same
	 *      same
	 *      same
	 *      same
	 *      预期输出：1
	 *      解释：所有字符串都相同
	 * 
	 * 2. 边界情况测试：
	 *    - 测试用例4：空字符串
	 *      输入：
	 *      3
	 *      
	 *      
	 *      test
	 *      预期输出：2
	 *      解释：空字符串算一种，test算一种
	 *      
	 *    - 测试用例5：单字符字符串
	 *      输入：
	 *      6
	 *      a
	 *      b
	 *      a
	 *      c
	 *      d
	 *      b
	 *      预期输出：4
	 *      解释：4个不同的单字符字符串
	 *      
	 *    - 测试用例6：最大数量限制
	 *      输入：
	 *      10000
	 *      [10000个不同的字符串]
	 *      预期输出：10000
	 *      测试算法处理最大数据量的能力
	 * 
	 * 3. 哈希冲突测试：
	 *    - 测试用例7：构造的哈希冲突字符串
	 *      目的：测试算法在哈希冲突情况下的表现
	 *      注意：需要针对具体哈希函数构造冲突字符串
	 *      
	 *    - 测试用例8：接近冲突的字符串
	 *      输入：
	 *      2
	 *      abc123
	 *      abc124
	 *      预期输出：2
	 *      解释：测试相似字符串的处理
	 * 
	 * 4. 特殊字符测试：
	 *    - 测试用例9：包含特殊字符的字符串
	 *      输入：
	 *      4
	 *      hello@world
	 *      hello#world
	 *      hello@world
	 *      hello$world
	 *      预期输出：3
	 *      解释：测试特殊字符对哈希计算的影响
	 *      
	 *    - 测试用例10：包含非ASCII字符的字符串
	 *      输入：
	 *      3
	 *      你好
	 *      世界
	 *      你好
	 *      预期输出：2
	 *      解释：测试Unicode字符的处理
	 * 
	 * 5. 性能测试：
	 *    - 测试用例11：长字符串测试
	 *      输入：
	 *      100
	 *      [100个长度接近1000的字符串，部分重复]
	 *      预期输出：[重复次数取决于输入]
	 *      测试处理长字符串的性能
	 */
	
	/*
	 * ============================================================================
	 * 字符串哈希算法比较分析
	 * ============================================================================
	 * 以下是不同字符串去重算法的详细对比分析，帮助理解哈希方法在字符串去重中的优势和劣势。
	 * 
	 * | 算法类型 | 时间复杂度 | 空间复杂度 | 实现复杂度 | 准确率 | 适用场景 |
	 * |---------|----------|-----------|-----------|-------|--------|
	 * | 多项式滚动哈希(单模数) | O(N*M) | O(N + K) | 低 | 高 | 编程竞赛，中等规模数据 |
	 * | 双哈希 | O(N*M) | O(N + K) | 中 | 极高 | 编程竞赛，大规模数据 |
	 * | 暴力比较法 | O(N²*M) | O(K*M) | 极低 | 100% | 小规模数据 |
	 * | 排序后比较 | O(N*M*logN) | O(N*M) | 低 | 100% | 中等规模数据 |
	 * | Trie树 | O(N*M) | O(K*M) | 中 | 100% | 前缀查询场景 |
	 * | HashSet直接存储 | O(N) | O(N*M) | 极低 | 100% | 小规模数据，内存充足 |
	 * | 后缀数组 | O(N*M) | O(N*M) | 高 | 100% | 字符串相似性分析 |
	 * 
	 * 注：N为字符串数量，M为平均字符串长度，K为不同字符串数量
	 * 
	 * 1. 哈希方法的优缺点：
	 *    - 优点：
	 *      * 时间效率高，O(N*M)复杂度
	 *      * 实现简单，代码量少
	 *      * 空间效率相对较好（存储哈希值而非原始字符串）
	 *      * 易于扩展和维护
	 *    - 缺点：
	 *      * 理论上存在哈希冲突风险
	 *      * 在极端情况下可能需要额外的字符串比较
	 *      * 性能受哈希函数质量影响
	 * 
	 * 2. 与排序后比较的比较：
	 *    - 时间复杂度：哈希法O(N*M) vs 排序法O(N*M*logN)
	 *    - 空间复杂度：两者相似
	 *    - 实现复杂度：哈希法更简单
	 *    - 准确率：排序法100%正确，哈希法理论有冲突风险
	 *    - 适用场景：哈希法适合需要快速去重的场景，排序法适合需要稳定结果的场景
	 * 
	 * 3. 与Trie树的比较：
	 *    - 时间复杂度：两者都是O(N*M)
	 *    - 空间复杂度：Trie树可能更优（共享前缀），但实际取决于字符串分布
	 *    - 实现复杂度：Trie树更复杂
	 *    - 准确率：Trie树100%正确
	 *    - 扩展功能：Trie树支持前缀查询，哈希法不支持
	 * 
	 * 4. 工业级应用中的最佳实践：
	 *    - 对于大数据量：
	 *      a. 分布式哈希表（如Redis集群）
	 *      b. 布隆过滤器（用于快速判断元素是否可能存在）
	 *    - 对于内存受限环境：
	 *      a. 压缩哈希表
	 *      b. 位图索引
	 *    - 对于实时系统：
	 *      a. 增量哈希计算
	 *      b. 缓存优化
	 *    - 对于高准确率要求：
	 *      a. 双哈希
	 *      b. 哈希值相等后再进行字符串比较
	 * 
	 * 5. 牛客网字符串去重问题的最佳算法选择：
	 *    - 首选方案：双哈希（本题代码的升级版）
	 *    - 理由：
	 *      a. 时间复杂度O(N*M)，满足题目要求
	 *      b. 空间效率良好
	 *      c. 实现相对简单
	 *      d. 冲突概率极低，在竞赛中足够可靠
	 *    - 次选方案：排序后比较
	 *    - 不推荐：暴力比较法（对于大数据量效率太低）
	 * 
	 * 6. 哈希优化技巧：
	 *    - 使用大质数模数和互质基数
	 *    - 对不同类型的字符串选择不同的哈希策略
	 *    - 对于非常长的字符串，可以考虑分段哈希
	 *    - 在哈希值相等时进行字符串比较（对于关键应用）
	 *    - 使用位运算优化哈希计算（如移位代替乘法）
	 *    - 预计算哈希值并缓存，避免重复计算
	 */
}