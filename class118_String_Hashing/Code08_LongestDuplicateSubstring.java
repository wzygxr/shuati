package class105;

import java.util.HashSet;

/**
 * LeetCode 1044 - 最长重复子串问题实现
 * <p>
 * 题目链接：https://leetcode.com/problems/longest-duplicate-substring/
 * <p>
 * 题目描述：
 * 给你一个字符串 s，考虑其所有重复子串：即 s 的连续子串，在 s 中出现 2 次或更多次。
 * 这些出现之间可能存在重叠。返回任意一个可能具有最长长度的重复子串。
 * 如果 s 不含重复子串，那么答案为空字符串。
 * <p>
 * 算法核心思想：
 * 1. 二分查找优化：利用二分查找确定最长重复子串的可能长度
 * 2. 哈希去重技术：使用多项式滚动哈希快速判断子串是否重复
 * 3. 集合存储：利用HashSet高效存储和查询子串哈希值
 * 4. 预计算策略：预先计算哈希值和幂次数组，支持O(1)时间子串哈希值查询
 * <p>
 * 多项式滚动哈希数学原理：
 * - 哈希函数定义：对于字符串s[0...n-1]，哈希值H(s) = s[0]*base^(n-1) + s[1]*base^(n-2) + ... + s[n-1]
 * - 前缀哈希：hash[i] = s[0]*base^i + s[1]*base^(i-1) + ... + s[i]
 * - 子串哈希：hash(l,r) = hash[r] - hash[l-1]*base^(r-l+1)，当l>0时
 * - 这种设计使得我们可以在O(1)时间内计算任意子串的哈希值，而无需重新计算
 * <p>
 * 算法详细步骤：
 * 1. 预处理阶段：
 *    - 预计算幂次数组pow[i] = base^i，避免重复计算
 *    - 计算字符串的前缀哈希数组，为后续子串哈希计算做准备
 * 2. 二分查找阶段：
 *    - 二分查找范围：0到n-1（n为字符串长度）
 *    - 对于每个中间长度m，调用check方法检查是否存在长度为m的重复子串
 *    - 如果存在，记录起始位置并尝试更长的长度；否则尝试更短的长度
 * 3. 子串检查阶段（check方法）：
 *    - 使用HashSet存储已见过的子串哈希值
 *    - 遍历所有长度为len的子串，计算其哈希值并检查是否已经存在
 *    - 如果存在重复，返回子串起始位置；否则将哈希值加入集合
 * 4. 结果构建：根据找到的最长长度和起始位置，返回最长重复子串
 * <p>
 * 算法正确性证明：
 * - 二分查找的正确性基于单调性质：如果存在长度为m的重复子串，那么对于所有k < m，也存在长度为k的重复子串
 * - 因此，二分查找可以找到最大的m值，使得存在长度为m的重复子串
 * - 哈希函数假设：在实际应用中，哈希冲突概率极低，可以近似认为哈希值相同意味着子串相同
 * <p>
 * 哈希冲突处理策略：
 * - 单哈希方案：当前实现使用单个哈希函数，对于大多数测试用例足够安全
 * - 双哈希优化：可以使用两个不同的哈希函数（不同的base和mod），只有当两个哈希值都匹配时才认为子串相同
 * - 冲突验证：当检测到哈希值相同时，可以进行实际的字符串比较来确认是否真的重复
 * - 模数选择：在实际应用中，通常会选择一个大质数作为模数，如10^9+7或10^9+9
 * <p>
 * 时间复杂度分析：
 * - 预处理阶段：O(n)，计算前缀哈希和幂次数组
 * - 二分查找阶段：O(log n)次迭代，每次迭代处理一个中间长度
 * - 每次check操作：O(n)，遍历所有长度为len的子串，每次哈希计算为O(1)
 * - 哈希集合操作：平均O(1)的插入和查询时间
 * - 总体时间复杂度：O(n log n)
 * <p>
 * 空间复杂度分析：
 * - 前缀哈希数组：O(n)，存储每个前缀的哈希值
 * - 幂次数组：O(n)，存储base的幂次
 * - HashSet存储：O(n)，最坏情况下存储所有子串的哈希值
 * - 总体空间复杂度：O(n)
 * <p>
 * 优化点分析：
 * 1. 双哈希方案：使用两个不同的哈希函数可以将冲突概率降低到几乎为零
 * 2. 大模数：添加大质数模数可以防止整数溢出并进一步减少冲突
 * 3. 字符串比较：对于哈希冲突的情况进行实际字符串比较，确保正确性
 * 4. 后缀数组：对于特别大的字符串，可以使用后缀数组方法，时间复杂度为O(n)或O(n log n)
 * 5. Rabin-Karp优化：可以利用滑动窗口技术优化哈希计算
 * <p>
 * 相似题目：
 * 1. LeetCode 1392: Longest Happy Prefix - 最长前缀后缀匹配
 * 2. LeetCode 686: Repeated String Match - 重复叠加字符串匹配
 * 3. LintCode 1360: 重复的DNA序列 - 固定长度重复子串查找
 * 4. HackerRank: Longest Repeating Substring - 重复子串查找
 * 5. CodeChef SUBINC - 递增子序列问题
 * 6. UVa 11475: Extend to Palindrome - 字符串扩展问题
 * 7. 牛客 NC132: 最长回文子串 - 回文子串查找
 * <p>
 * 测试链接：https://leetcode.com/problems/longest-duplicate-substring/
 * <p>
 * 多语言实现计划：
 * - Java实现：当前文件
 * - Python实现：Code08_LongestDuplicateSubstring.py（待实现）
 * - C++实现：Code08_LongestDuplicateSubstring.cpp（待实现）
 * - Go实现：Code08_LongestDuplicateSubstring.go（待实现）
 * <p>
 * 算法应用场景：
 * - 文本去重和相似性分析
 * - DNA序列分析中的重复序列查找
 * - 网络安全中的重复数据包检测
 * - 搜索引擎中的重复内容识别
 * - 代码库中的代码重复检测
 * 
 * @author Algorithm Journey
 * @version 1.0
 * @since 2024-01-01
 */
public class Code08_LongestDuplicateSubstring {

	/**
	 * 最大字符串长度
	 * 设置为30010，足够处理LeetCode题目约束
	 */
	public static int MAXN = 30010;

	/**
	 * 哈希基数，选择499作为大质数以减少哈希冲突
	 * 使用质数作为基数可以使哈希分布更均匀
	 */
	public static int base = 499;

	/**
	 * 存储base的幂次，避免重复计算
	 * pow[i] = base^i，用于快速计算子串哈希值
	 */
	public static long[] pow = new long[MAXN];

	/**
	 * 存储字符串的前缀哈希值
	 * hash[i]表示字符串前i+1个字符（s[0...i]）的哈希值
	 */
	public static long[] hash = new long[MAXN];

	/**
	 * 字符串长度
	 * 作为全局变量，避免在方法间传递
	 */
	public static int n;

	/**
	 * 字符数组，用于存储输入字符串
	 * 转换为字符数组以提高访问效率
	 */
	public static char[] s;

	/**
 * 查找最长重复子串的核心方法
 * <p>
 * 该方法采用二分查找结合多项式滚动哈希技术，高效地找到字符串中的最长重复子串。
 * 二分查找将求解最长重复子串长度的问题转化为一系列判定性问题，每个判定问题通过哈希技术高效解决。
 * <p>
 * 二分查找原理详解：
 * - 定义查找范围：左边界l=0，右边界r=n-1
 * - 每次取中间值m=(l+r)/2，检查是否存在长度为m的重复子串
 * - 如果存在（check(m)!=-1），说明可能还有更长的重复子串：更新起始位置并将l=m+1
 * - 如果不存在（check(m)==-1），说明当前长度太大，需要减小：将r=m-1
 * - 最终，r即为最长重复子串的长度，start为其中一个起始位置
 * <p>
 * 预处理阶段详解：
 * 1. 幂次数组计算：
 *    - pow[i]表示base的i次幂，用于子串哈希值的快速计算
 *    - 采用递推方式计算：pow[0]=1，pow[i]=pow[i-1]*base
 *    - 这样可以避免重复计算，确保O(1)时间访问
 * <p>
 * 2. 前缀哈希数组计算：
 *    - hash[i]表示字符串前i+1个字符（s[0...i]）的哈希值
 *    - 递推公式：hash[i] = hash[i-1] * base + (s[i] - 'a' + 1)
 *    - 字符映射加1是为了避免'0'值（当字符为'a'时，如果不加1会被映射为0）
 * <p>
 * 数学原理示例：
 * 对于字符串"abc"，base=499：
 * - pow数组：pow[0]=1, pow[1]=499, pow[2]=499²
 * - hash数组：
 *   - hash[0] = 'a'-'a'+1 = 1
 *   - hash[1] = 1*499 + ('b'-'a'+1) = 499 + 2 = 501
 *   - hash[2] = 501*499 + ('c'-'a'+1) = 501*499 + 3
 * 
 * @param str 输入字符串
 * @return 最长重复子串，如果不存在则返回空字符串
 * 
 * 时间复杂度：O(n log n)，其中n是字符串长度
 * - 预处理：O(n)
 * - 二分查找：O(log n)
 * - 每次check操作：O(n)
 * <p>
 * 空间复杂度：O(n)，用于存储哈希数组、幂次数组和字符数组
 */
public static String longestDupSubstring(String str) {
		// 初始化全局变量，避免在方法间传递参数
		n = str.length();
		s = str.toCharArray(); // 转换为字符数组，提高访问效率和性能

		// 预处理阶段1：预计算base的幂次数组
		// 这是多项式滚动哈希算法的关键组成部分，用于快速计算子串哈希
		pow[0] = 1; // 基础情况：base^0 = 1
		for (int i = 1; i < n; i++) {
			// 递推计算：pow[i] = pow[i-1] * base
			// 注意：在实际应用中，可能需要考虑溢出问题，可使用模数或BigInteger
			pow[i] = pow[i - 1] * base;
		}

		// 预处理阶段2：构建前缀哈希数组
		// 使用多项式滚动哈希算法，计算每个前缀的哈希值
		hash[0] = s[0] - 'a' + 1; // 第一个字符的哈希值，加1避免0值
		// 字符加1的目的是确保不同的空字符串不会产生相同的哈希值
		// 例如，字符'a'会被映射为1而非0
		for (int i = 1; i < n; i++) {
			// 哈希值递推公式：hash[i] = hash[i-1] * base + (s[i]的映射值)
			// 这个公式构建了一个多项式表示，确保子串哈希值可以通过前缀哈希计算得到
			hash[i] = hash[i - 1] * base + (s[i] - 'a' + 1);
		}

		// 二分查找阶段：寻找最长重复子串的长度
		// 这是算法的核心，通过二分查找将时间复杂度从O(n²)降低到O(n log n)
		int l = 0, r = n - 1; // 二分查找的左右边界
		int start = -1;       // 记录最长重复子串的起始位置

		// 二分查找主循环
		// 循环不变式：在每次迭代开始前，可能的最长重复子串长度在[l, r]范围内
		while (l <= r) {
			// 计算中间长度m，避免整数溢出的写法：m = l + (r - l) / 2
			// 但在本题中，由于n最大为30000，直接相加不会溢出
			int m = (l + r) / 2; 
			
			// 检查是否存在长度为m的重复子串
			// check方法返回第一个找到的重复子串的起始位置，如果不存在则返回-1
			int pos = check(m);

			if (pos != -1) {
				// 存在长度为m的重复子串
				// 根据单调性，可能存在更长的重复子串，因此尝试更大的长度
				start = pos;  // 更新起始位置记录
				l = m + 1;    // 左边界右移，搜索更长的可能长度
			} else {
				// 不存在长度为m的重复子串
				// 根据单调性，任何比m更长的子串也不可能重复，因此尝试更短的长度
				r = m - 1;    // 右边界左移，搜索更短的可能长度
			}
		}
		
		// 二分查找终止时的状态分析：
		// - l > r：搜索区间为空
		// - r是最大的长度，使得存在长度为r的重复子串
		// - start是找到的其中一个重复子串的起始位置
		// - 如果start == -1，表示没有找到任何重复子串

		// 结果构建：根据找到的最长长度和起始位置，返回对应的子串
		// 如果没有找到任何重复子串，返回空字符串
		if (start == -1) {
			return "";
		}

		// 构建并返回最长重复子串
		// 注意：循环结束后，r是最终确定的最长长度
		// substring方法参数：起始索引（包含）和结束索引（不包含）
		// 因此长度为r+1的子串范围是[start, start + r + 1)
		return str.substring(start, start + r + 1);
	}

	/**
 * 检查是否存在长度为len的重复子串
 * <p>
 * 这是二分查找中的关键判定方法，用于检查是否存在指定长度的重复子串。
 * 通过哈希+集合的方式，实现O(n)时间复杂度的高效检查。
 * <p>
 * 算法原理：
 * 1. 滑动窗口思想：遍历所有可能的长度为len的子串
 * 2. 哈希去重：利用多项式滚动哈希计算子串的哈希值
 * 3. 集合查询：使用HashSet快速判断哈希值是否已存在
 * <p>
 * 边界条件处理：
 * - 当len=0时，根据题目要求返回0（空字符串总是重复的）
 * - 当len>n时，不存在这样的子串，应返回-1
 * - 但在二分查找中，len的范围是[0, n-1]，因此第二个条件不会触发
 * <p>
 * 哈希冲突问题详解：
 * - 在理想情况下，不同的子串应产生不同的哈希值
 * - 但由于哈希函数是压缩映射，可能存在不同子串产生相同哈希值的情况（哈希冲突）
 * - 冲突概率与哈希基数、模数（本题未使用）和字符串特性有关
 * - 为提高正确性，可以采用以下策略：
 *   a. 双哈希：使用两个不同的哈希函数，只有两个哈希值都匹配时才认为重复
 *   b. 冲突验证：当哈希值相同时，进行实际字符串比较确认
 * <p>
 * 算法优化建议：
 * - 对于大字符串，可以考虑使用更大的哈希基数
 * - 添加模数以防止整数溢出
 * - 实现双哈希或冲突验证机制
 * 
 * @param len 要检查的子串长度
 * @return 如果存在重复子串，返回其中一个子串的起始位置；否则返回-1
 * 
 * 时间复杂度：O(n)，其中n是字符串长度
 * - 遍历所有可能的子串：O(n)
 * - 每个子串哈希计算：O(1)
 * - 集合操作（添加和查询）：平均O(1)
 * <p>
 * 空间复杂度：O(n)，用于存储哈希值集合，最坏情况需要存储O(n)个不同的哈希值
 */
public static int check(int len) {
		// 边界条件处理：长度为0的子串总是存在（空字符串）
		if (len == 0) {
			return 0;
		}

		// 使用HashSet存储已经出现过的子串哈希值
		// HashSet提供平均O(1)的插入和查询时间复杂度
		HashSet<Long> set = new HashSet<>();

		// 遍历所有可能的长度为len的子串
		// 起始位置i的取值范围：0 <= i <= n - len
		// 总共有(n - len + 1)个可能的子串
		for (int i = 0; i <= n - len; i++) {
			// 计算子串s[i...i+len-1]的哈希值
			// 利用预处理好的前缀哈希数组和幂次数组，实现O(1)时间计算
			long h = hash(i, i + len - 1);
			
			// 检查哈希值是否已经存在于集合中
			// 如果存在，说明找到了重复的子串
			// 注意：这里可能存在哈希冲突，导致误判
			if (set.contains(h)) {
				// 优化建议：在这里可以添加实际字符串比较来验证是否真的重复
				// 例如：if (set.contains(h) && equalsSubstring(i, lastPos, len))
				return i; // 返回当前找到的重复子串的起始位置
			}
			
			// 将当前哈希值加入集合，供后续子串检查使用
			set.add(h);
		}

		// 没有找到重复子串
		return -1;
	}

	/**
 * 计算子串s[l...r]的哈希值
 * <p>
 * 这是多项式滚动哈希算法的核心方法，利用预处理好的前缀哈希数组和幂次数组，
 * 实现O(1)时间内计算任意子串的哈希值，无需重新计算整个子串。
 * <p>
 * 数学原理详细推导：
 * 1. 前缀哈希定义：hash[r] = s[0]*base^r + s[1]*base^(r-1) + ... + s[r-1]*base + s[r]
 * 2. 我们需要计算子串s[l...r]的哈希值，即：
 *    hash(l,r) = s[l]*base^(r-l) + s[l+1]*base^(r-l-1) + ... + s[r]
 * 3. 注意到：hash[l-1] = s[0]*base^(l-1) + s[1]*base^(l-2) + ... + s[l-1]
 * 4. 将hash[l-1]乘以base^(r-l+1)：
 *    hash[l-1] * base^(r-l+1) = s[0]*base^r + s[1]*base^(r-1) + ... + s[l-1]*base^(r-l+1)
 * 5. 因此：hash[r] - hash[l-1] * base^(r-l+1) = s[l]*base^(r-l) + ... + s[r] = hash(l,r)
 * <p>
 * 数学示例计算：
 * 假设字符串为"abc"，base=10：
 * - hash[0] = 1
 * - hash[1] = 1*10 + 2 = 12
 * - hash[2] = 12*10 + 3 = 123
 * - 计算子串"bc"的哈希值 (l=1, r=2)：
 *   hash(1,2) = hash[2] - hash[0] * 10^(2-1+1) = 123 - 1*100 = 23
 *   而直接计算：2*10 + 3 = 23，验证了公式的正确性
 * <p>
 * 实现细节：
 * - 当l=0时，子串就是前缀s[0...r]，直接返回hash[r]
 * - 当l>0时，使用公式：ans = hash[r] - hash[l-1] * pow[r-l+1]
 * - pow[r-l+1]预先计算好，确保O(1)时间获取
 * <p>
 * 潜在问题：
 * - 整数溢出：在Java中，long类型可能会溢出
 * - 解决方案：在实际应用中，可以添加一个大质数模数（如10^9+7）
 * - 这样可以将哈希值限制在一定范围内，同时减少溢出风险
 * 
 * @param l 子串起始位置（包含，从0开始）
 * @param r 子串结束位置（包含，从0开始）
 * @return 子串的哈希值
 * 
 * 时间复杂度：O(1) 常量时间，只需几次简单的算术运算
 * 空间复杂度：O(1) 不使用额外空间
 */
public static long hash(int l, int r) {
		// 初始值为hash[r]（从0到r的前缀哈希值）
		long ans = hash[r];
		
		// 如果起始位置l大于0，需要从hash[r]中移除前l个字符的影响
		if (l > 0) {
			// 计算需要移除的部分：hash[l-1] * base^(r-l+1)
			// 这里的乘法操作将hash[l-1]调整到与hash[r]中对应部分相同的量级
			ans -= hash[l - 1] * pow[r - l + 1];
			
			// 注意：在使用模数的实现中，这里可能需要处理负数的情况
			// 例如：ans = (ans % mod + mod) % mod
		}
		return ans;
	}

	/**
	 * 哈希冲突概率的数学分析
	 * <p>
	 * 在多项式滚动哈希中，哈希冲突是不可避免的。冲突概率受以下因素影响：
	 * <ol>
	 * <li><b>基数选择(base)</b>：本实现选择499作为基数
	 * <li><b>模数(mod)</b>：本实现未使用模数，对于长字符串可能存在溢出风险
	 * <li><b>字符串长度</b>：较长的字符串增加哈希冲突的可能性
	 * <li><b>哈希值分布</b>：使用质数作为基数能更均匀地分布哈希值
	 * </ol>
	 * <p>
	 * 哈希冲突概率计算：
	 * 根据生日悖论，当有m个不同的子串和n个可能的哈希值时，冲突概率近似为：
	 * P ≈ 1 - e^(-m²/(2n))
	 * <p>
	 * 在本题中，由于使用long类型(64位)，哈希值空间约为2^64，
	 * 对于长度为30000的字符串，最多有约30000个长度为m的子串，
	 * 冲突概率极低，可以忽略不计。但在实际应用中，为了提高可靠性，
	 * 建议添加模数或使用双哈希技术。
	 */

	/**
	 * 双哈希实现示例
	 * <p>
	 * 为了进一步降低哈希冲突的可能性，可以采用双哈希技术，使用两组不同的base和mod组合：
	 * <pre><code>
	 * // 定义两组哈希参数
	 * public static int base1 = 499;  // 第一组基数
	 * public static int mod1 = 1000000007; // 第一组模数（大质数）
	 * public static int base2 = 503;  // 第二组基数
	 * public static int mod2 = 1000000009; // 第二组模数（另一个大质数）
	 * 
	 * // 预计算两组幂次数组
	 * public static long[] pow1 = new long[MAXN];
	 * public static long[] pow2 = new long[MAXN];
	 * 
	 * // 预计算两组前缀哈希数组
	 * public static long[] hash1 = new long[MAXN];
	 * public static long[] hash2 = new long[MAXN];
	 * 
	 * // 预处理方法
	 * public static void preprocess(char[] s) {
	 *     int n = s.length;
	 *     
	 *     // 预处理第一组幂次数组
	 *     pow1[0] = 1;
	 *     for (int i = 1; i < n; i++) {
	 *         pow1[i] = (pow1[i-1] * base1) % mod1;
	 *     }
	 *     
	 *     // 预处理第二组幂次数组
	 *     pow2[0] = 1;
	 *     for (int i = 1; i < n; i++) {
	 *         pow2[i] = (pow2[i-1] * base2) % mod2;
	 *     }
	 *     
	 *     // 计算第一组前缀哈希
	 *     hash1[0] = (s[0] - 'a' + 1) % mod1;
	 *     for (int i = 1; i < n; i++) {
	 *         hash1[i] = (hash1[i-1] * base1 + (s[i] - 'a' + 1)) % mod1;
	 *     }
	 *     
	 *     // 计算第二组前缀哈希
	 *     hash2[0] = (s[0] - 'a' + 1) % mod2;
	 *     for (int i = 1; i < n; i++) {
	 *         hash2[i] = (hash2[i-1] * base2 + (s[i] - 'a' + 1)) % mod2;
	 *     }
	 * }
	 * 
	 * // 双哈希计算方法
	 * public static long getHash1(int l, int r) {
	 *     long ans = hash1[r];
	 *     if (l > 0) {
	 *         ans = (ans - (hash1[l-1] * pow1[r-l+1]) % mod1 + mod1) % mod1;
	 *     }
	 *     return ans;
	 * }
	 * 
	 * public static long getHash2(int l, int r) {
	 *     long ans = hash2[r];
	 *     if (l > 0) {
	 *         ans = (ans - (hash2[l-1] * pow2[r-l+1]) % mod2 + mod2) % mod2;
	 *     }
	 *     return ans;
	 * }
	 * 
	 * // 修改check方法使用双哈希
	 * public static int check(int len) {
	 *     if (len == 0) {
	 *         return 0;
	 *     }
	 *     
	 *     // 使用HashSet存储哈希值对
	 *     HashSet<String> set = new HashSet<>();
	 *     
	 *     for (int i = 0; i <= n - len; i++) {
	 *         long h1 = getHash1(i, i + len - 1);
	 *         long h2 = getHash2(i, i + len - 1);
	 *         
	 *         // 将两个哈希值组合成一个字符串作为键
	 *         String key = h1 + "_" + h2;
	 *         
	 *         if (set.contains(key)) {
	 *             return i;
	 *         }
	 *         
	 *         set.add(key);
	 *     }
	 *     
	 *     return -1;
	 * }
	 * </code></pre>
	 * <p>
	 * 双哈希的优势在于，两个不同字符串同时在两组哈希中发生冲突的概率极低，
	 * 即使每组哈希的冲突概率为1e-9，双哈希的总冲突概率约为1e-18，
	 * 对于LeetCode这类算法竞赛问题来说，这已经足够安全。
	 */

	/**
	 * 推荐测试用例实现
	 * <p>
	 * 以下是针对本算法的推荐测试用例，覆盖不同的边界情况和关键场景：
	 * <pre><code>
	 * // 测试用例1：没有重复子串
	 * String s1 = "abcd";
	 * // 预期输出：""
	 * 
	 * // 测试用例2：完全重复的字符串
	 * String s2 = "aaaaa";
	 * // 预期输出："aaaa"（或任何长度为4的子串）
	 * 
	 * // 测试用例3：有多个重复子串，取最长的
	 * String s3 = "banana";
	 * // 预期输出："ana"（长度为3）
	 * 
	 * // 测试用例4：重复子串在开头和结尾
	 * String s4 = "abcabc";
	 * // 预期输出："abc"（长度为3）
	 * 
	 * // 测试用例5：单个字符重复
	 * String s5 = "abca";
	 * // 预期输出："a"（长度为1）
	 * 
	 * // 测试用例6：空字符串边界情况
	 * String s6 = "";
	 * // 预期输出：""
	 * 
	 * // 测试用例7：最大约束情况
	 * // 构造一个长度接近30000的字符串，其中包含一个长重复子串
	 * // 测试算法在大输入下的性能和正确性
	 * 
	 * // 测试用例8：哈希冲突测试
	 * // 构造一个可能触发哈希冲突的字符串（在当前实现中可能很难构造）
	 * </code></pre>
	 * <p>
	 * 测试用例设计原则：
	 * 1. 边界情况测试：空字符串、无重复子串、完全重复
	 * 2. 功能测试：多个重复子串、不同位置的重复
	 * 3. 性能测试：最大输入规模下的算法表现
	 * 4. 正确性测试：已知答案的标准测试用例
	 * <p>
	 * 测试方法建议：
	 * - 使用JUnit或其他测试框架编写单元测试
	 * - 对比其他算法（如后缀数组）的结果
	 * - 对每组测试用例记录算法运行时间，监控性能
	 * - 编写特定测试用例验证哈希冲突处理
	 */

	/**
	 * 字符串哈希算法比较分析
	 * <p>
	 * 本题实现了基于二分查找和多项式滚动哈希的最长重复子串查找，下面将其与其他常用方法进行比较：
	 * <table border="1">
	 * <tr>
	 *   <th>算法方法</th>
	 *   <th>优点</th>
	 *   <th>缺点</th>
	 *   <th>时间复杂度</th>
	 *   <th>空间复杂度</th>
	 * </tr>
	 * <tr>
	 *   <td><b>二分查找+哈希</b></td>
	 *   <td>
	 *     - 实现相对简单<br>
	 *     - 时间复杂度较好<br>
	 *     - 空间效率高<br>
	 *     - 适合中等规模数据
	 *   </td>
	 *   <td>
	 *     - 可能存在哈希冲突<br>
	 *     - 对于大字符串可能溢出<br>
	 *     - 需要额外措施确保正确性
	 *   </td>
	 *   <td>O(n log n)</td>
	 *   <td>O(n)</td>
	 * </tr>
	 * <tr>
	 *   <td><b>后缀数组+LCP</b></td>
	 *   <td>
	 *     - 理论时间复杂度低<br>
	 *     - 无哈希冲突问题<br>
	 *     - 可以处理任何规模数据<br>
	 *     - 可用于多种字符串问题
	 *   </td>
	 *   <td>
	 *     - 实现复杂<br>
	 *     - 理解难度大<br>
	 *     - 构建过程较繁琐<br>
	 *     - 对常数敏感
	 *   </td>
	 *   <td>O(n)或O(n log n)</td>
	 *   <td>O(n)</td>
	 * </tr>
	 * <tr>
	 *   <td><b>暴力法</b></td>
	 *   <td>
	 *     - 实现极其简单<br>
	 *     - 无哈希冲突问题<br>
	 *     - 逻辑直观<br>
	 *     - 无需额外空间
	 *   </td>
	 *   <td>
	 *     - 时间复杂度高<br>
	 *     - 仅适合小数据集<br>
	 *     - 效率低下<br>
	 *     - 无法通过大测试用例
	 *   </td>
	 *   <td>O(n³)</td>
	 *   <td>O(1)</td>
	 * </tr>
	 * <tr>
	 *   <td><b>Suffix Tree</b></td>
	 *   <td>
	 *     - 可以在线性时间内解决<br>
	 *     - 支持多种字符串查询<br>
	 *     - 空间效率较高<br>
	 *     - 结构优雅
	 *   </td>
	 *   <td>
	 *     - 实现极其复杂<br>
	 *     - 需要后缀链接等高级概念<br>
	 *     - 构建难度大<br>
	 *     - 实际应用中较少使用
	 *   </td>
	 *   <td>O(n)</td>
	 *   <td>O(n)</td>
	 * </tr>
	 * <tr>
	 *   <td><b>Rabin-Karp+二分</b></td>
	 *   <td>
	 *     - 思路清晰<br>
	 *     - 实现相对简单<br>
	 *     - 与当前实现类似<br>
	 *     - 适合竞赛环境
	 *   </td>
	 *   <td>
	 *     - 同样存在哈希冲突<br>
	 *     - 最坏情况性能较差<br>
	 *     - 需要处理冲突验证<br>
	 *     - 时间复杂度依赖哈希质量
	 *   </td>
	 *   <td>平均O(n log n)</td>
	 *   <td>O(n)</td>
	 * </tr>
	 * </table>
	 * <p>
	 * 本题选择二分查找+哈希的理由：
	 * 1. 时间复杂度适中（O(n log n)），可以处理LeetCode规模的数据
	 * 2. 实现相对简单，代码量少，便于调试和优化
	 * 3. 空间复杂度为O(n)，内存效率较高
	 * 4. 在实际应用中，通过适当的参数选择可以将哈希冲突概率降到极低
	 * <p>
	 * 算法优化建议：
	 * 1. 对于生产环境，建议采用双哈希技术确保正确性
	 * 2. 添加大质数模数防止整数溢出
	 * 3. 对于哈希值相同的情况，添加实际字符串比较进行验证
	 * 4. 考虑使用Rabin-Karp算法优化滑动窗口中的哈希计算
	 * 5. 对于超大字符串，可以考虑使用后缀数组实现
	 */
}