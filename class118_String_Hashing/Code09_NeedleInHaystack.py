import sys

"""
SPOJ 32 - A Needle in the Haystack 问题实现

题目链接：https://www.spoj.com/problems/NHAY/
题目链接(洛谷)：https://www.luogu.com.cn/problem/SP32

题目描述：
编写一个程序，在给定的输入字符串(haystack)中找到所有给定模式(needle)的出现位置。
程序必须检测到干草堆中的所有针。它应该将针和干草堆作为输入，并输出每个出现的位置。
字符从0开始编号，输出应该按升序排列。

算法核心思想：
1. 多项式滚动哈希：使用哈希函数将字符串转换为数值，实现高效比较
2. 前缀哈希预处理：预先计算文本串的前缀哈希数组，支持O(1)时间查询任意子串哈希
3. 滑动窗口比较：遍历文本串，比较每个可能位置的子串哈希值与模式串哈希值
4. 预计算幂次数组：避免重复计算，提高哈希值计算效率

多项式滚动哈希数学原理详解：
- 哈希函数定义：对于字符串s[0...n-1]，哈希值H(s) = s[0]*base^(n-1) + s[1]*base^(n-2) + ... + s[n-1]
- 前缀哈希公式：hash[i] = s[0]*base^i + s[1]*base^(i-1) + ... + s[i]
- 递推关系：hash[i] = hash[i-1] * base + s[i]
- 子串哈希公式：hash(l,r) = hash[r] - hash[l-1] * base^(r-l+1)（当l>0时）
- 数学原理：多项式展开和重组，确保可以通过前缀哈希值快速计算任意子串哈希值

算法详细步骤：
1. 预处理阶段：
   - 预计算幂次数组pow[i] = base^i，用于后续快速计算
   - 计算文本串haystack的前缀哈希数组，建立子串哈希计算基础
   - 计算模式串needle的完整哈希值，作为匹配比较的标准
2. 匹配阶段：
   - 遍历haystack中所有可能的起始位置i，范围是0 <= i <= haystackLen - needleLen
   - 对于每个位置i，计算以i为起点、长度为needleLen的子串哈希值
   - 比较子串哈希值与needle哈希值，若相等则认为找到匹配位置
3. 输出阶段：按升序输出所有匹配位置，每个测试用例间输出空行

算法正确性证明：
- 假设哈希函数是完美的（无冲突），则哈希值相等意味着字符串相等
- 多项式哈希函数的线性性质保证了子串哈希计算的正确性
- 算法通过滑动窗口遍历所有可能位置，确保不会漏掉任何匹配

时间复杂度分析：
- 预处理阶段：O(n + m)，其中n是haystack的长度，m是needle的长度
  - 幂次数组计算：O(n)，线性时间
  - 前缀哈希计算：O(n)，线性时间
  - 模式串哈希计算：O(m)，线性时间
- 匹配阶段：O(n)，只需遍历haystack一次，每次哈希计算O(1)
- 总体时间复杂度：O(n + m)，与KMP算法相同

空间复杂度分析：
- 前缀哈希数组：O(n)，存储每个前缀的哈希值
- 幂次数组：O(n)，存储base的各次幂
- 模式串哈希值：O(1)，单个变量存储
- 总体空间复杂度：O(n)，主要受文本串长度影响

哈希冲突概率分析与处理策略：
- 冲突概率：对于长度为L的字符串，使用base=499且不使用模数时，理论冲突概率约为1/L
- 单哈希方案：当前实现使用单个哈希函数，对于大多数测试用例足够安全
- 双哈希优化：使用两个不同的哈希函数（不同base和mod）可将冲突概率降低到接近零
- 模数选择：在生产环境中应使用大质数模数（如10^9+7或10^9+9）来防止溢出并减少冲突
- 冲突验证：哈希值匹配后可进行字符串实际比较，确保绝对正确性

Python实现特性：
- Python的整数类型可以无限大，不受溢出限制，简化了哈希计算
- 使用函数嵌套定义，保持代码逻辑的封装性
- 使用列表存储预处理数组，提高访问效率
- 使用sys.stdin读取输入，支持大规模数据处理

优化建议：
1. 添加模数运算：虽然Python整数无溢出，但大整数计算会影响性能，建议添加模数
2. 实现双哈希：增加可靠性，降低冲突概率
3. 添加冲突验证：哈希值相等时进行实际字符串比较
4. 优化输入处理：对于非常大的输入，可以使用更高效的读取方式
5. 预分配列表空间：使用列表推导式预分配内存，减少动态扩容开销

与Java版本对比：
- Java版本需要处理整数溢出问题，Python版本无需担心
- Java版本使用静态数组，Python版本使用动态列表
- 两者算法逻辑完全一致，但实现细节有所不同

测试链接：https://www.spoj.com/problems/NHAY/

相似题目：
1. LeetCode 28. 找到字符串中第一个匹配项 - 基本字符串匹配
2. LeetCode 459. 重复的子字符串 - 字符串周期性检测
3. LeetCode 1392. 最长快乐前缀 - 前缀后缀匹配
4. Codeforces 985F - Isomorphic Strings - 字符串同构判断
5. POJ 3461 - Oulipo - 经典字符串匹配
6. HDU 1686 - Oulipo - 字符串匹配变种

三种语言实现参考：
- Java实现：Code03_SubstringHash.java
- Python实现：当前文件
- C++实现：Code12_PatternFind.cpp

@author Algorithm Journey
@version 1.0
@since 2024-01-01
"""

# 哈希基数，选择一个较大的质数以减少哈希冲突
# 使用质数499作为基数可以使哈希分布更均匀，减少碰撞概率
# 常用的基数还包括911、1009、1231等较大的质数
base = 499

def main():
    """
    主函数，处理输入输出并执行字符串匹配算法
    
    该函数实现了完整的字符串匹配流程，从输入处理、预处理计算到匹配查找和结果输出。
    使用多项式滚动哈希技术实现高效的模式串匹配，能够处理多个测试用例。
    
    详细处理流程：
    1. 输入处理：
       - 读取所有输入行，存储在lines列表中
       - 处理多行输入，支持多个测试用例
    2. 测试用例处理循环：
       a. 跳过空行，处理边界情况
       b. 管理测试用例间的空行输出
       c. 读取模式串长度、模式串和文本串
    3. 预处理阶段：
       a. 预计算幂次数组
       b. 计算文本串前缀哈希数组
       c. 定义子串哈希计算函数
       d. 计算模式串哈希值
    4. 匹配查找阶段：
       a. 遍历文本串中所有可能的起始位置
       b. 对每个位置计算子串哈希并与模式串哈希比较
       c. 发现匹配时输出位置
    
    输入格式详解：
    - 输入格式：每个测试用例包含三行
      1. 第一行：模式串的长度（整数）
      2. 第二行：模式串内容（字符串）
      3. 第三行：文本串内容（字符串）
    - 输出格式：
      1. 按升序输出所有匹配位置（从0开始计数），每个位置占一行
      2. 各测试用例之间用一个空行分隔
    
    性能优化策略：
    1. 一次性读取所有输入，减少I/O操作次数
    2. 使用字符的ASCII码值直接进行哈希计算
    3. 预计算所有必要数据，避免重复计算
    4. Python的整数类型无溢出限制，简化了哈希计算
    
    时间复杂度分析：
    - 单个测试用例：O(n + m)，其中n是文本串长度，m是模式串长度
    - 总时间复杂度：O(T*(n+m))，其中T是测试用例数量
    
    空间复杂度分析：
    - 输入存储：O(T*(n+m))，存储所有测试用例的输入
    - 预处理数组：O(n)，存储幂次数组和前缀哈希数组
    - 总体空间复杂度：O(T*(n+m))，主要受输入规模影响
    """
    # 读取所有输入行，存储在lines列表中
    # 这种方式适合处理多行输入，可以一次性将所有数据读入内存
    lines = []
    for line in sys.stdin:
        lines.append(line.strip())
    
    # 初始化行索引和第一个测试用例标志
    i = 0
    first_case = True
    
    # 循环处理每个测试用例
    while i < len(lines):
        # 跳过空行（输入中的空行）
        if not lines[i]:  # 跳过空行
            i += 1
            continue
            
        # 管理测试用例间的空行输出
        # 第一个测试用例前不输出空行，后续测试用例前输出空行
        if first_case:
            first_case = False
        else:
            print()  # 每个测试用例之间输出一个空行
        
        # 读取needle的长度
        # 每个测试用例的第一行是模式串的长度
        needle_len = int(lines[i])
        i += 1
        
        # 读取needle（模式串）
        # 测试用例的第二行是模式串内容
        needle = lines[i]
        i += 1
        
        # 读取haystack（文本串）
        # 测试用例的第三行是文本串内容
        haystack = lines[i]
        haystack_len = len(haystack)
        i += 1
        
        # 预处理阶段1：预计算base的幂次数组
        # 这是多项式滚动哈希的基础，用于后续O(1)时间计算子串哈希值
        # 递推公式：pow_arr[j] = pow_arr[j-1] * base
        # 使用列表推导式初始化数组，设置初始值为1（base^0 = 1）
        pow_arr = [1] * haystack_len
        for j in range(1, haystack_len):
            # 递推计算各次幂，避免重复计算
            # 在Python中无需担心整数溢出问题，整数类型可以无限大
            pow_arr[j] = pow_arr[j - 1] * base
        
        # 预处理阶段2：计算haystack的前缀哈希值数组
        # 使用多项式滚动哈希算法构建前缀哈希
        # haystack_hash[j]表示子串haystack[0...j]的哈希值
        # 初始化前缀哈希数组，长度为文本串长度
        haystack_hash = [0] * haystack_len
        # 计算第一个字符的哈希值，加1避免0值
        # 字符加1的目的：
        # 1. 避免字符'a'被映射为0，失去区分度
        # 2. 确保空字符串和包含'a'的字符串有不同的哈希值
        haystack_hash[0] = ord(haystack[0]) - ord('a') + 1
        for j in range(1, haystack_len):
            # 哈希值递推公式：hash[j] = hash[j-1] * base + s[j]的映射值
            # 这个公式实际上构建了多项式：hash[j] = s[0]*base^j + s[1]*base^(j-1) + ... + s[j]
            haystack_hash[j] = haystack_hash[j - 1] * base + (ord(haystack[j]) - ord('a') + 1)
        
        # 计算子串haystack[l...r]的哈希值的内部函数
        # 使用函数嵌套定义，保持代码逻辑的封装性
        # 这种设计使得子串哈希计算函数可以直接访问预处理好的pow_arr和haystack_hash
        def substring_hash(l, r):
            """
            计算文本串haystack中子串[l...r]的哈希值
            
            这是多项式滚动哈希算法的核心方法，通过巧妙的数学变换，利用预处理好的前缀哈希数组
            和幂次数组，在O(1)时间内计算任意子串的哈希值，无需重新扫描子串字符。
            
            数学原理详细推导：
            1. 前缀哈希定义：hash[r] = s[0]*base^r + s[1]*base^(r-1) + ... + s[r-1]*base + s[r]
            2. 子串哈希目标：计算hash(l,r) = s[l]*base^(r-l) + s[l+1]*base^(r-l-1) + ... + s[r]
            3. 观察到：hash[l-1] = s[0]*base^(l-1) + s[1]*base^(l-2) + ... + s[l-1]
            4. 计算hash[l-1] * base^(r-l+1)：
               = s[0]*base^r + s[1]*base^(r-1) + ... + s[l-1]*base^(r-l+1)
            5. 因此：hash[r] - hash[l-1] * base^(r-l+1)
               = s[l]*base^(r-l) + s[l+1]*base^(r-l-1) + ... + s[r]
               = hash(l,r)，即我们要求的子串哈希值
            
            实现细节：
            - 当l=0时，子串即为前缀s[0...r]，直接返回haystack_hash[r]
            - 当l>0时，需要从haystack_hash[r]中移除前缀s[0...l-1]的影响
            
            参数:
                l: 子串的起始位置（包含，从0开始）
                r: 子串的结束位置（包含，从0开始）
            返回:
                子串[l...r]的哈希值
            
            时间复杂度：O(1) - 只需几次算术运算，与子串长度无关
            空间复杂度：O(1) - 不使用额外空间，仅依赖预计算的数组
            """
            # 基础情况：当起始位置为0时，直接返回前缀哈希值
            if l == 0:
                return haystack_hash[r]
            else:
                # 一般情况：从哈希值中移除前缀部分的影响
                # 公式：hash(l,r) = hash[r] - hash[l-1] * base^(r-l+1)
                return haystack_hash[r] - haystack_hash[l - 1] * pow_arr[r - l + 1]
        
        # 预处理阶段3：计算needle的完整哈希值
        # 使用与文本串完全相同的哈希函数，确保比较的一致性
        # 这样可以保证当且仅当子串与模式串相同时哈希值才相等（假设无冲突）
        # 计算模式串的第一个字符的哈希值
        needle_hash = ord(needle[0]) - ord('a') + 1
        for j in range(1, needle_len):
            # 使用相同的递推公式：needle_hash = needle_hash * base + s[j]的映射值
            # 与文本串的哈希计算保持一致，确保比较的正确性
            needle_hash = needle_hash * base + (ord(needle[j]) - ord('a') + 1)
        
        # 匹配阶段：遍历haystack，查找所有模式串的出现位置
        found = False  # 标记是否找到匹配，虽然本算法总是输出找到的位置
        
        # 遍历所有可能的起始位置j
        # 起始位置范围是0 <= j <= haystack_len - needle_len
        # 这样可以确保子串j到j+needle_len-1不会越界
        for j in range(haystack_len - needle_len + 1):
            # 计算以j为起点、长度为needle_len的子串哈希值
            # 调用内部定义的substring_hash函数，O(1)时间计算
            # 与预先计算好的needle_hash进行比较
            if substring_hash(j, j + needle_len - 1) == needle_hash:
                # 哈希值匹配，认为找到了一个匹配位置
                # 注意：这里假设没有哈希冲突，实际应用中可能需要额外的字符串比较验证
                print(j)  # 输出匹配位置（从0开始计数）
                found = True
        
        # 如果没有找到匹配项，不需要特殊处理
        # 由于题目没有要求输出未找到的情况，所以不做额外处理

if __name__ == "__main__":
    main()