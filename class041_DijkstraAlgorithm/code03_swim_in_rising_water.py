#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""
水位上升的泳池中游泳

题目链接：https://leetcode.cn/problems/swim-in-rising-water/

题目描述：
在一个 n x n 的整数矩阵 grid 中，
每一个方格的值 grid[i][j] 表示位置 (i, j) 的平台高度。
当开始下雨时，在时间为 t 时，水池中的水位为 t。
你可以从一个平台游向四周相邻的任意一个平台，但是前提是此时水位必须同时淹没这两个平台。
假定你可以瞬间移动无限距离，也就是默认在方格内部游动是不耗时的。
当然，在你游泳的时候你必须待在坐标方格里面。
你从坐标方格的左上平台 (0，0) 出发。
返回 你到达坐标方格的右下平台 (n-1, n-1) 所需的最少时间。

解题思路：
这是一个变形的最短路径问题，可以使用Dijkstra算法解决。
与传统最短路径不同的是，这里的"距离"定义为路径上所有平台高度的最大值。
因为要从一个平台游到另一个平台，水位必须同时淹没两个平台，
所以所需的时间是两个平台高度的最大值。
我们将每个平台看作图中的一个节点，相邻平台之间有边连接，
边的权重是两个平台高度的最大值。
使用Dijkstra算法找到从起点到终点的最少时间路径。

算法应用场景：
- 水位调度问题
- 网络传输中的最大延迟路径
- 游戏中的角色移动路径优化

时间复杂度分析：
O(n^2*log(n^2)) = O(n^2*logn)，其中n是矩阵的边长

空间复杂度分析：
O(n^2) 存储距离数组和访问标记数组
"""

import heapq

def swimInWater(grid):
    """
    使用Dijkstra算法求解最少时间
    
    算法核心思想：
    1. 将问题转化为图论中的最短路径问题
    2. 每个平台是一个节点，相邻平台之间有边连接
    3. 边的权重定义为两个平台高度的最大值（因为水位必须同时淹没两个平台）
    4. 路径的时间定义为路径上所有边权重的最大值
    5. 使用Dijkstra算法找到从起点到终点的最少时间路径
    
    算法步骤：
    1. 初始化距离数组，起点距离为其高度，其他点为无穷大
    2. 使用优先队列维护待处理节点，按时间从小到大排序
    3. 不断取出时间最小的节点，更新其邻居节点的最少时间
    4. 当处理到终点时，直接返回结果（剪枝优化）
    
    时间复杂度：O(n^2*log(n^2)) = O(n^2*logn)
    空间复杂度：O(n^2)
    
    Args:
        grid: List[List[int]] - n x n 的整数矩阵，grid[i][j]表示位置(i,j)的平台高度
    
    Returns:
        int - 从左上平台到右下平台所需的最少时间
    """
    n = len(grid)      # 矩阵行数
    m = len(grid[0])   # 矩阵列数
    
    # distance[i][j]表示从起点(0,0)到达点(i,j)的最少时间
    # 初始化为最大值，表示尚未访问
    distance = [[float('inf')] * m for _ in range(n)]
    # 起点时间为该点的高度
    # 因为从(0,0)出发，所以最少时间至少是该点的高度
    distance[0][0] = grid[0][0]
    
    # visited[i][j]表示点(i,j)是否已经确定了最短路径
    # 用于避免重复处理已经确定最短路径的节点
    visited = [[False] * m for _ in range(n)]
    
    # 方向数组：上、右、下、左
    move = [(-1, 0), (0, 1), (1, 0), (0, -1)]
    
    # 优先队列，按时间从小到大排序
    # 元组含义：(时间, 行, 列)
    heap = [(grid[0][0], 0, 0)]
    
    # Dijkstra算法主循环
    while heap:
        # 取出时间最小的节点
        c, x, y = heapq.heappop(heap)
        
        # 如果已经处理过，跳过
        # 这是为了避免同一节点多次处理导致的重复计算
        if visited[x][y]:
            continue
        
        # 标记为已处理，表示已确定从起点到该点的最少时间
        visited[x][y] = True
        
        # 如果到达终点，直接返回结果
        # 常见剪枝优化：发现终点直接返回，不用等都结束
        # 这是因为Dijkstra算法的特性保证了第一次到达终点时就是最优解
        if x == n - 1 and y == m - 1:
            return c
        
        # 向四个方向扩展（上、右、下、左）
        for dx, dy in move:
            # 计算新位置的坐标
            nx, ny = x + dx, y + dy
            
            # 检查边界条件和是否已访问
            # 1. 新位置不能超出矩阵边界
            # 2. 新位置不能是已经处理过的节点
            if 0 <= nx < n and 0 <= ny < m and not visited[nx][ny]:
                # 计算到达新点的时间
                # 需要同时淹没两个平台，所以时间为两个平台高度的最大值
                # 这是因为水位必须同时淹没当前位置和新位置才能游过去
                nc = max(c, grid[nx][ny])
                
                # 如果新的时间更小，则更新
                # 松弛操作：如果 nc < distance[nx][ny]，则更新distance[nx][ny]
                if nc < distance[nx][ny]:
                    distance[nx][ny] = nc
                    # 将更新后的节点加入优先队列
                    heapq.heappush(heap, (nc, nx, ny))
    
    # 理论上不会执行到这里，因为从左上角到右下角总是存在路径
    return -1


# 测试用例
if __name__ == "__main__":
    # 测试用例1
    # 输入：grid = [[0,2],[1,3]]
    # 输出：3
    grid1 = [[0,2],[1,3]]
    result1 = swimInWater(grid1)
    print(f"测试用例1结果: {result1}")  # 期望输出: 3
    
    # 测试用例2
    # 输入：grid = [[0,1,2,3,4],[24,23,22,21,5],[12,13,14,15,16],[11,17,18,19,20],[10,9,8,7,6]]
    # 输出：16
    grid2 = [[0,1,2,3,4],[24,23,22,21,5],[12,13,14,15,16],[11,17,18,19,20],[10,9,8,7,6]]
    result2 = swimInWater(grid2)
    print(f"测试用例2结果: {result2}")  # 期望输出: 16