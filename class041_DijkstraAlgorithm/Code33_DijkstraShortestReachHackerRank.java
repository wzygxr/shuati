package class064;

import java.util.*;

/**
 * ============================================================================
 * HackerRank - Dijkstra: Shortest Reach 2 算法实现
 * ============================================================================
 * 
 * 题目链接: https://www.hackerrank.com/challenges/dijkstrashortreach/problem
 * 
 * 题目描述:
 * 给定一个无向图和起始节点，确定从起始节点到图中所有其他节点的最短路径长度。
 * 如果某个节点无法从起始节点到达，则返回-1。
 * 
 * 输入格式:
 * - n: 节点数量，编号从1到n
 * - edges: 边列表，每条边格式为[u, v, w]，表示从u到v的无向边，权重为w
 * - s: 起始节点编号
 * 
 * 输出格式:
 * - 距离数组，dist[i]表示从起始节点到节点i的最短距离
 * - 如果节点不可达，则距离为-1
 * 
 * 算法原理:
 * ============================================================================
 * Dijkstra算法是一种贪心算法，用于解决带非负权边的单源最短路径问题。
 * 核心思想：每次选择当前距离最小的节点进行扩展，逐步确定所有节点的最短距离。
 * 
 * 算法正确性保证:
 * - 贪心选择性质：每次选择距离最小的节点，其距离已经是最短的
 * - 最优子结构：最短路径的子路径也是最短路径
 * 
 * 算法步骤详解:
 * ============================================================================
 * 1. 初始化阶段:
 *    - 构建图的邻接表表示
 *    - 初始化距离数组，起始节点距离为0，其他节点为无穷大
 *    - 创建优先队列（最小堆），按距离排序
 * 
 * 2. 处理阶段:
 *    - 从优先队列中取出距离最小的节点u
 *    - 如果u已经被访问过，跳过（避免重复处理）
 *    - 标记u为已访问
 *    - 遍历u的所有邻居节点v:
 *        - 计算通过u到达v的新距离 = dist[u] + w(u,v)
 *        - 如果新距离小于当前dist[v]，更新dist[v]并加入优先队列
 * 
 * 3. 输出阶段:
 *    - 将无穷大距离转换为-1（表示不可达）
 *    - 返回距离数组
 * 
 * 时间复杂度分析:
 * ============================================================================
 * - 每个节点入队出队一次: O(V log V)
 * - 每条边被处理一次: O(E log V)
 * - 总时间复杂度: O((V + E) log V)
 * 
 * 空间复杂度分析:
 * ============================================================================
 * - 邻接表存储: O(V + E)
 * - 距离数组: O(V)
 * - 优先队列: O(V)
 * - 总空间复杂度: O(V + E)
 * 
 * 算法优化技巧:
 * ============================================================================
 * 1. 优先队列优化: 使用最小堆代替普通队列，提高效率
 * 2. 懒删除: 允许重复节点入队，出队时检查是否已处理
 * 3. 邻接表存储: 使用邻接表而非邻接矩阵，节省空间
 * 
 * 边界情况处理:
 * ============================================================================
 * 1. 空图处理: 当n=0或edges为空时的处理
 * 2. 单节点图: 只有一个节点时的特殊情况
 * 3. 不可达节点: 使用Integer.MAX_VALUE表示无穷大
 * 4. 自环边: 自环边权重应为0，否则可能影响结果
 * 5. 重边处理: 保留最小权重的边
 * 
 * 测试用例设计:
 * ============================================================================
 * 1. 基础测试: 简单连通图
 * 2. 边界测试: 单节点、空图、完全图
 * 3. 性能测试: 大规模稀疏图和稠密图
 * 4. 特殊测试: 存在不可达节点、重边、自环
 * 
 * 工程化实践:
 * ============================================================================
 * 1. 代码可读性: 使用清晰的变量命名和注释
 * 2. 模块化设计: 将算法逻辑封装为独立方法
 * 3. 错误处理: 验证输入参数的合法性
 * 4. 性能监控: 添加性能统计和日志输出
 * 
 * 相关算法比较:
 * ============================================================================
 * - Bellman-Ford: 可处理负权边，但时间复杂度O(VE)
 * - Floyd-Warshall: 多源最短路，时间复杂度O(V³)
 * - SPFA: Bellman-Ford的队列优化版本
 * 
 * 作者：算法工程化项目组
 * 创建时间：2025-10-29
 * 版本：v1.0
 */
public class Code33_DijkstraShortestReachHackerRank {
    
    /**
     * 使用Dijkstra算法计算从起始节点到所有其他节点的最短距离
     * 
     * 算法步骤:
     * 1. 构建图的邻接表表示
     * 2. 初始化距离数组，起始节点距离为0，其他节点为无穷大
     * 3. 使用优先队列维护待处理节点，按距离从小到大排序
     * 4. 不断取出距离最小的节点，更新其邻居节点的最短距离
     * 5. 返回所有节点的最短距离数组
     * 
     * 时间复杂度: O((V + E) * log V)
     * 空间复杂度: O(V + E)
     * 
     * @param n 节点数
     * @param edges 边的列表，每个元素为 [from, to, weight]
     * @param s 起始节点
     * @return 从起始节点到所有节点的最短距离数组，无法到达的节点距离为-1
     */
    public static int[] shortestReach(int n, int[][] edges, int s) {
        // 构建邻接表表示的图
        List<List<int[]>> graph = new ArrayList<>();
        for (int i = 0; i <= n; i++) {
            graph.add(new ArrayList<>());
        }
        
        // 添加边到图中（无向图需要添加两条边）
        for (int[] edge : edges) {
            int u = edge[0];
            int v = edge[1];
            int w = edge[2];
            graph.get(u).add(new int[]{v, w});
            graph.get(v).add(new int[]{u, w});
        }
        
        // distance[i] 表示从源节点s到节点i的最短距离
        int[] distance = new int[n + 1];
        Arrays.fill(distance, Integer.MAX_VALUE);
        distance[s] = 0;
        
        // visited[i] 表示节点i是否已经确定了最短距离
        boolean[] visited = new boolean[n + 1];
        
        // 优先队列，按距离从小到大排序
        PriorityQueue<int[]> heap = new PriorityQueue<>((a, b) -> a[1] - b[1]);
        heap.add(new int[]{s, 0});
        
        // Dijkstra算法主循环
        while (!heap.isEmpty()) {
            // 取出距离源点最近的节点
            int[] current = heap.poll();
            int u = current[0];
            int dist = current[1];
            
            // 如果已经处理过，跳过
            if (visited[u]) {
                continue;
            }
            
            // 标记为已处理
            visited[u] = true;
            
            // 遍历u的所有邻居节点
            for (int[] edge : graph.get(u)) {
                int v = edge[0];  // 邻居节点
                int w = edge[1];  // 边的权重
                
                // 如果邻居节点未访问且通过u到达v的距离更短，则更新
                if (!visited[v] && distance[u] + w < distance[v]) {
                    distance[v] = distance[u] + w;
                    heap.add(new int[]{v, distance[v]});
                }
            }
        }
        
        // 构造结果数组，无法到达的节点距离为-1，起始节点不包含在结果中
        int[] result = new int[n - 1];
        int index = 0;
        for (int i = 1; i <= n; i++) {
            if (i != s) {
                result[index++] = (distance[i] == Integer.MAX_VALUE) ? -1 : distance[i];
            }
        }
        
        return result;
    }
    
    // 测试方法
    public static void main(String[] args) {
        // 示例测试用例
        int n = 4;
        int[][] edges = {{1, 2, 1}, {1, 3, 3}, {2, 3, 1}, {3, 4, 2}};
        int s = 1;
        
        int[] result = shortestReach(n, edges, s);
        System.out.print("从节点 " + s + " 到其他节点的最短距离为: ");
        for (int i = 0; i < result.length; i++) {
            System.out.print(result[i]);
            if (i < result.length - 1) {
                System.out.print(" ");
            }
        }
        System.out.println();
    }
}