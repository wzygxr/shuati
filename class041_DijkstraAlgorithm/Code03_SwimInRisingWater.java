package class064;

import java.util.PriorityQueue;

/**
 * 水位上升的泳池中游泳
 * 
 * 题目链接：https://leetcode.cn/problems/swim-in-rising-water/
 * 
 * 题目描述：
 * 在一个 n x n 的整数矩阵 grid 中，
 * 每一个方格的值 grid[i][j] 表示位置 (i, j) 的平台高度。
 * 当开始下雨时，在时间为 t 时，水池中的水位为 t。
 * 你可以从一个平台游向四周相邻的任意一个平台，但是前提是此时水位必须同时淹没这两个平台。
 * 假定你可以瞬间移动无限距离，也就是默认在方格内部游动是不耗时的。
 * 当然，在你游泳的时候你必须待在坐标方格里面。
 * 你从坐标方格的左上平台 (0，0) 出发。
 * 返回 你到达坐标方格的右下平台 (n-1, n-1) 所需的最少时间。
 * 
 * 解题思路：
 * 这是一个变形的最短路径问题，可以使用Dijkstra算法解决。
 * 与传统最短路径不同的是，这里的"距离"定义为路径上所有平台高度的最大值。
 * 因为要从一个平台游到另一个平台，水位必须同时淹没两个平台，
 * 所以所需的时间是两个平台高度的最大值。
 * 我们将每个平台看作图中的一个节点，相邻平台之间有边连接，
 * 边的权重是两个平台高度的最大值。
 * 使用Dijkstra算法找到从起点到终点的最少时间路径。
 * 
 * 算法应用场景：
 * - 水位调度问题
 * - 网络传输中的最大延迟路径
 * - 游戏中的角色移动路径优化
 * 
 * 时间复杂度分析：
 * O(n^2*log(n^2)) = O(n^2*logn)，其中n是矩阵的边长
 * 
 * 空间复杂度分析：
 * O(n^2) 存储距离数组和访问标记数组
 */
public class Code03_SwimInRisingWater {

	// 方向数组：0:上，1:右，2:下，3:左
	// 通过这种方式可以简化四个方向的遍历
	// move[i]和move[i+1]组成一个方向向量
	public static int[] move = new int[] { -1, 0, 1, 0, -1 };

	/**
	 * 使用Dijkstra算法求解最少时间
	 * 
	 * 算法核心思想：
	 * 1. 将问题转化为图论中的最短路径问题
	 * 2. 每个平台是一个节点，相邻平台之间有边连接
	 * 3. 边的权重定义为两个平台高度的最大值（因为水位必须同时淹没两个平台）
	 * 4. 路径的时间定义为路径上所有边权重的最大值
	 * 5. 使用Dijkstra算法找到从起点到终点的最少时间路径
	 * 
	 * 算法步骤：
	 * 1. 初始化距离数组，起点距离为其高度，其他点为无穷大
	 * 2. 使用优先队列维护待处理节点，按时间从小到大排序
	 * 3. 不断取出时间最小的节点，更新其邻居节点的最少时间
	 * 4. 当处理到终点时，直接返回结果（剪枝优化）
	 * 
	 * 时间复杂度：O(n^2*log(n^2)) = O(n^2*logn)
	 * 空间复杂度：O(n^2)
	 * 
	 * @param grid n x n 的整数矩阵，grid[i][j]表示位置(i,j)的平台高度
	 * @return 从左上平台到右下平台所需的最少时间
	 */
	public static int swimInWater(int[][] grid) {
		int n = grid.length;      // 矩阵行数
		int m = grid[0].length;   // 矩阵列数
		
		// distance[i][j]表示从起点(0,0)到达点(i,j)的最少时间
		// 初始化为最大值，表示尚未访问
		int[][] distance = new int[n][m];
		for (int i = 0; i < n; i++) {
			for (int j = 0; j < m; j++) {
				distance[i][j] = Integer.MAX_VALUE;
			}
		}
		// 起点时间为该点的高度
		// 因为从(0,0)出发，所以最少时间至少是该点的高度
		distance[0][0] = grid[0][0];
		
		// visited[i][j]表示点(i,j)是否已经确定了最短路径
		// 用于避免重复处理已经确定最短路径的节点
		boolean[][] visited = new boolean[n][m];
		
		// 优先队列，按时间从小到大排序
		// 数组含义：[0] 格子的行, [1] 格子的列, [2] 源点到当前格子的代价
		PriorityQueue<int[]> heap = new PriorityQueue<>((a, b) -> a[2] - b[2]);
		// 将起点加入优先队列，时间为该点的高度
		heap.add(new int[] { 0, 0, grid[0][0] });
		
		// Dijkstra算法主循环
		while (!heap.isEmpty()) {
			// 取出时间最小的节点
			int x = heap.peek()[0];   // 当前行
			int y = heap.peek()[1];   // 当前列
			int c = heap.peek()[2];   // 当前时间
			heap.poll();
			
			// 如果已经处理过，跳过
			// 这是为了避免同一节点多次处理导致的重复计算
			if (visited[x][y]) {
				continue;
			}
			
			// 标记为已处理，表示已确定从起点到该点的最少时间
			visited[x][y] = true;
			
			// 如果到达终点，直接返回结果
			// 常见剪枝优化：发现终点直接返回，不用等都结束
			// 这是因为Dijkstra算法的特性保证了第一次到达终点时就是最优解
			if (x == n - 1 && y == m - 1) {
				return c;
			}
			
			// 向四个方向扩展（上、右、下、左）
			for (int i = 0, nx, ny, nc; i < 4; i++) {
				// 计算新位置的坐标
				nx = x + move[i];     // 新行
				ny = y + move[i + 1]; // 新列
				
				// 检查边界条件和是否已访问
				// 1. 新位置不能超出矩阵边界
				// 2. 新位置不能是已经处理过的节点
				if (nx >= 0 && nx < n && ny >= 0 && ny < m && !visited[nx][ny]) {
					// 计算到达新点的时间
					// 需要同时淹没两个平台，所以时间为两个平台高度的最大值
					// 这是因为水位必须同时淹没当前位置和新位置才能游过去
					nc = Math.max(c, grid[nx][ny]);
					
					// 如果新的时间更小，则更新
					// 松弛操作：如果 nc < distance[nx][ny]，则更新distance[nx][ny]
					if (nc < distance[nx][ny]) {
						distance[nx][ny] = nc;
						// 将更新后的节点加入优先队列
						heap.add(new int[] { nx, ny, nc });
					}
				}
			}
		}
		// 理论上不会执行到这里，因为从左上角到右下角总是存在路径
		return -1;
	}

}