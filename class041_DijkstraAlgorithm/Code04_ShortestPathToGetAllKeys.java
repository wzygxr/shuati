package class064;

import java.util.*;

/**
 * ============================================================================
 * 获取所有钥匙的最短路径 - 状态压缩BFS算法实现
 * ============================================================================
 * 
 * 题目链接：https://leetcode.cn/problems/shortest-path-to-get-all-keys
 * 
 * 题目描述：
 * 给定一个二维网格 grid ，其中：
 * '.' 代表一个空房间、'#' 代表一堵墙、'@' 是起点
 * 小写字母代表钥匙、大写字母代表锁
 * 从起点开始出发，一次移动是指向四个基本方向之一行走一个单位空间
 * 不能在网格外面行走，也无法穿过一堵墙
 * 如果途经一个钥匙，我们就把它捡起来。除非我们手里有对应的钥匙，否则无法通过锁。
 * 假设 k 为 钥匙/锁 的个数，且满足 1 <= k <= 6，
 * 字母表中的前 k 个字母在网格中都有自己对应的一个小写和一个大写字母
 * 换言之，每个锁有唯一对应的钥匙，每个钥匙也有唯一对应的锁
 * 另外，代表钥匙和锁的字母互为大小写并按字母顺序排列
 * 返回获取所有钥匙所需要的移动的最少次数。如果无法获取所有钥匙，返回 -1 。
 * 
 * 输入格式：
 * - grid: 二维字符数组，表示网格地图
 * - 网格大小：1 <= n, m <= 30
 * - 钥匙数量：1 <= k <= 6
 * 
 * 输出格式：
 * - 获取所有钥匙所需的最少移动次数
 * - 如果无法获取所有钥匙，返回-1
 * 
 * 算法原理：
 * ============================================================================
 * 本问题是一个典型的状态空间搜索问题，需要在网格地图中寻找收集所有钥匙的最短路径。
 * 与传统BFS不同，这里的状态不仅包括位置坐标(x,y)，还包括钥匙收集状态。
 * 
 * 状态表示：
 * - 位置状态：(x, y) 坐标
 * - 钥匙状态：使用位掩码表示，第i位为1表示已收集第i把钥匙
 * - 完整状态：(x, y, keys_mask)
 * 
 * 状态转移：
 * 1. 移动：向四个方向移动，不能穿过墙和未解锁的锁
 * 2. 收集钥匙：遇到钥匙时更新钥匙状态
 * 3. 解锁：遇到锁时检查是否有对应钥匙
 * 
 * 算法正确性：
 * - BFS保证找到的路径是最短的
 * - 状态压缩避免重复访问相同状态
 * - 位运算高效处理钥匙状态
 * 
 * 算法步骤详解：
 * ============================================================================
 * 1. 初始化阶段：
 *    - 解析网格，找到起点位置和钥匙数量
 *    - 初始化三维访问数组 visited[x][y][state]
 *    - 创建队列，加入初始状态 (start_x, start_y, 0)
 *    - 初始化步数计数器
 * 
 * 2. BFS搜索阶段：
 *    - 按层遍历，每层代表一步移动
 *    - 对于当前层的每个状态 (x, y, keys)：
 *        - 如果已收集所有钥匙，返回当前步数
 *        - 向四个方向移动：
 *            - 检查新位置是否越界
 *            - 检查是否是墙
 *            - 检查是否是锁且没有对应钥匙
 *            - 如果是钥匙，更新钥匙状态
 *            - 如果新状态未被访问，加入队列
 * 
 * 3. 终止条件：
 *    - 成功：收集到所有钥匙
 *    - 失败：队列为空仍未收集所有钥匙
 * 
 * 时间复杂度分析：
 * ============================================================================
 * - 状态数量：O(n * m * 2^k)
 * - 每个状态处理：O(4) 四个方向
 * - 总时间复杂度：O(4 * n * m * 2^k)
 * 
 * 空间复杂度分析：
 * ============================================================================
 * - 访问数组：O(n * m * 2^k)
 * - 队列：O(n * m * 2^k)
 * - 总空间复杂度：O(n * m * 2^k)
 * 
 * 算法优化技巧：
 * ============================================================================
 * 1. 状态压缩：使用位运算表示钥匙状态，节省空间
 * 2. 方向数组：预定义四个方向，简化代码
 * 3. 提前终止：一旦收集所有钥匙立即返回
 * 4. 层序遍历：BFS按层遍历，保证最短路径
 * 
 * 边界情况处理：
 * ============================================================================
 * 1. 网格边界：检查坐标是否越界
 * 2. 墙和锁：正确处理障碍物
 * 3. 钥匙重复：避免重复收集同一把钥匙
 * 4. 状态重复：使用visited数组避免重复状态
 * 5. 大规模数据：k<=6保证状态空间可控
 * 
 * 测试用例设计：
 * ============================================================================
 * 1. 基础测试：简单网格，少量钥匙
 * 2. 复杂测试：迷宫式网格，多把钥匙和锁
 * 3. 边界测试：单钥匙、最大网格、所有钥匙被锁包围
 * 4. 性能测试：30x30网格，6把钥匙
 * 
 * 工程化实践：
 * ============================================================================
 * 1. 模块化设计：将BFS逻辑封装为独立方法
 * 2. 常量定义：使用常量提高代码可读性
 * 3. 错误处理：验证输入网格的合法性
 * 4. 性能监控：添加状态统计和性能分析
 * 
 * 应用场景：
 * ============================================================================
 * 1. 游戏开发：迷宫游戏中的寻路算法
 * 2. 机器人导航：需要收集物品的路径规划
 * 3. 网络安全：权限获取的最优路径分析
 * 4. 物流优化：多目标收集的路径规划
 * 
 * 相关算法扩展：
 * ============================================================================
 * 1. A*算法：使用启发式函数加速搜索
 * 2. 双向BFS：从起点和终点同时搜索
 * 3. 动态规划：预处理关键路径信息
 * 4. 分层图：将状态空间转化为图结构
 * 
 * 作者：算法工程化项目组
 * 创建时间：2025-10-29
 * 版本：v1.0
 */
public class Code04_ShortestPathToGetAllKeys {

	public static int MAXN = 31;
	public static int MAXM = 31;
	public static int MAXK = 6;

	// 方向数组：0:上，1:右，2:下，3:左
	// 通过这种方式可以简化四个方向的遍历
	// move[i]和move[i+1]组成一个方向向量
	public static int[] move = new int[] { -1, 0, 1, 0, -1 };

	public static char[][] grid = new char[MAXN][];
	
	// visited[x][y][state]表示在位置(x,y)且钥匙收集状态为state时是否已访问
	// state用位运算表示，第i位为1表示已收集第i把钥匙
	public static boolean[][][] visited = new boolean[MAXN][MAXM][1 << MAXK];

	// BFS队列，存储状态信息
	// 0 : 行坐标
	// 1 : 列坐标
	// 2 : 收集钥匙的状态（位运算表示）
	public static int[][] queue = new int[MAXN * MAXM * (1 << MAXK)][3];

	public static int l, r, n, m, key;

	/**
	 * 初始化函数
	 * 
	 * 主要工作：
	 * 1. 将字符串数组转换为字符数组
	 * 2. 寻找起点位置
	 * 3. 统计所有钥匙，用位运算表示
	 * 4. 初始化访问数组
	 * 
	 * 时间复杂度: O(n*m*2^k)
	 * 空间复杂度: O(n*m*2^k)
	 * 
	 * @param g 字符串数组表示的网格
	 */
	public static void build(String[] g) {
		l = r = key = 0;
		n = g.length;
		m = g[0].length();
		
		// 将字符串数组转换为字符数组，便于后续处理
		for (int i = 0; i < n; i++) {
			grid[i] = g[i].toCharArray();
		}
		
		// 寻找起点和所有钥匙
		for (int i = 0; i < n; i++) {
			for (int j = 0; j < m; j++) {
				// 找到起点
				if (grid[i][j] == '@') {
					queue[r][0] = i;        // 起点行坐标
					queue[r][1] = j;        // 起点列坐标
					// 0 : 000000 初始状态，没有钥匙
					queue[r++][2] = 0;      // 起点钥匙状态为0
				}
				// 统计所有钥匙，用位运算表示
				// 例如：如果有钥匙'a'和'c'，则key = (1<<0) | (1<<2) = 1 | 4 = 5 (二进制101)
				if (grid[i][j] >= 'a' && grid[i][j] <= 'f') {
					key |= 1 << (grid[i][j] - 'a');
				}
			}
		}
		
		// 初始化访问数组
		// 将所有状态标记为未访问
		for (int i = 0; i < n; i++) {
			for (int j = 0; j < m; j++) {
				for (int s = 0; s <= key; s++) {
					visited[i][j][s] = false;
				}
			}
		}
	}

	/**
	 * 使用BFS求解最短路径
	 * 
	 * 算法核心思想：
	 * 1. 这是一个状态空间搜索问题，状态包括位置和钥匙收集情况
	 * 2. 使用BFS保证第一次到达目标状态时步数最少
	 * 3. 用位运算优化钥匙状态的表示和处理
	 * 4. 通过visited数组避免重复访问相同状态
	 * 
	 * 算法步骤：
	 * 1. 初始化，将起点状态加入队列
	 * 2. 按层进行BFS遍历，每层代表相同的步数
	 * 3. 对于每个状态，向四个方向扩展
	 * 4. 根据移动到的新位置更新钥匙状态
	 * 5. 检查是否能通过锁（有对应钥匙）
	 * 6. 如果收集到所有钥匙，返回步数
	 * 
	 * 时间复杂度: O(n*m*2^k)
	 * 空间复杂度: O(n*m*2^k)
	 * 
	 * @param g 字符串数组表示的网格
	 * @return 获取所有钥匙所需要的移动的最少次数，如果无法获取所有钥匙返回-1
	 */
	public static int shortestPathAllKeys(String[] g) {
		build(g);
		// level表示移动的步数，从1开始计数
		int level = 1;
		
		// BFS主循环
		while (l < r) {
			// 按层遍历，保证同层节点具有相同的步数
			for (int k = 0, size = r - l, x, y, s; k < size; k++) {
				x = queue[l][0];    // 当前行坐标
				y = queue[l][1];    // 当前列坐标
				s = queue[l++][2];  // 当前钥匙状态
				
				// 向四个方向扩展（上、右、下、左）
				for (int i = 0, nx, ny, ns; i < 4; i++) {
					nx = x + move[i];     // 新行坐标
					ny = y + move[i + 1]; // 新列坐标
					ns = s;               // 新钥匙状态，初始与当前状态相同
					
					// 越界或者遇到墙，跳过
					if (nx < 0 || nx == n || ny < 0 || ny == m || grid[nx][ny] == '#') {
						continue;
					}
					
					// 遇到锁但没有对应的钥匙，跳过
					// 检查方法：(ns & (1 << (grid[nx][ny] - 'A'))) == 0
					// 如果结果为0，说明对应位为0，即没有该钥匙
					if (grid[nx][ny] >= 'A' && grid[nx][ny] <= 'F' && ((ns & (1 << (grid[nx][ny] - 'A'))) == 0)) {
						continue;
					}
					
					// 遇到钥匙，收集钥匙
					// 使用位运算更新钥匙状态
					// 例如：当前状态为010，遇到钥匙'c'，则新状态为010 | (1<<2) = 010 | 100 = 110
					if (grid[nx][ny] >= 'a' && grid[nx][ny] <= 'f') {
						// 是某一把钥匙
						ns |= (1 << (grid[nx][ny] - 'a'));
					}
					
					// 如果收集到了所有钥匙，返回步数
					// 常见剪枝优化：发现终点直接返回，不用等都结束
					if (ns == key) {
						return level;
					}
					
					// 如果该状态未访问过，加入队列
					// 避免重复访问相同状态，提高效率
					if (!visited[nx][ny][ns]) {
						visited[nx][ny][ns] = true;  // 标记为已访问
						queue[r][0] = nx;            // 新状态行坐标
						queue[r][1] = ny;            // 新状态列坐标
						queue[r++][2] = ns;          // 新状态钥匙状态
					}
				}
			}
			level++;  // 步数增加
		}
		// 无法收集所有钥匙
		return -1;
	}

}