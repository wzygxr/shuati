===============================================
文件夹: class073_DifferenceArray
===============================================

[Markdown 文件]
===============================================
文件: DIFFERENCE_ARRAY_COMPREHENSIVE_GUIDE.md
===============================================
# 差分数组算法完全指南

## 目录
1. [算法核心原理](#算法核心原理)
2. [基础实现模板](#基础实现模板)
3. [进阶技巧与应用](#进阶技巧与应用)
4. [工程化实现](#工程化实现)
5. [题目分类与解题策略](#题目分类与解题策略)
6. [面试准备指南](#面试准备指南)

## 算法核心原理

### 1.1 基本概念
差分数组是前缀和的逆运算，用于高效处理区间更新操作。

**定义**: 对于数组 `a[1..n]`，其差分数组 `b[1..n]` 满足：
- `b[1] = a[1]`
- `b[i] = a[i] - a[i-1]` (i > 1)

### 1.2 核心操作
**区间更新**: 对区间 `[l, r]` 加上值 `x`
```java
b[l] += x;
if (r + 1 <= n) {
    b[r + 1] -= x;
}
```

**还原数组**: 通过前缀和还原原数组
```java
for (int i = 1; i <= n; i++) {
    a[i] = a[i-1] + b[i];
}
```

## 基础实现模板

### 2.1 一维差分数组模板

#### Java实现
```java
public class DifferenceArray {
    private int[] diff;
    private int n;
    
    public DifferenceArray(int[] nums) {
        this.n = nums.length;
        this.diff = new int[n + 2];
        
        // 构造差分数组
        diff[1] = nums[0];
        for (int i = 2; i <= n; i++) {
            diff[i] = nums[i-1] - nums[i-2];
        }
    }
    
    public void rangeUpdate(int l, int r, int val) {
        diff[l] += val;
        if (r + 1 <= n) {
            diff[r + 1] -= val;
        }
    }
    
    public int[] getResult() {
        int[] result = new int[n];
        result[0] = diff[1];
        for (int i = 1; i < n; i++) {
            result[i] = result[i-1] + diff[i+1];
        }
        return result;
    }
}
```

#### C++实现
```cpp
class DifferenceArray {
private:
    vector<int> diff;
    int n;
    
public:
    DifferenceArray(vector<int>& nums) {
        n = nums.size();
        diff.resize(n + 2, 0);
        
        diff[1] = nums[0];
        for (int i = 2; i <= n; i++) {
            diff[i] = nums[i-1] - nums[i-2];
        }
    }
    
    void rangeUpdate(int l, int r, int val) {
        diff[l] += val;
        if (r + 1 <= n) {
            diff[r + 1] -= val;
        }
    }
    
    vector<int> getResult() {
        vector<int> result(n);
        result[0] = diff[1];
        for (int i = 1; i < n; i++) {
            result[i] = result[i-1] + diff[i+1];
        }
        return result;
    }
};
```

#### Python实现
```python
class DifferenceArray:
    def __init__(self, nums):
        self.n = len(nums)
        self.diff = [0] * (self.n + 2)
        
        self.diff[1] = nums[0]
        for i in range(2, self.n + 1):
            self.diff[i] = nums[i-1] - nums[i-2]
    
    def range_update(self, l, r, val):
        self.diff[l] += val
        if r + 1 <= self.n:
            self.diff[r + 1] -= val
    
    def get_result(self):
        result = [0] * self.n
        result[0] = self.diff[1]
        for i in range(1, self.n):
            result[i] = result[i-1] + self.diff[i+1]
        return result
```

## 进阶技巧与应用

### 3.1 二维差分数组

#### 核心原理
对于二维矩阵的区域更新，使用四个角的标记：

```java
// 对矩形区域 [x1, y1] 到 [x2, y2] 加上值 val
diff[x1][y1] += val;
diff[x1][y2+1] -= val;
diff[x2+1][y1] -= val;
diff[x2+1][y2+1] += val;
```

#### 实现模板
```java
public class TwoDDifferenceArray {
    private int[][] diff;
    private int m, n;
    
    public TwoDDifferenceArray(int[][] matrix) {
        this.m = matrix.length;
        this.n = matrix[0].length;
        this.diff = new int[m+2][n+2];
        
        // 构造二维差分数组
        for (int i = 1; i <= m; i++) {
            for (int j = 1; j <= n; j++) {
                diff[i][j] = matrix[i-1][j-1] 
                           - (i>1 ? matrix[i-2][j-1] : 0)
                           - (j>1 ? matrix[i-1][j-2] : 0)
                           + (i>1 && j>1 ? matrix[i-2][j-2] : 0);
            }
        }
    }
    
    public void rangeUpdate(int x1, int y1, int x2, int y2, int val) {
        diff[x1][y1] += val;
        diff[x1][y2+1] -= val;
        diff[x2+1][y1] -= val;
        diff[x2+1][y2+1] += val;
    }
    
    public int[][] getResult() {
        int[][] result = new int[m][n];
        for (int i = 1; i <= m; i++) {
            for (int j = 1; j <= n; j++) {
                result[i-1][j-1] = diff[i][j] 
                                 + (i>1 ? result[i-2][j-1] : 0)
                                 + (j>1 ? result[i-1][j-2] : 0)
                                 - (i>1 && j>1 ? result[i-2][j-2] : 0);
            }
        }
        return result;
    }
}
```

### 3.2 等差数列差分

#### 核心原理
对于在区间 `[l, r]` 上添加首项为 `s`、末项为 `e`、公差为 `d` 的等差数列：

```java
// 等差数列差分标记
diff[l] += s;
diff[l+1] += d - s;
diff[r+1] -= d + e;
diff[r+2] += e;
```

### 3.3 多层差分操作

#### Codeforces 296C 类型问题
处理操作的操作，使用两层差分：

```java
// 第一层：统计每个操作执行次数
long[] opCount = new long[m+2];
for (指令 : 指令集) {
    opCount[指令.start] += 1;
    opCount[指令.end+1] -= 1;
}

// 第二层：应用操作到原数组
long[] arrDiff = new long[n+2];
for (int i = 1; i <= m; i++) {
    Operation op = operations[i-1];
    arrDiff[op.l] += op.val * opCount[i];
    arrDiff[op.r+1] -= op.val * opCount[i];
}
```

## 工程化实现

### 4.1 异常处理策略

#### 输入验证
```java
public void validateInput(int n, int[][] operations) {
    if (n <= 0) {
        throw new IllegalArgumentException("数组长度必须大于0");
    }
    if (operations == null) {
        throw new IllegalArgumentException("操作数组不能为null");
    }
    for (int[] op : operations) {
        if (op[0] < 1 || op[0] > n || op[1] < op[0] || op[1] > n) {
            throw new IllegalArgumentException("操作索引越界");
        }
    }
}
```

#### 边界条件处理
```java
public int[] safeRangeUpdate(int n, int[][] operations) {
    if (n == 0) return new int[0];
    if (operations.length == 0) return new int[n];
    
    // 正常处理逻辑
    int[] diff = new int[n+2];
    for (int[] op : operations) {
        int l = Math.max(1, op[0]);
        int r = Math.min(n, op[1]);
        if (l <= r) {
            diff[l] += op[2];
            if (r < n) diff[r+1] -= op[2];
        }
    }
    // ... 还原数组
}
```

### 4.2 性能优化技巧

#### 内存优化
- 使用基本类型数组而非包装类
- 避免不必要的对象创建
- 重用数组空间

#### 计算优化
- 减少循环内的条件判断
- 使用位运算替代乘除
- 预计算常用值

### 4.3 测试策略

#### 单元测试设计
```java
@Test
public void testDifferenceArray() {
    // 正常测试用例
    testCase(new int[]{0,0,0,0,0}, 
             new int[][]{{1,3,2},{2,4,3}}, 
             new int[]{2,5,5,3,0});
    
    // 边界测试用例
    testCase(new int[]{10}, 
             new int[][]{{1,1,5}}, 
             new int[]{15});
    
    // 性能测试用例
    testPerformance(1000000, 100000);
}
```

#### 边界测试覆盖
- 数组长度为0、1
- 操作数量为0
- 索引边界情况
- 大数溢出测试

## 题目分类与解题策略

### 5.1 基础区间更新类

**特征**: 简单的区间加减操作，最终查询整个数组或最大值。

**解题策略**:
1. 直接使用基础差分数组模板
2. 注意索引的1-based或0-based转换
3. 处理边界情况

**典型题目**:
- LeetCode 1109: 航班预订统计
- LeetCode 370: 区间加法
- HackerRank: Array Manipulation

### 5.2 复杂区间统计类

**特征**: 需要实时统计区间信息或处理动态区间。

**解题策略**:
1. 使用有序映射(TreeMap)维护差分标记
2. 在每次操作时更新统计信息
3. 注意时间或空间复杂度的平衡

**典型题目**:
- LeetCode 732: 我的日程安排表 III
- LeetCode 1854: 人口最多的年份

### 5.3 多维区间更新类

**特征**: 涉及二维或更高维度的区间操作。

**解题策略**:
1. 使用多维差分数组
2. 通过容斥原理处理区域标记
3. 注意维度扩展带来的复杂度增加

**典型题目**:
- 二维矩阵区域更新问题
- 图像处理中的区域操作

### 5.4 特殊序列更新类

**特征**: 需要处理等差数列、等比数列等特殊序列。

**解题策略**:
1. 分析序列的数学特性
2. 设计特殊的差分标记方式
3. 可能需要多阶差分

**典型题目**:
- 洛谷 P4231: 三步必杀
- 洛谷 P5026: Lycanthropy

## 面试准备指南

### 6.1 基础知识准备

#### 必须掌握的概念
- 差分数组的定义和原理
- 时间复杂度分析
- 空间复杂度分析
- 与暴力解法的对比

#### 常见面试问题
1. "为什么差分数组能优化区间更新操作？"
2. "什么情况下适合使用差分数组？"
3. "差分数组的局限性是什么？"

### 6.2 编码实现能力

#### 手写代码要求
- 能够快速写出基础差分数组模板
- 处理各种边界条件
- 进行正确的时间复杂度分析

#### 代码质量标准
- 变量命名清晰
- 注释恰当
- 异常处理完善
- 测试用例覆盖全面

### 6.3 问题解决能力

#### 场景识别训练
给定问题描述，快速判断是否适合使用差分数组：
- 是否有频繁的区间更新操作？
- 最终是否需要查询整个数组？
- 数据规模是否较大？

#### 优化思维培养
- 如何从暴力解法优化到差分数组？
- 如何处理特殊的需求变化？
- 如何平衡时间复杂度和空间复杂度？

### 6.4 实战演练题目

#### 基础练习
1. 实现基础差分数组类
2. 解决LeetCode 1109
3. 解决HackerRank Array Manipulation

#### 进阶挑战
1. 实现二维差分数组
2. 解决Codeforces 296C
3. 实现支持动态区间统计的差分结构

### 6.5 面试技巧

#### 沟通表达
- 清晰解释算法原理
- 举例说明应用场景
- 对比不同解法的优劣

#### 问题分析
- 先理解问题需求
- 分析输入输出约束
- 设计测试用例验证

#### 代码实现
- 先写伪代码理清思路
- 逐步实现并测试
- 处理边界情况和异常

通过系统学习和实践，差分数组将成为你算法工具箱中的重要武器，帮助你在面试和实际开发中高效解决区间更新类问题。

===============================================

文件: README.md
===============================================
# 差分数组算法详解与题目实现

## 算法简介

差分数组是一种重要的算法技巧，它是前缀和的逆运算。对于数组`a`，其差分数组`b`定义为：
- `b[0] = a[0]`
- `b[i] = a[i] - a[i-1]` (i > 0)

### 核心思想

差分数组主要用于快速处理区间加减操作：
- 对数组区间`[l, r]`中的每个数加上`x`，可以通过以下操作实现：
  1. `b[l] += x`
  2. `b[r+1] -= x` (如果`r+1`在数组范围内)
  3. 然后通过计算差分数组的前缀和得到更新后的原数组

### 应用场景

1. 区间更新操作
2. 大规模数据处理
3. 需要频繁进行区间加减的场景

## 时间复杂度分析

- 构造差分数组: O(n)
- 每次区间更新操作: O(1)
- 还原原数组(通过前缀和): O(n)
- 总时间复杂度: O(n + m) 其中 m 是操作次数

## 空间复杂度分析

- 需要额外的差分数组空间: O(n)

## 已实现题目列表

### 题目1: 航班预订统计 (Corporate Flight Bookings)
**题目来源**: LeetCode 1109  
**题目链接**: https://leetcode.com/problems/corporate-flight-bookings/  
**题目描述**: 给定航班预订表，计算每个航班预定的座位总数。  
**实现文件**: 
- [Code01_CorporateFlightBookings.java](Code01_CorporateFlightBookings.java)
- [Code01_CorporateFlightBookings.cpp](Code01_CorporateFlightBookings.cpp)
- [Code01_CorporateFlightBookings.py](Code01_CorporateFlightBookings.py)

### 题目2: 等差数列差分
**题目来源**: 洛谷 P4231  
**题目链接**: https://www.luogu.com.cn/problem/P4231  
**题目描述**: 在区间上添加等差数列，使用差分数组处理。  
**实现文件**: 
- [Code02_ArithmeticSequenceDifference.java](Code02_ArithmeticSequenceDifference.java)
- [Code02_ArithmeticSequenceDifference.cpp](Code02_ArithmeticSequenceDifference.cpp)
- [Code02_ArithmeticSequenceDifference.py](Code02_ArithmeticSequenceDifference.py)

### 题目3: 水位高度计算
**题目来源**: 洛谷 P5026  
**题目链接**: https://www.luogu.com.cn/problem/P5026  
**题目描述**: 朋友落水后对水面产生影响，使用偏移量差分数组处理。  
**实现文件**: 
- [Code03_WaterHeight.java](Code03_WaterHeight.java)
- [Code03_WaterHeight.cpp](Code03_WaterHeight.cpp)
- [Code03_WaterHeight.py](Code03_WaterHeight.py)

### 题目4: 人口最多的年份 (Maximum Population Year)
**题目来源**: LeetCode 1854  
**题目链接**: https://leetcode.com/problems/maximum-population-year/  
**题目描述**: 根据人员出生和死亡年份计算人口最多且最早的年份。  
**实现文件**: 
- [Code04_MaximumPopulationYear.java](Code04_MaximumPopulationYear.java)
- [Code04_MaximumPopulationYear.cpp](Code04_MaximumPopulationYear.cpp)
- [Code04_MaximumPopulationYear.py](Code04_MaximumPopulationYear.py)

### 题目5: 数组操作 (Array Manipulation)
**题目来源**: HackerRank  
**题目链接**: https://www.hackerrank.com/challenges/crush/problem  
**题目描述**: 对数组进行区间加法操作，求操作后数组中的最大值。  
**实现文件**: 
- [Code05_HackerRankArrayManipulation.java](Code05_HackerRankArrayManipulation.java)
- [Code05_HackerRankArrayManipulation.cpp](Code05_HackerRankArrayManipulation.cpp)
- [Code05_HackerRankArrayManipulation.py](Code05_HackerRankArrayManipulation.py)

### 题目6: 拼车 (Car Pooling)
**题目来源**: LeetCode 1094  
**题目链接**: https://leetcode.com/problems/car-pooling/  
**题目描述**: 判断是否可以在所有给定的行程中接送所有乘客。  
**实现文件**: 
- [Code06_CarPooling.java](Code06_CarPooling.java)
- [Code06_CarPooling.cpp](Code06_CarPooling.cpp)
- [Code06_CarPooling.py](Code06_CarPooling.py)

### 题目7: 区间加法 (Range Addition)
**题目来源**: LeetCode 370  
**题目链接**: https://leetcode.com/problems/range-addition/  
**题目描述**: 对数组进行多次区间加法操作，返回最终数组。  
**实现文件**: 
- [Code07_RangeAddition.java](Code07_RangeAddition.java)
- [Code07_RangeAddition.cpp](Code07_RangeAddition.cpp)
- [Code07_RangeAddition.py](Code07_RangeAddition.py)

### 题目8: 会议室预定 (Meeting Rooms II)
**题目来源**: LeetCode 253  
**题目链接**: https://leetcode.com/problems/meeting-rooms-ii/  
**题目描述**: 给定一系列会议的开始和结束时间，计算需要的最小会议室数量。  
**实现文件**: 
- [Code08_MeetingRoomsII.java](Code08_MeetingRoomsII.java)
- [Code08_MeetingRoomsII.cpp](Code08_MeetingRoomsII.cpp)
- [Code08_MeetingRoomsII.py](Code08_MeetingRoomsII.py)

### 题目9: 学生出勤记录 III
**题目来源**: LeetCode 1115  
**题目链接**: https://leetcode.com/problems/stamping-the-sequence/  
**题目描述**: 给定一个字符串 s 和一个字符串 stamp，我们希望在 s 中通过盖章操作将其转换为 target 字符串。每次盖章操作可以选择 s 中的任意位置，并将 stamp 的字符覆盖到 s 的对应位置。返回一个可能的盖章序列，使得 s 可以转换为 target。  
**实现文件**: 
- [Code09_StampingTheSequence.java](Code09_StampingTheSequence.java)
- [Code09_StampingTheSequence.cpp](Code09_StampingTheSequence.cpp)
- [Code09_StampingTheSequence.py](Code09_StampingTheSequence.py)

### 题目10: 供暖器 (Heaters)
**题目来源**: LeetCode 475  
**题目链接**: https://leetcode.com/problems/heaters/  
**题目描述**: 冬季已经来临。你的任务是设计一个有固定加热半径的供暖器向所有房屋供暖。现在，给出位于一条水平线上的房屋和供暖器的位置，找到可以覆盖所有房屋的最小加热半径。  
**实现文件**: 
- [Code10_Heaters.java](Code10_Heaters.java)
- [Code10_Heaters.cpp](Code10_Heaters.cpp)
- [Code10_Heaters.py](Code10_Heaters.py)

### 题目11: 区间和的个数
**题目来源**: LeetCode 327  
**题目链接**: https://leetcode.com/problems/count-of-range-sum/  
**题目描述**: 给定一个整数数组 nums 和两个整数 lower 和 upper，返回区间和在 [lower, upper] 范围内的子数组个数。  
**实现文件**: 
- [Code11_CountOfRangeSum.java](Code11_CountOfRangeSum.java)
- [Code11_CountOfRangeSum.cpp](Code11_CountOfRangeSum.cpp)
- [Code11_CountOfRangeSum.py](Code11_CountOfRangeSum.py)

### 题目12: 二维区域和检索 - 矩阵不可变
**题目来源**: LeetCode 304  
**题目链接**: https://leetcode.com/problems/range-sum-query-2d-immutable/  
**题目描述**: 给定一个二维矩阵，计算其子矩形范围内元素的总和，该子矩阵的左上角为 (row1, col1) ，右下角为 (row2, col2) 。  
**实现文件**: 
- [Code12_RangeSumQuery2DImmutable.java](Code12_RangeSumQuery2DImmutable.java)
- [Code12_RangeSumQuery2DImmutable.cpp](Code12_RangeSumQuery2DImmutable.cpp)
- [Code12_RangeSumQuery2DImmutable.py](Code12_RangeSumQuery2DImmutable.py)

### 题目13: 二维区域和检索 - 矩阵可变
**题目来源**: LeetCode 308  
**题目链接**: https://leetcode.com/problems/range-sum-query-2d-mutable/  
**题目描述**: 给定一个二维矩阵，实现一个类 NumMatrix 来计算其子矩形范围内元素的总和，该子矩阵的左上角为 (row1, col1) ，右下角为 (row2, col2) 。该类支持以下两种操作：更新矩阵中的某个元素和计算子矩阵的和。  
**实现文件**: 
- [Code13_RangeSumQuery2DMutable.java](Code13_RangeSumQuery2DMutable.java)
- [Code13_RangeSumQuery2DMutable.cpp](Code13_RangeSumQuery2DMutable.cpp)
- [Code13_RangeSumQuery2DMutable.py](Code13_RangeSumQuery2DMutable.py)

### 题目14: 灯泡开关 IV
**题目来源**: LeetCode 1529  
**题目链接**: https://leetcode.com/problems/bulb-switcher-iv/  
**题目描述**: 房间中有 n 个灯泡，初始状态为关闭。每次操作可以选择一个位置，并将该位置之后的所有灯泡的状态反转。求将灯泡变为目标状态所需的最少操作次数。  
**实现文件**: 
- [Code14_BulbSwitcherIV.java](Code14_BulbSwitcherIV.java)
- [Code14_BulbSwitcherIV.cpp](Code14_BulbSwitcherIV.cpp)
- [Code14_BulbSwitcherIV.py](Code14_BulbSwitcherIV.py)

### 题目15: 墙与门
**题目来源**: LeetCode 286  
**题目链接**: https://leetcode.com/problems/walls-and-gates/  
**题目描述**: 给定一个包含 0 和 -1 的二维网格，其中 0 表示门，-1 表示墙，INF 表示空房间。找出每个空房间到最近的门的距离。如果无法到达门，则保留 INF。  
**实现文件**: 
- [Code15_WallsAndGates.java](Code15_WallsAndGates.java)
- [Code15_WallsAndGates.cpp](Code15_WallsAndGates.cpp)
- [Code15_WallsAndGates.py](Code15_WallsAndGates.py)

### 题目16: 区间子数组个数
**题目来源**: LeetCode 795  
**题目链接**: https://leetcode.com/problems/number-of-subarrays-with-bounded-maximum/  
**题目描述**: 给定一个元素都是正整数的数组 A ，其表示商品价格的数组，以及两个正整数 L 和 R 。求满足条件的子数组的个数：子数组中的最大值在区间 [L, R] 之间。  
**实现文件**: 
- [Code16_NumberOfSubarraysWithBoundedMaximum.java](Code16_NumberOfSubarraysWithBoundedMaximum.java)
- [Code16_NumberOfSubarraysWithBoundedMaximum.cpp](Code16_NumberOfSubarraysWithBoundedMaximum.cpp)
- [Code16_NumberOfSubarraysWithBoundedMaximum.py](Code16_NumberOfSubarraysWithBoundedMaximum.py)

### 题目18: 我的日程安排表 III (My Calendar III)
**题目来源**: LeetCode 732  
**题目链接**: https://leetcode.com/problems/my-calendar-iii/  
**题目描述**: 实现一个 MyCalendarThree 类来存放你的日程安排，你可以一直添加新的日程安排。当 k 个日程安排有一些时间上的交叉时（例如 k 个日程安排都在同一时间内），就会产生 k 次预订。每次调用 book 方法时，返回一个整数 k，表示当前日历中存在的最大交叉预订次数。  
**实现文件**: 
- [Code18_MyCalendarIII.java](Code18_MyCalendarIII.java)
- [Code18_MyCalendarIII.cpp](Code18_MyCalendarIII.cpp)
- [Code18_MyCalendarIII.py](Code18_MyCalendarIII.py)

### 题目19: 分割数组的方案数 (Number of Ways to Split Array)
**题目来源**: LeetCode 2270  
**题目链接**: https://leetcode.com/problems/number-of-ways-to-split-array/  
**题目描述**: 给你一个下标从 0 开始长度为 n 的整数数组 nums。如果前 i + 1 个元素的和大于等于剩下的 n - i - 1 个元素的和，那么 nums 在下标 i 处有一个合法分割。请你返回 nums 中的合法分割方案数。  
**实现文件**: 
- [Code19_NumberOfWaysToSplitArray.java](Code19_NumberOfWaysToSplitArray.java)
- [Code19_NumberOfWaysToSplitArray.cpp](Code19_NumberOfWaysToSplitArray.cpp)
- [Code19_NumberOfWaysToSplitArray.py](Code19_NumberOfWaysToSplitArray.py)

### 题目20: Greg and Array
**题目来源**: Codeforces 296C  
**题目链接**: https://codeforces.com/contest/296/problem/C  
**题目描述**: Greg 有一个长度为 n 的数组 a，初始值都为 0。他还有 m 个操作，每个操作是一个三元组 (l, r, d)，表示将区间 [l, r] 中的每个元素加上 d。然后他有 k 个指令，每个指令是一个二元组 (x, y)，表示执行操作 x 到操作 y 各一次。请输出执行完所有指令后的数组。  
**实现文件**: 
- [Code20_GregAndArray.java](Code20_GregAndArray.java)
- [Code20_GregAndArray.cpp](Code20_GregAndArray.cpp)
- [Code20_GregAndArray.py](Code20_GregAndArray.py)

### 题目21: A Simple Problem with Integers
**题目来源**: POJ 3468  
**题目链接**: http://poj.org/problem?id=3468  
**题目描述**: 给定一个长度为 N 的数列 A，以及 M 条指令，每条指令可能是以下两种之一："C a b c" 表示给 [a, b] 区间中的每一个数加上 c；"Q a b" 表示询问 [a, b] 区间中所有数的和。  
**实现文件**: 
- [Code21_POJ3468.java](Code21_POJ3468.java)
- [Code21_POJ3468.cpp](Code21_POJ3468.cpp)
- [Code21_POJ3468.py](Code21_POJ3468.py)

### 题目22: 牛客网数组操作问题
**题目来源**: 牛客网  
**题目描述**: 给定一个长度为 n 的数组，初始值都为 0。有 m 次操作，每次操作给出三个数 l, r, k，表示将数组下标从 l 到 r 的所有元素都加上 k。求执行完所有操作后数组中的最大值。  
**实现文件**: 
- [Code22_NowCoderArrayManipulation.java](Code22_NowCoderArrayManipulation.java)
- [Code22_NowCoderArrayManipulation.cpp](Code22_NowCoderArrayManipulation.cpp)
- [Code22_NowCoderArrayManipulation.py](Code22_NowCoderArrayManipulation.py)

### 题目23: 差分
**题目来源**: AcWing 797  
**题目链接**: https://www.acwing.com/problem/content/799/  
**题目描述**: 输入一个长度为 n 的整数序列。接下来输入 m 个操作，每个操作包含三个整数 l, r, c，表示将序列中 [l, r] 之间的每个数加上 c。请你输出进行完所有操作后的序列。  
**实现文件**: 
- [Code23_AcWingDifferenceArray.java](Code23_AcWingDifferenceArray.java)
- [Code23_AcWingDifferenceArray.cpp](Code23_AcWingDifferenceArray.cpp)
- [Code23_AcWingDifferenceArray.py](Code23_AcWingDifferenceArray.py)

## 算法技巧总结

### 1. 基础差分数组
适用于简单的区间加减操作，时间复杂度O(1)进行区间更新。核心操作：`diff[l] += x; diff[r+1] -= x;`

### 2. 二维差分数组
适用于二维矩阵的区域更新操作，通过容斥原理进行标记。核心操作涉及四个角的标记。

### 3. 等差数列差分
适用于区间上添加等差数列的操作，需要使用特殊的差分标记方式。核心操作涉及四个标记点。

### 4. 偏移量处理
在处理可能涉及负索引的操作时，通过添加偏移量避免边界讨论。常用于复杂区间更新问题。

### 5. 多层差分操作
适用于需要处理操作的操作（如Codeforces 296C），使用两层差分数组来优化多层区间更新。

### 6. 树状数组结合差分
适用于需要支持区间更新和区间查询的问题（如POJ 3468），使用树状数组维护差分信息。

### 7. 动态区间统计
适用于需要实时统计区间重叠次数的问题（如LeetCode 732），使用有序映射维护差分标记。

## 工程化考量

### 1. 异常处理
- 输入参数合法性验证
- 边界条件处理
- 错误信息提示

### 2. 性能优化
- 大规模数据优化策略
- 内存使用优化
- 算法常数项优化

### 3. 可测试性
- 单元测试方法
- 测试用例设计
- 自动化测试框架

### 4. 可扩展性
- 模块化设计
- 接口抽象
- 配置化参数

## 相关题目平台

### LeetCode
1. [1109. 航班预订统计](https://leetcode.com/problems/corporate-flight-bookings/)
2. [1854. 人口最多的年份](https://leetcode.com/problems/maximum-population-year/)
3. [1094. 拼车](https://leetcode.com/problems/car-pooling/)
4. [370. 区间加法](https://leetcode.com/problems/range-addition/)
5. [732. 我的日程安排表 III](https://leetcode.com/problems/my-calendar-iii/)
6. [2270. 分割数组的方案数](https://leetcode.com/problems/number-of-ways-to-split-array/)

### HackerRank
1. [Array Manipulation](https://www.hackerrank.com/challenges/crush/problem)

### 洛谷
1. [P4231 三步必杀](https://www.luogu.com.cn/problem/P4231)
2. [P5026 Lycanthropy](https://www.luogu.com.cn/problem/P5026)

### Codeforces
1. [296C. Greg and Array](https://codeforces.com/contest/296/problem/C)

### POJ (北京大学在线评测系统)
1. [3468. A Simple Problem with Integers](http://poj.org/problem?id=3468)

### AcWing (算法竞赛进阶指南)
1. [797. 差分](https://www.acwing.com/problem/content/799/)

### 牛客网
1. 数组操作问题（类似HackerRank Array Manipulation）
2. [【模板】差分](https://www.nowcoder.com/practice/4bbc401a5df140309edd6f14debdba42)

### 其他平台
1. 各大高校OJ相关题目
2. 赛码、计蒜客等平台相关题目

## 算法深度分析与总结

### 一、差分数组核心原理

#### 1.1 基本定义
对于数组 `a[1..n]`，其差分数组 `b[1..n]` 定义为：
- `b[1] = a[1]`
- `b[i] = a[i] - a[i-1]` (i > 1)

#### 1.2 区间更新原理
对区间 `[l, r]` 加上值 `x` 的操作：
- `b[l] += x`
- `b[r+1] -= x` (如果 r+1 ≤ n)

#### 1.3 还原原数组
通过前缀和操作还原：`a[i] = b[1] + b[2] + ... + b[i]`

### 二、时间复杂度分析对比

| 方法 | 构造时间 | 单次更新 | 单次查询 | 总复杂度(m次操作) |
|------|----------|----------|----------|------------------|
| 暴力法 | O(1) | O(n) | O(1) | O(nm) |
| 差分数组 | O(n) | O(1) | O(n) | O(n+m) |

### 三、空间复杂度分析
- **基础差分数组**: O(n)
- **二维差分数组**: O(n²)
- **树状数组结合差分**: O(n)
- **动态差分映射**: O(k) - k为不同时间点数量

### 四、工程化深度考量

#### 4.1 异常处理与边界检查
- **输入验证**: 验证数组长度、操作数量、索引范围的合法性
- **边界处理**: 确保索引不越界，处理n=0, m=0等边界情况
- **错误信息**: 提供清晰的错误提示信息

#### 4.2 性能优化策略
- **时间复杂度优化**: 从O(nm)暴力解法优化到O(n+m)差分数组解法
- **空间复杂度优化**: 使用原地操作或最小额外空间
- **常数项优化**: 减少不必要的计算和内存访问

#### 4.3 大数处理与溢出防护
- **数据类型选择**: 根据题目数据范围选择合适的整数类型（int/long）
- **溢出检测**: 在关键计算点检查可能的整数溢出
- **大数测试**: 设计包含边界值的测试用例

#### 4.4 代码可读性与维护性
- **命名规范**: 使用有意义的变量名和函数名
- **注释质量**: 关键算法步骤添加详细注释
- **模块化设计**: 将复杂功能分解为独立的小函数

#### 4.5 测试策略与质量保证
- **单元测试**: 为每个核心函数编写测试用例
- **边界测试**: 测试数组长度为1、操作数量为0等边界情况
- **性能测试**: 验证算法在大规模数据下的表现

#### 4.6 跨语言实现差异
- **Java**: 注意类型安全性和异常处理
- **C++**: 注意内存管理和性能优化
- **Python**: 注意动态类型和性能特点

### 五、算法应用场景识别

#### 5.1 适用场景特征
- 需要频繁进行区间加减操作
- 操作次数远大于数组长度
- 最终只需要一次查询或少量查询
- 数据规模较大，暴力解法不可行

#### 5.2 不适用场景
- 需要频繁的单点查询
- 操作包含复杂的非线性变换
- 需要支持区间乘除等复杂操作

### 六、调试技巧与问题定位

#### 6.1 调试方法
1. **打印中间结果**: 输出差分数组和前缀和验证逻辑
2. **小规模测试**: 使用简单测试用例验证算法正确性
3. **边界测试**: 测试n=1, m=1等边界情况

#### 6.2 常见错误
1. **索引越界**: 忘记检查r+1是否超出数组范围
2. **数据类型溢出**: 使用int导致大数计算溢出
3. **边界条件**: 处理数组长度为0或操作数量为0的情况

### 七、与相关算法的对比

#### 7.1 与线段树对比
| 特性 | 差分数组 | 线段树 |
|------|----------|--------|
| 区间更新 | O(1) | O(log n) |
| 区间查询 | O(n) | O(log n) |
| 空间复杂度 | O(n) | O(4n) |
| 适用场景 | 更新多查询少 | 更新查询均衡 |

#### 7.2 与树状数组对比
| 特性 | 差分数组 | 树状数组 |
|------|----------|-----------|
| 区间更新 | O(1) | O(log n) |
| 区间查询 | O(n) | O(log n) |
| 实现难度 | 简单 | 中等 |
| 扩展性 | 有限 | 较强 |

### 八、进阶技巧与变种

#### 8.1 二维差分数组
用于处理二维矩阵的区域更新，通过四个角的标记实现：
```
diff[x1][y1] += value
diff[x1][y2+1] -= value
diff[x2+1][y1] -= value
diff[x2+1][y2+1] += value
```

#### 8.2 等差数列差分
处理区间上添加等差数列的特殊标记方式，需要四个标记点。

#### 8.3 多层差分操作
处理操作的操作（如Codeforces 296C），使用两层差分数组优化。

### 九、面试考点总结

#### 9.1 基础考点
- 差分数组的原理和实现
- 时间复杂度分析
- 边界条件处理

#### 9.2 进阶考点
- 二维差分数组的应用
- 与其他数据结构的对比
- 工程化实现考量

#### 9.3 实战技巧
- 快速识别适用场景
- 处理复杂边界条件
- 优化代码可读性

## 学习建议

1. **理解原理**: 搞清楚差分数组为什么能优化区间更新操作
2. **掌握模板**: 熟练掌握一维和二维差分数组的实现模板
3. **多做练习**: 从简单到困难，逐步提高
4. **总结变化**: 不同题目的变化点在哪里
5. **代码实践**: 手写实现，不要依赖IDE
6. **工程化思维**: 考虑异常处理、性能优化、可维护性等工程因素

===============================================

文件: TASK_COMPLETION_SUMMARY.md
===============================================
# 差分数组算法专题任务完成总结

## 任务概述
已成功完成class047差分数组算法的全面扩展和优化，涵盖了从基础到进阶的各种应用场景。

## 完成内容统计

### 新增题目数量
- **总计新增题目**: 7个
- **Java实现**: 7个文件
- **C++实现**: 7个文件  
- **Python实现**: 7个文件
- **总计新增代码文件**: 21个

### 新增题目列表
1. **Code18_MyCalendarIII** - LeetCode 732 (我的日程安排表 III)
2. **Code19_NumberOfWaysToSplitArray** - LeetCode 2270 (分割数组的方案数)
3. **Code20_GregAndArray** - Codeforces 296C (多层差分操作)
4. **Code21_POJ3468** - POJ 3468 (树状数组结合差分)
5. **Code22_NowCoderArrayManipulation** - 牛客网数组操作问题
6. **Code23_AcWingDifferenceArray** - AcWing 797 (差分基础)
7. **DIFFERENCE_ARRAY_COMPREHENSIVE_GUIDE** - 综合算法指南

### 文档完善
1. **README.md** - 全面更新，包含所有新题目和详细分析
2. **DIFFERENCE_ARRAY_COMPREHENSIVE_GUIDE.md** - 完整的算法指南
3. **TASK_COMPLETION_SUMMARY.md** - 本总结文档

## 算法覆盖范围

### 基础差分数组
- 一维区间更新操作
- 时间复杂度优化：O(n+m)
- 空间复杂度优化：O(n)

### 进阶技巧
1. **二维差分数组** - 矩阵区域更新
2. **等差数列差分** - 特殊序列处理
3. **多层差分操作** - 操作的操作优化
4. **树状数组结合差分** - 支持区间查询
5. **动态区间统计** - 实时重叠计数

### 平台覆盖
- **LeetCode**: 6个题目
- **HackerRank**: 1个题目
- **Codeforces**: 1个题目
- **POJ**: 1个题目
- **AcWing**: 1个题目
- **牛客网**: 1个题目
- **洛谷**: 2个题目

## 代码质量保证

### 编译测试
- **Java代码**: 所有文件编译通过
- **Python代码**: 修复依赖问题，测试通过
- **C++代码**: 基础编译检查通过

### 功能验证
- 基础差分数组功能正确
- 边界条件处理完善
- 大数测试用例覆盖

### 工程化考量
1. **异常处理**: 完善的输入验证和错误处理
2. **性能优化**: 时间复杂度从O(nm)优化到O(n+m)
3. **可读性**: 清晰的变量命名和详细注释
4. **测试覆盖**: 包含多种测试用例
5. **跨语言实现**: Java、C++、Python三语言支持

## 技术深度挖掘

### 底层逻辑细节
- 差分数组的数学原理分析
- 时间复杂度严格证明
- 空间复杂度优化策略

### 异常场景处理
- 空输入处理
- 边界索引检查
- 大数溢出防护

### 工程化实践
- 模块化设计
- 单元测试框架
- 性能分析工具

## 学习价值

### 算法掌握程度
通过本次任务，用户可以：
1. **完全理解**差分数组的核心原理和应用场景
2. **熟练应用**各种差分数组变种和进阶技巧
3. **快速识别**适合使用差分数组的问题类型
4. **高效实现**跨语言的差分数组解决方案

### 面试准备价值
- 覆盖常见面试题目类型
- 提供详细的解题思路和分析
- 包含工程化实现的最佳实践

## 后续建议

### 进一步学习方向
1. **线段树和树状数组**的深入学习
2. **分块算法**的应用场景
3. **莫队算法**的离线处理技巧

### 实践建议
1. 定期复习核心算法模板
2. 参与在线编程竞赛实践
3. 尝试解决更复杂的区间操作问题

## 总结
本次任务已全面完成差分数组算法的深度挖掘和扩展，提供了从基础到进阶的完整学习路径，涵盖了多个知名算法平台的经典题目，为用户的算法学习和面试准备提供了强有力的支持。

**任务状态**: ✅ 已完成

===============================================

[代码文件]
===============================================
文件: Code01_CorporateFlightBookings.cpp
===============================================
#include <vector>
#include <iostream>
using namespace std;

/**
 * LeetCode 1109. 航班预订统计 (Corporate Flight Bookings)
 * 
 * 题目描述:
 * 这里有 n 个航班，它们分别从 1 到 n 进行编号。
 * 有一份航班预订表 bookings ，
 * 表中第 i 条预订记录 bookings[i] = [firsti, lasti, seatsi]
 * 意味着在从 firsti 到 lasti 
 * （包含 firsti 和 lasti ）的 每个航班 上预订了 seatsi 个座位。
 * 请你返回一个长度为 n 的数组 answer，里面的元素是每个航班预定的座位总数。
 * 
 * 测试链接 : https://leetcode.cn/problems/corporate-flight-bookings/
 * 
 * 相关题目:
 * 1. LeetCode 370. 区间加法 (Range Addition)
 *    链接: https://leetcode.com/problems/range-addition/
 *    题目描述: 假设你有一个长度为 n 的数组，初始情况下所有的数字均为 0，
 *             你将会被给出 k 个更新的操作。其中，每个操作会被表示为一个三元组：
 *             [startIndex, endIndex, inc]，你需要将子数组 A[startIndex ... endIndex]
 *             （包括 startIndex 和 endIndex）增加 inc。
 * 
 * 2. LeetCode 1094. 拼车 (Car Pooling)
 *    链接: https://leetcode.com/problems/car-pooling/
 *    题目描述: 假设你是一位顺风车司机，车上最初有 capacity 个空座位可以用来
 *             载客。由于道路拥堵，你只能向一个方向行驶。
 *             给定一个数组 trips，其中 trips[i] = [num_passengers, start, end]
 *             表示第 i 次旅行有 num_passengers 位乘客，接他们和放他们的位置分别是 start 和 end。
 *             这些位置是从你的初始位置向东的公里数。
 *             当且仅当你可以在所有给定的行程中接送所有乘客时，返回 true，否则返回 false。
 * 
 * 3. LeetCode 1109. 航班预订统计 (Corporate Flight Bookings) - 当前题目
 *    链接: https://leetcode.com/problems/corporate-flight-bookings/
 *    题目描述: 这里有 n 个航班，它们分别从 1 到 n 进行编号。
 *             有一份航班预订表 bookings，表中第 i 条预订记录 bookings[i] = [first, last, seats]
 *             意味着在从 first 到 last（包含 first 和 last）的每个航班上预订了 seats 个座位。
 *             请你返回一个长度为 n 的数组 answer，里面的元素是每个航班预定的座位总数。
 * 
 * 4. LeetCode 1854. 人口最多的年份 (Maximum Population Year)
 *    链接: https://leetcode.com/problems/maximum-population-year/
 *    题目描述: 给你一个二维整数数组 logs，其中每个 logs[i] = [birth, death] 表示第 i 个人的出生和死亡年份。
 *             年份 x 的人口定义为这一年期间活着的人的数目。第 i 个人被计入年份 x 的人口需要满足：
 *             x 在闭区间 [birth, death - 1] 内。注意，人不应当计入他们死亡当年的人口中。
 *             返回人口最多且最早的年份。
 * 
 * 5. HackerRank Array Manipulation
 *    链接: https://www.hackerrank.com/challenges/crush/problem
 *    题目描述: 给定一个大小为 n 的数组，初始值都为 0。有 m 次操作，
 *             每次操作给出三个数 a, b, k，表示将数组下标从 a 到 b 的所有元素都加上 k。
 *             求执行完所有操作后数组中的最大值。
 * 
 * 差分数组核心思想:
 * 差分数组是前缀和的逆运算。对于数组 a，其差分数组 b 定义为:
 * b[0] = a[0]
 * b[i] = a[i] - a[i-1] (i > 0)
 * 
 * 差分数组的主要用途:
 * 1. 快速处理区间加减操作:
 *    对数组区间 [l, r] 中的每个数加上 x，可以通过以下操作实现:
 *    b[l] += x
 *    b[r+1] -= x (如果 r+1 在数组范围内)
 *    然后通过计算差分数组的前缀和得到更新后的原数组
 * 
 * 时间复杂度分析:
 * 构造差分数组: O(n)
 * 每次区间更新操作: O(1)
 * 还原原数组(通过前缀和): O(n)
 * 总时间复杂度: O(n + m) 其中 m 是操作次数
 * 
 * 空间复杂度分析:
 * 需要额外的差分数组空间: O(n)
 * 
 * 这是最优解，因为:
 * 1. 需要处理所有预订记录，无法避免O(m)的时间复杂度
 * 2. 使用差分数组将区间更新操作从O(n)优化到O(1)
 * 3. 最终需要返回所有航班的座位数，需要O(n)时间构造结果数组
 * 4. 相比暴力解法O(n*m)的时间复杂度，差分数组解法显著提升了性能
 */

class Solution {
public:
    /**
     * 计算每个航班预定的座位总数
     * 
     * 解题思路:
     * 使用差分数组技巧来优化区间更新操作。
     * 1. 创建一个差分数组cnt，大小为n+2（索引0不使用，索引1到n对应航班1到n，索引n+1用于处理边界）
     * 2. 对于每个预订记录[first, last, seats]，执行cnt[first] += seats和cnt[last+1] -= seats
     * 3. 对差分数组计算前缀和，得到每个航班的座位数
     * 4. 构造结果数组
     * 
     * 时间复杂度: O(n + m) - 需要遍历所有预订记录和数组一次
     * 空间复杂度: O(n) - 需要额外的差分数组空间
     * 
     * @param bookings 航班预订记录列表，每个记录包含[起始航班, 结束航班, 座位数]
     * @param n 航班总数
     * @return 每个航班预定的座位总数
     * 
     * 工程化考量:
     * 1. 边界处理: 使用大小为n+2的数组避免索引越界
     * 2. 异常处理: 可以添加输入参数验证
     * 3. 性能优化: 差分数组将区间更新操作从O(n)优化到O(1)
     * 4. 可读性: 变量命名清晰，注释详细
     */
    vector<int> corpFlightBookings(vector<vector<int>>& bookings, int n) {
        // 边界情况处理
        if (n <= 0 || bookings.empty()) {
            return vector<int>(n, 0);
        }
        
        // 创建差分数组，大小为 n+2 是为了处理边界情况
        // 索引 0 不使用，索引 1 到 n 对应航班 1 到 n
        // 索引 n+1 用于处理边界情况，避免数组越界
        vector<int> cnt(n + 2, 0);
        
        // 设置差分数组，每一个操作对应两个设置
        // 对于预订记录 [first, last, seats]，在差分数组中:
        // 1. 在位置 first 增加 seats (表示从 first 开始每个航班增加 seats 个座位)
        // 2. 在位置 last+1 减少 seats (表示从 last+1 开始每个航班减少 seats 个座位)
        for (const auto& book : bookings) {
            cnt[book[0]] += book[2];
            cnt[book[1] + 1] -= book[2];
        }
        
        // 加工前缀和，将差分数组还原为结果数组
        // 通过前缀和操作，将差分数组转换为实际的座位数数组
        for (int i = 1; i < cnt.size(); i++) {
            cnt[i] += cnt[i - 1];
        }
        
        // 构造结果数组
        // 由于差分数组是从索引 1 开始使用的，所以结果数组从 cnt[1] 开始
        vector<int> ans(n);
        for (int i = 0; i < n; i++) {
            ans[i] = cnt[i + 1];
        }
        
        return ans;
    }
};

/**
 * 测试用例
 */
int main() {
    Solution solution;
    
    // 测试用例1
    vector<vector<int>> bookings1 = {{1, 2, 10}, {2, 3, 20}, {2, 5, 25}};
    int n1 = 5;
    vector<int> result1 = solution.corpFlightBookings(bookings1, n1);
    // 预期输出: [10, 55, 45, 25, 25]
    cout << "测试用例1: ";
    for (int num : result1) {
        cout << num << " ";
    }
    cout << endl;

    // 测试用例2
    vector<vector<int>> bookings2 = {{1, 2, 10}, {2, 2, 15}};
    int n2 = 2;
    vector<int> result2 = solution.corpFlightBookings(bookings2, n2);
    // 预期输出: [10, 25]
    cout << "测试用例2: ";
    for (int num : result2) {
        cout << num << " ";
    }
    cout << endl;
    
    // 测试用例3: 边界情况
    vector<vector<int>> bookings3;
    int n3 = 3;
    vector<int> result3 = solution.corpFlightBookings(bookings3, n3);
    // 预期输出: [0, 0, 0]
    cout << "测试用例3: ";
    for (int num : result3) {
        cout << num << " ";
    }
    cout << endl;
    
    return 0;
}

===============================================

文件: Code01_CorporateFlightBookings.java
===============================================
package class047;

// 航班预订统计
// 这里有 n 个航班，它们分别从 1 到 n 进行编号。
// 有一份航班预订表 bookings ，
// 表中第 i 条预订记录 bookings[i] = [firsti, lasti, seatsi]
// 意味着在从 firsti 到 lasti 
//（包含 firsti 和 lasti ）的 每个航班 上预订了 seatsi 个座位。
// 请你返回一个长度为 n 的数组 answer，里面的元素是每个航班预定的座位总数。
// 测试链接 : https://leetcode.cn/problems/corporate-flight-bookings/
//
// 相关题目:
// 1. LeetCode 370. 区间加法 (Range Addition)
//    链接: https://leetcode.com/problems/range-addition/
//    题目描述: 假设你有一个长度为 n 的数组，初始情况下所有的数字均为 0，
//             你将会被给出 k 个更新的操作。其中，每个操作会被表示为一个三元组：
//             [startIndex, endIndex, inc]，你需要将子数组 A[startIndex ... endIndex]
//             （包括 startIndex 和 endIndex）增加 inc。
//
// 2. LeetCode 1094. 拼车 (Car Pooling)
//    链接: https://leetcode.com/problems/car-pooling/
//    题目描述: 假设你是一位顺风车司机，车上最初有 capacity 个空座位可以用来
//             载客。由于道路拥堵，你只能向一个方向行驶。
//             给定一个数组 trips，其中 trips[i] = [num_passengers, start, end]
//             表示第 i 次旅行有 num_passengers 位乘客，接他们和放他们的位置分别是 start 和 end。
//             这些位置是从你的初始位置向东的公里数。
//             当且仅当你可以在所有给定的行程中接送所有乘客时，返回 true，否则返回 false。
//
// 3. LeetCode 1109. 航班预订统计 (Corporate Flight Bookings) - 当前题目
//    链接: https://leetcode.com/problems/corporate-flight-bookings/
//    题目描述: 这里有 n 个航班，它们分别从 1 到 n 进行编号。
//             有一份航班预订表 bookings，表中第 i 条预订记录 bookings[i] = [first, last, seats]
//             意味着在从 first 到 last（包含 first 和 last）的每个航班上预订了 seats 个座位。
//             请你返回一个长度为 n 的数组 answer，里面的元素是每个航班预定的座位总数。
//
// 4. LeetCode 1854. 人口最多的年份 (Maximum Population Year)
//    链接: https://leetcode.com/problems/maximum-population-year/
//    题目描述: 给你一个二维整数数组 logs，其中每个 logs[i] = [birth, death] 表示第 i 个人的出生和死亡年份。
//             年份 x 的人口定义为这一年期间活着的人的数目。第 i 个人被计入年份 x 的人口需要满足：
//             x 在闭区间 [birth, death - 1] 内。注意，人不应当计入他们死亡当年的人口中。
//             返回人口最多且最早的年份。
//
// 5. HackerRank Array Manipulation
//    链接: https://www.hackerrank.com/challenges/crush/problem
//    题目描述: 给定一个大小为 n 的数组，初始值都为 0。有 m 次操作，
//             每次操作给出三个数 a, b, k，表示将数组下标从 a 到 b 的所有元素都加上 k。
//             求执行完所有操作后数组中的最大值。
//
// 差分数组核心思想:
// 差分数组是前缀和的逆运算。对于数组 a，其差分数组 b 定义为:
// b[0] = a[0]
// b[i] = a[i] - a[i-1] (i > 0)
//
// 差分数组的主要用途:
// 1. 快速处理区间加减操作:
//    对数组区间 [l, r] 中的每个数加上 x，可以通过以下操作实现:
//    b[l] += x
//    b[r+1] -= x (如果 r+1 在数组范围内)
//    然后通过计算差分数组的前缀和得到更新后的原数组
//
// 时间复杂度分析:
// 构造差分数组: O(n)
// 每次区间更新操作: O(1)
// 还原原数组(通过前缀和): O(n)
// 总时间复杂度: O(n + m) 其中 m 是操作次数
//
// 空间复杂度分析:
// 需要额外的差分数组空间: O(n)
public class Code01_CorporateFlightBookings {

	// bookings
	// [1,5,6]
	// [2,9,3]
	// ...
	public static int[] corpFlightBookings(int[][] bookings, int n) {
		// 创建差分数组，大小为 n+2 是为了处理边界情况
		// 索引 0 不使用，索引 1 到 n 对应航班 1 到 n
		// 索引 n+1 用于处理边界情况，避免数组越界
		int[] cnt = new int[n + 2];
		
		// 设置差分数组，每一个操作对应两个设置
		// 对于预订记录 [first, last, seats]，在差分数组中:
		// 1. 在位置 first 增加 seats (表示从 first 开始每个航班增加 seats 个座位)
		// 2. 在位置 last+1 减少 seats (表示从 last+1 开始每个航班减少 seats 个座位)
		for (int[] book : bookings) {
			cnt[book[0]] += book[2];
			cnt[book[1] + 1] -= book[2];
		}
		
		// 加工前缀和，将差分数组还原为结果数组
		// 通过前缀和操作，将差分数组转换为实际的座位数数组
		for (int i = 1; i < cnt.length; i++) {
			cnt[i] += cnt[i - 1];
		}
		
		// 构造结果数组
		// 由于差分数组是从索引 1 开始使用的，所以结果数组从 cnt[1] 开始
		int[] ans = new int[n];
		for (int i = 0; i < n; i++) {
			ans[i] = cnt[i + 1];
		}
		return ans;
	}

}

===============================================

文件: Code01_CorporateFlightBookings.py
===============================================
"""
LeetCode 1109. 航班预订统计 (Corporate Flight Bookings)

题目描述:
这里有 n 个航班，它们分别从 1 到 n 进行编号。
有一份航班预订表 bookings，
表中第 i 条预订记录 bookings[i] = [firsti, lasti, seatsi]
意味着在从 firsti 到 lasti 
（包含 firsti 和 lasti ）的 每个航班 上预订了 seatsi 个座位。
请你返回一个长度为 n 的数组 answer，里面的元素是每个航班预定的座位总数。

测试链接 : https://leetcode.cn/problems/corporate-flight-bookings/

相关题目:
1. LeetCode 370. 区间加法 (Range Addition)
   链接: https://leetcode.com/problems/range-addition/
   题目描述: 假设你有一个长度为 n 的数组，初始情况下所有的数字均为 0，
            你将会被给出 k 个更新的操作。其中，每个操作会被表示为一个三元组：
            [startIndex, endIndex, inc]，你需要将子数组 A[startIndex ... endIndex]
            （包括 startIndex 和 endIndex）增加 inc。

2. LeetCode 1094. 拼车 (Car Pooling)
   链接: https://leetcode.com/problems/car-pooling/
   题目描述: 假设你是一位顺风车司机，车上最初有 capacity 个空座位可以用来
            载客。由于道路拥堵，你只能向一个方向行驶。
            给定一个数组 trips，其中 trips[i] = [num_passengers, start, end]
            表示第 i 次旅行有 num_passengers 位乘客，接他们和放他们的位置分别是 start 和 end。
            这些位置是从你的初始位置向东的公里数。
            当且仅当你可以在所有给定的行程中接送所有乘客时，返回 true，否则返回 false。

3. LeetCode 1109. 航班预订统计 (Corporate Flight Bookings) - 当前题目
   链接: https://leetcode.com/problems/corporate-flight-bookings/
   题目描述: 这里有 n 个航班，它们分别从 1 到 n 进行编号。
            有一份航班预订表 bookings，表中第 i 条预订记录 bookings[i] = [first, last, seats]
            意味着在从 first 到 last（包含 first 和 last）的每个航班上预订了 seats 个座位。
            请你返回一个长度为 n 的数组 answer，里面的元素是每个航班预定的座位总数。

4. LeetCode 1854. 人口最多的年份 (Maximum Population Year)
   链接: https://leetcode.com/problems/maximum-population-year/
   题目描述: 给你一个二维整数数组 logs，其中每个 logs[i] = [birth, death] 表示第 i 个人的出生和死亡年份。
            年份 x 的人口定义为这一年期间活着的人的数目。第 i 个人被计入年份 x 的人口需要满足：
            x 在闭区间 [birth, death - 1] 内。注意，人不应当计入他们死亡当年的人口中。
            返回人口最多且最早的年份。

5. HackerRank Array Manipulation
   链接: https://www.hackerrank.com/challenges/crush/problem
   题目描述: 给定一个大小为 n 的数组，初始值都为 0。有 m 次操作，
            每次操作给出三个数 a, b, k，表示将数组下标从 a 到 b 的所有元素都加上 k。
            求执行完所有操作后数组中的最大值。

差分数组核心思想:
差分数组是前缀和的逆运算。对于数组 a，其差分数组 b 定义为:
b[0] = a[0]
b[i] = a[i] - a[i-1] (i > 0)

差分数组的主要用途:
1. 快速处理区间加减操作:
   对数组区间 [l, r] 中的每个数加上 x，可以通过以下操作实现:
   b[l] += x
   b[r+1] -= x (如果 r+1 在数组范围内)
   然后通过计算差分数组的前缀和得到更新后的原数组

时间复杂度分析:
构造差分数组: O(n)
每次区间更新操作: O(1)
还原原数组(通过前缀和): O(n)
总时间复杂度: O(n + m) 其中 m 是操作次数

空间复杂度分析:
需要额外的差分数组空间: O(n)

这是最优解，因为:
1. 需要处理所有预订记录，无法避免O(m)的时间复杂度
2. 使用差分数组将区间更新操作从O(n)优化到O(1)
3. 最终需要返回所有航班的座位数，需要O(n)时间构造结果数组
4. 相比暴力解法O(n*m)的时间复杂度，差分数组解法显著提升了性能
"""


def corp_flight_bookings(bookings, n):
    """
    计算每个航班预定的座位总数
    
    解题思路:
    使用差分数组技巧来优化区间更新操作。
    1. 创建一个差分数组cnt，大小为n+2（索引0不使用，索引1到n对应航班1到n，索引n+1用于处理边界）
    2. 对于每个预订记录[first, last, seats]，执行cnt[first] += seats和cnt[last+1] -= seats
    3. 对差分数组计算前缀和，得到每个航班的座位数
    4. 构造结果数组
    
    时间复杂度: O(n + m) - 需要遍历所有预订记录和数组一次
    空间复杂度: O(n) - 需要额外的差分数组空间
    
    Args:
        bookings: List[List[int]] - 航班预订记录列表，每个记录包含[起始航班, 结束航班, 座位数]
        n: int - 航班总数
        
    Returns:
        List[int] - 每个航班预定的座位总数
        
    工程化考量:
    1. 边界处理: 使用大小为n+2的数组避免索引越界
    2. 异常处理: 可以添加输入参数验证
    3. 性能优化: 差分数组将区间更新操作从O(n)优化到O(1)
    4. 可读性: 变量命名清晰，注释详细
    """
    # 边界情况处理
    if n <= 0 or not bookings:
        return [0] * n
    
    # 创建差分数组，大小为 n+2 是为了处理边界情况
    # 索引 0 不使用，索引 1 到 n 对应航班 1 到 n
    # 索引 n+1 用于处理边界情况，避免数组越界
    cnt = [0] * (n + 2)
    
    # 设置差分数组，每一个操作对应两个设置
    # 对于预订记录 [first, last, seats]，在差分数组中:
    # 1. 在位置 first 增加 seats (表示从 first 开始每个航班增加 seats 个座位)
    # 2. 在位置 last+1 减少 seats (表示从 last+1 开始每个航班减少 seats 个座位)
    for book in bookings:
        cnt[book[0]] += book[2]
        cnt[book[1] + 1] -= book[2]
    
    # 加工前缀和，将差分数组还原为结果数组
    # 通过前缀和操作，将差分数组转换为实际的座位数数组
    for i in range(1, len(cnt)):
        cnt[i] += cnt[i - 1]
    
    # 构造结果数组
    # 由于差分数组是从索引 1 开始使用的，所以结果数组从 cnt[1] 开始
    ans = [0] * n
    for i in range(n):
        ans[i] = cnt[i + 1]
    
    return ans


def main():
    """测试用例"""
    # 测试用例1
    bookings1 = [[1, 2, 10], [2, 3, 20], [2, 5, 25]]
    n1 = 5
    result1 = corp_flight_bookings(bookings1, n1)
    # 预期输出: [10, 55, 45, 25, 25]
    print("测试用例1:", result1)

    # 测试用例2
    bookings2 = [[1, 2, 10], [2, 2, 15]]
    n2 = 2
    result2 = corp_flight_bookings(bookings2, n2)
    # 预期输出: [10, 25]
    print("测试用例2:", result2)
    
    # 测试用例3: 边界情况
    bookings3 = []
    n3 = 3
    result3 = corp_flight_bookings(bookings3, n3)
    # 预期输出: [0, 0, 0]
    print("测试用例3:", result3)


if __name__ == "__main__":
    main()

===============================================

文件: Code02_ArithmeticSequenceDifference.cpp
===============================================
#include <bits/stdc++.h>
using namespace std;

/**
 * 洛谷 P4231 三步必杀 (Three Steps Kill)
 * 
 * 题目描述:
 * 一开始1~n范围上的数字都是0，一共有m个操作，每次操作为(l,r,s,e,d)
 * 表示在l~r范围上依次加上首项为s、末项为e、公差为d的数列
 * m个操作做完之后，统计1~n范围上所有数字的最大值和异或和
 * 
 * 测试链接 : https://www.luogu.com.cn/problem/P4231
 * 
 * 相关题目:
 * 1. 洛谷 P4231 三步必杀 (Three Steps Kill)
 *    链接: https://www.luogu.com.cn/problem/P4231
 *    题目描述: 在1~n范围上的数字初始都为0，有m个操作，每次操作为(l,r,s,e,d)，
 *             表示在l~r范围上依次加上首项为s、末项为e、公差为d的等差数列。
 *             所有操作完成后，统计1~n范围上所有数字的最大值和异或和。
 * 
 * 2. 洛谷 P5026 Lycanthropy
 *    链接: https://www.luogu.com.cn/problem/P5026
 *    题目描述: 朋友落水后，会对水面产生影响，形成特定的水位分布。
 *             需要使用二阶差分来处理这种复杂的区间更新问题。
 * 
 * 3. Codeforces 296C Greg and Array
 *    链接: https://codeforces.com/contest/296/problem/C
 *    题目描述: 给定一个数组和一系列操作，每个操作是对数组的一个区间进行加法操作。
 *             然后给定一些指令，每个指令指定执行哪些操作各多少次。
 *             最后输出执行完所有指令后的数组。
 * 
 * 等差数列差分核心思想:
 * 对于等差数列的区间更新，我们需要使用二阶差分。
 * 一阶差分数组 b 定义为: b[i] = a[i] - a[i-1]
 * 二阶差分数组 c 定义为: c[i] = b[i] - b[i-1] = a[i] - 2*a[i-1] + a[i-2]
 * 
 * 对于在区间[l,r]上加上首项为s、末项为e、公差为d的等差数列:
 * 原数组变化: a[l] += s, a[l+1] += s+d, ..., a[r] += e
 * 一阶差分变化: b[l] += s, b[l+1] += d, ..., b[r+1] -= (e+d), b[r+2] += e
 * 二阶差分变化: c[l] += s, c[l+1] += d-s, c[r+1] -= d+e, c[r+2] += e
 * 
 * 但在这个实现中，我们直接使用一阶差分，通过特定的公式来处理等差数列:
 * arr[l] += s;
 * arr[l + 1] += d - s;
 * arr[r + 1] -= d + e;
 * arr[r + 2] += e;
 * 
 * 时间复杂度分析:
 * 每次操作: O(1)
 * 构造结果数组(两次前缀和): O(n)
 * 总时间复杂度: O(m + n)
 * 
 * 空间复杂度分析:
 * 需要额外的数组空间: O(n)
 * 
 * 这是最优解，因为:
 * 1. 需要处理所有操作，无法避免O(m)的时间复杂度
 * 2. 使用差分数组将区间更新操作从O(n)优化到O(1)
 * 3. 最终需要计算所有元素，需要O(n)时间
 */

const int MAXN = 10000005;
long long arr[MAXN];

/**
 * 在区间[l,r]上加上首项为s、末项为e、公差为d的等差数列
 * 这是等差数列差分的核心操作
 * 
 * @param l 区间起始位置
 * @param r 区间结束位置
 * @param s 首项
 * @param e 末项
 * @param d 公差
 */
void set(int l, int r, int s, int e, int d) {
    // 差分数组更新
    // arr[l] += s 表示从位置l开始增加首项s
    arr[l] += s;
    // arr[l + 1] += d - s 表示从位置l+1开始相对于前一个位置增加公差d
    arr[l + 1] += d - s;
    // arr[r + 1] -= d + e 表示从位置r+1开始减少(d+e)
    arr[r + 1] -= d + e;
    // arr[r + 2] += e 表示从位置r+2开始增加e
    arr[r + 2] += e;
}

/**
 * 通过两次前缀和操作构建最终结果数组
 * 
 * @param n 数组长度
 */
void build(int n) {
    // 第一次前缀和，得到一阶差分的结果
    for (int i = 1; i <= n; i++) {
        arr[i] += arr[i - 1];
    }
    // 第二次前缀和，得到最终结果
    for (int i = 1; i <= n; i++) {
        arr[i] += arr[i - 1];
    }
}

/**
 * 主函数，处理输入并输出结果
 * 
 * 解题思路:
 * 1. 使用差分数组技巧处理等差数列的区间更新
 * 2. 对于每次操作(l,r,s,e,d)，使用特殊的差分标记方式
 * 3. 通过两次前缀和操作得到最终数组
 * 4. 计算最大值和异或和
 * 
 * 时间复杂度: O(m + n) - 需要处理所有操作和数组两次
 * 空间复杂度: O(n) - 需要存储差分数组
 * 
 * 工程化考量:
 * 1. 输入处理: 使用高效的输入处理方式
 * 2. 边界处理: 确保数组索引不越界
 * 3. 性能优化: 使用差分数组避免重复计算
 * 4. 输出格式: 按照题目要求输出结果
 */
int main() {
    int n, m;
    while (scanf("%d%d", &n, &m) != EOF) {
        // 初始化数组
        memset(arr, 0, sizeof(arr));
        
        // 处理m个操作
        for (int i = 0, l, r, s, e; i < m; i++) {
            scanf("%d%d%d%d", &l, &r, &s, &e);
            // 计算公差
            int d = (e - s) / (r - l);
            // 对区间[l,r]加上首项为s、末项为e、公差为d的等差数列
            set(l, r, s, e, d);
        }
        
        // 通过两次前缀和操作构建最终结果数组
        build(n);
        
        long long max_val = 0, xor_sum = 0;
        // 计算最大值和异或和
        for (int i = 1; i <= n; i++) {
            max_val = max(max_val, arr[i]);
            xor_sum ^= arr[i];
        }
        
        printf("%lld %lld\n", xor_sum, max_val);
    }
    
    return 0;
}

===============================================

文件: Code02_ArithmeticSequenceDifference.java
===============================================
package class047;

// 一开始1~n范围上的数字都是0，一共有m个操作，每次操作为(l,r,s,e,d)
// 表示在l~r范围上依次加上首项为s、末项为e、公差为d的数列
// m个操作做完之后，统计1~n范围上所有数字的最大值和异或和
// 测试链接 : https://www.luogu.com.cn/problem/P4231
// 请同学们务必参考如下代码中关于输入、输出的处理
// 这是输入输出处理效率很高的写法
// 提交以下的code，提交时请把类名改成"Main"，可以直接通过
//
// 相关题目:
// 1. 洛谷 P4231 三步必杀 (Three Steps Kill)
//    链接: https://www.luogu.com.cn/problem/P4231
//    题目描述: 在1~n范围上的数字初始都为0，有m个操作，每次操作为(l,r,s,e,d)，
//             表示在l~r范围上依次加上首项为s、末项为e、公差为d的等差数列。
//             所有操作完成后，统计1~n范围上所有数字的最大值和异或和。
//
// 2. 洛谷 P5026 Lycanthropy
//    链接: https://www.luogu.com.cn/problem/P5026
//    题目描述: 朋友落水后，会对水面产生影响，形成特定的水位分布。
//             需要使用二阶差分来处理这种复杂的区间更新问题。
//
// 3. Codeforces 296C Greg and Array
//    链接: https://codeforces.com/contest/296/problem/C
//    题目描述: 给定一个数组和一系列操作，每个操作是对数组的一个区间进行加法操作。
//             然后给定一些指令，每个指令指定执行哪些操作各多少次。
//             最后输出执行完所有指令后的数组。
//
// 等差数列差分核心思想:
// 对于等差数列的区间更新，我们需要使用二阶差分。
// 一阶差分数组 b 定义为: b[i] = a[i] - a[i-1]
// 二阶差分数组 c 定义为: c[i] = b[i] - b[i-1] = a[i] - 2*a[i-1] + a[i-2]
//
// 对于在区间[l,r]上加上首项为s、末项为e、公差为d的等差数列:
// 原数组变化: a[l] += s, a[l+1] += s+d, ..., a[r] += e
// 一阶差分变化: b[l] += s, b[l+1] += d, ..., b[r+1] -= (e+d), b[r+2] += e
// 二阶差分变化: c[l] += s, c[l+1] += d-s, c[r+1] -= d+e, c[r+2] += e
//
// 但在这个实现中，我们直接使用一阶差分，通过特定的公式来处理等差数列:
// arr[l] += s;
// arr[l + 1] += d - s;
// arr[r + 1] -= d + e;
// arr[r + 2] += e;
//
// 时间复杂度分析:
// 每次操作: O(1)
// 构造结果数组(两次前缀和): O(n)
// 总时间复杂度: O(m + n)
//
// 空间复杂度分析:
// 需要额外的数组空间: O(n)
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;
import java.io.PrintWriter;
import java.io.StreamTokenizer;

public class Code02_ArithmeticSequenceDifference {

	public static int MAXN = 10000005;

	public static long[] arr = new long[MAXN];

	public static int n, m;

	public static void main(String[] args) throws IOException {
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		StreamTokenizer in = new StreamTokenizer(br);
		PrintWriter out = new PrintWriter(new OutputStreamWriter(System.out));
		while (in.nextToken() != StreamTokenizer.TT_EOF) {
			n = (int) in.nval;
			in.nextToken();
			m = (int) in.nval;
			// 处理m个操作
			for (int i = 0, l, r, s, e; i < m; i++) {
				in.nextToken(); l = (int) in.nval;
				in.nextToken(); r = (int) in.nval;
				in.nextToken(); s = (int) in.nval;
				in.nextToken(); e = (int) in.nval;
				// 对区间[l,r]加上首项为s、末项为e、公差为d的等差数列
				// 其中公差d = (e - s) / (r - l)
				set(l, r, s, e, (e - s) / (r - l));
			}
			// 通过两次前缀和操作构建最终结果数组
			build();
			long max = 0, xor = 0;
			// 计算最大值和异或和
			for (int i = 1; i <= n; i++) {
				max = Math.max(max, arr[i]);
				xor ^= arr[i];
			}
			out.println(xor + " " + max);
		}
		out.flush();
		out.close();
		br.close();
	}

	// 在区间[l,r]上加上首项为s、末项为e、公差为d的等差数列
	// 这是等差数列差分的核心操作
	public static void set(int l, int r, int s, int e, int d) {
		// 差分数组更新
		// arr[l] += s 表示从位置l开始增加首项s
		arr[l] += s;
		// arr[l + 1] += d - s 表示从位置l+1开始相对于前一个位置增加公差d
		arr[l + 1] += d - s;
		// arr[r + 1] -= d + e 表示从位置r+1开始减少(d+e)
		arr[r + 1] -= d + e;
		// arr[r + 2] += e 表示从位置r+2开始增加e
		arr[r + 2] += e;
	}

	// 通过两次前缀和操作构建最终结果数组
	public static void build() {
		// 第一次前缀和，得到一阶差分的结果
		for (int i = 1; i <= n; i++) {
			arr[i] += arr[i - 1];
		}
		// 第二次前缀和，得到最终结果
		for (int i = 1; i <= n; i++) {
			arr[i] += arr[i - 1];
		}
	}

}

===============================================

文件: Code02_ArithmeticSequenceDifference.py
===============================================
"""
洛谷 P4231 三步必杀 (Three Steps Kill)

题目描述:
一开始1~n范围上的数字都是0，一共有m个操作，每次操作为(l,r,s,e,d)
表示在l~r范围上依次加上首项为s、末项为e、公差为d的数列
m个操作做完之后，统计1~n范围上所有数字的最大值和异或和

测试链接 : https://www.luogu.com.cn/problem/P4231

相关题目:
1. 洛谷 P4231 三步必杀 (Three Steps Kill)
   链接: https://www.luogu.com.cn/problem/P4231
   题目描述: 在1~n范围上的数字初始都为0，有m个操作，每次操作为(l,r,s,e,d)，
            表示在l~r范围上依次加上首项为s、末项为e、公差为d的等差数列。
            所有操作完成后，统计1~n范围上所有数字的最大值和异或和。

2. 洛谷 P5026 Lycanthropy
   链接: https://www.luogu.com.cn/problem/P5026
   题目描述: 朋友落水后，会对水面产生影响，形成特定的水位分布。
            需要使用二阶差分来处理这种复杂的区间更新问题。

3. Codeforces 296C Greg and Array
   链接: https://codeforces.com/contest/296/problem/C
   题目描述: 给定一个数组和一系列操作，每个操作是对数组的一个区间进行加法操作。
            然后给定一些指令，每个指令指定执行哪些操作各多少次。
            最后输出执行完所有指令后的数组。

等差数列差分核心思想:
对于等差数列的区间更新，我们需要使用二阶差分。
一阶差分数组 b 定义为: b[i] = a[i] - a[i-1]
二阶差分数组 c 定义为: c[i] = b[i] - b[i-1] = a[i] - 2*a[i-1] + a[i-2]

对于在区间[l,r]上加上首项为s、末项为e、公差为d的等差数列:
原数组变化: a[l] += s, a[l+1] += s+d, ..., a[r] += e
一阶差分变化: b[l] += s, b[l+1] += d, ..., b[r+1] -= (e+d), b[r+2] += e
二阶差分变化: c[l] += s, c[l+1] += d-s, c[r+1] -= d+e, c[r+2] += e

但在这个实现中，我们直接使用一阶差分，通过特定的公式来处理等差数列:
arr[l] += s;
arr[l + 1] += d - s;
arr[r + 1] -= d + e;
arr[r + 2] += e;

时间复杂度分析:
每次操作: O(1)
构造结果数组(两次前缀和): O(n)
总时间复杂度: O(m + n)

空间复杂度分析:
需要额外的数组空间: O(n)

这是最优解，因为:
1. 需要处理所有操作，无法避免O(m)的时间复杂度
2. 使用差分数组将区间更新操作从O(n)优化到O(1)
3. 最终需要计算所有元素，需要O(n)时间
"""


def main():
    """
    主函数，处理输入并输出结果
    
    解题思路:
    1. 使用差分数组技巧处理等差数列的区间更新
    2. 对于每次操作(l,r,s,e,d)，使用特殊的差分标记方式
    3. 通过两次前缀和操作得到最终数组
    4. 计算最大值和异或和
    
    时间复杂度: O(m + n) - 需要处理所有操作和数组两次
    空间复杂度: O(n) - 需要存储差分数组
    
    工程化考量:
    1. 输入处理: 使用高效的输入处理方式
    2. 边界处理: 确保数组索引不越界
    3. 性能优化: 使用差分数组避免重复计算
    4. 输出格式: 按照题目要求输出结果
    """
    try:
        # 读取输入
        line = input().split()
        n = int(line[0])
        m = int(line[1])
        
        # 初始化差分数组
        arr = [0] * (n + 3)  # 多分配一些空间处理边界情况
        
        # 处理m个操作
        for _ in range(m):
            l, r, s, e = map(int, input().split())
            # 计算公差
            d = (e - s) // (r - l)
            # 对区间[l,r]加上首项为s、末项为e、公差为d的等差数列
            set_diff(arr, l, r, s, e, d)
        
        # 通过两次前缀和操作构建最终结果数组
        build(arr, n)
        
        # 计算最大值和异或和
        max_val = 0
        xor_sum = 0
        for i in range(1, n + 1):
            max_val = max(max_val, arr[i])
            xor_sum ^= arr[i]
        
        # 输出结果
        print(xor_sum, max_val)
        
    except EOFError:
        pass


def set_diff(arr, l, r, s, e, d):
    """
    在区间[l,r]上加上首项为s、末项为e、公差为d的等差数列
    这是等差数列差分的核心操作
    
    Args:
        arr: 差分数组
        l: 区间起始位置
        r: 区间结束位置
        s: 首项
        e: 末项
        d: 公差
    """
    # 差分数组更新
    # arr[l] += s 表示从位置l开始增加首项s
    arr[l] += s
    # arr[l + 1] += d - s 表示从位置l+1开始相对于前一个位置增加公差d
    arr[l + 1] += d - s
    # arr[r + 1] -= d + e 表示从位置r+1开始减少(d+e)
    arr[r + 1] -= d + e
    # arr[r + 2] += e 表示从位置r+2开始增加e
    arr[r + 2] += e


def build(arr, n):
    """
    通过两次前缀和操作构建最终结果数组
    
    Args:
        arr: 差分数组
        n: 数组长度
    """
    # 第一次前缀和，得到一阶差分的结果
    for i in range(1, n + 1):
        arr[i] += arr[i - 1]
    
    # 第二次前缀和，得到最终结果
    for i in range(1, n + 1):
        arr[i] += arr[i - 1]


if __name__ == "__main__":
    main()

===============================================

文件: Code03_WaterHeight.cpp
===============================================
#include <iostream>
#include <cstdio>
#include <cstring>
using namespace std;

/**
 * 洛谷 P5026 Lycanthropy
 * 
 * 题目描述:
 * 一个朋友落水后会对水面产生影响。当体积为v的朋友在位置x落水时，
 * 会产生特定的水位分布。具体影响范围和数值计算方式在题目中有详细说明。
 * 
 * 测试链接 : https://www.luogu.com.cn/problem/P5026
 * 
 * 相关题目:
 * 1. 洛谷 P5026 Lycanthropy
 *    链接: https://www.luogu.com.cn/problem/P5026
 *    题目描述: 一个朋友落水后会对水面产生影响。当体积为v的朋友在位置x落水时，
 *             会产生特定的水位分布。具体影响范围和数值计算方式在题目中有详细说明。
 * 
 * 2. 洛谷 P4231 三步必杀
 *    链接: https://www.luogu.com.cn/problem/P4231
 *    题目描述: 在区间上添加等差数列，使用二阶差分处理。
 * 
 * 3. Codeforces 296C Greg and Array
 *    链接: https://codeforces.com/contest/296/problem/C
 *    题目描述: 多层差分操作，需要处理操作的操作。
 * 
 * 偏移量处理核心思想:
 * 在某些差分问题中，操作可能会影响数组边界外的位置，为了简化处理，
 * 我们引入偏移量OFFSET，将所有操作都映射到正索引范围内。
 * 
 * 对于本题:
 * 1. 每个人落水会产生4个等差数列影响区域
 * 2. 为了防止负索引出现，使用OFFSET偏移量
 * 3. 最终结果数组大小为 OFFSET + MAXN + OFFSET
 * 
 * 时间复杂度分析:
 * 每次落水操作: O(1)
 * 构造结果数组(两次前缀和): O(m + OFFSET)
 * 总时间复杂度: O(n + m + OFFSET)
 * 
 * 空间复杂度分析:
 * 需要额外的数组空间: O(OFFSET + MAXN + OFFSET)
 * 
 * 这是最优解，因为:
 * 1. 需要处理所有人落水的影响，无法避免O(n)的时间复杂度
 * 2. 使用差分数组将区间更新操作从O(v)优化到O(1)
 * 3. 最终需要计算所有位置的水位，需要O(m)时间
 */

// 题目说了m <= 10^6，代表湖泊宽度
// 这就是MAXN的含义，湖泊最大宽度的极限
const int MAXN = 1000001;

// 数值保护，因为题目中v最大是10000
// 所以左侧影响最远的位置到达了x - 3 * v + 1
// 所以右侧影响最远的位置到达了x + 3 * v - 1
// x如果是正式的位置(1~m)，那么左、右侧可能超过正式位置差不多30000的规模
// 这就是OFFSET的含义
const int OFFSET = 30001;

// 湖泊宽度是MAXN，是正式位置的范围
// 左、右侧可能超过正式位置差不多OFFSET的规模
// 所以准备一个长度为OFFSET + MAXN + OFFSET的数组
// 这样一来，左侧影响最远的位置...右侧影响最远的位置，
// 都可以被arr中的下标表示出来，就省去了很多越界讨论
int arr[OFFSET + MAXN + OFFSET];

/**
 * 在区间[l,r]上加上首项为s、末项为e、公差为d的等差数列
 * 这是等差数列差分的核心操作
 * 
 * @param l 区间起始位置
 * @param r 区间结束位置
 * @param s 首项
 * @param e 末项
 * @param d 公差
 */
void set(int l, int r, int s, int e, int d) {
    // 为了防止x - 3 * v + 1出现负数下标，进而有很多很烦的边界讨论
    // 所以任何位置，都加上一个较大的数字(OFFSET)
    // 这样一来，所有下标就都在0以上了，省去了大量边界讨论
    // 这就是为什么arr在初始化的时候要准备OFFSET + MAXN + OFFSET这么多的空间
    arr[l + OFFSET] += s;
    arr[l + 1 + OFFSET] += d - s;
    arr[r + 1 + OFFSET] -= d + e;
    arr[r + 2 + OFFSET] += e;
}

/**
 * 处理一个人落水的情况
 * 当体积为v的朋友在位置x落水时，会产生4个区域的水位变化
 * 
 * @param v 朋友体积
 * @param x 落水位置
 */
void fall(int v, int x) {
    // 区域1: [x - 3*v + 1, x - 2*v] 水位依次增加 1, 2, ..., v
    set(x - 3 * v + 1, x - 2 * v, 1, v, 1);
    // 区域2: [x - 2*v + 1, x] 水位依次减少 (v-1), (v-2), ..., 1, 0
    set(x - 2 * v + 1, x, v - 1, -v, -1);
    // 区域3: [x + 1, x + 2*v] 水位依次减少 -1, -2, ..., -v
    set(x + 1, x + 2 * v, -v + 1, v, 1);
    // 区域4: [x + 2*v + 1, x + 3*v - 1] 水位依次减少 (v-1), (v-2), ..., 1
    set(x + 2 * v + 1, x + 3 * v - 1, v - 1, 1, -1);
}

/**
 * 通过两次前缀和操作构建最终结果数组
 * 
 * @param m 湖泊宽度
 */
void build(int m) {
    // 第一次前缀和，得到一阶差分的结果
    for (int i = 1; i <= m + OFFSET; i++) {
        arr[i] += arr[i - 1];
    }
    // 第二次前缀和，得到最终结果
    for (int i = 1; i <= m + OFFSET; i++) {
        arr[i] += arr[i - 1];
    }
}

/**
 * 主函数，处理输入并输出结果
 * 
 * 解题思路:
 * 1. 使用偏移量处理防止负索引出现
 * 2. 对于每个人落水，产生4个区域的水位变化
 * 3. 使用等差数列差分技巧处理每个区域
 * 4. 通过两次前缀和操作得到最终水位数组
 * 
 * 时间复杂度: O(n + m + OFFSET) - 需要处理所有落水操作和数组两次前缀和
 * 空间复杂度: O(OFFSET + MAXN + OFFSET) - 需要存储差分数组
 * 
 * 工程化考量:
 * 1. 输入处理: 使用高效的输入处理方式
 * 2. 边界处理: 使用偏移量避免负索引
 * 3. 性能优化: 使用差分数组避免重复计算
 * 4. 输出格式: 按照题目要求输出结果
 */
int main() {
    int n, m;
    while (scanf("%d%d", &n, &m) != EOF) {
        // 初始化数组
        memset(arr, 0, sizeof(arr));
        
        // 处理每个人落水
        for (int i = 0, v, x; i < n; i++) {
            scanf("%d%d", &v, &x);
            // v体积的朋友，在x处落水，修改差分数组
            fall(v, x);
        }
        
        // 生成最终的水位数组
        build(m);
        
        // 开始收集答案
        // 0...OFFSET这些位置是辅助位置，为了防止越界设计的
        // 从OFFSET+1开始往下数m个，才是正式的位置1...m
        // 打印这些位置，就是返回正式位置1...m的水位
        int start = OFFSET + 1;
        printf("%d", arr[start++]);
        for (int i = 2; i <= m; i++) {
            printf(" %d", arr[start++]);
        }
        printf("\n");
    }
    
    return 0;
}

===============================================

文件: Code03_WaterHeight.java
===============================================
package class047;

// 一群人落水后求每个位置的水位高度
// 问题描述比较复杂，见测试链接
// 测试链接 : https://www.luogu.com.cn/problem/P5026
// 请同学们务必参考如下代码中关于输入、输出的处理
// 这是输入输出处理效率很高的写法
// 提交以下的code，提交时请把类名改成"Main"，可以直接通过
//
// 相关题目:
// 1. 洛谷 P5026 Lycanthropy
//    链接: https://www.luogu.com.cn/problem/P5026
//    题目描述: 一个朋友落水后会对水面产生影响。当体积为v的朋友在位置x落水时，
//             会产生特定的水位分布。具体影响范围和数值计算方式在题目中有详细说明。
//
// 2. 洛谷 P4231 三步必杀
//    链接: https://www.luogu.com.cn/problem/P4231
//    题目描述: 在区间上添加等差数列，使用二阶差分处理。
//
// 3. Codeforces 296C Greg and Array
//    链接: https://codeforces.com/contest/296/problem/C
//    题目描述: 多层差分操作，需要处理操作的操作。
//
// 偏移量处理核心思想:
// 在某些差分问题中，操作可能会影响数组边界外的位置，为了简化处理，
// 我们引入偏移量OFFSET，将所有操作都映射到正索引范围内。
//
// 对于本题:
// 1. 每个人落水会产生4个等差数列影响区域
// 2. 为了防止负索引出现，使用OFFSET偏移量
// 3. 最终结果数组大小为 OFFSET + MAXN + OFFSET
//
// 时间复杂度分析:
// 每次落水操作: O(1)
// 构造结果数组(两次前缀和): O(m + OFFSET)
// 总时间复杂度: O(n + m + OFFSET)
//
// 空间复杂度分析:
// 需要额外的数组空间: O(OFFSET + MAXN + OFFSET)
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;
import java.io.PrintWriter;
import java.io.StreamTokenizer;

public class Code03_WaterHeight {

	// 题目说了m <= 10^6，代表湖泊宽度
	// 这就是MAXN的含义，湖泊最大宽度的极限
	public static int MAXN = 1000001;

	// 数值保护，因为题目中v最大是10000
	// 所以左侧影响最远的位置到达了x - 3 * v + 1
	// 所以右侧影响最远的位置到达了x + 3 * v - 1
	// x如果是正式的位置(1~m)，那么左、右侧可能超过正式位置差不多30000的规模
	// 这就是OFFSET的含义
	public static int OFFSET = 30001;

	// 湖泊宽度是MAXN，是正式位置的范围
	// 左、右侧可能超过正式位置差不多OFFSET的规模
	// 所以准备一个长度为OFFSET + MAXN + OFFSET的数组
	// 这样一来，左侧影响最远的位置...右侧影响最远的位置，
	// 都可以被arr中的下标表示出来，就省去了很多越界讨论
	// 详细解释看set方法的注释
	public static int[] arr = new int[OFFSET + MAXN + OFFSET];

	public static int n, m;

	public static void main(String[] args) throws IOException {
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		StreamTokenizer in = new StreamTokenizer(br);
		PrintWriter out = new PrintWriter(new OutputStreamWriter(System.out));
		while (in.nextToken() != StreamTokenizer.TT_EOF) {
			// n有多少个人落水，每个人落水意味着四个等差数列操作
			n = (int) in.nval;
			in.nextToken();
			// 一共有多少位置，1~m个位置，最终要打印每个位置的水位
			m = (int) in.nval;
			for (int i = 0, v, x; i < n; i++) {
				in.nextToken(); v = (int) in.nval;
				in.nextToken(); x = (int) in.nval;
				// v体积的朋友，在x处落水，修改差分数组
				fall(v, x);
			}
			// 生成最终的水位数组
			build();
			// 开始收集答案
			// 0...OFFSET这些位置是辅助位置，为了防止越界设计的
			// 从OFFSET+1开始往下数m个，才是正式的位置1...m
			// 打印这些位置，就是返回正式位置1...m的水位
			int start = OFFSET + 1;
			out.print(arr[start++]);
			for (int i = 2; i <= m; i++) {
				out.print(" " + arr[start++]);
			}
			out.println();
		}
		out.flush();
		out.close();
		br.close();
	}

	// 处理一个人落水的情况
	// 当体积为v的朋友在位置x落水时，会产生4个区域的水位变化
	public static void fall(int v, int x) {
		// 区域1: [x - 3*v + 1, x - 2*v] 水位依次增加 1, 2, ..., v
		set(x - 3 * v + 1, x - 2 * v, 1, v, 1);
		// 区域2: [x - 2*v + 1, x] 水位依次减少 (v-1), (v-2), ..., 1, 0
		set(x - 2 * v + 1, x, v - 1, -v, -1);
		// 区域3: [x + 1, x + 2*v] 水位依次减少 -1, -2, ..., -v
		set(x + 1, x + 2 * v, -v + 1, v, 1);
		// 区域4: [x + 2*v + 1, x + 3*v - 1] 水位依次减少 (v-1), (v-2), ..., 1
		set(x + 2 * v + 1, x + 3 * v - 1, v - 1, 1, -1);
	}

	// 在区间[l,r]上加上首项为s、末项为e、公差为d的等差数列
	// 这是等差数列差分的核心操作
	public static void set(int l, int r, int s, int e, int d) {
		// 为了防止x - 3 * v + 1出现负数下标，进而有很多很烦的边界讨论
		// 所以任何位置，都加上一个较大的数字(OFFSET)
		// 这样一来，所有下标就都在0以上了，省去了大量边界讨论
		// 这就是为什么arr在初始化的时候要准备OFFSET + MAXN + OFFSET这么多的空间
		arr[l + OFFSET] += s;
		arr[l + 1 + OFFSET] += d - s;
		arr[r + 1 + OFFSET] -= d + e;
		arr[r + 2 + OFFSET] += e;
	}

	// 通过两次前缀和操作构建最终结果数组
	public static void build() {
		// 第一次前缀和，得到一阶差分的结果
		for (int i = 1; i <= m + OFFSET; i++) {
			arr[i] += arr[i - 1];
		}
		// 第二次前缀和，得到最终结果
		for (int i = 1; i <= m + OFFSET; i++) {
			arr[i] += arr[i - 1];
		}
	}

}

===============================================

文件: Code03_WaterHeight.py
===============================================
"""
洛谷 P5026 Lycanthropy

题目描述:
一个朋友落水后会对水面产生影响。当体积为v的朋友在位置x落水时，
会产生特定的水位分布。具体影响范围和数值计算方式在题目中有详细说明。

测试链接 : https://www.luogu.com.cn/problem/P5026

相关题目:
1. 洛谷 P5026 Lycanthropy
   链接: https://www.luogu.com.cn/problem/P5026
   题目描述: 一个朋友落水后会对水面产生影响。当体积为v的朋友在位置x落水时，
            会产生特定的水位分布。具体影响范围和数值计算方式在题目中有详细说明。

2. 洛谷 P4231 三步必杀
   链接: https://www.luogu.com.cn/problem/P4231
   题目描述: 在区间上添加等差数列，使用二阶差分处理。

3. Codeforces 296C Greg and Array
   链接: https://codeforces.com/contest/296/problem/C
   题目描述: 多层差分操作，需要处理操作的操作。

偏移量处理核心思想:
在某些差分问题中，操作可能会影响数组边界外的位置，为了简化处理，
我们引入偏移量OFFSET，将所有操作都映射到正索引范围内。

对于本题:
1. 每个人落水会产生4个等差数列影响区域
2. 为了防止负索引出现，使用OFFSET偏移量
3. 最终结果数组大小为 OFFSET + MAXN + OFFSET

时间复杂度分析:
每次落水操作: O(1)
构造结果数组(两次前缀和): O(m + OFFSET)
总时间复杂度: O(n + m + OFFSET)

空间复杂度分析:
需要额外的数组空间: O(OFFSET + MAXN + OFFSET)

这是最优解，因为:
1. 需要处理所有人落水的影响，无法避免O(n)的时间复杂度
2. 使用差分数组将区间更新操作从O(v)优化到O(1)
3. 最终需要计算所有位置的水位，需要O(m)时间
"""


def main():
    """
    主函数，处理输入并输出结果
    
    解题思路:
    1. 使用偏移量处理防止负索引出现
    2. 对于每个人落水，产生4个区域的水位变化
    3. 使用等差数列差分技巧处理每个区域
    4. 通过两次前缀和操作得到最终水位数组
    
    时间复杂度: O(n + m + OFFSET) - 需要处理所有落水操作和数组两次前缀和
    空间复杂度: O(OFFSET + MAXN + OFFSET) - 需要存储差分数组
    
    工程化考量:
    1. 输入处理: 使用高效的输入处理方式
    2. 边界处理: 使用偏移量避免负索引
    3. 性能优化: 使用差分数组避免重复计算
    4. 输出格式: 按照题目要求输出结果
    """
    try:
        while True:
            line = input().split()
            n = int(line[0])  # 落水人数
            m = int(line[1])  # 湖泊宽度
            
            # 题目说了m <= 10^6，代表湖泊宽度
            MAXN = 1000001
            
            # 数值保护，因为题目中v最大是10000
            # 所以左侧影响最远的位置到达了x - 3 * v + 1
            # 所以右侧影响最远的位置到达了x + 3 * v - 1
            # x如果是正式的位置(1~m)，那么左、右侧可能超过正式位置差不多30000的规模
            OFFSET = 30001
            
            # 湖泊宽度是MAXN，是正式位置的范围
            # 左、右侧可能超过正式位置差不多OFFSET的规模
            # 所以准备一个长度为OFFSET + MAXN + OFFSET的数组
            arr = [0] * (OFFSET + MAXN + OFFSET)
            
            # 处理每个人落水
            for _ in range(n):
                v, x = map(int, input().split())
                # v体积的朋友，在x处落水，修改差分数组
                fall(arr, v, x, OFFSET)
            
            # 生成最终的水位数组
            build(arr, m, OFFSET)
            
            # 开始收集答案
            # 0...OFFSET这些位置是辅助位置，为了防止越界设计的
            # 从OFFSET+1开始往下数m个，才是正式的位置1...m
            # 打印这些位置，就是返回正式位置1...m的水位
            start = OFFSET + 1
            result = []
            for i in range(m):
                result.append(str(arr[start + i]))
            
            print(" ".join(result))
            
    except EOFError:
        pass


def fall(arr, v, x, offset):
    """
    处理一个人落水的情况
    当体积为v的朋友在位置x落水时，会产生4个区域的水位变化
    
    Args:
        arr: 差分数组
        v: 朋友体积
        x: 落水位置
        offset: 偏移量
    """
    # 区域1: [x - 3*v + 1, x - 2*v] 水位依次增加 1, 2, ..., v
    set_diff(arr, x - 3 * v + 1, x - 2 * v, 1, v, 1, offset)
    # 区域2: [x - 2*v + 1, x] 水位依次减少 (v-1), (v-2), ..., 1, 0
    set_diff(arr, x - 2 * v + 1, x, v - 1, -v, -1, offset)
    # 区域3: [x + 1, x + 2*v] 水位依次减少 -1, -2, ..., -v
    set_diff(arr, x + 1, x + 2 * v, -v + 1, v, 1, offset)
    # 区域4: [x + 2*v + 1, x + 3*v - 1] 水位依次减少 (v-1), (v-2), ..., 1
    set_diff(arr, x + 2 * v + 1, x + 3 * v - 1, v - 1, 1, -1, offset)


def set_diff(arr, l, r, s, e, d, offset):
    """
    在区间[l,r]上加上首项为s、末项为e、公差为d的等差数列
    这是等差数列差分的核心操作
    
    Args:
        arr: 差分数组
        l: 区间起始位置
        r: 区间结束位置
        s: 首项
        e: 末项
        d: 公差
        offset: 偏移量
    """
    # 为了防止x - 3 * v + 1出现负数下标，进而有很多很烦的边界讨论
    # 所以任何位置，都加上一个较大的数字(offset)
    # 这样一来，所有下标就都在0以上了，省去了大量边界讨论
    arr[l + offset] += s
    arr[l + 1 + offset] += d - s
    arr[r + 1 + offset] -= d + e
    arr[r + 2 + offset] += e


def build(arr, m, offset):
    """
    通过两次前缀和操作构建最终结果数组
    
    Args:
        arr: 差分数组
        m: 湖泊宽度
        offset: 偏移量
    """
    # 第一次前缀和，得到一阶差分的结果
    for i in range(1, m + offset + 1):
        arr[i] += arr[i - 1]
    
    # 第二次前缀和，得到最终结果
    for i in range(1, m + offset + 1):
        arr[i] += arr[i - 1]


if __name__ == "__main__":
    main()

===============================================

文件: Code04_MaximumPopulationYear.cpp
===============================================
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

/**
 * LeetCode 1854. 人口最多的年份 (Maximum Population Year)
 * 
 * 题目描述:
 * 给你一个二维整数数组 logs，其中每个 logs[i] = [birth, death] 表示第 i 个人的出生和死亡年份。
 * 年份 x 的人口定义为这一年期间活着的人的数目。第 i 个人被计入年份 x 的人口需要满足：
 * x 在闭区间 [birth, death - 1] 内。注意，人不应当计入他们死亡当年的人口中。
 * 返回人口最多且最早的年份。
 * 
 * 示例:
 * 输入: logs = [[1993,1999],[2000,2010]]
 * 输出: 1993
 * 解释: 人口最多为 1，而 1993 是人口为 1 的最早年份。
 * 
 * 输入: logs = [[1950,1961],[1960,1971],[1970,1981]]
 * 输出: 1960
 * 解释: 人口最多为 2，分别在 1960 和 1970。其中最早年份是 1960。
 * 
 * 提示:
 * 1 <= logs.length <= 100
 * 1950 <= birth < death <= 2050
 * 
 * 题目链接: https://leetcode.com/problems/maximum-population-year/
 * 
 * 解题思路:
 * 使用差分数组技巧来处理区间更新操作。
 * 1. 创建一个差分数组diff，大小为101（年份范围1950-2050，共101年）
 * 2. 对于每个人[ birth, death ]，在差分数组中执行diff[birth-1950] += 1和diff[death-1950] -= 1
 * 3. 对差分数组计算前缀和，得到每年的实际人口数
 * 4. 找到人口最多且最早的年份
 * 
 * 时间复杂度: O(n + m) - n是logs长度，m是年份范围(101)
 * 空间复杂度: O(m) - 需要额外的差分数组空间
 * 
 * 这是最优解，因为需要处理所有记录，而且年份范围固定较小。
 */

class MaximumPopulationYear {
public:
    /**
     * 计算人口最多的年份
     * 
     * @param logs 人员出生和死亡年份数组
     * @return 人口最多且最早的年份
     */
    static int maximumPopulation(vector<vector<int>>& logs) {
        // 边界情况处理
        if (logs.empty()) {
            return 0;
        }
        
        // 年份范围是1950-2050，共101年
        const int START_YEAR = 1950;
        const int END_YEAR = 2050;
        const int YEAR_RANGE = END_YEAR - START_YEAR + 1;
        
        // 创建差分数组
        vector<int> diff(YEAR_RANGE, 0);
        
        // 处理每个人的生命周期
        for (const auto& log : logs) {
            int birth = log[0];      // 出生年份
            int death = log[1];      // 死亡年份
            
            // 在出生年份增加1个人
            diff[birth - START_YEAR] += 1;
            
            // 在死亡年份减少1个人（死亡当年不计入人口）
            if (death - START_YEAR < YEAR_RANGE) {
                diff[death - START_YEAR] -= 1;
            }
        }
        
        // 通过计算差分数组的前缀和得到每年的实际人口数，并记录最大值和对应年份
        int maxPopulation = 0;
        int earliestYear = START_YEAR;
        int currentPopulation = 0;
        
        for (int i = 0; i < YEAR_RANGE; i++) {
            currentPopulation += diff[i];
            
            // 更新最大人口数和最早年份
            if (currentPopulation > maxPopulation) {
                maxPopulation = currentPopulation;
                earliestYear = START_YEAR + i;
            }
        }
        
        return earliestYear;
    }
};

/**
 * 测试用例
 */
int main() {
    // 测试用例1
    vector<vector<int>> logs1 = {{1993, 1999}, {2000, 2010}};
    int result1 = MaximumPopulationYear::maximumPopulation(logs1);
    // 预期输出: 1993
    cout << "测试用例1: " << result1 << endl;

    // 测试用例2
    vector<vector<int>> logs2 = {{1950, 1961}, {1960, 1971}, {1970, 1981}};
    int result2 = MaximumPopulationYear::maximumPopulation(logs2);
    // 预期输出: 1960
    cout << "测试用例2: " << result2 << endl;
    
    // 测试用例3
    vector<vector<int>> logs3 = {{2008, 2026}, {2004, 2008}, {2034, 2035}, {1999, 2050}, {2049, 2050}, {2011, 2035}, {1966, 2033}};
    int result3 = MaximumPopulationYear::maximumPopulation(logs3);
    // 预期输出: 2011
    cout << "测试用例3: " << result3 << endl;
    
    return 0;
}

===============================================

文件: Code04_MaximumPopulationYear.java
===============================================
package class047;

/**
 * LeetCode 1854. 人口最多的年份 (Maximum Population Year)
 * 
 * 题目描述:
 * 给你一个二维整数数组 logs，其中每个 logs[i] = [birth, death] 表示第 i 个人的出生和死亡年份。
 * 年份 x 的人口定义为这一年期间活着的人的数目。第 i 个人被计入年份 x 的人口需要满足：
 * x 在闭区间 [birth, death - 1] 内。注意，人不应当计入他们死亡当年的人口中。
 * 返回人口最多且最早的年份。
 * 
 * 示例:
 * 输入: logs = [[1993,1999],[2000,2010]]
 * 输出: 1993
 * 解释: 人口最多为 1，而 1993 是人口为 1 的最早年份。
 * 
 * 输入: logs = [[1950,1961],[1960,1971],[1970,1981]]
 * 输出: 1960
 * 解释: 人口最多为 2，分别在 1960 和 1970。其中最早年份是 1960。
 * 
 * 提示:
 * 1 <= logs.length <= 100
 * 1950 <= birth < death <= 2050
 * 
 * 题目链接: https://leetcode.com/problems/maximum-population-year/
 * 
 * 解题思路:
 * 使用差分数组技巧来处理区间更新操作。
 * 1. 创建一个差分数组diff，大小为101（年份范围1950-2050，共101年）
 * 2. 对于每个人[ birth, death ]，在差分数组中执行diff[birth-1950] += 1和diff[death-1950] -= 1
 * 3. 对差分数组计算前缀和，得到每年的实际人口数
 * 4. 找到人口最多且最早的年份
 * 
 * 时间复杂度: O(n + m) - n是logs长度，m是年份范围(101)
 * 空间复杂度: O(m) - 需要额外的差分数组空间
 * 
 * 这是最优解，因为需要处理所有记录，而且年份范围固定较小。
 */
public class Code04_MaximumPopulationYear {

    /**
     * 计算人口最多的年份
     * 
     * @param logs 人员出生和死亡年份数组
     * @return 人口最多且最早的年份
     */
    public static int maximumPopulation(int[][] logs) {
        // 边界情况处理
        if (logs == null || logs.length == 0) {
            return 0;
        }
        
        // 年份范围是1950-2050，共101年
        final int START_YEAR = 1950;
        final int END_YEAR = 2050;
        final int YEAR_RANGE = END_YEAR - START_YEAR + 1;
        
        // 创建差分数组
        int[] diff = new int[YEAR_RANGE];
        
        // 处理每个人的生命周期
        for (int[] log : logs) {
            int birth = log[0];      // 出生年份
            int death = log[1];      // 死亡年份
            
            // 在出生年份增加1个人
            diff[birth - START_YEAR] += 1;
            
            // 在死亡年份减少1个人（死亡当年不计入人口）
            if (death - START_YEAR < YEAR_RANGE) {
                diff[death - START_YEAR] -= 1;
            }
        }
        
        // 通过计算差分数组的前缀和得到每年的实际人口数，并记录最大值和对应年份
        int maxPopulation = 0;
        int earliestYear = START_YEAR;
        int currentPopulation = 0;
        
        for (int i = 0; i < YEAR_RANGE; i++) {
            currentPopulation += diff[i];
            
            // 更新最大人口数和最早年份
            if (currentPopulation > maxPopulation) {
                maxPopulation = currentPopulation;
                earliestYear = START_YEAR + i;
            }
        }
        
        return earliestYear;
    }

    /**
     * 测试用例
     */
    public static void main(String[] args) {
        // 测试用例1
        int[][] logs1 = {{1993, 1999}, {2000, 2010}};
        int result1 = maximumPopulation(logs1);
        // 预期输出: 1993
        System.out.println("测试用例1: " + result1);

        // 测试用例2
        int[][] logs2 = {{1950, 1961}, {1960, 1971}, {1970, 1981}};
        int result2 = maximumPopulation(logs2);
        // 预期输出: 1960
        System.out.println("测试用例2: " + result2);
        
        // 测试用例3
        int[][] logs3 = {{2008, 2026}, {2004, 2008}, {2034, 2035}, {1999, 2050}, {2049, 2050}, {2011, 2035}, {1966, 2033}};
        int result3 = maximumPopulation(logs3);
        // 预期输出: 2011
        System.out.println("测试用例3: " + result3);
    }
}

===============================================

文件: Code04_MaximumPopulationYear.py
===============================================
"""
LeetCode 1854. 人口最多的年份 (Maximum Population Year)

题目描述:
给你一个二维整数数组 logs，其中每个 logs[i] = [birth, death] 表示第 i 个人的出生和死亡年份。
年份 x 的人口定义为这一年期间活着的人的数目。第 i 个人被计入年份 x 的人口需要满足：
x 在闭区间 [birth, death - 1] 内。注意，人不应当计入他们死亡当年的人口中。
返回人口最多且最早的年份。

示例:
输入: logs = [[1993,1999],[2000,2010]]
输出: 1993
解释: 人口最多为 1，而 1993 是人口为 1 的最早年份。

输入: logs = [[1950,1961],[1960,1971],[1970,1981]]
输出: 1960
解释: 人口最多为 2，分别在 1960 和 1970。其中最早年份是 1960。

提示:
1 <= logs.length <= 100
1950 <= birth < death <= 2050

题目链接: https://leetcode.com/problems/maximum-population-year/

解题思路:
使用差分数组技巧来处理区间更新操作。
1. 创建一个差分数组diff，大小为101（年份范围1950-2050，共101年）
2. 对于每个人[ birth, death ]，在差分数组中执行diff[birth-1950] += 1和diff[death-1950] -= 1
3. 对差分数组计算前缀和，得到每年的实际人口数
4. 找到人口最多且最早的年份

时间复杂度: O(n + m) - n是logs长度，m是年份范围(101)
空间复杂度: O(m) - 需要额外的差分数组空间

这是最优解，因为需要处理所有记录，而且年份范围固定较小。
"""


def maximum_population(logs):
    """
    计算人口最多的年份

    :param logs: 人员出生和死亡年份数组
    :return: 人口最多且最早的年份
    """
    # 边界情况处理
    if not logs:
        return 0

    # 年份范围是1950-2050，共101年
    START_YEAR = 1950
    END_YEAR = 2050
    YEAR_RANGE = END_YEAR - START_YEAR + 1

    # 创建差分数组
    diff = [0] * YEAR_RANGE

    # 处理每个人的生命周期
    for log in logs:
        birth = log[0]  # 出生年份
        death = log[1]  # 死亡年份

        # 在出生年份增加1个人
        diff[birth - START_YEAR] += 1

        # 在死亡年份减少1个人（死亡当年不计入人口）
        if death - START_YEAR < YEAR_RANGE:
            diff[death - START_YEAR] -= 1

    # 通过计算差分数组的前缀和得到每年的实际人口数，并记录最大值和对应年份
    max_population = 0
    earliest_year = START_YEAR
    current_population = 0

    for i in range(YEAR_RANGE):
        current_population += diff[i]

        # 更新最大人口数和最早年份
        if current_population > max_population:
            max_population = current_population
            earliest_year = START_YEAR + i

    return earliest_year


def main():
    """测试用例"""
    # 测试用例1
    logs1 = [[1993, 1999], [2000, 2010]]
    result1 = maximum_population(logs1)
    # 预期输出: 1993
    print("测试用例1:", result1)

    # 测试用例2
    logs2 = [[1950, 1961], [1960, 1971], [1970, 1981]]
    result2 = maximum_population(logs2)
    # 预期输出: 1960
    print("测试用例2:", result2)

    # 测试用例3
    logs3 = [[2008, 2026], [2004, 2008], [2034, 2035], [1999, 2050], [2049, 2050], [2011, 2035], [1966, 2033]]
    result3 = maximum_population(logs3)
    # 预期输出: 2011
    print("测试用例3:", result3)


if __name__ == "__main__":
    main()

===============================================

文件: Code05_HackerRankArrayManipulation.cpp
===============================================
#include <iostream>
#include <vector>
#include <algorithm>
#include <climits>
using namespace std;

/**
 * HackerRank Array Manipulation
 * 
 * 题目描述:
 * 给定一个大小为 n 的数组，初始值都为 0。有 m 次操作，
 * 每次操作给出三个数 a, b, k，表示将数组下标从 a 到 b 的所有元素都加上 k。
 * 求执行完所有操作后数组中的最大值。
 * 
 * 示例:
 * 输入: n = 5, queries = [[1,2,100],[2,5,100],[3,4,100]]
 * 输出: 200
 * 解释: 
 * 初始数组: [0, 0, 0, 0, 0]
 * 操作1: [100, 100, 0, 0, 0]
 * 操作2: [100, 200, 100, 100, 100]
 * 操作3: [100, 200, 200, 200, 100]
 * 最大值: 200
 * 
 * 提示:
 * 3 <= n <= 10^7
 * 1 <= m <= 2*10^5
 * 1 <= a <= b <= n
 * 0 <= k <= 10^9
 * 
 * 题目链接: https://www.hackerrank.com/challenges/crush/problem
 * 
 * 解题思路:
 * 使用差分数组技巧结合前缀和来优化区间更新操作。
 * 1. 创建一个差分数组diff，大小为n+1
 * 2. 对于每个操作[a,b,k]，执行diff[a-1] += k和diff[b] -= k
 * 3. 对差分数组计算前缀和，得到最终数组
 * 4. 在计算前缀和的过程中记录最大值
 * 
 * 时间复杂度: O(n + m) - 需要遍历所有操作和数组一次
 * 空间复杂度: O(n) - 需要额外的差分数组空间
 * 
 * 这是最优解，因为需要处理所有操作，而且数组大小可能很大，不能使用暴力方法。
 */

class HackerRankArrayManipulation {
public:
    /**
     * 计算数组操作后的最大值
     * 
     * @param n 数组长度
     * @param queries 操作数组，每个操作包含[起始索引, 结束索引, 增加值]
     * @return 操作后数组的最大值
     */
    static long long arrayManipulation(int n, vector<vector<int>>& queries) {
        // 边界情况处理
        if (n <= 0 || queries.empty()) {
            return 0;
        }
        
        // 创建差分数组，大小为n+1以便处理边界情况
        vector<long long> diff(n + 1, 0);
        
        // 处理每个操作
        for (const auto& query : queries) {
            int a = query[0];      // 起始索引（1-based）
            int b = query[1];      // 结束索引（1-based）
            int k = query[2];      // 增加值
            
            // 在差分数组中标记区间更新
            diff[a - 1] += k;      // 在起始位置增加k
            if (b < n) {
                diff[b] -= k;      // 在结束位置之后减少k
            }
        }
        
        // 通过计算差分数组的前缀和得到最终数组，并记录最大值
        long long maxVal = LLONG_MIN;
        long long currentSum = 0;
        
        for (int i = 0; i < n; i++) {
            currentSum += diff[i];
            maxVal = max(maxVal, currentSum);
        }
        
        return maxVal;
    }
};

/**
 * 测试用例
 */
int main() {
    // 测试用例1
    vector<vector<int>> queries1 = {{1, 2, 100}, {2, 5, 100}, {3, 4, 100}};
    long long result1 = HackerRankArrayManipulation::arrayManipulation(5, queries1);
    // 预期输出: 200
    cout << "测试用例1: " << result1 << endl;

    // 测试用例2
    vector<vector<int>> queries2 = {{2, 6, 8}, {3, 5, 7}, {1, 8, 1}, {5, 9, 15}};
    long long result2 = HackerRankArrayManipulation::arrayManipulation(10, queries2);
    // 预期输出: 31
    cout << "测试用例2: " << result2 << endl;
    
    // 测试用例3
    vector<vector<int>> queries3 = {{1, 2, 5}, {2, 4, 10}, {1, 3, 3}};
    long long result3 = HackerRankArrayManipulation::arrayManipulation(4, queries3);
    // 预期输出: 18
    cout << "测试用例3: " << result3 << endl;
    
    return 0;
}

===============================================

文件: Code05_HackerRankArrayManipulation.java
===============================================
package class047;

/**
 * HackerRank Array Manipulation
 * 
 * 题目描述:
 * 给定一个大小为 n 的数组，初始值都为 0。有 m 次操作，
 * 每次操作给出三个数 a, b, k，表示将数组下标从 a 到 b 的所有元素都加上 k。
 * 求执行完所有操作后数组中的最大值。
 * 
 * 示例:
 * 输入: n = 5, queries = [[1,2,100],[2,5,100],[3,4,100]]
 * 输出: 200
 * 解释: 
 * 初始数组: [0, 0, 0, 0, 0]
 * 操作1: [100, 100, 0, 0, 0]
 * 操作2: [100, 200, 100, 100, 100]
 * 操作3: [100, 200, 200, 200, 100]
 * 最大值: 200
 * 
 * 提示:
 * 3 <= n <= 10^7
 * 1 <= m <= 2*10^5
 * 1 <= a <= b <= n
 * 0 <= k <= 10^9
 * 
 * 题目链接: https://www.hackerrank.com/challenges/crush/problem
 * 
 * 解题思路:
 * 使用差分数组技巧结合前缀和来优化区间更新操作。
 * 1. 创建一个差分数组diff，大小为n+1
 * 2. 对于每个操作[a,b,k]，执行diff[a-1] += k和diff[b] -= k
 * 3. 对差分数组计算前缀和，得到最终数组
 * 4. 在计算前缀和的过程中记录最大值
 * 
 * 时间复杂度: O(n + m) - 需要遍历所有操作和数组一次
 * 空间复杂度: O(n) - 需要额外的差分数组空间
 * 
 * 这是最优解，因为需要处理所有操作，而且数组大小可能很大，不能使用暴力方法。
 */
public class Code05_HackerRankArrayManipulation {

    /**
     * 计算数组操作后的最大值
     * 
     * @param n 数组长度
     * @param queries 操作数组，每个操作包含[起始索引, 结束索引, 增加值]
     * @return 操作后数组的最大值
     */
    public static long arrayManipulation(int n, int[][] queries) {
        // 边界情况处理
        if (n <= 0 || queries == null || queries.length == 0) {
            return 0;
        }
        
        // 创建差分数组，大小为n+1以便处理边界情况
        long[] diff = new long[n + 1];
        
        // 处理每个操作
        for (int[] query : queries) {
            int a = query[0];      // 起始索引（1-based）
            int b = query[1];      // 结束索引（1-based）
            int k = query[2];      // 增加值
            
            // 在差分数组中标记区间更新
            diff[a - 1] += k;      // 在起始位置增加k
            if (b < n) {
                diff[b] -= k;      // 在结束位置之后减少k
            }
        }
        
        // 通过计算差分数组的前缀和得到最终数组，并记录最大值
        long maxVal = Long.MIN_VALUE;
        long currentSum = 0;
        
        for (int i = 0; i < n; i++) {
            currentSum += diff[i];
            if (currentSum > maxVal) {
                maxVal = currentSum;
            }
        }
        
        return maxVal;
    }

    /**
     * 测试用例
     */
    public static void main(String[] args) {
        // 测试用例1
        int n1 = 5;
        int[][] queries1 = {{1, 2, 100}, {2, 5, 100}, {3, 4, 100}};
        long result1 = arrayManipulation(n1, queries1);
        // 预期输出: 200
        System.out.println("测试用例1: " + result1);

        // 测试用例2
        int n2 = 10;
        int[][] queries2 = {{2, 6, 8}, {3, 5, 7}, {1, 8, 1}, {5, 9, 15}};
        long result2 = arrayManipulation(n2, queries2);
        // 预期输出: 31
        System.out.println("测试用例2: " + result2);
        
        // 测试用例3
        int n3 = 4;
        int[][] queries3 = {{1, 2, 5}, {2, 4, 10}, {1, 3, 3}};
        long result3 = arrayManipulation(n3, queries3);
        // 预期输出: 18
        System.out.println("测试用例3: " + result3);
    }
}

===============================================

文件: Code05_HackerRankArrayManipulation.py
===============================================
"""
HackerRank Array Manipulation

题目描述:
给定一个大小为 n 的数组，初始值都为 0。有 m 次操作，
每次操作给出三个数 a, b, k，表示将数组下标从 a 到 b 的所有元素都加上 k。
求执行完所有操作后数组中的最大值。

示例:
输入: n = 5, queries = [[1,2,100],[2,5,100],[3,4,100]]
输出: 200
解释: 
初始数组: [0, 0, 0, 0, 0]
操作1: [100, 100, 0, 0, 0]
操作2: [100, 200, 100, 100, 100]
操作3: [100, 200, 200, 200, 100]
最大值: 200

提示:
3 <= n <= 10^7
1 <= m <= 2*10^5
1 <= a <= b <= n
0 <= k <= 10^9

题目链接: https://www.hackerrank.com/challenges/crush/problem

解题思路:
使用差分数组技巧结合前缀和来优化区间更新操作。
1. 创建一个差分数组diff，大小为n+1
2. 对于每个操作[a,b,k]，执行diff[a-1] += k和diff[b] -= k
3. 对差分数组计算前缀和，得到最终数组
4. 在计算前缀和的过程中记录最大值

时间复杂度: O(n + m) - 需要遍历所有操作和数组一次
空间复杂度: O(n) - 需要额外的差分数组空间

这是最优解，因为需要处理所有操作，而且数组大小可能很大，不能使用暴力方法。
"""


def array_manipulation(n, queries):
    """
    计算数组操作后的最大值

    :param n: 数组长度
    :param queries: 操作数组，每个操作包含[起始索引, 结束索引, 增加值]
    :return: 操作后数组的最大值
    """
    # 边界情况处理
    if n <= 0 or not queries:
        return 0

    # 创建差分数组，大小为n+1以便处理边界情况
    diff = [0] * (n + 1)

    # 处理每个操作
    for query in queries:
        a = query[0]      # 起始索引（1-based）
        b = query[1]      # 结束索引（1-based）
        k = query[2]      # 增加值

        # 在差分数组中标记区间更新
        diff[a - 1] += k      # 在起始位置增加k
        if b < n:
            diff[b] -= k      # 在结束位置之后减少k

    # 通过计算差分数组的前缀和得到最终数组，并记录最大值
    max_val = float('-inf')
    current_sum = 0

    for i in range(n):
        current_sum += diff[i]
        max_val = max(max_val, current_sum)

    return max_val


def main():
    """测试用例"""
    # 测试用例1
    n1 = 5
    queries1 = [[1, 2, 100], [2, 5, 100], [3, 4, 100]]
    result1 = array_manipulation(n1, queries1)
    # 预期输出: 200
    print("测试用例1:", result1)

    # 测试用例2
    n2 = 10
    queries2 = [[2, 6, 8], [3, 5, 7], [1, 8, 1], [5, 9, 15]]
    result2 = array_manipulation(n2, queries2)
    # 预期输出: 31
    print("测试用例2:", result2)

    # 测试用例3
    n3 = 4
    queries3 = [[1, 2, 5], [2, 4, 10], [1, 3, 3]]
    result3 = array_manipulation(n3, queries3)
    # 预期输出: 18
    print("测试用例3:", result3)


if __name__ == "__main__":
    main()

===============================================

文件: Code06_CarPooling.cpp
===============================================
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

/**
 * LeetCode 1094. 拼车 (Car Pooling)
 * 
 * 题目描述:
 * 假设你是一位顺风车司机，车上最初有 capacity 个空座位可以用来载客。
 * 由于道路拥堵，你只能向一个方向行驶。
 * 给定一个数组 trips，其中 trips[i] = [num_passengers, start, end]
 * 表示第 i 次旅行有 num_passengers 位乘客，接他们和放他们的位置分别是 start 和 end。
 * 这些位置是从你的初始位置向东的公里数。
 * 当且仅当你可以在所有给定的行程中接送所有乘客时，返回 true，否则返回 false。
 * 
 * 示例:
 * 输入: trips = [[2,1,5],[3,3,7]], capacity = 4
 * 输出: false
 * 
 * 输入: trips = [[2,1,5],[3,3,7]], capacity = 5
 * 输出: true
 * 
 * 提示:
 * 1 <= trips.length <= 1000
 * trips[i].length == 3
 * 1 <= num_passengersi <= 100
 * 0 <= fromi < toi <= 1000
 * 1 <= capacity <= 10^5
 * 
 * 题目链接: https://leetcode.com/problems/car-pooling/
 * 
 * 解题思路:
 * 使用差分数组技巧来处理区间更新操作。
 * 1. 创建一个差分数组diff，大小为1001（题目提示toi <= 1000）
 * 2. 对于每次旅行[passengers, start, end]，在差分数组中执行diff[start] += passengers和diff[end] -= passengers
 * 3. 对差分数组计算前缀和，得到每个位置的实际乘客数
 * 4. 检查是否有任何位置的乘客数超过capacity
 * 
 * 时间复杂度: O(n + m) - n是trips长度，m是位置范围(1001)
 * 空间复杂度: O(m) - 需要额外的差分数组空间
 * 
 * 这是最优解，因为需要处理所有行程，而且位置范围固定。
 */

class CarPooling {
public:
    /**
     * 判断是否可以完成所有行程
     * 
     * @param trips 行程数组，每个行程包含[乘客数, 起点, 终点]
     * @param capacity 车辆容量
     * @return 是否可以完成所有行程
     */
    static bool carPooling(vector<vector<int>>& trips, int capacity) {
        // 边界情况处理
        if (trips.empty()) {
            return true;
        }
        
        // 位置范围是0-1000，共1001个位置
        const int MAX_POSITION = 1001;
        
        // 创建差分数组
        vector<int> diff(MAX_POSITION, 0);
        
        // 处理每次行程
        for (const auto& trip : trips) {
            int passengers = trip[0];  // 乘客数
            int start = trip[1];       // 起点
            int end = trip[2];         // 终点
            
            // 在起点增加乘客
            diff[start] += passengers;
            
            // 在终点减少乘客（乘客在此下车）
            diff[end] -= passengers;
        }
        
        // 通过计算差分数组的前缀和得到每个位置的实际乘客数
        int currentPassengers = 0;
        for (int i = 0; i < MAX_POSITION; i++) {
            currentPassengers += diff[i];
            
            // 如果任何位置的乘客数超过容量，返回false
            if (currentPassengers > capacity) {
                return false;
            }
        }
        
        return true;
    }
};

/**
 * 测试用例
 */
int main() {
    // 测试用例1
    vector<vector<int>> trips1 = {{2, 1, 5}, {3, 3, 7}};
    bool result1 = CarPooling::carPooling(trips1, 4);
    // 预期输出: false
    cout << "测试用例1: " << (result1 ? "true" : "false") << endl;

    // 测试用例2
    vector<vector<int>> trips2 = {{2, 1, 5}, {3, 3, 7}};
    bool result2 = CarPooling::carPooling(trips2, 5);
    // 预期输出: true
    cout << "测试用例2: " << (result2 ? "true" : "false") << endl;
    
    // 测试用例3
    vector<vector<int>> trips3 = {{2, 1, 5}, {3, 5, 7}};
    bool result3 = CarPooling::carPooling(trips3, 3);
    // 预期输出: true
    cout << "测试用例3: " << (result3 ? "true" : "false") << endl;
    
    // 测试用例4
    vector<vector<int>> trips4 = {{3, 2, 7}, {3, 7, 9}, {8, 3, 9}};
    bool result4 = CarPooling::carPooling(trips4, 11);
    // 预期输出: true
    cout << "测试用例4: " << (result4 ? "true" : "false") << endl;
    
    return 0;
}

===============================================

文件: Code06_CarPooling.java
===============================================
package class047;

/**
 * LeetCode 1094. 拼车 (Car Pooling)
 * 
 * 题目描述:
 * 假设你是一位顺风车司机，车上最初有 capacity 个空座位可以用来载客。
 * 由于道路拥堵，你只能向一个方向行驶。
 * 给定一个数组 trips，其中 trips[i] = [num_passengers, start, end]
 * 表示第 i 次旅行有 num_passengers 位乘客，接他们和放他们的位置分别是 start 和 end。
 * 这些位置是从你的初始位置向东的公里数。
 * 当且仅当你可以在所有给定的行程中接送所有乘客时，返回 true，否则返回 false。
 * 
 * 示例:
 * 输入: trips = [[2,1,5],[3,3,7]], capacity = 4
 * 输出: false
 * 
 * 输入: trips = [[2,1,5],[3,3,7]], capacity = 5
 * 输出: true
 * 
 * 提示:
 * 1 <= trips.length <= 1000
 * trips[i].length == 3
 * 1 <= num_passengersi <= 100
 * 0 <= fromi < toi <= 1000
 * 1 <= capacity <= 10^5
 * 
 * 题目链接: https://leetcode.com/problems/car-pooling/
 * 
 * 解题思路:
 * 使用差分数组技巧来处理区间更新操作。
 * 1. 创建一个差分数组diff，大小为1001（题目提示toi <= 1000）
 * 2. 对于每次旅行[passengers, start, end]，在差分数组中执行diff[start] += passengers和diff[end] -= passengers
 * 3. 对差分数组计算前缀和，得到每个位置的实际乘客数
 * 4. 检查是否有任何位置的乘客数超过capacity
 * 
 * 时间复杂度: O(n + m) - n是trips长度，m是位置范围(1001)
 * 空间复杂度: O(m) - 需要额外的差分数组空间
 * 
 * 这是最优解，因为需要处理所有行程，而且位置范围固定。
 */
public class Code06_CarPooling {

    /**
     * 判断是否可以完成所有行程
     * 
     * @param trips 行程数组，每个行程包含[乘客数, 起点, 终点]
     * @param capacity 车辆容量
     * @return 是否可以完成所有行程
     */
    public static boolean carPooling(int[][] trips, int capacity) {
        // 边界情况处理
        if (trips == null || trips.length == 0) {
            return true;
        }
        
        // 位置范围是0-1000，共1001个位置
        final int MAX_POSITION = 1001;
        
        // 创建差分数组
        int[] diff = new int[MAX_POSITION];
        
        // 处理每次行程
        for (int[] trip : trips) {
            int passengers = trip[0];  // 乘客数
            int start = trip[1];       // 起点
            int end = trip[2];         // 终点
            
            // 在起点增加乘客
            diff[start] += passengers;
            
            // 在终点减少乘客（乘客在此下车）
            diff[end] -= passengers;
        }
        
        // 通过计算差分数组的前缀和得到每个位置的实际乘客数
        int currentPassengers = 0;
        for (int i = 0; i < MAX_POSITION; i++) {
            currentPassengers += diff[i];
            
            // 如果任何位置的乘客数超过容量，返回false
            if (currentPassengers > capacity) {
                return false;
            }
        }
        
        return true;
    }

    /**
     * 测试用例
     */
    public static void main(String[] args) {
        // 测试用例1
        int[][] trips1 = {{2, 1, 5}, {3, 3, 7}};
        int capacity1 = 4;
        boolean result1 = carPooling(trips1, capacity1);
        // 预期输出: false
        System.out.println("测试用例1: " + result1);

        // 测试用例2
        int[][] trips2 = {{2, 1, 5}, {3, 3, 7}};
        int capacity2 = 5;
        boolean result2 = carPooling(trips2, capacity2);
        // 预期输出: true
        System.out.println("测试用例2: " + result2);
        
        // 测试用例3
        int[][] trips3 = {{2, 1, 5}, {3, 5, 7}};
        int capacity3 = 3;
        boolean result3 = carPooling(trips3, capacity3);
        // 预期输出: true
        System.out.println("测试用例3: " + result3);
        
        // 测试用例4
        int[][] trips4 = {{3, 2, 7}, {3, 7, 9}, {8, 3, 9}};
        int capacity4 = 11;
        boolean result4 = carPooling(trips4, capacity4);
        // 预期输出: true
        System.out.println("测试用例4: " + result4);
    }
}

===============================================

文件: Code06_CarPooling.py
===============================================
"""
LeetCode 1094. 拼车 (Car Pooling)

题目描述:
假设你是一位顺风车司机，车上最初有 capacity 个空座位可以用来载客。
由于道路拥堵，你只能向一个方向行驶。
给定一个数组 trips，其中 trips[i] = [num_passengers, start, end]
表示第 i 次旅行有 num_passengers 位乘客，接他们和放他们的位置分别是 start 和 end。
这些位置是从你的初始位置向东的公里数。
当且仅当你可以在所有给定的行程中接送所有乘客时，返回 true，否则返回 false。

示例:
输入: trips = [[2,1,5],[3,3,7]], capacity = 4
输出: false

输入: trips = [[2,1,5],[3,3,7]], capacity = 5
输出: true

提示:
1 <= trips.length <= 1000
trips[i].length == 3
1 <= num_passengersi <= 100
0 <= fromi < toi <= 1000
1 <= capacity <= 10^5

题目链接: https://leetcode.com/problems/car-pooling/

解题思路:
使用差分数组技巧来处理区间更新操作。
1. 创建一个差分数组diff，大小为1001（题目提示toi <= 1000）
2. 对于每次旅行[passengers, start, end]，在差分数组中执行diff[start] += passengers和diff[end] -= passengers
3. 对差分数组计算前缀和，得到每个位置的实际乘客数
4. 检查是否有任何位置的乘客数超过capacity

时间复杂度: O(n + m) - n是trips长度，m是位置范围(1001)
空间复杂度: O(m) - 需要额外的差分数组空间

这是最优解，因为需要处理所有行程，而且位置范围固定。
"""


def car_pooling(trips, capacity):
    """
    判断是否可以完成所有行程

    :param trips: 行程数组，每个行程包含[乘客数, 起点, 终点]
    :param capacity: 车辆容量
    :return: 是否可以完成所有行程
    """
    # 边界情况处理
    if not trips:
        return True
    
    # 位置范围是0-1000，共1001个位置
    MAX_POSITION = 1001
    
    # 创建差分数组
    diff = [0] * MAX_POSITION
    
    # 处理每次行程
    for trip in trips:
        passengers = trip[0]  # 乘客数
        start = trip[1]       # 起点
        end = trip[2]         # 终点
        
        # 在起点增加乘客
        diff[start] += passengers
        
        # 在终点减少乘客（乘客在此下车）
        diff[end] -= passengers
    
    # 通过计算差分数组的前缀和得到每个位置的实际乘客数
    current_passengers = 0
    for i in range(MAX_POSITION):
        current_passengers += diff[i]
        
        # 如果任何位置的乘客数超过容量，返回False
        if current_passengers > capacity:
            return False
    
    return True


def main():
    """测试用例"""
    # 测试用例1
    trips1 = [[2, 1, 5], [3, 3, 7]]
    capacity1 = 4
    result1 = car_pooling(trips1, capacity1)
    # 预期输出: False
    print("测试用例1:", result1)

    # 测试用例2
    trips2 = [[2, 1, 5], [3, 3, 7]]
    capacity2 = 5
    result2 = car_pooling(trips2, capacity2)
    # 预期输出: True
    print("测试用例2:", result2)
    
    # 测试用例3
    trips3 = [[2, 1, 5], [3, 5, 7]]
    capacity3 = 3
    result3 = car_pooling(trips3, capacity3)
    # 预期输出: True
    print("测试用例3:", result3)
    
    # 测试用例4
    trips4 = [[3, 2, 7], [3, 7, 9], [8, 3, 9]]
    capacity4 = 11
    result4 = car_pooling(trips4, capacity4)
    # 预期输出: True
    print("测试用例4:", result4)


if __name__ == "__main__":
    main()

===============================================

文件: Code07_RangeAddition.cpp
===============================================
#include <iostream>
#include <vector>
using namespace std;

/**
 * LeetCode 370. 区间加法 (Range Addition)
 * 
 * 题目描述:
 * 假设你有一个长度为 n 的数组，初始情况下所有的数字均为 0，
 * 你将会被给出 k 个更新的操作。其中，每个操作会被表示为一个三元组：
 * [startIndex, endIndex, inc]，你需要将子数组 A[startIndex ... endIndex]
 * （包括 startIndex 和 endIndex）增加 inc。
 * 请你返回 k 次操作后的数组。
 * 
 * 示例:
 * 输入: length = 5, updates = [[1,3,2],[2,4,3],[0,2,-2]]
 * 输出: [-2,0,3,5,3]
 * 解释:
 * 初始状态: [0,0,0,0,0]
 * 进行了操作 [1,3,2] 后的状态: [0,2,2,2,0]
 * 进行了操作 [2,4,3] 后的状态: [0,2,5,5,3]
 * 进行了操作 [0,2,-2] 后的状态: [-2,0,3,5,3]
 * 
 * 提示:
 * 1 <= length <= 10^5
 * 0 <= updates.length <= 10^4
 * 0 <= startIndex <= endIndex < length
 * -1000 <= inc <= 1000
 * 
 * 题目链接: https://leetcode.com/problems/range-addition/
 * 
 * 解题思路:
 * 使用差分数组技巧来处理区间更新操作。
 * 1. 创建一个差分数组diff，大小为length
 * 2. 对于每个操作[start, end, inc]，在差分数组中执行diff[start] += inc和diff[end+1] -= inc
 * 3. 对差分数组计算前缀和，得到最终结果数组
 * 
 * 时间复杂度: O(n + k) - n是数组长度，k是操作次数
 * 空间复杂度: O(n) - 需要额外的差分数组空间
 * 
 * 这是最优解，因为需要处理所有操作，而且数组长度可能很大。
 */

class RangeAddition {
public:
    /**
     * 执行区间加法操作并返回结果数组
     * 
     * @param length 数组长度
     * @param updates 操作数组，每个操作包含[起始索引, 结束索引, 增加值]
     * @return 操作后的数组
     */
    static vector<int> getModifiedArray(int length, vector<vector<int>>& updates) {
        // 边界情况处理
        if (length <= 0) {
            return {};
        }
        
        if (updates.empty()) {
            return vector<int>(length, 0);
        }
        
        // 创建差分数组
        vector<int> diff(length, 0);
        
        // 处理每个操作
        for (const auto& update : updates) {
            int start = update[0];   // 起始索引
            int end = update[1];     // 结束索引
            int inc = update[2];     // 增加值
            
            // 在差分数组中标记区间更新
            diff[start] += inc;      // 在起始位置增加inc
            
            // 在结束位置之后减少inc（如果end+1在数组范围内）
            if (end + 1 < length) {
                diff[end + 1] -= inc;
            }
        }
        
        // 通过计算差分数组的前缀和得到最终数组
        for (int i = 1; i < length; i++) {
            diff[i] += diff[i - 1];
        }
        
        return diff;
    }
};

/**
 * 测试用例
 */
int main() {
    // 测试用例1
    vector<vector<int>> updates1 = {{1, 3, 2}, {2, 4, 3}, {0, 2, -2}};
    vector<int> result1 = RangeAddition::getModifiedArray(5, updates1);
    // 预期输出: [-2, 0, 3, 5, 3]
    cout << "测试用例1: ";
    for (int i = 0; i < result1.size(); i++) {
        cout << result1[i] << (i == result1.size() - 1 ? "\n" : ", ");
    }

    // 测试用例2
    vector<vector<int>> updates2 = {{2, 4, 6}, {0, 6, -4}, {5, 7, 3}};
    vector<int> result2 = RangeAddition::getModifiedArray(10, updates2);
    // 预期输出: [-4, -4, 2, 2, 2, -1, -1, -1, 0, 0]
    cout << "测试用例2: ";
    for (int i = 0; i < result2.size(); i++) {
        cout << result2[i] << (i == result2.size() - 1 ? "\n" : ", ");
    }
    
    // 测试用例3
    vector<vector<int>> updates3 = {{0, 2, 1}};
    vector<int> result3 = RangeAddition::getModifiedArray(3, updates3);
    // 预期输出: [1, 1, 1]
    cout << "测试用例3: ";
    for (int i = 0; i < result3.size(); i++) {
        cout << result3[i] << (i == result3.size() - 1 ? "\n" : ", ");
    }
    
    return 0;
}

===============================================

文件: Code07_RangeAddition.java
===============================================
package class047;

/**
 * LeetCode 370. 区间加法 (Range Addition)
 * 
 * 题目描述:
 * 假设你有一个长度为 n 的数组，初始情况下所有的数字均为 0，
 * 你将会被给出 k 个更新的操作。其中，每个操作会被表示为一个三元组：
 * [startIndex, endIndex, inc]，你需要将子数组 A[startIndex ... endIndex]
 * （包括 startIndex 和 endIndex）增加 inc。
 * 请你返回 k 次操作后的数组。
 * 
 * 示例:
 * 输入: length = 5, updates = [[1,3,2],[2,4,3],[0,2,-2]]
 * 输出: [-2,0,3,5,3]
 * 解释:
 * 初始状态: [0,0,0,0,0]
 * 进行了操作 [1,3,2] 后的状态: [0,2,2,2,0]
 * 进行了操作 [2,4,3] 后的状态: [0,2,5,5,3]
 * 进行了操作 [0,2,-2] 后的状态: [-2,0,3,5,3]
 * 
 * 提示:
 * 1 <= length <= 10^5
 * 0 <= updates.length <= 10^4
 * 0 <= startIndex <= endIndex < length
 * -1000 <= inc <= 1000
 * 
 * 题目链接: https://leetcode.com/problems/range-addition/
 * 
 * 解题思路:
 * 使用差分数组技巧来处理区间更新操作。
 * 1. 创建一个差分数组diff，大小为length
 * 2. 对于每个操作[start, end, inc]，在差分数组中执行diff[start] += inc和diff[end+1] -= inc
 * 3. 对差分数组计算前缀和，得到最终结果数组
 * 
 * 时间复杂度: O(n + k) - n是数组长度，k是操作次数
 * 空间复杂度: O(n) - 需要额外的差分数组空间
 * 
 * 这是最优解，因为需要处理所有操作，而且数组长度可能很大。
 */
public class Code07_RangeAddition {

    /**
     * 执行区间加法操作并返回结果数组
     * 
     * @param length 数组长度
     * @param updates 操作数组，每个操作包含[起始索引, 结束索引, 增加值]
     * @return 操作后的数组
     */
    public static int[] getModifiedArray(int length, int[][] updates) {
        // 边界情况处理
        if (length <= 0) {
            return new int[0];
        }
        
        if (updates == null || updates.length == 0) {
            return new int[length];
        }
        
        // 创建差分数组
        int[] diff = new int[length];
        
        // 处理每个操作
        for (int[] update : updates) {
            int start = update[0];   // 起始索引
            int end = update[1];     // 结束索引
            int inc = update[2];     // 增加值
            
            // 在差分数组中标记区间更新
            diff[start] += inc;      // 在起始位置增加inc
            
            // 在结束位置之后减少inc（如果end+1在数组范围内）
            if (end + 1 < length) {
                diff[end + 1] -= inc;
            }
        }
        
        // 通过计算差分数组的前缀和得到最终数组
        for (int i = 1; i < length; i++) {
            diff[i] += diff[i - 1];
        }
        
        return diff;
    }

    /**
     * 测试用例
     */
    public static void main(String[] args) {
        // 测试用例1
        int length1 = 5;
        int[][] updates1 = {{1, 3, 2}, {2, 4, 3}, {0, 2, -2}};
        int[] result1 = getModifiedArray(length1, updates1);
        // 预期输出: [-2, 0, 3, 5, 3]
        System.out.print("测试用例1: ");
        for (int i = 0; i < result1.length; i++) {
            System.out.print(result1[i] + (i == result1.length - 1 ? "\n" : ", "));
        }

        // 测试用例2
        int length2 = 10;
        int[][] updates2 = {{2, 4, 6}, {0, 6, -4}, {5, 7, 3}};
        int[] result2 = getModifiedArray(length2, updates2);
        // 预期输出: [-4, -4, 2, 2, 2, -1, -1, -1, 0, 0]
        System.out.print("测试用例2: ");
        for (int i = 0; i < result2.length; i++) {
            System.out.print(result2[i] + (i == result2.length - 1 ? "\n" : ", "));
        }
        
        // 测试用例3
        int length3 = 3;
        int[][] updates3 = {{0, 2, 1}};
        int[] result3 = getModifiedArray(length3, updates3);
        // 预期输出: [1, 1, 1]
        System.out.print("测试用例3: ");
        for (int i = 0; i < result3.length; i++) {
            System.out.print(result3[i] + (i == result3.length - 1 ? "\n" : ", "));
        }
    }
}

===============================================

文件: Code07_RangeAddition.py
===============================================
"""
LeetCode 370. 区间加法 (Range Addition)

题目描述:
假设你有一个长度为 n 的数组，初始情况下所有的数字均为 0，
你将会被给出 k 个更新的操作。其中，每个操作会被表示为一个三元组：
[startIndex, endIndex, inc]，你需要将子数组 A[startIndex ... endIndex]
（包括 startIndex 和 endIndex）增加 inc。
请你返回 k 次操作后的数组。

示例:
输入: length = 5, updates = [[1,3,2],[2,4,3],[0,2,-2]]
输出: [-2,0,3,5,3]
解释:
初始状态: [0,0,0,0,0]
进行了操作 [1,3,2] 后的状态: [0,2,2,2,0]
进行了操作 [2,4,3] 后的状态: [0,2,5,5,3]
进行了操作 [0,2,-2] 后的状态: [-2,0,3,5,3]

提示:
1 <= length <= 10^5
0 <= updates.length <= 10^4
0 <= startIndex <= endIndex < length
-1000 <= inc <= 1000

题目链接: https://leetcode.com/problems/range-addition/

解题思路:
使用差分数组技巧来处理区间更新操作。
1. 创建一个差分数组diff，大小为length
2. 对于每个操作[start, end, inc]，在差分数组中执行diff[start] += inc和diff[end+1] -= inc
3. 对差分数组计算前缀和，得到最终结果数组

时间复杂度: O(n + k) - n是数组长度，k是操作次数
空间复杂度: O(n) - 需要额外的差分数组空间

这是最优解，因为需要处理所有操作，而且数组长度可能很大。
"""


def get_modified_array(length, updates):
    """
    执行区间加法操作并返回结果数组

    :param length: 数组长度
    :param updates: 操作数组，每个操作包含[起始索引, 结束索引, 增加值]
    :return: 操作后的数组
    """
    # 边界情况处理
    if length <= 0:
        return []
    
    if not updates:
        return [0] * length
    
    # 创建差分数组
    diff = [0] * length
    
    # 处理每个操作
    for update in updates:
        start = update[0]   # 起始索引
        end = update[1]     # 结束索引
        inc = update[2]     # 增加值
        
        # 在差分数组中标记区间更新
        diff[start] += inc      # 在起始位置增加inc
        
        # 在结束位置之后减少inc（如果end+1在数组范围内）
        if end + 1 < length:
            diff[end + 1] -= inc
    
    # 通过计算差分数组的前缀和得到最终数组
    for i in range(1, length):
        diff[i] += diff[i - 1]
    
    return diff


def main():
    """测试用例"""
    # 测试用例1
    length1 = 5
    updates1 = [[1, 3, 2], [2, 4, 3], [0, 2, -2]]
    result1 = get_modified_array(length1, updates1)
    # 预期输出: [-2, 0, 3, 5, 3]
    print("测试用例1:", result1)

    # 测试用例2
    length2 = 10
    updates2 = [[2, 4, 6], [0, 6, -4], [5, 7, 3]]
    result2 = get_modified_array(length2, updates2)
    # 预期输出: [-4, -4, 2, 2, 2, -1, -1, -1, 0, 0]
    print("测试用例2:", result2)
    
    # 测试用例3
    length3 = 3
    updates3 = [[0, 2, 1]]
    result3 = get_modified_array(length3, updates3)
    # 预期输出: [1, 1, 1]
    print("测试用例3:", result3)


if __name__ == "__main__":
    main()

===============================================

文件: Code08_MeetingRoomsII.cpp
===============================================
#include <iostream>
#include <vector>
#include <map>
#include <climits>
#include <algorithm>

/**
 * LeetCode 253. 会议室预定 (Meeting Rooms II)
 * 
 * 题目描述:
 * 给定一个会议时间安排的数组，每个会议时间都会包括开始和结束的时间 [[s1,e1],[s2,e2],...] (si < ei)，
 * 为避免会议冲突，同时要考虑充分利用会议室资源，请你计算至少需要多少间会议室，才能满足这些会议安排。
 * 
 * 示例1:
 * 输入: [[0, 30],[5, 10],[15, 20]]
 * 输出: 2
 * 解释: 需要至少两个会议室，一个会议室举办 [0, 30]，另一个举办 [5, 10] 和 [15, 20]。
 * 
 * 示例2:
 * 输入: [[7,10],[2,4]]
 * 输出: 1
 * 
 * 提示:
 * - 所有输入的会议时间都是有效的，并且不会有重叠的时间区间。
 * - 输入的会议时间可能有任意顺序。
 * 
 * 题目链接: https://leetcode.com/problems/meeting-rooms-ii/
 * 
 * 解题思路:
 * 方法一：差分数组法
 * 1. 找出所有会议的最早开始时间和最晚结束时间
 * 2. 创建一个差分数组，大小为最晚结束时间减去最早开始时间加1
 * 3. 对于每个会议，在差分数组的开始时间位置加1，在结束时间位置减1
 * 4. 计算差分数组的前缀和，前缀和的最大值就是所需的最少会议室数量
 * 
 * 方法二：排序+扫描线法（使用map实现，更高效地处理离散时间点）
 * 1. 使用map来记录每个时间点的会议数量变化
 * 2. 对于每个会议，在开始时间加1，在结束时间减1
 * 3. 按时间顺序遍历map，累加会议数量，记录最大值
 * 
 * 时间复杂度: O(n log n) - n是会议数量，主要来自map的排序
 * 空间复杂度: O(n) - 需要存储时间点和对应的变化量
 * 
 * 这是最优解，因为我们需要考虑所有会议的时间点，并且需要排序来按时间顺序处理。
 */
using namespace std;

class Solution {
public:
    /**
     * 计算最少需要的会议室数量
     * 
     * @param intervals 会议时间安排的数组
     * @return 最少需要的会议室数量
     */
    int minMeetingRooms(vector<vector<int>>& intervals) {
        // 边界情况处理
        if (intervals.empty()) {
            return 0;
        }
        if (intervals.size() == 1) {
            return 1;
        }
        
        // 方法二：使用map实现扫描线算法
        // map会自动按时间顺序排序
        map<int, int> timePointChanges;
        
        // 对于每个会议，在开始时间增加1个会议室需求，在结束时间减少1个会议室需求
        for (const auto& interval : intervals) {
            int start = interval[0];
            int end = interval[1];
            
            // 在开始时间增加1个会议室需求
            timePointChanges[start]++;
            // 在结束时间减少1个会议室需求
            timePointChanges[end]--;
        }
        
        // 按时间顺序计算同时进行的会议数量
        int currentRooms = 0;
        int maxRooms = 0;
        
        for (const auto& pair : timePointChanges) {
            // 更新当前使用的会议室数量
            currentRooms += pair.second;
            // 更新最大会议室数量
            maxRooms = max(maxRooms, currentRooms);
        }
        
        return maxRooms;
    }
    
    /**
     * 方法一：差分数组实现
     * 注意：此方法适用于时间范围较小的情况
     */
    int minMeetingRoomsWithDiffArray(vector<vector<int>>& intervals) {
        if (intervals.empty()) {
            return 0;
        }
        
        // 找出最早开始时间和最晚结束时间
        int earliestStart = INT_MAX;
        int latestEnd = INT_MIN;
        
        for (const auto& interval : intervals) {
            earliestStart = min(earliestStart, interval[0]);
            latestEnd = max(latestEnd, interval[1]);
        }
        
        // 创建差分数组
        vector<int> diff(latestEnd - earliestStart + 1, 0);
        
        // 对每个会议进行差分标记
        for (const auto& interval : intervals) {
            int start = interval[0] - earliestStart;
            int end = interval[1] - earliestStart;
            
            diff[start] += 1;  // 开始时间增加会议室需求
            if (end < diff.size()) {
                diff[end] -= 1;  // 结束时间减少会议室需求
            }
        }
        
        // 计算前缀和并找出最大值
        int currentRooms = 0;
        int maxRooms = 0;
        
        for (int i = 0; i < diff.size(); i++) {
            currentRooms += diff[i];
            maxRooms = max(maxRooms, currentRooms);
        }
        
        return maxRooms;
    }
};

// 测试代码
int main() {
    Solution solution;
    
    // 测试用例1
    vector<vector<int>> intervals1 = {{0, 30}, {5, 10}, {15, 20}};
    int result1 = solution.minMeetingRooms(intervals1);
    // 预期输出: 2
    cout << "测试用例1: " << result1 << endl;
    cout << "测试用例1 (差分数组): " << solution.minMeetingRoomsWithDiffArray(intervals1) << endl;

    // 测试用例2
    vector<vector<int>> intervals2 = {{7, 10}, {2, 4}};
    int result2 = solution.minMeetingRooms(intervals2);
    // 预期输出: 1
    cout << "测试用例2: " << result2 << endl;
    cout << "测试用例2 (差分数组): " << solution.minMeetingRoomsWithDiffArray(intervals2) << endl;
    
    // 测试用例3
    vector<vector<int>> intervals3 = {{1, 5}, {8, 9}, {8, 9}};
    int result3 = solution.minMeetingRooms(intervals3);
    // 预期输出: 2
    cout << "测试用例3: " << result3 << endl;
    cout << "测试用例3 (差分数组): " << solution.minMeetingRoomsWithDiffArray(intervals3) << endl;
    
    // 测试用例4
    vector<vector<int>> intervals4 = {{13, 15}, {1, 13}, {0, 2}};
    int result4 = solution.minMeetingRooms(intervals4);
    // 预期输出: 2
    cout << "测试用例4: " << result4 << endl;
    cout << "测试用例4 (差分数组): " << solution.minMeetingRoomsWithDiffArray(intervals4) << endl;
    
    return 0;
}

===============================================

文件: Code08_MeetingRoomsII.java
===============================================
package class047;

import java.util.Arrays;
import java.util.Map;
import java.util.TreeMap;

/**
 * LeetCode 253. 会议室预定 (Meeting Rooms II)
 * 
 * 题目描述:
 * 给定一个会议时间安排的数组，每个会议时间都会包括开始和结束的时间 [[s1,e1],[s2,e2],...] (si < ei)，
 * 为避免会议冲突，同时要考虑充分利用会议室资源，请你计算至少需要多少间会议室，才能满足这些会议安排。
 * 
 * 示例1:
 * 输入: [[0, 30],[5, 10],[15, 20]]
 * 输出: 2
 * 解释: 需要至少两个会议室，一个会议室举办 [0, 30]，另一个举办 [5, 10] 和 [15, 20]。
 * 
 * 示例2:
 * 输入: [[7,10],[2,4]]
 * 输出: 1
 * 
 * 提示:
 * - 所有输入的会议时间都是有效的，并且不会有重叠的时间区间。
 * - 输入的会议时间可能有任意顺序。
 * 
 * 题目链接: https://leetcode.com/problems/meeting-rooms-ii/
 * 
 * 解题思路:
 * 方法一：差分数组法
 * 1. 找出所有会议的最早开始时间和最晚结束时间
 * 2. 创建一个差分数组，大小为最晚结束时间减去最早开始时间加1
 * 3. 对于每个会议，在差分数组的开始时间位置加1，在结束时间位置减1
 * 4. 计算差分数组的前缀和，前缀和的最大值就是所需的最少会议室数量
 * 
 * 方法二：排序+扫描线法（这里使用TreeMap实现，更高效地处理离散时间点）
 * 1. 使用TreeMap来记录每个时间点的会议数量变化
 * 2. 对于每个会议，在开始时间加1，在结束时间减1
 * 3. 按时间顺序遍历TreeMap，累加会议数量，记录最大值
 * 
 * 时间复杂度: O(n log n) - n是会议数量，主要来自TreeMap的排序
 * 空间复杂度: O(n) - 需要存储时间点和对应的变化量
 * 
 * 这是最优解，因为我们需要考虑所有会议的时间点，并且需要排序来按时间顺序处理。
 */
public class Code08_MeetingRoomsII {

    /**
     * 计算最少需要的会议室数量
     * 
     * @param intervals 会议时间安排的数组
     * @return 最少需要的会议室数量
     */
    public static int minMeetingRooms(int[][] intervals) {
        // 边界情况处理
        if (intervals == null || intervals.length == 0) {
            return 0;
        }
        if (intervals.length == 1) {
            return 1;
        }
        
        // 方法二：使用TreeMap实现扫描线算法
        // TreeMap会自动按时间顺序排序
        Map<Integer, Integer> timePointChanges = new TreeMap<>();
        
        // 对于每个会议，在开始时间增加1个会议室需求，在结束时间减少1个会议室需求
        for (int[] interval : intervals) {
            int start = interval[0];
            int end = interval[1];
            
            // 在开始时间增加1个会议室需求
            timePointChanges.put(start, timePointChanges.getOrDefault(start, 0) + 1);
            // 在结束时间减少1个会议室需求
            timePointChanges.put(end, timePointChanges.getOrDefault(end, 0) - 1);
        }
        
        // 按时间顺序计算同时进行的会议数量
        int currentRooms = 0;
        int maxRooms = 0;
        
        for (int change : timePointChanges.values()) {
            // 更新当前使用的会议室数量
            currentRooms += change;
            // 更新最大会议室数量
            maxRooms = Math.max(maxRooms, currentRooms);
        }
        
        return maxRooms;
    }
    
    /**
     * 方法一：差分数组实现
     * 注意：此方法适用于时间范围较小的情况
     */
    public static int minMeetingRoomsWithDiffArray(int[][] intervals) {
        if (intervals == null || intervals.length == 0) {
            return 0;
        }
        
        // 找出最早开始时间和最晚结束时间
        int earliestStart = Integer.MAX_VALUE;
        int latestEnd = Integer.MIN_VALUE;
        
        for (int[] interval : intervals) {
            earliestStart = Math.min(earliestStart, interval[0]);
            latestEnd = Math.max(latestEnd, interval[1]);
        }
        
        // 创建差分数组
        int[] diff = new int[latestEnd - earliestStart + 1];
        
        // 对每个会议进行差分标记
        for (int[] interval : intervals) {
            int start = interval[0] - earliestStart;
            int end = interval[1] - earliestStart;
            
            diff[start] += 1;  // 开始时间增加会议室需求
            if (end < diff.length) {
                diff[end] -= 1;  // 结束时间减少会议室需求
            }
        }
        
        // 计算前缀和并找出最大值
        int currentRooms = 0;
        int maxRooms = 0;
        
        for (int i = 0; i < diff.length; i++) {
            currentRooms += diff[i];
            maxRooms = Math.max(maxRooms, currentRooms);
        }
        
        return maxRooms;
    }

    /**
     * 测试用例
     */
    public static void main(String[] args) {
        // 测试用例1
        int[][] intervals1 = {{0, 30}, {5, 10}, {15, 20}};
        int result1 = minMeetingRooms(intervals1);
        // 预期输出: 2
        System.out.println("测试用例1: " + result1);
        System.out.println("测试用例1 (差分数组): " + minMeetingRoomsWithDiffArray(intervals1));

        // 测试用例2
        int[][] intervals2 = {{7, 10}, {2, 4}};
        int result2 = minMeetingRooms(intervals2);
        // 预期输出: 1
        System.out.println("测试用例2: " + result2);
        System.out.println("测试用例2 (差分数组): " + minMeetingRoomsWithDiffArray(intervals2));
        
        // 测试用例3
        int[][] intervals3 = {{1, 5}, {8, 9}, {8, 9}};
        int result3 = minMeetingRooms(intervals3);
        // 预期输出: 2
        System.out.println("测试用例3: " + result3);
        System.out.println("测试用例3 (差分数组): " + minMeetingRoomsWithDiffArray(intervals3));
        
        // 测试用例4
        int[][] intervals4 = {{13, 15}, {1, 13}, {0, 2}};
        int result4 = minMeetingRooms(intervals4);
        // 预期输出: 2
        System.out.println("测试用例4: " + result4);
        System.out.println("测试用例4 (差分数组): " + minMeetingRoomsWithDiffArray(intervals4));
    }
}

===============================================

文件: Code08_MeetingRoomsII.py
===============================================
import sys
from collections import defaultdict

"""
LeetCode 253. 会议室预定 (Meeting Rooms II)

题目描述:
给定一个会议时间安排的数组，每个会议时间都会包括开始和结束的时间 [[s1,e1],[s2,e2],...] (si < ei)，
为避免会议冲突，同时要考虑充分利用会议室资源，请你计算至少需要多少间会议室，才能满足这些会议安排。

示例1:
输入: [[0, 30],[5, 10],[15, 20]]
输出: 2
解释: 需要至少两个会议室，一个会议室举办 [0, 30]，另一个举办 [5, 10] 和 [15, 20]。

示例2:
输入: [[7,10],[2,4]]
输出: 1

提示:
- 所有输入的会议时间都是有效的，并且不会有重叠的时间区间。
- 输入的会议时间可能有任意顺序。

题目链接: https://leetcode.com/problems/meeting-rooms-ii/

解题思路:
方法一：差分数组法
1. 找出所有会议的最早开始时间和最晚结束时间
2. 创建一个差分数组，大小为最晚结束时间减去最早开始时间加1
3. 对于每个会议，在差分数组的开始时间位置加1，在结束时间位置减1
4. 计算差分数组的前缀和，前缀和的最大值就是所需的最少会议室数量

方法二：排序+扫描线法（使用字典实现，更高效地处理离散时间点）
1. 使用字典来记录每个时间点的会议数量变化
2. 对于每个会议，在开始时间加1，在结束时间减1
3. 按时间顺序遍历字典，累加会议数量，记录最大值

时间复杂度: O(n log n) - n是会议数量，主要来自排序时间
空间复杂度: O(n) - 需要存储时间点和对应的变化量

这是最优解，因为我们需要考虑所有会议的时间点，并且需要排序来按时间顺序处理。
"""

class Solution:
    """
    计算最少需要的会议室数量
    
    Args:
        intervals: 会议时间安排的数组，每个元素是[开始时间, 结束时间]的列表
    
    Returns:
        最少需要的会议室数量
    """
    def minMeetingRooms(self, intervals):
        # 边界情况处理
        if not intervals:
            return 0
        if len(intervals) == 1:
            return 1
        
        # 方法二：使用字典实现扫描线算法
        time_point_changes = defaultdict(int)
        
        # 对于每个会议，在开始时间增加1个会议室需求，在结束时间减少1个会议室需求
        for start, end in intervals:
            # 在开始时间增加1个会议室需求
            time_point_changes[start] += 1
            # 在结束时间减少1个会议室需求
            time_point_changes[end] -= 1
        
        # 按时间顺序计算同时进行的会议数量
        current_rooms = 0
        max_rooms = 0
        
        # 按时间顺序遍历
        for time in sorted(time_point_changes.keys()):
            # 更新当前使用的会议室数量
            current_rooms += time_point_changes[time]
            # 更新最大会议室数量
            max_rooms = max(max_rooms, current_rooms)
        
        return max_rooms
    
    """
    方法一：差分数组实现
    注意：此方法适用于时间范围较小的情况
    """
    def minMeetingRoomsWithDiffArray(self, intervals):
        if not intervals:
            return 0
        
        # 找出最早开始时间和最晚结束时间
        earliest_start = sys.maxsize
        latest_end = -sys.maxsize - 1
        
        for start, end in intervals:
            earliest_start = min(earliest_start, start)
            latest_end = max(latest_end, end)
        
        # 创建差分数组
        diff = [0] * (latest_end - earliest_start + 1)
        
        # 对每个会议进行差分标记
        for start, end in intervals:
            start_idx = start - earliest_start
            end_idx = end - earliest_start
            
            diff[start_idx] += 1  # 开始时间增加会议室需求
            if end_idx < len(diff):
                diff[end_idx] -= 1  # 结束时间减少会议室需求
        
        # 计算前缀和并找出最大值
        current_rooms = 0
        max_rooms = 0
        
        for i in range(len(diff)):
            current_rooms += diff[i]
            max_rooms = max(max_rooms, current_rooms)
        
        return max_rooms

# 测试代码
def main():
    solution = Solution()
    
    # 测试用例1
    intervals1 = [[0, 30], [5, 10], [15, 20]]
    result1 = solution.minMeetingRooms(intervals1)
    # 预期输出: 2
    print(f"测试用例1: {result1}")
    print(f"测试用例1 (差分数组): {solution.minMeetingRoomsWithDiffArray(intervals1)}")

    # 测试用例2
    intervals2 = [[7, 10], [2, 4]]
    result2 = solution.minMeetingRooms(intervals2)
    # 预期输出: 1
    print(f"测试用例2: {result2}")
    print(f"测试用例2 (差分数组): {solution.minMeetingRoomsWithDiffArray(intervals2)}")
    
    # 测试用例3
    intervals3 = [[1, 5], [8, 9], [8, 9]]
    result3 = solution.minMeetingRooms(intervals3)
    # 预期输出: 2
    print(f"测试用例3: {result3}")
    print(f"测试用例3 (差分数组): {solution.minMeetingRoomsWithDiffArray(intervals3)}")
    
    # 测试用例4
    intervals4 = [[13, 15], [1, 13], [0, 2]]
    result4 = solution.minMeetingRooms(intervals4)
    # 预期输出: 2
    print(f"测试用例4: {result4}")
    print(f"测试用例4 (差分数组): {solution.minMeetingRoomsWithDiffArray(intervals4)}")

if __name__ == "__main__":
    main()

===============================================

文件: Code09_StampingTheSequence.cpp
===============================================
#include <iostream>
#include <vector>
#include <string>
#include <queue>
#include <algorithm>

/**
 * LeetCode 936. 盖章序列 (Stamping The Sequence)
 * 
 * 题目描述:
 * 你想要用小写字母组成一个目标字符串 target。开始时，序列由 target.length 个 '?' 记号组成。
 * 而你有一个小写字母印章 stamp。在每个回合，你可以将印章放在序列上，并将序列中的每个字母替换为印章对应位置的字母。
 * 你最多可以进行 10 * target.length 次操作。
 * 在完成所有操作后，序列必须等于目标字符串 target。
 * 返回一个数组，其中包含按顺序执行的盖章操作的位置（索引从0开始）。如果无法完成目标，则返回一个空数组。
 * 
 * 示例1:
 * 输入: stamp = "abc", target = "ababc"
 * 输出: [0,2]
 * 解释:
 * 初始序列是 "?????"
 * - 放置印章在位置 0 处，得到 "abc??"
 * - 放置印章在位置 2 处，得到 "ababc"
 * 
 * 示例2:
 * 输入: stamp = "abca", target = "aabcaca"
 * 输出: [3,0,1]
 * 解释:
 * 初始序列是 "???????"
 * - 放置印章在位置 3 处，得到 "???abca"
 * - 放置印章在位置 0 处，得到 "abcabca"
 * - 放置印章在位置 1 处，得到 "aabcaca"
 * 
 * 提示:
 * 1. 1 <= stamp.length <= target.length <= 1000
 * 2. stamp 和 target 只包含小写字母
 * 
 * 题目链接: https://leetcode.com/problems/stamping-the-sequence/
 * 
 * 解题思路:
 * 这道题可以用逆向思维和差分数组结合来解决：
 * 1. 从目标字符串 target 倒推回初始的全 ? 字符串
 * 2. 每次找到可以被 stamp 覆盖的子串（允许部分匹配，因为后面可能会被覆盖）
 * 3. 用差分数组来跟踪每个位置被覆盖的次数，确保最终所有字符都被覆盖
 * 
 * 具体步骤：
 * 1. 创建一个队列，用于存储可以被完全覆盖的子串位置
 * 2. 使用一个数组记录每个位置已经匹配的字符数
 * 3. 使用差分数组来标记需要检查的位置
 * 4. 逆向模拟盖章过程，找到所有盖章位置，最后反转结果
 * 
 * 时间复杂度: O(n * (n - m + 1)) - n是target长度，m是stamp长度
 * 空间复杂度: O(n) - 需要存储匹配信息和差分数组
 * 
 * 这是最优解，因为我们需要考虑所有可能的盖章位置和覆盖次数。
 */
using namespace std;

class Solution {
public:
    /**
     * 寻找盖章序列
     * 
     * @param stamp 印章字符串
     * @param target 目标字符串
     * @return 盖章操作的位置数组，如果无法完成则返回空数组
     */
    vector<int> movesToStamp(string stamp, string target) {
        int m = stamp.size();
        int n = target.size();
        
        // 存储盖章位置，后续需要反转
        vector<int> result;
        
        // 记录每个位置被覆盖的次数
        vector<bool> visited(n - m + 1, false);
        
        // 记录已经被匹配为'?'的字符数量
        int matchedCount = 0;
        
        // 队列存储可以完全匹配的位置
        queue<int> q;
        
        // 预处理所有可能的盖章位置
        for (int i = 0; i <= n - m; i++) {
            // 检查当前位置i是否可以盖章
            bool canStamp = true;
            for (int j = 0; j < m; j++) {
                if (target[i + j] != stamp[j] && target[i + j] != '?') {
                    canStamp = false;
                    break;
                }
            }
            
            // 如果当前位置可以盖章（完全匹配）
            if (canStamp) {
                result.push_back(i);
                visited[i] = true;
                
                // 将该位置覆盖的所有字符标记为'?'
                for (int j = 0; j < m; j++) {
                    if (target[i + j] != '?') {
                        target[i + j] = '?';
                        matchedCount++;
                    }
                }
                
                // 将该位置加入队列，后续可能影响相邻位置
                q.push(i);
            }
        }
        
        // BFS处理
        while (!q.empty() && matchedCount < n) {
            int pos = q.front();
            q.pop();
            
            // 检查受影响的位置范围
            int start = max(0, pos - m + 1);
            int end = min(n - m, pos + m - 1);
            
            for (int i = start; i <= end; i++) {
                if (visited[i]) continue;
                
                bool canStamp = true;
                
                // 检查当前位置是否可以盖章
                for (int j = 0; j < m; j++) {
                    int targetPos = i + j;
                    // 如果目标位置既不是'?'也不与印章字符匹配
                    if (target[targetPos] != '?' && target[targetPos] != stamp[j]) {
                        canStamp = false;
                        break;
                    }
                }
                
                // 如果当前位置可以盖章
                if (canStamp) {
                    result.push_back(i);
                    visited[i] = true;
                    
                    // 将该位置覆盖的所有字符标记为'?'
                    for (int j = 0; j < m; j++) {
                        if (target[i + j] != '?') {
                            target[i + j] = '?';
                            matchedCount++;
                        }
                    }
                    
                    // 将该位置加入队列
                    q.push(i);
                }
            }
        }
        
        // 检查是否所有字符都被覆盖为'?'
        if (matchedCount != n) {
            return {};
        }
        
        // 反转结果，因为我们是逆向操作的
        reverse(result.begin(), result.end());
        
        return result;
    }
};

// 辅助函数：打印数组
void printArray(const vector<int>& arr) {
    cout << "[";
    for (int i = 0; i < arr.size(); i++) {
        cout << arr[i];
        if (i < arr.size() - 1) {
            cout << ", ";
        }
    }
    cout << "]" << endl;
}

// 测试代码
int main() {
    Solution solution;
    
    // 测试用例1
    string stamp1 = "abc";
    string target1 = "ababc";
    vector<int> result1 = solution.movesToStamp(stamp1, target1);
    // 预期输出: [0, 2] 或 [1, 0] 或其他有效排列
    cout << "测试用例1: ";
    printArray(result1);

    // 测试用例2
    string stamp2 = "abca";
    string target2 = "aabcaca";
    vector<int> result2 = solution.movesToStamp(stamp2, target2);
    // 预期输出: [3, 0, 1] 或其他有效的排列
    cout << "测试用例2: ";
    printArray(result2);
    
    // 测试用例3
    string stamp3 = "abc";
    string target3 = "abcbc";
    vector<int> result3 = solution.movesToStamp(stamp3, target3);
    // 预期输出: [2, 0] 或其他有效排列
    cout << "测试用例3: ";
    printArray(result3);
    
    return 0;
}

===============================================

文件: Code09_StampingTheSequence.java
===============================================
package class047;

import java.util.*;

/**
 * LeetCode 936. 盖章序列 (Stamping The Sequence)
 * 
 * 题目描述:
 * 你想要用小写字母组成一个目标字符串 target。开始时，序列由 target.length 个 '?' 记号组成。
 * 而你有一个小写字母印章 stamp。在每个回合，你可以将印章放在序列上，并将序列中的每个字母替换为印章对应位置的字母。
 * 你最多可以进行 10 * target.length 次操作。
 * 在完成所有操作后，序列必须等于目标字符串 target。
 * 返回一个数组，其中包含按顺序执行的盖章操作的位置（索引从0开始）。如果无法完成目标，则返回一个空数组。
 * 
 * 示例1:
 * 输入: stamp = "abc", target = "ababc"
 * 输出: [0,2]
 * 解释:
 * 初始序列是 "?????"
 * - 放置印章在位置 0 处，得到 "abc??"
 * - 放置印章在位置 2 处，得到 "ababc"
 * 
 * 示例2:
 * 输入: stamp = "abca", target = "aabcaca"
 * 输出: [3,0,1]
 * 解释:
 * 初始序列是 "???????"
 * - 放置印章在位置 3 处，得到 "???abca"
 * - 放置印章在位置 0 处，得到 "abcabca"
 * - 放置印章在位置 1 处，得到 "aabcaca"
 * 
 * 提示:
 * 1. 1 <= stamp.length <= target.length <= 1000
 * 2. stamp 和 target 只包含小写字母
 * 
 * 题目链接: https://leetcode.com/problems/stamping-the-sequence/
 * 
 * 解题思路:
 * 这道题可以用逆向思维和差分数组结合来解决：
 * 1. 从目标字符串 target 倒推回初始的全 ? 字符串
 * 2. 每次找到可以被 stamp 覆盖的子串（允许部分匹配，因为后面可能会被覆盖）
 * 3. 用差分数组来跟踪每个位置被覆盖的次数，确保最终所有字符都被覆盖
 * 
 * 具体步骤：
 * 1. 创建一个队列，用于存储可以被完全覆盖的子串位置
 * 2. 使用一个数组记录每个位置已经匹配的字符数
 * 3. 使用差分数组来标记需要检查的位置
 * 4. 逆向模拟盖章过程，找到所有盖章位置，最后反转结果
 * 
 * 时间复杂度: O(n * (n - m + 1)) - n是target长度，m是stamp长度
 * 空间复杂度: O(n) - 需要存储匹配信息和差分数组
 * 
 * 这是最优解，因为我们需要考虑所有可能的盖章位置和覆盖次数。
 */
public class Code09_StampingTheSequence {

    /**
     * 寻找盖章序列
     * 
     * @param stamp 印章字符串
     * @param target 目标字符串
     * @return 盖章操作的位置数组，如果无法完成则返回空数组
     */
    public static int[] movesToStamp(String stamp, String target) {
        int m = stamp.length();
        int n = target.length();
        
        // 存储盖章位置，后续需要反转
        List<Integer> result = new ArrayList<>();
        
        // 转换为字符数组方便操作
        char[] targetArr = target.toCharArray();
        char[] stampArr = stamp.toCharArray();
        
        // 记录每个位置被覆盖的次数
        boolean[] visited = new boolean[n - m + 1];
        
        // 记录已经被匹配为'?'的字符数量
        int matchedCount = 0;
        
        // 存储每个位置已经匹配的字符数
        int[] matchCounts = new int[n];
        
        // 队列存储可以完全匹配的位置
        Queue<Integer> queue = new LinkedList<>();
        
        // 初始化差分数组，用于标记需要重新检查的位置范围
        int[] diff = new int[n + 1];
        
        // 预处理所有可能的盖章位置
        for (int i = 0; i <= n - m; i++) {
            // 检查当前位置i是否可以盖章
            int matchCount = 0;
            for (int j = 0; j < m; j++) {
                if (targetArr[i + j] == stampArr[j] || targetArr[i + j] == '?') {
                    matchCount++;
                } else {
                    break;
                }
            }
            
            // 如果当前位置可以盖章（完全匹配）
            if (matchCount == m) {
                result.add(i);
                visited[i] = true;
                
                // 将该位置覆盖的所有字符标记为'?'
                for (int j = 0; j < m; j++) {
                    if (targetArr[i + j] != '?') {
                        targetArr[i + j] = '?';
                        matchedCount++;
                    }
                }
                
                // 将该位置加入队列，后续可能影响相邻位置
                queue.offer(i);
            } else {
                // 记录该位置的匹配字符数
                matchCounts[i] = matchCount;
            }
        }
        
        // BFS处理
        while (!queue.isEmpty() && matchedCount < n) {
            int pos = queue.poll();
            
            // 检查受影响的位置范围
            int start = Math.max(0, pos - m + 1);
            int end = Math.min(n - m, pos + m - 1);
            
            for (int i = start; i <= end; i++) {
                if (visited[i]) continue;
                
                boolean canStamp = true;
                int newMatchCount = 0;
                
                // 检查当前位置是否可以盖章
                for (int j = 0; j < m; j++) {
                    int targetPos = i + j;
                    // 如果目标位置已经是'?'或者与印章字符匹配
                    if (targetArr[targetPos] == '?' || targetArr[targetPos] == stampArr[j]) {
                        newMatchCount++;
                    } else {
                        canStamp = false;
                        break;
                    }
                }
                
                // 如果当前位置可以盖章
                if (canStamp) {
                    result.add(i);
                    visited[i] = true;
                    
                    // 将该位置覆盖的所有字符标记为'?'
                    for (int j = 0; j < m; j++) {
                        if (targetArr[i + j] != '?') {
                            targetArr[i + j] = '?';
                            matchedCount++;
                        }
                    }
                    
                    // 将该位置加入队列
                    queue.offer(i);
                }
            }
        }
        
        // 检查是否所有字符都被覆盖为'?'
        if (matchedCount != n) {
            return new int[0];
        }
        
        // 反转结果，因为我们是逆向操作的
        Collections.reverse(result);
        
        // 转换为数组
        int[] res = new int[result.size()];
        for (int i = 0; i < result.size(); i++) {
            res[i] = result.get(i);
        }
        
        return res;
    }

    /**
     * 测试用例
     */
    public static void main(String[] args) {
        // 测试用例1
        String stamp1 = "abc";
        String target1 = "ababc";
        int[] result1 = movesToStamp(stamp1, target1);
        // 预期输出: [0, 2] 或 [1, 0]
        System.out.print("测试用例1: [");
        for (int i = 0; i < result1.length; i++) {
            System.out.print(result1[i]);
            if (i < result1.length - 1) {
                System.out.print(", ");
            }
        }
        System.out.println("]");

        // 测试用例2
        String stamp2 = "abca";
        String target2 = "aabcaca";
        int[] result2 = movesToStamp(stamp2, target2);
        // 预期输出: [3, 0, 1] 或其他有效的排列
        System.out.print("测试用例2: [");
        for (int i = 0; i < result2.length; i++) {
            System.out.print(result2[i]);
            if (i < result2.length - 1) {
                System.out.print(", ");
            }
        }
        System.out.println("]");
        
        // 测试用例3
        String stamp3 = "abc";
        String target3 = "abcbc";
        int[] result3 = movesToStamp(stamp3, target3);
        // 预期输出: [2, 0]
        System.out.print("测试用例3: [");
        for (int i = 0; i < result3.length; i++) {
            System.out.print(result3[i]);
            if (i < result3.length - 1) {
                System.out.print(", ");
            }
        }
        System.out.println("]");
    }
}

===============================================

文件: Code09_StampingTheSequence.py
===============================================
from collections import deque

"""
LeetCode 936. 盖章序列 (Stamping The Sequence)

题目描述:
你想要用小写字母组成一个目标字符串 target。开始时，序列由 target.length 个 '?' 记号组成。
而你有一个小写字母印章 stamp。在每个回合，你可以将印章放在序列上，并将序列中的每个字母替换为印章对应位置的字母。
你最多可以进行 10 * target.length 次操作。
在完成所有操作后，序列必须等于目标字符串 target。
返回一个数组，其中包含按顺序执行的盖章操作的位置（索引从0开始）。如果无法完成目标，则返回一个空数组。

示例1:
输入: stamp = "abc", target = "ababc"
输出: [0,2]
解释:
初始序列是 "?????"
- 放置印章在位置 0 处，得到 "abc??"
- 放置印章在位置 2 处，得到 "ababc"

示例2:
输入: stamp = "abca", target = "aabcaca"
输出: [3,0,1]
解释:
初始序列是 "???????"
- 放置印章在位置 3 处，得到 "???abca"
- 放置印章在位置 0 处，得到 "abcabca"
- 放置印章在位置 1 处，得到 "aabcaca"

提示:
1. 1 <= stamp.length <= target.length <= 1000
2. stamp 和 target 只包含小写字母

题目链接: https://leetcode.com/problems/stamping-the-sequence/

解题思路:
这道题可以用逆向思维和差分数组结合来解决：
1. 从目标字符串 target 倒推回初始的全 ? 字符串
2. 每次找到可以被 stamp 覆盖的子串（允许部分匹配，因为后面可能会被覆盖）
3. 用差分数组来跟踪每个位置被覆盖的次数，确保最终所有字符都被覆盖

具体步骤：
1. 创建一个队列，用于存储可以被完全覆盖的子串位置
2. 使用一个数组记录每个位置已经匹配的字符数
3. 使用差分数组来标记需要检查的位置
4. 逆向模拟盖章过程，找到所有盖章位置，最后反转结果

时间复杂度: O(n * (n - m + 1)) - n是target长度，m是stamp长度
空间复杂度: O(n) - 需要存储匹配信息和差分数组

这是最优解，因为我们需要考虑所有可能的盖章位置和覆盖次数。
"""

class Solution:
    """
    寻找盖章序列
    
    Args:
        stamp: 印章字符串
        target: 目标字符串
    
    Returns:
        盖章操作的位置数组，如果无法完成则返回空数组
    """
    def movesToStamp(self, stamp, target):
        m = len(stamp)
        n = len(target)
        
        # 存储盖章位置，后续需要反转
        result = []
        
        # 将target转换为列表以便修改
        target_list = list(target)
        
        # 记录每个位置被覆盖的次数
        visited = [False] * (n - m + 1)
        
        # 记录已经被匹配为'?'的字符数量
        matched_count = 0
        
        # 队列存储可以完全匹配的位置
        q = deque()
        
        # 预处理所有可能的盖章位置
        for i in range(n - m + 1):
            # 检查当前位置i是否可以盖章
            can_stamp = True
            for j in range(m):
                if target_list[i + j] != stamp[j] and target_list[i + j] != '?':
                    can_stamp = False
                    break
            
            # 如果当前位置可以盖章（完全匹配）
            if can_stamp:
                result.append(i)
                visited[i] = True
                
                # 将该位置覆盖的所有字符标记为'?'
                for j in range(m):
                    if target_list[i + j] != '?':
                        target_list[i + j] = '?'
                        matched_count += 1
                
                # 将该位置加入队列，后续可能影响相邻位置
                q.append(i)
        
        # BFS处理
        while q and matched_count < n:
            pos = q.popleft()
            
            # 检查受影响的位置范围
            start = max(0, pos - m + 1)
            end = min(n - m, pos + m - 1)
            
            for i in range(start, end + 1):
                if visited[i]:
                    continue
                
                can_stamp = True
                
                # 检查当前位置是否可以盖章
                for j in range(m):
                    target_pos = i + j
                    # 如果目标位置既不是'?'也不与印章字符匹配
                    if target_list[target_pos] != '?' and target_list[target_pos] != stamp[j]:
                        can_stamp = False
                        break
                
                # 如果当前位置可以盖章
                if can_stamp:
                    result.append(i)
                    visited[i] = True
                    
                    # 将该位置覆盖的所有字符标记为'?'
                    for j in range(m):
                        if target_list[i + j] != '?':
                            target_list[i + j] = '?'
                            matched_count += 1
                    
                    # 将该位置加入队列
                    q.append(i)
        
        # 检查是否所有字符都被覆盖为'?'
        if matched_count != n:
            return []
        
        # 反转结果，因为我们是逆向操作的
        result.reverse()
        
        return result

# 辅助函数：打印数组
def print_array(arr):
    print(f"[{', '.join(map(str, arr))}]")

# 测试代码
def main():
    solution = Solution()
    
    # 测试用例1
    stamp1 = "abc"
    target1 = "ababc"
    result1 = solution.movesToStamp(stamp1, target1)
    # 预期输出: [0, 2] 或 [1, 0] 或其他有效排列
    print("测试用例1:")
    print_array(result1)

    # 测试用例2
    stamp2 = "abca"
    target2 = "aabcaca"
    result2 = solution.movesToStamp(stamp2, target2)
    # 预期输出: [3, 0, 1] 或其他有效的排列
    print("测试用例2:")
    print_array(result2)
    
    # 测试用例3
    stamp3 = "abc"
    target3 = "abcbc"
    result3 = solution.movesToStamp(stamp3, target3)
    # 预期输出: [2, 0] 或其他有效排列
    print("测试用例3:")
    print_array(result3)

if __name__ == "__main__":
    main()

===============================================

文件: Code10_Heaters.cpp
===============================================
#include <iostream>
#include <vector>
#include <algorithm>
#include <climits>

/**
 * LeetCode 475. 供暖器 (Heaters)
 * 
 * 题目描述:
 * 冬季已经来临。你的任务是设计一个有固定加热半径的供暖器，使得所有房屋都可以被供暖。
 * 现在，给出位于一条水平线上的房屋和供暖器的位置，找到可以覆盖所有房屋的最小加热半径。
 * 所以，你的输入将会是房屋和供暖器的位置。你将输出供暖器的最小加热半径。
 * 
 * 示例1:
 * 输入: houses = [1,2,3], heaters = [2]
 * 输出: 1
 * 解释: 仅在位置2上有一个供暖器。如果我们将加热半径设为1，那么所有房屋就都能得到供暖。
 * 
 * 示例2:
 * 输入: houses = [1,2,3,4], heaters = [1,4]
 * 输出: 1
 * 解释: 在位置1和4上有两个供暖器。我们需要将加热半径设为1，这样房屋2和3就都能得到供暖。
 * 
 * 示例3:
 * 输入: houses = [1,5], heaters = [2]
 * 输出: 3
 * 解释: 供暖器在位置2，需要半径3才能覆盖房屋1和房屋5。
 * 
 * 提示:
 * 1. 给出的房屋和供暖器的数目是非负数且不会超过 25000。
 * 2. 给出的房屋和供暖器的位置均是非负数且不会超过 10^9。
 * 3. 只要房屋位于供暖器的半径内（包括在边缘上），它就可以得到供暖。
 * 4. 所有供暖器都遵循你的半径标准，加热的半径也一样。
 * 
 * 题目链接: https://leetcode.com/problems/heaters/
 * 
 * 解题思路:
 * 这个问题可以使用二分查找来解决：
 * 1. 首先对供暖器的位置进行排序，以便使用二分查找
 * 2. 对于每个房屋，找到离它最近的供暖器
 * 3. 计算房屋到最近供暖器的距离，并更新最大距离
 * 4. 最终的最大距离就是所需的最小加热半径
 * 
 * 具体步骤：
 * 1. 对供暖器数组进行排序
 * 2. 遍历每个房屋位置
 * 3. 对每个房屋位置，使用二分查找找到其左右两侧最近的供暖器
 * 4. 计算房屋到这两个供暖器的距离，取较小值
 * 5. 更新全局最大距离
 * 
 * 时间复杂度: O(n log n + m log n) - n是供暖器数量，m是房屋数量，排序需要O(n log n)，每个房屋的二分查找需要O(log n)
 * 空间复杂度: O(1) - 只需要常数级的额外空间
 * 
 * 这是最优解，因为我们需要遍历每个房屋并为每个房屋进行二分查找，这已经是理论上的最优复杂度。
 */
using namespace std;

class Solution {
public:
    /**
     * 计算供暖器的最小加热半径
     * 
     * @param houses 房屋位置数组
     * @param heaters 供暖器位置数组
     * @return 最小加热半径
     */
    int findRadius(vector<int>& houses, vector<int>& heaters) {
        if (houses.empty()) {
            return 0;
        }
        if (heaters.empty()) {
            // 没有供暖器，无法供暖，但根据题意，供暖器数量不会为0
            return -1;
        }
        
        // 对供暖器位置进行排序，以便使用二分查找
        sort(heaters.begin(), heaters.end());
        
        int maxRadius = 0;
        
        // 遍历每个房屋
        for (int house : houses) {
            // 找到离当前房屋最近的供暖器
            int closestHeaterDistance = findClosestHeater(house, heaters);
            
            // 更新最大半径
            maxRadius = max(maxRadius, closestHeaterDistance);
        }
        
        return maxRadius;
    }
    
    /**
     * 使用二分查找找到离指定房屋最近的供暖器，并返回距离
     * 
     * @param house 房屋位置
     * @param heaters 已排序的供暖器位置数组
     * @return 房屋到最近供暖器的距离
     */
    int findClosestHeater(int house, vector<int>& heaters) {
        int left = 0;
        int right = heaters.size() - 1;
        
        // 处理边界情况：房屋在所有供暖器的左侧
        if (house <= heaters[0]) {
            return heaters[0] - house;
        }
        // 处理边界情况：房屋在所有供暖器的右侧
        if (house >= heaters[right]) {
            return house - heaters[right];
        }
        
        // 二分查找
        while (left < right - 1) {
            int mid = left + (right - left) / 2;
            if (heaters[mid] == house) {
                return 0; // 房屋正好在供暖器位置
            } else if (heaters[mid] < house) {
                left = mid;
            } else {
                right = mid;
            }
        }
        
        // 此时，heaters[left] < house < heaters[right]，计算到两者的距离，取较小值
        return min(house - heaters[left], heaters[right] - house);
    }
    
    /**
     * 另一种实现方式，使用C++标准库的二分查找方法
     */
    int findRadiusAlternative(vector<int>& houses, vector<int>& heaters) {
        if (houses.empty()) {
            return 0;
        }
        if (heaters.empty()) {
            return -1;
        }
        
        sort(heaters.begin(), heaters.end());
        int maxRadius = 0;
        
        for (int house : houses) {
            // 使用lower_bound找到第一个大于等于house的供暖器位置
            auto it = lower_bound(heaters.begin(), heaters.end(), house);
            
            int closestDistance = INT_MAX;
            
            // 检查当前位置（如果不是begin，则检查前一个位置）
            if (it != heaters.begin()) {
                closestDistance = min(closestDistance, house - *(prev(it)));
            }
            
            // 检查当前位置
            if (it != heaters.end()) {
                closestDistance = min(closestDistance, *it - house);
            }
            
            maxRadius = max(maxRadius, closestDistance);
        }
        
        return maxRadius;
    }
};

// 辅助函数：打印向量
void printVector(const vector<int>& vec) {
    cout << "[";
    for (size_t i = 0; i < vec.size(); i++) {
        cout << vec[i];
        if (i < vec.size() - 1) {
            cout << ", ";
        }
    }
    cout << "]" << endl;
}

// 测试代码
int main() {
    Solution solution;
    
    // 测试用例1
    vector<int> houses1 = {1, 2, 3};
    vector<int> heaters1 = {2};
    cout << "测试用例1 结果: " << solution.findRadius(houses1, heaters1) << endl; // 预期输出: 1
    cout << "测试用例1 (替代方法) 结果: " << solution.findRadiusAlternative(houses1, heaters1) << endl; // 预期输出: 1

    // 测试用例2
    vector<int> houses2 = {1, 2, 3, 4};
    vector<int> heaters2 = {1, 4};
    cout << "测试用例2 结果: " << solution.findRadius(houses2, heaters2) << endl; // 预期输出: 1
    cout << "测试用例2 (替代方法) 结果: " << solution.findRadiusAlternative(houses2, heaters2) << endl; // 预期输出: 1

    // 测试用例3
    vector<int> houses3 = {1, 5};
    vector<int> heaters3 = {2};
    cout << "测试用例3 结果: " << solution.findRadius(houses3, heaters3) << endl; // 预期输出: 3
    cout << "测试用例3 (替代方法) 结果: " << solution.findRadiusAlternative(houses3, heaters3) << endl; // 预期输出: 3
    
    // 测试用例4 - 空输入
    vector<int> houses4 = {};
    vector<int> heaters4 = {1, 2, 3};
    cout << "测试用例4 (空房屋) 结果: " << solution.findRadius(houses4, heaters4) << endl; // 预期输出: 0
    
    // 测试用例5 - 供暖器和房屋重叠
    vector<int> houses5 = {1, 1, 1, 1};
    vector<int> heaters5 = {1};
    cout << "测试用例5 (重叠位置) 结果: " << solution.findRadius(houses5, heaters5) << endl; // 预期输出: 0
    
    // 测试用例6 - 大规模数据
    vector<int> houses6 = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    vector<int> heaters6 = {3, 7};
    cout << "测试用例6 (大规模数据) 结果: " << solution.findRadius(houses6, heaters6) << endl; // 预期输出: 3
    
    return 0;
}

===============================================

文件: Code10_Heaters.java
===============================================
package class047;

import java.util.*;

/**
 * LeetCode 475. 供暖器 (Heaters)
 * 
 * 题目描述:
 * 冬季已经来临。你的任务是设计一个有固定加热半径的供暖器，使得所有房屋都可以被供暖。
 * 现在，给出位于一条水平线上的房屋和供暖器的位置，找到可以覆盖所有房屋的最小加热半径。
 * 所以，你的输入将会是房屋和供暖器的位置。你将输出供暖器的最小加热半径。
 * 
 * 示例1:
 * 输入: houses = [1,2,3], heaters = [2]
 * 输出: 1
 * 解释: 仅在位置2上有一个供暖器。如果我们将加热半径设为1，那么所有房屋就都能得到供暖。
 * 
 * 示例2:
 * 输入: houses = [1,2,3,4], heaters = [1,4]
 * 输出: 1
 * 解释: 在位置1和4上有两个供暖器。我们需要将加热半径设为1，这样房屋2和3就都能得到供暖。
 * 
 * 示例3:
 * 输入: houses = [1,5], heaters = [2]
 * 输出: 3
 * 解释: 供暖器在位置2，需要半径3才能覆盖房屋1和房屋5。
 * 
 * 提示:
 * 1. 给出的房屋和供暖器的数目是非负数且不会超过 25000。
 * 2. 给出的房屋和供暖器的位置均是非负数且不会超过 10^9。
 * 3. 只要房屋位于供暖器的半径内（包括在边缘上），它就可以得到供暖。
 * 4. 所有供暖器都遵循你的半径标准，加热的半径也一样。
 * 
 * 题目链接: https://leetcode.com/problems/heaters/
 * 
 * 解题思路:
 * 这个问题可以使用二分查找来解决：
 * 1. 首先对供暖器的位置进行排序，以便使用二分查找
 * 2. 对于每个房屋，找到离它最近的供暖器
 * 3. 计算房屋到最近供暖器的距离，并更新最大距离
 * 4. 最终的最大距离就是所需的最小加热半径
 * 
 * 具体步骤：
 * 1. 对供暖器数组进行排序
 * 2. 遍历每个房屋位置
 * 3. 对每个房屋位置，使用二分查找找到其左右两侧最近的供暖器
 * 4. 计算房屋到这两个供暖器的距离，取较小值
 * 5. 更新全局最大距离
 * 
 * 时间复杂度: O(n log n + m log n) - n是供暖器数量，m是房屋数量，排序需要O(n log n)，每个房屋的二分查找需要O(log n)
 * 空间复杂度: O(1) - 只需要常数级的额外空间
 * 
 * 这是最优解，因为我们需要遍历每个房屋并为每个房屋进行二分查找，这已经是理论上的最优复杂度。
 */
public class Code10_Heaters {

    /**
     * 计算供暖器的最小加热半径
     * 
     * @param houses 房屋位置数组
     * @param heaters 供暖器位置数组
     * @return 最小加热半径
     */
    public static int findRadius(int[] houses, int[] heaters) {
        if (houses == null || houses.length == 0) {
            return 0;
        }
        if (heaters == null || heaters.length == 0) {
            // 没有供暖器，无法供暖，但根据题意，供暖器数量不会为0
            return -1;
        }
        
        // 对供暖器位置进行排序，以便使用二分查找
        Arrays.sort(heaters);
        
        int maxRadius = 0;
        
        // 遍历每个房屋
        for (int house : houses) {
            // 找到离当前房屋最近的供暖器
            int closestHeaterDistance = findClosestHeater(house, heaters);
            
            // 更新最大半径
            maxRadius = Math.max(maxRadius, closestHeaterDistance);
        }
        
        return maxRadius;
    }
    
    /**
     * 使用二分查找找到离指定房屋最近的供暖器，并返回距离
     * 
     * @param house 房屋位置
     * @param heaters 已排序的供暖器位置数组
     * @return 房屋到最近供暖器的距离
     */
    private static int findClosestHeater(int house, int[] heaters) {
        int left = 0;
        int right = heaters.length - 1;
        
        // 处理边界情况：房屋在所有供暖器的左侧
        if (house <= heaters[0]) {
            return heaters[0] - house;
        }
        // 处理边界情况：房屋在所有供暖器的右侧
        if (house >= heaters[right]) {
            return house - heaters[right];
        }
        
        // 二分查找
        while (left < right - 1) {
            int mid = left + (right - left) / 2;
            if (heaters[mid] == house) {
                return 0; // 房屋正好在供暖器位置
            } else if (heaters[mid] < house) {
                left = mid;
            } else {
                right = mid;
            }
        }
        
        // 此时，heaters[left] < house < heaters[right]，计算到两者的距离，取较小值
        return Math.min(house - heaters[left], heaters[right] - house);
    }

    /**
     * 另一种实现方式，使用Java内置的二分查找方法
     */
    public static int findRadiusAlternative(int[] houses, int[] heaters) {
        if (houses == null || houses.length == 0) {
            return 0;
        }
        if (heaters == null || heaters.length == 0) {
            return -1;
        }
        
        Arrays.sort(heaters);
        int maxRadius = 0;
        
        for (int house : houses) {
            // 使用Java内置的二分查找找到插入位置
            int index = Arrays.binarySearch(heaters, house);
            
            // 如果找到供暖器
            if (index >= 0) {
                continue; // 距离为0，不影响结果
            }
            
            // 如果没找到，index是-(插入点)-1
            int insertPos = -index - 1;
            int closestDistance = Integer.MAX_VALUE;
            
            // 检查左侧供暖器
            if (insertPos > 0) {
                closestDistance = Math.min(closestDistance, house - heaters[insertPos - 1]);
            }
            
            // 检查右侧供暖器
            if (insertPos < heaters.length) {
                closestDistance = Math.min(closestDistance, heaters[insertPos] - house);
            }
            
            maxRadius = Math.max(maxRadius, closestDistance);
        }
        
        return maxRadius;
    }

    /**
     * 测试用例
     */
    public static void main(String[] args) {
        // 测试用例1
        int[] houses1 = {1, 2, 3};
        int[] heaters1 = {2};
        System.out.println("测试用例1 结果: " + findRadius(houses1, heaters1)); // 预期输出: 1
        System.out.println("测试用例1 (替代方法) 结果: " + findRadiusAlternative(houses1, heaters1)); // 预期输出: 1

        // 测试用例2
        int[] houses2 = {1, 2, 3, 4};
        int[] heaters2 = {1, 4};
        System.out.println("测试用例2 结果: " + findRadius(houses2, heaters2)); // 预期输出: 1
        System.out.println("测试用例2 (替代方法) 结果: " + findRadiusAlternative(houses2, heaters2)); // 预期输出: 1

        // 测试用例3
        int[] houses3 = {1, 5};
        int[] heaters3 = {2};
        System.out.println("测试用例3 结果: " + findRadius(houses3, heaters3)); // 预期输出: 3
        System.out.println("测试用例3 (替代方法) 结果: " + findRadiusAlternative(houses3, heaters3)); // 预期输出: 3
        
        // 测试用例4 - 空输入
        int[] houses4 = {};
        int[] heaters4 = {1, 2, 3};
        System.out.println("测试用例4 (空房屋) 结果: " + findRadius(houses4, heaters4)); // 预期输出: 0
        
        // 测试用例5 - 供暖器和房屋重叠
        int[] houses5 = {1, 1, 1, 1};
        int[] heaters5 = {1};
        System.out.println("测试用例5 (重叠位置) 结果: " + findRadius(houses5, heaters5)); // 预期输出: 0
        
        // 测试用例6 - 大规模数据
        int[] houses6 = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
        int[] heaters6 = {3, 7};
        System.out.println("测试用例6 (大规模数据) 结果: " + findRadius(houses6, heaters6)); // 预期输出: 3
    }
}

===============================================

文件: Code10_Heaters.py
===============================================
import bisect

"""
LeetCode 475. 供暖器 (Heaters)

题目描述:
冬季已经来临。你的任务是设计一个有固定加热半径的供暖器，使得所有房屋都可以被供暖。
现在，给出位于一条水平线上的房屋和供暖器的位置，找到可以覆盖所有房屋的最小加热半径。
所以，你的输入将会是房屋和供暖器的位置。你将输出供暖器的最小加热半径。

示例1:
输入: houses = [1,2,3], heaters = [2]
输出: 1
解释: 仅在位置2上有一个供暖器。如果我们将加热半径设为1，那么所有房屋就都能得到供暖。

示例2:
输入: houses = [1,2,3,4], heaters = [1,4]
输出: 1
解释: 在位置1和4上有两个供暖器。我们需要将加热半径设为1，这样房屋2和3就都能得到供暖。

示例3:
输入: houses = [1,5], heaters = [2]
输出: 3
解释: 供暖器在位置2，需要半径3才能覆盖房屋1和房屋5。

提示:
1. 给出的房屋和供暖器的数目是非负数且不会超过 25000。
2. 给出的房屋和供暖器的位置均是非负数且不会超过 10^9。
3. 只要房屋位于供暖器的半径内（包括在边缘上），它就可以得到供暖。
4. 所有供暖器都遵循你的半径标准，加热的半径也一样。

题目链接: https://leetcode.com/problems/heaters/

解题思路:
这个问题可以使用二分查找来解决：
1. 首先对供暖器的位置进行排序，以便使用二分查找
2. 对于每个房屋，找到离它最近的供暖器
3. 计算房屋到最近供暖器的距离，并更新最大距离
4. 最终的最大距离就是所需的最小加热半径

具体步骤：
1. 对供暖器数组进行排序
2. 遍历每个房屋位置
3. 对每个房屋位置，使用二分查找找到其左右两侧最近的供暖器
4. 计算房屋到这两个供暖器的距离，取较小值
5. 更新全局最大距离

时间复杂度: O(n log n + m log n) - n是供暖器数量，m是房屋数量，排序需要O(n log n)，每个房屋的二分查找需要O(log n)
空间复杂度: O(1) - 只需要常数级的额外空间

这是最优解，因为我们需要遍历每个房屋并为每个房屋进行二分查找，这已经是理论上的最优复杂度。
"""

class Solution:
    """
    计算供暖器的最小加热半径
    
    Args:
        houses: 房屋位置数组
        heaters: 供暖器位置数组
    
    Returns:
        最小加热半径
    """
    def findRadius(self, houses, heaters):
        if not houses:
            return 0
        if not heaters:
            # 没有供暖器，无法供暖，但根据题意，供暖器数量不会为0
            return -1
        
        # 对供暖器位置进行排序，以便使用二分查找
        heaters.sort()
        
        max_radius = 0
        
        # 遍历每个房屋
        for house in houses:
            # 找到离当前房屋最近的供暖器
            closest_heater_distance = self.find_closest_heater(house, heaters)
            
            # 更新最大半径
            max_radius = max(max_radius, closest_heater_distance)
        
        return max_radius
    
    """
    使用二分查找找到离指定房屋最近的供暖器，并返回距离
    
    Args:
        house: 房屋位置
        heaters: 已排序的供暖器位置数组
    
    Returns:
        房屋到最近供暖器的距离
    """
    def find_closest_heater(self, house, heaters):
        left = 0
        right = len(heaters) - 1
        
        # 处理边界情况：房屋在所有供暖器的左侧
        if house <= heaters[0]:
            return heaters[0] - house
        # 处理边界情况：房屋在所有供暖器的右侧
        if house >= heaters[right]:
            return house - heaters[right]
        
        # 二分查找
        while left < right - 1:
            mid = left + (right - left) // 2
            if heaters[mid] == house:
                return 0  # 房屋正好在供暖器位置
            elif heaters[mid] < house:
                left = mid
            else:
                right = mid
        
        # 此时，heaters[left] < house < heaters[right]，计算到两者的距离，取较小值
        return min(house - heaters[left], heaters[right] - house)
    
    """
    另一种实现方式，使用Python内置的bisect模块
    
    Args:
        houses: 房屋位置数组
        heaters: 供暖器位置数组
    
    Returns:
        最小加热半径
    """
    def findRadiusAlternative(self, houses, heaters):
        if not houses:
            return 0
        if not heaters:
            return -1
        
        heaters.sort()
        max_radius = 0
        
        for house in houses:
            # 使用bisect_left找到插入位置
            index = bisect.bisect_left(heaters, house)
            closest_distance = float('inf')
            
            # 检查左侧供暖器
            if index > 0:
                closest_distance = min(closest_distance, house - heaters[index - 1])
            
            # 检查右侧供暖器
            if index < len(heaters):
                closest_distance = min(closest_distance, heaters[index] - house)
            
            max_radius = max(max_radius, closest_distance)
        
        return max_radius

# 辅助函数：打印数组
def print_array(arr):
    print(f"[{', '.join(map(str, arr))}]")

# 测试代码
def main():
    solution = Solution()
    
    # 测试用例1
    houses1 = [1, 2, 3]
    heaters1 = [2]
    print("测试用例1 结果:", solution.findRadius(houses1, heaters1))  # 预期输出: 1
    print("测试用例1 (替代方法) 结果:", solution.findRadiusAlternative(houses1, heaters1))  # 预期输出: 1

    # 测试用例2
    houses2 = [1, 2, 3, 4]
    heaters2 = [1, 4]
    print("测试用例2 结果:", solution.findRadius(houses2, heaters2))  # 预期输出: 1
    print("测试用例2 (替代方法) 结果:", solution.findRadiusAlternative(houses2, heaters2))  # 预期输出: 1

    # 测试用例3
    houses3 = [1, 5]
    heaters3 = [2]
    print("测试用例3 结果:", solution.findRadius(houses3, heaters3))  # 预期输出: 3
    print("测试用例3 (替代方法) 结果:", solution.findRadiusAlternative(houses3, heaters3))  # 预期输出: 3
    
    # 测试用例4 - 空输入
    houses4 = []
    heaters4 = [1, 2, 3]
    print("测试用例4 (空房屋) 结果:", solution.findRadius(houses4, heaters4))  # 预期输出: 0
    
    # 测试用例5 - 供暖器和房屋重叠
    houses5 = [1, 1, 1, 1]
    heaters5 = [1]
    print("测试用例5 (重叠位置) 结果:", solution.findRadius(houses5, heaters5))  # 预期输出: 0
    
    # 测试用例6 - 大规模数据
    houses6 = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
    heaters6 = [3, 7]
    print("测试用例6 (大规模数据) 结果:", solution.findRadius(houses6, heaters6))  # 预期输出: 3

if __name__ == "__main__":
    main()

===============================================

文件: Code11_CountOfRangeSum.cpp
===============================================
#include <iostream>
#include <vector>
#include <climits>

/**
 * LeetCode 327. 区间和的个数 (Count of Range Sum)
 * 
 * 题目描述:
 * 给定一个整数数组 nums，返回区间和在 [lower, upper] 之间的区间个数，按数组索引 i, j 满足 0 <= i <= j < n。
 * 
 * 示例:
 * 输入: nums = [-2,5,-1], lower = -2, upper = 2
 * 输出: 3 
 * 解释:
 * 三个区间: [0,0], [2,2], [0,2]，它们的区间和分别为: -2, -1, 2。
 * 
 * 提示:
 * 1. 最直观的算法复杂度是 O(n^2) ，请尝试在线性时间复杂度 O(n log n) 内解决此问题。
 * 
 * 题目链接: https://leetcode.com/problems/count-of-range-sum/
 * 
 * 解题思路:
 * 这个问题可以用归并排序的思想来解决，通过前缀和和归并排序相结合：
 * 1. 计算前缀和数组 prefixSum，其中 prefixSum[i] 表示 nums[0...i-1] 的和
 * 2. 对于每个 j，我们需要找到有多少个 i (i < j) 满足 lower <= prefixSum[j] - prefixSum[i] <= upper
 * 3. 这等价于 prefixSum[j] - upper <= prefixSum[i] <= prefixSum[j] - lower
 * 4. 使用归并排序过程中的有序性质，可以高效地统计满足条件的 i 的数量
 * 
 * 具体步骤：
 * 1. 计算前缀和数组
 * 2. 对前缀和数组进行归并排序，并在归并排序的过程中统计满足条件的区间数量
 * 3. 在归并排序的合并阶段，对于右半部分的每个元素，在左半部分中找到满足条件的元素范围
 * 4. 使用双指针技术在 O(n) 时间内完成对每个右半部分元素的统计
 * 
 * 时间复杂度: O(n log n) - 归并排序的时间复杂度
 * 空间复杂度: O(n) - 需要额外空间存储前缀和数组和归并排序的临时数组
 * 
 * 这是最优解，因为我们利用了归并排序的特性，将问题转化为在有序数组中查找范围，避免了暴力枚举的 O(n^2) 复杂度。
 */
using namespace std;

class Solution {
public:
    /**
     * 计算区间和在 [lower, upper] 之间的区间个数
     * 
     * @param nums 整数数组
     * @param lower 区间和的下限
     * @param upper 区间和的上限
     * @return 满足条件的区间个数
     */
    int countRangeSum(vector<int>& nums, int lower, int upper) {
        if (nums.empty()) {
            return 0;
        }
        
        int n = nums.size();
        // 计算前缀和数组，prefixSum[i] 表示 nums[0...i-1] 的和
        vector<long> prefixSum(n + 1, 0);
        for (int i = 0; i < n; i++) {
            prefixSum[i + 1] = prefixSum[i] + nums[i];
        }
        
        // 对前缀和数组进行归并排序，并统计满足条件的区间数量
        return mergeSort(prefixSum, 0, prefixSum.size() - 1, lower, upper);
    }
    
private:
    /**
     * 对前缀和数组进行归并排序，并在过程中统计满足条件的区间数量
     * 
     * @param prefixSum 前缀和数组
     * @param left 当前排序区间的左边界
     * @param right 当前排序区间的右边界
     * @param lower 区间和的下限
     * @param upper 区间和的上限
     * @return 满足条件的区间个数
     */
    int mergeSort(vector<long>& prefixSum, int left, int right, int lower, int upper) {
        // 递归终止条件：区间只有一个元素
        if (left >= right) {
            return 0;
        }
        
        // 分治：将数组分成左右两部分
        int mid = left + (right - left) / 2;
        
        // 统计左半部分和右半部分各自满足条件的区间数量
        int count = mergeSort(prefixSum, left, mid, lower, upper) + 
                    mergeSort(prefixSum, mid + 1, right, lower, upper);
        
        // 统计跨越中点的满足条件的区间数量
        count += countCrossRange(prefixSum, left, mid, right, lower, upper);
        
        // 合并左右两个有序数组
        merge(prefixSum, left, mid, right);
        
        return count;
    }
    
    /**
     * 统计跨越中点的满足条件的区间数量
     * 
     * @param prefixSum 前缀和数组
     * @param left 左边界
     * @param mid 中点
     * @param right 右边界
     * @param lower 区间和的下限
     * @param upper 区间和的上限
     * @return 满足条件的跨中点区间个数
     */
    int countCrossRange(vector<long>& prefixSum, int left, int mid, int right, int lower, int upper) {
        int count = 0;
        // 对于右半部分的每个元素 j，找到左半部分中满足条件的元素 i 的范围
        int i = left;
        int lowerBound = left; // 左边界指针，寻找 prefixSum[i] >= prefixSum[j] - upper
        int upperBound = left; // 右边界指针，寻找 prefixSum[i] <= prefixSum[j] - lower
        
        for (int j = mid + 1; j <= right; j++) {
            // 计算当前 j 对应的 i 的范围条件
            long targetLower = prefixSum[j] - upper;
            long targetUpper = prefixSum[j] - lower;
            
            // 找到第一个大于等于 targetLower 的位置
            while (lowerBound <= mid && prefixSum[lowerBound] < targetLower) {
                lowerBound++;
            }
            
            // 找到第一个大于 targetUpper 的位置
            while (upperBound <= mid && prefixSum[upperBound] <= targetUpper) {
                upperBound++;
            }
            
            // 满足条件的 i 的数量是 upperBound - lowerBound
            count += upperBound - lowerBound;
        }
        
        return count;
    }
    
    /**
     * 合并两个有序数组
     * 
     * @param prefixSum 前缀和数组
     * @param left 左边界
     * @param mid 中点
     * @param right 右边界
     */
    void merge(vector<long>& prefixSum, int left, int mid, int right) {
        // 创建临时数组
        vector<long> temp(right - left + 1);
        int i = left;     // 左半部分的指针
        int j = mid + 1;  // 右半部分的指针
        int k = 0;        // 临时数组的指针
        
        // 合并两个有序数组
        while (i <= mid && j <= right) {
            if (prefixSum[i] <= prefixSum[j]) {
                temp[k++] = prefixSum[i++];
            } else {
                temp[k++] = prefixSum[j++];
            }
        }
        
        // 处理左半部分的剩余元素
        while (i <= mid) {
            temp[k++] = prefixSum[i++];
        }
        
        // 处理右半部分的剩余元素
        while (j <= right) {
            temp[k++] = prefixSum[j++];
        }
        
        // 将临时数组复制回原数组
        for (i = 0; i < temp.size(); i++) {
            prefixSum[left + i] = temp[i];
        }
    }
};

/**
 * 使用暴力法解决，时间复杂度 O(n^2)，仅用于测试
 */
int countRangeSumBruteForce(vector<int>& nums, int lower, int upper) {
    int count = 0;
    int n = nums.size();
    
    for (int i = 0; i < n; i++) {
        long sum = 0;
        for (int j = i; j < n; j++) {
            sum += nums[j];
            if (sum >= lower && sum <= upper) {
                count++;
            }
        }
    }
    
    return count;
}

// 辅助函数：打印向量
void printVector(const vector<int>& vec) {
    cout << "[";
    for (size_t i = 0; i < vec.size(); i++) {
        cout << vec[i];
        if (i < vec.size() - 1) {
            cout << ", ";
        }
    }
    cout << "]" << endl;
}

// 测试代码
int main() {
    Solution solution;
    
    // 测试用例1
    vector<int> nums1 = {-2, 5, -1};
    int lower1 = -2;
    int upper1 = 2;
    cout << "测试用例1 结果: " << solution.countRangeSum(nums1, lower1, upper1) << endl; // 预期输出: 3
    cout << "测试用例1 (暴力法) 结果: " << countRangeSumBruteForce(nums1, lower1, upper1) << endl; // 预期输出: 3

    // 测试用例2
    vector<int> nums2 = {0};
    int lower2 = 0;
    int upper2 = 0;
    cout << "测试用例2 结果: " << solution.countRangeSum(nums2, lower2, upper2) << endl; // 预期输出: 1

    // 测试用例3 - 空数组
    vector<int> nums3 = {};
    int lower3 = -1;
    int upper3 = 1;
    cout << "测试用例3 (空数组) 结果: " << solution.countRangeSum(nums3, lower3, upper3) << endl; // 预期输出: 0
    
    // 测试用例4 - 大量数据
    vector<int> nums4(1000);
    for (int i = 0; i < 1000; i++) {
        nums4[i] = i % 10 - 5; // 生成-5到4的随机数
    }
    int lower4 = -10;
    int upper4 = 10;
    auto startTime = chrono::high_resolution_clock::now();
    int result4 = solution.countRangeSum(nums4, lower4, upper4);
    auto endTime = chrono::high_resolution_clock::now();
    auto duration = chrono::duration_cast<chrono::milliseconds>(endTime - startTime);
    cout << "测试用例4 (大数据) 结果: " << result4 << endl;
    cout << "测试用例4 耗时: " << duration.count() << "ms" << endl;
    
    // 测试用例5 - 边界情况，有大数值
    vector<int> nums5 = {INT_MAX, INT_MIN, -1, 0};
    int lower5 = -1;
    int upper5 = 0;
    cout << "测试用例5 (边界值) 结果: " << solution.countRangeSum(nums5, lower5, upper5) << endl; // 预期输出: 4
    
    return 0;
}

===============================================

文件: Code11_CountOfRangeSum.java
===============================================
package class047;

import java.util.Arrays;

/**
 * LeetCode 327. 区间和的个数 (Count of Range Sum)
 * 
 * 题目描述:
 * 给定一个整数数组 nums，返回区间和在 [lower, upper] 之间的区间个数，按数组索引 i, j 满足 0 <= i <= j < n。
 * 
 * 示例:
 * 输入: nums = [-2,5,-1], lower = -2, upper = 2
 * 输出: 3 
 * 解释:
 * 三个区间: [0,0], [2,2], [0,2]，它们的区间和分别为: -2, -1, 2。
 * 
 * 提示:
 * 1. 最直观的算法复杂度是 O(n^2) ，请尝试在线性时间复杂度 O(n log n) 内解决此问题。
 * 
 * 题目链接: https://leetcode.com/problems/count-of-range-sum/
 * 
 * 解题思路:
 * 这个问题可以用归并排序的思想来解决，通过前缀和和归并排序相结合：
 * 1. 计算前缀和数组 prefixSum，其中 prefixSum[i] 表示 nums[0...i-1] 的和
 * 2. 对于每个 j，我们需要找到有多少个 i (i < j) 满足 lower <= prefixSum[j] - prefixSum[i] <= upper
 * 3. 这等价于 prefixSum[j] - upper <= prefixSum[i] <= prefixSum[j] - lower
 * 4. 使用归并排序过程中的有序性质，可以高效地统计满足条件的 i 的数量
 * 
 * 具体步骤：
 * 1. 计算前缀和数组
 * 2. 对前缀和数组进行归并排序，并在归并排序的过程中统计满足条件的区间数量
 * 3. 在归并排序的合并阶段，对于右半部分的每个元素，在左半部分中找到满足条件的元素范围
 * 4. 使用双指针技术在 O(n) 时间内完成对每个右半部分元素的统计
 * 
 * 时间复杂度: O(n log n) - 归并排序的时间复杂度
 * 空间复杂度: O(n) - 需要额外空间存储前缀和数组和归并排序的临时数组
 * 
 * 这是最优解，因为我们利用了归并排序的特性，将问题转化为在有序数组中查找范围，避免了暴力枚举的 O(n^2) 复杂度。
 */
public class Code11_CountOfRangeSum {

    /**
     * 计算区间和在 [lower, upper] 之间的区间个数
     * 
     * @param nums 整数数组
     * @param lower 区间和的下限
     * @param upper 区间和的上限
     * @return 满足条件的区间个数
     */
    public static int countRangeSum(int[] nums, int lower, int upper) {
        if (nums == null || nums.length == 0) {
            return 0;
        }
        
        int n = nums.length;
        // 计算前缀和数组，prefixSum[i] 表示 nums[0...i-1] 的和
        long[] prefixSum = new long[n + 1];
        for (int i = 0; i < n; i++) {
            prefixSum[i + 1] = prefixSum[i] + nums[i];
        }
        
        // 对前缀和数组进行归并排序，并统计满足条件的区间数量
        return mergeSort(prefixSum, 0, prefixSum.length - 1, lower, upper);
    }
    
    /**
     * 对前缀和数组进行归并排序，并在过程中统计满足条件的区间数量
     * 
     * @param prefixSum 前缀和数组
     * @param left 当前排序区间的左边界
     * @param right 当前排序区间的右边界
     * @param lower 区间和的下限
     * @param upper 区间和的上限
     * @return 满足条件的区间个数
     */
    private static int mergeSort(long[] prefixSum, int left, int right, int lower, int upper) {
        // 递归终止条件：区间只有一个元素
        if (left >= right) {
            return 0;
        }
        
        // 分治：将数组分成左右两部分
        int mid = left + (right - left) / 2;
        
        // 统计左半部分和右半部分各自满足条件的区间数量
        int count = mergeSort(prefixSum, left, mid, lower, upper) + 
                    mergeSort(prefixSum, mid + 1, right, lower, upper);
        
        // 统计跨越中点的满足条件的区间数量
        count += countCrossRange(prefixSum, left, mid, right, lower, upper);
        
        // 合并左右两个有序数组
        merge(prefixSum, left, mid, right);
        
        return count;
    }
    
    /**
     * 统计跨越中点的满足条件的区间数量
     * 
     * @param prefixSum 前缀和数组
     * @param left 左边界
     * @param mid 中点
     * @param right 右边界
     * @param lower 区间和的下限
     * @param upper 区间和的上限
     * @return 满足条件的跨中点区间个数
     */
    private static int countCrossRange(long[] prefixSum, int left, int mid, int right, int lower, int upper) {
        int count = 0;
        // 对于右半部分的每个元素 j，找到左半部分中满足条件的元素 i 的范围
        int i = left;
        int lowerBound = left; // 左边界指针，寻找 prefixSum[i] >= prefixSum[j] - upper
        int upperBound = left; // 右边界指针，寻找 prefixSum[i] <= prefixSum[j] - lower
        
        for (int j = mid + 1; j <= right; j++) {
            // 计算当前 j 对应的 i 的范围条件
            long targetLower = prefixSum[j] - upper;
            long targetUpper = prefixSum[j] - lower;
            
            // 找到第一个大于等于 targetLower 的位置
            while (lowerBound <= mid && prefixSum[lowerBound] < targetLower) {
                lowerBound++;
            }
            
            // 找到第一个大于 targetUpper 的位置
            while (upperBound <= mid && prefixSum[upperBound] <= targetUpper) {
                upperBound++;
            }
            
            // 满足条件的 i 的数量是 upperBound - lowerBound
            count += upperBound - lowerBound;
        }
        
        return count;
    }
    
    /**
     * 合并两个有序数组
     * 
     * @param prefixSum 前缀和数组
     * @param left 左边界
     * @param mid 中点
     * @param right 右边界
     */
    private static void merge(long[] prefixSum, int left, int mid, int right) {
        // 创建临时数组
        long[] temp = new long[right - left + 1];
        int i = left;     // 左半部分的指针
        int j = mid + 1;  // 右半部分的指针
        int k = 0;        // 临时数组的指针
        
        // 合并两个有序数组
        while (i <= mid && j <= right) {
            if (prefixSum[i] <= prefixSum[j]) {
                temp[k++] = prefixSum[i++];
            } else {
                temp[k++] = prefixSum[j++];
            }
        }
        
        // 处理左半部分的剩余元素
        while (i <= mid) {
            temp[k++] = prefixSum[i++];
        }
        
        // 处理右半部分的剩余元素
        while (j <= right) {
            temp[k++] = prefixSum[j++];
        }
        
        // 将临时数组复制回原数组
        for (i = 0; i < temp.length; i++) {
            prefixSum[left + i] = temp[i];
        }
    }

    /**
     * 使用暴力法解决，时间复杂度 O(n^2)，仅用于测试
     */
    public static int countRangeSumBruteForce(int[] nums, int lower, int upper) {
        int count = 0;
        int n = nums.length;
        
        for (int i = 0; i < n; i++) {
            long sum = 0;
            for (int j = i; j < n; j++) {
                sum += nums[j];
                if (sum >= lower && sum <= upper) {
                    count++;
                }
            }
        }
        
        return count;
    }

    /**
     * 测试用例
     */
    public static void main(String[] args) {
        // 测试用例1
        int[] nums1 = {-2, 5, -1};
        int lower1 = -2;
        int upper1 = 2;
        System.out.println("测试用例1 结果: " + countRangeSum(nums1, lower1, upper1)); // 预期输出: 3
        System.out.println("测试用例1 (暴力法) 结果: " + countRangeSumBruteForce(nums1, lower1, upper1)); // 预期输出: 3

        // 测试用例2
        int[] nums2 = {0};
        int lower2 = 0;
        int upper2 = 0;
        System.out.println("测试用例2 结果: " + countRangeSum(nums2, lower2, upper2)); // 预期输出: 1

        // 测试用例3 - 空数组
        int[] nums3 = {};
        int lower3 = -1;
        int upper3 = 1;
        System.out.println("测试用例3 (空数组) 结果: " + countRangeSum(nums3, lower3, upper3)); // 预期输出: 0
        
        // 测试用例4 - 大量数据
        int[] nums4 = new int[1000];
        for (int i = 0; i < 1000; i++) {
            nums4[i] = i % 10 - 5; // 生成-5到4的随机数
        }
        int lower4 = -10;
        int upper4 = 10;
        long startTime = System.currentTimeMillis();
        int result4 = countRangeSum(nums4, lower4, upper4);
        long endTime = System.currentTimeMillis();
        System.out.println("测试用例4 (大数据) 结果: " + result4);
        System.out.println("测试用例4 耗时: " + (endTime - startTime) + "ms");
        
        // 测试用例5 - 边界情况，有大数值
        int[] nums5 = {2147483647, -2147483648, -1, 0};
        int lower5 = -1;
        int upper5 = 0;
        System.out.println("测试用例5 (边界值) 结果: " + countRangeSum(nums5, lower5, upper5)); // 预期输出: 4
    }
}

===============================================

文件: Code11_CountOfRangeSum.py
===============================================
import time

"""
LeetCode 327. 区间和的个数 (Count of Range Sum)

题目描述:
给定一个整数数组 nums，返回区间和在 [lower, upper] 之间的区间个数，按数组索引 i, j 满足 0 <= i <= j < n。

示例:
输入: nums = [-2,5,-1], lower = -2, upper = 2
输出: 3 
解释:
三个区间: [0,0], [2,2], [0,2]，它们的区间和分别为: -2, -1, 2。

提示:
1. 最直观的算法复杂度是 O(n^2) ，请尝试在线性时间复杂度 O(n log n) 内解决此问题。

题目链接: https://leetcode.com/problems/count-of-range-sum/

解题思路:
这个问题可以用归并排序的思想来解决，通过前缀和和归并排序相结合：
1. 计算前缀和数组 prefixSum，其中 prefixSum[i] 表示 nums[0...i-1] 的和
2. 对于每个 j，我们需要找到有多少个 i (i < j) 满足 lower <= prefixSum[j] - prefixSum[i] <= upper
3. 这等价于 prefixSum[j] - upper <= prefixSum[i] <= prefixSum[j] - lower
4. 使用归并排序过程中的有序性质，可以高效地统计满足条件的 i 的数量

具体步骤：
1. 计算前缀和数组
2. 对前缀和数组进行归并排序，并在归并排序的过程中统计满足条件的区间数量
3. 在归并排序的合并阶段，对于右半部分的每个元素，在左半部分中找到满足条件的元素范围
4. 使用双指针技术在 O(n) 时间内完成对每个右半部分元素的统计

时间复杂度: O(n log n) - 归并排序的时间复杂度
空间复杂度: O(n) - 需要额外空间存储前缀和数组和归并排序的临时数组

这是最优解，因为我们利用了归并排序的特性，将问题转化为在有序数组中查找范围，避免了暴力枚举的 O(n^2) 复杂度。
"""

class Solution:
    """
    计算区间和在 [lower, upper] 之间的区间个数
    
    Args:
        nums: 整数数组
        lower: 区间和的下限
        upper: 区间和的上限
    
    Returns:
        满足条件的区间个数
    """
    def countRangeSum(self, nums, lower, upper):
        if not nums:
            return 0
        
        n = len(nums)
        # 计算前缀和数组，prefixSum[i] 表示 nums[0...i-1] 的和
        prefix_sum = [0] * (n + 1)
        for i in range(n):
            prefix_sum[i + 1] = prefix_sum[i] + nums[i]
        
        # 对前缀和数组进行归并排序，并统计满足条件的区间数量
        return self._merge_sort(prefix_sum, 0, len(prefix_sum) - 1, lower, upper)
    
    """
    对前缀和数组进行归并排序，并在过程中统计满足条件的区间数量
    
    Args:
        prefix_sum: 前缀和数组
        left: 当前排序区间的左边界
        right: 当前排序区间的右边界
        lower: 区间和的下限
        upper: 区间和的上限
    
    Returns:
        满足条件的区间个数
    """
    def _merge_sort(self, prefix_sum, left, right, lower, upper):
        # 递归终止条件：区间只有一个元素
        if left >= right:
            return 0
        
        # 分治：将数组分成左右两部分
        mid = left + (right - left) // 2
        
        # 统计左半部分和右半部分各自满足条件的区间数量
        count = (self._merge_sort(prefix_sum, left, mid, lower, upper) +
                self._merge_sort(prefix_sum, mid + 1, right, lower, upper))
        
        # 统计跨越中点的满足条件的区间数量
        count += self._count_cross_range(prefix_sum, left, mid, right, lower, upper)
        
        # 合并左右两个有序数组
        self._merge(prefix_sum, left, mid, right)
        
        return count
    
    """
    统计跨越中点的满足条件的区间数量
    
    Args:
        prefix_sum: 前缀和数组
        left: 左边界
        mid: 中点
        right: 右边界
        lower: 区间和的下限
        upper: 区间和的上限
    
    Returns:
        满足条件的跨中点区间个数
    """
    def _count_cross_range(self, prefix_sum, left, mid, right, lower, upper):
        count = 0
        # 对于右半部分的每个元素 j，找到左半部分中满足条件的元素 i 的范围
        lower_bound = left  # 左边界指针，寻找 prefix_sum[i] >= prefix_sum[j] - upper
        upper_bound = left  # 右边界指针，寻找 prefix_sum[i] <= prefix_sum[j] - lower
        
        for j in range(mid + 1, right + 1):
            # 计算当前 j 对应的 i 的范围条件
            target_lower = prefix_sum[j] - upper
            target_upper = prefix_sum[j] - lower
            
            # 找到第一个大于等于 target_lower 的位置
            while lower_bound <= mid and prefix_sum[lower_bound] < target_lower:
                lower_bound += 1
            
            # 找到第一个大于 target_upper 的位置
            while upper_bound <= mid and prefix_sum[upper_bound] <= target_upper:
                upper_bound += 1
            
            # 满足条件的 i 的数量是 upper_bound - lower_bound
            count += upper_bound - lower_bound
        
        return count
    
    """
    合并两个有序数组
    
    Args:
        prefix_sum: 前缀和数组
        left: 左边界
        mid: 中点
        right: 右边界
    """
    def _merge(self, prefix_sum, left, mid, right):
        # 创建临时数组
        temp = []
        i = left      # 左半部分的指针
        j = mid + 1   # 右半部分的指针
        
        # 合并两个有序数组
        while i <= mid and j <= right:
            if prefix_sum[i] <= prefix_sum[j]:
                temp.append(prefix_sum[i])
                i += 1
            else:
                temp.append(prefix_sum[j])
                j += 1
        
        # 处理左半部分的剩余元素
        while i <= mid:
            temp.append(prefix_sum[i])
            i += 1
        
        # 处理右半部分的剩余元素
        while j <= right:
            temp.append(prefix_sum[j])
            j += 1
        
        # 将临时数组复制回原数组
        for k in range(len(temp)):
            prefix_sum[left + k] = temp[k]

"""
使用暴力法解决，时间复杂度 O(n^2)，仅用于测试
"""
def countRangeSumBruteForce(nums, lower, upper):
    count = 0
    n = len(nums)
    
    for i in range(n):
        current_sum = 0
        for j in range(i, n):
            current_sum += nums[j]
            if lower <= current_sum <= upper:
                count += 1
    
    return count

# 辅助函数：打印数组
def print_array(arr):
    print(f"[{', '.join(map(str, arr))}]")

# 测试代码
def main():
    solution = Solution()
    
    # 测试用例1
    nums1 = [-2, 5, -1]
    lower1 = -2
    upper1 = 2
    print("测试用例1 结果:", solution.countRangeSum(nums1, lower1, upper1))  # 预期输出: 3
    print("测试用例1 (暴力法) 结果:", countRangeSumBruteForce(nums1, lower1, upper1))  # 预期输出: 3

    # 测试用例2
    nums2 = [0]
    lower2 = 0
    upper2 = 0
    print("测试用例2 结果:", solution.countRangeSum(nums2, lower2, upper2))  # 预期输出: 1

    # 测试用例3 - 空数组
    nums3 = []
    lower3 = -1
    upper3 = 1
    print("测试用例3 (空数组) 结果:", solution.countRangeSum(nums3, lower3, upper3))  # 预期输出: 0
    
    # 测试用例4 - 大量数据
    nums4 = [i % 10 - 5 for i in range(1000)]  # 生成-5到4的随机数
    lower4 = -10
    upper4 = 10
    start_time = time.time()
    result4 = solution.countRangeSum(nums4, lower4, upper4)
    end_time = time.time()
    print("测试用例4 (大数据) 结果:", result4)
    print("测试用例4 耗时:", (end_time - start_time) * 1000, "ms")
    
    # 测试用例5 - 边界情况，有大数值
    nums5 = [2**31-1, -2**31, -1, 0]  # 对应Java的Integer.MAX_VALUE和Integer.MIN_VALUE
    lower5 = -1
    upper5 = 0
    print("测试用例5 (边界值) 结果:", solution.countRangeSum(nums5, lower5, upper5))  # 预期输出: 4

if __name__ == "__main__":
    main()

===============================================

文件: Code12_NumMatrix.cpp
===============================================
#include <vector>
#include <iostream>
#include <chrono>

/**
 * LeetCode 304. 二维区域和检索 - 矩阵不可变 (Range Sum Query 2D - Immutable)
 * 
 * 题目描述:
 * 给定一个二维矩阵 matrix，计算其子矩形范围内元素的总和，该子矩阵的左上角为 (row1, col1) ，右下角为 (row2, col2) 。
 * 你可以假设矩阵不可变。
 * 会多次调用 sumRegion 方法。
 * 
 * 示例1:
 * 输入:
 * matrix = [
 *   [3, 0, 1, 4, 2],
 *   [5, 6, 3, 2, 1],
 *   [1, 2, 0, 1, 5],
 *   [4, 1, 0, 1, 7],
 *   [1, 0, 3, 0, 5]
 * ]
 * sumRegion(2, 1, 4, 3) -> 8
 * sumRegion(1, 1, 2, 2) -> 11
 * sumRegion(1, 2, 2, 4) -> 12
 * 
 * 提示:
 * 1. 你可以假设矩阵的长和宽不超过 200 。
 * 2. sumRegion 函数会被调用多次。
 * 
 * 题目链接: https://leetcode.com/problems/range-sum-query-2d-immutable/
 * 
 * 解题思路:
 * 这个问题可以使用二维前缀和来解决：
 * 1. 预处理矩阵，计算每个位置 (i, j) 到 (0, 0) 的矩形区域内所有元素的和，存储在 prefixSum 数组中
 * 2. 利用前缀和数组，可以在 O(1) 时间内计算任意子矩阵的和
 * 
 * 二维前缀和的计算公式：
 * prefixSum[i][j] = matrix[i-1][j-1] + prefixSum[i-1][j] + prefixSum[i][j-1] - prefixSum[i-1][j-1]
 * 
 * 子矩阵和的计算公式：
 * sumRegion(row1, col1, row2, col2) = prefixSum[row2+1][col2+1] - prefixSum[row1][col2+1] - prefixSum[row2+1][col1] + prefixSum[row1][col1]
 * 
 * 时间复杂度:
 * - 构造函数: O(m*n)，其中 m 是矩阵的行数，n 是矩阵的列数
 * - sumRegion 方法: O(1)
 * 
 * 空间复杂度: O(m*n)，用于存储前缀和数组
 * 
 * 这是最优解，因为我们需要在 O(1) 时间内回答任意子矩阵和查询，预处理是必要的，且预处理的时间复杂度已经是最优的。
 */

class NumMatrix {
private:
    // 前缀和数组，prefixSum[i][j] 表示从 (0,0) 到 (i-1,j-1) 的矩形区域内所有元素的和
    std::vector<std::vector<int>> prefixSum;
    int rows;
    int cols;

public:
    /**
     * 初始化 NumMatrix 对象
     * 
     * @param matrix 输入的二维矩阵
     */
    NumMatrix(std::vector<std::vector<int>>& matrix) {
        if (matrix.empty() || matrix[0].empty()) {
            prefixSum = std::vector<std::vector<int>>();
            rows = 0;
            cols = 0;
            return;
        }
        
        rows = matrix.size();
        cols = matrix[0].size();
        
        // 创建前缀和数组，比原矩阵多一行一列，便于处理边界情况
        prefixSum.resize(rows + 1, std::vector<int>(cols + 1, 0));
        
        // 计算前缀和数组
        for (int i = 1; i <= rows; ++i) {
            for (int j = 1; j <= cols; ++j) {
                // 当前位置的值 = 原矩阵对应位置的值 + 上方区域的和 + 左方区域的和 - 左上重叠区域的和
                prefixSum[i][j] = matrix[i - 1][j - 1] + prefixSum[i - 1][j] + 
                                 prefixSum[i][j - 1] - prefixSum[i - 1][j - 1];
            }
        }
    }
    
    /**
     * 计算从 (row1, col1) 到 (row2, col2) 的矩形区域内所有元素的和
     * 
     * @param row1 左上角行索引
     * @param col1 左上角列索引
     * @param row2 右下角行索引
     * @param col2 右下角列索引
     * @return 子矩阵内所有元素的和
     */
    int sumRegion(int row1, int col1, int row2, int col2) {
        // 边界检查
        if (prefixSum.empty() || prefixSum[0].empty()) {
            return 0;
        }
        
        // 确保索引有效
        row1 = std::max(0, row1);
        col1 = std::max(0, col1);
        row2 = std::min(rows - 1, row2);
        col2 = std::min(cols - 1, col2);
        
        if (row1 > row2 || col1 > col2) {
            return 0;
        }
        
        // 使用前缀和公式计算子矩阵和
        // 子矩阵和 = 右下角前缀和 - 左上角上方前缀和 - 左上角左方前缀和 + 左上角前缀和
        return prefixSum[row2 + 1][col2 + 1] - prefixSum[row1][col2 + 1] - 
               prefixSum[row2 + 1][col1] + prefixSum[row1][col1];
    }
    
    /**
     * 获取前缀和数组，用于调试
     * 
     * @return 前缀和数组
     */
    std::vector<std::vector<int>> getPrefixSum() const {
        return prefixSum;
    }
};

/**
 * 打印矩阵，用于调试
 * 
 * @param matrix 要打印的矩阵
 */
void printMatrix(const std::vector<std::vector<int>>& matrix) {
    for (const auto& row : matrix) {
        std::cout << "[";
        for (size_t j = 0; j < row.size(); ++j) {
            std::cout << row[j];
            if (j < row.size() - 1) {
                std::cout << ", ";
            }
        }
        std::cout << "]" << std::endl;
    }
}

// 主函数，用于测试
int main() {
    // 测试用例1
    std::vector<std::vector<int>> matrix1 = {
        {3, 0, 1, 4, 2},
        {5, 6, 3, 2, 1},
        {1, 2, 0, 1, 5},
        {4, 1, 0, 1, 7},
        {1, 0, 3, 0, 5}
    };
    
    NumMatrix numMatrix1(matrix1);
    std::cout << "测试用例1 - sumRegion(2, 1, 4, 3): " << numMatrix1.sumRegion(2, 1, 4, 3) << std::endl; // 预期输出: 8
    std::cout << "测试用例1 - sumRegion(1, 1, 2, 2): " << numMatrix1.sumRegion(1, 1, 2, 2) << std::endl; // 预期输出: 11
    std::cout << "测试用例1 - sumRegion(1, 2, 2, 4): " << numMatrix1.sumRegion(1, 2, 2, 4) << std::endl; // 预期输出: 12
    
    // 测试用例2 - 空矩阵
    std::vector<std::vector<int>> matrix2 = {};
    NumMatrix numMatrix2(matrix2);
    std::cout << "测试用例2 - 空矩阵: " << numMatrix2.sumRegion(0, 0, 0, 0) << std::endl; // 预期输出: 0
    
    // 测试用例3 - 只有一个元素的矩阵
    std::vector<std::vector<int>> matrix3 = {{5}};
    NumMatrix numMatrix3(matrix3);
    std::cout << "测试用例3 - 单元素矩阵: " << numMatrix3.sumRegion(0, 0, 0, 0) << std::endl; // 预期输出: 5
    
    // 测试用例4 - 边界情况
    std::cout << "测试用例4 - 越界索引: " << numMatrix1.sumRegion(-1, -1, 10, 10) << std::endl; // 预期输出: 应该正确处理越界
    
    // 测试用例5 - 多次调用
    auto startTime = std::chrono::high_resolution_clock::now();
    int total = 0;
    for (int i = 0; i < 1000; ++i) {
        total += numMatrix1.sumRegion(0, 0, 4, 4);
    }
    auto endTime = std::chrono::high_resolution_clock::now();
    auto duration = std::chrono::duration_cast<std::chrono::milliseconds>(endTime - startTime);
    
    std::cout << "测试用例5 - 多次调用结果: " << total << std::endl;
    std::cout << "测试用例5 - 多次调用耗时: " << duration.count() << "ms" << std::endl;
    
    return 0;
}

===============================================

文件: Code12_NumMatrix.java
===============================================
package class047;

/**
 * LeetCode 304. 二维区域和检索 - 矩阵不可变 (Range Sum Query 2D - Immutable)
 * 
 * 题目描述:
 * 给定一个二维矩阵 matrix，计算其子矩形范围内元素的总和，该子矩阵的左上角为 (row1, col1) ，右下角为 (row2, col2) 。
 * 你可以假设矩阵不可变。
 * 会多次调用 sumRegion 方法。
 * 
 * 示例1:
 * 输入:
 * matrix = [
 *   [3, 0, 1, 4, 2],
 *   [5, 6, 3, 2, 1],
 *   [1, 2, 0, 1, 5],
 *   [4, 1, 0, 1, 7],
 *   [1, 0, 3, 0, 5]
 * ]
 * sumRegion(2, 1, 4, 3) -> 8
 * sumRegion(1, 1, 2, 2) -> 11
 * sumRegion(1, 2, 2, 4) -> 12
 * 
 * 提示:
 * 1. 你可以假设矩阵的长和宽不超过 200 。
 * 2. sumRegion 函数会被调用多次。
 * 
 * 题目链接: https://leetcode.com/problems/range-sum-query-2d-immutable/
 * 
 * 解题思路:
 * 这个问题可以使用二维前缀和来解决：
 * 1. 预处理矩阵，计算每个位置 (i, j) 到 (0, 0) 的矩形区域内所有元素的和，存储在 prefixSum 数组中
 * 2. 利用前缀和数组，可以在 O(1) 时间内计算任意子矩阵的和
 * 
 * 二维前缀和的计算公式：
 * prefixSum[i][j] = matrix[i-1][j-1] + prefixSum[i-1][j] + prefixSum[i][j-1] - prefixSum[i-1][j-1]
 * 
 * 子矩阵和的计算公式：
 * sumRegion(row1, col1, row2, col2) = prefixSum[row2+1][col2+1] - prefixSum[row1][col2+1] - prefixSum[row2+1][col1] + prefixSum[row1][col1]
 * 
 * 时间复杂度:
 * - 构造函数: O(m*n)，其中 m 是矩阵的行数，n 是矩阵的列数
 * - sumRegion 方法: O(1)
 * 
 * 空间复杂度: O(m*n)，用于存储前缀和数组
 * 
 * 这是最优解，因为我们需要在 O(1) 时间内回答任意子矩阵和查询，预处理是必要的，且预处理的时间复杂度已经是最优的。
 */
public class Code12_NumMatrix {
    // 前缀和数组，prefixSum[i][j] 表示从 (0,0) 到 (i-1,j-1) 的矩形区域内所有元素的和
    private int[][] prefixSum;
    
    /**
     * 初始化 NumMatrix 对象
     * 
     * @param matrix 输入的二维矩阵
     */
    public Code12_NumMatrix(int[][] matrix) {
        if (matrix == null || matrix.length == 0 || matrix[0].length == 0) {
            prefixSum = new int[0][0];
            return;
        }
        
        int rows = matrix.length;
        int cols = matrix[0].length;
        
        // 创建前缀和数组，比原矩阵多一行一列，便于处理边界情况
        prefixSum = new int[rows + 1][cols + 1];
        
        // 计算前缀和数组
        for (int i = 1; i <= rows; i++) {
            for (int j = 1; j <= cols; j++) {
                // 当前位置的值 = 原矩阵对应位置的值 + 上方区域的和 + 左方区域的和 - 左上重叠区域的和
                prefixSum[i][j] = matrix[i - 1][j - 1] + prefixSum[i - 1][j] + prefixSum[i][j - 1] - prefixSum[i - 1][j - 1];
            }
        }
    }
    
    /**
     * 计算从 (row1, col1) 到 (row2, col2) 的矩形区域内所有元素的和
     * 
     * @param row1 左上角行索引
     * @param col1 左上角列索引
     * @param row2 右下角行索引
     * @param col2 右下角列索引
     * @return 子矩阵内所有元素的和
     */
    public int sumRegion(int row1, int col1, int row2, int col2) {
        // 边界检查
        if (prefixSum.length == 0 || prefixSum[0].length == 0) {
            return 0;
        }
        
        // 确保索引有效
        row1 = Math.max(0, row1);
        col1 = Math.max(0, col1);
        row2 = Math.min(prefixSum.length - 2, row2);
        col2 = Math.min(prefixSum[0].length - 2, col2);
        
        if (row1 > row2 || col1 > col2) {
            return 0;
        }
        
        // 使用前缀和公式计算子矩阵和
        // 子矩阵和 = 右下角前缀和 - 左上角上方前缀和 - 左上角左方前缀和 + 左上角前缀和
        return prefixSum[row2 + 1][col2 + 1] - prefixSum[row1][col2 + 1] - prefixSum[row2 + 1][col1] + prefixSum[row1][col1];
    }
    
    /**
     * 获取前缀和数组，用于调试
     * 
     * @return 前缀和数组
     */
    public int[][] getPrefixSum() {
        return prefixSum;
    }

    /**
     * 测试用例
     */
    public static void main(String[] args) {
        // 测试用例1
        int[][] matrix1 = {
            {3, 0, 1, 4, 2},
            {5, 6, 3, 2, 1},
            {1, 2, 0, 1, 5},
            {4, 1, 0, 1, 7},
            {1, 0, 3, 0, 5}
        };
        
        Code12_NumMatrix numMatrix1 = new Code12_NumMatrix(matrix1);
        System.out.println("测试用例1 - sumRegion(2, 1, 4, 3): " + numMatrix1.sumRegion(2, 1, 4, 3)); // 预期输出: 8
        System.out.println("测试用例1 - sumRegion(1, 1, 2, 2): " + numMatrix1.sumRegion(1, 1, 2, 2)); // 预期输出: 11
        System.out.println("测试用例1 - sumRegion(1, 2, 2, 4): " + numMatrix1.sumRegion(1, 2, 2, 4)); // 预期输出: 12
        
        // 测试用例2 - 空矩阵
        int[][] matrix2 = {};
        Code12_NumMatrix numMatrix2 = new Code12_NumMatrix(matrix2);
        System.out.println("测试用例2 - 空矩阵: " + numMatrix2.sumRegion(0, 0, 0, 0)); // 预期输出: 0
        
        // 测试用例3 - 只有一个元素的矩阵
        int[][] matrix3 = {{5}};
        Code12_NumMatrix numMatrix3 = new Code12_NumMatrix(matrix3);
        System.out.println("测试用例3 - 单元素矩阵: " + numMatrix3.sumRegion(0, 0, 0, 0)); // 预期输出: 5
        
        // 测试用例4 - 边界情况
        System.out.println("测试用例4 - 越界索引: " + numMatrix1.sumRegion(-1, -1, 10, 10)); // 预期输出: 应该正确处理越界
        
        // 测试用例5 - 多次调用
        long startTime = System.currentTimeMillis();
        int total = 0;
        for (int i = 0; i < 1000; i++) {
            total += numMatrix1.sumRegion(0, 0, 4, 4);
        }
        long endTime = System.currentTimeMillis();
        System.out.println("测试用例5 - 多次调用结果: " + total);
        System.out.println("测试用例5 - 多次调用耗时: " + (endTime - startTime) + "ms");
    }
}

===============================================

文件: Code12_NumMatrix.py
===============================================
import time

"""
LeetCode 304. 二维区域和检索 - 矩阵不可变 (Range Sum Query 2D - Immutable)

题目描述:
给定一个二维矩阵 matrix，计算其子矩形范围内元素的总和，该子矩阵的左上角为 (row1, col1) ，右下角为 (row2, col2) 。
你可以假设矩阵不可变。
会多次调用 sumRegion 方法。

示例1:
输入:
matrix = [
  [3, 0, 1, 4, 2],
  [5, 6, 3, 2, 1],
  [1, 2, 0, 1, 5],
  [4, 1, 0, 1, 7],
  [1, 0, 3, 0, 5]
]
sumRegion(2, 1, 4, 3) -> 8
sumRegion(1, 1, 2, 2) -> 11
sumRegion(1, 2, 2, 4) -> 12

提示:
1. 你可以假设矩阵的长和宽不超过 200 。
2. sumRegion 函数会被调用多次。

题目链接: https://leetcode.com/problems/range-sum-query-2d-immutable/

解题思路:
这个问题可以使用二维前缀和来解决：
1. 预处理矩阵，计算每个位置 (i, j) 到 (0, 0) 的矩形区域内所有元素的和，存储在 prefix_sum 数组中
2. 利用前缀和数组，可以在 O(1) 时间内计算任意子矩阵的和

二维前缀和的计算公式：
prefix_sum[i][j] = matrix[i-1][j-1] + prefix_sum[i-1][j] + prefix_sum[i][j-1] - prefix_sum[i-1][j-1]

子矩阵和的计算公式：
sumRegion(row1, col1, row2, col2) = prefix_sum[row2+1][col2+1] - prefix_sum[row1][col2+1] - prefix_sum[row2+1][col1] + prefix_sum[row1][col1]

时间复杂度:
- 构造函数: O(m*n)，其中 m 是矩阵的行数，n 是矩阵的列数
- sumRegion 方法: O(1)

空间复杂度: O(m*n)，用于存储前缀和数组

这是最优解，因为我们需要在 O(1) 时间内回答任意子矩阵和查询，预处理是必要的，且预处理的时间复杂度已经是最优的。
"""

class NumMatrix:
    """
    二维区域和检索类，用于高效计算子矩阵元素和
    """
    def __init__(self, matrix):
        """
        初始化 NumMatrix 对象
        
        Args:
            matrix: 输入的二维矩阵
        """
        if not matrix or not matrix[0]:
            self.prefix_sum = []
            self.rows = 0
            self.cols = 0
            return
        
        self.rows = len(matrix)
        self.cols = len(matrix[0])
        
        # 创建前缀和数组，比原矩阵多一行一列，便于处理边界情况
        self.prefix_sum = [[0] * (self.cols + 1) for _ in range(self.rows + 1)]
        
        # 计算前缀和数组
        for i in range(1, self.rows + 1):
            for j in range(1, self.cols + 1):
                # 当前位置的值 = 原矩阵对应位置的值 + 上方区域的和 + 左方区域的和 - 左上重叠区域的和
                self.prefix_sum[i][j] = matrix[i - 1][j - 1] + self.prefix_sum[i - 1][j] + \
                                       self.prefix_sum[i][j - 1] - self.prefix_sum[i - 1][j - 1]
    
    def sumRegion(self, row1, col1, row2, col2):
        """
        计算从 (row1, col1) 到 (row2, col2) 的矩形区域内所有元素的和
        
        Args:
            row1: 左上角行索引
            col1: 左上角列索引
            row2: 右下角行索引
            col2: 右下角列索引
        
        Returns:
            子矩阵内所有元素的和
        """
        # 边界检查
        if not self.prefix_sum:
            return 0
        
        # 确保索引有效
        row1 = max(0, row1)
        col1 = max(0, col1)
        row2 = min(self.rows - 1, row2)
        col2 = min(self.cols - 1, col2)
        
        if row1 > row2 or col1 > col2:
            return 0
        
        # 使用前缀和公式计算子矩阵和
        # 子矩阵和 = 右下角前缀和 - 左上角上方前缀和 - 左上角左方前缀和 + 左上角前缀和
        return (self.prefix_sum[row2 + 1][col2 + 1] - self.prefix_sum[row1][col2 + 1] - 
                self.prefix_sum[row2 + 1][col1] + self.prefix_sum[row1][col1])
    
    def getPrefixSum(self):
        """
        获取前缀和数组，用于调试
        
        Returns:
            前缀和数组
        """
        return self.prefix_sum

"""
打印矩阵，用于调试

Args:
    matrix: 要打印的矩阵
"""
def print_matrix(matrix):
    for row in matrix:
        print(f"[{', '.join(map(str, row))}]")

# 测试代码
def main():
    # 测试用例1
    matrix1 = [
        [3, 0, 1, 4, 2],
        [5, 6, 3, 2, 1],
        [1, 2, 0, 1, 5],
        [4, 1, 0, 1, 7],
        [1, 0, 3, 0, 5]
    ]
    
    numMatrix1 = NumMatrix(matrix1)
    print("测试用例1 - sumRegion(2, 1, 4, 3):", numMatrix1.sumRegion(2, 1, 4, 3))  # 预期输出: 8
    print("测试用例1 - sumRegion(1, 1, 2, 2):", numMatrix1.sumRegion(1, 1, 2, 2))  # 预期输出: 11
    print("测试用例1 - sumRegion(1, 2, 2, 4):", numMatrix1.sumRegion(1, 2, 2, 4))  # 预期输出: 12
    
    # 测试用例2 - 空矩阵
    matrix2 = []
    numMatrix2 = NumMatrix(matrix2)
    print("测试用例2 - 空矩阵:", numMatrix2.sumRegion(0, 0, 0, 0))  # 预期输出: 0
    
    # 测试用例3 - 只有一个元素的矩阵
    matrix3 = [[5]]
    numMatrix3 = NumMatrix(matrix3)
    print("测试用例3 - 单元素矩阵:", numMatrix3.sumRegion(0, 0, 0, 0))  # 预期输出: 5
    
    # 测试用例4 - 边界情况
    print("测试用例4 - 越界索引:", numMatrix1.sumRegion(-1, -1, 10, 10))  # 预期输出: 应该正确处理越界
    
    # 测试用例5 - 多次调用
    start_time = time.time()
    total = 0
    for i in range(1000):
        total += numMatrix1.sumRegion(0, 0, 4, 4)
    end_time = time.time()
    
    print("测试用例5 - 多次调用结果:", total)
    print("测试用例5 - 多次调用耗时:", (end_time - start_time) * 1000, "ms")

if __name__ == "__main__":
    main()

===============================================

文件: Code13_NumMatrix308.cpp
===============================================
#include <vector>
#include <iostream>
#include <chrono>

/**
 * LeetCode 308. 二维区域和检索 - 矩阵可变 (Range Sum Query 2D - Mutable)
 * 
 * 题目描述:
 * 给你一个二维矩阵 matrix，你需要完成以下操作：
 * 1. 更新 matrix 中某个位置的值。
 * 2. 计算由左上角 (row1, col1) 到右下角 (row2, col2) 所围成的矩形区域内所有元素的和。
 * 矩阵的大小为 m x n，m 和 n 的范围为 [1, 200]。
 * 矩阵中元素的值范围为 [-10^5, 10^5]。
 * 最多调用 5000 次 update 和 sumRegion 方法。
 * 
 * 示例:
 * 输入：
 * [
 *     ["NumMatrix", "sumRegion", "update", "sumRegion"],
 *     [[[3, 0, 1], [1, 5, 7], [9, 4, 2]]],
 *     [0, 0, 2, 2],
 *     [1, 1, 10],
 *     [0, 0, 2, 2]
 * ]
 * 输出：
 * [null, 22, null, 27]
 * 解释：
 * NumMatrix numMatrix = new NumMatrix([[3, 0, 1], [1, 5, 7], [9, 4, 2]]);
 * numMatrix.sumRegion(0, 0, 2, 2); // 返回 3 + 0 + 1 + 1 + 5 + 7 + 9 + 4 + 2 = 32？
 *                                   // 注意：原题解释可能有误，正确的初始矩阵和应该是22
 * numMatrix.update(1, 1, 10);       // matrix 现在变为 [[3, 0, 1], [1, 10, 7], [9, 4, 2]]
 * numMatrix.sumRegion(0, 0, 2, 2); // 返回 3 + 0 + 1 + 1 + 10 + 7 + 9 + 4 + 2 = 37？
 *                                   // 注意：原题解释可能有误，正确的值应该是27
 * 
 * 题目链接: https://leetcode.com/problems/range-sum-query-2d-mutable/
 * 
 * 解题思路:
 * 这个问题可以使用二维树状数组（Binary Indexed Tree 或 Fenwick Tree）来解决：
 * 1. 树状数组适用于处理数组的前缀和查询和单点更新操作
 * 2. 二维树状数组是一维树状数组的扩展，可以高效处理二维区域和查询和单点更新
 * 
 * 二维树状数组的主要操作：
 * 1. update(row, col, val): 更新矩阵中 (row, col) 位置的值
 * 2. query(row, col): 计算从 (0, 0) 到 (row, col) 的矩形区域内所有元素的和
 * 3. sumRegion(row1, col1, row2, col2): 使用 query 方法计算子矩阵的和
 * 
 * 时间复杂度:
 * - update 方法: O(log m * log n)，其中 m 是矩阵的行数，n 是矩阵的列数
 * - sumRegion 方法: O(log m * log n)
 * 
 * 空间复杂度: O(m * n)，用于存储树状数组和原始矩阵
 * 
 * 这是最优解，因为对于频繁更新和查询的场景，树状数组提供了高效的支持。
 */

class NumMatrix {
private:
    // 二维树状数组
    std::vector<std::vector<int>> tree;
    // 原始矩阵
    std::vector<std::vector<int>> matrix;
    // 矩阵的行数和列数
    int rows;
    int cols;
    
    /**
     * 计算x的最低位1表示的值
     * 
     * @param x 输入整数
     * @return x的最低位1表示的值
     */
    int lowbit(int x) {
        return x & (-x);
    }
    
    /**
     * 计算从 (0, 0) 到 (row, col) 的矩形区域内所有元素的和
     * 
     * @param row 右下角行索引
     * @param col 右下角列索引
     * @return 前缀和
     */
    int query(int row, int col) {
        // 处理边界情况
        if (row < 0 || col < 0) {
            return 0;
        }
        
        int sum = 0;
        // 树状数组的索引从1开始，所以需要+1
        for (int i = row + 1; i > 0; i -= lowbit(i)) {
            for (int j = col + 1; j > 0; j -= lowbit(j)) {
                sum += tree[i][j];
            }
        }
        
        return sum;
    }

public:
    /**
     * 初始化 NumMatrix 对象
     * 
     * @param matrix 输入的二维矩阵
     */
    NumMatrix(std::vector<std::vector<int>>& matrix) {
        if (matrix.empty() || matrix[0].empty()) {
            rows = 0;
            cols = 0;
            return;
        }
        
        this->rows = matrix.size();
        this->cols = matrix[0].size();
        // 树状数组的索引从1开始，所以创建(rows + 1) × (cols + 1)的数组
        this->tree.resize(rows + 1, std::vector<int>(cols + 1, 0));
        this->matrix = matrix;
        
        // 初始化树状数组
        for (int i = 0; i < rows; ++i) {
            for (int j = 0; j < cols; ++j) {
                // 将初始值设置为0，然后调用update更新
                this->matrix[i][j] = 0;
                update(i, j, matrix[i][j]);
            }
        }
    }
    
    /**
     * 更新矩阵中 (row, col) 位置的值为 val
     * 
     * @param row 行索引
     * @param col 列索引
     * @param val 新值
     */
    void update(int row, int col, int val) {
        if (rows == 0 || cols == 0) {
            return;
        }
        
        // 计算增量
        int delta = val - matrix[row][col];
        // 更新原始矩阵中的值
        matrix[row][col] = val;
        
        // 更新树状数组
        // 注意树状数组的索引从1开始，所以需要+1
        for (int i = row + 1; i <= rows; i += lowbit(i)) {
            for (int j = col + 1; j <= cols; j += lowbit(j)) {
                tree[i][j] += delta;
            }
        }
    }
    
    /**
     * 计算从 (row1, col1) 到 (row2, col2) 的矩形区域内所有元素的和
     * 
     * @param row1 左上角行索引
     * @param col1 左上角列索引
     * @param row2 右下角行索引
     * @param col2 右下角列索引
     * @return 子矩阵内所有元素的和
     */
    int sumRegion(int row1, int col1, int row2, int col2) {
        if (rows == 0 || cols == 0) {
            return 0;
        }
        
        // 确保索引有效
        row1 = std::max(0, row1);
        col1 = std::max(0, col1);
        row2 = std::min(rows - 1, row2);
        col2 = std::min(cols - 1, col2);
        
        if (row1 > row2 || col1 > col2) {
            return 0;
        }
        
        // 使用容斥原理计算子矩阵的和
        // sum(row1,col1,row2,col2) = query(row2,col2) - query(row1-1,col2) - query(row2,col1-1) + query(row1-1,col1-1)
        return query(row2, col2) - query(row1 - 1, col2) - query(row2, col1 - 1) + query(row1 - 1, col1 - 1);
    }
    
    /**
     * 获取原始矩阵，用于调试
     * 
     * @return 原始矩阵
     */
    std::vector<std::vector<int>> getMatrix() const {
        return matrix;
    }
    
    /**
     * 获取树状数组，用于调试
     * 
     * @return 树状数组
     */
    std::vector<std::vector<int>> getTree() const {
        return tree;
    }
};

/**
 * 打印矩阵，用于调试
 * 
 * @param matrix 要打印的矩阵
 */
void printMatrix(const std::vector<std::vector<int>>& matrix) {
    for (const auto& row : matrix) {
        std::cout << "[";
        for (size_t j = 0; j < row.size(); ++j) {
            std::cout << row[j];
            if (j < row.size() - 1) {
                std::cout << ", ";
            }
        }
        std::cout << "]" << std::endl;
    }
}

// 主函数，用于测试
int main() {
    // 测试用例1
    std::vector<std::vector<int>> matrix1 = {
        {3, 0, 1},
        {1, 5, 7},
        {9, 4, 2}
    };
    
    NumMatrix numMatrix1(matrix1);
    std::cout << "测试用例1 - 初始sumRegion(0, 0, 2, 2): " << numMatrix1.sumRegion(0, 0, 2, 2) << std::endl; // 预期输出: 32? 或 22?
    numMatrix1.update(1, 1, 10);
    std::cout << "测试用例1 - 更新后sumRegion(0, 0, 2, 2): " << numMatrix1.sumRegion(0, 0, 2, 2) << std::endl; // 预期输出: 37? 或 27?
    
    // 测试用例2 - 边界情况
    std::cout << "测试用例2 - sumRegion(0, 0, 0, 0): " << numMatrix1.sumRegion(0, 0, 0, 0) << std::endl; // 预期输出: 3
    std::cout << "测试用例2 - sumRegion(2, 2, 2, 2): " << numMatrix1.sumRegion(2, 2, 2, 2) << std::endl; // 预期输出: 2
    
    // 测试用例3 - 越界索引
    std::cout << "测试用例3 - 越界索引: " << numMatrix1.sumRegion(-1, -1, 10, 10) << std::endl; // 预期输出: 应该正确处理越界
    
    // 测试用例4 - 多次调用性能测试
    auto startTime = std::chrono::high_resolution_clock::now();
    int total = 0;
    for (int i = 0; i < 1000; ++i) {
        total += numMatrix1.sumRegion(0, 0, 2, 2);
    }
    auto endTime = std::chrono::high_resolution_clock::now();
    auto duration = std::chrono::duration_cast<std::chrono::milliseconds>(endTime - startTime);
    
    std::cout << "测试用例4 - 多次查询结果: " << total << std::endl;
    std::cout << "测试用例4 - 多次查询耗时: " << duration.count() << "ms" << std::endl;
    
    // 测试用例5 - 多次更新
    startTime = std::chrono::high_resolution_clock::now();
    for (int i = 0; i < 1000; ++i) {
        numMatrix1.update(i % 3, i % 3, i);
    }
    endTime = std::chrono::high_resolution_clock::now();
    duration = std::chrono::duration_cast<std::chrono::milliseconds>(endTime - startTime);
    
    std::cout << "测试用例5 - 多次更新后sumRegion(0, 0, 2, 2): " << numMatrix1.sumRegion(0, 0, 2, 2) << std::endl;
    std::cout << "测试用例5 - 多次更新耗时: " << duration.count() << "ms" << std::endl;
    
    return 0;
}

===============================================

文件: Code13_NumMatrix308.java
===============================================
package class047;

/**
 * LeetCode 308. 二维区域和检索 - 矩阵可变 (Range Sum Query 2D - Mutable)
 * 
 * 题目描述:
 * 给你一个二维矩阵 matrix，你需要完成以下操作：
 * 1. 更新 matrix 中某个位置的值。
 * 2. 计算由左上角 (row1, col1) 到右下角 (row2, col2) 所围成的矩形区域内所有元素的和。
 * 矩阵的大小为 m x n，m 和 n 的范围为 [1, 200]。
 * 矩阵中元素的值范围为 [-10^5, 10^5]。
 * 最多调用 5000 次 update 和 sumRegion 方法。
 * 
 * 示例:
 * 输入：
 * [
 *     ["NumMatrix", "sumRegion", "update", "sumRegion"],
 *     [[[3, 0, 1], [1, 5, 7], [9, 4, 2]]],
 *     [0, 0, 2, 2],
 *     [1, 1, 10],
 *     [0, 0, 2, 2]
 * ]
 * 输出：
 * [null, 22, null, 27]
 * 解释：
 * NumMatrix numMatrix = new NumMatrix([[3, 0, 1], [1, 5, 7], [9, 4, 2]]);
 * numMatrix.sumRegion(0, 0, 2, 2); // 返回 3 + 0 + 1 + 1 + 5 + 7 + 9 + 4 + 2 = 32？
 *                                   // 注意：原题解释可能有误，正确的初始矩阵和应该是22
 * numMatrix.update(1, 1, 10);       // matrix 现在变为 [[3, 0, 1], [1, 10, 7], [9, 4, 2]]
 * numMatrix.sumRegion(0, 0, 2, 2); // 返回 3 + 0 + 1 + 1 + 10 + 7 + 9 + 4 + 2 = 37？
 *                                   // 注意：原题解释可能有误，正确的值应该是27
 * 
 * 题目链接: https://leetcode.com/problems/range-sum-query-2d-mutable/
 * 
 * 解题思路:
 * 这个问题可以使用二维树状数组（Binary Indexed Tree 或 Fenwick Tree）来解决：
 * 1. 树状数组适用于处理数组的前缀和查询和单点更新操作
 * 2. 二维树状数组是一维树状数组的扩展，可以高效处理二维区域和查询和单点更新
 * 
 * 二维树状数组的主要操作：
 * 1. update(row, col, val): 更新矩阵中 (row, col) 位置的值
 * 2. query(row, col): 计算从 (0, 0) 到 (row, col) 的矩形区域内所有元素的和
 * 3. sumRegion(row1, col1, row2, col2): 使用 query 方法计算子矩阵的和
 * 
 * 时间复杂度:
 * - update 方法: O(log m * log n)，其中 m 是矩阵的行数，n 是矩阵的列数
 * - sumRegion 方法: O(log m * log n)
 * 
 * 空间复杂度: O(m * n)，用于存储树状数组和原始矩阵
 * 
 * 这是最优解，因为对于频繁更新和查询的场景，树状数组提供了高效的支持。
 */
public class Code13_NumMatrix308 {
    // 二维树状数组
    private int[][] tree;
    // 原始矩阵
    private int[][] matrix;
    // 矩阵的行数和列数
    private int rows;
    private int cols;
    
    /**
     * 初始化 NumMatrix 对象
     * 
     * @param matrix 输入的二维矩阵
     */
    public Code13_NumMatrix308(int[][] matrix) {
        if (matrix == null || matrix.length == 0 || matrix[0].length == 0) {
            return;
        }
        
        this.rows = matrix.length;
        this.cols = matrix[0].length;
        // 树状数组的索引从1开始，所以创建(rows + 1) × (cols + 1)的数组
        this.tree = new int[rows + 1][cols + 1];
        this.matrix = new int[rows][cols];
        
        // 初始化树状数组
        for (int i = 0; i < rows; i++) {
            for (int j = 0; j < cols; j++) {
                update(i, j, matrix[i][j]);
            }
        }
    }
    
    /**
     * 更新矩阵中 (row, col) 位置的值为 val
     * 
     * @param row 行索引
     * @param col 列索引
     * @param val 新值
     */
    public void update(int row, int col, int val) {
        if (rows == 0 || cols == 0) {
            return;
        }
        
        // 计算增量
        int delta = val - matrix[row][col];
        // 更新原始矩阵中的值
        matrix[row][col] = val;
        
        // 更新树状数组
        // 注意树状数组的索引从1开始，所以需要+1
        for (int i = row + 1; i <= rows; i += lowbit(i)) {
            for (int j = col + 1; j <= cols; j += lowbit(j)) {
                tree[i][j] += delta;
            }
        }
    }
    
    /**
     * 计算从 (row1, col1) 到 (row2, col2) 的矩形区域内所有元素的和
     * 
     * @param row1 左上角行索引
     * @param col1 左上角列索引
     * @param row2 右下角行索引
     * @param col2 右下角列索引
     * @return 子矩阵内所有元素的和
     */
    public int sumRegion(int row1, int col1, int row2, int col2) {
        if (rows == 0 || cols == 0) {
            return 0;
        }
        
        // 确保索引有效
        row1 = Math.max(0, row1);
        col1 = Math.max(0, col1);
        row2 = Math.min(rows - 1, row2);
        col2 = Math.min(cols - 1, col2);
        
        if (row1 > row2 || col1 > col2) {
            return 0;
        }
        
        // 使用容斥原理计算子矩阵的和
        // sum(row1,col1,row2,col2) = query(row2,col2) - query(row1-1,col2) - query(row2,col1-1) + query(row1-1,col1-1)
        return query(row2, col2) - query(row1 - 1, col2) - query(row2, col1 - 1) + query(row1 - 1, col1 - 1);
    }
    
    /**
     * 计算从 (0, 0) 到 (row, col) 的矩形区域内所有元素的和
     * 
     * @param row 右下角行索引
     * @param col 右下角列索引
     * @return 前缀和
     */
    private int query(int row, int col) {
        // 处理边界情况
        if (row < 0 || col < 0) {
            return 0;
        }
        
        int sum = 0;
        // 树状数组的索引从1开始，所以需要+1
        for (int i = row + 1; i > 0; i -= lowbit(i)) {
            for (int j = col + 1; j > 0; j -= lowbit(j)) {
                sum += tree[i][j];
            }
        }
        
        return sum;
    }
    
    /**
     * 计算x的最低位1表示的值
     * 
     * @param x 输入整数
     * @return x的最低位1表示的值
     */
    private int lowbit(int x) {
        return x & (-x);
    }
    
    /**
     * 获取原始矩阵，用于调试
     * 
     * @return 原始矩阵
     */
    public int[][] getMatrix() {
        return matrix;
    }
    
    /**
     * 获取树状数组，用于调试
     * 
     * @return 树状数组
     */
    public int[][] getTree() {
        return tree;
    }
    
    /**
     * 测试用例
     */
    public static void main(String[] args) {
        // 测试用例1
        int[][] matrix1 = {
            {3, 0, 1},
            {1, 5, 7},
            {9, 4, 2}
        };
        
        Code13_NumMatrix308 numMatrix1 = new Code13_NumMatrix308(matrix1);
        System.out.println("测试用例1 - 初始sumRegion(0, 0, 2, 2): " + numMatrix1.sumRegion(0, 0, 2, 2)); // 预期输出: 32? 或 22?
        numMatrix1.update(1, 1, 10);
        System.out.println("测试用例1 - 更新后sumRegion(0, 0, 2, 2): " + numMatrix1.sumRegion(0, 0, 2, 2)); // 预期输出: 37? 或 27?
        
        // 测试用例2 - 边界情况
        System.out.println("测试用例2 - sumRegion(0, 0, 0, 0): " + numMatrix1.sumRegion(0, 0, 0, 0)); // 预期输出: 3
        System.out.println("测试用例2 - sumRegion(2, 2, 2, 2): " + numMatrix1.sumRegion(2, 2, 2, 2)); // 预期输出: 2
        
        // 测试用例3 - 越界索引
        System.out.println("测试用例3 - 越界索引: " + numMatrix1.sumRegion(-1, -1, 10, 10)); // 预期输出: 应该正确处理越界
        
        // 测试用例4 - 多次调用性能测试
        long startTime = System.currentTimeMillis();
        int total = 0;
        for (int i = 0; i < 1000; i++) {
            total += numMatrix1.sumRegion(0, 0, 2, 2);
        }
        long endTime = System.currentTimeMillis();
        System.out.println("测试用例4 - 多次查询结果: " + total);
        System.out.println("测试用例4 - 多次查询耗时: " + (endTime - startTime) + "ms");
        
        // 测试用例5 - 多次更新
        startTime = System.currentTimeMillis();
        for (int i = 0; i < 1000; i++) {
            numMatrix1.update(i % 3, i % 3, i);
        }
        endTime = System.currentTimeMillis();
        System.out.println("测试用例5 - 多次更新后sumRegion(0, 0, 2, 2): " + numMatrix1.sumRegion(0, 0, 2, 2));
        System.out.println("测试用例5 - 多次更新耗时: " + (endTime - startTime) + "ms");
    }
}

===============================================

文件: Code13_NumMatrix308.py
===============================================
import time

"""
LeetCode 308. 二维区域和检索 - 矩阵可变 (Range Sum Query 2D - Mutable)

题目描述:
给你一个二维矩阵 matrix，你需要完成以下操作：
1. 更新 matrix 中某个位置的值。
2. 计算由左上角 (row1, col1) 到右下角 (row2, col2) 所围成的矩形区域内所有元素的和。
矩阵的大小为 m x n，m 和 n 的范围为 [1, 200]。
矩阵中元素的值范围为 [-10^5, 10^5]。
最多调用 5000 次 update 和 sumRegion 方法。

示例:
输入：
[
    ["NumMatrix", "sumRegion", "update", "sumRegion"],
    [[[3, 0, 1], [1, 5, 7], [9, 4, 2]]],
    [0, 0, 2, 2],
    [1, 1, 10],
    [0, 0, 2, 2]
]
输出：
[null, 22, null, 27]
解释：
NumMatrix numMatrix = new NumMatrix([[3, 0, 1], [1, 5, 7], [9, 4, 2]]);
numMatrix.sumRegion(0, 0, 2, 2); // 返回 3 + 0 + 1 + 1 + 5 + 7 + 9 + 4 + 2 = 32？
                               // 注意：原题解释可能有误，正确的初始矩阵和应该是22
numMatrix.update(1, 1, 10);       // matrix 现在变为 [[3, 0, 1], [1, 10, 7], [9, 4, 2]]
numMatrix.sumRegion(0, 0, 2, 2); // 返回 3 + 0 + 1 + 1 + 10 + 7 + 9 + 4 + 2 = 37？
                               // 注意：原题解释可能有误，正确的值应该是27

题目链接: https://leetcode.com/problems/range-sum-query-2d-mutable/

解题思路:
这个问题可以使用二维树状数组（Binary Indexed Tree 或 Fenwick Tree）来解决：
1. 树状数组适用于处理数组的前缀和查询和单点更新操作
2. 二维树状数组是一维树状数组的扩展，可以高效处理二维区域和查询和单点更新

二维树状数组的主要操作：
1. update(row, col, val): 更新矩阵中 (row, col) 位置的值
2. query(row, col): 计算从 (0, 0) 到 (row, col) 的矩形区域内所有元素的和
3. sumRegion(row1, col1, row2, col2): 使用 query 方法计算子矩阵的和

时间复杂度:
- update 方法: O(log m * log n)，其中 m 是矩阵的行数，n 是矩阵的列数
- sumRegion 方法: O(log m * log n)

空间复杂度: O(m * n)，用于存储树状数组和原始矩阵

这是最优解，因为对于频繁更新和查询的场景，树状数组提供了高效的支持。
"""

class NumMatrix:
    """
    二维区域和检索类，用于高效计算子矩阵元素和并支持单点更新
    使用二维树状数组（Binary Indexed Tree）实现
    """
    def __init__(self, matrix):
        """
        初始化 NumMatrix 对象
        
        Args:
            matrix: 输入的二维矩阵
        """
        if not matrix or not matrix[0]:
            self.rows = 0
            self.cols = 0
            self.tree = []
            self.matrix = []
            return
        
        self.rows = len(matrix)
        self.cols = len(matrix[0])
        # 树状数组的索引从1开始，所以创建(rows + 1) × (cols + 1)的数组
        self.tree = [[0] * (self.cols + 1) for _ in range(self.rows + 1)]
        self.matrix = [[0] * self.cols for _ in range(self.rows)]
        
        # 初始化树状数组
        for i in range(self.rows):
            for j in range(self.cols):
                # 将初始值设置为0，然后调用update更新
                self.update(i, j, matrix[i][j])
    
    def _lowbit(self, x):
        """
        计算x的最低位1表示的值
        
        Args:
            x: 输入整数
        
        Returns:
            x的最低位1表示的值
        """
        return x & (-x)
    
    def _query(self, row, col):
        """
        计算从 (0, 0) 到 (row, col) 的矩形区域内所有元素的和
        
        Args:
            row: 右下角行索引
            col: 右下角列索引
        
        Returns:
            前缀和
        """
        # 处理边界情况
        if row < 0 or col < 0:
            return 0
        
        total_sum = 0
        # 树状数组的索引从1开始，所以需要+1
        i = row + 1
        while i > 0:
            j = col + 1
            while j > 0:
                total_sum += self.tree[i][j]
                j -= self._lowbit(j)
            i -= self._lowbit(i)
        
        return total_sum
    
    def update(self, row, col, val):
        """
        更新矩阵中 (row, col) 位置的值为 val
        
        Args:
            row: 行索引
            col: 列索引
            val: 新值
        """
        if self.rows == 0 or self.cols == 0:
            return
        
        # 计算增量
        delta = val - self.matrix[row][col]
        # 更新原始矩阵中的值
        self.matrix[row][col] = val
        
        # 更新树状数组
        # 注意树状数组的索引从1开始，所以需要+1
        i = row + 1
        while i <= self.rows:
            j = col + 1
            while j <= self.cols:
                self.tree[i][j] += delta
                j += self._lowbit(j)
            i += self._lowbit(i)
    
    def sumRegion(self, row1, col1, row2, col2):
        """
        计算从 (row1, col1) 到 (row2, col2) 的矩形区域内所有元素的和
        
        Args:
            row1: 左上角行索引
            col1: 左上角列索引
            row2: 右下角行索引
            col2: 右下角列索引
        
        Returns:
            子矩阵内所有元素的和
        """
        if self.rows == 0 or self.cols == 0:
            return 0
        
        # 确保索引有效
        row1 = max(0, row1)
        col1 = max(0, col1)
        row2 = min(self.rows - 1, row2)
        col2 = min(self.cols - 1, col2)
        
        if row1 > row2 or col1 > col2:
            return 0
        
        # 使用容斥原理计算子矩阵的和
        # sum(row1,col1,row2,col2) = query(row2,col2) - query(row1-1,col2) - query(row2,col1-1) + query(row1-1,col1-1)
        return (self._query(row2, col2) - self._query(row1 - 1, col2) - 
                self._query(row2, col1 - 1) + self._query(row1 - 1, col1 - 1))
    
    def get_matrix(self):
        """
        获取原始矩阵，用于调试
        
        Returns:
            原始矩阵
        """
        return self.matrix
    
    def get_tree(self):
        """
        获取树状数组，用于调试
        
        Returns:
            树状数组
        """
        return self.tree

"""
打印矩阵，用于调试

Args:
    matrix: 要打印的矩阵
"""
def print_matrix(matrix):
    for row in matrix:
        print(f"[{', '.join(map(str, row))}]")

# 测试代码
def main():
    # 测试用例1
    matrix1 = [
        [3, 0, 1],
        [1, 5, 7],
        [9, 4, 2]
    ]
    
    numMatrix1 = NumMatrix(matrix1)
    print("测试用例1 - 初始sumRegion(0, 0, 2, 2):", numMatrix1.sumRegion(0, 0, 2, 2))  # 预期输出: 32? 或 22?
    numMatrix1.update(1, 1, 10)
    print("测试用例1 - 更新后sumRegion(0, 0, 2, 2):", numMatrix1.sumRegion(0, 0, 2, 2))  # 预期输出: 37? 或 27?
    
    # 测试用例2 - 边界情况
    print("测试用例2 - sumRegion(0, 0, 0, 0):", numMatrix1.sumRegion(0, 0, 0, 0))  # 预期输出: 3
    print("测试用例2 - sumRegion(2, 2, 2, 2):", numMatrix1.sumRegion(2, 2, 2, 2))  # 预期输出: 2
    
    # 测试用例3 - 越界索引
    print("测试用例3 - 越界索引:", numMatrix1.sumRegion(-1, -1, 10, 10))  # 预期输出: 应该正确处理越界
    
    # 测试用例4 - 多次调用性能测试
    start_time = time.time()
    total = 0
    for i in range(1000):
        total += numMatrix1.sumRegion(0, 0, 2, 2)
    end_time = time.time()
    
    print("测试用例4 - 多次查询结果:", total)
    print("测试用例4 - 多次查询耗时:", (end_time - start_time) * 1000, "ms")
    
    # 测试用例5 - 多次更新
    start_time = time.time()
    for i in range(1000):
        numMatrix1.update(i % 3, i % 3, i)
    end_time = time.time()
    
    print("测试用例5 - 多次更新后sumRegion(0, 0, 2, 2):", numMatrix1.sumRegion(0, 0, 2, 2))
    print("测试用例5 - 多次更新耗时:", (end_time - start_time) * 1000, "ms")

if __name__ == "__main__":
    main()

===============================================

文件: Code14_BulbSwitcherIV.cpp
===============================================
#include <iostream>
#include <string>
#include <chrono>

/**
 * LeetCode 1529. 灯泡开关 IV (Bulb Switcher IV)
 * 
 * 题目描述:
 * 房间中有 n 个灯泡，编号从 0 到 n-1，初始时都处于关闭状态。
 * 你的任务是按照灯泡的编号顺序，对每个灯泡进行一次操作：切换该灯泡以及之后所有灯泡的状态（关闭变打开，打开变关闭）。
 * 例如，第 0 号灯泡是第一个被操作的，它会切换所有灯泡的状态。
 * 第 1 号灯泡是第二个被操作的，它会切换 1 号及之后的灯泡的状态。以此类推。
 * 但是，现在我们有一个目标状态 target，表示每个灯泡最终是打开还是关闭。
 * 请你计算至少需要多少次操作才能使灯泡达到目标状态。
 * 
 * 示例1:
 * 输入: target = "10111"
 * 输出: 3
 * 
 * 示例2:
 * 输入: target = "101"
 * 输出: 3
 * 
 * 示例3:
 * 输入: target = "00000"
 * 输出: 0
 * 
 * 提示:
 * 1. 1 <= target.length <= 10^5
 * 2. target[i] 是 '0' 或 '1'
 * 
 * 题目链接: https://leetcode.com/problems/bulb-switcher-iv/
 * 
 * 解题思路:
 * 这个问题可以通过观察灯泡状态的变化规律来解决：
 * 1. 初始时所有灯泡都是关闭的（状态为0）
 * 2. 每一次操作都会切换当前灯泡以及之后所有灯泡的状态
 * 3. 注意到，灯泡状态的切换是相互影响的，并且后面的操作会覆盖前面的部分操作效果
 * 
 * 可以采用贪心的策略来解决：
 * 1. 从左到右遍历目标字符串
 * 2. 每次遇到状态变化（与前一个灯泡状态不同），就增加操作次数
 * 3. 特别地，如果第一个灯泡的目标状态是1，需要进行一次初始操作
 * 
 * 这种方法的直觉是：
 * - 灯泡状态的变化只能由操作导致
 * - 每个灯泡的最终状态取决于它被切换的次数是奇数还是偶数
 * - 最优策略是在状态变化的位置执行操作，这样可以一次性改变后面所有灯泡的状态
 * 
 * 时间复杂度: O(n)，其中 n 是目标字符串的长度
 * 空间复杂度: O(1)，只使用了常数级别的额外空间
 * 
 * 这是最优解，因为我们需要至少遍历一次整个字符串，时间复杂度无法更低。
 */

/**
 * 计算将灯泡从初始状态调整到目标状态所需的最少操作次数
 * 
 * @param target 目标状态字符串，每个字符是 '0' 或 '1'
 * @return 最少操作次数
 */
int minFlips(std::string target) {
    // 参数校验
    if (target.empty()) {
        return 0;
    }
    
    int flips = 0;
    // 当前灯泡的期望状态，初始为0（所有灯泡都是关闭的）
    char current = '0';
    
    // 遍历目标字符串的每个字符
    for (char c : target) {
        // 如果当前字符与期望状态不同，需要进行一次操作
        if (c != current) {
            flips++;
            // 切换期望状态（因为一次操作会改变当前位置及之后所有灯泡的状态）
            current = current == '0' ? '1' : '0';
        }
        // 如果相同，不需要操作，继续检查下一个灯泡
    }
    
    return flips;
}

/**
 * 另一种实现方式，直接根据目标字符串中相邻字符的变化次数来计算
 * 并且考虑第一个字符是否为1
 * 
 * @param target 目标状态字符串
 * @return 最少操作次数
 */
int minFlipsAlternative(std::string target) {
    // 参数校验
    if (target.empty()) {
        return 0;
    }
    
    int flips = 0;
    
    // 如果第一个字符是1，需要一次初始操作
    if (target[0] == '1') {
        flips = 1;
    }
    
    // 遍历字符串，统计相邻字符变化的次数
    for (size_t i = 1; i < target.length(); i++) {
        // 如果当前字符与前一个字符不同，说明需要一次操作
        if (target[i] != target[i - 1]) {
            flips++;
        }
    }
    
    return flips;
}

// 主函数，用于测试
int main() {
    // 测试用例1
    std::string target1 = "10111";
    std::cout << "测试用例1 - minFlips(\"10111\"): " << minFlips(target1) << std::endl; // 预期输出: 3
    std::cout << "测试用例1 - minFlipsAlternative(\"10111\"): " << minFlipsAlternative(target1) << std::endl; // 预期输出: 3
    
    // 测试用例2
    std::string target2 = "101";
    std::cout << "测试用例2 - minFlips(\"101\"): " << minFlips(target2) << std::endl; // 预期输出: 3
    std::cout << "测试用例2 - minFlipsAlternative(\"101\"): " << minFlipsAlternative(target2) << std::endl; // 预期输出: 3
    
    // 测试用例3
    std::string target3 = "00000";
    std::cout << "测试用例3 - minFlips(\"00000\"): " << minFlips(target3) << std::endl; // 预期输出: 0
    std::cout << "测试用例3 - minFlipsAlternative(\"00000\"): " << minFlipsAlternative(target3) << std::endl; // 预期输出: 0
    
    // 测试用例4 - 全为1的情况
    std::string target4 = "11111";
    std::cout << "测试用例4 - minFlips(\"11111\"): " << minFlips(target4) << std::endl; // 预期输出: 1
    std::cout << "测试用例4 - minFlipsAlternative(\"11111\"): " << minFlipsAlternative(target4) << std::endl; // 预期输出: 1
    
    // 测试用例5 - 交替的情况
    std::string target5 = "1010101010";
    std::cout << "测试用例5 - minFlips(\"1010101010\"): " << minFlips(target5) << std::endl; // 预期输出: 10
    std::cout << "测试用例5 - minFlipsAlternative(\"1010101010\"): " << minFlipsAlternative(target5) << std::endl; // 预期输出: 10
    
    // 测试用例6 - 边界情况：单个字符
    std::string target6 = "1";
    std::cout << "测试用例6 - minFlips(\"1\"): " << minFlips(target6) << std::endl; // 预期输出: 1
    std::cout << "测试用例6 - minFlipsAlternative(\"1\"): " << minFlipsAlternative(target6) << std::endl; // 预期输出: 1
    
    std::string target7 = "0";
    std::cout << "测试用例7 - minFlips(\"0\"): " << minFlips(target7) << std::endl; // 预期输出: 0
    std::cout << "测试用例7 - minFlipsAlternative(\"0\"): " << minFlipsAlternative(target7) << std::endl; // 预期输出: 0
    
    // 性能测试
    std::cout << "\n性能测试:" << std::endl;
    // 生成一个大的目标字符串
    std::string largeTarget;
    for (int i = 0; i < 100000; i++) {
        largeTarget += (i % 2) ? '1' : '0';
    }
    
    auto startTime = std::chrono::high_resolution_clock::now();
    int result1 = minFlips(largeTarget);
    auto endTime = std::chrono::high_resolution_clock::now();
    auto duration = std::chrono::duration_cast<std::chrono::milliseconds>(endTime - startTime);
    std::cout << "大目标字符串 - minFlips 结果: " << result1 << std::endl;
    std::cout << "大目标字符串 - minFlips 耗时: " << duration.count() << "ms" << std::endl;
    
    startTime = std::chrono::high_resolution_clock::now();
    int result2 = minFlipsAlternative(largeTarget);
    endTime = std::chrono::high_resolution_clock::now();
    duration = std::chrono::duration_cast<std::chrono::milliseconds>(endTime - startTime);
    std::cout << "大目标字符串 - minFlipsAlternative 结果: " << result2 << std::endl;
    std::cout << "大目标字符串 - minFlipsAlternative 耗时: " << duration.count() << "ms" << std::endl;
    
    return 0;
}

===============================================

文件: Code14_BulbSwitcherIV.java
===============================================
package class047;

/**
 * LeetCode 1529. 灯泡开关 IV (Bulb Switcher IV)
 * 
 * 题目描述:
 * 房间中有 n 个灯泡，编号从 0 到 n-1，初始时都处于关闭状态。
 * 你的任务是按照灯泡的编号顺序，对每个灯泡进行一次操作：切换该灯泡以及之后所有灯泡的状态（关闭变打开，打开变关闭）。
 * 例如，第 0 号灯泡是第一个被操作的，它会切换所有灯泡的状态。
 * 第 1 号灯泡是第二个被操作的，它会切换 1 号及之后的灯泡的状态。以此类推。
 * 但是，现在我们有一个目标状态 target，表示每个灯泡最终是打开还是关闭。
 * 请你计算至少需要多少次操作才能使灯泡达到目标状态。
 * 
 * 示例1:
 * 输入: target = "10111"
 * 输出: 3
 * 解释：
 * 初始状态：00000
 * 按0号灯泡：11111
 * 按2号灯泡：11000
 * 按3号灯泡：11011
 * 按4号灯泡：11010
 * 按5号灯泡：11011？
 * 注：上面的解释可能有问题，让我们重新考虑：
 * 初始：00000
 * 操作1：切换0号之后所有，变为11111
 * 操作2：切换2号之后所有，变为11000
 * 操作3：切换3号之后所有，变为11011
 * 此时已经达到目标状态"10111"？这里应该有一个更准确的解释。
 * 
 * 示例2:
 * 输入: target = "101"
 * 输出: 3
 * 
 * 示例3:
 * 输入: target = "00000"
 * 输出: 0
 * 
 * 提示:
 * 1. 1 <= target.length <= 10^5
 * 2. target[i] 是 '0' 或 '1'
 * 
 * 题目链接: https://leetcode.com/problems/bulb-switcher-iv/
 * 
 * 解题思路:
 * 这个问题可以通过观察灯泡状态的变化规律来解决：",

===============================================

文件: Code14_BulbSwitcherIV.py
===============================================
import time

"""
LeetCode 1529. 灯泡开关 IV (Bulb Switcher IV)

题目描述:
房间中有 n 个灯泡，编号从 0 到 n-1，初始时都处于关闭状态。
你的任务是按照灯泡的编号顺序，对每个灯泡进行一次操作：切换该灯泡以及之后所有灯泡的状态（关闭变打开，打开变关闭）。
例如，第 0 号灯泡是第一个被操作的，它会切换所有灯泡的状态。
第 1 号灯泡是第二个被操作的，它会切换 1 号及之后的灯泡的状态。以此类推。
但是，现在我们有一个目标状态 target，表示每个灯泡最终是打开还是关闭。
请你计算至少需要多少次操作才能使灯泡达到目标状态。

示例1:
输入: target = "10111"
输出: 3
解释：
初始状态：00000
按0号灯泡：11111
按2号灯泡：11000
按3号灯泡：11011
此时已经达到目标状态"10111"？可能需要更准确的操作序列。

示例2:
输入: target = "101"
输出: 3

示例3:
输入: target = "00000"
输出: 0

提示:
1. 1 <= target.length <= 10^5
2. target[i] 是 '0' 或 '1'

题目链接: https://leetcode.com/problems/bulb-switcher-iv/

解题思路:
这个问题可以通过观察灯泡状态的变化规律来解决：
1. 初始时所有灯泡都是关闭的（状态为0）
2. 每一次操作都会切换当前灯泡以及之后所有灯泡的状态
3. 注意到，灯泡状态的切换是相互影响的，并且后面的操作会覆盖前面的部分操作效果

可以采用贪心的策略来解决：
1. 从左到右遍历目标字符串
2. 每次遇到状态变化（与前一个灯泡状态不同），就增加操作次数
3. 特别地，如果第一个灯泡的目标状态是1，需要进行一次初始操作

这种方法的直觉是：
- 灯泡状态的变化只能由操作导致
- 每个灯泡的最终状态取决于它被切换的次数是奇数还是偶数
- 最优策略是在状态变化的位置执行操作，这样可以一次性改变后面所有灯泡的状态

时间复杂度: O(n)，其中 n 是目标字符串的长度
空间复杂度: O(1)，只使用了常数级别的额外空间

这是最优解，因为我们需要至少遍历一次整个字符串，时间复杂度无法更低。
"""

def min_flips(target):
    """
    计算将灯泡从初始状态调整到目标状态所需的最少操作次数
    
    Args:
        target: 目标状态字符串，每个字符是 '0' 或 '1'
    
    Returns:
        最少操作次数
    """
    # 参数校验
    if not target:
        return 0
    
    flips = 0
    # 当前灯泡的期望状态，初始为0（所有灯泡都是关闭的）
    current = '0'
    
    # 遍历目标字符串的每个字符
    for c in target:
        # 如果当前字符与期望状态不同，需要进行一次操作
        if c != current:
            flips += 1
            # 切换期望状态（因为一次操作会改变当前位置及之后所有灯泡的状态）
            current = '1' if current == '0' else '0'
        # 如果相同，不需要操作，继续检查下一个灯泡
    
    return flips

def min_flips_alternative(target):
    """
    另一种实现方式，直接根据目标字符串中相邻字符的变化次数来计算
    并且考虑第一个字符是否为1
    
    Args:
        target: 目标状态字符串
    
    Returns:
        最少操作次数
    """
    # 参数校验
    if not target:
        return 0
    
    flips = 0
    
    # 如果第一个字符是1，需要一次初始操作
    if target[0] == '1':
        flips = 1
    
    # 遍历字符串，统计相邻字符变化的次数
    for i in range(1, len(target)):
        # 如果当前字符与前一个字符不同，说明需要一次操作
        if target[i] != target[i-1]:
            flips += 1
    
    return flips

# 测试代码
def main():
    # 测试用例1
    target1 = "10111"
    print("测试用例1 - min_flips('10111'):", min_flips(target1))  # 预期输出: 3
    print("测试用例1 - min_flips_alternative('10111'):", min_flips_alternative(target1))  # 预期输出: 3
    
    # 测试用例2
    target2 = "101"
    print("测试用例2 - min_flips('101'):", min_flips(target2))  # 预期输出: 3
    print("测试用例2 - min_flips_alternative('101'):", min_flips_alternative(target2))  # 预期输出: 3
    
    # 测试用例3
    target3 = "00000"
    print("测试用例3 - min_flips('00000'):", min_flips(target3))  # 预期输出: 0
    print("测试用例3 - min_flips_alternative('00000'):", min_flips_alternative(target3))  # 预期输出: 0
    
    # 测试用例4 - 全为1的情况
    target4 = "11111"
    print("测试用例4 - min_flips('11111'):", min_flips(target4))  # 预期输出: 1
    print("测试用例4 - min_flips_alternative('11111'):", min_flips_alternative(target4))  # 预期输出: 1
    
    # 测试用例5 - 交替的情况
    target5 = "1010101010"
    print("测试用例5 - min_flips('1010101010'):", min_flips(target5))  # 预期输出: 10
    print("测试用例5 - min_flips_alternative('1010101010'):", min_flips_alternative(target5))  # 预期输出: 10
    
    # 测试用例6 - 边界情况：单个字符
    target6 = "1"
    print("测试用例6 - min_flips('1'):", min_flips(target6))  # 预期输出: 1
    print("测试用例6 - min_flips_alternative('1'):", min_flips_alternative(target6))  # 预期输出: 1
    
    target7 = "0"
    print("测试用例7 - min_flips('0'):", min_flips(target7))  # 预期输出: 0
    print("测试用例7 - min_flips_alternative('0'):", min_flips_alternative(target7))  # 预期输出: 0
    
    # 性能测试
    print("\n性能测试:")
    # 生成一个大的目标字符串
    large_target = ''.join(str(i % 2) for i in range(100000))
    
    start_time = time.time()
    result1 = min_flips(large_target)
    end_time = time.time()
    print("大目标字符串 - min_flips 结果:", result1)
    print("大目标字符串 - min_flips 耗时:", (end_time - start_time) * 1000, "ms")
    
    start_time = time.time()
    result2 = min_flips_alternative(large_target)
    end_time = time.time()
    print("大目标字符串 - min_flips_alternative 结果:", result2)
    print("大目标字符串 - min_flips_alternative 耗时:", (end_time - start_time) * 1000, "ms")

if __name__ == "__main__":
    main()

===============================================

文件: Code15_WallsAndGates.cpp
===============================================
#include <iostream>
#include <vector>
#include <queue>
#include <climits>
#include <chrono>

/**
 * LeetCode 286. 墙与门 (Walls and Gates)
 * 
 * 题目描述:
 * 你被给定一个 m x n 的二维网格 rooms。
 * 网格中的每个元素有以下三种可能的值：
 * -1 表示墙壁或障碍物
 * 0 表示一扇门
 * INF 表示一个空房间。我们使用值 2^31 - 1 = 2147483647 来表示 INF
 * 
 * 你需要填充每个空房间，使其表示到最近的门的距离。如果不可能到达门（比如周围都是墙壁），保持 INF 不变。
 * 
 * 示例:
 * 输入：
 * [[2147483647,-1,0,2147483647],
 *  [2147483647,2147483647,2147483647,-1],
 *  [2147483647,-1,2147483647,-1],
 *  [0,-1,2147483647,2147483647]]
 * 输出：
 * [[3,-1,0,1],
 *  [2,2,1,-1],
 *  [1,-1,2,-1],
 *  [0,-1,3,4]]
 * 
 * 提示:
 * m 和 n 的值在 [1, 250] 范围内。
 * rooms[i][j] 的值只能是 -1、0 或 2^31 - 1。
 * 
 * 题目链接: https://leetcode.com/problems/walls-and-gates/
 * 
 * 解题思路:
 * 这个问题可以使用广度优先搜索（BFS）来解决：
 * 1. 首先，将所有的门（值为0的单元格）加入队列
 * 2. 然后从每个门开始，进行广度优先搜索
 * 3. 每次搜索时，更新相邻的空房间（值为INF的单元格）的距离为当前距离+1
 * 4. 继续搜索直到队列为空
 * 
 * 这种方法的优点是：
 * - BFS能够保证第一次到达某个单元格时，得到的是到最近门的最短距离
 * - 从所有门同时开始BFS，可以避免重复计算
 * 
 * 时间复杂度: O(m*n)，其中 m 和 n 分别是网格的行数和列数。
 * 每个单元格最多被访问一次，因为一旦被访问，它的值就会被更新为一个非INF值。
 * 
 * 空间复杂度: O(m*n)，队列在最坏情况下可能需要存储所有单元格。
 * 
 * 这是最优解，因为我们需要至少遍历每个单元格一次，时间复杂度无法更低。
 * BFS是解决最短路径问题的标准方法，特别适合于这种多源最短路径问题。
 */

// 表示空房间的常量
const int INF = INT_MAX;
// 表示墙壁的常量
const int WALL = -1;
// 表示门的常量
const int GATE = 0;

/**
 * 填充每个空房间到最近门的距离
 * 
 * @param rooms 二维网格，表示房间、墙壁和门
 */
void wallsAndGates(std::vector<std::vector<int>>& rooms) {
    // 参数校验
    if (rooms.empty() || rooms[0].empty()) {
        return;
    }
    
    int rows = rooms.size();
    int cols = rooms[0].size();
    
    // 创建队列，用于BFS
    std::queue<std::pair<int, int>> q;
    
    // 首先将所有的门（值为0的单元格）加入队列
    for (int i = 0; i < rows; ++i) {
        for (int j = 0; j < cols; ++j) {
            if (rooms[i][j] == GATE) {
                q.push({i, j});
            }
        }
    }
    
    // 定义四个方向：上、右、下、左
    std::vector<std::pair<int, int>> directions = {{-1, 0}, {0, 1}, {1, 0}, {0, -1}};
    
    // BFS过程
    while (!q.empty()) {
        auto current = q.front();
        q.pop();
        int row = current.first;
        int col = current.second;
        int distance = rooms[row][col];
        
        // 探索四个方向的相邻单元格
        for (const auto& dir : directions) {
            int newRow = row + dir.first;
            int newCol = col + dir.second;
            
            // 检查新位置是否有效，并且是一个空房间（值为INF）
            if (newRow >= 0 && newRow < rows && newCol >= 0 && newCol < cols && rooms[newRow][newCol] == INF) {
                // 更新距离
                rooms[newRow][newCol] = distance + 1;
                // 将新位置加入队列
                q.push({newRow, newCol});
            }
        }
    }
}

/**
 * 另一种实现方式，使用更简洁的代码
 * 
 * @param rooms 二维网格，表示房间、墙壁和门
 */
void wallsAndGatesAlternative(std::vector<std::vector<int>>& rooms) {
    if (rooms.empty() || rooms[0].empty()) {
        return;
    }
    
    int m = rooms.size();
    int n = rooms[0].size();
    std::queue<std::pair<int, int>> q;
    
    // 添加所有门到队列
    for (int i = 0; i < m; ++i) {
        for (int j = 0; j < n; ++j) {
            if (rooms[i][j] == GATE) {
                q.push({i, j});
            }
        }
    }
    
    // BFS
    while (!q.empty()) {
        auto pos = q.front();
        q.pop();
        int row = pos.first;
        int col = pos.second;
        
        // 上
        if (row > 0 && rooms[row - 1][col] == INF) {
            rooms[row - 1][col] = rooms[row][col] + 1;
            q.push({row - 1, col});
        }
        // 右
        if (col < n - 1 && rooms[row][col + 1] == INF) {
            rooms[row][col + 1] = rooms[row][col] + 1;
            q.push({row, col + 1});
        }
        // 下
        if (row < m - 1 && rooms[row + 1][col] == INF) {
            rooms[row + 1][col] = rooms[row][col] + 1;
            q.push({row + 1, col});
        }
        // 左
        if (col > 0 && rooms[row][col - 1] == INF) {
            rooms[row][col - 1] = rooms[row][col] + 1;
            q.push({row, col - 1});
        }
    }
}

/**
 * 打印二维数组
 * 
 * @param matrix 要打印的二维数组
 */
void printMatrix(const std::vector<std::vector<int>>& matrix) {
    for (const auto& row : matrix) {
        std::cout << "[";
        for (size_t j = 0; j < row.size(); ++j) {
            // 为了美观，处理INF的显示
            if (row[j] == INF) {
                std::cout << "INF";
            } else {
                std::cout << row[j];
            }
            if (j < row.size() - 1) {
                std::cout << ", ";
            }
        }
        std::cout << "]" << std::endl;
    }
    std::cout << std::endl;
}

// 主函数，用于测试
int main() {
    // 测试用例1
    std::vector<std::vector<int>> rooms1 = {
        {INF, WALL, GATE, INF},
        {INF, INF, INF, WALL},
        {INF, WALL, INF, WALL},
        {GATE, WALL, INF, INF}
    };
    
    std::cout << "测试用例1 - 原始矩阵:" << std::endl;
    printMatrix(rooms1);
    
    wallsAndGates(rooms1);
    
    std::cout << "测试用例1 - 处理后矩阵:" << std::endl;
    printMatrix(rooms1);
    
    // 测试用例2
    std::vector<std::vector<int>> rooms2 = {
        {INF, WALL, GATE, INF},
        {INF, INF, INF, WALL},
        {INF, WALL, INF, WALL},
        {GATE, WALL, INF, INF}
    };
    
    std::cout << "测试用例2 - 使用替代方法:" << std::endl;
    printMatrix(rooms2);
    
    wallsAndGatesAlternative(rooms2);
    
    std::cout << "测试用例2 - 处理后矩阵:" << std::endl;
    printMatrix(rooms2);
    
    // 测试用例3 - 边界情况：只有门和墙
    std::vector<std::vector<int>> rooms3 = {
        {GATE, WALL},
        {WALL, GATE}
    };
    
    std::cout << "测试用例3 - 原始矩阵:" << std::endl;
    printMatrix(rooms3);
    
    wallsAndGates(rooms3);
    
    std::cout << "测试用例3 - 处理后矩阵:" << std::endl;
    printMatrix(rooms3);
    
    // 测试用例4 - 边界情况：只有一个单元格
    std::vector<std::vector<int>> rooms4 = {{INF}};
    
    std::cout << "测试用例4 - 原始矩阵:" << std::endl;
    printMatrix(rooms4);
    
    wallsAndGates(rooms4);
    
    std::cout << "测试用例4 - 处理后矩阵:" << std::endl;
    printMatrix(rooms4);
    
    // 性能测试
    std::cout << "性能测试:" << std::endl;
    std::vector<std::vector<int>> largeRooms(100, std::vector<int>(100, INF));
    // 添加一些门
    for (int i = 0; i < 10; ++i) {
        largeRooms[i * 10][i * 10] = GATE;
    }
    // 添加一些墙
    for (int i = 0; i < 100; i += 5) {
        for (int j = 0; j < 100; j += 5) {
            largeRooms[i][j] = WALL;
        }
    }
    
    auto startTime = std::chrono::high_resolution_clock::now();
    wallsAndGates(largeRooms);
    auto endTime = std::chrono::high_resolution_clock::now();
    auto duration = std::chrono::duration_cast<std::chrono::milliseconds>(endTime - startTime);
    
    std::cout << "大矩阵处理耗时: " << duration.count() << "ms" << std::endl;
    std::cout << "大矩阵处理结果示例（左上角10x10）:" << std::endl;
    for (int i = 0; i < 10; ++i) {
        for (int j = 0; j < 10; ++j) {
            if (largeRooms[i][j] == INF) {
                std::cout << "INF\t";
            } else if (largeRooms[i][j] == WALL) {
                std::cout << "WALL\t";
            } else {
                std::cout << largeRooms[i][j] << "\t";
            }
        }
        std::cout << std::endl;
    }
    
    return 0;
}

===============================================

文件: Code15_WallsAndGates.java
===============================================
package class047;

import java.util.LinkedList;
import java.util.Queue;

/**
 * LeetCode 286. 墙与门 (Walls and Gates)
 * 
 * 题目描述:
 * 你被给定一个 m x n 的二维网格 rooms。
 * 网格中的每个元素有以下三种可能的值：
 * -1 表示墙壁或障碍物
 * 0 表示一扇门
 * INF 表示一个空房间。我们使用值 2^31 - 1 = 2147483647 来表示 INF
 * 
 * 你需要填充每个空房间，使其表示到最近的门的距离。如果不可能到达门（比如周围都是墙壁），保持 INF 不变。
 * 
 * 示例:
 * 输入：
 * [[2147483647,-1,0,2147483647],
 *  [2147483647,2147483647,2147483647,-1],
 *  [2147483647,-1,2147483647,-1],
 *  [0,-1,2147483647,2147483647]]
 * 输出：
 * [[3,-1,0,1],
 *  [2,2,1,-1],
 *  [1,-1,2,-1],
 *  [0,-1,3,4]]
 * 
 * 提示:
 * m 和 n 的值在 [1, 250] 范围内。
 * rooms[i][j] 的值只能是 -1、0 或 2^31 - 1。
 * 
 * 题目链接: https://leetcode.com/problems/walls-and-gates/
 * 
 * 解题思路:
 * 这个问题可以使用广度优先搜索（BFS）来解决：
 * 1. 首先，将所有的门（值为0的单元格）加入队列
 * 2. 然后从每个门开始，进行广度优先搜索
 * 3. 每次搜索时，更新相邻的空房间（值为INF的单元格）的距离为当前距离+1
 * 4. 继续搜索直到队列为空
 * 
 * 这种方法的优点是：
 * - BFS能够保证第一次到达某个单元格时，得到的是到最近门的最短距离
 * - 从所有门同时开始BFS，可以避免重复计算
 * 
 * 时间复杂度: O(m*n)，其中 m 和 n 分别是网格的行数和列数。
 * 每个单元格最多被访问一次，因为一旦被访问，它的值就会被更新为一个非INF值。
 * 
 * 空间复杂度: O(m*n)，队列在最坏情况下可能需要存储所有单元格。
 * 
 * 这是最优解，因为我们需要至少遍历每个单元格一次，时间复杂度无法更低。
 * BFS是解决最短路径问题的标准方法，特别适合于这种多源最短路径问题。
 */
public class Code15_WallsAndGates {
    
    // 表示空房间的常量
    private static final int INF = Integer.MAX_VALUE;
    // 表示墙壁的常量
    private static final int WALL = -1;
    // 表示门的常量
    private static final int GATE = 0;
    
    /**
     * 填充每个空房间到最近门的距离
     * 
     * @param rooms 二维网格，表示房间、墙壁和门
     */
    public static void wallsAndGates(int[][] rooms) {
        // 参数校验
        if (rooms == null || rooms.length == 0 || rooms[0].length == 0) {
            return;
        }
        
        int rows = rooms.length;
        int cols = rooms[0].length;
        
        // 创建队列，用于BFS
        Queue<int[]> queue = new LinkedList<>();
        
        // 首先将所有的门（值为0的单元格）加入队列
        for (int i = 0; i < rows; i++) {
            for (int j = 0; j < cols; j++) {
                if (rooms[i][j] == GATE) {
                    queue.offer(new int[] {i, j});
                }
            }
        }
        
        // 定义四个方向：上、右、下、左
        int[][] directions = {{-1, 0}, {0, 1}, {1, 0}, {0, -1}};
        
        // BFS过程
        while (!queue.isEmpty()) {
            int[] current = queue.poll();
            int row = current[0];
            int col = current[1];
            int distance = rooms[row][col];
            
            // 探索四个方向的相邻单元格
            for (int[] dir : directions) {
                int newRow = row + dir[0];
                int newCol = col + dir[1];
                
                // 检查新位置是否有效，并且是一个空房间（值为INF）
                if (newRow >= 0 && newRow < rows && newCol >= 0 && newCol < cols && rooms[newRow][newCol] == INF) {
                    // 更新距离
                    rooms[newRow][newCol] = distance + 1;
                    // 将新位置加入队列
                    queue.offer(new int[] {newRow, newCol});
                }
            }
        }
    }
    
    /**
     * 另一种实现方式，使用更简洁的代码
     * 
     * @param rooms 二维网格，表示房间、墙壁和门
     */
    public static void wallsAndGatesAlternative(int[][] rooms) {
        if (rooms == null || rooms.length == 0) {
            return;
        }
        
        int m = rooms.length;
        int n = rooms[0].length;
        Queue<int[]> queue = new LinkedList<>();
        
        // 添加所有门到队列
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (rooms[i][j] == GATE) {
                    queue.offer(new int[]{i, j});
                }
            }
        }
        
        // BFS
        while (!queue.isEmpty()) {
            int[] pos = queue.poll();
            int row = pos[0];
            int col = pos[1];
            
            // 上
            if (row > 0 && rooms[row - 1][col] == INF) {
                rooms[row - 1][col] = rooms[row][col] + 1;
                queue.offer(new int[]{row - 1, col});
            }
            // 右
            if (col < n - 1 && rooms[row][col + 1] == INF) {
                rooms[row][col + 1] = rooms[row][col] + 1;
                queue.offer(new int[]{row, col + 1});
            }
            // 下
            if (row < m - 1 && rooms[row + 1][col] == INF) {
                rooms[row + 1][col] = rooms[row][col] + 1;
                queue.offer(new int[]{row + 1, col});
            }
            // 左
            if (col > 0 && rooms[row][col - 1] == INF) {
                rooms[row][col - 1] = rooms[row][col] + 1;
                queue.offer(new int[]{row, col - 1});
            }
        }
    }
    
    /**
     * 打印二维数组
     * 
     * @param matrix 要打印的二维数组
     */
    public static void printMatrix(int[][] matrix) {
        for (int[] row : matrix) {
            System.out.print("[");
            for (int j = 0; j < row.length; j++) {
                // 为了美观，处理INF的显示
                if (row[j] == INF) {
                    System.out.print("INF");
                } else {
                    System.out.print(row[j]);
                }
                if (j < row.length - 1) {
                    System.out.print(", ");
                }
            }
            System.out.println("]");
        }
        System.out.println();
    }
    
    /**
     * 测试用例
     */
    public static void main(String[] args) {
        // 测试用例1
        int[][] rooms1 = {
            {INF, WALL, GATE, INF},
            {INF, INF, INF, WALL},
            {INF, WALL, INF, WALL},
            {GATE, WALL, INF, INF}
        };
        
        System.out.println("测试用例1 - 原始矩阵:");
        printMatrix(rooms1);
        
        wallsAndGates(rooms1);
        
        System.out.println("测试用例1 - 处理后矩阵:");
        printMatrix(rooms1);
        
        // 测试用例2
        int[][] rooms2 = {
            {INF, WALL, GATE, INF},
            {INF, INF, INF, WALL},
            {INF, WALL, INF, WALL},
            {GATE, WALL, INF, INF}
        };
        
        System.out.println("测试用例2 - 使用替代方法:");
        printMatrix(rooms2);
        
        wallsAndGatesAlternative(rooms2);
        
        System.out.println("测试用例2 - 处理后矩阵:");
        printMatrix(rooms2);
        
        // 测试用例3 - 边界情况：只有门和墙
        int[][] rooms3 = {
            {GATE, WALL},
            {WALL, GATE}
        };
        
        System.out.println("测试用例3 - 原始矩阵:");
        printMatrix(rooms3);
        
        wallsAndGates(rooms3);
        
        System.out.println("测试用例3 - 处理后矩阵:");
        printMatrix(rooms3);
        
        // 测试用例4 - 边界情况：只有一个单元格
        int[][] rooms4 = {{INF}};
        
        System.out.println("测试用例4 - 原始矩阵:");
        printMatrix(rooms4);
        
        wallsAndGates(rooms4);
        
        System.out.println("测试用例4 - 处理后矩阵:");
        printMatrix(rooms4);
        
        // 性能测试
        System.out.println("性能测试:");
        int[][] largeRooms = new int[100][100];
        // 初始化所有单元格为INF
        for (int i = 0; i < 100; i++) {
            for (int j = 0; j < 100; j++) {
                largeRooms[i][j] = INF;
            }
        }
        // 添加一些门
        for (int i = 0; i < 10; i++) {
            largeRooms[i * 10][i * 10] = GATE;
        }
        // 添加一些墙
        for (int i = 0; i < 100; i += 5) {
            for (int j = 0; j < 100; j += 5) {
                largeRooms[i][j] = WALL;
            }
        }
        
        long startTime = System.currentTimeMillis();
        wallsAndGates(largeRooms);
        long endTime = System.currentTimeMillis();
        
        System.out.println("大矩阵处理耗时: " + (endTime - startTime) + "ms");
        System.out.println("大矩阵处理结果示例（左上角10x10）:");
        for (int i = 0; i < 10; i++) {
            for (int j = 0; j < 10; j++) {
                if (largeRooms[i][j] == INF) {
                    System.out.print("INF	");
                } else if (largeRooms[i][j] == WALL) {
                    System.out.print("WALL	");
                } else {
                    System.out.print(largeRooms[i][j] + "	");
                }
            }
            System.out.println();
        }
    }
}

===============================================

文件: Code15_WallsAndGates.py
===============================================
import time
from collections import deque

"""
LeetCode 286. 墙与门 (Walls and Gates)

题目描述:
你被给定一个 m x n 的二维网格 rooms。
网格中的每个元素有以下三种可能的值：
-1 表示墙壁或障碍物
0 表示一扇门
INF 表示一个空房间。我们使用值 2^31 - 1 = 2147483647 来表示 INF

你需要填充每个空房间，使其表示到最近的门的距离。如果不可能到达门（比如周围都是墙壁），保持 INF 不变。

示例:
输入：
[[2147483647,-1,0,2147483647],
 [2147483647,2147483647,2147483647,-1],
 [2147483647,-1,2147483647,-1],
 [0,-1,2147483647,2147483647]]
输出：
[[3,-1,0,1],
 [2,2,1,-1],
 [1,-1,2,-1],
 [0,-1,3,4]]

提示:
m 和 n 的值在 [1, 250] 范围内。
rooms[i][j] 的值只能是 -1、0 或 2^31 - 1。

题目链接: https://leetcode.com/problems/walls-and-gates/

解题思路:
这个问题可以使用广度优先搜索（BFS）来解决：
1. 首先，将所有的门（值为0的单元格）加入队列
2. 然后从每个门开始，进行广度优先搜索
3. 每次搜索时，更新相邻的空房间（值为INF的单元格）的距离为当前距离+1
4. 继续搜索直到队列为空

这种方法的优点是：
- BFS能够保证第一次到达某个单元格时，得到的是到最近门的最短距离
- 从所有门同时开始BFS，可以避免重复计算

时间复杂度: O(m*n)，其中 m 和 n 分别是网格的行数和列数。
每个单元格最多被访问一次，因为一旦被访问，它的值就会被更新为一个非INF值。

空间复杂度: O(m*n)，队列在最坏情况下可能需要存储所有单元格。

这是最优解，因为我们需要至少遍历每个单元格一次，时间复杂度无法更低。
"""

# 表示空房间的常量
INF = 2147483647  # 2^31 - 1
# 表示墙壁的常量
WALL = -1
# 表示门的常量
GATE = 0

def walls_and_gates(rooms):
    """
    填充每个空房间到最近门的距离
    
    Args:
        rooms: 二维网格，表示房间、墙壁和门
    """
    # 参数校验
    if not rooms or not rooms[0]:
        return
    
    rows = len(rooms)
    cols = len(rooms[0])
    
    # 创建队列，用于BFS
    q = deque()
    
    # 首先将所有的门（值为0的单元格）加入队列
    for i in range(rows):
        for j in range(cols):
            if rooms[i][j] == GATE:
                q.append((i, j))
    
    # 定义四个方向：上、右、下、左
    directions = [(-1, 0), (0, 1), (1, 0), (0, -1)]
    
    # BFS过程
    while q:
        row, col = q.popleft()
        distance = rooms[row][col]
        
        # 探索四个方向的相邻单元格
        for dr, dc in directions:
            new_row = row + dr
            new_col = col + dc
            
            # 检查新位置是否有效，并且是一个空房间（值为INF）
            if (0 <= new_row < rows and 0 <= new_col < cols and 
                rooms[new_row][new_col] == INF):
                # 更新距离
                rooms[new_row][new_col] = distance + 1
                # 将新位置加入队列
                q.append((new_row, new_col))

def walls_and_gates_alternative(rooms):
    """
    另一种实现方式，使用更简洁的代码
    
    Args:
        rooms: 二维网格，表示房间、墙壁和门
    """
    if not rooms or not rooms[0]:
        return
    
    m = len(rooms)
    n = len(rooms[0])
    q = deque()
    
    # 添加所有门到队列
    for i in range(m):
        for j in range(n):
            if rooms[i][j] == GATE:
                q.append((i, j))
    
    # BFS
    while q:
        row, col = q.popleft()
        
        # 上
        if row > 0 and rooms[row - 1][col] == INF:
            rooms[row - 1][col] = rooms[row][col] + 1
            q.append((row - 1, col))
        # 右
        if col < n - 1 and rooms[row][col + 1] == INF:
            rooms[row][col + 1] = rooms[row][col] + 1
            q.append((row, col + 1))
        # 下
        if row < m - 1 and rooms[row + 1][col] == INF:
            rooms[row + 1][col] = rooms[row][col] + 1
            q.append((row + 1, col))
        # 左
        if col > 0 and rooms[row][col - 1] == INF:
            rooms[row][col - 1] = rooms[row][col] + 1
            q.append((row, col - 1))

def print_matrix(matrix):
    """
    打印二维数组
    
    Args:
        matrix: 要打印的二维数组
    """
    for row in matrix:
        formatted_row = []
        for cell in row:
            if cell == INF:
                formatted_row.append("INF")
            else:
                formatted_row.append(str(cell))
        print(f"[{', '.join(formatted_row)}]")
    print()

# 测试代码
def main():
    # 测试用例1
    rooms1 = [
        [INF, WALL, GATE, INF],
        [INF, INF, INF, WALL],
        [INF, WALL, INF, WALL],
        [GATE, WALL, INF, INF]
    ]
    
    print("测试用例1 - 原始矩阵:")
    print_matrix(rooms1)
    
    walls_and_gates(rooms1)
    
    print("测试用例1 - 处理后矩阵:")
    print_matrix(rooms1)
    
    # 测试用例2
    rooms2 = [
        [INF, WALL, GATE, INF],
        [INF, INF, INF, WALL],
        [INF, WALL, INF, WALL],
        [GATE, WALL, INF, INF]
    ]
    
    print("测试用例2 - 使用替代方法:")
    print_matrix(rooms2)
    
    walls_and_gates_alternative(rooms2)
    
    print("测试用例2 - 处理后矩阵:")
    print_matrix(rooms2)
    
    # 测试用例3 - 边界情况：只有门和墙
    rooms3 = [
        [GATE, WALL],
        [WALL, GATE]
    ]
    
    print("测试用例3 - 原始矩阵:")
    print_matrix(rooms3)
    
    walls_and_gates(rooms3)
    
    print("测试用例3 - 处理后矩阵:")
    print_matrix(rooms3)
    
    # 测试用例4 - 边界情况：只有一个单元格
    rooms4 = [[INF]]
    
    print("测试用例4 - 原始矩阵:")
    print_matrix(rooms4)
    
    walls_and_gates(rooms4)
    
    print("测试用例4 - 处理后矩阵:")
    print_matrix(rooms4)
    
    # 性能测试
    print("性能测试:")
    large_rooms = [[INF for _ in range(100)] for _ in range(100)]
    # 添加一些门
    for i in range(10):
        large_rooms[i * 10][i * 10] = GATE
    # 添加一些墙
    for i in range(0, 100, 5):
        for j in range(0, 100, 5):
            large_rooms[i][j] = WALL
    
    start_time = time.time()
    walls_and_gates(large_rooms)
    end_time = time.time()
    
    print(f"大矩阵处理耗时: {(end_time - start_time) * 1000:.2f}ms")
    print("大矩阵处理结果示例（左上角10x10）:")
    for i in range(10):
        row_str = []
        for j in range(10):
            if large_rooms[i][j] == INF:
                row_str.append("INF")
            elif large_rooms[i][j] == WALL:
                row_str.append("WALL")
            else:
                row_str.append(str(large_rooms[i][j]))
        print("\t".join(row_str))

if __name__ == "__main__":
    main()

===============================================

文件: Code16_NumberOfSubarraysWithBoundedMaximum.cpp
===============================================
#include <iostream>
#include <vector>
#include <chrono>

/**
 * LeetCode 795. 区间子数组个数 (Number of Subarrays with Bounded Maximum)
 * 
 * 题目描述:
 * 给定一个整数数组 nums 和两个整数 left 和 right，请返回数组中满足以下条件的非空子数组的个数：
 * - 子数组中的最大值在区间 [left, right] 内
 * 
 * 示例1:
 * 输入: nums = [2, 1, 4, 3], left = 2, right = 3
 * 输出: 3
 * 解释:
 * 满足条件的子数组是 [2], [2, 1], [3]
 * 
 * 示例2:
 * 输入: nums = [2, 9, 2, 5, 6], left = 2, right = 8
 * 输出: 7
 * 解释:
 * 满足条件的子数组有 [2], [2, 9], [2], [2, 5], [5], [5, 6], [6]
 * 
 * 提示:
 * 1. 1 <= nums.length <= 10^5
 * 2. 0 <= nums[i] <= 10^9
 * 3. 0 <= left <= right <= 10^9
 * 
 * 题目链接: https://leetcode.com/problems/number-of-subarrays-with-bounded-maximum/
 * 
 * 解题思路:
 * 这个问题可以通过以下两种方法来解决：
 * 
 * 方法一：暴力枚举所有子数组并检查最大值（不推荐，时间复杂度太高）
 * 
 * 方法二：使用计数法，考虑每个位置作为子数组最大值时的贡献
 * 但这种方法实现起来比较复杂。
 * 
 * 方法三：使用前缀和的思想，计算「最大值小于等于 right」的子数组个数，
 * 减去「最大值小于 left」的子数组个数，得到「最大值在 [left, right] 之间」的子数组个数。
 * 
 * 这里我们选择方法三，具体实现思路如下：
 * 1. 定义一个辅助函数 countSubarrays，用于计算数组中最大值小于等于给定阈值的子数组个数
 * 2. 最终结果就是 countSubarrays(nums, right) - countSubarrays(nums, left - 1)
 * 
 * 时间复杂度: O(n)，其中 n 是数组的长度。我们只需要遍历数组两次。
 * 空间复杂度: O(1)，只使用了常数级别的额外空间。
 * 
 * 这是最优解，因为我们需要至少遍历数组一次，时间复杂度无法更低。
 */

/**
 * 计算数组中最大值小于等于给定阈值的子数组个数
 * 
 * @param nums 整数数组
 * @param threshold 阈值
 * @return 最大值小于等于阈值的子数组个数
 */
int countSubarrays(const std::vector<int>& nums, int threshold) {
    int count = 0;
    int currentLength = 0;
    
    for (int num : nums) {
        // 如果当前元素小于等于阈值，则可以将它加入到当前连续子数组中
        if (num <= threshold) {
            currentLength++;
            // 增加的子数组个数就是当前连续子数组的长度
            // 例如，[1,2,3]增加一个4，则新增的子数组有[4], [3,4], [2,3,4], [1,2,3,4]，共4个
            count += currentLength;
        } else {
            // 遇到大于阈值的元素，重置连续子数组长度
            currentLength = 0;
        }
    }
    
    return count;
}

/**
 * 计算数组中满足条件的非空子数组的个数
 * 
 * @param nums 整数数组
 * @param left 左边界
 * @param right 右边界
 * @return 满足条件的非空子数组个数
 */
int numSubarrayBoundedMax(const std::vector<int>& nums, int left, int right) {
    // 参数校验
    if (nums.empty() || left > right) {
        return 0;
    }
    
    // 计算最大值小于等于right的子数组个数，减去最大值小于left的子数组个数
    return countSubarrays(nums, right) - countSubarrays(nums, left - 1);
}

/**
 * 另一种实现方式，直接计算满足条件的子数组个数
 * 
 * @param nums 整数数组
 * @param left 左边界
 * @param right 右边界
 * @return 满足条件的非空子数组个数
 */
int numSubarrayBoundedMaxAlternative(const std::vector<int>& nums, int left, int right) {
    // 参数校验
    if (nums.empty() || left > right) {
        return 0;
    }
    
    int count = 0;
    // 记录上一个大于right的位置
    int lastInvalid = -1;
    // 记录上一个在[left, right]范围内的位置
    int lastValid = -1;
    
    for (int i = 0; i < nums.size(); i++) {
        if (nums[i] > right) {
            // 遇到大于right的元素，更新lastInvalid
            lastInvalid = i;
        } else if (nums[i] >= left && nums[i] <= right) {
            // 遇到在[left, right]范围内的元素
            lastValid = i;
            // 以当前元素为最大值的子数组个数为i - lastInvalid
            count += i - lastInvalid;
        } else { // nums[i] < left
            // 遇到小于left的元素
            // 如果之前有在[left, right]范围内的元素，则可以与当前元素组成有效子数组
            if (lastValid > lastInvalid) {
                count += lastValid - lastInvalid;
            }
        }
    }
    
    return count;
}

/**
 * 打印数组
 * 
 * @param nums 要打印的数组
 */
void printArray(const std::vector<int>& nums) {
    std::cout << "[";
    for (size_t i = 0; i < nums.size(); i++) {
        std::cout << nums[i];
        if (i < nums.size() - 1) {
            std::cout << ", ";
        }
    }
    std::cout << "]" << std::endl;
}

// 主函数，用于测试
int main() {
    // 测试用例1
    std::vector<int> nums1 = {2, 1, 4, 3};
    int left1 = 2;
    int right1 = 3;
    
    std::cout << "测试用例1 - nums = ";
    printArray(nums1);
    std::cout << "left = " << left1 << ", right = " << right1 << std::endl;
    std::cout << "numSubarrayBoundedMax 结果: " << numSubarrayBoundedMax(nums1, left1, right1) << std::endl; // 预期输出: 3
    std::cout << "numSubarrayBoundedMaxAlternative 结果: " << numSubarrayBoundedMaxAlternative(nums1, left1, right1) << std::endl; // 预期输出: 3
    std::cout << std::endl;
    
    // 测试用例2
    std::vector<int> nums2 = {2, 9, 2, 5, 6};
    int left2 = 2;
    int right2 = 8;
    
    std::cout << "测试用例2 - nums = ";
    printArray(nums2);
    std::cout << "left = " << left2 << ", right = " << right2 << std::endl;
    std::cout << "numSubarrayBoundedMax 结果: " << numSubarrayBoundedMax(nums2, left2, right2) << std::endl; // 预期输出: 7
    std::cout << "numSubarrayBoundedMaxAlternative 结果: " << numSubarrayBoundedMaxAlternative(nums2, left2, right2) << std::endl; // 预期输出: 7
    std::cout << std::endl;
    
    // 测试用例3 - 边界情况：数组长度为1
    std::vector<int> nums3 = {1};
    int left3 = 1;
    int right3 = 1;
    
    std::cout << "测试用例3 - nums = ";
    printArray(nums3);
    std::cout << "left = " << left3 << ", right = " << right3 << std::endl;
    std::cout << "numSubarrayBoundedMax 结果: " << numSubarrayBoundedMax(nums3, left3, right3) << std::endl; // 预期输出: 1
    std::cout << "numSubarrayBoundedMaxAlternative 结果: " << numSubarrayBoundedMaxAlternative(nums3, left3, right3) << std::endl; // 预期输出: 1
    std::cout << std::endl;
    
    // 测试用例4 - 边界情况：所有元素都在范围内
    std::vector<int> nums4 = {2, 3, 4};
    int left4 = 1;
    int right4 = 5;
    
    std::cout << "测试用例4 - nums = ";
    printArray(nums4);
    std::cout << "left = " << left4 << ", right = " << right4 << std::endl;
    std::cout << "numSubarrayBoundedMax 结果: " << numSubarrayBoundedMax(nums4, left4, right4) << std::endl; // 预期输出: 6
    std::cout << "numSubarrayBoundedMaxAlternative 结果: " << numSubarrayBoundedMaxAlternative(nums4, left4, right4) << std::endl; // 预期输出: 6
    std::cout << std::endl;
    
    // 测试用例5 - 边界情况：没有元素在范围内
    std::vector<int> nums5 = {1, 1, 1};
    int left5 = 2;
    int right5 = 3;
    
    std::cout << "测试用例5 - nums = ";
    printArray(nums5);
    std::cout << "left = " << left5 << ", right = " << right5 << std::endl;
    std::cout << "numSubarrayBoundedMax 结果: " << numSubarrayBoundedMax(nums5, left5, right5) << std::endl; // 预期输出: 0
    std::cout << "numSubarrayBoundedMaxAlternative 结果: " << numSubarrayBoundedMaxAlternative(nums5, left5, right5) << std::endl; // 预期输出: 0
    std::cout << std::endl;
    
    // 性能测试
    std::cout << "性能测试:" << std::endl;
    std::vector<int> largeNums(100000);
    // 生成一个混合数组，一部分元素在范围内，一部分不在
    for (int i = 0; i < largeNums.size(); i++) {
        if (i % 5 == 0) {
            largeNums[i] = 100; // 大于right的元素
        } else if (i % 3 == 0) {
            largeNums[i] = 50; // 在范围内的元素
        } else {
            largeNums[i] = 10; // 小于left的元素
        }
    }
    int left6 = 40;
    int right6 = 60;
    
    auto startTime = std::chrono::high_resolution_clock::now();
    int result1 = numSubarrayBoundedMax(largeNums, left6, right6);
    auto endTime = std::chrono::high_resolution_clock::now();
    auto duration = std::chrono::duration_cast<std::chrono::milliseconds>(endTime - startTime);
    std::cout << "大数组 - numSubarrayBoundedMax 结果: " << result1 << std::endl;
    std::cout << "大数组 - numSubarrayBoundedMax 耗时: " << duration.count() << "ms" << std::endl;
    
    startTime = std::chrono::high_resolution_clock::now();
    int result2 = numSubarrayBoundedMaxAlternative(largeNums, left6, right6);
    endTime = std::chrono::high_resolution_clock::now();
    duration = std::chrono::duration_cast<std::chrono::milliseconds>(endTime - startTime);
    std::cout << "大数组 - numSubarrayBoundedMaxAlternative 结果: " << result2 << std::endl;
    std::cout << "大数组 - numSubarrayBoundedMaxAlternative 耗时: " << duration.count() << "ms" << std::endl;
    
    return 0;
}

===============================================

文件: Code16_NumberOfSubarraysWithBoundedMaximum.java
===============================================
package class047;

/**
 * LeetCode 795. 区间子数组个数 (Number of Subarrays with Bounded Maximum)
 * 
 * 题目描述:
 * 给定一个整数数组 nums 和两个整数 left 和 right，请返回数组中满足以下条件的非空子数组的个数：
 * - 子数组中的最大值在区间 [left, right] 内
 * 
 * 示例1:
 * 输入: nums = [2, 1, 4, 3], left = 2, right = 3
 * 输出: 3
 * 解释:
 * 满足条件的子数组是 [2], [2, 1], [3]
 * 
 * 示例2:
 * 输入: nums = [2, 9, 2, 5, 6], left = 2, right = 8
 * 输出: 7
 * 解释:
 * 满足条件的子数组有 [2], [2, 9], [2], [2, 5], [5], [5, 6], [6]
 * 
 * 提示:
 * 1. 1 <= nums.length <= 10^5
 * 2. 0 <= nums[i] <= 10^9
 * 3. 0 <= left <= right <= 10^9
 * 
 * 题目链接: https://leetcode.com/problems/number-of-subarrays-with-bounded-maximum/
 * 
 * 解题思路:
 * 这个问题可以通过以下两种方法来解决：
 * 
 * 方法一：暴力枚举所有子数组并检查最大值（不推荐，时间复杂度太高）
 * 
 * 方法二：使用计数法，考虑每个位置作为子数组最大值时的贡献
 * 但这种方法实现起来比较复杂。
 * 
 * 方法三：使用前缀和的思想，计算「最大值小于等于 right」的子数组个数，
 * 减去「最大值小于 left」的子数组个数，得到「最大值在 [left, right] 之间」的子数组个数。
 * 
 * 这里我们选择方法三，具体实现思路如下：
 * 1. 定义一个辅助函数 countSubarrays，用于计算数组中最大值小于等于给定阈值的子数组个数
 * 2. 最终结果就是 countSubarrays(nums, right) - countSubarrays(nums, left - 1)
 * 
 * 时间复杂度: O(n)，其中 n 是数组的长度。我们只需要遍历数组两次。
 * 空间复杂度: O(1)，只使用了常数级别的额外空间。
 * 
 * 这是最优解，因为我们需要至少遍历数组一次，时间复杂度无法更低。
 */
public class Code16_NumberOfSubarraysWithBoundedMaximum {
    
    /**
     * 计算数组中满足条件的非空子数组的个数
     * 
     * @param nums 整数数组
     * @param left 左边界
     * @param right 右边界
     * @return 满足条件的非空子数组个数
     */
    public static int numSubarrayBoundedMax(int[] nums, int left, int right) {
        // 参数校验
        if (nums == null || nums.length == 0 || left > right) {
            return 0;
        }
        
        // 计算最大值小于等于right的子数组个数，减去最大值小于left的子数组个数
        return countSubarrays(nums, right) - countSubarrays(nums, left - 1);
    }
    
    /**
     * 计算数组中最大值小于等于给定阈值的子数组个数
     * 
     * @param nums 整数数组
     * @param threshold 阈值
     * @return 最大值小于等于阈值的子数组个数
     */
    private static int countSubarrays(int[] nums, int threshold) {
        int count = 0;
        int currentLength = 0;
        
        for (int num : nums) {
            // 如果当前元素小于等于阈值，则可以将它加入到当前连续子数组中
            if (num <= threshold) {
                currentLength++;
                // 增加的子数组个数就是当前连续子数组的长度
                // 例如，[1,2,3]增加一个4，则新增的子数组有[4], [3,4], [2,3,4], [1,2,3,4]，共4个
                count += currentLength;
            } else {
                // 遇到大于阈值的元素，重置连续子数组长度
                currentLength = 0;
            }
        }
        
        return count;
    }
    
    /**
     * 另一种实现方式，直接计算满足条件的子数组个数
     * 
     * @param nums 整数数组
     * @param left 左边界
     * @param right 右边界
     * @return 满足条件的非空子数组个数
     */
    public static int numSubarrayBoundedMaxAlternative(int[] nums, int left, int right) {
        // 参数校验
        if (nums == null || nums.length == 0 || left > right) {
            return 0;
        }
        
        int count = 0;
        // 记录上一个大于right的位置
        int lastInvalid = -1;
        // 记录上一个在[left, right]范围内的位置
        int lastValid = -1;
        
        for (int i = 0; i < nums.length; i++) {
            if (nums[i] > right) {
                // 遇到大于right的元素，更新lastInvalid
                lastInvalid = i;
            } else if (nums[i] >= left && nums[i] <= right) {
                // 遇到在[left, right]范围内的元素
                lastValid = i;
                // 以当前元素为最大值的子数组个数为i - lastInvalid
                count += i - lastInvalid;
            } else { // nums[i] < left
                // 遇到小于left的元素
                // 如果之前有在[left, right]范围内的元素，则可以与当前元素组成有效子数组
                if (lastValid > lastInvalid) {
                    count += lastValid - lastInvalid;
                }
            }
        }
        
        return count;
    }
    
    /**
     * 打印数组
     * 
     * @param nums 要打印的数组
     */
    public static void printArray(int[] nums) {
        System.out.print("[");
        for (int i = 0; i < nums.length; i++) {
            System.out.print(nums[i]);
            if (i < nums.length - 1) {
                System.out.print(", ");
            }
        }
        System.out.println("]");
    }
    
    /**
     * 测试用例
     */
    public static void main(String[] args) {
        // 测试用例1
        int[] nums1 = {2, 1, 4, 3};
        int left1 = 2;
        int right1 = 3;
        
        System.out.print("测试用例1 - nums = ");
        printArray(nums1);
        System.out.println("left = " + left1 + ", right = " + right1);
        System.out.println("numSubarrayBoundedMax 结果: " + numSubarrayBoundedMax(nums1, left1, right1)); // 预期输出: 3
        System.out.println("numSubarrayBoundedMaxAlternative 结果: " + numSubarrayBoundedMaxAlternative(nums1, left1, right1)); // 预期输出: 3
        System.out.println();
        
        // 测试用例2
        int[] nums2 = {2, 9, 2, 5, 6};
        int left2 = 2;
        int right2 = 8;
        
        System.out.print("测试用例2 - nums = ");
        printArray(nums2);
        System.out.println("left = " + left2 + ", right = " + right2);
        System.out.println("numSubarrayBoundedMax 结果: " + numSubarrayBoundedMax(nums2, left2, right2)); // 预期输出: 7
        System.out.println("numSubarrayBoundedMaxAlternative 结果: " + numSubarrayBoundedMaxAlternative(nums2, left2, right2)); // 预期输出: 7
        System.out.println();
        
        // 测试用例3 - 边界情况：数组长度为1
        int[] nums3 = {1};
        int left3 = 1;
        int right3 = 1;
        
        System.out.print("测试用例3 - nums = ");
        printArray(nums3);
        System.out.println("left = " + left3 + ", right = " + right3);
        System.out.println("numSubarrayBoundedMax 结果: " + numSubarrayBoundedMax(nums3, left3, right3)); // 预期输出: 1
        System.out.println("numSubarrayBoundedMaxAlternative 结果: " + numSubarrayBoundedMaxAlternative(nums3, left3, right3)); // 预期输出: 1
        System.out.println();
        
        // 测试用例4 - 边界情况：所有元素都在范围内
        int[] nums4 = {2, 3, 4};
        int left4 = 1;
        int right4 = 5;
        
        System.out.print("测试用例4 - nums = ");
        printArray(nums4);
        System.out.println("left = " + left4 + ", right = " + right4);
        System.out.println("numSubarrayBoundedMax 结果: " + numSubarrayBoundedMax(nums4, left4, right4)); // 预期输出: 6
        System.out.println("numSubarrayBoundedMaxAlternative 结果: " + numSubarrayBoundedMaxAlternative(nums4, left4, right4)); // 预期输出: 6
        System.out.println();
        
        // 测试用例5 - 边界情况：没有元素在范围内
        int[] nums5 = {1, 1, 1};
        int left5 = 2;
        int right5 = 3;
        
        System.out.print("测试用例5 - nums = ");
        printArray(nums5);
        System.out.println("left = " + left5 + ", right = " + right5);
        System.out.println("numSubarrayBoundedMax 结果: " + numSubarrayBoundedMax(nums5, left5, right5)); // 预期输出: 0
        System.out.println("numSubarrayBoundedMaxAlternative 结果: " + numSubarrayBoundedMaxAlternative(nums5, left5, right5)); // 预期输出: 0
        System.out.println();
        
        // 性能测试
        System.out.println("性能测试:");
        int[] largeNums = new int[100000];
        // 生成一个混合数组，一部分元素在范围内，一部分不在
        for (int i = 0; i < largeNums.length; i++) {
            if (i % 5 == 0) {
                largeNums[i] = 100; // 大于right的元素
            } else if (i % 3 == 0) {
                largeNums[i] = 50; // 在范围内的元素
            } else {
                largeNums[i] = 10; // 小于left的元素
            }
        }
        int left6 = 40;
        int right6 = 60;
        
        long startTime = System.currentTimeMillis();
        int result1 = numSubarrayBoundedMax(largeNums, left6, right6);
        long endTime = System.currentTimeMillis();
        System.out.println("大数组 - numSubarrayBoundedMax 结果: " + result1);
        System.out.println("大数组 - numSubarrayBoundedMax 耗时: " + (endTime - startTime) + "ms");
        
        startTime = System.currentTimeMillis();
        int result2 = numSubarrayBoundedMaxAlternative(largeNums, left6, right6);
        endTime = System.currentTimeMillis();
        System.out.println("大数组 - numSubarrayBoundedMaxAlternative 结果: " + result2);
        System.out.println("大数组 - numSubarrayBoundedMaxAlternative 耗时: " + (endTime - startTime) + "ms");
    }
}

===============================================

文件: Code16_NumberOfSubarraysWithBoundedMaximum.py
===============================================
import time

"""
LeetCode 795. 区间子数组个数 (Number of Subarrays with Bounded Maximum)

题目描述:
给定一个整数数组 nums 和两个整数 left 和 right，请返回数组中满足以下条件的非空子数组的个数：
- 子数组中的最大值在区间 [left, right] 内

示例1:
输入: nums = [2, 1, 4, 3], left = 2, right = 3
输出: 3
解释:
满足条件的子数组是 [2], [2, 1], [3]

示例2:
输入: nums = [2, 9, 2, 5, 6], left = 2, right = 8
输出: 7
解释:
满足条件的子数组有 [2], [2, 9], [2], [2, 5], [5], [5, 6], [6]

提示:
1. 1 <= nums.length <= 10^5
2. 0 <= nums[i] <= 10^9
3. 0 <= left <= right <= 10^9

题目链接: https://leetcode.com/problems/number-of-subarrays-with-bounded-maximum/

解题思路:
这个问题可以通过以下两种方法来解决：

方法一：暴力枚举所有子数组并检查最大值（不推荐，时间复杂度太高）

方法二：使用计数法，考虑每个位置作为子数组最大值时的贡献
但这种方法实现起来比较复杂。

方法三：使用前缀和的思想，计算「最大值小于等于 right」的子数组个数，
减去「最大值小于 left」的子数组个数，得到「最大值在 [left, right] 之间」的子数组个数。

这里我们选择方法三，具体实现思路如下：
1. 定义一个辅助函数 count_subarrays，用于计算数组中最大值小于等于给定阈值的子数组个数
2. 最终结果就是 count_subarrays(nums, right) - count_subarrays(nums, left - 1)

时间复杂度: O(n)，其中 n 是数组的长度。我们只需要遍历数组两次。
空间复杂度: O(1)，只使用了常数级别的额外空间。

这是最优解，因为我们需要至少遍历数组一次，时间复杂度无法更低。
"""

def count_subarrays(nums, threshold):
    """
    计算数组中最大值小于等于给定阈值的子数组个数
    
    Args:
        nums: 整数数组
        threshold: 阈值
    
    Returns:
        最大值小于等于阈值的子数组个数
    """
    count = 0
    current_length = 0
    
    for num in nums:
        # 如果当前元素小于等于阈值，则可以将它加入到当前连续子数组中
        if num <= threshold:
            current_length += 1
            # 增加的子数组个数就是当前连续子数组的长度
            # 例如，[1,2,3]增加一个4，则新增的子数组有[4], [3,4], [2,3,4], [1,2,3,4]，共4个
            count += current_length
        else:
            # 遇到大于阈值的元素，重置连续子数组长度
            current_length = 0
    
    return count

def num_subarray_bounded_max(nums, left, right):
    """
    计算数组中满足条件的非空子数组的个数
    
    Args:
        nums: 整数数组
        left: 左边界
        right: 右边界
    
    Returns:
        满足条件的非空子数组个数
    """
    # 参数校验
    if not nums or left > right:
        return 0
    
    # 计算最大值小于等于right的子数组个数，减去最大值小于left的子数组个数
    return count_subarrays(nums, right) - count_subarrays(nums, left - 1)

def num_subarray_bounded_max_alternative(nums, left, right):
    """
    另一种实现方式，直接计算满足条件的子数组个数
    
    Args:
        nums: 整数数组
        left: 左边界
        right: 右边界
    
    Returns:
        满足条件的非空子数组个数
    """
    # 参数校验
    if not nums or left > right:
        return 0
    
    count = 0
    # 记录上一个大于right的位置
    last_invalid = -1
    # 记录上一个在[left, right]范围内的位置
    last_valid = -1
    
    for i in range(len(nums)):
        if nums[i] > right:
            # 遇到大于right的元素，更新last_invalid
            last_invalid = i
        elif left <= nums[i] <= right:
            # 遇到在[left, right]范围内的元素
            last_valid = i
            # 以当前元素为最大值的子数组个数为i - last_invalid
            count += i - last_invalid
        else:  # nums[i] < left
            # 遇到小于left的元素
            # 如果之前有在[left, right]范围内的元素，则可以与当前元素组成有效子数组
            if last_valid > last_invalid:
                count += last_valid - last_invalid
    
    return count

def print_array(nums):
    """
    打印数组
    
    Args:
        nums: 要打印的数组
    """
    print(f"[{' '.join(map(str, nums))}]")

# 测试代码
def main():
    # 测试用例1
    nums1 = [2, 1, 4, 3]
    left1 = 2
    right1 = 3
    
    print("测试用例1 - nums = ")
    print_array(nums1)
    print(f"left = {left1}, right = {right1}")
    print(f"num_subarray_bounded_max 结果: {num_subarray_bounded_max(nums1, left1, right1)}")  # 预期输出: 3
    print(f"num_subarray_bounded_max_alternative 结果: {num_subarray_bounded_max_alternative(nums1, left1, right1)}")  # 预期输出: 3
    print()
    
    # 测试用例2
    nums2 = [2, 9, 2, 5, 6]
    left2 = 2
    right2 = 8
    
    print("测试用例2 - nums = ")
    print_array(nums2)
    print(f"left = {left2}, right = {right2}")
    print(f"num_subarray_bounded_max 结果: {num_subarray_bounded_max(nums2, left2, right2)}")  # 预期输出: 7
    print(f"num_subarray_bounded_max_alternative 结果: {num_subarray_bounded_max_alternative(nums2, left2, right2)}")  # 预期输出: 7
    print()
    
    # 测试用例3 - 边界情况：数组长度为1
    nums3 = [1]
    left3 = 1
    right3 = 1
    
    print("测试用例3 - nums = ")
    print_array(nums3)
    print(f"left = {left3}, right = {right3}")
    print(f"num_subarray_bounded_max 结果: {num_subarray_bounded_max(nums3, left3, right3)}")  # 预期输出: 1
    print(f"num_subarray_bounded_max_alternative 结果: {num_subarray_bounded_max_alternative(nums3, left3, right3)}")  # 预期输出: 1
    print()
    
    # 测试用例4 - 边界情况：所有元素都在范围内
    nums4 = [2, 3, 4]
    left4 = 1
    right4 = 5
    
    print("测试用例4 - nums = ")
    print_array(nums4)
    print(f"left = {left4}, right = {right4}")
    print(f"num_subarray_bounded_max 结果: {num_subarray_bounded_max(nums4, left4, right4)}")  # 预期输出: 6
    print(f"num_subarray_bounded_max_alternative 结果: {num_subarray_bounded_max_alternative(nums4, left4, right4)}")  # 预期输出: 6
    print()
    
    # 测试用例5 - 边界情况：没有元素在范围内
    nums5 = [1, 1, 1]
    left5 = 2
    right5 = 3
    
    print("测试用例5 - nums = ")
    print_array(nums5)
    print(f"left = {left5}, right = {right5}")
    print(f"num_subarray_bounded_max 结果: {num_subarray_bounded_max(nums5, left5, right5)}")  # 预期输出: 0
    print(f"num_subarray_bounded_max_alternative 结果: {num_subarray_bounded_max_alternative(nums5, left5, right5)}")  # 预期输出: 0
    print()
    
    # 性能测试
    print("性能测试:")
    large_nums = []
    # 生成一个混合数组，一部分元素在范围内，一部分不在
    for i in range(100000):
        if i % 5 == 0:
            large_nums.append(100)  # 大于right的元素
        elif i % 3 == 0:
            large_nums.append(50)   # 在范围内的元素
        else:
            large_nums.append(10)   # 小于left的元素
    left6 = 40
    right6 = 60
    
    start_time = time.time()
    result1 = num_subarray_bounded_max(large_nums, left6, right6)
    end_time = time.time()
    print(f"大数组 - num_subarray_bounded_max 结果: {result1}")
    print(f"大数组 - num_subarray_bounded_max 耗时: {(end_time - start_time) * 1000:.2f}ms")
    
    start_time = time.time()
    result2 = num_subarray_bounded_max_alternative(large_nums, left6, right6)
    end_time = time.time()
    print(f"大数组 - num_subarray_bounded_max_alternative 结果: {result2}")
    print(f"大数组 - num_subarray_bounded_max_alternative 耗时: {(end_time - start_time) * 1000:.2f}ms")

if __name__ == "__main__":
    main()

===============================================

文件: Code17_CarFleet.cpp
===============================================
#include <iostream>
#include <vector>
#include <algorithm>
#include <chrono>

/**
 * LeetCode 853. 车队 (Car Fleet)
 * 
 * 题目描述:
 * N 辆车沿着一条车道驶向位于 target 英里之外的共同目的地。
 * 每辆车 i 以恒定的速度 speed[i] 英里/小时，从初始位置 position[i] 英里处出发。
 * 一辆车永远不会超过前面的另一辆车，但它可以追上去，并与前车以相同的速度紧接着行驶。
 * 此时，我们会忽略这两辆车之间的距离，也就是说，它们被假定处于同一位置。
 * 车队是一些由一辆或多辆车组成的非空集合，这些车以相同的速度行驶，并且彼此之间没有间隔。
 * 注意，一辆车也可以是一个车队。
 * 即便一辆车在到达目的地后不会再移动，它仍然可能是车队的一部分。
 * 
 * 返回最终车队的数量。
 * 
 * 示例1:
 * 输入: target = 12, position = [10,8,0,5,3], speed = [2,4,1,1,3]
 * 输出: 3
 * 解释:
 * 从初始位置开始，车辆按以下方式移动：
 * - 10号位置的车以2的速度移动，到达时间为(12-10)/2=1小时
 * - 8号位置的车以4的速度移动，到达时间为(12-8)/4=1小时
 * - 0号位置的车以1的速度移动，到达时间为12/1=12小时
 * - 5号位置的车以1的速度移动，到达时间为(12-5)/1=7小时
 * - 3号位置的车以3的速度移动，到达时间为(12-3)/3=3小时
 * 
 * 0号车会在12小时到达，而前面的车已经到达。
 * 3号车和5号车在到达之前都不会被前面的车阻挡。
 * 10号车和8号车会在1小时同时到达，并且形成一个车队。
 * 因此，最终车队的数量是3。
 * 
 * 示例2:
 * 输入: target = 10, position = [3], speed = [3]
 * 输出: 1
 * 
 * 示例3:
 * 输入: target = 100, position = [0,2,4], speed = [4,2,1]
 * 输出: 1
 * 解释: 0号车会在(100-0)/4=25小时到达，2号车会在(100-2)/2=49小时到达，4号车会在(100-4)/1=96小时到达。
 * 但0号车会被2号车和4号车阻挡，最终这三辆车会形成一个车队。
 * 
 * 提示:
 * 1. 0 <= N <= 10^4
 * 2. 0 < target <= 10^6
 * 3. 0 <= position[i] < target
 * 4. 0 < speed[i] <= 10^6
 * 5. 所有车的初始位置各不相同。
 * 
 * 题目链接: https://leetcode.com/problems/car-fleet/
 * 
 * 解题思路:
 * 这个问题可以通过以下步骤解决：
 * 1. 首先，我们需要将每辆车的位置和速度组合成一个对象，并按照位置从大到小（离终点近到远）排序
 * 2. 然后，计算每辆车到达终点所需的时间
 * 3. 从离终点最近的车开始，如果后面的车到达终点的时间不大于前面的车，那么后面的车会与前面的车组成一个车队
 * 4. 否则，后面的车会形成一个新的车队
 * 
 * 时间复杂度: O(n log n)，其中 n 是车的数量。排序的时间复杂度为 O(n log n)。
 * 空间复杂度: O(n)，用于存储车的信息和到达时间。
 * 
 * 这是最优解，因为我们需要至少对车辆进行一次排序，排序的时间复杂度无法低于 O(n log n)。
 */

/**
 * 计算最终车队的数量
 * 
 * @param target 目标位置
 * @param position 每辆车的初始位置数组
 * @param speed 每辆车的速度数组
 * @return 最终车队的数量
 */
int carFleet(int target, std::vector<int>& position, std::vector<int>& speed) {
    // 参数校验
    if (position.size() != speed.size()) {
        throw std::invalid_argument("参数无效：position 和 speed 数组必须长度相同");
    }
    
    int n = position.size();
    if (n == 0) {
        return 0;
    }
    
    // 创建车辆列表，存储位置和速度
    std::vector<std::pair<int, int>> cars;
    for (int i = 0; i < n; i++) {
        cars.push_back({position[i], speed[i]});
    }
    
    // 按照位置从大到小排序（离终点近到远）
    std::sort(cars.begin(), cars.end(), [](const auto& a, const auto& b) {
        return a.first > b.first;
    });
    
    int fleetCount = 1; // 至少有一个车队
    double currentTime = static_cast<double>(target - cars[0].first) / cars[0].second; // 第一辆车到达终点的时间
    
    // 从第二辆车开始，检查是否会与前面的车形成车队
    for (int i = 1; i < n; i++) {
        double arrivalTime = static_cast<double>(target - cars[i].first) / cars[i].second;
        
        // 如果当前车的到达时间大于前面车队的到达时间，那么它会形成一个新的车队
        if (arrivalTime > currentTime) {
            fleetCount++;
            currentTime = arrivalTime;
        }
        // 否则，当前车会与前面的车形成一个车队
    }
    
    return fleetCount;
}

/**
 * 另一种实现方式，使用结构体来存储车辆信息
 * 
 * @param target 目标位置
 * @param position 每辆车的初始位置数组
 * @param speed 每辆车的速度数组
 * @return 最终车队的数量
 */
int carFleetAlternative(int target, std::vector<int>& position, std::vector<int>& speed) {
    // 参数校验
    if (position.size() != speed.size()) {
        throw std::invalid_argument("参数无效：position 和 speed 数组必须长度相同");
    }
    
    int n = position.size();
    if (n == 0) {
        return 0;
    }
    
    // 定义车辆结构体
    struct Car {
        int pos;
        int spd;
    };
    
    // 创建车辆数组
    std::vector<Car> cars(n);
    for (int i = 0; i < n; i++) {
        cars[i].pos = position[i];
        cars[i].spd = speed[i];
    }
    
    // 按照位置从大到小排序
    std::sort(cars.begin(), cars.end(), [](const Car& a, const Car& b) {
        return a.pos > b.pos;
    });
    
    int fleetCount = 1;
    double prevTime = static_cast<double>(target - cars[0].pos) / cars[0].spd;
    
    for (int i = 1; i < n; i++) {
        double currTime = static_cast<double>(target - cars[i].pos) / cars[i].spd;
        if (currTime > prevTime) {
            fleetCount++;
            prevTime = currTime;
        }
    }
    
    return fleetCount;
}

/**
 * 打印数组
 * 
 * @param arr 要打印的数组
 */
void printArray(const std::vector<int>& arr) {
    std::cout << "[";
    for (size_t i = 0; i < arr.size(); i++) {
        std::cout << arr[i];
        if (i < arr.size() - 1) {
            std::cout << ", ";
        }
    }
    std::cout << "]" << std::endl;
}

// 主函数，用于测试
int main() {
    try {
        // 测试用例1
        int target1 = 12;
        std::vector<int> position1 = {10, 8, 0, 5, 3};
        std::vector<int> speed1 = {2, 4, 1, 1, 3};
        
        std::cout << "测试用例1:" << std::endl;
        std::cout << "target = " << target1 << std::endl;
        std::cout << "position = ";
        printArray(position1);
        std::cout << "speed = ";
        printArray(speed1);
        std::cout << "carFleet 结果: " << carFleet(target1, position1, speed1) << std::endl; // 预期输出: 3
        std::cout << "carFleetAlternative 结果: " << carFleetAlternative(target1, position1, speed1) << std::endl; // 预期输出: 3
        std::cout << std::endl;
        
        // 测试用例2
        int target2 = 10;
        std::vector<int> position2 = {3};
        std::vector<int> speed2 = {3};
        
        std::cout << "测试用例2:" << std::endl;
        std::cout << "target = " << target2 << std::endl;
        std::cout << "position = ";
        printArray(position2);
        std::cout << "speed = ";
        printArray(speed2);
        std::cout << "carFleet 结果: " << carFleet(target2, position2, speed2) << std::endl; // 预期输出: 1
        std::cout << "carFleetAlternative 结果: " << carFleetAlternative(target2, position2, speed2) << std::endl; // 预期输出: 1
        std::cout << std::endl;
        
        // 测试用例3
        int target3 = 100;
        std::vector<int> position3 = {0, 2, 4};
        std::vector<int> speed3 = {4, 2, 1};
        
        std::cout << "测试用例3:" << std::endl;
        std::cout << "target = " << target3 << std::endl;
        std::cout << "position = ";
        printArray(position3);
        std::cout << "speed = ";
        printArray(speed3);
        std::cout << "carFleet 结果: " << carFleet(target3, position3, speed3) << std::endl; // 预期输出: 1
        std::cout << "carFleetAlternative 结果: " << carFleetAlternative(target3, position3, speed3) << std::endl; // 预期输出: 1
        std::cout << std::endl;
        
        // 测试用例4 - 边界情况：所有车都形成一个车队
        int target4 = 100;
        std::vector<int> position4 = {90, 80, 70, 60};
        std::vector<int> speed4 = {1, 2, 3, 4};
        
        std::cout << "测试用例4:" << std::endl;
        std::cout << "target = " << target4 << std::endl;
        std::cout << "position = ";
        printArray(position4);
        std::cout << "speed = ";
        printArray(speed4);
        std::cout << "carFleet 结果: " << carFleet(target4, position4, speed4) << std::endl; // 预期输出: 1
        std::cout << "carFleetAlternative 结果: " << carFleetAlternative(target4, position4, speed4) << std::endl; // 预期输出: 1
        std::cout << std::endl;
        
        // 测试用例5 - 边界情况：所有车都各自形成一个车队
        int target5 = 100;
        std::vector<int> position5 = {90, 80, 70, 60};
        std::vector<int> speed5 = {1, 1, 1, 1};
        
        std::cout << "测试用例5:" << std::endl;
        std::cout << "target = " << target5 << std::endl;
        std::cout << "position = ";
        printArray(position5);
        std::cout << "speed = ";
        printArray(speed5);
        std::cout << "carFleet 结果: " << carFleet(target5, position5, speed5) << std::endl; // 预期输出: 4
        std::cout << "carFleetAlternative 结果: " << carFleetAlternative(target5, position5, speed5) << std::endl; // 预期输出: 4
        std::cout << std::endl;
        
        // 性能测试
        std::cout << "性能测试:" << std::endl;
        int target6 = 1000000;
        int n = 10000;
        std::vector<int> position6(n);
        std::vector<int> speed6(n);
        for (int i = 0; i < n; i++) {
            position6[i] = n - i - 1; // 从近到远排列
            speed6[i] = 1 + (i % 10); // 速度在1-10之间
        }
        
        auto startTime = std::chrono::high_resolution_clock::now();
        int result1 = carFleet(target6, position6, speed6);
        auto endTime = std::chrono::high_resolution_clock::now();
        auto duration = std::chrono::duration_cast<std::chrono::milliseconds>(endTime - startTime);
        std::cout << "大数组 - carFleet 结果: " << result1 << std::endl;
        std::cout << "大数组 - carFleet 耗时: " << duration.count() << "ms" << std::endl;
        
        startTime = std::chrono::high_resolution_clock::now();
        int result2 = carFleetAlternative(target6, position6, speed6);
        endTime = std::chrono::high_resolution_clock::now();
        duration = std::chrono::duration_cast<std::chrono::milliseconds>(endTime - startTime);
        std::cout << "大数组 - carFleetAlternative 结果: " << result2 << std::endl;
        std::cout << "大数组 - carFleetAlternative 耗时: " << duration.count() << "ms" << std::endl;
        
    } catch (const std::exception& e) {
        std::cerr << "错误: " << e.what() << std::endl;
        return 1;
    }
    
    return 0;
}

===============================================

文件: Code17_CarFleet.java
===============================================
package class047;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.List;

/**
 * LeetCode 853. 车队 (Car Fleet)
 * 
 * 题目描述:
 * N 辆车沿着一条车道驶向位于 target 英里之外的共同目的地。
 * 每辆车 i 以恒定的速度 speed[i] 英里/小时，从初始位置 position[i] 英里处出发。
 * 一辆车永远不会超过前面的另一辆车，但它可以追上去，并与前车以相同的速度紧接着行驶。
 * 此时，我们会忽略这两辆车之间的距离，也就是说，它们被假定处于同一位置。
 * 车队是一些由一辆或多辆车组成的非空集合，这些车以相同的速度行驶，并且彼此之间没有间隔。
 * 注意，一辆车也可以是一个车队。
 * 即便一辆车在到达目的地后不会再移动，它仍然可能是车队的一部分。
 * 
 * 返回最终车队的数量。
 * 
 * 示例1:
 * 输入: target = 12, position = [10,8,0,5,3], speed = [2,4,1,1,3]
 * 输出: 3
 * 解释:
 * 从初始位置开始，车辆按以下方式移动：
 * - 10号位置的车以2的速度移动，到达时间为(12-10)/2=1小时
 * - 8号位置的车以4的速度移动，到达时间为(12-8)/4=1小时
 * - 0号位置的车以1的速度移动，到达时间为12/1=12小时
 * - 5号位置的车以1的速度移动，到达时间为(12-5)/1=7小时
 * - 3号位置的车以3的速度移动，到达时间为(12-3)/3=3小时
 * 
 * 0号车会在12小时到达，而前面的车已经到达。
 * 3号车和5号车在到达之前都不会被前面的车阻挡。
 * 10号车和8号车会在1小时同时到达，并且形成一个车队。
 * 因此，最终车队的数量是3。
 * 
 * 示例2:
 * 输入: target = 10, position = [3], speed = [3]
 * 输出: 1
 * 
 * 示例3:
 * 输入: target = 100, position = [0,2,4], speed = [4,2,1]
 * 输出: 1
 * 解释: 0号车会在(100-0)/4=25小时到达，2号车会在(100-2)/2=49小时到达，4号车会在(100-4)/1=96小时到达。
 * 但0号车会被2号车和4号车阻挡，最终这三辆车会形成一个车队。
 * 
 * 提示:
 * 1. 0 <= N <= 10^4
 * 2. 0 < target <= 10^6
 * 3. 0 <= position[i] < target
 * 4. 0 < speed[i] <= 10^6
 * 5. 所有车的初始位置各不相同。
 * 
 * 题目链接: https://leetcode.com/problems/car-fleet/
 * 
 * 解题思路:
 * 这个问题可以通过以下步骤解决：
 * 1. 首先，我们需要将每辆车的位置和速度组合成一个对象，并按照位置从大到小（离终点近到远）排序
 * 2. 然后，计算每辆车到达终点所需的时间
 * 3. 从离终点最近的车开始，如果后面的车到达终点的时间不大于前面的车，那么后面的车会与前面的车组成一个车队
 * 4. 否则，后面的车会形成一个新的车队
 * 
 * 时间复杂度: O(n log n)，其中 n 是车的数量。排序的时间复杂度为 O(n log n)。
 * 空间复杂度: O(n)，用于存储车的信息和到达时间。
 * 
 * 这是最优解，因为我们需要至少对车辆进行一次排序，排序的时间复杂度无法低于 O(n log n)。
 */
public class Code17_CarFleet {
    
    /**
     * 车辆类，用于存储车辆的位置和速度
     */
    private static class Car {
        int position;
        int speed;
        
        public Car(int position, int speed) {
            this.position = position;
            this.speed = speed;
        }
    }
    
    /**
     * 计算最终车队的数量
     * 
     * @param target 目标位置
     * @param position 每辆车的初始位置数组
     * @param speed 每辆车的速度数组
     * @return 最终车队的数量
     */
    public static int carFleet(int target, int[] position, int[] speed) {
        // 参数校验
        if (position == null || speed == null || position.length != speed.length) {
            throw new IllegalArgumentException("参数无效：position 和 speed 数组必须长度相同且非空");
        }
        
        int n = position.length;
        if (n == 0) {
            return 0;
        }
        
        // 创建车辆列表
        List<Car> cars = new ArrayList<>();
        for (int i = 0; i < n; i++) {
            cars.add(new Car(position[i], speed[i]));
        }
        
        // 按照位置从大到小排序（离终点近到远）
        Collections.sort(cars, (a, b) -> b.position - a.position);
        
        int fleetCount = 1; // 至少有一个车队
        double currentTime = (double)(target - cars.get(0).position) / cars.get(0).speed; // 第一辆车到达终点的时间
        
        // 从第二辆车开始，检查是否会与前面的车形成车队
        for (int i = 1; i < n; i++) {
            double arrivalTime = (double)(target - cars.get(i).position) / cars.get(i).speed;
            
            // 如果当前车的到达时间大于前面车队的到达时间，那么它会形成一个新的车队
            if (arrivalTime > currentTime) {
                fleetCount++;
                currentTime = arrivalTime;
            }
            // 否则，当前车会与前面的车形成一个车队
        }
        
        return fleetCount;
    }
    
    /**
     * 另一种实现方式，使用数组而不是列表
     * 
     * @param target 目标位置
     * @param position 每辆车的初始位置数组
     * @param speed 每辆车的速度数组
     * @return 最终车队的数量
     */
    public static int carFleetAlternative(int target, int[] position, int[] speed) {
        // 参数校验
        if (position == null || speed == null || position.length != speed.length) {
            throw new IllegalArgumentException("参数无效：position 和 speed 数组必须长度相同且非空");
        }
        
        int n = position.length;
        if (n == 0) {
            return 0;
        }
        
        // 创建一个二维数组，存储位置和速度
        int[][] cars = new int[n][2];
        for (int i = 0; i < n; i++) {
            cars[i][0] = position[i];
            cars[i][1] = speed[i];
        }
        
        // 按照位置从大到小排序
        java.util.Arrays.sort(cars, (a, b) -> b[0] - a[0]);
        
        int fleetCount = 1;
        double prevTime = (double)(target - cars[0][0]) / cars[0][1];
        
        for (int i = 1; i < n; i++) {
            double currTime = (double)(target - cars[i][0]) / cars[i][1];
            if (currTime > prevTime) {
                fleetCount++;
                prevTime = currTime;
            }
        }
        
        return fleetCount;
    }
    
    /**
     * 打印数组
     * 
     * @param arr 要打印的数组
     */
    public static void printArray(int[] arr) {
        System.out.print("[");
        for (int i = 0; i < arr.length; i++) {
            System.out.print(arr[i]);
            if (i < arr.length - 1) {
                System.out.print(", ");
            }
        }
        System.out.println("]");
    }
    
    /**
     * 测试用例
     */
    public static void main(String[] args) {
        // 测试用例1
        int target1 = 12;
        int[] position1 = {10, 8, 0, 5, 3};
        int[] speed1 = {2, 4, 1, 1, 3};
        
        System.out.println("测试用例1:");
        System.out.println("target = " + target1);
        System.out.print("position = ");
        printArray(position1);
        System.out.print("speed = ");
        printArray(speed1);
        System.out.println("carFleet 结果: " + carFleet(target1, position1, speed1)); // 预期输出: 3
        System.out.println("carFleetAlternative 结果: " + carFleetAlternative(target1, position1, speed1)); // 预期输出: 3
        System.out.println();
        
        // 测试用例2
        int target2 = 10;
        int[] position2 = {3};
        int[] speed2 = {3};
        
        System.out.println("测试用例2:");
        System.out.println("target = " + target2);
        System.out.print("position = ");
        printArray(position2);
        System.out.print("speed = ");
        printArray(speed2);
        System.out.println("carFleet 结果: " + carFleet(target2, position2, speed2)); // 预期输出: 1
        System.out.println("carFleetAlternative 结果: " + carFleetAlternative(target2, position2, speed2)); // 预期输出: 1
        System.out.println();
        
        // 测试用例3
        int target3 = 100;
        int[] position3 = {0, 2, 4};
        int[] speed3 = {4, 2, 1};
        
        System.out.println("测试用例3:");
        System.out.println("target = " + target3);
        System.out.print("position = ");
        printArray(position3);
        System.out.print("speed = ");
        printArray(speed3);
        System.out.println("carFleet 结果: " + carFleet(target3, position3, speed3)); // 预期输出: 1
        System.out.println("carFleetAlternative 结果: " + carFleetAlternative(target3, position3, speed3)); // 预期输出: 1
        System.out.println();
        
        // 测试用例4 - 边界情况：所有车都形成一个车队
        int target4 = 100;
        int[] position4 = {90, 80, 70, 60};
        int[] speed4 = {1, 2, 3, 4};
        
        System.out.println("测试用例4:");
        System.out.println("target = " + target4);
        System.out.print("position = ");
        printArray(position4);
        System.out.print("speed = ");
        printArray(speed4);
        System.out.println("carFleet 结果: " + carFleet(target4, position4, speed4)); // 预期输出: 1
        System.out.println("carFleetAlternative 结果: " + carFleetAlternative(target4, position4, speed4)); // 预期输出: 1
        System.out.println();
        
        // 测试用例5 - 边界情况：所有车都各自形成一个车队
        int target5 = 100;
        int[] position5 = {90, 80, 70, 60};
        int[] speed5 = {1, 1, 1, 1};
        
        System.out.println("测试用例5:");
        System.out.println("target = " + target5);
        System.out.print("position = ");
        printArray(position5);
        System.out.print("speed = ");
        printArray(speed5);
        System.out.println("carFleet 结果: " + carFleet(target5, position5, speed5)); // 预期输出: 4
        System.out.println("carFleetAlternative 结果: " + carFleetAlternative(target5, position5, speed5)); // 预期输出: 4
        System.out.println();
        
        // 性能测试
        System.out.println("性能测试:");
        int target6 = 1000000;
        int n = 10000;
        int[] position6 = new int[n];
        int[] speed6 = new int[n];
        for (int i = 0; i < n; i++) {
            position6[i] = n - i - 1; // 从近到远排列
            speed6[i] = 1 + (i % 10); // 速度在1-10之间
        }
        
        long startTime = System.currentTimeMillis();
        int result1 = carFleet(target6, position6, speed6);
        long endTime = System.currentTimeMillis();
        System.out.println("大数组 - carFleet 结果: " + result1);
        System.out.println("大数组 - carFleet 耗时: " + (endTime - startTime) + "ms");
        
        startTime = System.currentTimeMillis();
        int result2 = carFleetAlternative(target6, position6, speed6);
        endTime = System.currentTimeMillis();
        System.out.println("大数组 - carFleetAlternative 结果: " + result2);
        System.out.println("大数组 - carFleetAlternative 耗时: " + (endTime - startTime) + "ms");
    }
}

===============================================

文件: Code17_CarFleet.py
===============================================
import time

"""
LeetCode 853. 车队 (Car Fleet)

题目描述:
N 辆车沿着一条车道驶向位于 target 英里之外的共同目的地。
每辆车 i 以恒定的速度 speed[i] 英里/小时，从初始位置 position[i] 英里处出发。
一辆车永远不会超过前面的另一辆车，但它可以追上去，并与前车以相同的速度紧接着行驶。
此时，我们会忽略这两辆车之间的距离，也就是说，它们被假定处于同一位置。
车队是一些由一辆或多辆车组成的非空集合，这些车以相同的速度行驶，并且彼此之间没有间隔。
注意，一辆车也可以是一个车队。
即便一辆车在到达目的地后不会再移动，它仍然可能是车队的一部分。

返回最终车队的数量。

示例1:
输入: target = 12, position = [10,8,0,5,3], speed = [2,4,1,1,3]
输出: 3
解释:
从初始位置开始，车辆按以下方式移动：
- 10号位置的车以2的速度移动，到达时间为(12-10)/2=1小时
- 8号位置的车以4的速度移动，到达时间为(12-8)/4=1小时
- 0号位置的车以1的速度移动，到达时间为12/1=12小时
- 5号位置的车以1的速度移动，到达时间为(12-5)/1=7小时
- 3号位置的车以3的速度移动，到达时间为(12-3)/3=3小时

0号车会在12小时到达，而前面的车已经到达。
3号车和5号车在到达之前都不会被前面的车阻挡。
10号车和8号车会在1小时同时到达，并且形成一个车队。
因此，最终车队的数量是3。

示例2:
输入: target = 10, position = [3], speed = [3]
输出: 1

示例3:
输入: target = 100, position = [0,2,4], speed = [4,2,1]
输出: 1
解释: 0号车会在(100-0)/4=25小时到达，2号车会在(100-2)/2=49小时到达，4号车会在(100-4)/1=96小时到达。
但0号车会被2号车和4号车阻挡，最终这三辆车会形成一个车队。

提示:
1. 0 <= N <= 10^4
2. 0 < target <= 10^6
3. 0 <= position[i] < target
4. 0 < speed[i] <= 10^6
5. 所有车的初始位置各不相同。

题目链接: https://leetcode.com/problems/car-fleet/

解题思路:
这个问题可以通过以下步骤解决：
1. 首先，我们需要将每辆车的位置和速度组合成一个对象，并按照位置从大到小（离终点近到远）排序
2. 然后，计算每辆车到达终点所需的时间
3. 从离终点最近的车开始，如果后面的车到达终点的时间不大于前面的车，那么后面的车会与前面的车组成一个车队
4. 否则，后面的车会形成一个新的车队

时间复杂度: O(n log n)，其中 n 是车的数量。排序的时间复杂度为 O(n log n)。
空间复杂度: O(n)，用于存储车的信息和到达时间。

这是最优解，因为我们需要至少对车辆进行一次排序，排序的时间复杂度无法低于 O(n log n)。
"""

def car_fleet(target, position, speed):
    """
    计算最终车队的数量
    
    Args:
        target: 目标位置
        position: 每辆车的初始位置数组
        speed: 每辆车的速度数组
    
    Returns:
        最终车队的数量
    """
    # 参数校验
    if not position or not speed or len(position) != len(speed):
        return 0
    
    # 创建车辆列表，存储位置和速度
    cars = list(zip(position, speed))
    
    # 按照位置从大到小排序（离终点近到远）
    cars.sort(key=lambda x: x[0], reverse=True)
    
    fleet_count = 1  # 至少有一个车队
    current_time = (target - cars[0][0]) / cars[0][1]  # 第一辆车到达终点的时间
    
    # 从第二辆车开始，检查是否会与前面的车形成车队
    for i in range(1, len(cars)):
        arrival_time = (target - cars[i][0]) / cars[i][1]
        
        # 如果当前车的到达时间大于前面车队的到达时间，那么它会形成一个新的车队
        if arrival_time > current_time:
            fleet_count += 1
            current_time = arrival_time
        # 否则，当前车会与前面的车形成一个车队
    
    return fleet_count

def car_fleet_alternative(target, position, speed):
    """
    另一种实现方式，使用列表推导式和zip函数
    
    Args:
        target: 目标位置
        position: 每辆车的初始位置数组
        speed: 每辆车的速度数组
    
    Returns:
        最终车队的数量
    """
    # 参数校验
    if not position or not speed or len(position) != len(speed):
        return 0
    
    # 计算每辆车到达终点所需的时间，并按照位置从大到小排序
    # 使用列表存储 (position, time_to_reach)
    time_and_positions = [(pos, (target - pos) / spd) for pos, spd in zip(position, speed)]
    
    # 按照位置从大到小排序
    time_and_positions.sort(key=lambda x: x[0], reverse=True)
    
    fleet_count = 0
    current_max_time = 0
    
    # 从离终点最近的车开始遍历
    for _, arrival_time in time_and_positions:
        # 如果当前车的到达时间大于之前所有车的到达时间，它将形成一个新的车队
        if arrival_time > current_max_time:
            current_max_time = arrival_time
            fleet_count += 1
    
    return fleet_count

def print_array(arr):
    """
    打印数组
    
    Args:
        arr: 要打印的数组
    """
    print(f"[{' '.join(map(str, arr))}]")

# 测试代码
def main():
    # 测试用例1
    target1 = 12
    position1 = [10, 8, 0, 5, 3]
    speed1 = [2, 4, 1, 1, 3]
    
    print("测试用例1:")
    print(f"target = {target1}")
    print("position = ")
    print_array(position1)
    print("speed = ")
    print_array(speed1)
    print(f"car_fleet 结果: {car_fleet(target1, position1, speed1)}")  # 预期输出: 3
    print(f"car_fleet_alternative 结果: {car_fleet_alternative(target1, position1, speed1)}")  # 预期输出: 3
    print()
    
    # 测试用例2
    target2 = 10
    position2 = [3]
    speed2 = [3]
    
    print("测试用例2:")
    print(f"target = {target2}")
    print("position = ")
    print_array(position2)
    print("speed = ")
    print_array(speed2)
    print(f"car_fleet 结果: {car_fleet(target2, position2, speed2)}")  # 预期输出: 1
    print(f"car_fleet_alternative 结果: {car_fleet_alternative(target2, position2, speed2)}")  # 预期输出: 1
    print()
    
    # 测试用例3
    target3 = 100
    position3 = [0, 2, 4]
    speed3 = [4, 2, 1]
    
    print("测试用例3:")
    print(f"target = {target3}")
    print("position = ")
    print_array(position3)
    print("speed = ")
    print_array(speed3)
    print(f"car_fleet 结果: {car_fleet(target3, position3, speed3)}")  # 预期输出: 1
    print(f"car_fleet_alternative 结果: {car_fleet_alternative(target3, position3, speed3)}")  # 预期输出: 1
    print()
    
    # 测试用例4 - 边界情况：所有车都形成一个车队
    target4 = 100
    position4 = [90, 80, 70, 60]
    speed4 = [1, 2, 3, 4]
    
    print("测试用例4:")
    print(f"target = {target4}")
    print("position = ")
    print_array(position4)
    print("speed = ")
    print_array(speed4)
    print(f"car_fleet 结果: {car_fleet(target4, position4, speed4)}")  # 预期输出: 1
    print(f"car_fleet_alternative 结果: {car_fleet_alternative(target4, position4, speed4)}")  # 预期输出: 1
    print()
    
    # 测试用例5 - 边界情况：所有车都各自形成一个车队
    target5 = 100
    position5 = [90, 80, 70, 60]
    speed5 = [1, 1, 1, 1]
    
    print("测试用例5:")
    print(f"target = {target5}")
    print("position = ")
    print_array(position5)
    print("speed = ")
    print_array(speed5)
    print(f"car_fleet 结果: {car_fleet(target5, position5, speed5)}")  # 预期输出: 4
    print(f"car_fleet_alternative 结果: {car_fleet_alternative(target5, position5, speed5)}")  # 预期输出: 4
    print()
    
    # 性能测试
    print("性能测试:")
    target6 = 1000000
    n = 10000
    position6 = [n - i - 1 for i in range(n)]  # 从近到远排列
    speed6 = [1 + (i % 10) for i in range(n)]  # 速度在1-10之间
    
    start_time = time.time()
    result1 = car_fleet(target6, position6, speed6)
    end_time = time.time()
    print(f"大数组 - car_fleet 结果: {result1}")
    print(f"大数组 - car_fleet 耗时: {(end_time - start_time) * 1000:.2f}ms")
    
    start_time = time.time()
    result2 = car_fleet_alternative(target6, position6, speed6)
    end_time = time.time()
    print(f"大数组 - car_fleet_alternative 结果: {result2}")
    print(f"大数组 - car_fleet_alternative 耗时: {(end_time - start_time) * 1000:.2f}ms")

if __name__ == "__main__":
    main()

===============================================

文件: Code18_MyCalendarIII.cpp
===============================================
#include <iostream>
#include <map>
#include <vector>
#include <algorithm>

using namespace std;

/**
 * LeetCode 732. 我的日程安排表 III (My Calendar III)
 * 
 * 题目描述:
 * 实现一个 MyCalendarThree 类来存放你的日程安排，你可以一直添加新的日程安排。
 * 当 k 个日程安排有一些时间上的交叉时（例如 k 个日程安排都在同一时间内），就会产生 k 次预订。
 * 每次调用 MyCalendarThree.book(int start, int end) 方法时，返回一个整数 k，
 * 表示当前日历中存在的最大交叉预订次数。
 * 
 * 示例:
 * MyCalendarThree calendar;
 * calendar.book(10, 20); // 返回 1
 * calendar.book(50, 60); // 返回 1
 * calendar.book(10, 40); // 返回 2
 * calendar.book(5, 15);  // 返回 3
 * calendar.book(5, 10);  // 返回 3
 * calendar.book(25, 55); // 返回 3
 * 
 * 提示:
 * 每个测试用例，调用 MyCalendarThree.book 函数最多不超过 400 次。
 * 调用函数 MyCalendarThree.book(start, end) 时，start 和 end 满足 0 <= start < end <= 10^9。
 * 
 * 题目链接: https://leetcode.com/problems/my-calendar-iii/
 * 
 * 解题思路:
 * 使用差分数组技巧来处理区间更新操作。
 * 1. 使用map来存储差分标记，key为时间点，value为在该时间点的变化量
 * 2. 对于每个book操作，在start处+1，在end处-1
 * 3. 遍历map，计算前缀和，记录最大值
 * 
 * 时间复杂度: O(n^2) - 每次book操作需要遍历所有时间点
 * 空间复杂度: O(n) - 需要存储所有时间点的差分标记
 * 
 * 这是最优解，因为需要处理动态的区间更新和查询。
 */
class MyCalendarThree {
private:
    map<int, int> diff;

public:
    MyCalendarThree() {}
    
    /**
     * 添加日程安排并返回当前最大交叉预订次数
     * 
     * @param start 开始时间
     * @param end 结束时间
     * @return 当前最大交叉预订次数
     */
    int book(int start, int end) {
        // 边界检查
        if (start < 0 || end <= start) {
            return 0;
        }
        
        // 在start处增加1
        diff[start]++;
        // 在end处减少1
        diff[end]--;
        
        // 计算当前最大交叉预订次数
        int maxK = 0;
        int current = 0;
        
        // 遍历所有时间点，计算前缀和
        for (auto& pair : diff) {
            current += pair.second;
            maxK = max(maxK, current);
        }
        
        return maxK;
    }
};

/**
 * 测试用例
 */
int main() {
    MyCalendarThree calendar;
    
    // 测试用例1
    cout << "测试用例1: " << calendar.book(10, 20) << endl; // 预期: 1
    cout << "测试用例2: " << calendar.book(50, 60) << endl; // 预期: 1
    cout << "测试用例3: " << calendar.book(10, 40) << endl; // 预期: 2
    cout << "测试用例4: " << calendar.book(5, 15) << endl;  // 预期: 3
    cout << "测试用例5: " << calendar.book(5, 10) << endl;  // 预期: 3
    cout << "测试用例6: " << calendar.book(25, 55) << endl; // 预期: 3
    
    return 0;
}

===============================================

文件: Code18_MyCalendarIII.java
===============================================
package class047;

/**
 * LeetCode 732. 我的日程安排表 III (My Calendar III)
 * 
 * 题目描述:
 * 实现一个 MyCalendarThree 类来存放你的日程安排，你可以一直添加新的日程安排。
 * 当 k 个日程安排有一些时间上的交叉时（例如 k 个日程安排都在同一时间内），就会产生 k 次预订。
 * 每次调用 MyCalendarThree.book(int start, int end) 方法时，返回一个整数 k，
 * 表示当前日历中存在的最大交叉预订次数。
 * 
 * 示例:
 * MyCalendarThree calendar = new MyCalendarThree();
 * calendar.book(10, 20); // 返回 1
 * calendar.book(50, 60); // 返回 1
 * calendar.book(10, 40); // 返回 2
 * calendar.book(5, 15);  // 返回 3
 * calendar.book(5, 10);  // 返回 3
 * calendar.book(25, 55); // 返回 3
 * 
 * 解释:
 * 前两个日程安排可以预订并且不相交，所以最大交叉预订次数是1。
 * 第三个日程安排[10,40)与第一个日程安排[10,20)相交，所以最大交叉预订次数是2。
 * 第四个日程安排[5,15)与第一个和第三个日程安排相交，所以最大交叉预订次数是3。
 * 剩下的两个日程安排的最大交叉预订次数仍然是3。
 * 
 * 提示:
 * 每个测试用例，调用 MyCalendarThree.book 函数最多不超过 400 次。
 * 调用函数 MyCalendarThree.book(start, end) 时，start 和 end 满足 0 <= start < end <= 10^9。
 * 
 * 题目链接: https://leetcode.com/problems/my-calendar-iii/
 * 
 * 解题思路:
 * 使用差分数组技巧来处理区间更新操作。
 * 1. 使用TreeMap来存储差分标记，key为时间点，value为在该时间点的变化量
 * 2. 对于每个book操作，在start处+1，在end处-1
 * 3. 遍历TreeMap，计算前缀和，记录最大值
 * 
 * 时间复杂度: O(n^2) - 每次book操作需要遍历所有时间点
 * 空间复杂度: O(n) - 需要存储所有时间点的差分标记
 * 
 * 这是最优解，因为需要处理动态的区间更新和查询。
 */
import java.util.TreeMap;

public class Code18_MyCalendarIII {
    
    private TreeMap<Integer, Integer> diff;

    public Code18_MyCalendarIII() {
        diff = new TreeMap<>();
    }
    
    /**
     * 添加日程安排并返回当前最大交叉预订次数
     * 
     * @param start 开始时间
     * @param end 结束时间
     * @return 当前最大交叉预订次数
     */
    public int book(int start, int end) {
        // 边界检查
        if (start < 0 || end <= start) {
            return 0;
        }
        
        // 在start处增加1
        diff.put(start, diff.getOrDefault(start, 0) + 1);
        // 在end处减少1
        diff.put(end, diff.getOrDefault(end, 0) - 1);
        
        // 计算当前最大交叉预订次数
        int maxK = 0;
        int current = 0;
        
        // 遍历所有时间点，计算前缀和
        for (int value : diff.values()) {
            current += value;
            maxK = Math.max(maxK, current);
        }
        
        return maxK;
    }

    /**
     * 测试用例
     */
    public static void main(String[] args) {
        Code18_MyCalendarIII calendar = new Code18_MyCalendarIII();
        
        // 测试用例1
        System.out.println("测试用例1: " + calendar.book(10, 20)); // 预期: 1
        System.out.println("测试用例2: " + calendar.book(50, 60)); // 预期: 1
        System.out.println("测试用例3: " + calendar.book(10, 40)); // 预期: 2
        System.out.println("测试用例4: " + calendar.book(5, 15));  // 预期: 3
        System.out.println("测试用例5: " + calendar.book(5, 10));  // 预期: 3
        System.out.println("测试用例6: " + calendar.book(25, 55)); // 预期: 3
    }
}

===============================================

文件: Code18_MyCalendarIII.py
===============================================
from collections import OrderedDict

class MyCalendarThree:
    """
    LeetCode 732. 我的日程安排表 III (My Calendar III)
    
    题目描述:
    实现一个 MyCalendarThree 类来存放你的日程安排，你可以一直添加新的日程安排。
    当 k 个日程安排有一些时间上的交叉时（例如 k 个日程安排都在同一时间内），就会产生 k 次预订。
    每次调用 MyCalendarThree.book(int start, int end) 方法时，返回一个整数 k，
    表示当前日历中存在的最大交叉预订次数。
    
    示例:
    calendar = MyCalendarThree()
    calendar.book(10, 20) # 返回 1
    calendar.book(50, 60) # 返回 1
    calendar.book(10, 40) # 返回 2
    calendar.book(5, 15)  # 返回 3
    calendar.book(5, 10)  # 返回 3
    calendar.book(25, 55) # 返回 3
    
    提示:
    每个测试用例，调用 MyCalendarThree.book 函数最多不超过 400 次。
    调用函数 MyCalendarThree.book(start, end) 时，start 和 end 满足 0 <= start < end <= 10^9。
    
    题目链接: https://leetcode.com/problems/my-calendar-iii/
    
    解题思路:
    使用差分数组技巧来处理区间更新操作。
    1. 使用SortedDict来存储差分标记，key为时间点，value为在该时间点的变化量
    2. 对于每个book操作，在start处+1，在end处-1
    3. 遍历SortedDict，计算前缀和，记录最大值
    
    时间复杂度: O(n^2) - 每次book操作需要遍历所有时间点
    空间复杂度: O(n) - 需要存储所有时间点的差分标记
    
    这是最优解，因为需要处理动态的区间更新和查询。
    """
    
    def __init__(self):
        self.diff = {}
    
    def book(self, start: int, end: int) -> int:
        """
        添加日程安排并返回当前最大交叉预订次数
        
        Args:
            start: 开始时间
            end: 结束时间
            
        Returns:
            当前最大交叉预订次数
        """
        # 边界检查
        if start < 0 or end <= start:
            return 0
        
        # 在start处增加1
        self.diff[start] = self.diff.get(start, 0) + 1
        # 在end处减少1
        self.diff[end] = self.diff.get(end, 0) - 1
        
        # 计算当前最大交叉预订次数
        max_k = 0
        current = 0
        
        # 遍历所有时间点，计算前缀和（按时间顺序）
        sorted_keys = sorted(self.diff.keys())
        for key in sorted_keys:
            current += self.diff[key]
            max_k = max(max_k, current)
        
        return max_k

def test_my_calendar_three():
    """
    测试用例
    """
    calendar = MyCalendarThree()
    
    # 测试用例1
    print(f"测试用例1: {calendar.book(10, 20)}")  # 预期: 1
    print(f"测试用例2: {calendar.book(50, 60)}")  # 预期: 1
    print(f"测试用例3: {calendar.book(10, 40)}")  # 预期: 2
    print(f"测试用例4: {calendar.book(5, 15)}")   # 预期: 3
    print(f"测试用例5: {calendar.book(5, 10)}")   # 预期: 3
    print(f"测试用例6: {calendar.book(25, 55)}")  # 预期: 3

if __name__ == "__main__":
    test_my_calendar_three()

===============================================

文件: Code19_NumberOfWaysToSplitArray.cpp
===============================================
#include <iostream>
#include <vector>
#include <numeric>

using namespace std;

/**
 * LeetCode 2270. 分割数组的方案数 (Number of Ways to Split Array)
 * 
 * 题目描述:
 * 给你一个下标从 0 开始长度为 n 的整数数组 nums。
 * 如果以下描述为真，那么 nums 在下标 i 处有一个 合法分割：
 * 1. 前 i + 1 个元素的和 大于等于 剩下的 n - i - 1 个元素的和。
 * 2. 前 i + 1 个元素的和 大于等于 剩下的 n - i - 1 个元素的和。
 * 注意，第 i + 1 个元素 包含在 前 i + 1 个元素中。
 * 请你返回 nums 中的 合法分割 方案数。
 * 
 * 示例:
 * 输入: nums = [10,4,-8,7]
 * 输出: 2
 * 解释: 总共有 3 种分割方案：
 * - 下标 0 处分割：10 和 4,-8,7 的和，10 >= 4-8+7=3
 * - 下标 1 处分割：10,4 和 -8,7 的和，14 >= -8+7=-1
 * - 下标 2 处分割：10,4,-8 和 7 的和，6 >= 7
 * 只有下标 0 和 1 处是合法分割。
 * 
 * 提示:
 * 2 <= nums.length <= 10^5
 * -10^5 <= nums[i] <= 10^5
 * 
 * 题目链接: https://leetcode.com/problems/number-of-ways-to-split-array/
 * 
 * 解题思路:
 * 使用前缀和技巧来优化区间和的计算。
 * 1. 计算整个数组的总和 totalSum
 * 2. 从左到右遍历数组，维护当前前缀和 leftSum
 * 3. 对于每个位置 i，检查 leftSum >= totalSum - leftSum 是否成立
 * 4. 统计满足条件的分割点数量
 * 
 * 时间复杂度: O(n) - 需要遍历数组两次（一次计算总和，一次遍历检查）
 * 空间复杂度: O(1) - 只需要常数级别的额外空间
 * 
 * 这是最优解，因为需要遍历整个数组来计算前缀和。
 */
class Solution {
public:
    int waysToSplitArray(vector<int>& nums) {
        // 边界情况处理
        if (nums.size() < 2) {
            return 0;
        }
        
        // 计算整个数组的总和
        long long totalSum = 0;
        for (int num : nums) {
            totalSum += num;
        }
        
        // 统计合法分割方案数
        int count = 0;
        long long leftSum = 0;
        
        // 遍历数组，检查每个可能的分割点
        // 注意：最后一个位置不能分割，因为右边没有元素
        for (int i = 0; i < nums.size() - 1; i++) {
            leftSum += nums[i];
            long long rightSum = totalSum - leftSum;
            
            // 检查分割条件：左边和 >= 右边和
            if (leftSum >= rightSum) {
                count++;
            }
        }
        
        return count;
    }
};

/**
 * 测试用例
 */
int main() {
    Solution solution;
    
    // 测试用例1
    vector<int> nums1 = {10, 4, -8, 7};
    int result1 = solution.waysToSplitArray(nums1);
    // 预期输出: 2
    cout << "测试用例1: " << result1 << endl;

    // 测试用例2
    vector<int> nums2 = {2, 3, 1, 0};
    int result2 = solution.waysToSplitArray(nums2);
    // 预期输出: 2
    cout << "测试用例2: " << result2 << endl;
    
    // 测试用例3
    vector<int> nums3 = {0, 0};
    int result3 = solution.waysToSplitArray(nums3);
    // 预期输出: 1 (左边和0 >= 右边和0)
    cout << "测试用例3: " << result3 << endl;
    
    // 测试用例4
    vector<int> nums4 = {1, 1, 1};
    int result4 = solution.waysToSplitArray(nums4);
    // 预期输出: 1 (在位置0分割：1 >= 2? 不成立；在位置1分割：2 >= 1? 成立)
    cout << "测试用例4: " << result4 << endl;
    
    // 测试用例5 - 大数测试
    vector<int> nums5 = {100000, 100000, 100000, 100000};
    int result5 = solution.waysToSplitArray(nums5);
    // 预期输出: 3 (每个分割点都满足条件)
    cout << "测试用例5: " << result5 << endl;
    
    return 0;
}

===============================================

文件: Code19_NumberOfWaysToSplitArray.java
===============================================
package class047;

/**
 * LeetCode 2270. 分割数组的方案数 (Number of Ways to Split Array)
 * 
 * 题目描述:
 * 给你一个下标从 0 开始长度为 n 的整数数组 nums。
 * 如果以下描述为真，那么 nums 在下标 i 处有一个 合法分割：
 * 1. 前 i + 1 个元素的和 大于等于 剩下的 n - i - 1 个元素的和。
 * 2. 前 i + 1 个元素的和 大于等于 剩下的 n - i - 1 个元素的和。
 * 注意，第 i + 1 个元素 包含在 前 i + 1 个元素中。
 * 请你返回 nums 中的 合法分割 方案数。
 * 
 * 示例:
 * 输入: nums = [10,4,-8,7]
 * 输出: 2
 * 解释: 总共有 3 种分割方案：
 * - 下标 0 处分割：10 和 4,-8,7 的和，10 >= 4-8+7=3
 * - 下标 1 处分割：10,4 和 -8,7 的和，14 >= -8+7=-1
 * - 下标 2 处分割：10,4,-8 和 7 的和，6 >= 7
 * 只有下标 0 和 1 处是合法分割。
 * 
 * 提示:
 * 2 <= nums.length <= 10^5
 * -10^5 <= nums[i] <= 10^5
 * 
 * 题目链接: https://leetcode.com/problems/number-of-ways-to-split-array/
 * 
 * 解题思路:
 * 使用前缀和技巧来优化区间和的计算。
 * 1. 计算整个数组的总和 totalSum
 * 2. 从左到右遍历数组，维护当前前缀和 leftSum
 * 3. 对于每个位置 i，检查 leftSum >= totalSum - leftSum 是否成立
 * 4. 统计满足条件的分割点数量
 * 
 * 时间复杂度: O(n) - 需要遍历数组两次（一次计算总和，一次遍历检查）
 * 空间复杂度: O(1) - 只需要常数级别的额外空间
 * 
 * 这是最优解，因为需要遍历整个数组来计算前缀和。
 */
public class Code19_NumberOfWaysToSplitArray {

    /**
     * 计算合法分割方案数
     * 
     * @param nums 输入数组
     * @return 合法分割方案数
     */
    public static int waysToSplitArray(int[] nums) {
        // 边界情况处理
        if (nums == null || nums.length < 2) {
            return 0;
        }
        
        // 计算整个数组的总和
        long totalSum = 0;
        for (int num : nums) {
            totalSum += num;
        }
        
        // 统计合法分割方案数
        int count = 0;
        long leftSum = 0;
        
        // 遍历数组，检查每个可能的分割点
        // 注意：最后一个位置不能分割，因为右边没有元素
        for (int i = 0; i < nums.length - 1; i++) {
            leftSum += nums[i];
            long rightSum = totalSum - leftSum;
            
            // 检查分割条件：左边和 >= 右边和
            if (leftSum >= rightSum) {
                count++;
            }
        }
        
        return count;
    }

    /**
     * 测试用例
     */
    public static void main(String[] args) {
        // 测试用例1
        int[] nums1 = {10, 4, -8, 7};
        int result1 = waysToSplitArray(nums1);
        // 预期输出: 2
        System.out.println("测试用例1: " + result1);

        // 测试用例2
        int[] nums2 = {2, 3, 1, 0};
        int result2 = waysToSplitArray(nums2);
        // 预期输出: 2
        System.out.println("测试用例2: " + result2);
        
        // 测试用例3
        int[] nums3 = {0, 0};
        int result3 = waysToSplitArray(nums3);
        // 预期输出: 1 (左边和0 >= 右边和0)
        System.out.println("测试用例3: " + result3);
        
        // 测试用例4
        int[] nums4 = {1, 1, 1};
        int result4 = waysToSplitArray(nums4);
        // 预期输出: 1 (在位置0分割：1 >= 2? 不成立；在位置1分割：2 >= 1? 成立)
        System.out.println("测试用例4: " + result4);
        
        // 测试用例5 - 大数测试
        int[] nums5 = {100000, 100000, 100000, 100000};
        int result5 = waysToSplitArray(nums5);
        // 预期输出: 3 (每个分割点都满足条件)
        System.out.println("测试用例5: " + result5);
    }
}

===============================================

文件: Code19_NumberOfWaysToSplitArray.py
===============================================
from typing import List

class Solution:
    """
    LeetCode 2270. 分割数组的方案数 (Number of Ways to Split Array)
    
    题目描述:
    给你一个下标从 0 开始长度为 n 的整数数组 nums。
    如果以下描述为真，那么 nums 在下标 i 处有一个 合法分割：
    1. 前 i + 1 个元素的和 大于等于 剩下的 n - i - 1 个元素的和。
    2. 前 i + 1 个元素的和 大于等于 剩下的 n - i - 1 个元素的和。
    注意，第 i + 1 个元素 包含在 前 i + 1 个元素中。
    请你返回 nums 中的 合法分割 方案数。
    
    示例:
    输入: nums = [10,4,-8,7]
    输出: 2
    解释: 总共有 3 种分割方案：
    - 下标 0 处分割：10 和 4,-8,7 的和，10 >= 4-8+7=3
    - 下标 1 处分割：10,4 和 -8,7 的和，14 >= -8+7=-1
    - 下标 2 处分割：10,4,-8 和 7 的和，6 >= 7
    只有下标 0 和 1 处是合法分割。
    
    提示:
    2 <= nums.length <= 10^5
    -10^5 <= nums[i] <= 10^5
    
    题目链接: https://leetcode.com/problems/number-of-ways-to-split-array/
    
    解题思路:
    使用前缀和技巧来优化区间和的计算。
    1. 计算整个数组的总和 totalSum
    2. 从左到右遍历数组，维护当前前缀和 leftSum
    3. 对于每个位置 i，检查 leftSum >= totalSum - leftSum 是否成立
    4. 统计满足条件的分割点数量
    
    时间复杂度: O(n) - 需要遍历数组两次（一次计算总和，一次遍历检查）
    空间复杂度: O(1) - 只需要常数级别的额外空间
    
    这是最优解，因为需要遍历整个数组来计算前缀和。
    """
    
    def waysToSplitArray(self, nums: List[int]) -> int:
        """
        计算合法分割方案数
        
        Args:
            nums: 输入数组
            
        Returns:
            合法分割方案数
        """
        # 边界情况处理
        if not nums or len(nums) < 2:
            return 0
        
        # 计算整个数组的总和
        total_sum = sum(nums)
        
        # 统计合法分割方案数
        count = 0
        left_sum = 0
        
        # 遍历数组，检查每个可能的分割点
        # 注意：最后一个位置不能分割，因为右边没有元素
        for i in range(len(nums) - 1):
            left_sum += nums[i]
            right_sum = total_sum - left_sum
            
            # 检查分割条件：左边和 >= 右边和
            if left_sum >= right_sum:
                count += 1
        
        return count

def test_ways_to_split_array():
    """
    测试用例
    """
    solution = Solution()
    
    # 测试用例1
    nums1 = [10, 4, -8, 7]
    result1 = solution.waysToSplitArray(nums1)
    # 预期输出: 2
    print(f"测试用例1: {result1}")

    # 测试用例2
    nums2 = [2, 3, 1, 0]
    result2 = solution.waysToSplitArray(nums2)
    # 预期输出: 2
    print(f"测试用例2: {result2}")
    
    # 测试用例3
    nums3 = [0, 0]
    result3 = solution.waysToSplitArray(nums3)
    # 预期输出: 1 (左边和0 >= 右边和0)
    print(f"测试用例3: {result3}")
    
    # 测试用例4
    nums4 = [1, 1, 1]
    result4 = solution.waysToSplitArray(nums4)
    # 预期输出: 1 (在位置0分割：1 >= 2? 不成立；在位置1分割：2 >= 1? 成立)
    print(f"测试用例4: {result4}")
    
    # 测试用例5 - 大数测试
    nums5 = [100000, 100000, 100000, 100000]
    result5 = solution.waysToSplitArray(nums5)
    # 预期输出: 3 (每个分割点都满足条件)
    print(f"测试用例5: {result5}")

if __name__ == "__main__":
    test_ways_to_split_array()

===============================================

文件: Code20_GregAndArray.cpp
===============================================
#include <vector>
#include <iostream>

using namespace std;

/**
 * Codeforces 296C. Greg and Array
 * 
 * 题目描述:
 * Greg 有一个长度为 n 的数组 a，初始值都为 0。
 * 他还有 m 个操作，每个操作是一个三元组 (l, r, d)，表示将区间 [l, r] 中的每个元素加上 d。
 * 然后他有 k 个指令，每个指令是一个二元组 (x, y)，表示执行操作 x 到操作 y 各一次。
 * 请输出执行完所有指令后的数组。
 * 
 * 示例:
 * 输入: n = 3, m = 3, k = 3
 * 操作: 
 * 操作1: (1, 2, 1)
 * 操作2: (1, 3, 2)
 * 操作3: (2, 3, 4)
 * 指令:
 * 指令1: (1, 2)
 * 指令2: (1, 3)
 * 指令3: (2, 3)
 * 输出: [9, 18, 17]
 * 
 * 题目链接: https://codeforces.com/contest/296/problem/C
 * 
 * 解题思路:
 * 使用两层差分数组技巧来处理多层区间更新操作。
 * 1. 第一层差分: 统计每个操作被执行多少次
 * 2. 第二层差分: 根据操作执行次数，计算对原数组的影响
 * 
 * 时间复杂度: O(n + m + k) - 需要处理所有操作和指令
 * 空间复杂度: O(n + m) - 需要存储操作信息和差分数组
 * 
 * 这是最优解，因为需要处理多层区间更新。
 */
class Solution {
public:
    vector<long long> gregAndArray(int n, int m, int k, vector<vector<int>>& operations, vector<vector<int>>& instructions) {
        // 边界情况处理
        if (n <= 0 || m <= 0 || k <= 0) {
            return vector<long long>(n, 0);
        }
        
        // 第一层差分: 统计每个操作被执行多少次
        vector<long long> opCount(m + 2, 0); // 操作索引从1开始
        
        // 处理指令，统计每个操作被执行次数
        for (auto& instruction : instructions) {
            int x = instruction[0]; // 起始操作索引
            int y = instruction[1]; // 结束操作索引
            
            // 使用差分标记指令区间
            opCount[x] += 1;
            if (y + 1 <= m) {
                opCount[y + 1] -= 1;
            }
        }
        
        // 计算每个操作的实际执行次数
        for (int i = 1; i <= m; i++) {
            opCount[i] += opCount[i - 1];
        }
        
        // 第二层差分: 计算对原数组的影响
        vector<long long> diff(n + 2, 0); // 数组索引从1开始
        
        // 根据操作执行次数，计算对原数组的影响
        for (int i = 1; i <= m; i++) {
            vector<int> op = operations[i - 1]; // 操作索引从0开始
            int l = op[0];
            int r = op[1];
            long long d = op[2];
            long long count = opCount[i]; // 该操作执行次数
            
            // 应用操作到差分数组
            diff[l] += d * count;
            if (r + 1 <= n) {
                diff[r + 1] -= d * count;
            }
        }
        
        // 计算最终结果数组
        vector<long long> result(n, 0);
        long long current = 0;
        for (int i = 1; i <= n; i++) {
            current += diff[i];
            result[i - 1] = current;
        }
        
        return result;
    }
};

/**
 * 测试用例
 */
int main() {
    Solution solution;
    
    // 测试用例1: 题目示例
    int n1 = 3, m1 = 3, k1 = 3;
    vector<vector<int>> operations1 = {
        {1, 2, 1},  // 操作1
        {1, 3, 2},  // 操作2
        {2, 3, 4}   // 操作3
    };
    vector<vector<int>> instructions1 = {
        {1, 2},     // 指令1
        {1, 3},     // 指令2
        {2, 3}      // 指令3
    };
    
    vector<long long> result1 = solution.gregAndArray(n1, m1, k1, operations1, instructions1);
    cout << "测试用例1: ";
    for (long long num : result1) {
        cout << num << " ";
    }
    cout << endl; // 预期输出: 9 18 17
    
    // 测试用例2: 简单情况
    int n2 = 5, m2 = 2, k2 = 1;
    vector<vector<int>> operations2 = {
        {1, 3, 2},  // 操作1
        {2, 4, 3}   // 操作2
    };
    vector<vector<int>> instructions2 = {
        {1, 2}      // 指令1
    };
    
    vector<long long> result2 = solution.gregAndArray(n2, m2, k2, operations2, instructions2);
    cout << "测试用例2: ";
    for (long long num : result2) {
        cout << num << " ";
    }
    cout << endl; // 预期输出: 2 5 5 3 0
    
    // 测试用例3: 边界情况
    int n3 = 1, m3 = 1, k3 = 1;
    vector<vector<int>> operations3 = {
        {1, 1, 5}   // 操作1
    };
    vector<vector<int>> instructions3 = {
        {1, 1}      // 指令1
    };
    
    vector<long long> result3 = solution.gregAndArray(n3, m3, k3, operations3, instructions3);
    cout << "测试用例3: ";
    for (long long num : result3) {
        cout << num << " ";
    }
    cout << endl; // 预期输出: 5
    
    return 0;
}

===============================================

文件: Code20_GregAndArray.java
===============================================
package class047;

import java.util.*;

/**
 * Codeforces 296C. Greg and Array
 * 
 * 题目描述:
 * Greg 有一个长度为 n 的数组 a，初始值都为 0。
 * 他还有 m 个操作，每个操作是一个三元组 (l, r, d)，表示将区间 [l, r] 中的每个元素加上 d。
 * 然后他有 k 个指令，每个指令是一个二元组 (x, y)，表示执行操作 x 到操作 y 各一次。
 * 请输出执行完所有指令后的数组。
 * 
 * 示例:
 * 输入: n = 3, m = 3, k = 3
 * 操作: 
 * 操作1: (1, 2, 1)
 * 操作2: (1, 3, 2)
 * 操作3: (2, 3, 4)
 * 指令:
 * 指令1: (1, 2)
 * 指令2: (1, 3)
 * 指令3: (2, 3)
 * 输出: [9, 18, 17]
 * 
 * 解释:
 * 操作1执行次数: 指令1(1次) + 指令2(1次) + 指令3(0次) = 2次
 * 操作2执行次数: 指令1(0次) + 指令2(1次) + 指令3(1次) = 2次
 * 操作3执行次数: 指令1(0次) + 指令2(1次) + 指令3(1次) = 2次
 * 最终数组:
 * 操作1执行2次: [2, 4, 0]
 * 操作2执行2次: [4, 8, 4]
 * 操作3执行2次: [4, 16, 12]
 * 总和: [2+4+4, 4+8+16, 0+4+12] = [10, 28, 16] (注意：示例输出可能有误，实际计算应为[10,28,16])
 * 
 * 题目链接: https://codeforces.com/contest/296/problem/C
 * 
 * 解题思路:
 * 使用两层差分数组技巧来处理多层区间更新操作。
 * 1. 第一层差分: 统计每个操作被执行多少次
 * 2. 第二层差分: 根据操作执行次数，计算对原数组的影响
 * 
 * 时间复杂度: O(n + m + k) - 需要处理所有操作和指令
 * 空间复杂度: O(n + m) - 需要存储操作信息和差分数组
 * 
 * 这是最优解，因为需要处理多层区间更新。
 */
public class Code20_GregAndArray {

    /**
     * 执行Greg的数组操作
     * 
     * @param n 数组长度
     * @param m 操作数量
     * @param k 指令数量
     * @param operations 操作数组，每个操作包含[l, r, d]
     * @param instructions 指令数组，每个指令包含[x, y]
     * @return 执行完所有指令后的数组
     */
    public static long[] gregAndArray(int n, int m, int k, int[][] operations, int[][] instructions) {
        // 边界情况处理
        if (n <= 0 || m <= 0 || k <= 0) {
            return new long[n];
        }
        
        // 第一层差分: 统计每个操作被执行多少次
        long[] opCount = new long[m + 2]; // 操作索引从1开始
        
        // 处理指令，统计每个操作被执行次数
        for (int[] instruction : instructions) {
            int x = instruction[0]; // 起始操作索引
            int y = instruction[1]; // 结束操作索引
            
            // 使用差分标记指令区间
            opCount[x] += 1;
            if (y + 1 <= m) {
                opCount[y + 1] -= 1;
            }
        }
        
        // 计算每个操作的实际执行次数
        for (int i = 1; i <= m; i++) {
            opCount[i] += opCount[i - 1];
        }
        
        // 第二层差分: 计算对原数组的影响
        long[] diff = new long[n + 2]; // 数组索引从1开始
        
        // 根据操作执行次数，计算对原数组的影响
        for (int i = 1; i <= m; i++) {
            int[] op = operations[i - 1]; // 操作索引从0开始
            int l = op[0];
            int r = op[1];
            long d = op[2];
            long count = opCount[i]; // 该操作执行次数
            
            // 应用操作到差分数组
            diff[l] += d * count;
            if (r + 1 <= n) {
                diff[r + 1] -= d * count;
            }
        }
        
        // 计算最终结果数组
        long[] result = new long[n];
        long current = 0;
        for (int i = 1; i <= n; i++) {
            current += diff[i];
            result[i - 1] = current;
        }
        
        return result;
    }

    /**
     * 测试用例
     */
    public static void main(String[] args) {
        // 测试用例1: 题目示例
        int n1 = 3, m1 = 3, k1 = 3;
        int[][] operations1 = {
            {1, 2, 1},  // 操作1
            {1, 3, 2},  // 操作2
            {2, 3, 4}   // 操作3
        };
        int[][] instructions1 = {
            {1, 2},     // 指令1
            {1, 3},     // 指令2
            {2, 3}      // 指令3
        };
        
        long[] result1 = gregAndArray(n1, m1, k1, operations1, instructions1);
        System.out.print("测试用例1: ");
        for (long num : result1) {
            System.out.print(num + " ");
        }
        System.out.println(); // 预期输出: 9 18 17 (但实际计算应为10 28 16)
        
        // 测试用例2: 简单情况
        int n2 = 5, m2 = 2, k2 = 1;
        int[][] operations2 = {
            {1, 3, 2},  // 操作1
            {2, 4, 3}   // 操作2
        };
        int[][] instructions2 = {
            {1, 2}      // 指令1
        };
        
        long[] result2 = gregAndArray(n2, m2, k2, operations2, instructions2);
        System.out.print("测试用例2: ");
        for (long num : result2) {
            System.out.print(num + " ");
        }
        System.out.println(); // 预期输出: 2 5 5 3 0
        
        // 测试用例3: 边界情况
        int n3 = 1, m3 = 1, k3 = 1;
        int[][] operations3 = {
            {1, 1, 5}   // 操作1
        };
        int[][] instructions3 = {
            {1, 1}      // 指令1
        };
        
        long[] result3 = gregAndArray(n3, m3, k3, operations3, instructions3);
        System.out.print("测试用例3: ");
        for (long num : result3) {
            System.out.print(num + " ");
        }
        System.out.println(); // 预期输出: 5
    }
    
    /**
     * 工程化考量:
     * 1. 异常处理: 验证输入参数的合法性
     * 2. 边界检查: 确保索引不越界
     * 3. 大数处理: 使用long类型防止整数溢出
     * 4. 性能优化: 使用差分数组减少时间复杂度
     * 5. 可读性: 清晰的变量命名和注释
     */
    
    /**
     * 时间复杂度分析:
     * - 处理指令: O(k)
     * - 计算操作执行次数: O(m)
     * - 应用操作到数组: O(m)
     * - 构建结果数组: O(n)
     * 总时间复杂度: O(n + m + k)
     * 
     * 空间复杂度分析:
     * - 操作计数数组: O(m)
     * - 差分数组: O(n)
     * 总空间复杂度: O(n + m)
     */
    
    /**
     * 算法调试技巧:
     * 1. 打印中间结果: 可以打印操作执行次数和差分数组来验证逻辑
     * 2. 小规模测试: 使用简单测试用例验证算法正确性
     * 3. 边界测试: 测试n=1, m=1, k=1等边界情况
     */
}

===============================================

文件: Code20_GregAndArray.py
===============================================
from typing import List

class Solution:
    """
    Codeforces 296C. Greg and Array
    
    题目描述:
    Greg 有一个长度为 n 的数组 a，初始值都为 0。
    他还有 m 个操作，每个操作是一个三元组 (l, r, d)，表示将区间 [l, r] 中的每个元素加上 d。
    然后他有 k 个指令，每个指令是一个二元组 (x, y)，表示执行操作 x 到操作 y 各一次。
    请输出执行完所有指令后的数组。
    
    示例:
    输入: n = 3, m = 3, k = 3
    操作: 
    操作1: (1, 2, 1)
    操作2: (1, 3, 2)
    操作3: (2, 3, 4)
    指令:
    指令1: (1, 2)
    指令2: (1, 3)
    指令3: (2, 3)
    输出: [9, 18, 17]
    
    题目链接: https://codeforces.com/contest/296/problem/C
    
    解题思路:
    使用两层差分数组技巧来处理多层区间更新操作。
    1. 第一层差分: 统计每个操作被执行多少次
    2. 第二层差分: 根据操作执行次数，计算对原数组的影响
    
    时间复杂度: O(n + m + k) - 需要处理所有操作和指令
    空间复杂度: O(n + m) - 需要存储操作信息和差分数组
    
    这是最优解，因为需要处理多层区间更新。
    """
    
    def gregAndArray(self, n: int, m: int, k: int, operations: List[List[int]], instructions: List[List[int]]) -> List[int]:
        """
        执行Greg的数组操作
        
        Args:
            n: 数组长度
            m: 操作数量
            k: 指令数量
            operations: 操作数组，每个操作包含[l, r, d]
            instructions: 指令数组，每个指令包含[x, y]
            
        Returns:
            执行完所有指令后的数组
        """
        # 边界情况处理
        if n <= 0 or m <= 0 or k <= 0:
            return [0] * n
        
        # 第一层差分: 统计每个操作被执行多少次
        op_count = [0] * (m + 2)  # 操作索引从1开始
        
        # 处理指令，统计每个操作被执行次数
        for instruction in instructions:
            x = instruction[0]  # 起始操作索引
            y = instruction[1]  # 结束操作索引
            
            # 使用差分标记指令区间
            op_count[x] += 1
            if y + 1 <= m:
                op_count[y + 1] -= 1
        
        # 计算每个操作的实际执行次数
        for i in range(1, m + 1):
            op_count[i] += op_count[i - 1]
        
        # 第二层差分: 计算对原数组的影响
        diff = [0] * (n + 2)  # 数组索引从1开始
        
        # 根据操作执行次数，计算对原数组的影响
        for i in range(1, m + 1):
            op = operations[i - 1]  # 操作索引从0开始
            l, r, d = op[0], op[1], op[2]
            count = op_count[i]  # 该操作执行次数
            
            # 应用操作到差分数组
            diff[l] += d * count
            if r + 1 <= n:
                diff[r + 1] -= d * count
        
        # 计算最终结果数组
        result = [0] * n
        current = 0
        for i in range(1, n + 1):
            current += diff[i]
            result[i - 1] = current
        
        return result

def test_greg_and_array():
    """
    测试用例
    """
    solution = Solution()
    
    # 测试用例1: 题目示例
    n1, m1, k1 = 3, 3, 3
    operations1 = [
        [1, 2, 1],  # 操作1
        [1, 3, 2],  # 操作2
        [2, 3, 4]   # 操作3
    ]
    instructions1 = [
        [1, 2],     # 指令1
        [1, 3],     # 指令2
        [2, 3]      # 指令3
    ]
    
    result1 = solution.gregAndArray(n1, m1, k1, operations1, instructions1)
    print(f"测试用例1: {result1}")  # 预期输出: [9, 18, 17]
    
    # 测试用例2: 简单情况
    n2, m2, k2 = 5, 2, 1
    operations2 = [
        [1, 3, 2],  # 操作1
        [2, 4, 3]   # 操作2
    ]
    instructions2 = [
        [1, 2]      # 指令1
    ]
    
    result2 = solution.gregAndArray(n2, m2, k2, operations2, instructions2)
    print(f"测试用例2: {result2}")  # 预期输出: [2, 5, 5, 3, 0]
    
    # 测试用例3: 边界情况
    n3, m3, k3 = 1, 1, 1
    operations3 = [
        [1, 1, 5]   # 操作1
    ]
    instructions3 = [
        [1, 1]      # 指令1
    ]
    
    result3 = solution.gregAndArray(n3, m3, k3, operations3, instructions3)
    print(f"测试用例3: {result3}")  # 预期输出: [5]

if __name__ == "__main__":
    test_greg_and_array()

===============================================

文件: Code21_POJ3468.cpp
===============================================
#include <iostream>
#include <vector>
#include <string>

using namespace std;

/**
 * POJ 3468. A Simple Problem with Integers
 * 
 * 题目描述:
 * 给定一个长度为 N 的数列 A，以及 M 条指令，每条指令可能是以下两种之一：
 * 1. "C a b c"：表示给 [a, b] 区间中的每一个数加上 c。
 * 2. "Q a b"：表示询问 [a, b] 区间中所有数的和。
 * 
 * 示例:
 * 输入:
 * 10 5
 * 1 2 3 4 5 6 7 8 9 10
 * Q 4 4
 * Q 1 10
 * Q 2 4
 * C 3 6 3
 * Q 2 4
 * 
 * 输出:
 * 4
 * 55
 * 9
 * 15
 * 
 * 题目链接: http://poj.org/problem?id=3468
 * 
 * 解题思路:
 * 使用线段树或树状数组来支持区间更新和区间查询。
 * 这里使用差分数组结合树状数组的方法：
 * 1. 维护两个树状数组：一个用于记录区间加法的累积影响，另一个用于记录区间加法的次数
 * 2. 区间更新时，使用差分思想在树状数组上进行标记
 * 3. 区间查询时，通过两个树状数组的组合计算得到区间和
 * 
 * 时间复杂度: O((N+M)logN) - 每次操作的时间复杂度为O(logN)
 * 空间复杂度: O(N) - 需要存储树状数组
 * 
 * 这是最优解之一，线段树和树状数组都是解决此类问题的标准方法。
 */
class FenwickTree {
private:
    vector<long long> tree;
    int n;
    
public:
    FenwickTree(int size) : n(size) {
        tree.resize(n + 1, 0);
    }
    
    // 单点更新
    void update(int index, long long delta) {
        while (index <= n) {
            tree[index] += delta;
            index += index & -index;
        }
    }
    
    // 前缀和查询
    long long query(int index) {
        long long sum = 0;
        while (index > 0) {
            sum += tree[index];
            index -= index & -index;
        }
        return sum;
    }
    
    // 区间和查询
    long long rangeQuery(int l, int r) {
        return query(r) - query(l - 1);
    }
};

int main() {
    int n, m;
    cin >> n >> m;
    
    vector<long long> arr(n + 1);
    FenwickTree bit1(n); // 用于记录区间加法的累积影响
    FenwickTree bit2(n); // 用于记录区间加法的次数
    
    // 读取初始数组
    for (int i = 1; i <= n; i++) {
        cin >> arr[i];
    }
    
    // 构建初始前缀和
    vector<long long> prefix(n + 1, 0);
    for (int i = 1; i <= n; i++) {
        prefix[i] = prefix[i - 1] + arr[i];
    }
    
    // 处理指令
    for (int i = 0; i < m; i++) {
        string op;
        cin >> op;
        if (op == "C") {
            int a, b;
            long long c;
            cin >> a >> b >> c;
            
            // 区间更新: 使用差分思想
            bit1.update(a, c);
            if (b + 1 <= n) {
                bit1.update(b + 1, -c);
            }
            bit2.update(a, c * (a - 1));
            if (b + 1 <= n) {
                bit2.update(b + 1, -c * b);
            }
        } else if (op == "Q") {
            int a, b;
            cin >> a >> b;
            
            // 区间查询: 使用两个树状数组组合计算
            long long sum1 = prefix[b] + bit1.query(b) * b - bit2.query(b);
            long long sum2 = prefix[a - 1] + bit1.query(a - 1) * (a - 1) - bit2.query(a - 1);
            cout << sum1 - sum2 << endl;
        }
    }
    
    return 0;
}

===============================================

文件: Code21_POJ3468.java
===============================================
package class047;

import java.util.Scanner;

/**
 * POJ 3468. A Simple Problem with Integers
 * 
 * 题目描述:
 * 给定一个长度为 N 的数列 A，以及 M 条指令，每条指令可能是以下两种之一：
 * 1. "C a b c"：表示给 [a, b] 区间中的每一个数加上 c。
 * 2. "Q a b"：表示询问 [a, b] 区间中所有数的和。
 * 
 * 示例:
 * 输入:
 * 10 5
 * 1 2 3 4 5 6 7 8 9 10
 * Q 4 4
 * Q 1 10
 * Q 2 4
 * C 3 6 3
 * Q 2 4
 * 
 * 输出:
 * 4
 * 55
 * 9
 * 15
 * 
 * 题目链接: http://poj.org/problem?id=3468
 * 
 * 解题思路:
 * 使用线段树或树状数组来支持区间更新和区间查询。
 * 这里使用差分数组结合树状数组的方法：
 * 1. 维护两个树状数组：一个用于记录区间加法的累积影响，另一个用于记录区间加法的次数
 * 2. 区间更新时，使用差分思想在树状数组上进行标记
 * 3. 区间查询时，通过两个树状数组的组合计算得到区间和
 * 
 * 时间复杂度: O((N+M)logN) - 每次操作的时间复杂度为O(logN)
 * 空间复杂度: O(N) - 需要存储树状数组
 * 
 * 这是最优解之一，线段树和树状数组都是解决此类问题的标准方法。
 */
public class Code21_POJ3468 {

    static class FenwickTree {
        long[] tree;
        int n;
        
        public FenwickTree(int size) {
            this.n = size;
            this.tree = new long[n + 1];
        }
        
        // 单点更新
        public void update(int index, long delta) {
            while (index <= n) {
                tree[index] += delta;
                index += index & -index;
            }
        }
        
        // 前缀和查询
        public long query(int index) {
            long sum = 0;
            while (index > 0) {
                sum += tree[index];
                index -= index & -index;
            }
            return sum;
        }
        
        // 区间和查询
        public long rangeQuery(int l, int r) {
            return query(r) - query(l - 1);
        }
    }
    
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int n = scanner.nextInt();
        int m = scanner.nextInt();
        
        long[] arr = new long[n + 1];
        FenwickTree bit1 = new FenwickTree(n); // 用于记录区间加法的累积影响
        FenwickTree bit2 = new FenwickTree(n); // 用于记录区间加法的次数
        
        // 读取初始数组
        for (int i = 1; i <= n; i++) {
            arr[i] = scanner.nextLong();
        }
        
        // 构建初始前缀和
        long[] prefix = new long[n + 1];
        for (int i = 1; i <= n; i++) {
            prefix[i] = prefix[i - 1] + arr[i];
        }
        
        // 处理指令
        for (int i = 0; i < m; i++) {
            String op = scanner.next();
            if (op.equals("C")) {
                int a = scanner.nextInt();
                int b = scanner.nextInt();
                long c = scanner.nextLong();
                
                // 区间更新: 使用差分思想
                bit1.update(a, c);
                bit1.update(b + 1, -c);
                bit2.update(a, c * (a - 1));
                bit2.update(b + 1, -c * b);
            } else if (op.equals("Q")) {
                int a = scanner.nextInt();
                int b = scanner.nextInt();
                
                // 区间查询: 使用两个树状数组组合计算
                long sum1 = prefix[b] + bit1.query(b) * b - bit2.query(b);
                long sum2 = prefix[a - 1] + bit1.query(a - 1) * (a - 1) - bit2.query(a - 1);
                System.out.println(sum1 - sum2);
            }
        }
        
        scanner.close();
    }
    
    /**
     * 算法原理详解:
     * 对于区间 [a, b] 加上 c 的操作，我们可以使用差分思想：
     * 设 d[i] 表示第 i 个位置的增量，那么：
     * - 在位置 a 加上 c
     * - 在位置 b+1 减去 c
     * 
     * 但是这样只能支持单点查询，为了支持区间查询，我们需要维护两个树状数组：
     * bit1: 记录差分数组 d[i]
     * bit2: 记录 i*d[i] 的前缀和
     * 
     * 区间和公式推导:
     * sum[1..x] = Σ(i=1 to x) arr[i] + Σ(i=1 to x) d[i] * (x - i + 1)
     *           = prefix[x] + x * Σ(i=1 to x) d[i] - Σ(i=1 to x) (i-1) * d[i]
     * 
     * 因此，区间 [a, b] 的和 = sum[1..b] - sum[1..a-1]
     */
    
    /**
     * 工程化考量:
     * 1. 大数处理: 使用long类型防止整数溢出
     * 2. 输入优化: 使用Scanner进行快速输入
     * 3. 边界检查: 确保索引不越界
     * 4. 性能优化: 使用树状数组降低时间复杂度
     */
    
    /**
     * 时间复杂度分析:
     * - 构建前缀和: O(n)
     * - 每次更新操作: O(log n)
     * - 每次查询操作: O(log n)
     * 总时间复杂度: O((n + m) log n)
     * 
     * 空间复杂度分析:
     * - 原始数组: O(n)
     * - 前缀和数组: O(n)
     * - 两个树状数组: O(n)
     * 总空间复杂度: O(n)
     */
    
    /**
     * 测试用例设计:
     * 1. 小规模测试: 验证基本功能
     * 2. 边界测试: 测试n=1, m=1的情况
     * 3. 性能测试: 大规模数据测试算法效率
     * 4. 正确性测试: 对比暴力解法的结果
     */
}

===============================================

文件: Code21_POJ3468.py
===============================================
import sys

class FenwickTree:
    """
    树状数组（Fenwick Tree）实现
    用于高效支持区间更新和区间查询
    """
    
    def __init__(self, size: int):
        self.n = size
        self.tree = [0] * (size + 1)
    
    def update(self, index: int, delta: int) -> None:
        """
        单点更新
        
        Args:
            index: 更新位置
            delta: 增量值
        """
        while index <= self.n:
            self.tree[index] += delta
            index += index & -index
    
    def query(self, index: int) -> int:
        """
        前缀和查询
        
        Args:
            index: 查询位置
            
        Returns:
            前缀和
        """
        total = 0
        while index > 0:
            total += self.tree[index]
            index -= index & -index
        return total
    
    def range_query(self, l: int, r: int) -> int:
        """
        区间和查询
        
        Args:
            l: 左边界
            r: 右边界
            
        Returns:
            区间和
        """
        return self.query(r) - self.query(l - 1)

def main():
    """
    POJ 3468. A Simple Problem with Integers
    
    题目描述:
    给定一个长度为 N 的数列 A，以及 M 条指令，每条指令可能是以下两种之一：
    1. "C a b c"：表示给 [a, b] 区间中的每一个数加上 c。
    2. "Q a b"：表示询问 [a, b] 区间中所有数的和。
    
    示例:
    输入:
    10 5
    1 2 3 4 5 6 7 8 9 10
    Q 4 4
    Q 1 10
    Q 2 4
    C 3 6 3
    Q 2 4
    
    输出:
    4
    55
    9
    15
    
    题目链接: http://poj.org/problem?id=3468
    
    解题思路:
    使用线段树或树状数组来支持区间更新和区间查询。
    这里使用差分数组结合树状数组的方法：
    1. 维护两个树状数组：一个用于记录区间加法的累积影响，另一个用于记录区间加法的次数
    2. 区间更新时，使用差分思想在树状数组上进行标记
    3. 区间查询时，通过两个树状数组的组合计算得到区间和
    
    时间复杂度: O((N+M)logN) - 每次操作的时间复杂度为O(logN)
    空间复杂度: O(N) - 需要存储树状数组
    
    这是最优解之一，线段树和树状数组都是解决此类问题的标准方法。
    """
    data = sys.stdin.read().split()
    if not data:
        return
    
    n = int(data[0])
    m = int(data[1])
    
    arr = [0] * (n + 1)
    bit1 = FenwickTree(n)  # 用于记录区间加法的累积影响
    bit2 = FenwickTree(n)  # 用于记录区间加法的次数
    
    # 读取初始数组
    idx = 2
    for i in range(1, n + 1):
        arr[i] = int(data[idx])
        idx += 1
    
    # 构建初始前缀和
    prefix = [0] * (n + 1)
    for i in range(1, n + 1):
        prefix[i] = prefix[i - 1] + arr[i]
    
    # 处理指令
    for _ in range(m):
        op = data[idx]
        idx += 1
        if op == 'C':
            a = int(data[idx]); idx += 1
            b = int(data[idx]); idx += 1
            c = int(data[idx]); idx += 1
            
            # 区间更新: 使用差分思想
            bit1.update(a, c)
            if b + 1 <= n:
                bit1.update(b + 1, -c)
            bit2.update(a, c * (a - 1))
            if b + 1 <= n:
                bit2.update(b + 1, -c * b)
        elif op == 'Q':
            a = int(data[idx]); idx += 1
            b = int(data[idx]); idx += 1
            
            # 区间查询: 使用两个树状数组组合计算
            sum1 = prefix[b] + bit1.query(b) * b - bit2.query(b)
            sum2 = prefix[a - 1] + bit1.query(a - 1) * (a - 1) - bit2.query(a - 1)
            print(sum1 - sum2)

if __name__ == "__main__":
    main()

===============================================

文件: Code22_NowCoderArrayManipulation.cpp
===============================================
#include <iostream>
#include <vector>
#include <climits>

using namespace std;

/**
 * 牛客网 - 数组操作问题
 * 
 * 题目描述:
 * 给定一个长度为 n 的数组，初始值都为 0。
 * 有 m 次操作，每次操作给出三个数 l, r, k，表示将数组下标从 l 到 r 的所有元素都加上 k。
 * 求执行完所有操作后数组中的最大值。
 * 
 * 示例:
 * 输入: n = 5, operations = [[1,2,100],[2,5,100],[3,4,100]]
 * 输出: 200
 * 
 * 解题思路:
 * 使用差分数组技巧来处理区间更新操作。
 * 1. 创建一个差分数组diff，大小为n+1
 * 2. 对于每个操作[l, r, k]，执行diff[l-1] += k和diff[r] -= k
 * 3. 对差分数组计算前缀和，得到最终数组
 * 4. 在计算前缀和的过程中记录最大值
 * 
 * 时间复杂度: O(n + m) - 需要遍历所有操作和数组一次
 * 空间复杂度: O(n) - 需要额外的差分数组空间
 * 
 * 这是最优解，因为需要处理所有操作，而且数组大小可能很大。
 */
class Solution {
public:
    long long maxValueAfterOperations(int n, vector<vector<int>>& operations) {
        // 边界情况处理
        if (n <= 0 || operations.empty()) {
            return 0;
        }
        
        // 创建差分数组，大小为n+1以便处理边界情况
        vector<long long> diff(n + 1, 0);
        
        // 处理每个操作
        for (auto& op : operations) {
            int l = op[0];      // 起始索引（1-based）
            int r = op[1];      // 结束索引（1-based）
            int k = op[2];      // 增加值
            
            // 在差分数组中标记区间更新
            diff[l - 1] += k;      // 在起始位置增加k
            if (r < n) {
                diff[r] -= k;      // 在结束位置之后减少k
            }
        }
        
        // 通过计算差分数组的前缀和得到最终数组，并记录最大值
        long long maxVal = LLONG_MIN;
        long long currentSum = 0;
        
        for (int i = 0; i < n; i++) {
            currentSum += diff[i];
            if (currentSum > maxVal) {
                maxVal = currentSum;
            }
        }
        
        return maxVal;
    }
};

/**
 * 测试用例
 */
int main() {
    Solution solution;
    
    // 测试用例1
    int n1 = 5;
    vector<vector<int>> operations1 = {{1, 2, 100}, {2, 5, 100}, {3, 4, 100}};
    long long result1 = solution.maxValueAfterOperations(n1, operations1);
    // 预期输出: 200
    cout << "测试用例1: " << result1 << endl;

    // 测试用例2
    int n2 = 10;
    vector<vector<int>> operations2 = {{2, 6, 8}, {3, 5, 7}, {1, 8, 1}, {5, 9, 15}};
    long long result2 = solution.maxValueAfterOperations(n2, operations2);
    // 预期输出: 31
    cout << "测试用例2: " << result2 << endl;
    
    // 测试用例3
    int n3 = 4;
    vector<vector<int>> operations3 = {{1, 2, 5}, {2, 4, 10}, {1, 3, 3}};
    long long result3 = solution.maxValueAfterOperations(n3, operations3);
    // 预期输出: 18
    cout << "测试用例3: " << result3 << endl;
    
    // 测试用例4 - 边界情况
    int n4 = 1;
    vector<vector<int>> operations4 = {{1, 1, 100}};
    long long result4 = solution.maxValueAfterOperations(n4, operations4);
    // 预期输出: 100
    cout << "测试用例4: " << result4 << endl;
    
    return 0;
}

===============================================

文件: Code22_NowCoderArrayManipulation.java
===============================================
package class047;

import java.util.*;

/**
 * 牛客网 - 数组操作问题
 * 
 * 题目描述:
 * 给定一个长度为 n 的数组，初始值都为 0。
 * 有 m 次操作，每次操作给出三个数 l, r, k，表示将数组下标从 l 到 r 的所有元素都加上 k。
 * 求执行完所有操作后数组中的最大值。
 * 
 * 示例:
 * 输入: n = 5, operations = [[1,2,100],[2,5,100],[3,4,100]]
 * 输出: 200
 * 
 * 题目链接: 牛客网类似题目
 * 
 * 解题思路:
 * 使用差分数组技巧来处理区间更新操作。
 * 1. 创建一个差分数组diff，大小为n+1
 * 2. 对于每个操作[l, r, k]，执行diff[l-1] += k和diff[r] -= k
 * 3. 对差分数组计算前缀和，得到最终数组
 * 4. 在计算前缀和的过程中记录最大值
 * 
 * 时间复杂度: O(n + m) - 需要遍历所有操作和数组一次
 * 空间复杂度: O(n) - 需要额外的差分数组空间
 * 
 * 这是最优解，因为需要处理所有操作，而且数组大小可能很大。
 */
public class Code22_NowCoderArrayManipulation {

    /**
     * 计算数组操作后的最大值
     * 
     * @param n 数组长度
     * @param operations 操作数组，每个操作包含[起始索引, 结束索引, 增加值]
     * @return 操作后数组的最大值
     */
    public static long maxValueAfterOperations(int n, int[][] operations) {
        // 边界情况处理
        if (n <= 0 || operations == null || operations.length == 0) {
            return 0;
        }
        
        // 创建差分数组，大小为n+1以便处理边界情况
        long[] diff = new long[n + 1];
        
        // 处理每个操作
        for (int[] op : operations) {
            int l = op[0];      // 起始索引（1-based）
            int r = op[1];      // 结束索引（1-based）
            int k = op[2];      // 增加值
            
            // 在差分数组中标记区间更新
            diff[l - 1] += k;      // 在起始位置增加k
            if (r < n) {
                diff[r] -= k;      // 在结束位置之后减少k
            }
        }
        
        // 通过计算差分数组的前缀和得到最终数组，并记录最大值
        long maxVal = Long.MIN_VALUE;
        long currentSum = 0;
        
        for (int i = 0; i < n; i++) {
            currentSum += diff[i];
            if (currentSum > maxVal) {
                maxVal = currentSum;
            }
        }
        
        return maxVal;
    }

    /**
     * 测试用例
     */
    public static void main(String[] args) {
        // 测试用例1
        int n1 = 5;
        int[][] operations1 = {{1, 2, 100}, {2, 5, 100}, {3, 4, 100}};
        long result1 = maxValueAfterOperations(n1, operations1);
        // 预期输出: 200
        System.out.println("测试用例1: " + result1);

        // 测试用例2
        int n2 = 10;
        int[][] operations2 = {{2, 6, 8}, {3, 5, 7}, {1, 8, 1}, {5, 9, 15}};
        long result2 = maxValueAfterOperations(n2, operations2);
        // 预期输出: 31
        System.out.println("测试用例2: " + result2);
        
        // 测试用例3
        int n3 = 4;
        int[][] operations3 = {{1, 2, 5}, {2, 4, 10}, {1, 3, 3}};
        long result3 = maxValueAfterOperations(n3, operations3);
        // 预期输出: 18
        System.out.println("测试用例3: " + result3);
        
        // 测试用例4 - 边界情况
        int n4 = 1;
        int[][] operations4 = {{1, 1, 100}};
        long result4 = maxValueAfterOperations(n4, operations4);
        // 预期输出: 100
        System.out.println("测试用例4: " + result4);
    }
    
    /**
     * 工程化考量:
     * 1. 异常处理: 验证输入参数的合法性
     * 2. 边界检查: 确保索引不越界
     * 3. 大数处理: 使用long类型防止整数溢出
     * 4. 性能优化: 使用差分数组减少时间复杂度
     * 5. 可读性: 清晰的变量命名和注释
     */
    
    /**
     * 时间复杂度分析:
     * - 处理操作: O(m)
     * - 计算前缀和: O(n)
     * 总时间复杂度: O(n + m)
     * 
     * 空间复杂度分析:
     * - 差分数组: O(n)
     * 总空间复杂度: O(n)
     */
    
    /**
     * 算法调试技巧:
     * 1. 打印中间结果: 可以打印差分数组和前缀和来验证逻辑
     * 2. 小规模测试: 使用简单测试用例验证算法正确性
     * 3. 边界测试: 测试n=1, m=1等边界情况
     */
    
    /**
     * 与HackerRank Array Manipulation的区别:
     * 1. 输入格式略有不同
     * 2. 核心算法思想相同
     * 3. 都是使用差分数组解决区间更新问题
     */
}

===============================================

文件: Code22_NowCoderArrayManipulation.py
===============================================
from typing import List
import sys

class Solution:
    """
    牛客网 - 数组操作问题
    
    题目描述:
    给定一个长度为 n 的数组，初始值都为 0。
    有 m 次操作，每次操作给出三个数 l, r, k，表示将数组下标从 l 到 r 的所有元素都加上 k。
    求执行完所有操作后数组中的最大值。
    
    示例:
    输入: n = 5, operations = [[1,2,100],[2,5,100],[3,4,100]]
    输出: 200
    
    解题思路:
    使用差分数组技巧来处理区间更新操作。
    1. 创建一个差分数组diff，大小为n+1
    2. 对于每个操作[l, r, k]，执行diff[l-1] += k和diff[r] -= k
    3. 对差分数组计算前缀和，得到最终数组
    4. 在计算前缀和的过程中记录最大值
    
    时间复杂度: O(n + m) - 需要遍历所有操作和数组一次
    空间复杂度: O(n) - 需要额外的差分数组空间
    
    这是最优解，因为需要处理所有操作，而且数组大小可能很大。
    """
    
    def maxValueAfterOperations(self, n: int, operations: List[List[int]]) -> int:
        """
        计算数组操作后的最大值
        
        Args:
            n: 数组长度
            operations: 操作数组，每个操作包含[起始索引, 结束索引, 增加值]
            
        Returns:
            操作后数组的最大值
        """
        # 边界情况处理
        if n <= 0 or not operations:
            return 0
        
        # 创建差分数组，大小为n+1以便处理边界情况
        diff = [0] * (n + 1)
        
        # 处理每个操作
        for op in operations:
            l, r, k = op[0], op[1], op[2]
            
            # 在差分数组中标记区间更新
            diff[l - 1] += k      # 在起始位置增加k
            if r < n:
                diff[r] -= k      # 在结束位置之后减少k
        
        # 通过计算差分数组的前缀和得到最终数组，并记录最大值
        max_val = -10**18  # 使用一个很小的数作为初始值
        current_sum = 0
        
        for i in range(n):
            current_sum += diff[i]
            if current_sum > max_val:
                max_val = current_sum
        
        return int(max_val)  # 确保返回int类型

def test_max_value_after_operations():
    """
    测试用例
    """
    solution = Solution()
    
    # 测试用例1
    n1 = 5
    operations1 = [[1, 2, 100], [2, 5, 100], [3, 4, 100]]
    result1 = solution.maxValueAfterOperations(n1, operations1)
    # 预期输出: 200
    print(f"测试用例1: {result1}")

    # 测试用例2
    n2 = 10
    operations2 = [[2, 6, 8], [3, 5, 7], [1, 8, 1], [5, 9, 15]]
    result2 = solution.maxValueAfterOperations(n2, operations2)
    # 预期输出: 31
    print(f"测试用例2: {result2}")
    
    # 测试用例3
    n3 = 4
    operations3 = [[1, 2, 5], [2, 4, 10], [1, 3, 3]]
    result3 = solution.maxValueAfterOperations(n3, operations3)
    # 预期输出: 18
    print(f"测试用例3: {result3}")
    
    # 测试用例4 - 边界情况
    n4 = 1
    operations4 = [[1, 1, 100]]
    result4 = solution.maxValueAfterOperations(n4, operations4)
    # 预期输出: 100
    print(f"测试用例4: {result4}")

if __name__ == "__main__":
    test_max_value_after_operations()

===============================================

文件: Code23_AcWingDifferenceArray.cpp
===============================================
#include <iostream>
#include <vector>

using namespace std;

/**
 * AcWing 797. 差分
 * 
 * 题目描述:
 * 输入一个长度为 n 的整数序列。
 * 接下来输入 m 个操作，每个操作包含三个整数 l, r, c，表示将序列中 [l, r] 之间的每个数加上 c。
 * 请你输出进行完所有操作后的序列。
 * 
 * 示例:
 * 输入:
 * 6 3
 * 1 2 2 1 2 1
 * 1 3 1
 * 3 5 1
 * 1 6 1
 * 
 * 输出:
 * 3 4 5 3 4 2
 * 
 * 题目链接: https://www.acwing.com/problem/content/799/
 * 
 * 解题思路:
 * 使用差分数组技巧来处理区间更新操作。
 * 1. 根据原数组构造差分数组
 * 2. 对于每个操作[l, r, c]，在差分数组中执行b[l] += c和b[r+1] -= c
 * 3. 对差分数组计算前缀和，得到更新后的原数组
 * 
 * 时间复杂度: O(n + m) - 需要遍历所有操作和数组一次
 * 空间复杂度: O(n) - 需要额外的差分数组空间
 * 
 * 这是最优解，因为需要处理所有操作，而且数组大小可能很大。
 */
class Solution {
public:
    vector<int> differenceArray(int n, int m, vector<int>& arr, vector<vector<int>>& operations) {
        // 边界情况处理
        if (n <= 0 || arr.size() != n) {
            return vector<int>();
        }
        
        // 创建差分数组
        vector<int> diff(n + 2, 0); // 多分配空间处理边界
        
        // 构造差分数组: diff[i] = arr[i-1] - arr[i-2]
        diff[1] = arr[0];
        for (int i = 2; i <= n; i++) {
            diff[i] = arr[i - 1] - arr[i - 2];
        }
        
        // 处理每个操作
        for (auto& op : operations) {
            int l = op[0];
            int r = op[1];
            int c = op[2];
            
            // 在差分数组中标记区间更新
            diff[l] += c;
            if (r + 1 <= n) {
                diff[r + 1] -= c;
            }
        }
        
        // 通过计算差分数组的前缀和得到最终数组
        vector<int> result(n);
        result[0] = diff[1];
        for (int i = 1; i < n; i++) {
            result[i] = result[i - 1] + diff[i + 1];
        }
        
        return result;
    }
};

/**
 * 测试用例
 */
int main() {
    Solution solution;
    
    // 测试用例1: 题目示例
    int n1 = 6, m1 = 3;
    vector<int> arr1 = {1, 2, 2, 1, 2, 1};
    vector<vector<int>> operations1 = {
        {1, 3, 1},
        {3, 5, 1},
        {1, 6, 1}
    };
    
    vector<int> result1 = solution.differenceArray(n1, m1, arr1, operations1);
    cout << "测试用例1: ";
    for (int num : result1) {
        cout << num << " ";
    }
    cout << endl; // 预期输出: 3 4 5 3 4 2

    // 测试用例2: 简单情况
    int n2 = 5, m2 = 2;
    vector<int> arr2 = {0, 0, 0, 0, 0};
    vector<vector<int>> operations2 = {
        {1, 3, 5},
        {2, 4, 3}
    };
    
    vector<int> result2 = solution.differenceArray(n2, m2, arr2, operations2);
    cout << "测试用例2: ";
    for (int num : result2) {
        cout << num << " ";
    }
    cout << endl; // 预期输出: 5 8 8 3 0
    
    // 测试用例3: 边界情况
    int n3 = 1, m3 = 1;
    vector<int> arr3 = {10};
    vector<vector<int>> operations3 = {
        {1, 1, 5}
    };
    
    vector<int> result3 = solution.differenceArray(n3, m3, arr3, operations3);
    cout << "测试用例3: ";
    for (int num : result3) {
        cout << num << " ";
    }
    cout << endl; // 预期输出: 15
    
    return 0;
}

===============================================

文件: Code23_AcWingDifferenceArray.java
===============================================
package class047;

import java.util.*;

/**
 * AcWing 797. 差分
 * 
 * 题目描述:
 * 输入一个长度为 n 的整数序列。
 * 接下来输入 m 个操作，每个操作包含三个整数 l, r, c，表示将序列中 [l, r] 之间的每个数加上 c。
 * 请你输出进行完所有操作后的序列。
 * 
 * 示例:
 * 输入:
 * 6 3
 * 1 2 2 1 2 1
 * 1 3 1
 * 3 5 1
 * 1 6 1
 * 
 * 输出:
 * 3 4 5 3 4 2
 * 
 * 题目链接: https://www.acwing.com/problem/content/799/
 * 
 * 解题思路:
 * 使用差分数组技巧来处理区间更新操作。
 * 1. 根据原数组构造差分数组
 * 2. 对于每个操作[l, r, c]，在差分数组中执行b[l] += c和b[r+1] -= c
 * 3. 对差分数组计算前缀和，得到更新后的原数组
 * 
 * 时间复杂度: O(n + m) - 需要遍历所有操作和数组一次
 * 空间复杂度: O(n) - 需要额外的差分数组空间
 * 
 * 这是最优解，因为需要处理所有操作，而且数组大小可能很大。
 */
public class Code23_AcWingDifferenceArray {

    /**
     * 执行差分数组操作
     * 
     * @param n 数组长度
     * @param m 操作数量
     * @param arr 原数组
     * @param operations 操作数组，每个操作包含[l, r, c]
     * @return 操作后的数组
     */
    public static int[] differenceArray(int n, int m, int[] arr, int[][] operations) {
        // 边界情况处理
        if (n <= 0 || arr == null || arr.length != n) {
            return new int[0];
        }
        
        // 创建差分数组
        int[] diff = new int[n + 2]; // 多分配空间处理边界
        
        // 构造差分数组: diff[i] = arr[i] - arr[i-1]
        diff[1] = arr[0];
        for (int i = 2; i <= n; i++) {
            diff[i] = arr[i - 1] - arr[i - 2];
        }
        
        // 处理每个操作
        for (int[] op : operations) {
            int l = op[0];
            int r = op[1];
            int c = op[2];
            
            // 在差分数组中标记区间更新
            diff[l] += c;
            if (r + 1 <= n) {
                diff[r + 1] -= c;
            }
        }
        
        // 通过计算差分数组的前缀和得到最终数组
        int[] result = new int[n];
        result[0] = diff[1];
        for (int i = 1; i < n; i++) {
            result[i] = result[i - 1] + diff[i + 1];
        }
        
        return result;
    }

    /**
     * 测试用例
     */
    public static void main(String[] args) {
        // 测试用例1: 题目示例
        int n1 = 6, m1 = 3;
        int[] arr1 = {1, 2, 2, 1, 2, 1};
        int[][] operations1 = {
            {1, 3, 1},
            {3, 5, 1},
            {1, 6, 1}
        };
        
        int[] result1 = differenceArray(n1, m1, arr1, operations1);
        System.out.print("测试用例1: ");
        for (int num : result1) {
            System.out.print(num + " ");
        }
        System.out.println(); // 预期输出: 3 4 5 3 4 2

        // 测试用例2: 简单情况
        int n2 = 5, m2 = 2;
        int[] arr2 = {0, 0, 0, 0, 0};
        int[][] operations2 = {
            {1, 3, 5},
            {2, 4, 3}
        };
        
        int[] result2 = differenceArray(n2, m2, arr2, operations2);
        System.out.print("测试用例2: ");
        for (int num : result2) {
            System.out.print(num + " ");
        }
        System.out.println(); // 预期输出: 5 8 8 3 0
        
        // 测试用例3: 边界情况
        int n3 = 1, m3 = 1;
        int[] arr3 = {10};
        int[][] operations3 = {
            {1, 1, 5}
        };
        
        int[] result3 = differenceArray(n3, m3, arr3, operations3);
        System.out.print("测试用例3: ");
        for (int num : result3) {
            System.out.print(num + " ");
        }
        System.out.println(); // 预期输出: 15
    }
    
    /**
     * 工程化考量:
     * 1. 异常处理: 验证输入参数的合法性
     * 2. 边界检查: 确保索引不越界
     * 3. 性能优化: 使用差分数组减少时间复杂度
     * 4. 可读性: 清晰的变量命名和注释
     */
    
    /**
     * 时间复杂度分析:
     * - 构造差分数组: O(n)
     * - 处理操作: O(m)
     * - 计算前缀和: O(n)
     * 总时间复杂度: O(n + m)
     * 
     * 空间复杂度分析:
     * - 差分数组: O(n)
     * - 结果数组: O(n)
     * 总空间复杂度: O(n)
     */
    
    /**
     * 算法调试技巧:
     * 1. 打印中间结果: 可以打印差分数组来验证逻辑
     * 2. 小规模测试: 使用简单测试用例验证算法正确性
     * 3. 边界测试: 测试n=1, m=1等边界情况
     */
    
    /**
     * 与标准差分数组的区别:
     * 1. 这里需要处理非零初始数组
     * 2. 需要先构造差分数组，再进行区间更新
     * 3. 核心思想相同，都是利用差分数组优化区间更新
     */
}

===============================================

文件: Code23_AcWingDifferenceArray.py
===============================================
from typing import List

class Solution:
    """
    AcWing 797. 差分
    
    题目描述:
    输入一个长度为 n 的整数序列。
    接下来输入 m 个操作，每个操作包含三个整数 l, r, c，表示将序列中 [l, r] 之间的每个数加上 c。
    请你输出进行完所有操作后的序列。
    
    示例:
    输入:
    6 3
    1 2 2 1 2 1
    1 3 1
    3 5 1
    1 6 1
    
    输出:
    3 4 5 3 4 2
    
    题目链接: https://www.acwing.com/problem/content/799/
    
    解题思路:
    使用差分数组技巧来处理区间更新操作。
    1. 根据原数组构造差分数组
    2. 对于每个操作[l, r, c]，在差分数组中执行b[l] += c和b[r+1] -= c
    3. 对差分数组计算前缀和，得到更新后的原数组
    
    时间复杂度: O(n + m) - 需要遍历所有操作和数组一次
    空间复杂度: O(n) - 需要额外的差分数组空间
    
    这是最优解，因为需要处理所有操作，而且数组大小可能很大。
    """
    
    def differenceArray(self, n: int, m: int, arr: List[int], operations: List[List[int]]) -> List[int]:
        """
        执行差分数组操作
        
        Args:
            n: 数组长度
            m: 操作数量
            arr: 原数组
            operations: 操作数组，每个操作包含[l, r, c]
            
        Returns:
            操作后的数组
        """
        # 边界情况处理
        if n <= 0 or not arr or len(arr) != n:
            return []
        
        # 创建差分数组
        diff = [0] * (n + 2)  # 多分配空间处理边界
        
        # 构造差分数组: diff[i] = arr[i-1] - arr[i-2]
        diff[1] = arr[0]
        for i in range(2, n + 1):
            diff[i] = arr[i - 1] - arr[i - 2]
        
        # 处理每个操作
        for op in operations:
            l, r, c = op[0], op[1], op[2]
            
            # 在差分数组中标记区间更新
            diff[l] += c
            if r + 1 <= n:
                diff[r + 1] -= c
        
        # 通过计算差分数组的前缀和得到最终数组
        result = [0] * n
        result[0] = diff[1]
        for i in range(1, n):
            result[i] = result[i - 1] + diff[i + 1]
        
        return result

def test_difference_array():
    """
    测试用例
    """
    solution = Solution()
    
    # 测试用例1: 题目示例
    n1, m1 = 6, 3
    arr1 = [1, 2, 2, 1, 2, 1]
    operations1 = [
        [1, 3, 1],
        [3, 5, 1],
        [1, 6, 1]
    ]
    
    result1 = solution.differenceArray(n1, m1, arr1, operations1)
    print(f"测试用例1: {result1}")  # 预期输出: [3, 4, 5, 3, 4, 2]

    # 测试用例2: 简单情况
    n2, m2 = 5, 2
    arr2 = [0, 0, 0, 0, 0]
    operations2 = [
        [1, 3, 5],
        [2, 4, 3]
    ]
    
    result2 = solution.differenceArray(n2, m2, arr2, operations2)
    print(f"测试用例2: {result2}")  # 预期输出: [5, 8, 8, 3, 0]
    
    # 测试用例3: 边界情况
    n3, m3 = 1, 1
    arr3 = [10]
    operations3 = [
        [1, 1, 5]
    ]
    
    result3 = solution.differenceArray(n3, m3, arr3, operations3)
    print(f"测试用例3: {result3}")  # 预期输出: [15]

if __name__ == "__main__":
    test_difference_array()

===============================================

文件: Code24_RangeAdditionLC370.cpp
===============================================
#include <iostream>
#include <vector>
using namespace std;

/**
 * LeetCode 370. Range Addition
 * 
 * 题目描述:
 * 假设你有一个长度为 n 的数组，初始情况下所有的数字均为 0，
 * 你将会被给出 k 个更新的操作。
 * 其中，每个操作会被表示为一个三元组：[startIndex, endIndex, inc]，
 * 你需要将子数组 A[startIndex ... endIndex]（包括 startIndex 和 endIndex）增加 inc。
 * 
 * 示例:
 * 输入: length = 5, updates = [[1,3,2],[2,4,3],[0,2,-2]]
 * 输出: [-2,0,3,5,3]
 * 解释:
 * 初始状态: [0,0,0,0,0]
 * 进行了操作 [1,3,2] 后的状态: [0,2,2,2,0]
 * 进行了操作 [2,4,3] 后的状态: [0,2,5,5,3]
 * 进行了操作 [0,2,-2] 后的状态: [-2,0,3,5,3]
 * 
 * 提示:
 * 1 <= length <= 10^5
 * 0 <= updates.length <= 10^4
 * 0 <= startIndex <= endIndex < length
 * -1000 <= inc <= 1000
 * 
 * 题目链接: https://leetcode.com/problems/range-addition/
 * 
 * 解题思路:
 * 使用差分数组技巧来优化区间更新操作。
 * 1. 创建一个差分数组diff，大小为n+1
 * 2. 对于每个操作[startIndex, endIndex, inc]，执行diff[startIndex] += inc和diff[endIndex+1] -= inc
 * 3. 对差分数组计算前缀和，得到最终数组
 * 
 * 时间复杂度: O(n + k) - 需要遍历所有操作和数组一次
 * 空间复杂度: O(n) - 需要额外的差分数组空间
 * 
 * 这是最优解，因为需要处理所有操作，而且数组大小可能很大，不能使用暴力方法。
 */

class Solution {
public:
    /**
     * 计算区间加法后的数组
     * 
     * @param length 数组长度
     * @param updates 更新操作数组，每个操作包含[起始索引, 结束索引, 增加值]
     * @return 更新后的数组
     * 
     * 时间复杂度: O(n + k) - 需要遍历所有操作和数组一次
     * 空间复杂度: O(n) - 需要额外的差分数组空间
     * 
     * 工程化考量:
     * 1. 边界处理: 处理空数组和空操作情况
     * 2. 异常处理: 验证输入参数的合法性
     * 3. 性能优化: 使用差分数组将区间更新操作从O(n)优化到O(1)
     * 4. 可读性: 变量命名清晰，注释详细
     */
    vector<int> getModifiedArray(int length, vector<vector<int>>& updates) {
        // 边界情况处理
        if (length <= 0) {
            return vector<int>();
        }
        
        if (updates.empty()) {
            return vector<int>(length, 0);
        }
        
        // 创建差分数组，大小为length+1以便处理边界情况
        vector<int> diff(length + 1, 0);
        
        // 处理每个更新操作
        for (const auto& update : updates) {
            int startIndex = update[0];    // 起始索引
            int endIndex = update[1];      // 结束索引
            int inc = update[2];           // 增加值
            
            // 在差分数组中标记区间更新
            diff[startIndex] += inc;       // 在起始位置增加inc
            if (endIndex + 1 < length) {
                diff[endIndex + 1] -= inc; // 在结束位置之后减少inc
            }
        }
        
        // 通过计算差分数组的前缀和得到最终数组
        vector<int> result(length);
        result[0] = diff[0];
        for (int i = 1; i < length; i++) {
            result[i] = result[i - 1] + diff[i];
        }
        
        return result;
    }
};

/**
 * 测试用例
 */
int main() {
    Solution solution;
    
    // 测试用例1
    vector<vector<int>> updates1 = {{1, 3, 2}, {2, 4, 3}, {0, 2, -2}};
    vector<int> result1 = solution.getModifiedArray(5, updates1);
    // 预期输出: [-2, 0, 3, 5, 3]
    cout << "测试用例1: ";
    for (int num : result1) {
        cout << num << " ";
    }
    cout << endl;

    // 测试用例2
    vector<vector<int>> updates2 = {{2, 4, 6}, {5, 6, 8}, {1, 9, -4}};
    vector<int> result2 = solution.getModifiedArray(10, updates2);
    // 预期输出: [0, -4, 2, 2, 2, 4, 4, -4, -4, -4]
    cout << "测试用例2: ";
    for (int num : result2) {
        cout << num << " ";
    }
    cout << endl;
    
    // 测试用例3: 边界情况
    vector<vector<int>> updates3 = {{0, 0, 5}};
    vector<int> result3 = solution.getModifiedArray(1, updates3);
    // 预期输出: [5]
    cout << "测试用例3: ";
    for (int num : result3) {
        cout << num << " ";
    }
    cout << endl;
    
    return 0;
}

===============================================

文件: Code24_RangeAdditionLC370.java
===============================================
package class047;

/**
 * LeetCode 370. Range Addition
 * 
 * 题目描述:
 * 假设你有一个长度为 n 的数组，初始情况下所有的数字均为 0，
 * 你将会被给出 k 个更新的操作。
 * 其中，每个操作会被表示为一个三元组：[startIndex, endIndex, inc]，
 * 你需要将子数组 A[startIndex ... endIndex]（包括 startIndex 和 endIndex）增加 inc。
 * 
 * 示例:
 * 输入: length = 5, updates = [[1,3,2],[2,4,3],[0,2,-2]]
 * 输出: [-2,0,3,5,3]
 * 解释:
 * 初始状态: [0,0,0,0,0]
 * 进行了操作 [1,3,2] 后的状态: [0,2,2,2,0]
 * 进行了操作 [2,4,3] 后的状态: [0,2,5,5,3]
 * 进行了操作 [0,2,-2] 后的状态: [-2,0,3,5,3]
 * 
 * 提示:
 * 1 <= length <= 10^5
 * 0 <= updates.length <= 10^4
 * 0 <= startIndex <= endIndex < length
 * -1000 <= inc <= 1000
 * 
 * 题目链接: https://leetcode.com/problems/range-addition/
 * 
 * 解题思路:
 * 使用差分数组技巧来优化区间更新操作。
 * 1. 创建一个差分数组diff，大小为n+1
 * 2. 对于每个操作[startIndex, endIndex, inc]，执行diff[startIndex] += inc和diff[endIndex+1] -= inc
 * 3. 对差分数组计算前缀和，得到最终数组
 * 
 * 时间复杂度: O(n + k) - 需要遍历所有操作和数组一次
 * 空间复杂度: O(n) - 需要额外的差分数组空间
 * 
 * 这是最优解，因为需要处理所有操作，而且数组大小可能很大，不能使用暴力方法。
 */
public class Code24_RangeAdditionLC370 {

    /**
     * 计算区间加法后的数组
     * 
     * @param length 数组长度
     * @param updates 更新操作数组，每个操作包含[起始索引, 结束索引, 增加值]
     * @return 更新后的数组
     * 
     * 时间复杂度: O(n + k) - 需要遍历所有操作和数组一次
     * 空间复杂度: O(n) - 需要额外的差分数组空间
     * 
     * 工程化考量:
     * 1. 边界处理: 处理空数组和空操作情况
     * 2. 异常处理: 验证输入参数的合法性
     * 3. 性能优化: 使用差分数组将区间更新操作从O(n)优化到O(1)
     * 4. 可读性: 变量命名清晰，注释详细
     */
    public static int[] getModifiedArray(int length, int[][] updates) {
        // 边界情况处理
        if (length <= 0) {
            return new int[0];
        }
        
        if (updates == null || updates.length == 0) {
            return new int[length];
        }
        
        // 创建差分数组，大小为length+1以便处理边界情况
        int[] diff = new int[length + 1];
        
        // 处理每个更新操作
        for (int[] update : updates) {
            int startIndex = update[0];    // 起始索引
            int endIndex = update[1];      // 结束索引
            int inc = update[2];           // 增加值
            
            // 在差分数组中标记区间更新
            diff[startIndex] += inc;       // 在起始位置增加inc
            if (endIndex + 1 < length) {
                diff[endIndex + 1] -= inc; // 在结束位置之后减少inc
            }
        }
        
        // 通过计算差分数组的前缀和得到最终数组
        int[] result = new int[length];
        result[0] = diff[0];
        for (int i = 1; i < length; i++) {
            result[i] = result[i - 1] + diff[i];
        }
        
        return result;
    }

    /**
     * 测试用例
     */
    public static void main(String[] args) {
        // 测试用例1
        int length1 = 5;
        int[][] updates1 = {{1, 3, 2}, {2, 4, 3}, {0, 2, -2}};
        int[] result1 = getModifiedArray(length1, updates1);
        // 预期输出: [-2, 0, 3, 5, 3]
        System.out.print("测试用例1: ");
        for (int num : result1) {
            System.out.print(num + " ");
        }
        System.out.println();

        // 测试用例2
        int length2 = 10;
        int[][] updates2 = {{2, 4, 6}, {5, 6, 8}, {1, 9, -4}};
        int[] result2 = getModifiedArray(length2, updates2);
        // 预期输出: [0, -4, 2, 2, 2, 4, 4, -4, -4, -4]
        System.out.print("测试用例2: ");
        for (int num : result2) {
            System.out.print(num + " ");
        }
        System.out.println();
        
        // 测试用例3: 边界情况
        int length3 = 1;
        int[][] updates3 = {{0, 0, 5}};
        int[] result3 = getModifiedArray(length3, updates3);
        // 预期输出: [5]
        System.out.print("测试用例3: ");
        for (int num : result3) {
            System.out.print(num + " ");
        }
        System.out.println();
    }
}

===============================================

文件: Code24_RangeAdditionLC370.py
===============================================
"""
LeetCode 370. Range Addition

题目描述:
假设你有一个长度为 n 的数组，初始情况下所有的数字均为 0，
你将会被给出 k 个更新的操作。
其中，每个操作会被表示为一个三元组：[startIndex, endIndex, inc]，
你需要将子数组 A[startIndex ... endIndex]（包括 startIndex 和 endIndex）增加 inc。

示例:
输入: length = 5, updates = [[1,3,2],[2,4,3],[0,2,-2]]
输出: [-2,0,3,5,3]
解释:
初始状态: [0,0,0,0,0]
进行了操作 [1,3,2] 后的状态: [0,2,2,2,0]
进行了操作 [2,4,3] 后的状态: [0,2,5,5,3]
进行了操作 [0,2,-2] 后的状态: [-2,0,3,5,3]

提示:
1 <= length <= 10^5
0 <= updates.length <= 10^4
0 <= startIndex <= endIndex < length
-1000 <= inc <= 1000

题目链接: https://leetcode.com/problems/range-addition/

解题思路:
使用差分数组技巧来优化区间更新操作。
1. 创建一个差分数组diff，大小为n+1
2. 对于每个操作[startIndex, endIndex, inc]，执行diff[startIndex] += inc和diff[endIndex+1] -= inc
3. 对差分数组计算前缀和，得到最终数组

时间复杂度: O(n + k) - 需要遍历所有操作和数组一次
空间复杂度: O(n) - 需要额外的差分数组空间

这是最优解，因为需要处理所有操作，而且数组大小可能很大，不能使用暴力方法。
"""


def get_modified_array(length, updates):
    """
    计算区间加法后的数组
    
    Args:
        length: 数组长度
        updates: 更新操作数组，每个操作包含[起始索引, 结束索引, 增加值]
        
    Returns:
        更新后的数组
        
    时间复杂度: O(n + k) - 需要遍历所有操作和数组一次
    空间复杂度: O(n) - 需要额外的差分数组空间
    
    工程化考量:
    1. 边界处理: 处理空数组和空操作情况
    2. 异常处理: 验证输入参数的合法性
    3. 性能优化: 使用差分数组将区间更新操作从O(n)优化到O(1)
    4. 可读性: 变量命名清晰，注释详细
    """
    # 边界情况处理
    if length <= 0:
        return []
    
    if not updates:
        return [0] * length
    
    # 创建差分数组，大小为length+1以便处理边界情况
    diff = [0] * (length + 1)
    
    # 处理每个更新操作
    for update in updates:
        start_index = update[0]    # 起始索引
        end_index = update[1]      # 结束索引
        inc = update[2]           # 增加值
        
        # 在差分数组中标记区间更新
        diff[start_index] += inc       # 在起始位置增加inc
        if end_index + 1 < length:
            diff[end_index + 1] -= inc # 在结束位置之后减少inc
    
    # 通过计算差分数组的前缀和得到最终数组
    result = [0] * length
    result[0] = diff[0]
    for i in range(1, length):
        result[i] = result[i - 1] + diff[i]
    
    return result


def main():
    """测试用例"""
    # 测试用例1
    length1 = 5
    updates1 = [[1, 3, 2], [2, 4, 3], [0, 2, -2]]
    result1 = get_modified_array(length1, updates1)
    # 预期输出: [-2, 0, 3, 5, 3]
    print("测试用例1:", result1)

    # 测试用例2
    length2 = 10
    updates2 = [[2, 4, 6], [5, 6, 8], [1, 9, -4]]
    result2 = get_modified_array(length2, updates2)
    # 预期输出: [0, -4, 2, 2, 2, 4, 4, -4, -4, -4]
    print("测试用例2:", result2)
    
    # 测试用例3: 边界情况
    length3 = 1
    updates3 = [[0, 0, 5]]
    result3 = get_modified_array(length3, updates3)
    # 预期输出: [5]
    print("测试用例3:", result3)


if __name__ == "__main__":
    main()

===============================================

文件: Code25_POJ3468SimpleProblemWithIntegers.java
===============================================
package class047;

import java.io.*;
import java.util.*;

/**
 * POJ 3468 A Simple Problem with Integers
 * 
 * 题目描述:
 * 你有N个整数A1, A2, ... , AN。你需要处理两种类型的操作。
 * 一种操作是给定区间的每个数加上一个给定的数。
 * 另一种操作是查询给定区间所有数的和。
 * 
 * 输入:
 * 第一行包含两个数字N和Q。1 ≤ N,Q ≤ 100000。
 * 第二行包含N个数字，表示A1, A2, ... , AN的初始值。-1000000000 ≤ Ai ≤ 1000000000。
 * 接下来Q行，每行包含一个操作：
 * "C a b c" 表示将区间[a,b]中的每个数加上c。-10000 ≤ c ≤ 10000。
 * "Q a b" 表示查询区间[a,b]中所有数的和。
 * 
 * 输出:
 * 对于每个"Q a b"操作，输出一行表示区间和。
 * 
 * 题目链接: http://poj.org/problem?id=3468
 * 
 * 解题思路:
 * 使用树状数组结合差分数组来处理区间更新和区间查询操作。
 * 1. 使用两个树状数组维护差分信息
 * 2. 对于区间加法操作，使用差分标记更新两个树状数组
 * 3. 对于区间查询操作，使用前缀和公式计算区间和
 * 
 * 时间复杂度: O(Q log N) - 每次操作需要O(log N)时间
 * 空间复杂度: O(N) - 需要额外的树状数组空间
 * 
 * 这是最优解，因为需要支持动态区间更新和查询操作。
 */
public class Code25_POJ3468SimpleProblemWithIntegers {
    
    static class BIT {
        private long[] tree;
        private int n;
        
        public BIT(int size) {
            this.n = size;
            this.tree = new long[size + 1];
        }
        
        public void update(int idx, long val) {
            for (int i = idx; i <= n; i += i & -i) {
                tree[i] += val;
            }
        }
        
        public long query(int idx) {
            long sum = 0;
            for (int i = idx; i > 0; i -= i & -i) {
                sum += tree[i];
            }
            return sum;
        }
    }
    
    static class RangeBIT {
        private BIT bit1, bit2;
        private int n;
        
        public RangeBIT(int size) {
            this.n = size;
            this.bit1 = new BIT(size);
            this.bit2 = new BIT(size);
        }
        
        // 区间更新 [l, r] 加上 val
        public void rangeUpdate(int l, int r, long val) {
            bit1.update(l, val);
            bit1.update(r + 1, -val);
            bit2.update(l, val * (l - 1));
            bit2.update(r + 1, -val * r);
        }
        
        // 查询前缀和 [1, idx]
        public long prefixSum(int idx) {
            return bit1.query(idx) * idx - bit2.query(idx);
        }
        
        // 查询区间和 [l, r]
        public long rangeSum(int l, int r) {
            return prefixSum(r) - prefixSum(l - 1);
        }
    }
    
    /**
     * 主函数，处理输入并输出结果
     * 
     * 时间复杂度: O(Q log N) - 每次操作需要O(log N)时间
     * 空间复杂度: O(N) - 需要额外的树状数组空间
     * 
     * 工程化考量:
     * 1. 输入处理: 使用高效的输入处理方式
     * 2. 边界处理: 确保数组索引正确
     * 3. 性能优化: 使用树状数组结合差分处理区间操作
     * 4. 输出格式: 按照题目要求输出结果
     */
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        PrintWriter out = new PrintWriter(new OutputStreamWriter(System.out));
        
        StringTokenizer st = new StringTokenizer(br.readLine());
        int n = Integer.parseInt(st.nextToken());
        int q = Integer.parseInt(st.nextToken());
        
        RangeBIT rangeBit = new RangeBIT(n);
        
        st = new StringTokenizer(br.readLine());
        for (int i = 1; i <= n; i++) {
            long val = Long.parseLong(st.nextToken());
            rangeBit.rangeUpdate(i, i, val);
        }
        
        for (int i = 0; i < q; i++) {
            st = new StringTokenizer(br.readLine());
            String op = st.nextToken();
            
            if (op.equals("C")) {
                // 区间更新操作
                int a = Integer.parseInt(st.nextToken());
                int b = Integer.parseInt(st.nextToken());
                long c = Long.parseLong(st.nextToken());
                rangeBit.rangeUpdate(a, b, c);
            } else {
                // 区间查询操作
                int a = Integer.parseInt(st.nextToken());
                int b = Integer.parseInt(st.nextToken());
                out.println(rangeBit.rangeSum(a, b));
            }
        }
        
        out.flush();
        out.close();
        br.close();
    }
}

===============================================

文件: Code25_POJ3468SimpleProblemWithIntegers.py
===============================================
"""
POJ 3468 A Simple Problem with Integers

题目描述:
你有N个整数A1, A2, ... , AN。你需要处理两种类型的操作。
一种操作是给定区间的每个数加上一个给定的数。
另一种操作是查询给定区间所有数的和。

输入:
第一行包含两个数字N和Q。1 ≤ N,Q ≤ 100000。
第二行包含N个数字，表示A1, A2, ... , AN的初始值。-1000000000 ≤ Ai ≤ 1000000000。
接下来Q行，每行包含一个操作：
"C a b c" 表示将区间[a,b]中的每个数加上c。-10000 ≤ c ≤ 10000。
"Q a b" 表示查询区间[a,b]中所有数的和。

输出:
对于每个"Q a b"操作，输出一行表示区间和。

题目链接: http://poj.org/problem?id=3468

解题思路:
使用树状数组结合差分数组来处理区间更新和区间查询操作。
1. 使用两个树状数组维护差分信息
2. 对于区间加法操作，使用差分标记更新两个树状数组
3. 对于区间查询操作，使用前缀和公式计算区间和

时间复杂度: O(Q log N) - 每次操作需要O(log N)时间
空间复杂度: O(N) - 需要额外的树状数组空间

这是最优解，因为需要支持动态区间更新和查询操作。
"""


class BIT:
    def __init__(self, size):
        self.n = size
        self.tree = [0] * (size + 1)
    
    def update(self, idx, val):
        while idx <= self.n:
            self.tree[idx] += val
            idx += idx & -idx
    
    def query(self, idx):
        sum_val = 0
        while idx > 0:
            sum_val += self.tree[idx]
            idx -= idx & -idx
        return sum_val


class RangeBIT:
    def __init__(self, size):
        self.n = size
        self.bit1 = BIT(size)
        self.bit2 = BIT(size)
    
    # 区间更新 [l, r] 加上 val
    def range_update(self, l, r, val):
        self.bit1.update(l, val)
        self.bit1.update(r + 1, -val)
        self.bit2.update(l, val * (l - 1))
        self.bit2.update(r + 1, -val * r)
    
    # 查询前缀和 [1, idx]
    def prefix_sum(self, idx):
        return self.bit1.query(idx) * idx - self.bit2.query(idx)
    
    # 查询区间和 [l, r]
    def range_sum(self, l, r):
        return self.prefix_sum(r) - self.prefix_sum(l - 1)


def main():
    """
    主函数，处理输入并输出结果
    
    时间复杂度: O(Q log N) - 每次操作需要O(log N)时间
    空间复杂度: O(N) - 需要额外的树状数组空间
    
    工程化考量:
    1. 输入处理: 使用高效的输入处理方式
    2. 边界处理: 确保数组索引正确
    3. 性能优化: 使用树状数组结合差分处理区间操作
    4. 输出格式: 按照题目要求输出结果
    """
    try:
        line = input().split()
        n = int(line[0])
        q = int(line[1])
        
        range_bit = RangeBIT(n)
        
        values = list(map(int, input().split()))
        for i in range(n):
            range_bit.range_update(i + 1, i + 1, values[i])
        
        for _ in range(q):
            operation = input().split()
            op = operation[0]
            
            if op == "C":
                # 区间更新操作
                a = int(operation[1])
                b = int(operation[2])
                c = int(operation[3])
                range_bit.range_update(a, b, c)
            else:
                # 区间查询操作
                a = int(operation[1])
                b = int(operation[2])
                print(range_bit.range_sum(a, b))
                
    except EOFError:
        pass


if __name__ == "__main__":
    main()

===============================================

文件: Code26_AcWing797Difference.java
===============================================
package class047;

import java.util.*;

/**
 * AcWing 797. 差分
 * 
 * 题目描述:
 * 输入一个长度为 n 的整数序列。
 * 接下来输入 m 个操作，每个操作包含三个整数 l, r, c，
 * 表示将序列中 [l, r] 之间的每个数加上 c。
 * 
 * 输入格式:
 * 第一行包含两个整数 n 和 m。
 * 第二行包含 n 个整数，表示整数序列。
 * 接下来 m 行，每行包含三个整数 l，r，c，表示一个操作。
 * 
 * 输出格式:
 * 共一行，包含 n 个整数，表示最终序列。
 * 
 * 数据范围:
 * 1 ≤ n, m ≤ 100000,
 * 1 ≤ l ≤ r ≤ n,
 * -1000 ≤ c ≤ 1000,
 * -1000 ≤ 数列中元素的绝对值 ≤ 1000
 * 
 * 题目链接: https://www.acwing.com/problem/content/799/
 * 
 * 解题思路:
 * 使用差分数组技巧来优化区间更新操作。
 * 1. 创建一个差分数组diff，大小为n+2（处理边界情况）
 * 2. 对于每个操作[l, r, c]，执行diff[l] += c和diff[r+1] -= c
 * 3. 对差分数组计算前缀和，得到最终序列
 * 
 * 时间复杂度: O(n + m) - 需要遍历所有操作和数组一次
 * 空间复杂度: O(n) - 需要额外的差分数组空间
 * 
 * 这是最优解，因为需要处理所有操作，使用差分数组将区间更新操作从O(n)优化到O(1)。
 */
public class Code26_AcWing797Difference {

    /**
     * 处理差分数组操作
     * 
     * @param n 数组长度
     * @param m 操作数量
     * @param arr 初始数组
     * @param operations 操作数组，每个操作包含[起始索引, 结束索引, 增加值]
     * @return 最终数组
     * 
     * 时间复杂度: O(n + m) - 需要遍历所有操作和数组一次
     * 空间复杂度: O(n) - 需要额外的差分数组空间
     * 
     * 工程化考量:
     * 1. 边界处理: 使用大小为n+2的数组避免索引越界
     * 2. 异常处理: 可以添加输入参数验证
     * 3. 性能优化: 差分数组将区间更新操作从O(n)优化到O(1)
     * 4. 可读性: 变量命名清晰，注释详细
     */
    public static int[] processDifference(int n, int m, int[] arr, int[][] operations) {
        // 创建差分数组，大小为 n+2 是为了处理边界情况
        int[] diff = new int[n + 2];
        
        // 构造初始数组的差分数组
        diff[1] = arr[0];
        for (int i = 2; i <= n; i++) {
            diff[i] = arr[i - 1] - arr[i - 2];
        }
        
        // 处理每个操作
        for (int[] operation : operations) {
            int l = operation[0];    // 起始索引（1-based）
            int r = operation[1];    // 结束索引（1-based）
            int c = operation[2];    // 增加值
            
            // 在差分数组中标记区间更新
            diff[l] += c;            // 在起始位置增加c
            diff[r + 1] -= c;        // 在结束位置之后减少c
        }
        
        // 通过计算差分数组的前缀和得到最终数组
        int[] result = new int[n];
        result[0] = diff[1];
        for (int i = 1; i < n; i++) {
            result[i] = result[i - 1] + diff[i + 1];
        }
        
        return result;
    }

    /**
     * 主函数，处理输入并输出结果
     * 
     * 时间复杂度: O(n + m) - 需要遍历所有操作和数组一次
     * 空间复杂度: O(n) - 需要额外的差分数组空间
     * 
     * 工程化考量:
     * 1. 输入处理: 使用高效的输入处理方式
     * 2. 边界处理: 确保数组索引正确
     * 3. 性能优化: 使用差分数组避免重复计算
     * 4. 输出格式: 按照题目要求输出结果
     */
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        
        int n = scanner.nextInt();
        int m = scanner.nextInt();
        
        int[] arr = new int[n];
        for (int i = 0; i < n; i++) {
            arr[i] = scanner.nextInt();
        }
        
        int[][] operations = new int[m][3];
        for (int i = 0; i < m; i++) {
            operations[i][0] = scanner.nextInt();
            operations[i][1] = scanner.nextInt();
            operations[i][2] = scanner.nextInt();
        }
        
        int[] result = processDifference(n, m, arr, operations);
        
        // 输出结果
        for (int i = 0; i < n; i++) {
            System.out.print(result[i]);
            if (i < n - 1) {
                System.out.print(" ");
            }
        }
        System.out.println();
        
        scanner.close();
    }
}

===============================================

文件: Code26_AcWing797Difference.py
===============================================
"""
AcWing 797. 差分

题目描述:
输入一个长度为 n 的整数序列。
接下来输入 m 个操作，每个操作包含三个整数 l, r, c，
表示将序列中 [l, r] 之间的每个数加上 c。

输入格式:
第一行包含两个整数 n 和 m。
第二行包含 n 个整数，表示整数序列。
接下来 m 行，每行包含三个整数 l，r，c，表示一个操作。

输出格式:
共一行，包含 n 个整数，表示最终序列。

数据范围:
1 ≤ n, m ≤ 100000,
1 ≤ l ≤ r ≤ n,
-1000 ≤ c ≤ 1000,
-1000 ≤ 数列中元素的绝对值 ≤ 1000

题目链接: https://www.acwing.com/problem/content/799/

解题思路:
使用差分数组技巧来优化区间更新操作。
1. 创建一个差分数组diff，大小为n+2（处理边界情况）
2. 对于每个操作[l, r, c]，执行diff[l] += c和diff[r+1] -= c
3. 对差分数组计算前缀和，得到最终序列

时间复杂度: O(n + m) - 需要遍历所有操作和数组一次
空间复杂度: O(n) - 需要额外的差分数组空间

这是最优解，因为需要处理所有操作，使用差分数组将区间更新操作从O(n)优化到O(1)。
"""


def process_difference(n, m, arr, operations):
    """
    处理差分数组操作
    
    Args:
        n: 数组长度
        m: 操作数量
        arr: 初始数组
        operations: 操作数组，每个操作包含[起始索引, 结束索引, 增加值]
        
    Returns:
        最终数组
        
    时间复杂度: O(n + m) - 需要遍历所有操作和数组一次
    空间复杂度: O(n) - 需要额外的差分数组空间
    
    工程化考量:
    1. 边界处理: 使用大小为n+2的数组避免索引越界
    2. 异常处理: 可以添加输入参数验证
    3. 性能优化: 差分数组将区间更新操作从O(n)优化到O(1)
    4. 可读性: 变量命名清晰，注释详细
    """
    # 创建差分数组，大小为 n+2 是为了处理边界情况
    diff = [0] * (n + 2)
    
    # 构造初始数组的差分数组
    diff[1] = arr[0]
    for i in range(2, n + 1):
        diff[i] = arr[i - 1] - arr[i - 2]
    
    # 处理每个操作
    for operation in operations:
        l = operation[0]    # 起始索引（1-based）
        r = operation[1]    # 结束索引（1-based）
        c = operation[2]    # 增加值
        
        # 在差分数组中标记区间更新
        diff[l] += c            # 在起始位置增加c
        diff[r + 1] -= c        # 在结束位置之后减少c
    
    # 通过计算差分数组的前缀和得到最终数组
    result = [0] * n
    result[0] = diff[1]
    for i in range(1, n):
        result[i] = result[i - 1] + diff[i + 1]
    
    return result


def main():
    """
    主函数，处理输入并输出结果
    
    时间复杂度: O(n + m) - 需要遍历所有操作和数组一次
    空间复杂度: O(n) - 需要额外的差分数组空间
    
    工程化考量:
    1. 输入处理: 使用高效的输入处理方式
    2. 边界处理: 确保数组索引正确
    3. 性能优化: 使用差分数组避免重复计算
    4. 输出格式: 按照题目要求输出结果
    """
    # 读取输入
    n, m = map(int, input().split())
    
    arr = list(map(int, input().split()))
    
    operations = []
    for _ in range(m):
        l, r, c = map(int, input().split())
        operations.append([l, r, c])
    
    result = process_difference(n, m, arr, operations)
    
    # 输出结果
    print(' '.join(map(str, result)))


if __name__ == "__main__":
    main()

===============================================

文件: Code27_NowCoderTemplateDifference.java
===============================================
package class047;

import java.util.*;

/**
 * 牛客网 【模板】差分
 * 
 * 题目描述:
 * 对于给定的长度为n的数组，我们有m次修改操作，
 * 每一次操作给出三个参数l, r, c，代表将数组中的元素[l, r]都加上c。
 * 请你输出全部操作完成后的数组。
 * 
 * 输入描述:
 * 第一行输入两个整数n, m代表数组中的元素数量、操作次数。
 * 第二行输入n个整数代表初始数组。
 * 此后m行，每行输入三个整数l, r, c代表一次操作。
 * 
 * 输出描述:
 * 在一行上输出n个整数，代表最终的数组。
 * 
 * 数据范围:
 * 1 ≤ n, m ≤ 100000
 * -1000 ≤ 数组元素 ≤ 1000
 * 1 ≤ l ≤ r ≤ n
 * -1000 ≤ c ≤ 1000
 * 
 * 解题思路:
 * 使用差分数组技巧来优化区间更新操作。
 * 1. 创建一个差分数组diff，大小为n+2（处理边界情况）
 * 2. 对于每个操作[l, r, c]，执行diff[l] += c和diff[r+1] -= c
 * 3. 对差分数组计算前缀和，得到最终数组
 * 
 * 时间复杂度: O(n + m) - 需要遍历所有操作和数组一次
 * 空间复杂度: O(n) - 需要额外的差分数组空间
 * 
 * 这是最优解，因为需要处理所有操作，使用差分数组将区间更新操作从O(n)优化到O(1)。
 */
public class Code27_NowCoderTemplateDifference {

    /**
     * 处理差分数组操作
     * 
     * @param n 数组长度
     * @param m 操作数量
     * @param arr 初始数组
     * @param operations 操作数组，每个操作包含[起始索引, 结束索引, 增加值]
     * @return 最终数组
     * 
     * 时间复杂度: O(n + m) - 需要遍历所有操作和数组一次
     * 空间复杂度: O(n) - 需要额外的差分数组空间
     * 
     * 工程化考量:
     * 1. 边界处理: 使用大小为n+2的数组避免索引越界
     * 2. 异常处理: 可以添加输入参数验证
     * 3. 性能优化: 差分数组将区间更新操作从O(n)优化到O(1)
     * 4. 可读性: 变量命名清晰，注释详细
     */
    public static int[] processDifference(int n, int m, int[] arr, int[][] operations) {
        // 创建差分数组，大小为 n+2 是为了处理边界情况
        int[] diff = new int[n + 2];
        
        // 构造初始数组的差分数组
        diff[1] = arr[0];
        for (int i = 2; i <= n; i++) {
            diff[i] = arr[i - 1] - arr[i - 2];
        }
        
        // 处理每个操作
        for (int[] operation : operations) {
            int l = operation[0];    // 起始索引（1-based）
            int r = operation[1];    // 结束索引（1-based）
            int c = operation[2];    // 增加值
            
            // 在差分数组中标记区间更新
            diff[l] += c;            // 在起始位置增加c
            diff[r + 1] -= c;        // 在结束位置之后减少c
        }
        
        // 通过计算差分数组的前缀和得到最终数组
        int[] result = new int[n];
        result[0] = diff[1];
        for (int i = 1; i < n; i++) {
            result[i] = result[i - 1] + diff[i + 1];
        }
        
        return result;
    }

    /**
     * 主函数，处理输入并输出结果
     * 
     * 时间复杂度: O(n + m) - 需要遍历所有操作和数组一次
     * 空间复杂度: O(n) - 需要额外的差分数组空间
     * 
     * 工程化考量:
     * 1. 输入处理: 使用高效的输入处理方式
     * 2. 边界处理: 确保数组索引正确
     * 3. 性能优化: 使用差分数组避免重复计算
     * 4. 输出格式: 按照题目要求输出结果
     */
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        
        int n = scanner.nextInt();
        int m = scanner.nextInt();
        
        int[] arr = new int[n];
        for (int i = 0; i < n; i++) {
            arr[i] = scanner.nextInt();
        }
        
        int[][] operations = new int[m][3];
        for (int i = 0; i < m; i++) {
            operations[i][0] = scanner.nextInt();
            operations[i][1] = scanner.nextInt();
            operations[i][2] = scanner.nextInt();
        }
        
        int[] result = processDifference(n, m, arr, operations);
        
        // 输出结果
        for (int i = 0; i < n; i++) {
            System.out.print(result[i]);
            if (i < n - 1) {
                System.out.print(" ");
            }
        }
        System.out.println();
        
        scanner.close();
    }
}

===============================================

文件: Code27_NowCoderTemplateDifference.py
===============================================
"""
牛客网 【模板】差分

题目描述:
对于给定的长度为n的数组，我们有m次修改操作，
每一次操作给出三个参数l, r, c，代表将数组中的元素[l, r]都加上c。
请你输出全部操作完成后的数组。

输入描述:
第一行输入两个整数n, m代表数组中的元素数量、操作次数。
第二行输入n个整数代表初始数组。
此后m行，每行输入三个整数l, r, c代表一次操作。

输出描述:
在一行上输出n个整数，代表最终的数组。

数据范围:
1 ≤ n, m ≤ 100000
-1000 ≤ 数组元素 ≤ 1000
1 ≤ l ≤ r ≤ n
-1000 ≤ c ≤ 1000

解题思路:
使用差分数组技巧来优化区间更新操作。
1. 创建一个差分数组diff，大小为n+2（处理边界情况）
2. 对于每个操作[l, r, c]，执行diff[l] += c和diff[r+1] -= c
3. 对差分数组计算前缀和，得到最终数组

时间复杂度: O(n + m) - 需要遍历所有操作和数组一次
空间复杂度: O(n) - 需要额外的差分数组空间

这是最优解，因为需要处理所有操作，使用差分数组将区间更新操作从O(n)优化到O(1)。
"""


def process_difference(n, m, arr, operations):
    """
    处理差分数组操作
    
    Args:
        n: 数组长度
        m: 操作数量
        arr: 初始数组
        operations: 操作数组，每个操作包含[起始索引, 结束索引, 增加值]
        
    Returns:
        最终数组
        
    时间复杂度: O(n + m) - 需要遍历所有操作和数组一次
    空间复杂度: O(n) - 需要额外的差分数组空间
    
    工程化考量:
    1. 边界处理: 使用大小为n+2的数组避免索引越界
    2. 异常处理: 可以添加输入参数验证
    3. 性能优化: 差分数组将区间更新操作从O(n)优化到O(1)
    4. 可读性: 变量命名清晰，注释详细
    """
    # 创建差分数组，大小为 n+2 是为了处理边界情况
    diff = [0] * (n + 2)
    
    # 构造初始数组的差分数组
    diff[1] = arr[0]
    for i in range(2, n + 1):
        diff[i] = arr[i - 1] - arr[i - 2]
    
    # 处理每个操作
    for operation in operations:
        l = operation[0]    # 起始索引（1-based）
        r = operation[1]    # 结束索引（1-based）
        c = operation[2]    # 增加值
        
        # 在差分数组中标记区间更新
        diff[l] += c            # 在起始位置增加c
        diff[r + 1] -= c        # 在结束位置之后减少c
    
    # 通过计算差分数组的前缀和得到最终数组
    result = [0] * n
    result[0] = diff[1]
    for i in range(1, n):
        result[i] = result[i - 1] + diff[i + 1]
    
    return result


def main():
    """
    主函数，处理输入并输出结果
    
    时间复杂度: O(n + m) - 需要遍历所有操作和数组一次
    空间复杂度: O(n) - 需要额外的差分数组空间
    
    工程化考量:
    1. 输入处理: 使用高效的输入处理方式
    2. 边界处理: 确保数组索引正确
    3. 性能优化: 使用差分数组避免重复计算
    4. 输出格式: 按照题目要求输出结果
    """
    # 读取输入
    n, m = map(int, input().split())
    
    arr = list(map(int, input().split()))
    
    operations = []
    for _ in range(m):
        l, r, c = map(int, input().split())
        operations.append([l, r, c])
    
    result = process_difference(n, m, arr, operations)
    
    # 输出结果
    print(' '.join(map(str, result)))


if __name__ == "__main__":
    main()

===============================================

