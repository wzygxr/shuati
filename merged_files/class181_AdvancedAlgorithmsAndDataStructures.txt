===============================================
文件夹: class181_AdvancedAlgorithmsAndDataStructures
===============================================

[Markdown 文件]
===============================================
文件: README.md
===============================================
# 高级算法与数据结构扩展项目

## 项目概述

本项目专注于8个核心高级算法与数据结构的深入学习和实践，每个算法都提供了Java、C++、Python三种语言的完整实现，包含详细的注释、复杂度分析、边界处理、异常场景和工程化考量。

## 算法模块概览

### 1. 平面分治算法（最近点对问题）
**核心思想**：通过分治策略在平面点集中找到距离最近的两个点

**相关题目**：
- LeetCode 612 - 平面内最短距离
- LeetCode 973 - 距离原点最近的K个点
- LeetCode 149 - 同一直线上的最大点数
- LeetCode 1584 - 连接所有点的最小费用
- Codeforces 1042D - Petya and Array
- Codeforces 1681D - Required Length

**时间复杂度**：O(n log n)
**空间复杂度**：O(n)

### 2. 棋盘模拟（生命游戏）
**核心思想**：基于细胞自动机规则的二维网格演化系统

**相关题目**：
- LeetCode 289 - 生命游戏
- LeetCode 1829 - 每个查询的最大异或值

**时间复杂度**：O(m × n)
**空间复杂度**：O(1) 原地修改

### 3. 间隔打表（稀疏表）
**核心思想**：预处理数据支持快速区间查询的静态数据结构

**相关题目**：
- LeetCode 315 - 计算右侧小于当前元素的个数
- LeetCode 239 - 滑动窗口最大值

**时间复杂度**：构建O(n log n)，查询O(1)
**空间复杂度**：O(n log n)

### 4. 事件排序（时间扫描）
**核心思想**：按时间顺序处理事件，解决区间重叠问题

**相关题目**：
- LeetCode 56 - 合并区间
- LeetCode 253 - 会议室II
- LeetCode 759 - 员工空闲时间

**时间复杂度**：O(n log n)
**空间复杂度**：O(n)

### 5. 差分驱动模拟（差分数组）
**核心思想**：通过差分数组高效处理区间更新操作

**相关题目**：
- LeetCode 370 - 区间加法
- LeetCode 1094 - 拼车

**时间复杂度**：O(n + k)，k为操作次数
**空间复杂度**：O(n)

### 6. 双向循环链表
**核心思想**：支持双向遍历和循环访问的链表结构

**相关题目**：
- LeetCode 146 - LRU缓存机制

**时间复杂度**：插入/删除O(1)，查找O(n)
**空间复杂度**：O(n)

### 7. 斐波那契堆
**核心思想**：支持快速合并和降键操作的高级优先队列

**相关题目**：
- LeetCode 743 - 网络延迟时间
- LeetCode 1584 - 连接所有点的最小费用

**时间复杂度**：插入O(1)，删除最小O(log n)
**空间复杂度**：O(n)

### 8. 块状链表
**核心思想**：将链表分块存储，平衡查询和修改效率

**相关题目**：
- LeetCode 706 - 设计哈希映射

**时间复杂度**：查询O(√n)，修改O(√n)
**空间复杂度**：O(n)

## 工程化考量

### 1. 异常处理
- 空输入检查
- 边界值验证
- 溢出检测
- 非法参数抛出

### 2. 性能优化
- 避免冗余计算
- 空间复杂度优化
- 缓存友好设计
- 常数项优化

### 3. 测试覆盖
- 单元测试用例
- 边界场景测试
- 性能压力测试
- 跨语言一致性验证

### 4. 代码质量
- 清晰的变量命名
- 详细的注释说明
- 模块化设计
- 可复用组件

## 学习路径建议

1. **基础理解**：先掌握每个算法的核心思想和数学原理
2. **代码实现**：阅读并理解三种语言的实现差异
3. **题目练习**：完成相关题目的独立实现
4. **性能分析**：分析时间空间复杂度，理解优化策略
5. **工程应用**：思考在实际项目中的应用场景

## 跨语言特性对比

| 特性 | Java | C++ | Python |
|------|------|-----|--------|
| 内存管理 | 自动GC | 手动管理 | 自动GC |
| 性能特点 | 稳定均衡 | 高效快速 | 开发便捷 |
| 异常处理 | try-catch | try-catch | try-except |
| 标准库 | 丰富完善 | STL强大 | 简洁易用 |

## 常见问题排查

### 编译错误
- 检查语法规范
- 验证依赖导入
- 确认平台兼容性

### 运行时错误
- 边界值检查
- 空指针检测
- 数组越界验证

### 性能问题
- 分析时间复杂度
- 优化空间使用
- 减少常数项开销

## 扩展学习资源

- 《算法导论》
- 《数据结构与算法分析》
- LeetCode官方题解
- 各大OJ平台题目

## 贡献指南

欢迎提交新的算法实现、题目解答或优化建议。请确保：
1. 代码风格统一
2. 注释详细清晰
3. 测试用例完整
4. 性能分析准确

---

*本项目持续更新中，致力于提供最全面的高级算法学习资源*

===============================================

[代码文件]
===============================================
文件: AdvancedDataStructures.java
===============================================
package class185;

import java.util.*;

/**
 * 高级数据结构实现 - Java版本
 * 包含：
 * 1. 斐波那契堆 (Fibonacci Heap)
 * 2. 块状链表 (Block Linked List / Unrolled Linked List)
 * 
 * 算法复杂度分析：
 * - 斐波那契堆：
 *   - insert: O(1) 均摊时间复杂度
 *   - extractMin: O(log n) 均摊时间复杂度
 *   - decreaseKey: O(1) 均摊时间复杂度
 *   - delete: O(log n) 均摊时间复杂度
 *   - merge: O(1) 时间复杂度
 * 
 * - 块状链表：
 *   - insert/delete: O(n/b) 均摊时间复杂度，其中b是块大小
 *   - get/set: O(n/b) 时间复杂度
 *   - 空间复杂度：O(n)
 */
public class AdvancedDataStructures {
    
    // ================================
    // 1. 斐波那契堆 (Fibonacci Heap)
    // ================================
    
    /**
     * 斐波那契堆节点类
     */
    public static class FibonacciHeapNode<T> {
        T key;                 // 节点键值
        double priority;       // 优先级（用于排序）
        int degree;            // 节点的度数（子节点数量）
        boolean marked;        // 是否被标记（用于级联剪枝）
        FibonacciHeapNode<T> parent;      // 父节点
        FibonacciHeapNode<T> child;       // 第一个子节点
        FibonacciHeapNode<T> left;        // 左侧兄弟节点
        FibonacciHeapNode<T> right;       // 右侧兄弟节点
        
        /**
         * 构造函数
         * @param key 节点键值
         * @param priority 节点优先级
         */
        public FibonacciHeapNode(T key, double priority) {
            this.key = key;
            this.priority = priority;
            this.degree = 0;
            this.marked = false;
            this.parent = null;
            this.child = null;
            // 初始化为自环双向链表
            this.left = this;
            this.right = this;
        }
    }
    
    /**
     * 斐波那契堆实现
     * 支持高效的优先队列操作
     */
    public static class FibonacciHeap<T> {
        private FibonacciHeapNode<T> minNode;  // 指向最小节点
        private int size;                      // 堆中节点数量
        
        /**
         * 构造空堆
         */
        public FibonacciHeap() {
            this.minNode = null;
            this.size = 0;
        }
        
        /**
         * 检查堆是否为空
         * @return 堆是否为空
         */
        public boolean isEmpty() {
            return minNode == null;
        }
        
        /**
         * 获取堆中元素数量
         * @return 元素数量
         */
        public int size() {
            return size;
        }
        
        /**
         * 插入新节点到堆中
         * 时间复杂度：O(1) 均摊
         * @param key 节点键值
         * @param priority 节点优先级
         * @return 新插入的节点
         */
        public FibonacciHeapNode<T> insert(T key, double priority) {
            FibonacciHeapNode<T> newNode = new FibonacciHeapNode<>(key, priority);
            
            // 将新节点添加到根链表
            if (minNode == null) {
                // 空堆情况
                minNode = newNode;
            } else {
                // 将新节点插入到根链表的minNode旁边
                linkRootList(newNode, minNode);
                
                // 更新最小节点
                if (newNode.priority < minNode.priority) {
                    minNode = newNode;
                }
            }
            
            // 增加节点计数
            size++;
            return newNode;
        }
        
        /**
         * 合并两个斐波那契堆
         * 时间复杂度：O(1)
         * @param other 要合并的另一个堆
         */
        public void merge(FibonacciHeap<T> other) {
            if (other == null || other.isEmpty()) {
                return;  // 空堆无需合并
            }
            
            if (this.isEmpty()) {
                // 如果当前堆为空，直接接管other的minNode
                this.minNode = other.minNode;
                this.size = other.size;
                return;
            }
            
            // 合并两个根链表
            FibonacciHeapNode<T> thisRight = this.minNode.right;
            FibonacciHeapNode<T> otherLeft = other.minNode.left;
            
            this.minNode.right = other.minNode;
            other.minNode.left = this.minNode;
            
            thisRight.left = otherLeft;
            otherLeft.right = thisRight;
            
            // 更新最小节点
            if (other.minNode.priority < this.minNode.priority) {
                this.minNode = other.minNode;
            }
            
            // 更新节点数量
            this.size += other.size;
            
            // 重置other堆，避免悬空引用
            other.minNode = null;
            other.size = 0;
        }
        
        /**
         * 提取堆中的最小节点
         * 时间复杂度：O(log n) 均摊
         * @return 最小节点的键值，如果堆为空返回null
         */
        public T extractMin() {
            if (isEmpty()) {
                return null;
            }
            
            FibonacciHeapNode<T> min = minNode;
            
            // 将min的所有子节点提升到根链表
            if (min.child != null) {
                FibonacciHeapNode<T> child = min.child;
                do {
                    FibonacciHeapNode<T> nextChild = child.right;
                    
                    // 从子链表中移除child
                    removeFromChildList(child);
                    
                    // 添加到根链表
                    child.parent = null;
                    linkRootList(child, minNode);
                    
                    child = nextChild;
                } while (child != min.child);
                
                // 清除min的子节点引用
                min.child = null;
            }
            
            // 从根链表中移除min
            if (min.right == min) {
                // 根链表中只有一个节点
                minNode = null;
            } else {
                // 更新根链表
                minNode = min.right;  // 暂时将min的右侧设为新的minNode
                removeFromRootList(min);
                
                // 合并相同度数的树
                consolidate();
            }
            
            // 减少节点计数
            size--;
            
            return min.key;
        }
        
        /**
         * 减小节点的优先级
         * 时间复杂度：O(1) 均摊
         * @param node 要修改的节点
         * @param newPriority 新的优先级
         * @throws IllegalArgumentException 如果新优先级大于当前优先级
         */
        public void decreaseKey(FibonacciHeapNode<T> node, double newPriority) {
            if (newPriority > node.priority) {
                throw new IllegalArgumentException("New priority cannot be greater than current priority");
            }
            
            node.priority = newPriority;
            FibonacciHeapNode<T> parent = node.parent;
            
            // 如果节点在根链表中，或者父节点的优先级不大于当前节点，无需其他操作
            if (parent == null || parent.priority <= node.priority) {
                // 如果是根链表中的节点且优先级比当前minNode小，更新minNode
                if (parent == null && node.priority < minNode.priority) {
                    minNode = node;
                }
                return;
            }
            
            // 否则，需要进行级联剪枝操作
            cut(node, parent);
            cascadingCut(parent);
        }
        
        /**
         * 删除指定节点
         * 时间复杂度：O(log n) 均摊
         * @param node 要删除的节点
         */
        public void delete(FibonacciHeapNode<T> node) {
            // 将节点优先级设置为负无穷，使其成为新的最小节点
            decreaseKey(node, Double.NEGATIVE_INFINITY);
            
            // 提取最小节点（即刚刚被设置为负无穷的节点）
            extractMin();
        }
        
        /**
         * 获取最小节点（不移除）
         * 时间复杂度：O(1)
         * @return 最小节点的键值，如果堆为空返回null
         */
        public T getMin() {
            return isEmpty() ? null : minNode.key;
        }
        
        // ==================== 辅助方法 ====================
        
        /**
         * 将节点链接到根链表
         */
        private void linkRootList(FibonacciHeapNode<T> node, FibonacciHeapNode<T> root) {
            // 在根和根的右侧节点之间插入node
            node.right = root.right;
            node.left = root;
            root.right.left = node;
            root.right = node;
        }
        
        /**
         * 从根链表中移除节点
         */
        private void removeFromRootList(FibonacciHeapNode<T> node) {
            node.left.right = node.right;
            node.right.left = node.left;
        }
        
        /**
         * 从子链表中移除节点
         */
        private void removeFromChildList(FibonacciHeapNode<T> node) {
            if (node.parent.child == node) {
                // 如果是父节点的第一个子节点，更新父节点的child指针
                if (node.right != node) {
                    node.parent.child = node.right;
                } else {
                    node.parent.child = null;
                }
            }
            
            // 更新子链表中的双向链接
            node.left.right = node.right;
            node.right.left = node.left;
        }
        
        /**
         * 将一个节点作为另一个节点的子节点
         */
        private void linkAsChild(FibonacciHeapNode<T> child, FibonacciHeapNode<T> parent) {
            // 从根链表中移除child
            removeFromRootList(child);
            
            // 重置child的状态
            child.parent = parent;
            child.marked = false;
            
            // 将child添加到parent的子链表中
            if (parent.child == null) {
                // parent没有子节点
                parent.child = child;
                child.left = child;
                child.right = child;
            } else {
                // 将child插入到parent的第一个子节点旁边
                child.right = parent.child.right;
                child.left = parent.child;
                parent.child.right.left = child;
                parent.child.right = child;
            }
            
            // 增加parent的度数
            parent.degree++;
        }
        
        /**
         * 合并相同度数的树
         */
        private void consolidate() {
            // 计算最大可能的度数，理论上不会超过log_phi(n)，其中phi是黄金分割比
            int maxDegree = (int) Math.floor(Math.log(size) / Math.log((1 + Math.sqrt(5)) / 2)) + 1;
            
            // 用于存储不同度数的根节点
            @SuppressWarnings("unchecked")
            FibonacciHeapNode<T>[] degreeTable = new FibonacciHeapNode[maxDegree];
            
            // 遍历所有根节点
            FibonacciHeapNode<T> start = minNode;
            FibonacciHeapNode<T> current = start;
            boolean isVisited;
            
            do {
                isVisited = false;
                int degree = current.degree;
                FibonacciHeapNode<T> next = current.right;
                
                // 合并相同度数的树
                while (degreeTable[degree] != null) {
                    FibonacciHeapNode<T> other = degreeTable[degree];
                    
                    // 确保current的优先级不大于other
                    if (current.priority > other.priority) {
                        FibonacciHeapNode<T> temp = current;
                        current = other;
                        other = temp;
                    }
                    
                    // 将other作为current的子节点
                    linkAsChild(other, current);
                    
                    // 清除度数表中的条目
                    degreeTable[degree] = null;
                    degree++;
                }
                
                // 记录当前度数的根节点
                degreeTable[degree] = current;
                
                // 移动到下一个根节点
                current = next;
                
                // 检查是否已经遍历完所有根节点
                if (current == start) {
                    isVisited = true;
                }
            } while (!isVisited);
            
            // 重建根链表并找到新的最小节点
            minNode = null;
            
            for (int i = 0; i < maxDegree; i++) {
                if (degreeTable[i] != null) {
                    // 初始化根链表
                    if (minNode == null) {
                        minNode = degreeTable[i];
                        minNode.left = minNode;
                        minNode.right = minNode;
                    } else {
                        // 将节点添加到根链表
                        linkRootList(degreeTable[i], minNode);
                        
                        // 更新最小节点
                        if (degreeTable[i].priority < minNode.priority) {
                            minNode = degreeTable[i];
                        }
                    }
                }
            }
        }
        
        /**
         * 剪切操作：将节点从父节点的子树中移除并添加到根链表
         */
        private void cut(FibonacciHeapNode<T> node, FibonacciHeapNode<T> parent) {
            // 从父节点的子链表中移除node
            removeFromChildList(node);
            
            // 减少父节点的度数
            parent.degree--;
            
            // 将node添加到根链表
            node.parent = null;
            node.marked = false;
            linkRootList(node, minNode);
        }
        
        /**
         * 级联剪切操作
         */
        private void cascadingCut(FibonacciHeapNode<T> node) {
            FibonacciHeapNode<T> parent = node.parent;
            
            if (parent != null) {
                if (!node.marked) {
                    // 如果节点未被标记，标记它
                    node.marked = true;
                } else {
                    // 如果节点已被标记，进行剪切并继续级联
                    cut(node, parent);
                    cascadingCut(parent);
                }
            }
        }
        
        /**
         * 打印堆的结构（用于调试）
         */
        public void printHeap() {
            if (isEmpty()) {
                System.out.println("Heap is empty");
                return;
            }
            
            System.out.println("Fibonacci Heap Structure:");
            Set<FibonacciHeapNode<T>> visited = new HashSet<>();
            printNode(minNode, 0, visited);
        }
        
        /**
         * 递归打印节点及其子节点
         */
        private void printNode(FibonacciHeapNode<T> node, int level, Set<FibonacciHeapNode<T>> visited) {
            if (node == null || visited.contains(node)) {
                return;
            }
            
            visited.add(node);
            
            // 打印缩进
            for (int i = 0; i < level; i++) {
                System.out.print("  ");
            }
            
            // 打印节点信息
            System.out.println("Key: " + node.key + ", Priority: " + node.priority + ", Degree: " + node.degree + ", Marked: " + node.marked);
            
            // 递归打印子节点
            if (node.child != null) {
                FibonacciHeapNode<T> child = node.child;
                do {
                    printNode(child, level + 1, visited);
                    child = child.right;
                } while (child != node.child && !visited.contains(child));
            }
            
            // 递归打印根链表中的下一个节点
            FibonacciHeapNode<T> next = node.right;
            if (next != minNode && !visited.contains(next)) {
                printNode(next, level, visited);
            }
        }
    }
    
    // ================================
    // 2. 块状链表 (Unrolled Linked List)
    // ================================
    
    /**
     * 块状链表的块类
     */
    public static class Block<T> {
        private T[] array;      // 块内的数组
        private int size;       // 当前块中元素的数量
        private Block<T> next;  // 指向下一个块
        private Block<T> prev;  // 指向上一个块
        private final int capacity;  // 块的最大容量
        
        /**
         * 构造函数
         * @param capacity 块的最大容量
         */
        @SuppressWarnings("unchecked")
        public Block(int capacity) {
            this.capacity = capacity;
            this.array = (T[]) new Object[capacity];
            this.size = 0;
            this.next = null;
            this.prev = null;
        }
        
        /**
         * 检查块是否已满
         * @return 块是否已满
         */
        public boolean isFull() {
            return size == capacity;
        }
        
        /**
         * 检查块是否为空
         * @return 块是否为空
         */
        public boolean isEmpty() {
            return size == 0;
        }
        
        /**
         * 获取块的大小
         * @return 块中元素的数量
         */
        public int size() {
            return size;
        }
        
        /**
         * 获取块的容量
         * @return 块的最大容量
         */
        public int capacity() {
            return capacity;
        }
        
        /**
         * 在块的末尾添加元素
         * @param value 要添加的值
         * @throws IllegalStateException 如果块已满
         */
        public void add(T value) {
            if (isFull()) {
                throw new IllegalStateException("Block is full");
            }
            array[size++] = value;
        }
        
        /**
         * 在指定位置插入元素
         * @param index 插入位置
         * @param value 要插入的值
         * @throws IndexOutOfBoundsException 如果索引无效
         * @throws IllegalStateException 如果块已满
         */
        public void insert(int index, T value) {
            if (isFull()) {
                throw new IllegalStateException("Block is full");
            }
            
            if (index < 0 || index > size) {
                throw new IndexOutOfBoundsException("Index out of bounds: " + index);
            }
            
            // 移动元素为新元素腾出空间
            System.arraycopy(array, index, array, index + 1, size - index);
            array[index] = value;
            size++;
        }
        
        /**
         * 删除指定位置的元素
         * @param index 要删除的元素位置
         * @return 被删除的元素
         * @throws IndexOutOfBoundsException 如果索引无效
         */
        public T delete(int index) {
            if (index < 0 || index >= size) {
                throw new IndexOutOfBoundsException("Index out of bounds: " + index);
            }
            
            T value = array[index];
            
            // 移动元素覆盖被删除的元素
            System.arraycopy(array, index + 1, array, index, size - index - 1);
            array[--size] = null;  // 清除引用，便于GC
            
            return value;
        }
        
        /**
         * 获取指定位置的元素
         * @param index 元素位置
         * @return 元素值
         * @throws IndexOutOfBoundsException 如果索引无效
         */
        public T get(int index) {
            if (index < 0 || index >= size) {
                throw new IndexOutOfBoundsException("Index out of bounds: " + index);
            }
            return array[index];
        }
        
        /**
         * 设置指定位置的元素值
         * @param index 元素位置
         * @param value 新的元素值
         * @return 原来的元素值
         * @throws IndexOutOfBoundsException 如果索引无效
         */
        public T set(int index, T value) {
            if (index < 0 || index >= size) {
                throw new IndexOutOfBoundsException("Index out of bounds: " + index);
            }
            
            T oldValue = array[index];
            array[index] = value;
            return oldValue;
        }
        
        /**
         * 分割块
         * 将当前块从指定位置分割，返回包含后半部分元素的新块
         * @param splitIndex 分割位置
         * @return 包含后半部分元素的新块
         * @throws IndexOutOfBoundsException 如果分割位置无效
         */
        public Block<T> split(int splitIndex) {
            if (splitIndex < 0 || splitIndex > size) {
                throw new IndexOutOfBoundsException("Split index out of bounds: " + splitIndex);
            }
            
            // 创建新块
            Block<T> newBlock = new Block<>(capacity);
            
            // 复制后半部分元素到新块
            int elementsToMove = size - splitIndex;
            for (int i = 0; i < elementsToMove; i++) {
                newBlock.array[i] = array[splitIndex + i];
                array[splitIndex + i] = null;  // 清除引用
            }
            
            // 更新块大小
            newBlock.size = elementsToMove;
            this.size = splitIndex;
            
            // 建立双向链接
            newBlock.next = this.next;
            if (this.next != null) {
                this.next.prev = newBlock;
            }
            this.next = newBlock;
            newBlock.prev = this;
            
            return newBlock;
        }
        
        /**
         * 合并两个相邻块
         * 假设当前块和next块是相邻的
         * @return 合并后的块（即当前块）
         * @throws IllegalStateException 如果没有下一个块或合并后超出容量
         */
        public Block<T> mergeNext() {
            if (next == null) {
                throw new IllegalStateException("No next block to merge");
            }
            
            if (this.size + next.size > this.capacity) {
                throw new IllegalStateException("Merged size exceeds block capacity");
            }
            
            // 复制next块的元素到当前块
            System.arraycopy(next.array, 0, this.array, this.size, next.size);
            this.size += next.size;
            
            // 更新链接，跳过next块
            Block<T> nextNext = next.next;
            this.next = nextNext;
            if (nextNext != null) {
                nextNext.prev = this;
            }
            
            return this;
        }
    }
    
    /**
     * 块状链表实现
     * 使用块存储元素，优化内存使用和遍历性能
     */
    public static class UnrolledLinkedList<T> {
        private Block<T> head;  // 头块指针
        private Block<T> tail;  // 尾块指针
        private int size;       // 链表元素总数
        private final int blockCapacity;  // 块的最大容量
        
        /**
         * 构造函数，使用默认块容量（通常为sqrt(n)，这里使用16作为示例）
         */
        public UnrolledLinkedList() {
            this(16);  // 默认块容量为16
        }
        
        /**
         * 构造函数
         * @param blockCapacity 块的最大容量
         * @throws IllegalArgumentException 如果块容量小于2
         */
        public UnrolledLinkedList(int blockCapacity) {
            if (blockCapacity < 2) {
                throw new IllegalArgumentException("Block capacity must be at least 2");
            }
            
            this.blockCapacity = blockCapacity;
            this.head = null;
            this.tail = null;
            this.size = 0;
        }
        
        /**
         * 检查链表是否为空
         * @return 链表是否为空
         */
        public boolean isEmpty() {
            return size == 0;
        }
        
        /**
         * 获取链表中元素的数量
         * @return 元素数量
         */
        public int size() {
            return size;
        }
        
        /**
         * 在链表末尾添加元素
         * 时间复杂度：O(n/b) 均摊，其中b是块容量
         * @param value 要添加的值
         */
        public void add(T value) {
            if (isEmpty()) {
                // 空链表，创建第一个块
                head = new Block<>(blockCapacity);
                tail = head;
                head.add(value);
            } else {
                // 非空链表，检查尾块是否已满
                if (tail.isFull()) {
                    // 尾块已满，分割为两个半满的块
                    tail.split(tail.size() / 2);
                    tail = tail.next;  // 更新尾块指针
                }
                tail.add(value);
            }
            size++;
        }
        
        /**
         * 在指定位置插入元素
         * 时间复杂度：O(n/b)
         * @param index 插入位置
         * @param value 要插入的值
         * @throws IndexOutOfBoundsException 如果索引无效
         */
        public void insert(int index, T value) {
            if (index < 0 || index > size) {
                throw new IndexOutOfBoundsException("Index out of bounds: " + index);
            }
            
            if (index == size) {
                // 在末尾插入，调用add方法
                add(value);
                return;
            }
            
            if (isEmpty()) {
                // 空链表，创建第一个块
                head = new Block<>(blockCapacity);
                tail = head;
                head.add(value);
            } else {
                // 定位到包含插入位置的块和块内索引
                BlockPosition<T> pos = findBlockAndIndex(index);
                Block<T> block = pos.block;
                int blockIndex = pos.index;
                
                // 检查块是否已满
                if (block.isFull()) {
                    // 块已满，分割为两个半满的块
                    int splitIndex = block.size() / 2;
                    Block<T> newBlock = block.split(splitIndex);
                    
                    // 调整插入位置
                    if (blockIndex >= splitIndex) {
                        block = newBlock;
                        blockIndex -= splitIndex;
                    }
                }
                
                // 在块中插入元素
                block.insert(blockIndex, value);
                
                // 更新尾块指针（如果需要）
                Block<T> lastBlock = head;
                while (lastBlock.next != null) {
                    lastBlock = lastBlock.next;
                }
                tail = lastBlock;
            }
            
            size++;
        }
        
        /**
         * 删除指定位置的元素
         * 时间复杂度：O(n/b)
         * @param index 要删除的元素位置
         * @return 被删除的元素
         * @throws IndexOutOfBoundsException 如果索引无效
         */
        public T delete(int index) {
            if (isEmpty()) {
                throw new IllegalStateException("Cannot delete from empty list");
            }
            
            if (index < 0 || index >= size) {
                throw new IndexOutOfBoundsException("Index out of bounds: " + index);
            }
            
            // 定位到包含删除位置的块和块内索引
            BlockPosition<T> pos = findBlockAndIndex(index);
            Block<T> block = pos.block;
            int blockIndex = pos.index;
            
            // 保存要删除的元素值
            T value = block.delete(blockIndex);
            
            // 如果删除后块的大小过小，尝试与相邻块合并（保持块的大小在合理范围）
            if (block.size() < blockCapacity / 4 && block != head || 
                block.isEmpty() && size > 0) {  // 特殊处理空块
                
                // 优先与前一个块合并
                if (block.prev != null) {
                    Block<T> prevBlock = block.prev;
                    // 确保合并后不会超出容量
                    if (prevBlock.size() + block.size() <= blockCapacity) {
                        // 将要删除的索引调整为前一个块的末尾
                        if (block == tail) {
                            tail = prevBlock;
                        }
                        prevBlock.mergeNext();
                        // 如果当前删除的块是head，更新head指针
                        if (block == head) {
                            head = prevBlock;
                        }
                    }
                } 
                // 否则与后一个块合并
                else if (block.next != null) {
                    Block<T> nextBlock = block.next;
                    if (block.size() + nextBlock.size() <= blockCapacity) {
                        if (nextBlock == tail) {
                            tail = block;
                        }
                        block.mergeNext();
                    }
                }
                // 特殊情况：只剩一个空块
                else if (block.isEmpty()) {
                    head = null;
                    tail = null;
                }
            }
            
            size--;
            return value;
        }
        
        /**
         * 获取指定位置的元素
         * 时间复杂度：O(n/b)
         * @param index 元素位置
         * @return 元素值
         * @throws IndexOutOfBoundsException 如果索引无效
         */
        public T get(int index) {
            if (isEmpty()) {
                throw new IllegalStateException("List is empty");
            }
            
            if (index < 0 || index >= size) {
                throw new IndexOutOfBoundsException("Index out of bounds: " + index);
            }
            
            BlockPosition<T> pos = findBlockAndIndex(index);
            return pos.block.get(pos.index);
        }
        
        /**
         * 设置指定位置的元素值
         * 时间复杂度：O(n/b)
         * @param index 元素位置
         * @param value 新的元素值
         * @return 原来的元素值
         * @throws IndexOutOfBoundsException 如果索引无效
         */
        public T set(int index, T value) {
            if (isEmpty()) {
                throw new IllegalStateException("List is empty");
            }
            
            if (index < 0 || index >= size) {
                throw new IndexOutOfBoundsException("Index out of bounds: " + index);
            }
            
            BlockPosition<T> pos = findBlockAndIndex(index);
            return pos.block.set(pos.index, value);
        }
        
        /**
         * 清空链表
         * 时间复杂度：O(n)
         */
        public void clear() {
            head = null;
            tail = null;
            size = 0;
        }
        
        /**
         * 将链表内容转换为数组
         * 时间复杂度：O(n)
         * @return 包含链表所有元素的数组
         */
        @SuppressWarnings("unchecked")
        public T[] toArray() {
            if (isEmpty()) {
                return (T[]) new Object[0];
            }
            
            T[] result = (T[]) new Object[size];
            int index = 0;
            Block<T> current = head;
            
            while (current != null) {
                for (int i = 0; i < current.size(); i++) {
                    result[index++] = current.get(i);
                }
                current = current.next;
            }
            
            return result;
        }
        
        /**
         * 查找第一个出现的指定值的索引
         * 时间复杂度：O(n)
         * @param value 要查找的值
         * @return 元素索引，如果未找到返回-1
         */
        public int indexOf(T value) {
            if (isEmpty()) {
                return -1;
            }
            
            int index = 0;
            Block<T> current = head;
            
            while (current != null) {
                for (int i = 0; i < current.size(); i++) {
                    if (Objects.equals(current.get(i), value)) {
                        return index + i;
                    }
                }
                index += current.size();
                current = current.next;
            }
            
            return -1;
        }
        
        /**
         * 查找最后一个出现的指定值的索引
         * 时间复杂度：O(n)
         * @param value 要查找的值
         * @return 元素索引，如果未找到返回-1
         */
        public int lastIndexOf(T value) {
            if (isEmpty()) {
                return -1;
            }
            
            int index = size - 1;
            Block<T> current = tail;
            int currentBlockSize = current.size();
            
            while (current != null) {
                for (int i = currentBlockSize - 1; i >= 0; i--) {
                    if (Objects.equals(current.get(i), value)) {
                        return index - (currentBlockSize - 1 - i);
                    }
                }
                
                index -= currentBlockSize;
                current = current.prev;
                currentBlockSize = (current != null) ? current.size() : 0;
            }
            
            return -1;
        }
        
        /**
         * 检查链表是否包含指定值
         * 时间复杂度：O(n)
         * @param value 要检查的值
         * @return 是否包含该值
         */
        public boolean contains(T value) {
            return indexOf(value) != -1;
        }
        
        /**
         * 范围查询：获取从start到end（不包含）的子列表
         * 时间复杂度：O(n/b + k)，其中k是子列表的大小
         * @param start 起始索引（包含）
         * @param end 结束索引（不包含）
         * @return 子列表
         * @throws IndexOutOfBoundsException 如果索引无效
         */
        public UnrolledLinkedList<T> subList(int start, int end) {
            if (start < 0 || end > size || start > end) {
                throw new IndexOutOfBoundsException("Invalid range: [" + start + ", " + end + ")");
            }
            
            UnrolledLinkedList<T> sublist = new UnrolledLinkedList<>(blockCapacity);
            
            if (start == end) {
                return sublist;  // 空的子列表
            }
            
            // 处理跨越多个块的情况
            int currentIndex = start;
            while (currentIndex < end) {
                sublist.add(get(currentIndex));
                currentIndex++;
            }
            
            return sublist;
        }
        
        /**
         * 打印链表内容
         * 时间复杂度：O(n)
         */
        public void printList() {
            if (isEmpty()) {
                System.out.println("List is empty");
                return;
            }
            
            System.out.print("UnrolledLinkedList: [");
            Block<T> current = head;
            boolean firstElement = true;
            
            while (current != null) {
                for (int i = 0; i < current.size(); i++) {
                    if (!firstElement) {
                        System.out.print(", ");
                    } else {
                        firstElement = false;
                    }
                    System.out.print(current.get(i));
                }
                current = current.next;
            }
            
            System.out.println("]");
        }
        
        /**
         * 打印链表的块结构（用于调试）
         */
        public void printBlockStructure() {
            if (isEmpty()) {
                System.out.println("List is empty");
                return;
            }
            
            System.out.println("Block Structure:");
            int blockIndex = 0;
            Block<T> current = head;
            
            while (current != null) {
                System.out.print("Block " + blockIndex + " (size=" + current.size() + "): [");
                
                for (int i = 0; i < current.size(); i++) {
                    System.out.print(current.get(i));
                    if (i < current.size() - 1) {
                        System.out.print(", ");
                    }
                }
                
                System.out.println("]");
                
                current = current.next;
                blockIndex++;
            }
        }
        
        // ==================== 内部辅助类和方法 ====================
        
        /**
         * 存储块指针和块内索引的内部类
         */
        private static class BlockPosition<T> {
            Block<T> block;
            int index;
            
            BlockPosition(Block<T> block, int index) {
                this.block = block;
                this.index = index;
            }
        }
        
        /**
         * 查找包含指定索引的块和块内索引
         * 时间复杂度：O(n/b)
         * @param index 元素索引
         * @return 包含块和块内索引的BlockPosition对象
         */
        private BlockPosition<T> findBlockAndIndex(int index) {
            if (isEmpty() || index < 0 || index >= size) {
                throw new IndexOutOfBoundsException("Index out of bounds: " + index);
            }
            
            // 优化：根据索引位置选择从头还是从尾开始查找
            // 如果索引更靠近头部，从头开始
            if (index < size / 2) {
                Block<T> current = head;
                int currentIndex = 0;
                
                while (current != null) {
                    if (index < currentIndex + current.size()) {
                        // 找到了包含索引的块
                        return new BlockPosition<>(current, index - currentIndex);
                    }
                    currentIndex += current.size();
                    current = current.next;
                }
            } 
            // 否则从尾开始
            else {
                Block<T> current = tail;
                int currentIndex = size - 1;
                int currentBlockSize = current.size();
                
                while (current != null) {
                    if (index >= currentIndex - currentBlockSize + 1) {
                        // 找到了包含索引的块
                        return new BlockPosition<>(current, index - (currentIndex - currentBlockSize + 1));
                    }
                    currentIndex -= currentBlockSize;
                    current = current.prev;
                    currentBlockSize = (current != null) ? current.size() : 0;
                }
            }
            
            // 不应该到达这里
            throw new IndexOutOfBoundsException("Index not found: " + index);
        }
    }
    
    // ================================
    // 主方法 - 测试数据结构
    // ================================
    
    public static void main(String[] args) {
        // 测试斐波那契堆
        testFibonacciHeap();
        
        // 测试块状链表
        testUnrolledLinkedList();
    }
    
    /**
     * 测试斐波那契堆的各种操作
     */
    private static void testFibonacciHeap() {
        System.out.println("=== 测试斐波那契堆 ===");
        FibonacciHeap<String> heap = new FibonacciHeap<>();
        
        // 测试插入操作
        System.out.println("\n1. 测试插入操作:");
        FibonacciHeapNode<String> node1 = heap.insert("Task 1", 5);
        FibonacciHeapNode<String> node2 = heap.insert("Task 2", 3);
        FibonacciHeapNode<String> node3 = heap.insert("Task 3", 8);
        FibonacciHeapNode<String> node4 = heap.insert("Task 4", 1);
        FibonacciHeapNode<String> node5 = heap.insert("Task 5", 10);
        
        System.out.println("插入5个节点后，最小节点: " + heap.getMin());  // 应该是 Task 4
        
        // 测试提取最小节点
        System.out.println("\n2. 测试提取最小节点:");
        String min1 = heap.extractMin();
        System.out.println("提取的最小节点: " + min1);  // 应该是 Task 4
        System.out.println("提取后，最小节点: " + heap.getMin());  // 应该是 Task 2
        
        // 测试减小键值
        System.out.println("\n3. 测试减小键值:");
        heap.decreaseKey(node3, 2);
        System.out.println("减小Task 3的优先级后，最小节点: " + heap.getMin());  // 应该是 Task 3
        
        // 测试删除节点
        System.out.println("\n4. 测试删除节点:");
        heap.delete(node5);
        System.out.println("删除Task 5后，最小节点: " + heap.getMin());  // 仍然是 Task 3
        
        // 测试合并操作
        System.out.println("\n5. 测试合并操作:");
        FibonacciHeap<String> heap2 = new FibonacciHeap<>();
        heap2.insert("Task A", 4);
        heap2.insert("Task B", 6);
        
        heap.merge(heap2);
        System.out.println("合并两个堆后，最小节点: " + heap.getMin());  // 仍然是 Task 3
        System.out.println("堆大小: " + heap.size());  // 应该是 5
        
        // 测试提取所有元素
        System.out.println("\n6. 测试提取所有元素:");
        System.out.print("按优先级提取顺序: ");
        while (!heap.isEmpty()) {
            System.out.print(heap.extractMin() + " ");
        }
        System.out.println();
        
        // 测试边界情况
        System.out.println("\n7. 测试边界情况:");
        System.out.println("空堆获取最小节点: " + heap.getMin());  // 应该是 null
        System.out.println("空堆提取最小节点: " + heap.extractMin());  // 应该是 null
    }
    
    /**
     * 测试块状链表的各种操作
     */
    private static void testUnrolledLinkedList() {
        System.out.println("\n=== 测试块状链表 ===");
        // 使用较小的块容量以便更容易观察块分割和合并
        UnrolledLinkedList<Integer> list = new UnrolledLinkedList<>(4);
        
        // 测试添加操作
        System.out.println("\n1. 测试添加操作:");
        for (int i = 1; i <= 10; i++) {
            list.add(i);
        }
        System.out.println("添加1-10后的列表:");
        list.printList();
        list.printBlockStructure();
        
        // 测试获取和设置
        System.out.println("\n2. 测试获取和设置操作:");
        System.out.println("索引5的值: " + list.get(5));  // 应该是 6
        int oldValue = list.set(5, 100);
        System.out.println("设置索引5的值为100，旧值: " + oldValue);
        System.out.println("索引5的新值: " + list.get(5));  // 应该是 100
        list.printList();
        
        // 测试插入操作
        System.out.println("\n3. 测试插入操作:");
        list.insert(3, 50);  // 在索引3插入50
        System.out.println("在索引3插入50后:");
        list.printList();
        list.printBlockStructure();
        
        list.insert(0, 0);  // 在头部插入0
        System.out.println("在头部插入0后:");
        list.printList();
        
        // 测试删除操作
        System.out.println("\n4. 测试删除操作:");
        int deletedValue = list.delete(5);  // 删除索引5的值
        System.out.println("删除索引5的值: " + deletedValue);
        System.out.println("删除后:");
        list.printList();
        list.printBlockStructure();
        
        list.delete(0);  // 删除头部
        System.out.println("删除头部后:");
        list.printList();
        
        // 测试查找操作
        System.out.println("\n5. 测试查找操作:");
        System.out.println("值为100的索引: " + list.indexOf(100));
        System.out.println("值为99的索引: " + list.indexOf(99));  // 应该是 -1
        System.out.println("列表是否包含50: " + list.contains(50));
        
        // 测试子列表
        System.out.println("\n6. 测试子列表:");
        UnrolledLinkedList<Integer> sublist = list.subList(2, 6);
        System.out.println("子列表[2,6):");
        sublist.printList();
        
        // 测试清空操作
        System.out.println("\n7. 测试清空操作:");
        list.clear();
        System.out.println("清空后:");
        list.printList();
        System.out.println("列表大小: " + list.size());
        
        // 测试边界情况
        System.out.println("\n8. 测试边界情况:");
        try {
            list.get(0);  // 空列表访问
        } catch (Exception e) {
            System.out.println("空列表访问异常: " + e.getMessage());
        }
        
        list.add(1);  // 添加一个元素
        list.add(2);  // 添加第二个元素
        System.out.println("添加两个元素后:");
        list.printList();
        
        list.delete(0);  // 删除第一个元素
        list.delete(0);  // 删除第二个元素
        System.out.println("删除所有元素后:");
        list.printList();
    }
}

===============================================

文件: advanced_data_structures.cpp
===============================================
#include <iostream>
#include <vector>
#include <algorithm>
#include <cmath>
#include <stdexcept>
#include <memory>
#include <limits>
#include <queue>
#include <tuple>
#include <functional>
#include <unordered_set>
#include <functional>

/**
 * C++版本高级数据结构与算法实现
 * 包含：
 * 1. 平面分治 (Closest Pair of Points)
 * 2. 棋盘模拟 (Game of Life)
 * 3. 间隔打表 (Sparse Table)
 * 4. 事件排序 (Time Sweep)
 * 5. 差分驱动模拟 (Difference Array)
 * 6. 双向循环链表 (Doubly Circular Linked List)
 * 7. 斐波那契堆 (Fibonacci Heap)
 * 8. 块状链表 (Unrolled Linked List)
 * 
 * 时间复杂度分析：
 * - 平面分治: O(n log n)
 * - 棋盘模拟: O(m*n)
 * - 间隔打表: O(n log n) 预处理, O(1) 查询
 * - 事件排序: O(n log n)
 * - 差分驱动: O(1) 区间更新, O(n) 获取结果
 * - 双向循环链表: 插入/删除头部/尾部 O(1), 其他 O(n)
 * - 斐波那契堆: 插入 O(1) 均摊, 提取最小 O(log n) 均摊
 * - 块状链表: O(n/b) 操作复杂度，b为块大小
 */

// ================================
// 1. 平面分治 - 最近点对问题
// ================================

struct Point {
    double x, y;
    
    Point(double x = 0, double y = 0) : x(x), y(y) {}
    
    double distanceTo(const Point& other) const {
        double dx = this->x - other.x;
        double dy = this->y - other.y;
        return std::sqrt(dx * dx + dy * dy);
    }
    
    // 按x坐标排序的比较函数
    bool operator<(const Point& other) const {
        return x < other.x;
    }
    
    friend std::ostream& operator<<(std::ostream& os, const Point& p) {
        return os << "Point(" << p.x << ", " << p.y << ")";
    }
};

struct PairDistance {
    double distance;
    Point p1, p2;
    
    PairDistance(double distance = 0, Point p1 = Point(), Point p2 = Point()) 
        : distance(distance), p1(p1), p2(p2) {}
};

// 按y坐标排序的比较函数
bool compareByY(const Point& a, const Point& b) {
    return a.y < b.y;
}

PairDistance bruteForceClosestPair(const std::vector<Point>& points) {
    int n = points.size();
    double minDist = std::numeric_limits<double>::max();
    Point p1, p2;
    
    for (int i = 0; i < n; i++) {
        for (int j = i + 1; j < n; j++) {
            double dist = points[i].distanceTo(points[j]);
            if (dist < minDist) {
                minDist = dist;
                p1 = points[i];
                p2 = points[j];
            }
        }
    }
    
    return PairDistance(minDist, p1, p2);
}

PairDistance stripClosest(std::vector<Point>& strip, PairDistance currentMin) {
    double minDist = currentMin.distance;
    Point p1 = currentMin.p1;
    Point p2 = currentMin.p2;
    
    // 按y坐标排序已经完成
    int size = strip.size();
    
    // 对于带内的每个点，只需要检查后面y坐标相差不超过min_dist的点
    for (int i = 0; i < size; i++) {
        for (int j = i + 1; j < size && (strip[j].y - strip[i].y) < minDist; j++) {
            double dist = strip[i].distanceTo(strip[j]);
            if (dist < minDist) {
                minDist = dist;
                p1 = strip[i];
                p2 = strip[j];
            }
        }
    }
    
    return PairDistance(minDist, p1, p2);
}

PairDistance closestPairRecursive(std::vector<Point>& pointsSortedByX, std::vector<Point>& pointsSortedByY) {
    int n = pointsSortedByX.size();
    
    // 基本情况：小于等于3个点，使用暴力法
    if (n <= 3) {
        return bruteForceClosestPair(pointsSortedByX);
    }
    
    // 分治：将点集分为左右两部分
    int mid = n / 2;
    Point midPoint = pointsSortedByX[mid];
    
    // 分割y排序的点列表
    std::vector<Point> leftPointsY, rightPointsY;
    
    for (const Point& p : pointsSortedByY) {
        if (p.x <= midPoint.x) {
            leftPointsY.push_back(p);
        } else {
            rightPointsY.push_back(p);
        }
    }
    
    // 递归求解左右两部分的最近点对
    std::vector<Point> leftPointsX(pointsSortedByX.begin(), pointsSortedByX.begin() + mid);
    std::vector<Point> rightPointsX(pointsSortedByX.begin() + mid, pointsSortedByX.end());
    
    PairDistance leftResult = closestPairRecursive(leftPointsX, leftPointsY);
    PairDistance rightResult = closestPairRecursive(rightPointsX, rightPointsY);
    
    // 合并：取左右两部分中的最小距离
    PairDistance minResult = (leftResult.distance <= rightResult.distance) 
        ? leftResult : rightResult;
    
    // 带内搜索：查找跨越中线的点对
    // 构建带内的点列表，只考虑x坐标在中线附近min_dist范围内的点
    std::vector<Point> strip;
    for (const Point& p : pointsSortedByY) {
        if (std::abs(p.x - midPoint.x) < minResult.distance) {
            strip.push_back(p);
        }
    }
    
    // 在带内查找可能的更近点对
    PairDistance stripResult = stripClosest(strip, minResult);
    
    // 比较并返回全局最小距离
    return (stripResult.distance < minResult.distance) ? stripResult : minResult;
}

PairDistance closestPair(std::vector<Point> points) {
    if (points.empty()) {
        throw std::invalid_argument("输入点列表不能为空");
    }
    if (points.size() < 2) {
        throw std::invalid_argument("至少需要两个点来计算距离");
    }
    
    // 按x坐标排序
    std::vector<Point> pointsSortedByX = points;
    std::sort(pointsSortedByX.begin(), pointsSortedByX.end());
    
    // 按y坐标排序，用于带内搜索
    std::vector<Point> pointsSortedByY = points;
    std::sort(pointsSortedByY.begin(), pointsSortedByY.end(), compareByY);
    
    // 调用递归函数
    return closestPairRecursive(pointsSortedByX, pointsSortedByY);
}

// ================================
// 2. 棋盘模拟 - 生命游戏
// ================================

class GameOfLife {
private:
    std::vector<std::vector<int>> board;
    int rows;
    int cols;
    
    int countNeighbors(const std::vector<std::vector<int>>& board, int row, int col) const {
        int neighbors = 0;
        // 八个方向的偏移
        std::vector<std::pair<int, int>> directions = {
            {-1, -1}, {-1, 0}, {-1, 1},
            {0, -1},           {0, 1},
            {1, -1},  {1, 0}, {1, 1}
        };
        
        for (const auto& dir : directions) {
            int r = row + dir.first;
            int c = col + dir.second;
            
            // 检查边界并计数
            if (r >= 0 && r < rows && c >= 0 && c < cols) {
                // 注意：对于原地版本，我们需要考虑标记后的状态
                // 1和2表示原始状态为活细胞（1：保持活，2：将死亡）
                if (board[r][c] == 1 || board[r][c] == 2) {
                    neighbors++;
                }
            }
        }
        
        return neighbors;
    }
    
public:
    GameOfLife(const std::vector<std::vector<int>>& initialBoard) {
        if (initialBoard.empty() || initialBoard[0].empty()) {
            throw std::invalid_argument("输入棋盘不能为空");
        }
        
        // 深拷贝输入棋盘
        this->rows = initialBoard.size();
        this->cols = initialBoard[0].size();
        this->board.resize(rows, std::vector<int>(cols));
        
        for (int i = 0; i < rows; i++) {
            for (int j = 0; j < cols; j++) {
                this->board[i][j] = initialBoard[i][j];
            }
        }
    }
    
    std::vector<std::vector<int>> nextGenerationStandard() {
        // 创建新棋盘存储下一代状态
        std::vector<std::vector<int>> nextBoard(rows, std::vector<int>(cols, 0));
        
        // 计算每个细胞的下一代状态
        for (int i = 0; i < rows; i++) {
            for (int j = 0; j < cols; j++) {
                int neighbors = countNeighbors(this->board, i, j);
                
                // 应用生命游戏规则
                if (this->board[i][j] == 1) {  // 活细胞
                    if (neighbors < 2 || neighbors > 3) {
                        nextBoard[i][j] = 0;  // 死亡：人口稀少或过度拥挤
                    } else {
                        nextBoard[i][j] = 1;  // 存活
                    }
                } else {  // 死细胞
                    if (neighbors == 3) {
                        nextBoard[i][j] = 1;  // 繁殖
                    }
                }
            }
        }
        
        // 更新当前棋盘
        this->board = nextBoard;
        return this->board;
    }
    
    std::vector<std::vector<int>> nextGenerationInplace() {
        // 编码规则：
        // 0: 死细胞 -> 死细胞
        // 1: 活细胞 -> 活细胞
        // 2: 活细胞 -> 死细胞
        // 3: 死细胞 -> 活细胞
        
        for (int i = 0; i < rows; i++) {
            for (int j = 0; j < cols; j++) {
                int neighbors = countNeighbors(this->board, i, j);
                
                if (this->board[i][j] == 1) {  // 活细胞
                    if (neighbors < 2 || neighbors > 3) {
                        this->board[i][j] = 2;  // 标记为将死亡
                    }
                } else {  // 死细胞
                    if (neighbors == 3) {
                        this->board[i][j] = 3;  // 标记为将复活
                    }
                }
            }
        }
        
        // 解码：将标记转换回0和1
        for (int i = 0; i < rows; i++) {
            for (int j = 0; j < cols; j++) {
                this->board[i][j] %= 2;  // 2 -> 0, 3 -> 1
            }
        }
        
        return this->board;
    }
    
    std::vector<std::vector<int>> simulate(int generations, bool inplace) {
        if (generations <= 0) {
            return getBoard();
        }
        
        for (int i = 0; i < generations; i++) {
            if (inplace) {
                nextGenerationInplace();
            } else {
                nextGenerationStandard();
            }
        }
        
        return getBoard();
    }
    
    std::vector<std::vector<int>> getBoard() const {
        // 返回深拷贝，避免外部修改
        std::vector<std::vector<int>> copy(rows, std::vector<int>(cols));
        for (int i = 0; i < rows; i++) {
            for (int j = 0; j < cols; j++) {
                copy[i][j] = this->board[i][j];
            }
        }
        return copy;
    }
    
    void printBoard() const {
        for (const auto& row : board) {
            for (int cell : row) {
                std::cout << (cell == 1 ? '#' : ' ') << ' ';
            }
            std::cout << std::endl;
        }
        std::cout << std::endl;
    }
};

// ================================
// 3. 间隔打表 - 稀疏表
// ================================

class SparseTable {
private:
    std::vector<int> data;
    std::vector<std::vector<int>> st;
    std::vector<int> logTable;
    
    // 用于区间查询的函数
    using MergeFunc = std::function<int(int, int)>;
    MergeFunc mergeFunc;
    
    std::vector<int> buildLogTable() {
        int n = data.size();
        std::vector<int> logTable(n + 1, 0);
        for (int i = 2; i <= n; i++) {
            logTable[i] = logTable[i / 2] + 1;
        }
        return logTable;
    }
    
    std::vector<std::vector<int>> buildSparseTable() {
        int n = data.size();
        int kMax = logTable[n] + 1;
        std::vector<std::vector<int>> st(kMax, std::vector<int>(n));
        
        // 初始化k=0的情况（长度为1的区间）
        for (int i = 0; i < n; i++) {
            st[0][i] = data[i];
        }
        
        // 动态规划构建其他k值
        for (int k = 1; (1 << k) <= n; k++) {
            for (int i = 0; i + (1 << k) <= n; i++) {
                // 合并两个长度为2^(k-1)的区间
                st[k][i] = mergeFunc(
                    st[k-1][i],
                    st[k-1][i + (1 << (k-1))]
                );
            }
        }
        
        return st;
    }
    
public:
    SparseTable(const std::vector<int>& data, MergeFunc func) 
        : data(data), mergeFunc(func) {
        if (data.empty()) {
            throw std::invalid_argument("输入数据不能为空");
        }
        
        this->logTable = buildLogTable();
        this->st = buildSparseTable();
    }
    
    // 默认使用最小值函数
    SparseTable(const std::vector<int>& data) 
        : SparseTable(data, [](int a, int b) { return std::min(a, b); }) {}
    
    int queryRange(int l, int r) {
        // 检查边界
        if (l < 0 || r >= data.size() || l > r) {
            throw std::invalid_argument("无效的区间边界: [" + std::to_string(l) + ", " + std::to_string(r) + "]");
        }
        
        // 计算区间长度
        int length = r - l + 1;
        // 找到最大的k，使得2^k <= length
        int k = logTable[length];
        
        // 查询两个重叠的子区间并合并结果
        return mergeFunc(
            st[k][l],
            st[k][r - (1 << k) + 1]
        );
    }
    
    std::vector<int> batchQuery(const std::vector<std::pair<int, int>>& queries) {
        std::vector<int> results;
        results.reserve(queries.size());
        for (const auto& query : queries) {
            results.push_back(queryRange(query.first, query.second));
        }
        return results;
    }
    
    bool isRangeAllSame(int l, int r) {
        if (l == r) {
            return true;
        }
        return queryRange(l, r) == data[l];
    }
    
    int getRangeExtreme(int l, int r) {
        return queryRange(l, r);
    }
};

// ================================
// 4. 事件排序 - 扫描线算法
// ================================

class EventSweep {
public:
    struct OverlapResult {
        int maxOverlap;
        std::vector<std::pair<int, int>> overlappingIntervals;
        
        OverlapResult(int maxOverlap = 0, 
                     const std::vector<std::pair<int, int>>& overlappingIntervals = {}) 
            : maxOverlap(maxOverlap), overlappingIntervals(overlappingIntervals) {}
    };
    
    // 事件类，用于排序
    struct Event {
        int pos;
        int type;  // 1表示开始，-1表示结束
        int index;
        
        Event(int pos = 0, int type = 0, int index = 0) 
            : pos(pos), type(type), index(index) {}
        
        bool operator<(const Event& other) const {
            // 按位置排序，当位置相同时，结束事件（type=-1）优先
            if (this->pos != other.pos) {
                return this->pos < other.pos;
            }
            return this->type < other.type;
        }
    };
    
    static OverlapResult intervalOverlap(const std::vector<std::pair<int, int>>& intervals) {
        if (intervals.empty()) {
            return OverlapResult(0, {});
        }
        
        // 创建事件点列表
        std::vector<Event> events;
        for (int i = 0; i < intervals.size(); i++) {
            int start = intervals[i].first;
            int end = intervals[i].second;
            if (start > end) {
                throw std::invalid_argument("无效的区间: [" + std::to_string(start) + ", " + std::to_string(end) + "]");
            }
            events.emplace_back(start, 1, i);  // 开始事件
            events.emplace_back(end, -1, i);   // 结束事件
        }
        
        // 按位置排序事件，当位置相同时，结束事件优先
        std::sort(events.begin(), events.end());
        
        int currentOverlap = 0;
        int maxOverlap = 0;
        std::unordered_set<int> activeIntervals;
        std::unordered_set<int> maxOverlapIntervalIndices;
        
        // 扫描事件
        for (const Event& event : events) {
            // 更新当前重叠数量
            currentOverlap += event.type;
            
            // 更新活动区间列表
            if (event.type == 1) {
                activeIntervals.insert(event.index);
            } else {
                activeIntervals.erase(event.index);
            }
            
            // 更新最大重叠
            if (currentOverlap > maxOverlap) {
                maxOverlap = currentOverlap;
                maxOverlapIntervalIndices = activeIntervals;
            }
        }
        
        // 收集重叠的区间
        std::vector<std::pair<int, int>> overlappingIntervals;
        for (int idx : maxOverlapIntervalIndices) {
            overlappingIntervals.push_back(intervals[idx]);
        }
        
        return OverlapResult(maxOverlap, overlappingIntervals);
    }
    
    // 矩形面积计算
    struct RectangleEvent {
        int x;
        bool isStart;
        int y1, y2;
        
        RectangleEvent(int x = 0, bool isStart = false, int y1 = 0, int y2 = 0) 
            : x(x), isStart(isStart), y1(y1), y2(y2) {}
        
        bool operator<(const RectangleEvent& other) const {
            return this->x < other.x;
        }
    };
    
    static int rectangleArea(const std::vector<std::tuple<int, int, int, int>>& rectangles) {
        if (rectangles.empty()) {
            return 0;
        }
        
        // 创建垂直边事件
        std::vector<RectangleEvent> events;
        std::unordered_set<int> xCoords;
        
        for (const auto& rect : rectangles) {
            int x1 = std::get<0>(rect);
            int y1 = std::get<1>(rect);
            int x2 = std::get<2>(rect);
            int y2 = std::get<3>(rect);
            
            if (x1 >= x2 || y1 >= y2) {
                throw std::invalid_argument("无效的矩形: [" + std::to_string(x1) + ", " + 
                                          std::to_string(y1) + ", " + std::to_string(x2) + ", " + 
                                          std::to_string(y2) + "]");
            }
            
            // 添加垂直线事件
            events.emplace_back(x1, true, y1, y2);  // 左边界
            events.emplace_back(x2, false, y1, y2); // 右边界
            xCoords.insert(x1);
            xCoords.insert(x2);
        }
        
        // 按x坐标排序事件
        std::sort(events.begin(), events.end());
        // 排序x坐标
        std::vector<int> sortedX(xCoords.begin(), xCoords.end());
        std::sort(sortedX.begin(), sortedX.end());
        
        std::vector<std::pair<int, int>> activeIntervals;
        int area = 0;
        int prevX = -1;
        bool hasPrev = false;
        
        // 扫描事件
        for (const RectangleEvent& event : events) {
            // 计算当前扫描线和前一条扫描线之间的面积
            if (hasPrev && event.x > prevX && !activeIntervals.empty()) {
                // 计算当前活动的y区间的总长度
                int activeLength = mergeAndCalculateLength(activeIntervals);
                // 面积 = 宽度 * 高度
                area += (event.x - prevX) * activeLength;
            }
            
            // 更新活动区间
            if (event.isStart) {
                activeIntervals.emplace_back(event.y1, event.y2);
            } else {
                // 移除对应的区间
                activeIntervals.erase(
                    std::remove_if(activeIntervals.begin(), activeIntervals.end(),
                                 [&](const std::pair<int, int>& interval) {
                                     return interval.first == event.y1 && interval.second == event.y2;
                                 }),
                    activeIntervals.end()
                );
            }
            
            prevX = event.x;
            hasPrev = true;
        }
        
        return area;
    }
    
private:
    static int mergeAndCalculateLength(std::vector<std::pair<int, int>>& intervals) {
        if (intervals.empty()) {
            return 0;
        }
        
        // 按起始位置排序
        std::sort(intervals.begin(), intervals.end());
        
        std::vector<std::pair<int, int>> merged;
        merged.push_back(intervals[0]);
        
        for (size_t i = 1; i < intervals.size(); i++) {
            const auto& current = intervals[i];
            auto& last = merged.back();
            
            if (current.first <= last.second) {  // 有重叠
                // 合并区间
                int newStart = last.first;
                int newEnd = std::max(last.second, current.second);
                merged.back() = {newStart, newEnd};
            } else {
                merged.push_back(current);
            }
        }
        
        // 计算总长度
        int totalLength = 0;
        for (const auto& interval : merged) {
            totalLength += interval.second - interval.first;
        }
        
        return totalLength;
    }
};

// ================================
// 5. 差分驱动模拟 - 差分数组
// ================================

class DifferenceArray {
private:
    std::vector<int> diff;
    int size;
    
public:
    DifferenceArray(int size) {
        if (size <= 0) {
            throw std::invalid_argument("数组大小必须为正数");
        }
        this->size = size;
        this->diff.resize(size, 0);  // 初始化为全0数组的差分数组
    }
    
    DifferenceArray(const std::vector<int>& initialArray) {
        if (initialArray.empty()) {
            throw std::invalid_argument("初始数组不能为空");
        }
        
        this->size = initialArray.size();
        // 从初始数组构建差分数组
        this->diff.resize(size);
        this->diff[0] = initialArray[0];
        for (int i = 1; i < size; i++) {
            this->diff[i] = initialArray[i] - initialArray[i-1];
        }
    }
    
    void rangeAdd(int l, int r, int val) {
        // 检查边界
        if (l < 0 || r >= size || l > r) {
            throw std::invalid_argument("无效的区间边界: [" + std::to_string(l) + ", " + std::to_string(r) + "]");
        }
        
        // 在差分数组上进行标记
        diff[l] += val;
        if (r + 1 < size) {
            diff[r + 1] -= val;
        }
    }
    
    std::vector<int> getResult() {
        std::vector<int> res(size);
        res[0] = diff[0];
        
        // 前缀和恢复原始数组
        for (int i = 1; i < size; i++) {
            res[i] = res[i-1] + diff[i];
        }
        
        return res;
    }
    
    std::vector<int> getDifferenceArray() const {
        return diff;  // 返回副本
    }
    
    void multipleRangeUpdates(const std::vector<std::tuple<int, int, int>>& updates) {
        for (const auto& update : updates) {
            rangeAdd(std::get<0>(update), std::get<1>(update), std::get<2>(update));
        }
    }
    
    void reset() {
        std::fill(diff.begin(), diff.end(), 0);
    }
};

// ================================
// 6. 双向循环链表
// ================================

class DoublyCircularLinkedList {
private:
    struct Node {
        int data;
        Node* prev;
        Node* next;
        
        Node(int data) : data(data), prev(this), next(this) {}
    };
    
    Node* head;
    int size;
    
public:
    DoublyCircularLinkedList() : head(nullptr), size(0) {}
    
    ~DoublyCircularLinkedList() {
        clear();
    }
    
    bool isEmpty() const {
        return head == nullptr;
    }
    
    int getSize() const {
        return size;
    }
    
    void insertAtHead(int data) {
        Node* newNode = new Node(data);
        
        if (isEmpty()) {
            // 空链表情况
            head = newNode;
        } else {
            // 非空链表，插入到头部
            Node* tail = head->prev;
            
            // 连接新节点与尾节点
            newNode->prev = tail;
            tail->next = newNode;
            
            // 连接新节点与头节点
            newNode->next = head;
            head->prev = newNode;
            
            // 更新头节点
            head = newNode;
        }
        
        size++;
    }
    
    void insertAtTail(int data) {
        if (isEmpty()) {
            // 空链表情况，直接调用insertAtHead
            insertAtHead(data);
            return;
        }
        
        Node* newNode = new Node(data);
        Node* tail = head->prev;
        
        // 连接尾节点与新节点
        tail->next = newNode;
        newNode->prev = tail;
        
        // 连接新节点与头节点
        newNode->next = head;
        head->prev = newNode;
        
        size++;
    }
    
    void insertAtPosition(int index, int data) {
        if (index < 0 || index > size) {
            throw std::out_of_range("插入位置无效: " + std::to_string(index));
        }
        
        if (index == 0) {
            // 在头部插入
            insertAtHead(data);
            return;
        }
        
        if (index == size) {
            // 在尾部插入
            insertAtTail(data);
            return;
        }
        
        // 找到插入位置的前一个节点
        Node* current;
        if (index <= size / 2) {
            // 从头开始遍历
            current = head;
            for (int i = 0; i < index - 1; i++) {
                current = current->next;
            }
        } else {
            // 从尾开始遍历
            current = head->prev;
            for (int i = 0; i < size - index; i++) {
                current = current->prev;
            }
        }
        
        // 创建新节点
        Node* newNode = new Node(data);
        Node* nextNode = current->next;
        
        // 建立连接
        newNode->prev = current;
        newNode->next = nextNode;
        current->next = newNode;
        nextNode->prev = newNode;
        
        size++;
    }
    
    int deleteHead() {
        if (isEmpty()) {
            throw std::runtime_error("无法从空链表删除元素");
        }
        
        Node* temp = head;
        int data = temp->data;
        
        if (size == 1) {
            // 链表只有一个节点
            delete temp;
            head = nullptr;
        } else {
            // 链表有多个节点
            Node* tail = head->prev;
            Node* newHead = head->next;
            
            // 更新连接
            tail->next = newHead;
            newHead->prev = tail;
            
            // 删除旧头节点
            delete temp;
            
            // 更新头节点
            head = newHead;
        }
        
        size--;
        return data;
    }
    
    int deleteTail() {
        if (isEmpty()) {
            throw std::runtime_error("无法从空链表删除元素");
        }
        
        if (size == 1) {
            // 链表只有一个节点，直接调用deleteHead
            return deleteHead();
        }
        
        Node* tail = head->prev;
        int data = tail->data;
        
        // 更新连接
        Node* newTail = tail->prev;
        newTail->next = head;
        head->prev = newTail;
        
        // 删除尾节点
        delete tail;
        
        size--;
        return data;
    }
    
    int deleteAtPosition(int index) {
        if (isEmpty()) {
            throw std::runtime_error("无法从空链表删除元素");
        }
        
        if (index < 0 || index >= size) {
            throw std::out_of_range("删除位置无效: " + std::to_string(index));
        }
        
        if (index == 0) {
            return deleteHead();
        }
        
        if (index == size - 1) {
            return deleteTail();
        }
        
        // 找到要删除的节点
        Node* current;
        if (index <= size / 2) {
            current = head;
            for (int i = 0; i < index; i++) {
                current = current->next;
            }
        } else {
            current = head->prev;
            for (int i = 0; i < size - 1 - index; i++) {
                current = current->prev;
            }
        }
        
        // 保存数据
        int data = current->data;
        
        // 更新连接
        Node* prevNode = current->prev;
        Node* nextNode = current->next;
        prevNode->next = nextNode;
        nextNode->prev = prevNode;
        
        // 删除节点
        delete current;
        
        size--;
        return data;
    }
    
    bool deleteByValue(int value) {
        if (isEmpty()) {
            return false;
        }
        
        // 特殊情况：头节点就是要删除的节点
        if (head->data == value) {
            deleteHead();
            return true;
        }
        
        // 遍历链表查找值
        Node* current = head->next;
        while (current != head) {
            if (current->data == value) {
                // 找到要删除的节点
                Node* prevNode = current->prev;
                Node* nextNode = current->next;
                
                // 更新连接
                prevNode->next = nextNode;
                nextNode->prev = prevNode;
                
                // 删除节点
                delete current;
                
                size--;
                return true;
            }
            current = current->next;
        }
        
        // 未找到值
        return false;
    }
    
    std::vector<int> traverseForward() const {
        std::vector<int> result;
        if (isEmpty()) {
            return result;
        }
        
        result.reserve(size);
        Node* current = head;
        do {
            result.push_back(current->data);
            current = current->next;
        } while (current != head);
        
        return result;
    }
    
    std::vector<int> traverseBackward() const {
        std::vector<int> result;
        if (isEmpty()) {
            return result;
        }
        
        result.reserve(size);
        // 从尾节点开始
        Node* current = head->prev;
        do {
            result.push_back(current->data);
            current = current->prev;
        } while (current != head->prev);
        
        return result;
    }
    
    int search(int value) const {
        if (isEmpty()) {
            return -1;
        }
        
        int index = 0;
        Node* current = head;
        do {
            if (current->data == value) {
                return index;
            }
            current = current->next;
            index++;
        } while (current != head);
        
        return -1;
    }
    
    int get(int index) const {
        if (isEmpty()) {
            throw std::runtime_error("链表为空");
        }
        
        if (index < 0 || index >= size) {
            throw std::out_of_range("索引无效: " + std::to_string(index));
        }
        
        // 优化：根据索引位置选择从头还是从尾开始遍历
        Node* current;
        if (index <= size / 2) {
            current = head;
            for (int i = 0; i < index; i++) {
                current = current->next;
            }
        } else {
            current = head->prev;
            for (int i = 0; i < size - 1 - index; i++) {
                current = current->prev;
            }
        }
        
        return current->data;
    }
    
    int set(int index, int value) {
        if (isEmpty()) {
            throw std::runtime_error("链表为空");
        }
        
        if (index < 0 || index >= size) {
            throw std::out_of_range("索引无效: " + std::to_string(index));
        }
        
        // 优化：根据索引位置选择从头还是从尾开始遍历
        Node* current;
        if (index <= size / 2) {
            current = head;
            for (int i = 0; i < index; i++) {
                current = current->next;
            }
        } else {
            current = head->prev;
            for (int i = 0; i < size - 1 - index; i++) {
                current = current->prev;
            }
        }
        
        int oldValue = current->data;
        current->data = value;
        return oldValue;
    }
    
    void clear() {
        if (isEmpty()) {
            return;
        }
        
        Node* current = head;
        do {
            Node* next = current->next;
            delete current;
            current = next;
        } while (current != head);
        
        head = nullptr;
        size = 0;
    }
    
    void reverse() {
        if (isEmpty() || size == 1) {
            return;  // 空链表或只有一个节点不需要反转
        }
        
        // 保存头节点和尾节点
        Node* current = head;
        Node* tail = head->prev;
        
        // 交换每个节点的prev和next指针
        do {
            // 交换prev和next
            std::swap(current->prev, current->next);
            
            // 移动到下一个节点（现在是prev指针）
            current = current->prev;
            
        } while (current != head);
        
        // 更新头节点为原来的尾节点
        head = tail;
    }
    
    void rotate(int k) {
        if (isEmpty() || size == 1 || k % size == 0) {
            return;  // 无需旋转
        }
        
        // 标准化k值，使其在[0, size-1]范围内
        k = k % size;
        if (k < 0) {
            k += size;  // 转换为正向旋转
        }
        
        // 向右旋转k步相当于将倒数第k个节点作为新的头节点
        if (k > 0) {
            // 找到新的头节点（倒数第k个节点）
            Node* newHead = head;
            for (int i = 0; i < size - k; i++) {
                newHead = newHead->next;
            }
            
            // 更新头节点
            head = newHead;
        }
    }
    
    void printList() const {
        if (isEmpty()) {
            std::cout << "链表为空" << std::endl;
            return;
        }
        
        Node* current = head;
        do {
            std::cout << current->data;
            if (current->next != head) {
                std::cout << " <-> ";
            }
            current = current->next;
        } while (current != head);
        
        std::cout << " (循环)" << std::endl;
    }
};

// ================================
// 7. 斐波那契堆
// ================================

class FibonacciHeap {
private:
    struct Node {
        int key;
        Node* parent;
        Node* child;
        Node* left;
        Node* right;
        int degree;
        bool mark;
        
        Node(int key) : key(key), parent(nullptr), child(nullptr), 
                       left(this), right(this), degree(0), mark(false) {}
    };
    
    Node* min;  // 最小节点
    int size;   // 节点数量
    
    // 将节点x链接到节点y的右侧
    void linkNodes(Node* x, Node* y) {
        x->left->right = x->right;
        x->right->left = x->left;
        
        x->parent = y;
        
        if (y->child == nullptr) {
            y->child = x;
            x->left = x->right = x;
        } else {
            x->right = y->child->right;
            x->left = y->child;
            y->child->right->left = x;
            y->child->right = x;
        }
        
        y->degree++;
        x->mark = false;
    }
    
    // 合并根链表
    void consolidate() {
        // 最大度数不超过log_phi(size)，这里用size作为上限
        std::vector<Node*> A(size + 1, nullptr);
        
        Node* current = min;
        Node* start = min;
        bool end = false;
        
        do {
            Node* next = current->right;
            int d = current->degree;
            
            // 合并度数相同的树
            while (A[d] != nullptr) {
                Node* y = A[d];
                if (current->key > y->key) {
                    std::swap(current, y);
                }
                
                linkNodes(y, current);
                A[d] = nullptr;
                d++;
            }
            
            A[d] = current;
            current = next;
            
            if (current == start) {
                end = true;
            }
        } while (!end);
        
        // 重新设置min节点
        min = nullptr;
        for (int i = 0; i <= size; i++) {
            if (A[i] != nullptr) {
                if (min == nullptr || A[i]->key < min->key) {
                    min = A[i];
                }
            }
        }
    }
    
    // 级联剪枝
    void cascadingCut(Node* y) {
        Node* z = y->parent;
        if (z != nullptr) {
            if (!y->mark) {
                y->mark = true;
            } else {
                cut(y, z);
                cascadingCut(z);
            }
        }
    }
    
    // 剪枝操作
    void cut(Node* x, Node* y) {
        // 从y的子节点中移除x
        x->left->right = x->right;
        x->right->left = x->left;
        y->degree--;
        
        if (y->child == x) {
            y->child = (x->right != x) ? x->right : nullptr;
        }
        
        // 将x添加到根链表
        x->parent = nullptr;
        x->mark = false;
        x->left = x->right = x;
        
        // 链接到min节点
        x->right = min->right;
        x->left = min;
        min->right->left = x;
        min->right = x;
        
        // 更新min节点
        if (x->key < min->key) {
            min = x;
        }
    }
    
    // 析构辅助函数
    void destroyNodes(Node* node) {
        if (node == nullptr) {
            return;
        }
        
        Node* current = node;
        do {
            Node* next = current->right;
            destroyNodes(current->child);
            delete current;
            current = next;
        } while (current != node);
    }
    
public:
    FibonacciHeap() : min(nullptr), size(0) {}
    
    ~FibonacciHeap() {
        if (min != nullptr) {
            destroyNodes(min);
        }
    }
    
    bool isEmpty() const {
        return min == nullptr;
    }
    
    int getSize() const {
        return size;
    }
    
    // 插入操作 - O(1)
    void insert(int key) {
        Node* newNode = new Node(key);
        
        if (min == nullptr) {
            min = newNode;
        } else {
            // 将新节点链接到min节点的右侧
            newNode->right = min->right;
            newNode->left = min;
            min->right->left = newNode;
            min->right = newNode;
            
            // 更新min节点
            if (newNode->key < min->key) {
                min = newNode;
            }
        }
        
        size++;
    }
    
    // 获取最小值 - O(1)
    int getMin() const {
        if (isEmpty()) {
            throw std::runtime_error("堆为空");
        }
        return min->key;
    }
    
    // 提取最小值 - O(log n) 均摊
    int extractMin() {
        if (isEmpty()) {
            throw std::runtime_error("堆为空");
        }
        
        Node* z = min;
        int minKey = z->key;
        
        // 将z的所有子节点添加到根链表
        if (z->child != nullptr) {
            Node* child = z->child;
            do {
                Node* next = child->right;
                
                // 断开与父节点的连接
                child->parent = nullptr;
                
                // 添加到根链表
                child->right = min->right;
                child->left = min;
                min->right->left = child;
                min->right = child;
                
                child = next;
            } while (child != z->child);
        }
        
        // 从根链表中移除z
        z->left->right = z->right;
        z->right->left = z->left;
        
        size--;
        
        if (z == z->right) {
            // 堆为空
            min = nullptr;
        } else {
            min = z->right;
            consolidate();
        }
        
        delete z;
        return minKey;
    }
    
    // 合并两个斐波那契堆 - O(1)
    void merge(FibonacciHeap& other) {
        if (other.isEmpty()) {
            return;
        }
        
        if (isEmpty()) {
            min = other.min;
            size = other.size;
            other.min = nullptr;
            other.size = 0;
            return;
        }
        
        // 合并根链表
        Node* thisRight = min->right;
        Node* otherRight = other.min->right;
        
        min->right = otherRight;
        otherRight->left = min;
        
        other.min->right = thisRight;
        thisRight->left = other.min;
        
        // 更新min节点
        if (other.min->key < min->key) {
            min = other.min;
        }
        
        size += other.size;
        
        // 重置other堆
        other.min = nullptr;
        other.size = 0;
    }
    
    // 减少键值 - O(1) 均摊
    void decreaseKey(Node* x, int newKey) {
        if (newKey > x->key) {
            throw std::invalid_argument("新键值大于当前键值");
        }
        
        x->key = newKey;
        Node* y = x->parent;
        
        if (y != nullptr && x->key < y->key) {
            cut(x, y);
            cascadingCut(y);
        }
        
        if (x->key < min->key) {
            min = x;
        }
    }
    
    // 删除节点 - O(log n) 均摊
    void deleteNode(Node* x) {
        decreaseKey(x, std::numeric_limits<int>::min());
        extractMin();
    }
};

// ================================
// 8. 块状链表 (Unrolled Linked List)
// ================================

class UnrolledLinkedList {
private:
    struct Block {
        std::vector<int> data;
        Block* next;
        
        Block(size_t blockSize) : next(nullptr) {
            data.reserve(blockSize);
        }
        
        bool isFull(size_t blockSize) const {
            return data.size() >= blockSize;
        }
        
        bool isEmpty() const {
            return data.empty();
        }
    };
    
    Block* head;
    Block* tail;
    int size;
    const size_t blockSize;
    const size_t minBlockSize;  // 重平衡时保留的最小元素数量
    
    // 插入到指定块的指定位置
    void insertInBlock(Block* block, size_t pos, int value) {
        if (block->isFull(blockSize)) {
            // 块已满，需要分裂
            Block* newBlock = new Block(blockSize);
            
            // 将后半部分数据移到新块
            size_t mid = block->data.size() / 2;
            newBlock->data.insert(newBlock->data.end(), 
                                block->data.begin() + mid, 
                                block->data.end());
            block->data.erase(block->data.begin() + mid, block->data.end());
            
            // 插入新块到链表中
            newBlock->next = block->next;
            block->next = newBlock;
            
            // 更新tail
            if (block == tail) {
                tail = newBlock;
            }
            
            // 决定在哪个块插入
            if (pos > mid) {
                block = newBlock;
                pos -= mid;
            }
        }
        
        // 在块中的指定位置插入元素
        block->data.insert(block->data.begin() + pos, value);
        size++;
    }
    
    // 从指定块的指定位置删除
    int deleteFromBlock(Block* block, Block* prevBlock, size_t pos) {
        int value = block->data[pos];
        block->data.erase(block->data.begin() + pos);
        size--;
        
        // 检查是否需要合并块
        if (block->data.size() < minBlockSize && block != head) {
            // 尝试从下一个块借一个元素
            if (block->next && block->next->data.size() > minBlockSize) {
                block->data.push_back(block->next->data[0]);
                block->next->data.erase(block->next->data.begin());
            } 
            // 尝试从上一个块借一个元素
            else if (prevBlock && prevBlock->data.size() > minBlockSize) {
                block->data.insert(block->data.begin(), prevBlock->data.back());
                prevBlock->data.pop_back();
            } 
            // 合并到前一个块
            else if (prevBlock) {
                prevBlock->data.insert(prevBlock->data.end(), 
                                     block->data.begin(), 
                                     block->data.end());
                prevBlock->next = block->next;
                
                if (block == tail) {
                    tail = prevBlock;
                }
                
                delete block;
            } 
            // 不能合并（只有一个块）
            else {
                // 单块情况下不做处理
            }
        }
        
        return value;
    }
    
    // 查找元素位置，返回块指针和块内偏移
    std::pair<Block*, size_t> findPosition(int index) const {
        if (index < 0 || index >= size) {
            throw std::out_of_range("索引无效: " + std::to_string(index));
        }
        
        Block* current = head;
        int currentIndex = 0;
        
        while (currentIndex + current->data.size() <= index) {
            currentIndex += current->data.size();
            current = current->next;
        }
        
        return {current, index - currentIndex};
    }
    
public:
    UnrolledLinkedList(size_t blockSize = 16) 
        : head(nullptr), tail(nullptr), size(0), 
          blockSize(blockSize), minBlockSize(std::max(size_t(1), blockSize / 4)) {}
    
    ~UnrolledLinkedList() {
        clear();
    }
    
    bool isEmpty() const {
        return size == 0;
    }
    
    int getSize() const {
        return size;
    }
    
    void insert(int index, int value) {
        if (index < 0 || index > size) {
            throw std::out_of_range("插入位置无效: " + std::to_string(index));
        }
        
        // 空列表情况
        if (isEmpty()) {
            head = new Block(blockSize);
            tail = head;
            head->data.push_back(value);
            size++;
            return;
        }
        
        // 插入到开头
        if (index == 0) {
            insertInBlock(head, 0, value);
            return;
        }
        
        // 插入到末尾
        if (index == size) {
            // 检查最后一个块是否已满
            if (!tail->isFull(blockSize)) {
                tail->data.push_back(value);
                size++;
            } else {
                // 最后一个块已满，先找到位置再插入
                auto result = findPosition(index - 1);
                auto block = result.first;
                auto pos = result.second;
                insertInBlock(block, pos + 1, value);
            }
            return;
        }
        
        // 插入到中间位置
        auto result = findPosition(index);
        auto block = result.first;
        auto pos = result.second;
        insertInBlock(block, pos, value);
    }
    
    int deleteAt(int index) {
        if (isEmpty()) {
            throw std::runtime_error("列表为空");
        }
        
        if (index < 0 || index >= size) {
            throw std::out_of_range("删除位置无效: " + std::to_string(index));
        }
        
        // 找到块和位置
        Block* current = head;
        Block* prev = nullptr;
        int currentIndex = 0;
        
        while (currentIndex + current->data.size() <= index) {
            prev = current;
            currentIndex += current->data.size();
            current = current->next;
        }
        
        size_t posInBlock = index - currentIndex;
        int value = deleteFromBlock(current, prev, posInBlock);
        
        // 检查是否需要更新head
        if (head->isEmpty()) {
            Block* oldHead = head;
            head = head->next;
            delete oldHead;
            
            // 如果删除后为空，更新tail
            if (head == nullptr) {
                tail = nullptr;
            }
        }
        
        return value;
    }
    
    int get(int index) const {
        if (isEmpty()) {
            throw std::runtime_error("列表为空");
        }
        
        auto result = findPosition(index);
        auto block = result.first;
        auto pos = result.second;
        return block->data[pos];
    }
    
    void set(int index, int value) {
        if (isEmpty()) {
            throw std::runtime_error("列表为空");
        }
        
        auto result = findPosition(index);
        auto block = result.first;
        auto pos = result.second;
        block->data[pos] = value;
    }
    
    std::vector<int> toVector() const {
        std::vector<int> result;
        result.reserve(size);
        
        Block* current = head;
        while (current != nullptr) {
            result.insert(result.end(), current->data.begin(), current->data.end());
            current = current->next;
        }
        
        return result;
    }
    
    void clear() {
        Block* current = head;
        while (current != nullptr) {
            Block* next = current->next;
            delete current;
            current = next;
        }
        
        head = tail = nullptr;
        size = 0;
    }
    
    void printList() const {
        if (isEmpty()) {
            std::cout << "列表为空" << std::endl;
            return;
        }
        
        Block* current = head;
        int blockIndex = 0;
        
        while (current != nullptr) {
            std::cout << "块 " << blockIndex++ << ": [";
            for (size_t i = 0; i < current->data.size(); i++) {
                std::cout << current->data[i];
                if (i < current->data.size() - 1) {
                    std::cout << ", ";
                }
            }
            std::cout << "]" << std::endl;
            current = current->next;
        }
    }
};

// ================================
// 主函数，用于测试
// ================================

int main() {
    std::cout << "=== C++高级数据结构与算法实现 ===" << std::endl;
    
    // 测试平面分治算法
    std::cout << "\n=== 测试平面分治算法 - 最近点对 ===" << std::endl;
    std::vector<Point> points = {Point(0, 0), Point(3, 0), Point(0, 4), Point(1, 1)};
    try {
        PairDistance result = closestPair(points);
        std::cout << "最小距离: " << result.distance << std::endl;
        std::cout << "最近点对: " << result.p1 << " 和 " << result.p2 << std::endl;
    } catch (const std::exception& e) {
        std::cerr << "错误: " << e.what() << std::endl;
    }
    
    // 测试生命游戏
    std::cout << "\n=== 测试生命游戏 ===" << std::endl;
    std::vector<std::vector<int>> initialBoard = {
        {0, 1, 0},
        {0, 1, 0},
        {0, 1, 0}
    };
    try {
        GameOfLife game(initialBoard);
        std::cout << "初始状态:" << std::endl;
        game.printBoard();
        
        game.simulate(1, true);
        std::cout << "下一代状态:" << std::endl;
        game.printBoard();
    } catch (const std::exception& e) {
        std::cerr << "错误: " << e.what() << std::endl;
    }
    
    // 测试双向循环链表
    std::cout << "\n=== 测试双向循环链表 ===" << std::endl;
    try {
        DoublyCircularLinkedList list;
        list.insertAtHead(1);
        list.insertAtTail(3);
        list.insertAtPosition(1, 2);
        
        std::cout << "链表内容: ";
        list.printList();
        
        std::cout << "正向遍历: ";
        for (int val : list.traverseForward()) {
            std::cout << val << " ";
        }
        std::cout << std::endl;
        
        std::cout << "反向遍历: ";
        for (int val : list.traverseBackward()) {
            std::cout << val << " ";
        }
        std::cout << std::endl;
    } catch (const std::exception& e) {
        std::cerr << "错误: " << e.what() << std::endl;
    }
    
    // 测试块状链表
    std::cout << "\n=== 测试块状链表 ===" << std::endl;
    try {
        UnrolledLinkedList ull(4);
        ull.insert(0, 1);
        ull.insert(1, 2);
        ull.insert(2, 3);
        ull.insert(3, 4);
        ull.insert(4, 5);
        
        std::cout << "块状链表内容:" << std::endl;
        ull.printList();
        
        std::cout << "转换为数组: ";
        for (int val : ull.toVector()) {
            std::cout << val << " ";
        }
        std::cout << std::endl;
    } catch (const std::exception& e) {
        std::cerr << "错误: " << e.what() << std::endl;
    }
    
    return 0;
}

===============================================

文件: advanced_data_structures.py
===============================================
#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
高级数据结构实现

包含：
1. 斐波那契堆（Fibonacci Heap）
2. 块状链表（Unrolled Linked List）

时间复杂度分析：
- 斐波那契堆：
  - 插入：O(1) 均摊
  - 查找最小值：O(1)
  - 合并：O(1)
  - 提取最小值：O(log n) 均摊
  - 减少键值：O(1) 均摊
  - 删除：O(log n) 均摊

- 块状链表：
  - 插入：O(1) 均摊
  - 删除：O(1) 均摊
  - 查找：O(n/b)，其中b是块大小
  - 遍历：O(n)
"""

import math
from collections import defaultdict

# ============================================
# 1. 斐波那契堆（Fibonacci Heap）实现
# ============================================

class FibonacciHeapNode:
    """
    斐波那契堆节点类
    """
    def __init__(self, key, value=None):
        """
        初始化斐波那契堆节点
        
        Args:
            key: 节点的键值，用于比较
            value: 节点存储的值（可选）
        """
        self.key = key                # 键值
        self.value = value or key     # 存储的值
        self.degree = 0               # 子节点的数量
        self.mark = False             # 是否被标记（是否失去过子节点）
        self.parent = None            # 父节点引用
        self.child = None             # 第一个子节点引用
        self.left = self              # 左兄弟引用
        self.right = self             # 右兄弟引用

class FibonacciHeap:
    """
    斐波那契堆实现
    特点：
    1. 支持快速插入、合并和减少键值操作（均为O(1)均摊时间复杂度）
    2. 适合需要频繁插入和减少键值的场景，如Dijkstra算法
    3. 结构复杂但性能优秀
    """
    
    def __init__(self):
        """
        初始化空的斐波那契堆
        """
        self.min_node = None  # 指向最小键值的节点
        self.node_count = 0   # 堆中节点的数量
    
    def is_empty(self):
        """
        检查堆是否为空
        
        Returns:
            bool: 如果堆为空返回True，否则返回False
        """
        return self.min_node is None
    
    def insert(self, key, value=None):
        """
        插入新节点到斐波那契堆
        时间复杂度：O(1) 均摊
        
        Args:
            key: 节点的键值
            value: 节点存储的值（可选）
            
        Returns:
            FibonacciHeapNode: 新插入的节点引用
        """
        # 创建新节点
        new_node = FibonacciHeapNode(key, value)
        
        # 将新节点添加到根链表
        if self.min_node is None:
            # 空堆的情况
            self.min_node = new_node
        else:
            # 非空堆，将新节点插入到min_node的右边
            self._link_nodes(self.min_node, new_node)
            # 更新最小节点
            if new_node.key < self.min_node.key:
                self.min_node = new_node
        
        # 增加节点计数
        self.node_count += 1
        return new_node
    
    def _link_nodes(self, left, right):
        """
        将right节点链接到left节点的右边，形成双向循环链表
        
        Args:
            left: 左边的节点
            right: 右边的节点
        """
        left.right.left = right
        right.right = left.right
        left.right = right
        right.left = left
    
    def extract_min(self):
        """
        提取并返回堆中键值最小的节点
        时间复杂度：O(log n) 均摊
        
        Returns:
            FibonacciHeapNode: 键值最小的节点，如果堆为空返回None
        """
        if self.is_empty():
            return None
        
        # 保存要返回的最小节点
        min_node = self.min_node
        
        # 如果只有一个节点
        if min_node.left == min_node and min_node.child is None:
            self.min_node = None
            self.node_count = 0
            return min_node
        
        # 将最小节点的所有子节点提升到根链表
        if min_node.child is not None:
            child = min_node.child
            while True:
                next_child = child.right
                # 断开子节点与父节点的连接
                child.parent = None
                # 将子节点插入到根链表
                self._link_nodes(min_node, child)
                # 移动到下一个子节点
                child = next_child
                if child == min_node.child:
                    break
        
        # 从根链表中移除最小节点
        min_node.left.right = min_node.right
        min_node.right.left = min_node.left
        
        # 如果最小节点是其唯一的根节点，则更新min_node为其任意子节点
        if min_node == min_node.right:
            self.min_node = min_node.child
        else:
            # 否则，将min_node设置为任意一个根节点，然后执行合并操作
            self.min_node = min_node.right
            # 执行合并操作，确保每个度数的树只有一个
            self._consolidate()
        
        # 减少节点计数
        self.node_count -= 1
        return min_node
    
    def _consolidate(self):
        """
        合并具有相同度数的树，确保每个度数的树最多只有一个
        这是extract_min操作中的关键步骤
        """
        # 创建度数表，用于存储不同度数的根节点
        max_degree = int(math.log2(self.node_count)) + 1 if self.node_count > 0 else 0
        degree_table = [None] * (max_degree + 2)
        
        # 获取根链表中的第一个节点
        current = self.min_node
        if current is None:
            return
        
        # 收集所有根节点
        roots = []
        while True:
            roots.append(current)
            current = current.right
            if current == self.min_node:
                break
        
        # 处理每个根节点
        for root in roots:
            degree = root.degree
            # 合并具有相同度数的树
            while degree_table[degree] is not None:
                other = degree_table[degree]
                # 确保root是键值较小的节点
                if root.key > other.key:
                    root, other = other, root
                
                # 将other作为root的子节点
                self._link_as_child(other, root)
                
                # 清空度数表中该度数的条目
                degree_table[degree] = None
                degree += 1
            
            # 将合并后的树存入度数表
            degree_table[degree] = root
        
        # 重新设置min_node
        self.min_node = None
        for i in range(len(degree_table)):
            if degree_table[i] is not None:
                if self.min_node is None:
                    self.min_node = degree_table[i]
                    # 初始化循环链表
                    degree_table[i].left = degree_table[i]
                    degree_table[i].right = degree_table[i]
                else:
                    # 将节点添加到根链表
                    self._link_nodes(self.min_node, degree_table[i])
                    # 更新最小节点
                    if degree_table[i].key < self.min_node.key:
                        self.min_node = degree_table[i]
    
    def _link_as_child(self, child_node, parent_node):
        """
        将child_node链接为parent_node的子节点
        
        Args:
            child_node: 子节点
            parent_node: 父节点
        """
        # 从根链表中移除子节点
        child_node.left.right = child_node.right
        child_node.right.left = child_node.left
        
        # 重置子节点的引用
        child_node.parent = parent_node
        child_node.mark = False
        
        # 将子节点添加到父节点的子节点列表
        if parent_node.child is None:
            parent_node.child = child_node
            child_node.left = child_node
            child_node.right = child_node
        else:
            self._link_nodes(parent_node.child, child_node)
        
        # 增加父节点的度数
        parent_node.degree += 1
    
    def decrease_key(self, node, new_key):
        """
        减少指定节点的键值
        时间复杂度：O(1) 均摊
        
        Args:
            node: 要减少键值的节点
            new_key: 新的键值
            
        Raises:
            ValueError: 如果新键值大于当前键值
        """
        if new_key > node.key:
            raise ValueError("新键值必须小于当前键值")
        
        node.key = new_key
        parent = node.parent
        
        # 如果节点在根链表或父节点的键值小于等于当前节点的键值，则只需更新min_node
        if parent is None or parent.key <= node.key:
            # 更新最小节点
            if node.key < self.min_node.key:
                self.min_node = node
        else:
            # 否则，执行级联剪切操作
            self._cut(node, parent)
            self._cascading_cut(parent)
    
    def _cut(self, node, parent):
        """
        将node从parent的子节点列表中移除，并添加到根链表
        
        Args:
            node: 要剪切的节点
            parent: 父节点
        """
        # 减少父节点的度数
        parent.degree -= 1
        
        # 如果node是父节点的唯一子节点
        if parent.child == node and node.right == node:
            parent.child = None
        else:
            parent.child = node.right
            # 从子节点链表中移除node
            node.left.right = node.right
            node.right.left = node.left
        
        # 将node添加到根链表
        self._link_nodes(self.min_node, node)
        node.parent = None
        node.mark = False
        
        # 更新最小节点
        if node.key < self.min_node.key:
            self.min_node = node
    
    def _cascading_cut(self, node):
        """
        级联剪切操作，向上检查并剪切被标记的节点
        
        Args:
            node: 开始检查的节点
        """
        parent = node.parent
        if parent is not None:
            if not node.mark:
                # 第一次失去子节点，标记该节点
                node.mark = True
            else:
                # 已经被标记，再次失去子节点，执行剪切
                self._cut(node, parent)
                self._cascading_cut(parent)
    
    def delete(self, node):
        """
        删除指定节点
        时间复杂度：O(log n) 均摊
        
        Args:
            node: 要删除的节点
        """
        # 将节点的键值减少到负无穷
        self.decrease_key(node, float('-inf'))
        # 提取最小节点（即刚被设置为负无穷的节点）
        self.extract_min()
    
    def merge(self, other_heap):
        """
        合并两个斐波那契堆
        时间复杂度：O(1)
        
        Args:
            other_heap: 要合并的另一个斐波那契堆
        """
        # 如果另一个堆为空，直接返回
        if other_heap.is_empty():
            return
        
        # 如果当前堆为空，直接复制另一个堆的属性
        if self.is_empty():
            self.min_node = other_heap.min_node
            self.node_count = other_heap.node_count
            return
        
        # 合并两个根链表
        self._link_nodes(self.min_node, other_heap.min_node)
        # 更新最小节点
        if other_heap.min_node.key < self.min_node.key:
            self.min_node = other_heap.min_node
        # 更新节点计数
        self.node_count += other_heap.node_count
    
    def get_min(self):
        """
        获取堆中键值最小的节点但不移除
        时间复杂度：O(1)
        
        Returns:
            FibonacciHeapNode: 键值最小的节点，如果堆为空返回None
        """
        return self.min_node
    
    def size(self):
        """
        获取堆中节点的数量
        
        Returns:
            int: 节点数量
        """
        return self.node_count

# ============================================
# 2. 块状链表（Unrolled Linked List）实现
# ============================================

class Block:
    """
    块状链表中的块类
    """
    def __init__(self, max_size=16):
        """
        初始化块
        
        Args:
            max_size: 块的最大容量
        """
        self.data = []             # 存储数据的列表
        self.max_size = max_size   # 块的最大容量
        self.next = None           # 指向下一个块的引用

class UnrolledLinkedList:
    """
    块状链表实现
    特点：
    1. 结合了数组和链表的优点
    2. 减少了纯链表的内存开销和指针操作
    3. 支持高效的区间操作
    """
    
    def __init__(self, block_size=16):
        """
        初始化块状链表
        
        Args:
            block_size: 每个块的最大容量，默认为16
        """
        self.head = Block(block_size)  # 头节点
        self.tail = self.head          # 尾节点
        self.block_size = block_size   # 块大小
        self.size = 0                  # 元素总数
    
    def is_empty(self):
        """
        检查链表是否为空
        
        Returns:
            bool: 如果链表为空返回True，否则返回False
        """
        return self.size == 0
    
    def _get_block_and_index(self, index):
        """
        获取指定索引所在的块和在块内的位置
        
        Args:
            index: 元素索引
            
        Returns:
            tuple: (块引用, 块内索引)
            
        Raises:
            IndexError: 如果索引无效
        """
        if index < 0 or index >= self.size:
            raise IndexError("索引超出范围")
        
        current_block = self.head
        while len(current_block.data) <= index:
            index -= len(current_block.data)
            current_block = current_block.next
        
        return current_block, index
    
    def get(self, index):
        """
        获取指定索引的元素
        时间复杂度：O(n/b)，其中b是块大小
        
        Args:
            index: 元素索引
            
        Returns:
            索引位置的元素
        """
        block, block_index = self._get_block_and_index(index)
        return block.data[block_index]
    
    def set(self, index, value):
        """
        设置指定索引的元素值
        时间复杂度：O(n/b)
        
        Args:
            index: 元素索引
            value: 新的值
        """
        block, block_index = self._get_block_and_index(index)
        block.data[block_index] = value
    
    def insert(self, index, value):
        """
        在指定位置插入元素
        时间复杂度：O(n/b)均摊
        
        Args:
            index: 插入位置
            value: 要插入的值
        """
        if index < 0 or index > self.size:
            raise IndexError("索引超出范围")
        
        # 处理空链表的情况
        if self.is_empty():
            self.head.data.append(value)
            self.size += 1
            return
        
        # 找到插入位置所在的块
        current_block = self.head
        prev_block = None
        current_index = 0
        
        while current_block and current_index + len(current_block.data) <= index:
            current_index += len(current_block.data)
            prev_block = current_block
            current_block = current_block.next
        
        # 如果需要创建新的块（插入到末尾）
        if current_block is None:
            current_block = Block(self.block_size)
            prev_block.next = current_block
            self.tail = current_block
            block_index = 0
        else:
            block_index = index - current_index
        
        # 插入元素
        current_block.data.insert(block_index, value)
        self.size += 1
        
        # 如果块过大，分割块
        if len(current_block.data) > self.block_size:
            self._split_block(current_block)
    
    def _split_block(self, block):
        """
        分割过大的块
        
        Args:
            block: 要分割的块
        """
        # 创建新块
        new_block = Block(self.block_size)
        
        # 计算分割点
        split_point = len(block.data) // 2
        
        # 移动后半部分数据到新块
        new_block.data = block.data[split_point:]
        block.data = block.data[:split_point]
        
        # 插入新块到链表中
        new_block.next = block.next
        block.next = new_block
        
        # 更新尾节点
        if block == self.tail:
            self.tail = new_block
    
    def append(self, value):
        """
        在链表末尾添加元素
        时间复杂度：O(1)均摊
        
        Args:
            value: 要添加的值
        """
        # 如果尾块已满，创建新块
        if len(self.tail.data) >= self.block_size:
            new_block = Block(self.block_size)
            self.tail.next = new_block
            self.tail = new_block
        
        # 添加元素到尾块
        self.tail.data.append(value)
        self.size += 1
    
    def prepend(self, value):
        """
        在链表头部添加元素
        时间复杂度：O(1)均摊
        
        Args:
            value: 要添加的值
        """
        # 如果头块已满，创建新块
        if len(self.head.data) >= self.block_size:
            new_block = Block(self.block_size)
            new_block.next = self.head
            self.head = new_block
        
        # 添加元素到头块的开头
        self.head.data.insert(0, value)
        self.size += 1
    
    def delete(self, index):
        """
        删除指定位置的元素
        时间复杂度：O(n/b)
        
        Args:
            index: 要删除的元素索引
            
        Returns:
            被删除的元素值
        """
        block, block_index = self._get_block_and_index(index)
        
        # 删除元素
        value = block.data.pop(block_index)
        self.size -= 1
        
        # 如果链表只有一个块且为空，保持头块不变
        if self.size == 0:
            self.head.data = []
            self.tail = self.head
            return value
        
        # 如果块变得太小，尝试合并
        if block != self.head and len(block.data) < self.block_size // 2:
            self._merge_or_redistribute(block)
        
        return value
    
    def _merge_or_redistribute(self, block):
        """
        合并或重新分配块中的元素
        
        Args:
            block: 需要处理的块
        """
        # 找到前一个块
        prev_block = self.head
        while prev_block and prev_block.next != block:
            prev_block = prev_block.next
        
        # 尝试从下一个块借元素
        if block.next and len(block.next.data) > self.block_size // 2:
            # 从下一个块的开头借一个元素
            block.data.append(block.next.data.pop(0))
        # 尝试向前一个块借元素
        elif prev_block and len(prev_block.data) > self.block_size // 2:
            # 从前一个块的末尾借一个元素
            block.data.insert(0, prev_block.data.pop())
        # 合并到前一个块
        elif prev_block:
            prev_block.data.extend(block.data)
            prev_block.next = block.next
            # 更新尾节点
            if block == self.tail:
                self.tail = prev_block
        # 合并到下一个块（这种情况只可能是头块）
        elif block.next:
            block.next.data = block.data + block.next.data
            self.head = block.next
    
    def __getitem__(self, index):
        """
        支持通过索引访问元素，例如：list[index]
        """
        return self.get(index)
    
    def __setitem__(self, index, value):
        """
        支持通过索引设置元素，例如：list[index] = value
        """
        self.set(index, value)
    
    def __delitem__(self, index):
        """
        支持通过索引删除元素，例如：del list[index]
        """
        self.delete(index)
    
    def __len__(self):
        """
        返回链表长度，例如：len(list)
        """
        return self.size
    
    def __iter__(self):
        """
        支持迭代，例如：for item in list
        """
        current_block = self.head
        while current_block:
            for item in current_block.data:
                yield item
            current_block = current_block.next
    
    def __str__(self):
        """
        返回链表的字符串表示
        """
        return str(list(self))
    
    def __repr__(self):
        """
        返回链表的详细字符串表示
        """
        return f"UnrolledLinkedList(size={self.size}, block_size={self.block_size}, data={list(self)})"
    
    # 区间操作方法
    def insert_range(self, index, values):
        """
        在指定位置插入多个元素
        
        Args:
            index: 插入位置
            values: 要插入的值列表
        """
        for i, value in enumerate(values):
            self.insert(index + i, value)
    
    def delete_range(self, start, end):
        """
        删除指定范围的元素
        
        Args:
            start: 起始索引（包含）
            end: 结束索引（不包含）
        """
        for _ in range(start, end):
            self.delete(start)
    
    def get_range(self, start, end):
        """
        获取指定范围的元素
        
        Args:
            start: 起始索引（包含）
            end: 结束索引（不包含）
            
        Returns:
            list: 范围内的元素列表
        """
        result = []
        for i in range(start, end):
            result.append(self.get(i))
        return result

# 测试代码
def test_fibonacci_heap():
    """
    测试斐波那契堆的基本操作
    """
    print("=== 测试斐波那契堆 ===")
    
    # 创建斐波那契堆
    fib_heap = FibonacciHeap()
    
    # 测试插入
    print("\n测试插入操作:")
    nodes = []
    for i in range(10, 0, -1):
        node = fib_heap.insert(i, f"value_{i}")
        nodes.append(node)
        print(f"插入键值 {i}, 当前最小键值: {fib_heap.get_min().key if fib_heap.get_min() else None}")
    
    print(f"堆大小: {fib_heap.size()}")
    
    # 测试获取最小值
    print("\n测试获取最小值:")
    min_node = fib_heap.get_min()
    print(f"最小值节点: 键值={min_node.key}, 值={min_node.value}")
    
    # 测试减少键值
    print("\n测试减少键值:")
    fib_heap.decrease_key(nodes[0], 0)
    print(f"将键值10减少到0后，最小值: {fib_heap.get_min().key}")
    
    # 测试提取最小值
    print("\n测试提取最小值:")
    extracted = fib_heap.extract_min()
    print(f"提取的最小值: 键值={extracted.key}, 值={extracted.value}")
    print(f"提取后最小值: {fib_heap.get_min().key}")
    print(f"提取后堆大小: {fib_heap.size()}")
    
    # 测试删除操作
    print("\n测试删除操作:")
    node_to_delete = nodes[2]  # 键值8的节点
    print(f"删除键值为{node_to_delete.key}的节点")
    fib_heap.delete(node_to_delete)
    print(f"删除后堆大小: {fib_heap.size()}")
    
    # 测试合并堆
    print("\n测试合并堆:")
    fib_heap2 = FibonacciHeap()
    for i in range(100, 90, -1):
        fib_heap2.insert(i)
    
    fib_heap.merge(fib_heap2)
    print(f"合并后堆大小: {fib_heap.size()}")
    print(f"合并后最小值: {fib_heap.get_min().key}")
    
    # 测试批量提取最小值
    print("\n测试批量提取最小值:")
    for _ in range(5):
        min_node = fib_heap.extract_min()
        print(f"提取: {min_node.key}")
    
    print(f"最终堆大小: {fib_heap.size()}")

def test_unrolled_linked_list():
    """
    测试块状链表的基本操作
    """
    print("\n=== 测试块状链表 ===")
    
    # 创建块状链表，设置较小的块大小以便测试块分割和合并
    ull = UnrolledLinkedList(block_size=4)
    
    # 测试添加元素
    print("\n测试添加元素:")
    for i in range(1, 11):
        ull.append(i)
    print(f"添加1-10后: {ull}")
    print(f"链表大小: {len(ull)}")
    
    # 测试插入元素
    print("\n测试插入元素:")
    ull.insert(5, 99)
    print(f"在位置5插入99后: {ull}")
    ull.prepend(0)
    print(f"在头部插入0后: {ull}")
    
    # 测试访问和修改元素
    print("\n测试访问和修改元素:")
    print(f"位置6的值: {ull[6]}")
    ull[6] = 100
    print(f"修改位置6后: {ull}")
    
    # 测试删除元素
    print("\n测试删除元素:")
    deleted = ull.delete(3)
    print(f"删除位置3的元素({deleted})后: {ull}")
    del ull[0]  # 测试通过del语句删除
    print(f"删除位置0后: {ull}")
    
    # 测试迭代
    print("\n测试迭代:")
    print("迭代结果:", end=" ")
    for item in ull:
        print(item, end=" ")
    print()
    
    # 测试区间操作
    print("\n测试区间操作:")
    ull.insert_range(2, [200, 201, 202])
    print(f"插入范围后: {ull}")
    
    range_values = ull.get_range(3, 7)
    print(f"获取范围[3,7): {range_values}")
    
    ull.delete_range(1, 4)
    print(f"删除范围[1,4)后: {ull}")
    
    # 测试边界情况
    print("\n测试边界情况:")
    empty_ull = UnrolledLinkedList()
    print(f"空链表: {empty_ull}, 大小: {len(empty_ull)}")
    empty_ull.append(42)
    print(f"添加一个元素后: {empty_ull}")
    del empty_ull[0]
    print(f"删除唯一元素后: {empty_ull}, 是否为空: {empty_ull.is_empty()}")

if __name__ == "__main__":
    # 运行测试
    test_fibonacci_heap()
    test_unrolled_linked_list()

# ================================
# C++ 代码等效实现注释版 - 斐波那契堆
'''
#include <iostream>
#include <vector>
#include <cmath>
#include <stdexcept>

class FibonacciHeapNode {
publc:
    int key;
    void* value;
    int degree;
    bool mark;
    FibonacciHeapNode* parent;
    FibonacciHeapNode* child;
    FibonacciHeapNode* left;
    FibonacciHeapNode* right;
    
    FibonacciHeapNode(int k, void* v = nullptr) : 
        key(k), value(v), degree(0), mark(false),
        parent(nullptr), child(nullptr), left(this), right(this) {}
};

class FibonacciHeap {
private:
    FibonacciHeapNode* minNode;
    int nodeCount;
    
    void linkNodes(FibonacciHeapNode* left, FibonacciHeapNode* right) {
        left->right->left = right;
        right->right = left->right;
        left->right = right;
        right->left = left;
    }
    
    void linkAsChild(FibonacciHeapNode* childNode, FibonacciHeapNode* parentNode) {
        // 从根链表移除子节点
        childNode->left->right = childNode->right;
        childNode->right->left = childNode->left;
        
        // 重置子节点引用
        childNode->parent = parentNode;
        childNode->mark = false;
        
        // 添加到父节点的子节点列表
        if (parentNode->child == nullptr) {
            parentNode->child = childNode;
            childNode->left = childNode;
            childNode->right = childNode;
        } else {
            linkNodes(parentNode->child, childNode);
        }
        
        parentNode->degree++;
    }
    
    void cut(FibonacciHeapNode* node, FibonacciHeapNode* parent) {
        parent->degree--;
        
        if (parent->child == node && node->right == node) {
            parent->child = nullptr;
        } else {
            parent->child = node->right;
            node->left->right = node->right;
            node->right->left = node->left;
        }
        
        linkNodes(minNode, node);
        node->parent = nullptr;
        node->mark = false;
        
        if (node->key < minNode->key) {
            minNode = node;
        }
    }
    
    void cascadingCut(FibonacciHeapNode* node) {
        FibonacciHeapNode* parent = node->parent;
        if (parent != nullptr) {
            if (!node->mark) {
                node->mark = true;
            } else {
                cut(node, parent);
                cascadingCut(parent);
            }
        }
    }
    
    void consolidate() {
        if (minNode == nullptr) return;
        
        int maxDegree = log2(nodeCount) + 1;
        std::vector<FibonacciHeapNode*> degreeTable(maxDegree + 2, nullptr);
        
        // 收集所有根节点
        std::vector<FibonacciHeapNode*> roots;
        FibonacciHeapNode* current = minNode;
        do {
            roots.push_back(current);
            current = current->right;
        } while (current != minNode);
        
        for (auto root : roots) {
            int degree = root->degree;
            while (degreeTable[degree] != nullptr) {
                FibonacciHeapNode* other = degreeTable[degree];
                if (root->key > other->key) {
                    std::swap(root, other);
                }
                
                linkAsChild(other, root);
                degreeTable[degree] = nullptr;
                degree++;
            }
            degreeTable[degree] = root;
        }
        
        minNode = nullptr;
        for (auto node : degreeTable) {
            if (node != nullptr) {
                if (minNode == nullptr) {
                    minNode = node;
                    node->left = node;
                    node->right = node;
                } else {
                    linkNodes(minNode, node);
                    if (node->key < minNode->key) {
                        minNode = node;
                    }
                }
            }
        }
    }
    
public:
    FibonacciHeap() : minNode(nullptr), nodeCount(0) {}
    
    bool isEmpty() const {
        return minNode == nullptr;
    }
    
    FibonacciHeapNode* insert(int key, void* value = nullptr) {
        FibonacciHeapNode* newNode = new FibonacciHeapNode(key, value);
        
        if (minNode == nullptr) {
            minNode = newNode;
        } else {
            linkNodes(minNode, newNode);
            if (newNode->key < minNode->key) {
                minNode = newNode;
            }
        }
        
        nodeCount++;
        return newNode;
    }
    
    FibonacciHeapNode* extractMin() {
        if (isEmpty()) return nullptr;
        
        FibonacciHeapNode* minNode = this->minNode;
        
        // 处理子节点
        if (minNode->child != nullptr) {
            FibonacciHeapNode* child = minNode->child;
            do {
                FibonacciHeapNode* nextChild = child->right;
                child->parent = nullptr;
                linkNodes(minNode, child);
                child = nextChild;
            } while (child != minNode->child);
        }
        
        // 从根链表移除
        minNode->left->right = minNode->right;
        minNode->right->left = minNode->left;
        
        if (minNode == minNode->right) {
            this->minNode = nullptr;
        } else {
            this->minNode = minNode->right;
            consolidate();
        }
        
        nodeCount--;
        return minNode;
    }
    
    void decreaseKey(FibonacciHeapNode* node, int newKey) {
        if (newKey > node->key) {
            throw std::invalid_argument("New key must be smaller than current key");
        }
        
        node->key = newKey;
        FibonacciHeapNode* parent = node->parent;
        
        if (parent == nullptr || parent->key <= node->key) {
            if (node->key < minNode->key) {
                minNode = node;
            }
        } else {
            cut(node, parent);
            cascadingCut(parent);
        }
    }
    
    void deleteNode(FibonacciHeapNode* node) {
        decreaseKey(node, INT_MIN);
        extractMin();
    }
    
    void merge(FibonacciHeap& otherHeap) {
        if (otherHeap.isEmpty()) return;
        if (isEmpty()) {
            minNode = otherHeap.minNode;
            nodeCount = otherHeap.nodeCount;
            return;
        }
        
        linkNodes(minNode, otherHeap.minNode);
        if (otherHeap.minNode->key < minNode->key) {
            minNode = otherHeap.minNode;
        }
        
        nodeCount += otherHeap.nodeCount;
    }
    
    FibonacciHeapNode* getMin() const {
        return minNode;
    }
    
    int size() const {
        return nodeCount;
    }
    
    ~FibonacciHeap() {
        // 析构函数实现，释放所有节点内存
        while (!isEmpty()) {
            delete extractMin();
        }
    }
};
'''

# ================================
# Java 代码等效实现注释版 - 块状链表
'''
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;

class Block {
    List<Object> data;
    int maxSize;
    Block next;
    
    Block(int maxSize) {
        this.data = new ArrayList<>();
        this.maxSize = maxSize;
        this.next = null;
    }
}

public class UnrolledLinkedList implements Iterable<Object> {
    private Block head;
    private Block tail;
    private int blockSize;
    private int size;
    
    public UnrolledLinkedList(int blockSize) {
        this.head = new Block(blockSize);
        this.tail = this.head;
        this.blockSize = blockSize;
        this.size = 0;
    }
    
    public UnrolledLinkedList() {
        this(16); // 默认块大小
    }
    
    public boolean isEmpty() {
        return size == 0;
    }
    
    private Pair<Block, Integer> getBlockAndIndex(int index) {
        if (index < 0 || index >= size) {
            throw new IndexOutOfBoundsException("Index: " + index + ", Size: " + size);
        }
        
        Block currentBlock = head;
        while (currentBlock.data.size() <= index) {
            index -= currentBlock.data.size();
            currentBlock = currentBlock.next;
        }
        
        return new Pair<>(currentBlock, index);
    }
    
    public Object get(int index) {
        Pair<Block, Integer> result = getBlockAndIndex(index);
        return result.first.data.get(result.second);
    }
    
    public void set(int index, Object value) {
        Pair<Block, Integer> result = getBlockAndIndex(index);
        result.first.data.set(result.second, value);
    }
    
    public void insert(int index, Object value) {
        if (index < 0 || index > size) {
            throw new IndexOutOfBoundsException("Index: " + index + ", Size: " + size);
        }
        
        if (isEmpty()) {
            head.data.add(value);
            size++;
            return;
        }
        
        Block currentBlock = head;
        Block prevBlock = null;
        int currentIndex = 0;
        
        while (currentBlock != null && currentIndex + currentBlock.data.size() <= index) {
            currentIndex += currentBlock.data.size();
            prevBlock = currentBlock;
            currentBlock = currentBlock.next;
        }
        
        Block targetBlock;
        int blockIndex;
        
        if (currentBlock == null) {
            targetBlock = new Block(blockSize);
            prevBlock.next = targetBlock;
            tail = targetBlock;
            blockIndex = 0;
        } else {
            targetBlock = currentBlock;
            blockIndex = index - currentIndex;
        }
        
        targetBlock.data.add(blockIndex, value);
        size++;
        
        if (targetBlock.data.size() > blockSize) {
            splitBlock(targetBlock);
        }
    }
    
    private void splitBlock(Block block) {
        Block newBlock = new Block(blockSize);
        int splitPoint = block.data.size() / 2;
        
        // 移动后半部分数据
        for (int i = splitPoint; i < block.data.size(); i++) {
            newBlock.data.add(block.data.get(i));
        }
        // 删除原块中的后半部分
        for (int i = block.data.size() - 1; i >= splitPoint; i--) {
            block.data.remove(i);
        }
        
        // 插入新块
        newBlock.next = block.next;
        block.next = newBlock;
        
        if (block == tail) {
            tail = newBlock;
        }
    }
    
    public void append(Object value) {
        if (tail.data.size() >= blockSize) {
            Block newBlock = new Block(blockSize);
            tail.next = newBlock;
            tail = newBlock;
        }
        tail.data.add(value);
        size++;
    }
    
    public void prepend(Object value) {
        if (head.data.size() >= blockSize) {
            Block newBlock = new Block(blockSize);
            newBlock.next = head;
            head = newBlock;
        }
        head.data.add(0, value);
        size++;
    }
    
    public Object delete(int index) {
        Pair<Block, Integer> result = getBlockAndIndex(index);
        Block block = result.first;
        int blockIndex = result.second;
        
        Object value = block.data.remove(blockIndex);
        size--;
        
        if (size == 0) {
            head.data.clear();
            tail = head;
            return value;
        }
        
        if (block != head && block.data.size() < blockSize / 2) {
            mergeOrRedistribute(block);
        }
        
        return value;
    }
    
    private void mergeOrRedistribute(Block block) {
        // 找到前一个块
        Block prevBlock = head;
        while (prevBlock != null && prevBlock.next != block) {
            prevBlock = prevBlock.next;
        }
        
        // 尝试从下一个块借
        if (block.next != null && block.next.data.size() > blockSize / 2) {
            block.data.add(block.next.data.remove(0));
        }
        // 尝试从前一个块借
        else if (prevBlock != null && prevBlock.data.size() > blockSize / 2) {
            block.data.add(0, prevBlock.data.remove(prevBlock.data.size() - 1));
        }
        // 合并到前一个块
        else if (prevBlock != null) {
            prevBlock.data.addAll(block.data);
            prevBlock.next = block.next;
            if (block == tail) {
                tail = prevBlock;
            }
        }
        // 合并到下一个块
        else if (block.next != null) {
            block.next.data.addAll(0, block.data);
            head = block.next;
        }
    }
    
    public void insertRange(int index, List<Object> values) {
        for (int i = 0; i < values.size(); i++) {
            insert(index + i, values.get(i));
        }
    }
    
    public List<Object> getRange(int start, int end) {
        List<Object> result = new ArrayList<>();
        for (int i = start; i < end; i++) {
            result.add(get(i));
        }
        return result;
    }
    
    public void deleteRange(int start, int end) {
        for (int i = 0; i < end - start; i++) {
            delete(start);
        }
    }
    
    public int size() {
        return size;
    }
    
    @Override
    public Iterator<Object> iterator() {
        return new Iterator<Object>() {
            private Block currentBlock = head;
            private int currentIndex = 0;
            private int visited = 0;
            
            @Override
            public boolean hasNext() {
                return visited < size;
            }
            
            @Override
            public Object next() {
                if (!hasNext()) {
                    throw new java.util.NoSuchElementException();
                }
                
                while (currentIndex >= currentBlock.data.size()) {
                    currentBlock = currentBlock.next;
                    currentIndex = 0;
                }
                
                Object value = currentBlock.data.get(currentIndex);
                currentIndex++;
                visited++;
                return value;
            }
        };
    }
    
    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder("[");
        boolean first = true;
        for (Object obj : this) {
            if (!first) {
                sb.append(", ");
            }
            sb.append(obj);
            first = false;
        }
        sb.append("]");
        return sb.toString();
    }
    
    // 辅助类
    private static class Pair<K, V> {
        K first;
        V second;
        
        Pair(K first, V second) {
            this.first = first;
            this.second = second;
        }
    }
}
'''

===============================================

文件: algorithm1.cpp
===============================================
#include <iostream>
#include <vector>
#include <algorithm>
#include <cmath>
#include <stdexcept>
#include <memory>
#include <limits>
#include <queue>
#include <tuple>
#include <string>
#include <unordered_set>
#include <unordered_map>
#include <functional>

/**
 * C++版本综合算法与数据结构实现
 * 包含：
 * 1. 平面分治 (Closest Pair of Points)
 * 2. 棋盘模拟 (Game of Life)
 * 3. 间隔打表 (Sparse Table)
 * 4. 事件排序 (Time Sweep)
 * 5. 差分驱动模拟 (Difference Array)
 * 
 * 时间复杂度分析：
 * - 平面分治: O(n log n)
 * - 棋盘模拟: O(m*n)
 * - 间隔打表: O(n log n) 预处理, O(1) 查询
 * - 事件排序: O(n log n)
 * - 差分驱动: O(1) 区间更新, O(n) 获取结果
 */

// ================================
// 1. 平面分治 - 最近点对问题
// ================================

/**
 * 平面点类，表示二维平面上的一个点
 */
struct Point {
    double x, y;
    
    /**
     * 构造函数
     * @param x 点的x坐标
     * @param y 点的y坐标
     */
    Point(double x = 0, double y = 0) : x(x), y(y) {}
    
    /**
     * 计算与另一个点的欧几里得距离
     * @param other 另一个点
     * @return 两点间的距离
     */
    double distanceTo(const Point& other) const {
        double dx = this->x - other.x;
        double dy = this->y - other.y;
        return std::sqrt(dx * dx + dy * dy);
    }
    
    /**
     * 按x坐标排序的比较函数
     * @param other 另一个点
     * @return 如果当前点的x坐标小于另一个点，则返回true
     */
    bool operator<(const Point& other) const {
        return x < other.x;
    }
    
    /**
     * 输出运算符重载
     */
    friend std::ostream& operator<<(std::ostream& os, const Point& p) {
        return os << "Point(" << p.x << ", " << p.y << ")";
    }
};

/**
 * 点对距离结果类，存储最近点对及其距离
 */
struct PairDistance {
    double distance;  // 两点间距离
    Point p1, p2;     // 两个点
    
    /**
     * 构造函数
     * @param distance 距离
     * @param p1 第一个点
     * @param p2 第二个点
     */
    PairDistance(double distance = 0, Point p1 = Point(), Point p2 = Point()) 
        : distance(distance), p1(p1), p2(p2) {}
};

/**
 * 按y坐标排序的比较函数
 * @param a 第一个点
 * @param b 第二个点
 * @return 如果a的y坐标小于b的y坐标，则返回true
 */
bool compareByY(const Point& a, const Point& b) {
    return a.y < b.y;
}

/**
 * 暴力法计算最近点对
 * 时间复杂度：O(n^2)
 * @param points 点的集合
 * @return 最近点对及其距离
 */
PairDistance bruteForceClosestPair(const std::vector<Point>& points) {
    int n = points.size();
    double minDist = std::numeric_limits<double>::max();
    Point p1, p2;
    
    for (int i = 0; i < n; i++) {
        for (int j = i + 1; j < n; j++) {
            double dist = points[i].distanceTo(points[j]);
            if (dist < minDist) {
                minDist = dist;
                p1 = points[i];
                p2 = points[j];
            }
        }
    }
    
    return PairDistance(minDist, p1, p2);
}

/**
 * 计算带内（跨越中线的区域）的最近点对
 * 时间复杂度：O(n) - 由于每个点最多检查常数个点
 * @param strip 带内的点集
 * @param currentMin 当前已知的最小距离
 * @return 带内的最近点对
 */
PairDistance stripClosest(std::vector<Point>& strip, PairDistance currentMin) {
    double minDist = currentMin.distance;
    Point p1 = currentMin.p1;
    Point p2 = currentMin.p2;
    
    // 按y坐标排序已经完成
    int size = strip.size();
    
    // 对于带内的每个点，只需要检查后面y坐标相差不超过min_dist的点
    // 理论上只需要检查最多6个点，这是平面分治算法的关键优化点
    for (int i = 0; i < size; i++) {
        for (int j = i + 1; j < size && (strip[j].y - strip[i].y) < minDist; j++) {
            double dist = strip[i].distanceTo(strip[j]);
            if (dist < minDist) {
                minDist = dist;
                p1 = strip[i];
                p2 = strip[j];
            }
        }
    }
    
    return PairDistance(minDist, p1, p2);
}

/**
 * 递归实现平面分治算法
 * @param pointsSortedByX 按x坐标排序的点集
 * @param pointsSortedByY 按y坐标排序的点集
 * @return 最近点对及其距离
 */
PairDistance closestPairRecursive(std::vector<Point>& pointsSortedByX, std::vector<Point>& pointsSortedByY) {
    int n = pointsSortedByX.size();
    
    // 基本情况：小于等于3个点，使用暴力法
    if (n <= 3) {
        return bruteForceClosestPair(pointsSortedByX);
    }
    
    // 分治：将点集分为左右两部分
    int mid = n / 2;
    Point midPoint = pointsSortedByX[mid];
    
    // 分割y排序的点列表
    std::vector<Point> leftPointsY, rightPointsY;
    
    for (const Point& p : pointsSortedByY) {
        if (p.x <= midPoint.x) {
            leftPointsY.push_back(p);
        } else {
            rightPointsY.push_back(p);
        }
    }
    
    // 递归求解左右两部分的最近点对
    std::vector<Point> leftPointsX(pointsSortedByX.begin(), pointsSortedByX.begin() + mid);
    std::vector<Point> rightPointsX(pointsSortedByX.begin() + mid, pointsSortedByX.end());
    
    PairDistance leftResult = closestPairRecursive(leftPointsX, leftPointsY);
    PairDistance rightResult = closestPairRecursive(rightPointsX, rightPointsY);
    
    // 合并：取左右两部分中的最小距离
    PairDistance minResult = (leftResult.distance <= rightResult.distance) 
        ? leftResult : rightResult;
    
    // 带内搜索：查找跨越中线的点对
    // 构建带内的点列表，只考虑x坐标在中线附近min_dist范围内的点
    std::vector<Point> strip;
    for (const Point& p : pointsSortedByY) {
        if (std::abs(p.x - midPoint.x) < minResult.distance) {
            strip.push_back(p);
        }
    }
    
    // 在带内查找可能的更近点对
    PairDistance stripResult = stripClosest(strip, minResult);
    
    // 比较并返回全局最小距离
    return (stripResult.distance < minResult.distance) ? stripResult : minResult;
}

/**
 * 平面分治算法主函数 - 最近点对问题
 * 时间复杂度：O(n log n)
 * 空间复杂度：O(n)
 * @param points 点的集合
 * @return 最近点对及其距离
 * @throws std::invalid_argument 当输入无效时抛出异常
 */
PairDistance closestPair(std::vector<Point> points) {
    if (points.empty()) {
        throw std::invalid_argument("输入点列表不能为空");
    }
    if (points.size() < 2) {
        throw std::invalid_argument("至少需要两个点来计算距离");
    }
    
    // 按x坐标排序
    std::vector<Point> pointsSortedByX = points;
    std::sort(pointsSortedByX.begin(), pointsSortedByX.end());
    
    // 按y坐标排序，用于带内搜索
    std::vector<Point> pointsSortedByY = points;
    std::sort(pointsSortedByY.begin(), pointsSortedByY.end(), compareByY);
    
    // 调用递归函数
    return closestPairRecursive(pointsSortedByX, pointsSortedByY);
}

// ================================
// 2. 棋盘模拟 - 生命游戏
// ================================

/**
 * 生命游戏模拟器类
 * 实现康威生命游戏的模拟
 */
class GameOfLife {
private:
    std::vector<std::vector<int>> board;  // 棋盘
    int rows;                             // 行数
    int cols;                             // 列数
    
    /**
     * 计算指定位置的邻居数量
     * @param board 当前棋盘
     * @param row 行索引
     * @param col 列索引
     * @return 邻居数量
     */
    int countNeighbors(const std::vector<std::vector<int>>& board, int row, int col) const {
        int neighbors = 0;
        // 八个方向的偏移
        std::vector<std::pair<int, int>> directions = {
            {-1, -1}, {-1, 0}, {-1, 1},
            {0, -1},           {0, 1},
            {1, -1},  {1, 0}, {1, 1}
        };
        
        for (const auto& dir : directions) {
            int r = row + dir.first;
            int c = col + dir.second;
            
            // 检查边界并计数
            if (r >= 0 && r < rows && c >= 0 && c < cols) {
                // 注意：对于原地版本，我们需要考虑标记后的状态
                // 1和2表示原始状态为活细胞（1：保持活，2：将死亡）
                if (board[r][c] == 1 || board[r][c] == 2) {
                    neighbors++;
                }
            }
        }
        
        return neighbors;
    }
    
public:
    /**
     * 构造函数
     * @param initialBoard 初始棋盘状态
     * @throws std::invalid_argument 当输入棋盘为空时抛出异常
     */
    GameOfLife(const std::vector<std::vector<int>>& initialBoard) {
        if (initialBoard.empty() || initialBoard[0].empty()) {
            throw std::invalid_argument("输入棋盘不能为空");
        }
        
        // 深拷贝输入棋盘
        this->rows = initialBoard.size();
        this->cols = initialBoard[0].size();
        this->board.resize(rows, std::vector<int>(cols));
        
        for (int i = 0; i < rows; i++) {
            for (int j = 0; j < cols; j++) {
                this->board[i][j] = initialBoard[i][j];
            }
        }
    }
    
    /**
     * 标准方法计算下一代状态（使用额外空间）
     * 时间复杂度：O(m*n)
     * 空间复杂度：O(m*n)
     * @return 更新后的棋盘状态
     */
    std::vector<std::vector<int>> nextGenerationStandard() {
        // 创建新棋盘存储下一代状态
        std::vector<std::vector<int>> nextBoard(rows, std::vector<int>(cols, 0));
        
        // 计算每个细胞的下一代状态
        for (int i = 0; i < rows; i++) {
            for (int j = 0; j < cols; j++) {
                int neighbors = countNeighbors(this->board, i, j);
                
                // 应用生命游戏规则
                if (this->board[i][j] == 1) {  // 活细胞
                    if (neighbors < 2 || neighbors > 3) {
                        nextBoard[i][j] = 0;  // 死亡：人口稀少或过度拥挤
                    } else {
                        nextBoard[i][j] = 1;  // 存活
                    }
                } else {  // 死细胞
                    if (neighbors == 3) {
                        nextBoard[i][j] = 1;  // 繁殖
                    }
                }
            }
        }
        
        // 更新当前棋盘
        this->board = nextBoard;
        return this->board;
    }
    
    /**
     * 原地计算下一代状态（节省空间）
     * 时间复杂度：O(m*n)
     * 空间复杂度：O(1)
     * @return 更新后的棋盘状态
     */
    std::vector<std::vector<int>> nextGenerationInplace() {
        // 编码规则：
        // 0: 死细胞 -> 死细胞
        // 1: 活细胞 -> 活细胞
        // 2: 活细胞 -> 死细胞
        // 3: 死细胞 -> 活细胞
        
        for (int i = 0; i < rows; i++) {
            for (int j = 0; j < cols; j++) {
                int neighbors = countNeighbors(this->board, i, j);
                
                if (this->board[i][j] == 1) {  // 活细胞
                    if (neighbors < 2 || neighbors > 3) {
                        this->board[i][j] = 2;  // 标记为将死亡
                    }
                } else {  // 死细胞
                    if (neighbors == 3) {
                        this->board[i][j] = 3;  // 标记为将复活
                    }
                }
            }
        }
        
        // 解码：将标记转换回0和1
        for (int i = 0; i < rows; i++) {
            for (int j = 0; j < cols; j++) {
                this->board[i][j] %= 2;  // 2 -> 0, 3 -> 1
            }
        }
        
        return this->board;
    }
    
    /**
     * 模拟多代生命游戏
     * @param generations 模拟的代数
     * @param inplace 是否使用原地算法
     * @return 模拟后的棋盘状态
     */
    std::vector<std::vector<int>> simulate(int generations, bool inplace) {
        if (generations <= 0) {
            return getBoard();
        }
        
        for (int i = 0; i < generations; i++) {
            if (inplace) {
                nextGenerationInplace();
            } else {
                nextGenerationStandard();
            }
        }
        
        return getBoard();
    }
    
    /**
     * 获取当前棋盘状态的副本
     * @return 棋盘状态的深拷贝
     */
    std::vector<std::vector<int>> getBoard() const {
        // 返回深拷贝，避免外部修改
        std::vector<std::vector<int>> copy(rows, std::vector<int>(cols));
        for (int i = 0; i < rows; i++) {
            for (int j = 0; j < cols; j++) {
                copy[i][j] = this->board[i][j];
            }
        }
        return copy;
    }
    
    /**
     * 打印当前棋盘状态
     */
    void printBoard() const {
        for (const auto& row : board) {
            for (int cell : row) {
                std::cout << (cell == 1 ? '█' : ' ') << ' ';
            }
            std::cout << std::endl;
        }
        std::cout << std::endl;
    }
};

// ================================
// 3. 间隔打表 - 稀疏表
// ================================

/**
 * 稀疏表（Sparse Table）类
 * 用于高效地回答区间查询问题，如区间最小值、最大值等
 * 预处理时间复杂度：O(n log n)
 * 查询时间复杂度：O(1)
 */
class SparseTable {
private:
    std::vector<int> data;                    // 原始数据
    std::vector<std::vector<int>> st;         // 稀疏表结构
    std::vector<int> logTable;                // 预计算的log表
    
    // 用于区间查询的函数类型
    using MergeFunc = std::function<int(int, int)>;
    MergeFunc mergeFunc;                      // 区间合并函数
    
    /**
     * 构建log表，用于快速计算区间长度对应的k值
     * @return log表
     */
    std::vector<int> buildLogTable() {
        int n = data.size();
        std::vector<int> logTable(n + 1, 0);
        for (int i = 2; i <= n; i++) {
            logTable[i] = logTable[i / 2] + 1;
        }
        return logTable;
    }
    
    /**
     * 构建稀疏表
     * @return 稀疏表结构
     */
    std::vector<std::vector<int>> buildSparseTable() {
        int n = data.size();
        int kMax = logTable[n] + 1;
        std::vector<std::vector<int>> st(kMax, std::vector<int>(n));
        
        // 初始化k=0的情况（长度为1的区间）
        for (int i = 0; i < n; i++) {
            st[0][i] = data[i];
        }
        
        // 动态规划构建其他k值
        // st[k][i] 表示从i开始，长度为2^k的区间的合并结果
        for (int k = 1; (1 << k) <= n; k++) {
            for (int i = 0; i + (1 << k) <= n; i++) {
                // 合并两个长度为2^(k-1)的区间
                st[k][i] = mergeFunc(
                    st[k-1][i],                     // 左侧区间
                    st[k-1][i + (1 << (k-1))]        // 右侧区间
                );
            }
        }
        
        return st;
    }
    
public:
    /**
     * 构造函数
     * @param data 原始数据数组
     * @param func 区间合并函数（默认使用最小值函数）
     * @throws std::invalid_argument 当输入数据为空时抛出异常
     */
    SparseTable(const std::vector<int>& data, MergeFunc func) 
        : data(data), mergeFunc(func) {
        if (data.empty()) {
            throw std::invalid_argument("输入数据不能为空");
        }
        
        this->logTable = buildLogTable();
        this->st = buildSparseTable();
    }
    
    /**
     * 默认构造函数，使用最小值作为合并函数
     * @param data 原始数据数组
     */
    SparseTable(const std::vector<int>& data) 
        : SparseTable(data, [](int a, int b) { return std::min(a, b); }) {}
    
    /**
     * 查询区间[l, r]的合并结果
     * 时间复杂度：O(1)
     * @param l 区间左端点（包含）
     * @param r 区间右端点（包含）
     * @return 区间合并结果
     * @throws std::invalid_argument 当区间无效时抛出异常
     */
    int queryRange(int l, int r) {
        // 检查边界
        if (l < 0 || r >= data.size() || l > r) {
            throw std::invalid_argument("无效的区间边界: [" + std::to_string(l) + ", " + std::to_string(r) + "]");
        }
        
        // 计算区间长度
        int length = r - l + 1;
        // 找到最大的k，使得2^k <= length
        int k = logTable[length];
        
        // 查询两个重叠的子区间并合并结果
        // 第一个区间从l开始，长度为2^k
        // 第二个区间从r-2^k+1开始，长度为2^k
        // 两个区间的并集正好覆盖[l, r]
        return mergeFunc(
            st[k][l],
            st[k][r - (1 << k) + 1]
        );
    }
    
    /**
     * 批量查询多个区间
     * @param queries 查询的区间列表
     * @return 查询结果列表
     */
    std::vector<int> batchQuery(const std::vector<std::pair<int, int>>& queries) {
        std::vector<int> results;
        results.reserve(queries.size());
        for (const auto& query : queries) {
            results.push_back(queryRange(query.first, query.second));
        }
        return results;
    }
    
    /**
     * 检查区间内所有元素是否相同
     * @param l 区间左端点
     * @param r 区间右端点
     * @return 如果区间内所有元素相同则返回true
     */
    bool isRangeAllSame(int l, int r) {
        if (l == r) {
            return true;
        }
        return queryRange(l, r) == data[l];
    }
    
    /**
     * 获取区间的极值（取决于mergeFunc）
     * @param l 区间左端点
     * @param r 区间右端点
     * @return 区间极值
     */
    int getRangeExtreme(int l, int r) {
        return queryRange(l, r);
    }
};

// ================================
// 4. 事件排序 - 扫描线算法
// ================================

/**
 * 事件排序（扫描线）算法实现类
 */
class EventSweep {
public:
    /**
     * 区间重叠结果类
     */
    struct OverlapResult {
        int maxOverlap;                      // 最大重叠次数
        std::vector<std::pair<int, int>> overlappingIntervals;  // 重叠的区间
        
        OverlapResult(int maxOverlap = 0, 
                     const std::vector<std::pair<int, int>>& overlappingIntervals = {}) 
            : maxOverlap(maxOverlap), overlappingIntervals(overlappingIntervals) {}
    };
    
    /**
     * 区间事件类，用于排序
     */
    struct Event {
        int pos;    // 事件位置
        int type;   // 1表示开始，-1表示结束
        int index;  // 对应的区间索引
        
        Event(int pos = 0, int type = 0, int index = 0) 
            : pos(pos), type(type), index(index) {}
        
        // 按位置排序，当位置相同时，结束事件（type=-1）优先
        bool operator<(const Event& other) const {
            if (this->pos != other.pos) {
                return this->pos < other.pos;
            }
            return this->type < other.type;  // 结束事件（type=-1）优先于开始事件（type=1）
        }
    };
    
    /**
     * 计算区间集合中的最大重叠次数和重叠的区间
     * 时间复杂度：O(n log n)，主要来自排序
     * 空间复杂度：O(n)
     * @param intervals 区间集合，每个区间表示为[start, end]
     * @return 重叠结果
     * @throws std::invalid_argument 当区间无效时抛出异常
     */
    static OverlapResult intervalOverlap(const std::vector<std::pair<int, int>>& intervals) {
        if (intervals.empty()) {
            return OverlapResult(0, {});
        }
        
        // 创建事件点列表
        std::vector<Event> events;
        for (int i = 0; i < intervals.size(); i++) {
            int start = intervals[i].first;
            int end = intervals[i].second;
            if (start > end) {
                throw std::invalid_argument("无效的区间: [" + std::to_string(start) + ", " + std::to_string(end) + "]");
            }
            events.emplace_back(start, 1, i);  // 开始事件
            events.emplace_back(end, -1, i);   // 结束事件
        }
        
        // 按位置排序事件，当位置相同时，结束事件优先
        std::sort(events.begin(), events.end());
        
        int currentOverlap = 0;
        int maxOverlap = 0;
        std::unordered_set<int> activeIntervals;      // 当前活动的区间索引集合
        std::unordered_set<int> maxOverlapIntervalIndices;  // 达到最大重叠时的区间索引集合
        
        // 扫描事件
        for (const Event& event : events) {
            // 更新当前重叠数量
            currentOverlap += event.type;
            
            // 更新活动区间列表
            if (event.type == 1) {
                activeIntervals.insert(event.index);
            } else {
                activeIntervals.erase(event.index);
            }
            
            // 更新最大重叠
            if (currentOverlap > maxOverlap) {
                maxOverlap = currentOverlap;
                maxOverlapIntervalIndices = activeIntervals;
            }
        }
        
        // 收集重叠的区间
        std::vector<std::pair<int, int>> overlappingIntervals;
        for (int idx : maxOverlapIntervalIndices) {
            overlappingIntervals.push_back(intervals[idx]);
        }
        
        return OverlapResult(maxOverlap, overlappingIntervals);
    }
    
    /**
     * 矩形事件类，用于矩形面积计算
     */
    struct RectangleEvent {
        int x;       // x坐标
        bool isStart; // 是否是矩形的左边界
        int y1, y2;  // y区间
        
        RectangleEvent(int x = 0, bool isStart = false, int y1 = 0, int y2 = 0) 
            : x(x), isStart(isStart), y1(y1), y2(y2) {}
        
        // 按x坐标排序
        bool operator<(const RectangleEvent& other) const {
            return this->x < other.x;
        }
    };
    
    /**
     * 计算多个矩形覆盖的总面积（去重）
     * 时间复杂度：O(n log n)
     * 空间复杂度：O(n)
     * @param rectangles 矩形集合，每个矩形表示为(x1, y1, x2, y2)
     * @return 覆盖的总面积
     * @throws std::invalid_argument 当矩形无效时抛出异常
     */
    static int rectangleArea(const std::vector<std::tuple<int, int, int, int>>& rectangles) {
        if (rectangles.empty()) {
            return 0;
        }
        
        // 创建垂直边事件
        std::vector<RectangleEvent> events;
        std::unordered_set<int> xCoords;
        
        for (const auto& rect : rectangles) {
            int x1 = std::get<0>(rect);
            int y1 = std::get<1>(rect);
            int x2 = std::get<2>(rect);
            int y2 = std::get<3>(rect);
            
            if (x1 >= x2 || y1 >= y2) {
                throw std::invalid_argument("无效的矩形: [" + std::to_string(x1) + ", " + 
                                          std::to_string(y1) + ", " + std::to_string(x2) + ", " + 
                                          std::to_string(y2) + "]");
            }
            
            // 添加垂直线事件
            events.emplace_back(x1, true, y1, y2);  // 左边界（开始）
            events.emplace_back(x2, false, y1, y2); // 右边界（结束）
            xCoords.insert(x1);
            xCoords.insert(x2);
        }
        
        // 按x坐标排序事件
        std::sort(events.begin(), events.end());
        
        std::vector<int> sortedX(xCoords.begin(), xCoords.end());
        std::sort(sortedX.begin(), sortedX.end());
        
        std::vector<std::pair<int, int>> activeIntervals;  // 当前活动的y区间
        int area = 0;
        int prevX = -1;
        bool hasPrev = false;
        
        // 扫描事件
        for (const RectangleEvent& event : events) {
            // 计算当前扫描线和前一条扫描线之间的面积
            if (hasPrev && event.x > prevX && !activeIntervals.empty()) {
                // 计算当前活动的y区间的总长度
                int activeLength = mergeAndCalculateLength(activeIntervals);
                // 面积 = 宽度 * 高度
                area += (event.x - prevX) * activeLength;
            }
            
            // 更新活动区间
            if (event.isStart) {
                activeIntervals.emplace_back(event.y1, event.y2);
            } else {
                // 移除对应的区间
                activeIntervals.erase(
                    std::remove_if(activeIntervals.begin(), activeIntervals.end(),
                                 [&](const std::pair<int, int>& interval) {
                                     return interval.first == event.y1 && interval.second == event.y2;
                                 }),
                    activeIntervals.end()
                );
            }
            
            prevX = event.x;
            hasPrev = true;
        }
        
        return area;
    }
    
private:
    /**
     * 合并重叠的区间并计算总长度
     * @param intervals 区间集合
     * @return 合并后的总长度
     */
    static int mergeAndCalculateLength(std::vector<std::pair<int, int>>& intervals) {
        if (intervals.empty()) {
            return 0;
        }
        
        // 按起始位置排序
        std::sort(intervals.begin(), intervals.end());
        
        std::vector<std::pair<int, int>> merged;
        merged.push_back(intervals[0]);
        
        for (size_t i = 1; i < intervals.size(); i++) {
            const auto& current = intervals[i];
            auto& last = merged.back();
            
            if (current.first <= last.second) {  // 有重叠
                // 合并区间
                int newStart = last.first;
                int newEnd = std::max(last.second, current.second);
                merged.back() = {newStart, newEnd};
            } else {
                merged.push_back(current);
            }
        }
        
        // 计算总长度
        int totalLength = 0;
        for (const auto& interval : merged) {
            totalLength += interval.second - interval.first;
        }
        
        return totalLength;
    }
};

// ================================
// 5. 差分驱动模拟 - 差分数组
// ================================

/**
 * 差分数组类
 * 用于高效地进行区间更新操作
 * 区间更新时间复杂度：O(1)
 * 获取结果时间复杂度：O(n)
 */
class DifferenceArray {
private:
    std::vector<int> diff;  // 差分数组
    int size;              // 数组大小
    
public:
    /**
     * 构造函数，创建指定大小的差分数组（初始化为全0）
     * @param size 数组大小
     * @throws std::invalid_argument 当大小无效时抛出异常
     */
    DifferenceArray(int size) {
        if (size <= 0) {
            throw std::invalid_argument("数组大小必须为正数");
        }
        this->size = size;
        this->diff.resize(size, 0);  // 初始化为全0数组的差分数组
    }
    
    /**
     * 构造函数，从初始数组构建差分数组
     * @param initialArray 初始数组
     * @throws std::invalid_argument 当初始数组为空时抛出异常
     */
    DifferenceArray(const std::vector<int>& initialArray) {
        if (initialArray.empty()) {
            throw std::invalid_argument("初始数组不能为空");
        }
        
        this->size = initialArray.size();
        // 从初始数组构建差分数组
        this->diff.resize(size);
        this->diff[0] = initialArray[0];
        for (int i = 1; i < size; i++) {
            this->diff[i] = initialArray[i] - initialArray[i-1];
        }
    }
    
    /**
     * 对区间[l, r]加上值val
     * 时间复杂度：O(1)
     * @param l 区间左端点（包含）
     * @param r 区间右端点（包含）
     * @param val 要加的值
     * @throws std::invalid_argument 当区间无效时抛出异常
     */
    void rangeAdd(int l, int r, int val) {
        // 检查边界
        if (l < 0 || r >= size || l > r) {
            throw std::invalid_argument("无效的区间边界: [" + std::to_string(l) + ", " + std::to_string(r) + "]");
        }
        
        // 在差分数组上进行标记
        diff[l] += val;
        if (r + 1 < size) {
            diff[r + 1] -= val;
        }
    }
    
    /**
     * 获取差分数组对应的原始数组
     * 时间复杂度：O(n)
     * @return 原始数组
     */
    std::vector<int> getResult() {
        std::vector<int> res(size);
        res[0] = diff[0];
        
        // 前缀和恢复原始数组
        for (int i = 1; i < size; i++) {
            res[i] = res[i-1] + diff[i];
        }
        
        return res;
    }
    
    /**
     * 获取差分数组的副本
     * @return 差分数组副本
     */
    std::vector<int> getDifferenceArray() const {
        return diff;  // 返回副本
    }
    
    /**
     * 执行多个区间更新操作
     * @param updates 更新操作列表，每个更新为(l, r, val)
     */
    void multipleRangeUpdates(const std::vector<std::tuple<int, int, int>>& updates) {
        for (const auto& update : updates) {
            rangeAdd(std::get<0>(update), std::get<1>(update), std::get<2>(update));
        }
    }
    
    /**
     * 重置差分数组为全0
     */
    void reset() {
        std::fill(diff.begin(), diff.end(), 0);
    }
};

// ================================
// 主函数，用于测试各种算法
// ================================

/**
 * 测试函数：打印算法测试结果
 */
void testAlgorithms() {
    std::cout << "=== C++高级算法实现测试 ===" << std::endl;
    
    // 测试平面分治算法 - 最近点对
    std::cout << "\n=== 测试平面分治算法 - 最近点对 ===" << std::endl;
    std::vector<Point> points = {Point(0, 0), Point(3, 0), Point(0, 4), Point(1, 1), Point(5, 5), Point(4, 4)};
    try {
        PairDistance result = closestPair(points);
        std::cout << "最小距离: " << result.distance << std::endl;
        std::cout << "最近点对: " << result.p1 << " 和 " << result.p2 << std::endl;
    } catch (const std::exception& e) {
        std::cerr << "错误: " << e.what() << std::endl;
    }
    
    // 测试生命游戏
    std::cout << "\n=== 测试生命游戏 ===" << std::endl;
    std::vector<std::vector<int>> initialBoard = {
        {0, 1, 0},
        {0, 1, 0},
        {0, 1, 0}
    };
    try {
        GameOfLife game(initialBoard);
        std::cout << "初始状态:" << std::endl;
        game.printBoard();
        
        std::cout << "使用原地算法模拟下一代:" << std::endl;
        game.nextGenerationInplace();
        game.printBoard();
        
        std::cout << "使用标准算法模拟下一代:" << std::endl;
        game.nextGenerationStandard();
        game.printBoard();
    } catch (const std::exception& e) {
        std::cerr << "错误: " << e.what() << std::endl;
    }
    
    // 测试稀疏表
    std::cout << "\n=== 测试稀疏表（区间最小值查询） ===" << std::endl;
    std::vector<int> data = {1, 3, 5, 7, 9, 11, 13, 15};
    try {
        SparseTable stMin(data);  // 默认使用最小值
        
        std::cout << "区间[1, 4]的最小值: " << stMin.queryRange(1, 4) << std::endl;
        std::cout << "区间[3, 6]的最小值: " << stMin.queryRange(3, 6) << std::endl;
        
        // 测试最大值查询
        SparseTable stMax(data, [](int a, int b) { return std::max(a, b); });
        std::cout << "区间[1, 4]的最大值: " << stMax.queryRange(1, 4) << std::endl;
    } catch (const std::exception& e) {
        std::cerr << "错误: " << e.what() << std::endl;
    }
    
    // 测试事件排序算法
    std::cout << "\n=== 测试事件排序算法 - 区间重叠 ===" << std::endl;
    std::vector<std::pair<int, int>> intervals = { {1, 3}, {2, 5}, {4, 8}, {6, 10}, {7, 12} };
    try {
        EventSweep::OverlapResult overlapResult = EventSweep::intervalOverlap(intervals);
        std::cout << "最大重叠次数: " << overlapResult.maxOverlap << std::endl;
        std::cout << "重叠的区间: " << std::endl;
        for (const auto& interval : overlapResult.overlappingIntervals) {
            std::cout << "[" << interval.first << ", " << interval.second << "]" << std::endl;
        }
    } catch (const std::exception& e) {
        std::cerr << "错误: " << e.what() << std::endl;
    }
    
    // 测试差分数组
    std::cout << "\n=== 测试差分数组 ===" << std::endl;
    try {
        DifferenceArray diffArray(10);
        
        // 对区间[2, 5]加上3
        diffArray.rangeAdd(2, 5, 3);
        // 对区间[1, 7]加上2
        diffArray.rangeAdd(1, 7, 2);
        
        std::vector<int> result = diffArray.getResult();
        std::cout << "差分数组结果: ";
        for (int val : result) {
            std::cout << val << " ";
        }
        std::cout << std::endl;
    } catch (const std::exception& e) {
        std::cerr << "错误: " << e.what() << std::endl;
    }
    
    // 测试矩形面积计算
    std::cout << "\n=== 测试矩形面积计算 ===" << std::endl;
    std::vector<std::tuple<int, int, int, int>> rectangles = {
        {1, 1, 3, 3},
        {2, 2, 4, 4},
        {5, 5, 7, 7}
    };
    try {
        int area = EventSweep::rectangleArea(rectangles);
        std::cout << "矩形覆盖的总面积: " << area << std::endl;
    } catch (const std::exception& e) {
        std::cerr << "错误: " << e.what() << std::endl;
    }
}

/**
 * 主函数
 */
int main() {
    // 运行算法测试
    testAlgorithms();
    
    return 0;
}

// ================================
// 相关算法题目及思路总结
// ================================

/*

平面分治算法相关题目：
1. LeetCode 973. K Closest Points to Origin
2. LeetCode 826. Most Profit Assigning Work
3. POJ 3714 Raid
4. HDU 1021 Fibonacci Again

思路总结：
- 平面分治适用于需要在二维平面上处理大量点的数据问题
- 核心思想是将平面递归地分割，然后合并子问题的解
- 关键优化是在合并阶段只考虑跨越分割线的有限数量的候选点

生命游戏相关题目：
1. LeetCode 289. Game of Life
2. LeetCode 733. Flood Fill
3. CodeChef - LIFE
4. Codeforces - 961E Tufurama

思路总结：
- 棋盘模拟问题通常涉及状态转移规则
- 关键在于高效地表示和更新状态，避免状态更新相互影响
- 原地算法可以通过编码中间状态来实现

稀疏表相关题目：
1. LeetCode 2448. Minimum Cost to Make Array Equal
2. LeetCode 1439. Find the Kth Smallest Sum of a Matrix With Sorted Rows
3. Codeforces - 1202E. You Are Given Some Strings...
4. AtCoder - ARC098D Donation

思路总结：
- 稀疏表适用于区间查询问题，尤其是静态数据的重复查询
- 预处理时间O(n log n)，查询时间O(1)
- 可以灵活应用于各种区间合并操作，如min、max、gcd等

事件排序相关题目：
1. LeetCode 253. Meeting Rooms II
2. LeetCode 759. Employee Free Time
3. Codeforces - 981E Addition on Segments
4. POJ 3273 Monthly Expense

思路总结：
- 事件排序的核心是将问题转化为事件点的处理
- 通过排序和扫描，可以高效地处理区间覆盖、重叠等问题
- 常用于区间调度、资源分配等场景

差分数组相关题目：
1. LeetCode 1109. Corporate Flight Bookings
2. LeetCode 1094. Car Pooling
3. Codeforces - 445B DZY Loves Chemistry
4. POJ 2352 Stars

思路总结：
- 差分数组是处理区间更新操作的高效工具
- 区间更新时间复杂度O(1)，是处理大量区间操作的理想选择
- 结合前缀和，可以轻松还原原始数组

*/

===============================================

文件: Algorithm1.java
===============================================
package class185;

import java.util.*;

/**
 * 高级算法与数据结构实现 - Java版本
 * 包含：
 * 1. 平面分治 (Closest Pair of Points)
 * 2. 棋盘模拟 (Game of Life)
 * 3. 间隔打表 (Sparse Table) - 离线查询优化和在线算法适配
 * 4. 事件排序 (Time Sweep)
 * 5. 差分驱动模拟 (Difference Array)
 *
 * 算法复杂度分析：
 * - 平面分治：O(n log n) 时间复杂度
 * - 棋盘模拟：O(m*n) 时间复杂度/代
 * - 间隔打表：O(n log n) 预处理，O(1) 查询
 * - 事件排序：O(n log n) 时间复杂度
 * - 差分驱动：O(n + k) 时间复杂度
 */
public class Algorithm1 {
    
    // ================================
    // 1. 平面分治 - 最近点对问题
    // ================================
    
    /**
     * 点类，用于存储二维坐标
     */
    static class Point {
        double x, y;
        
        Point(double x, double y) {
            this.x = x;
            this.y = y;
        }
        
        /**
         * 计算两个点之间的欧几里得距离
         */
        public double distanceTo(Point p) {
            double dx = this.x - p.x;
            double dy = this.y - p.y;
            return Math.sqrt(dx * dx + dy * dy);
        }
        
        @Override
        public String toString() {
            return "(" + x + ", " + y + ")";
        }
    }
    
    /**
     * 最近点对问题的平面分治算法实现
     */
    public static class ClosestPair {
        /**
         * 查找最近点对
         * @param points 点集
         * @return 包含最近点对和距离的数组
         */
        public static Object[] findClosestPair(Point[] points) {
            if (points == null || points.length < 2) {
                throw new IllegalArgumentException("点集必须包含至少两个点");
            }
            
            // 按照x坐标排序
            Point[] pointsSortedByX = points.clone();
            Arrays.sort(pointsSortedByX, Comparator.comparingDouble(p -> p.x));
            
            // 按照y坐标排序（用于后续处理）
            Point[] pointsSortedByY = pointsSortedByX.clone();
            Arrays.sort(pointsSortedByY, Comparator.comparingDouble(p -> p.y));
            
            // 记录最近点对
            Point[] closestPair = new Point[2];
            double minDistance = closestPairRecursive(pointsSortedByX, 0, pointsSortedByX.length - 1, 
                                                    pointsSortedByY, closestPair);
            
            return new Object[]{closestPair, minDistance};
        }
        
        /**
         * 递归求解最近点对
         */
        private static double closestPairRecursive(Point[] pointsSortedByX, int left, int right, 
                                                 Point[] pointsSortedByY, Point[] closestPair) {
            // 基本情况：小规模问题直接暴力求解
            if (right - left <= 3) {
                return bruteForce(pointsSortedByX, left, right, closestPair);
            }
            
            // 分治求解
            int mid = left + (right - left) / 2;
            Point midPoint = pointsSortedByX[mid];
            
            // 分割y排序的数组
            Point[] leftPointsSortedByY = new Point[mid - left + 1];
            Point[] rightPointsSortedByY = new Point[right - mid];
            
            int leftIdx = 0, rightIdx = 0;
            for (Point p : pointsSortedByY) {
                if (p.x <= midPoint.x && leftIdx < leftPointsSortedByY.length) {
                    leftPointsSortedByY[leftIdx++] = p;
                } else {
                    rightPointsSortedByY[rightIdx++] = p;
                }
            }
            
            // 递归求解左右子数组
            Point[] leftClosestPair = new Point[2];
            Point[] rightClosestPair = new Point[2];
            
            double leftMin = closestPairRecursive(pointsSortedByX, left, mid, leftPointsSortedByY, leftClosestPair);
            double rightMin = closestPairRecursive(pointsSortedByX, mid + 1, right, rightPointsSortedByY, rightClosestPair);
            
            // 确定左右子数组中的最小距离
            double minDist;
            if (leftMin < rightMin) {
                minDist = leftMin;
                closestPair[0] = leftClosestPair[0];
                closestPair[1] = leftClosestPair[1];
            } else {
                minDist = rightMin;
                closestPair[0] = rightClosestPair[0];
                closestPair[1] = rightClosestPair[1];
            }
            
            // 处理跨越中线的点对
            // 筛选出在中线附近的点
            List<Point> strip = new ArrayList<>();
            for (Point p : pointsSortedByY) {
                if (Math.abs(p.x - midPoint.x) < minDist) {
                    strip.add(p);
                }
            }
            
            // 检查strip中的点对
            double stripMin = checkStrip(strip, minDist, closestPair);
            
            return Math.min(minDist, stripMin);
        }
        
        /**
         * 暴力求解小规模问题
         */
        private static double bruteForce(Point[] points, int left, int right, Point[] closestPair) {
            double minDist = Double.MAX_VALUE;
            
            for (int i = left; i <= right; i++) {
                for (int j = i + 1; j <= right; j++) {
                    double dist = points[i].distanceTo(points[j]);
                    if (dist < minDist) {
                        minDist = dist;
                        closestPair[0] = points[i];
                        closestPair[1] = points[j];
                    }
                }
            }
            
            return minDist;
        }
        
        /**
         * 检查跨越中线的点对
         */
        private static double checkStrip(List<Point> strip, double minDist, Point[] closestPair) {
            double currentMin = minDist;
            
            // 按照y坐标排序（已经是排序好的）
            // 只需要检查相邻的最多7个点
            for (int i = 0; i < strip.size(); i++) {
                for (int j = i + 1; j < strip.size() && (strip.get(j).y - strip.get(i).y) < currentMin; j++) {
                    double dist = strip.get(i).distanceTo(strip.get(j));
                    if (dist < currentMin) {
                        currentMin = dist;
                        closestPair[0] = strip.get(i);
                        closestPair[1] = strip.get(j);
                    }
                }
            }
            
            return currentMin;
        }
        
        /**
         * 测试最近点对算法
         */
        public static void testClosestPair() {
            System.out.println("=== 测试最近点对算法 ===");
            
            // 测试用例1：随机点集
            Point[] points1 = {
                new Point(2, 3),
                new Point(12, 30),
                new Point(40, 50),
                new Point(5, 1),
                new Point(12, 10),
                new Point(3, 4)
            };
            
            Object[] result1 = findClosestPair(points1);
            Point[] pair1 = (Point[]) result1[0];
            double dist1 = (double) result1[1];
            System.out.println("最近点对1: " + pair1[0] + " 和 " + pair1[1]);
            System.out.println("距离: " + dist1);
            
            // 测试用例2：所有点在一条直线上
            Point[] points2 = {
                new Point(0, 0),
                new Point(1, 0),
                new Point(2, 0),
                new Point(3, 0),
                new Point(100, 0)
            };
            
            Object[] result2 = findClosestPair(points2);
            Point[] pair2 = (Point[]) result2[0];
            double dist2 = (double) result2[1];
            System.out.println("最近点对2: " + pair2[0] + " 和 " + pair2[1]);
            System.out.println("距离: " + dist2);
            
            // 测试用例3：边界情况
            Point[] points3 = {
                new Point(0, 0),
                new Point(0, 0)  // 重复点
            };
            
            Object[] result3 = findClosestPair(points3);
            Point[] pair3 = (Point[]) result3[0];
            double dist3 = (double) result3[1];
            System.out.println("最近点对3: " + pair3[0] + " 和 " + pair3[1]);
            System.out.println("距离: " + dist3);
        }
    }
    
    // ================================
    // 2. 棋盘模拟 - 康威生命游戏
    // ================================
    
    /**
     * 康威生命游戏模拟实现
     */
    public static class GameOfLife {
        private int[][] board;
        private int rows, cols;
        
        /**
         * 构造函数
         * @param initialBoard 初始棋盘状态
         */
        public GameOfLife(int[][] initialBoard) {
            if (initialBoard == null || initialBoard.length == 0 || initialBoard[0].length == 0) {
                throw new IllegalArgumentException("初始棋盘不能为空");
            }
            
            this.rows = initialBoard.length;
            this.cols = initialBoard[0].length;
            this.board = new int[rows][cols];
            
            // 深拷贝初始棋盘
            for (int i = 0; i < rows; i++) {
                System.arraycopy(initialBoard[i], 0, this.board[i], 0, cols);
            }
        }
        
        /**
         * 计算下一代的状态
         * 时间复杂度：O(m*n)
         * 空间复杂度：O(m*n)
         */
        public void nextGeneration() {
            // 创建新的棋盘来存储下一代状态
            int[][] newBoard = new int[rows][cols];
            
            // 遍历每个细胞
            for (int i = 0; i < rows; i++) {
                for (int j = 0; j < cols; j++) {
                    // 计算周围活细胞数量
                    int liveNeighbors = countLiveNeighbors(i, j);
                    
                    // 应用生命游戏规则
                    if (board[i][j] == 1) {
                        // 活细胞
                        if (liveNeighbors < 2 || liveNeighbors > 3) {
                            newBoard[i][j] = 0;  // 死亡
                        } else {
                            newBoard[i][j] = 1;  // 存活
                        }
                    } else {
                        // 死细胞
                        if (liveNeighbors == 3) {
                            newBoard[i][j] = 1;  // 繁殖
                        } else {
                            newBoard[i][j] = 0;  // 保持死亡
                        }
                    }
                }
            }
            
            // 更新棋盘
            this.board = newBoard;
        }
        
        /**
         * 使用原地算法计算下一代状态
         * 时间复杂度：O(m*n)
         * 空间复杂度：O(1)
         * 使用特殊标记：2表示从活到死，-1表示从死到活
         */
        public void nextGenerationInPlace() {
            // 遍历每个细胞
            for (int i = 0; i < rows; i++) {
                for (int j = 0; j < cols; j++) {
                    // 计算周围活细胞数量
                    int liveNeighbors = countLiveNeighborsWithMarkers(i, j);
                    
                    // 应用生命游戏规则
                    if (board[i][j] == 1) {
                        // 活细胞
                        if (liveNeighbors < 2 || liveNeighbors > 3) {
                            board[i][j] = 2;  // 标记为从活到死
                        }
                        // 否则保持为1，继续存活
                    } else {
                        // 死细胞
                        if (liveNeighbors == 3) {
                            board[i][j] = -1;  // 标记为从死到活
                        }
                        // 否则保持为0，继续死亡
                    }
                }
            }
            
            // 解析标记，恢复真实状态
            for (int i = 0; i < rows; i++) {
                for (int j = 0; j < cols; j++) {
                    if (board[i][j] == 2) {
                        board[i][j] = 0;  // 死亡
                    } else if (board[i][j] == -1) {
                        board[i][j] = 1;  // 新生
                    }
                }
            }
        }
        
        /**
         * 计算指定位置周围的活细胞数量
         */
        private int countLiveNeighbors(int row, int col) {
            int count = 0;
            // 8个方向的偏移
            int[][] directions = {
                {-1, -1}, {-1, 0}, {-1, 1},
                {0, -1},          {0, 1},
                {1, -1},  {1, 0}, {1, 1}
            };
            
            for (int[] dir : directions) {
                int newRow = row + dir[0];
                int newCol = col + dir[1];
                
                // 检查边界并计算活细胞
                if (newRow >= 0 && newRow < rows && newCol >= 0 && newCol < cols) {
                    if (board[newRow][newCol] == 1) {
                        count++;
                    }
                }
            }
            
            return count;
        }
        
        /**
         * 在原地算法中计算周围的活细胞数量（考虑标记）
         */
        private int countLiveNeighborsWithMarkers(int row, int col) {
            int count = 0;
            int[][] directions = {
                {-1, -1}, {-1, 0}, {-1, 1},
                {0, -1},          {0, 1},
                {1, -1},  {1, 0}, {1, 1}
            };
            
            for (int[] dir : directions) {
                int newRow = row + dir[0];
                int newCol = col + dir[1];
                
                if (newRow >= 0 && newRow < rows && newCol >= 0 && newCol < cols) {
                    // 1或2表示之前是活细胞
                    if (board[newRow][newCol] == 1 || board[newRow][newCol] == 2) {
                        count++;
                    }
                }
            }
            
            return count;
        }
        
        /**
         * 获取当前棋盘状态
         */
        public int[][] getBoard() {
            int[][] copy = new int[rows][cols];
            for (int i = 0; i < rows; i++) {
                System.arraycopy(board[i], 0, copy[i], 0, cols);
            }
            return copy;
        }
        
        /**
         * 打印棋盘状态
         */
        public void printBoard() {
            for (int i = 0; i < rows; i++) {
                for (int j = 0; j < cols; j++) {
                    System.out.print(board[i][j] + " ");
                }
                System.out.println();
            }
            System.out.println();
        }
        
        /**
         * 测试生命游戏
         */
        public static void testGameOfLife() {
            System.out.println("=== 测试康威生命游戏 ===");
            
            // 测试用例：闪烁器（Blinker）
            int[][] blinker = {
                {0, 1, 0},
                {0, 1, 0},
                {0, 1, 0}
            };
            
            System.out.println("初始状态:");
            GameOfLife game = new GameOfLife(blinker);
            game.printBoard();
            
            System.out.println("第1代（原地算法）:");
            game.nextGenerationInPlace();
            game.printBoard();
            
            System.out.println("第2代（原地算法）:");
            game.nextGenerationInPlace();
            game.printBoard();
            
            // 测试用例：滑翔机（Glider）
            int[][] glider = {
                {0, 1, 0},
                {0, 0, 1},
                {1, 1, 1}
            };
            
            System.out.println("滑翔机 - 初始状态:");
            GameOfLife gliderGame = new GameOfLife(glider);
            gliderGame.printBoard();
            
            for (int i = 1; i <= 4; i++) {
                System.out.println("滑翔机 - 第" + i + "代:");
                gliderGame.nextGeneration();
                gliderGame.printBoard();
            }
        }
    }
    
    // ================================
    // 3. 间隔打表 - 稀疏表实现
    // ================================
    
    /**
     * 稀疏表（Sparse Table）实现
     * 支持O(1)时间的区间查询操作
     */
    public static class SparseTable {
        private int[][] st;      // 稀疏表数组
        private int[] logTable;  // 预计算的log值表
        private int[] data;      // 原始数据
        private boolean isMin;   // 是否是最小值查询（true）或最大值查询（false）
        
        /**
         * 构造函数 - 最小值查询
         * @param data 输入数组
         */
        public SparseTable(int[] data) {
            this(data, true);
        }
        
        /**
         * 构造函数
         * @param data 输入数组
         * @param isMin 是否是最小值查询
         */
        public SparseTable(int[] data, boolean isMin) {
            if (data == null || data.length == 0) {
                throw new IllegalArgumentException("输入数组不能为空");
            }
            
            this.data = data;
            this.isMin = isMin;
            int n = data.length;
            
            // 计算log表
            precomputeLogTable(n);
            
            // 计算稀疏表
            int k = logTable[n] + 1;
            st = new int[k][n];
            
            // 初始化第一行（区间长度为1）
            for (int i = 0; i < n; i++) {
                st[0][i] = i;  // 存储索引而不是值，便于范围查询
            }
            
            // 填充其他行
            for (int j = 1; j < k; j++) {
                for (int i = 0; i <= n - (1 << j); i++) {
                    int prevLen = 1 << (j - 1);
                    int left = st[j - 1][i];
                    int right = st[j - 1][i + prevLen];
                    
                    // 根据查询类型选择最小或最大值
                    if (isMin) {
                        st[j][i] = (data[left] <= data[right]) ? left : right;
                    } else {
                        st[j][i] = (data[left] >= data[right]) ? left : right;
                    }
                }
            }
        }
        
        /**
         * 预计算log2值表
         */
        private void precomputeLogTable(int n) {
            logTable = new int[n + 1];
            logTable[1] = 0;
            for (int i = 2; i <= n; i++) {
                logTable[i] = logTable[i / 2] + 1;
            }
        }
        
        /**
         * 区间查询操作
         * 时间复杂度：O(1)
         * @param l 左边界（包含）
         * @param r 右边界（包含）
         * @return 区间内的最小/最大值
         */
        public int query(int l, int r) {
            if (l < 0 || r >= data.length || l > r) {
                throw new IllegalArgumentException("查询范围无效");
            }
            
            int length = r - l + 1;
            int k = logTable[length];
            
            int left = st[k][l];
            int right = st[k][r - (1 << k) + 1];
            
            if (isMin) {
                return Math.min(data[left], data[right]);
            } else {
                return Math.max(data[left], data[right]);
            }
        }
        
        /**
         * 离线查询处理
         * @param queries 包含多个查询的数组，每个查询是 [l, r] 形式
         * @return 查询结果数组
         */
        public int[] processOfflineQueries(int[][] queries) {
            int[] results = new int[queries.length];
            
            for (int i = 0; i < queries.length; i++) {
                results[i] = query(queries[i][0], queries[i][1]);
            }
            
            return results;
        }
        
        /**
         * 测试稀疏表
         */
        public static void testSparseTable() {
            System.out.println("=== 测试稀疏表 ===");
            
            int[] data = {1, 3, 5, 7, 9, 11, 13, 15, 17};
            
            // 测试最小值查询
            System.out.println("测试最小值查询:");
            SparseTable minST = new SparseTable(data, true);
            System.out.println("区间[1, 5]的最小值: " + minST.query(1, 5));  // 应该是3
            System.out.println("区间[0, 8]的最小值: " + minST.query(0, 8));  // 应该是1
            System.out.println("区间[4, 7]的最小值: " + minST.query(4, 7));  // 应该是9
            
            // 测试最大值查询
            System.out.println("\n测试最大值查询:");
            SparseTable maxST = new SparseTable(data, false);
            System.out.println("区间[1, 5]的最大值: " + maxST.query(1, 5));  // 应该是11
            System.out.println("区间[0, 8]的最大值: " + maxST.query(0, 8));  // 应该是17
            System.out.println("区间[4, 7]的最大值: " + maxST.query(4, 7));  // 应该是15
            
            // 测试离线查询
            System.out.println("\n测试离线查询:");
            int[][] queries = {
                {0, 2}, {1, 5}, {3, 7}, {2, 8}
            };
            
            int[] minResults = minST.processOfflineQueries(queries);
            System.out.print("离线最小值查询结果: ");
            for (int result : minResults) {
                System.out.print(result + " ");
            }
            System.out.println();
            
            int[] maxResults = maxST.processOfflineQueries(queries);
            System.out.print("离线最大值查询结果: ");
            for (int result : maxResults) {
                System.out.print(result + " ");
            }
            System.out.println();
        }
    }
    
    // ================================
    // 4. 事件排序 - 时间扫描线算法
    // ================================
    
    /**
     * 事件类，用于时间扫描线算法
     */
    static class Event implements Comparable<Event> {
        double time;       // 事件发生的时间
        int type;          // 事件类型：0表示开始，1表示结束
        int data;          // 事件关联的数据
        
        Event(double time, int type, int data) {
            this.time = time;
            this.type = type;
            this.data = data;
        }
        
        @Override
        public int compareTo(Event other) {
            // 首先按照时间排序
            if (this.time != other.time) {
                return Double.compare(this.time, other.time);
            }
            // 时间相同时，结束事件优先处理，避免重复计算
            return Integer.compare(other.type, this.type);
        }
    }
    
    /**
     * 时间扫描线算法实现
     */
    public static class EventSweep {
        /**
         * 区间覆盖问题：计算最多有多少个重叠的区间
         * @param intervals 区间数组，每个区间是 [start, end] 形式
         * @return 最大重叠数量
         */
        public static int maxOverlap(int[][] intervals) {
            if (intervals == null || intervals.length == 0) {
                return 0;
            }
            
            List<Event> events = new ArrayList<>();
            
            // 为每个区间创建开始和结束事件
            for (int[] interval : intervals) {
                events.add(new Event(interval[0], 0, 1));  // 开始事件
                events.add(new Event(interval[1], 1, 1));  // 结束事件
            }
            
            // 按照时间排序事件
            Collections.sort(events);
            
            int maxOverlap = 0;
            int currentOverlap = 0;
            
            // 扫描所有事件
            for (Event event : events) {
                if (event.type == 0) {  // 开始事件
                    currentOverlap++;
                    maxOverlap = Math.max(maxOverlap, currentOverlap);
                } else {  // 结束事件
                    currentOverlap--;
                }
            }
            
            return maxOverlap;
        }
        
        /**
         * 扫描线算法解决矩形面积问题：计算多个矩形的总面积（不重复计算重叠部分）
         * @param rectangles 矩形数组，每个矩形是 [x1, y1, x2, y2] 形式，其中(x1,y1)是左下顶点，(x2,y2)是右上顶点
         * @return 矩形覆盖的总面积
         */
        public static int calculateRectangleArea(int[][] rectangles) {
            if (rectangles == null || rectangles.length == 0) {
                return 0;
            }
            
            // 创建垂直扫描线事件
            List<Event> events = new ArrayList<>();
            Set<Integer> yCoordinates = new HashSet<>();
            
            for (int[] rect : rectangles) {
                int x1 = rect[0];
                int y1 = rect[1];
                int x2 = rect[2];
                int y2 = rect[3];
                
                // 添加开始和结束事件
                events.add(new Event(x1, 0, y1 * 1000 + y2));  // 使用编码存储y范围
                events.add(new Event(x2, 1, y1 * 1000 + y2));  // 假设y不超过1000
                
                // 收集所有y坐标
                yCoordinates.add(y1);
                yCoordinates.add(y2);
            }
            
            // 排序事件
            Collections.sort(events);
            
            // 对y坐标排序
            List<Integer> sortedY = new ArrayList<>(yCoordinates);
            Collections.sort(sortedY);
            
            // 用于跟踪当前活动的矩形
            Set<String> activeIntervals = new HashSet<>();
            double totalArea = 0;
            double prevX = events.get(0).time;
            
            // 处理每个事件
            for (Event event : events) {
                double currentX = event.time;
                double width = currentX - prevX;
                
                // 计算当前活动的y区间总长度
                double height = calculateActiveHeight(activeIntervals, sortedY);
                
                // 增加面积
                totalArea += width * height;
                
                // 更新活动区间
                int y1 = event.data / 1000;
                int y2 = event.data % 1000;
                String intervalKey = y1 + "-" + y2;
                
                if (event.type == 0) {
                    activeIntervals.add(intervalKey);
                } else {
                    activeIntervals.remove(intervalKey);
                }
                
                prevX = currentX;
            }
            
            return (int) totalArea;
        }
        
        /**
         * 计算当前活动的y区间总长度
         */
        private static double calculateActiveHeight(Set<String> activeIntervals, List<Integer> sortedY) {
            if (activeIntervals.isEmpty()) {
                return 0;
            }
            
            // 将活动区间转换为具体的y范围
            List<int[]> intervals = new ArrayList<>();
            for (String key : activeIntervals) {
                String[] parts = key.split("-");
                int y1 = Integer.parseInt(parts[0]);
                int y2 = Integer.parseInt(parts[1]);
                intervals.add(new int[]{y1, y2});
            }
            
            // 合并重叠的y区间
            intervals.sort(Comparator.comparingInt(a -> a[0]));
            
            double totalHeight = 0;
            int currentStart = intervals.get(0)[0];
            int currentEnd = intervals.get(0)[1];
            
            for (int i = 1; i < intervals.size(); i++) {
                if (intervals.get(i)[0] <= currentEnd) {
                    // 重叠，合并区间
                    currentEnd = Math.max(currentEnd, intervals.get(i)[1]);
                } else {
                    // 不重叠，计算长度并更新当前区间
                    totalHeight += currentEnd - currentStart;
                    currentStart = intervals.get(i)[0];
                    currentEnd = intervals.get(i)[1];
                }
            }
            
            // 加上最后一个区间
            totalHeight += currentEnd - currentStart;
            
            return totalHeight;
        }
        
        /**
         * 测试事件扫描线算法
         */
        public static void testEventSweep() {
            System.out.println("=== 测试事件扫描线算法 ===");
            
            // 测试区间重叠问题
            System.out.println("测试区间重叠问题:");
            int[][] intervals1 = {
                {1, 4}, {2, 5}, {3, 6}, {7, 9}
            };
            System.out.println("最大重叠数量: " + maxOverlap(intervals1));  // 应该是3
            
            int[][] intervals2 = {
                {1, 2}, {3, 4}, {5, 6}
            };
            System.out.println("最大重叠数量: " + maxOverlap(intervals2));  // 应该是1
            
            // 测试矩形面积问题
            System.out.println("\n测试矩形面积计算:");
            int[][] rectangles1 = {
                {0, 0, 2, 2}, {1, 1, 3, 3}
            };
            System.out.println("矩形覆盖总面积: " + calculateRectangleArea(rectangles1));  // 应该是7
            
            int[][] rectangles2 = {
                {0, 0, 1, 1}, {2, 2, 3, 3}, {1, 1, 2, 2}
            };
            System.out.println("矩形覆盖总面积: " + calculateRectangleArea(rectangles2));  // 应该是3
        }
    }
    
    // ================================
    // 5. 差分驱动模拟 - 差分数组
    // ================================
    
    /**
     * 差分数组实现
     * 高效处理区间更新操作
     */
    public static class DifferenceArray {
        private int[] diff;      // 差分数组
        private int[] original;  // 原始数组
        private int size;
        
        /**
         * 构造函数
         * @param n 数组大小
         */
        public DifferenceArray(int n) {
            if (n <= 0) {
                throw new IllegalArgumentException("数组大小必须为正整数");
            }
            
            this.size = n;
            this.diff = new int[n + 1];  // 差分数组大小为n+1，便于处理边界
            this.original = new int[n];
        }
        
        /**
         * 从原始数组创建差分数组
         * @param arr 原始数组
         */
        public DifferenceArray(int[] arr) {
            if (arr == null) {
                throw new IllegalArgumentException("输入数组不能为空");
            }
            
            this.size = arr.length;
            this.original = arr.clone();
            this.diff = new int[size + 1];
            
            // 初始化差分数组
            diff[0] = arr[0];
            for (int i = 1; i < size; i++) {
                diff[i] = arr[i] - arr[i - 1];
            }
        }
        /**
         * 区间更新：将区间[start, end]的每个元素加上val
         * 时间复杂度：O(1)
         * @param start 起始索引（包含）
         * @param end 结束索引（包含）
         * @param val 要增加的值
         */
        public void rangeUpdate(int start, int end, int val) {
            if (start < 0 || end >= size || start > end) {
                throw new IllegalArgumentException("更新范围无效");
            }
            
            diff[start] += val;
            diff[end + 1] -= val;
        }
        /**
         * 获取更新后的数组
         * 时间复杂度：O(n)
         * @return 更新后的数组
         */
        public int[] getResult() {
            int[] result = new int[size];
            result[0] = diff[0];
            
            for (int i = 1; i < size; i++) {
                result[i] = result[i - 1] + diff[i];
            }
            
            return result;
        }
        /**
         * 直接获取数组中特定位置的值
         * 注意：这需要先重建数组，时间复杂度O(n)
         * @param index 索引位置
         * @return 该位置的值
         */
        public int getValue(int index) {
            if (index < 0 || index >= size) {
                throw new IllegalArgumentException("索引无效");
            }
            
            int[] result = getResult();
            return result[index];
        }
        /**
         * 重置差分数组
         */
        public void reset() {
            Arrays.fill(diff, 0);
            if (original.length == size) {
                for (int i = 0; i < size; i++) {
                    rangeUpdate(i, i, original[i]);
                }
            }
        }
        /**
         * 测试差分数组
         */
        public static void testDifferenceArray() {
            System.out.println("=== 测试差分数组 ===");
            
            // 测试从大小创建
            System.out.println("测试从大小创建:");
            DifferenceArray da1 = new DifferenceArray(5);
            System.out.println("初始数组: " + Arrays.toString(da1.getResult()));
            
            da1.rangeUpdate(0, 2, 1);
            System.out.println("区间[0,2]加1: " + Arrays.toString(da1.getResult()));
            
            da1.rangeUpdate(1, 4, 2);
            System.out.println("区间[1,4]加2: " + Arrays.toString(da1.getResult()));
            
            da1.rangeUpdate(2, 3, -1);
            System.out.println("区间[2,3]减1: " + Arrays.toString(da1.getResult()));
            
            // 测试从原始数组创建
            System.out.println("\n测试从原始数组创建:");
            int[] original = {1, 2, 3, 4, 5};
            DifferenceArray da2 = new DifferenceArray(original);
            System.out.println("原始数组: " + Arrays.toString(da2.getResult()));
            
            da2.rangeUpdate(1, 3, 10);
            System.out.println("区间[1,3]加10: " + Arrays.toString(da2.getResult()));
            
            da2.rangeUpdate(0, 4, -5);
            System.out.println("区间[0,4]减5: " + Arrays.toString(da2.getResult()));
            
            // 测试重置功能
            da2.reset();
            System.out.println("重置后: " + Arrays.toString(da2.getResult()));
            
            // 测试边界情况
            System.out.println("\n测试边界情况:");
            DifferenceArray da3 = new DifferenceArray(1);
            da3.rangeUpdate(0, 0, 100);
            System.out.println("单元素数组更新: " + Arrays.toString(da3.getResult()));
        }
    }
    
    // ================================
    // 主方法 - 运行所有测试
    // ================================
    
    public static void main(String[] args) {
        // 运行所有测试
        ClosestPair.testClosestPair();
        System.out.println();
        
        GameOfLife.testGameOfLife();
        System.out.println();
        
        SparseTable.testSparseTable();
        System.out.println();
        
        EventSweep.testEventSweep();
        System.out.println();
        
        DifferenceArray.testDifferenceArray();
    }
}

===============================================

文件: algorithm1.py
===============================================
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Python版本算法与数据结构实现
包含：
1. 平面分治 (Closest Pair of Points)
2. 棋盘模拟 (Game of Life)
3. 间隔打表 (Sparse Table)
4. 事件排序 (Time Sweep)
5. 差分驱动模拟 (Difference Array)
6. 双向循环链表 (Doubly Circular Linked List)
7. 斐波那契堆 (Fibonacci Heap)
8. 块状链表 (Unrolled Linked List)

时间复杂度分析：
- 平面分治: O(n log n)
- 棋盘模拟: O(m*n)
- 间隔打表: O(n log n) 预处理, O(1) 查询
- 事件排序: O(n log n)
- 差分驱动: O(1) 区间更新, O(n) 获取结果
- 双向循环链表: 插入/删除头部/尾部 O(1), 其他 O(n)
- 斐波那契堆: 插入 O(1) 均摊, 提取最小 O(log n) 均摊
- 块状链表: O(n/b) 操作复杂度，b为块大小
"""

import math
import heapq
from collections import namedtuple
import sys

# ================================
# 1. 平面分治 - 最近点对问题
# ================================

class Point:
    """点类，用于表示平面上的点"""
    def __init__(self, x, y):
        self.x = x
        self.y = y
    
    def __repr__(self):
        return f"Point({self.x}, {self.y})"
    
    def distance_to(self, other):
        """计算到另一个点的欧几里得距离"""
        return math.sqrt((self.x - other.x) ** 2 + (self.y - other.y) ** 2)


def closest_pair(points):
    """
    使用分治法求解最近点对问题
    时间复杂度: O(n log n)
    
    参数:
        points: 点列表
    返回:
        (最小距离, 最近点对)
    """
    if not points:
        raise ValueError("输入点列表不能为空")
    if len(points) < 2:
        raise ValueError("至少需要两个点来计算距离")
    
    # 按x坐标排序
    points_sorted_by_x = sorted(points, key=lambda p: p.x)
    # 按y坐标排序，用于带内搜索
    points_sorted_by_y = sorted(points, key=lambda p: p.y)
    
    # 调用递归函数
    min_dist, pair = closest_pair_recursive(points_sorted_by_x, points_sorted_by_y)
    return min_dist, pair

def closest_pair_recursive(points_sorted_by_x, points_sorted_by_y):
    """递归求解最近点对"""
    n = len(points_sorted_by_x)
    
    # 基本情况：小于等于3个点，使用暴力法
    if n <= 3:
        return brute_force_closest_pair(points_sorted_by_x)
    
    # 分治：将点集分为左右两部分
    mid = n // 2
    mid_point = points_sorted_by_x[mid]
    
    # 分割y排序的点列表
    left_points_y = [p for p in points_sorted_by_y if p.x <= mid_point.x]
    right_points_y = [p for p in points_sorted_by_y if p.x > mid_point.x]
    
    # 递归求解左右两部分的最近点对
    left_min_dist, left_pair = closest_pair_recursive(points_sorted_by_x[:mid], left_points_y)
    right_min_dist, right_pair = closest_pair_recursive(points_sorted_by_x[mid:], right_points_y)
    
    # 合并：取左右两部分中的最小距离
    if left_min_dist <= right_min_dist:
        min_dist = left_min_dist
        min_pair = left_pair
    else:
        min_dist = right_min_dist
        min_pair = right_pair
    
    # 带内搜索：查找跨越中线的点对
    # 构建带内的点列表，只考虑x坐标在中线附近min_dist范围内的点
    strip = [p for p in points_sorted_by_y if abs(p.x - mid_point.x) < min_dist]
    
    # 在带内查找可能的更近点对
    strip_min_dist, strip_pair = strip_closest(strip, min_dist, min_pair)
    
    # 比较并返回全局最小距离
    if strip_min_dist < min_dist:
        return strip_min_dist, strip_pair
    else:
        return min_dist, min_pair

def brute_force_closest_pair(points):
    """暴力法计算最近点对，用于小规模输入"""
    n = len(points)
    min_dist = float('inf')
    min_pair = None
    
    for i in range(n):
        for j in range(i + 1, n):
            dist = points[i].distance_to(points[j])
            if dist < min_dist:
                min_dist = dist
                min_pair = (points[i], points[j])
    
    return min_dist, min_pair

def strip_closest(strip, min_dist, min_pair):
    """在带内查找最近点对"""
    # 按y坐标排序已经完成
    size = len(strip)
    
    # 对于带内的每个点，只需要检查后面y坐标相差不超过min_dist的点
    # 理论上最多检查6个点（平面分治的关键优化）
    for i in range(size):
        j = i + 1
        while j < size and (strip[j].y - strip[i].y) < min_dist:
            dist = strip[i].distance_to(strip[j])
            if dist < min_dist:
                min_dist = dist
                min_pair = (strip[i], strip[j])
            j += 1
    
    return min_dist, min_pair

# ================================
# 2. 棋盘模拟 - 生命游戏
# ================================

class GameOfLife:
    """
    康威生命游戏实现
    时间复杂度: O(m*n)，空间复杂度: 标准版O(m*n)，原地版O(1)
    """
    
    def __init__(self, board):
        """
        初始化生命游戏
        
        参数:
            board: 二维列表，表示初始棋盘状态
        """
        if not board or not board[0]:
            raise ValueError("输入棋盘不能为空")
        
        # 深拷贝输入棋盘，避免修改原始数据
        self.rows = len(board)
        self.cols = len(board[0])
        self.board = [row[:] for row in board]
    
    def count_neighbors(self, board, row, col):
        """
        计算指定位置的邻居数量
        
        参数:
            board: 当前棋盘状态
            row: 行索引
            col: 列索引
        返回:
            邻居数量
        """
        neighbors = 0
        # 八个方向的偏移
        directions = [
            (-1, -1), (-1, 0), (-1, 1),
            (0, -1),          (0, 1),
            (1, -1),  (1, 0), (1, 1)
        ]
        
        for dr, dc in directions:
            r, c = row + dr, col + dc
            # 检查边界并计数
            if 0 <= r < self.rows and 0 <= c < self.cols:
                # 注意：对于原地版本，我们需要考虑标记后的状态
                # 1和2表示原始状态为活细胞（1：保持活，2：将死亡）
                if board[r][c] == 1 or board[r][c] == 2:
                    neighbors += 1
        
        return neighbors
    
    def next_generation_standard(self):
        """
        使用额外空间计算下一代
        空间复杂度: O(m*n)
        
        返回:
            下一代棋盘状态
        """
        # 创建新棋盘存储下一代状态
        next_board = [[0 for _ in range(self.cols)] for _ in range(self.rows)]
        
        # 计算每个细胞的下一代状态
        for i in range(self.rows):
            for j in range(self.cols):
                neighbors = self.count_neighbors(self.board, i, j)
                
                # 应用生命游戏规则
                if self.board[i][j] == 1:  # 活细胞
                    if neighbors < 2 or neighbors > 3:
                        next_board[i][j] = 0  # 死亡：人口稀少或过度拥挤
                    else:
                        next_board[i][j] = 1  # 存活
                else:  # 死细胞
                    if neighbors == 3:
                        next_board[i][j] = 1  # 繁殖
        
        # 更新当前棋盘
        self.board = next_board
        return self.board
    
    def next_generation_inplace(self):
        """
        原地计算下一代，不使用额外空间
        空间复杂度: O(1)
        
        返回:
            更新后的棋盘（原地修改）
        """
        # 编码规则：
        # 0: 死细胞 -> 死细胞
        # 1: 活细胞 -> 活细胞
        # 2: 活细胞 -> 死细胞
        # 3: 死细胞 -> 活细胞
        
        for i in range(self.rows):
            for j in range(self.cols):
                neighbors = self.count_neighbors(self.board, i, j)
                
                if self.board[i][j] == 1:  # 活细胞
                    if neighbors < 2 or neighbors > 3:
                        self.board[i][j] = 2  # 标记为将死亡
                else:  # 死细胞
                    if neighbors == 3:
                        self.board[i][j] = 3  # 标记为将复活
        
        # 解码：将标记转换回0和1
        for i in range(self.rows):
            for j in range(self.cols):
                self.board[i][j] %= 2  # 2 -> 0, 3 -> 1
        
        return self.board
    
    def simulate(self, generations, inplace=True):
        """
        模拟多代生命游戏
        
        参数:
            generations: 要模拟的代数
            inplace: 是否使用原地算法
        返回:
            最终棋盘状态
        """
        if generations <= 0:
            return self.board
        
        for _ in range(generations):
            if inplace:
                self.next_generation_inplace()
            else:
                self.next_generation_standard()
        
        return self.board
    
    def get_board(self):
        """
        获取当前棋盘状态
        """
        # 返回深拷贝，避免外部修改
        return [row[:] for row in self.board]
    
    def print_board(self):
        """
        打印当前棋盘状态
        """
        for row in self.board:
            print(' '.join('█' if cell else ' ' for cell in row))
        print()

# ================================
# 3. 间隔打表 - 稀疏表
# ================================

class SparseTable:
    """
    稀疏表实现，用于高效的区间查询
    支持区间最小值查询和区间最大值查询
    时间复杂度：预处理O(n log n)，查询O(1)
    """
    
    def __init__(self, data, func=min):
        """
        初始化稀疏表
        
        参数:
            data: 一维数组数据
            func: 查询函数，可以是min或max
        """
        if not data:
            raise ValueError("输入数据不能为空")
        
        self.data = data
        self.n = len(data)
        self.func = func
        # 计算log2(n)的上界
        self.log_table = self._build_log_table()
        # 构建稀疏表
        self.st = self._build_sparse_table()
    
    def _build_log_table(self):
        """
        构建log表，用于快速计算区间长度对应的k值
        """
        log_table = [0] * (self.n + 1)
        for i in range(2, self.n + 1):
            log_table[i] = log_table[i // 2] + 1
        return log_table
    
    def _build_sparse_table(self):
        """
        构建稀疏表
        st[k][i]表示从i开始，长度为2^k的区间的查询结果
        """
        k_max = self.log_table[self.n] + 1
        # 创建k_max行n列的稀疏表
        st = [[0] * self.n for _ in range(k_max)]
        
        # 初始化k=0的情况（长度为1的区间）
        for i in range(self.n):
            st[0][i] = self.data[i]
        
        # 动态规划构建其他k值
        k = 1
        while (1 << k) <= self.n:
            i = 0
            while i + (1 << k) <= self.n:
                # 合并两个长度为2^(k-1)的区间
                st[k][i] = self.func(
                    st[k-1][i],
                    st[k-1][i + (1 << (k-1))]
                )
                i += 1
            k += 1
        
        return st
    
    def query_range(self, l, r):
        """
        查询区间[l, r]的结果（包含端点）
        时间复杂度: O(1)
        
        参数:
            l: 左边界（包含）
            r: 右边界（包含）
        返回:
            查询结果
        """
        # 检查边界
        if l < 0 or r >= self.n or l > r:
            raise ValueError(f"无效的区间边界: [{l}, {r}]")
        
        # 计算区间长度
        length = r - l + 1
        # 找到最大的k，使得2^k <= length
        k = self.log_table[length]
        
        # 查询两个重叠的子区间并合并结果
        # 第一个子区间: [l, l+2^k-1]
        # 第二个子区间: [r-2^k+1, r]
        return self.func(
            self.st[k][l],
            self.st[k][r - (1 << k) + 1]
        )
    
    def batch_query(self, queries):
        """
        批量处理多个区间查询
        
        参数:
            queries: 查询列表，每个查询是(l, r)元组
        返回:
            查询结果列表
        """
        results = []
        for l, r in queries:
            results.append(self.query_range(l, r))
        return results
    
    # 以下是一些常见的应用
    
    def is_range_all_same(self, l, r):
        """
        检查区间内所有元素是否相同
        """
        if l == r:
            return True
        return self.query_range(l, r) == self.data[l]  # 假设使用min查询
    
    def get_range_extreme(self, l, r):
        """
        获取区间的极值（最小值或最大值，取决于初始化时的func）
        """
        return self.query_range(l, r)

# ================================
# 4. 事件排序 - 扫描线算法
# ================================

class EventSweep:
    """
    扫描线算法实现，用于处理平面扫描问题
    """
    
    @staticmethod
    def interval_overlap(intervals):
        """
        计算区间重叠的最大数量
        时间复杂度: O(n log n)
        
        参数:
            intervals: 区间列表，每个区间是[start, end]的形式
        返回:
            最大重叠数量和发生重叠的区间
        """
        if not intervals:
            return 0, []
        
        # 创建事件点：(位置, 类型)，类型1表示开始，-1表示结束
        events = []
        for i, (start, end) in enumerate(intervals):
            if start > end:
                raise ValueError(f"无效的区间: [{start}, {end}]")
            events.append((start, 1, i))  # 开始事件
            events.append((end, -1, i))   # 结束事件
        
        # 按位置排序事件，当位置相同时，结束事件优先（确保[1,2]和[2,3]不被视为重叠）
        events.sort(key=lambda x: (x[0], x[1]))
        
        current_overlap = 0
        max_overlap = 0
        active_intervals = []
        max_overlap_intervals = []
        
        # 扫描事件
        for pos, typ, idx in events:
            # 更新当前重叠数量
            current_overlap += typ
            
            # 更新活动区间列表
            if typ == 1:
                active_intervals.append(idx)
            else:
                active_intervals.remove(idx)
            
            # 更新最大重叠
            if current_overlap > max_overlap:
                max_overlap = current_overlap
                max_overlap_intervals = active_intervals.copy()
            # 当重叠数量相同时，如果是结束事件，我们不更新，因为我们想要最大重叠开始的位置
        
        # 返回最大重叠数量和对应的原始区间
        overlapping_intervals = [intervals[i] for i in max_overlap_intervals]
        return max_overlap, overlapping_intervals
    
    @staticmethod
    def rectangle_area(rectangles):
        """
        计算多个矩形的总面积（去除重叠部分）
        时间复杂度: O(n^2 log n)
        
        参数:
            rectangles: 矩形列表，每个矩形是[x1, y1, x2, y2]，其中(x1,y1)是左下角，(x2,y2)是右上角
        返回:
            总面积
        """
        if not rectangles:
            return 0
        
        # 创建垂直边事件
        events = []
        x_coords = set()
        
        for x1, y1, x2, y2 in rectangles:
            if x1 >= x2 or y1 >= y2:
                raise ValueError(f"无效的矩形: [{x1}, {y1}, {x2}, {y2}]")
            # 添加垂直线事件
            events.append((x1, 'start', y1, y2))  # 左边界
            events.append((x2, 'end', y1, y2))    # 右边界
            x_coords.add(x1)
            x_coords.add(x2)
        
        # 按x坐标排序事件
        events.sort(key=lambda x: x[0])
        # 排序x坐标，用于计算相邻扫描线之间的距离
        sorted_x = sorted(x_coords)
        
        active_intervals = []
        area = 0
        prev_x = None
        
        # 扫描事件
        for x, typ, y1, y2 in events:
            # 计算当前扫描线和前一条扫描线之间的面积
            if prev_x is not None and x > prev_x and active_intervals:
                # 计算当前活动的y区间的总长度
                active_length = EventSweep._merge_and_calculate_length(active_intervals)
                # 面积 = 宽度 * 高度
                area += (x - prev_x) * active_length
            
            # 更新活动区间
            if typ == 'start':
                active_intervals.append((y1, y2))
            else:
                # 移除对应的区间
                active_intervals = [(a, b) for a, b in active_intervals if not (a == y1 and b == y2)]
            
            prev_x = x
        
        return area
    
    @staticmethod
    def _merge_and_calculate_length(intervals):
        """
        合并重叠的区间并计算总长度
        """
        if not intervals:
            return 0
        
        # 按起始位置排序
        sorted_intervals = sorted(intervals, key=lambda x: x[0])
        
        merged = [sorted_intervals[0]]
        for current_start, current_end in sorted_intervals[1:]:
            last_start, last_end = merged[-1]
            
            if current_start <= last_end:  # 有重叠
                # 合并区间
                new_start = last_start
                new_end = max(last_end, current_end)
                merged[-1] = (new_start, new_end)
            else:
                merged.append((current_start, current_end))
        
        # 计算总长度
        total_length = 0
        for start, end in merged:
            total_length += end - start
        
        return total_length
    
    @staticmethod
    def plane_sweep_for_intersections(segments):
        """
        使用扫描线算法检测线段相交
        注意：这是一个简化实现，仅用于演示
        
        参数:
            segments: 线段列表，每个线段是[(x1,y1), (x2,y2)]的形式
        返回:
            相交的线段对列表
        """
        if not segments:
            return []
        
        intersections = []
        events = []
        
        # 创建事件：线段的左右端点
        for i, ((x1, y1), (x2, y2)) in enumerate(segments):
            # 确保左端点的x坐标较小
            if x1 > x2:
                x1, x2 = x2, x1
                y1, y2 = y2, y1
            # 添加事件
            events.append((x1, 'start', i, y1, y2))  # 左端点
            events.append((x2, 'end', i, y1, y2))    # 右端点
        
        # 按x坐标排序事件
        events.sort(key=lambda x: x[0])
        
        active_segments = []
        
        for x, typ, idx, y1, y2 in events:
            if typ == 'start':
                # 检查与所有活动线段的相交
                for active_idx, active_y1, active_y2 in active_segments:
                    # 简化判断，实际应该使用线段相交算法
                    # 这里仅作为示例
                    if (min(y1, y2) <= max(active_y1, active_y2) and 
                        max(y1, y2) >= min(active_y1, active_y2)):
                        # 有潜在相交，记录
                        intersections.append((idx, active_idx))
                # 添加到活动线段
                active_segments.append((idx, y1, y2))
                # 按y坐标排序，用于处理垂直线段
                active_segments.sort(key=lambda s: min(s[1], s[2]))
            else:
                # 从活动线段中移除
                active_segments = [(i, ay1, ay2) for i, ay1, ay2 in active_segments if i != idx]
        
        return intersections

# ================================
# 5. 差分驱动模拟 - 差分数组
# ================================

class DifferenceArray:
    """
    差分数组实现，用于高效处理区间更新操作
    支持O(1)区间更新，O(n)获取结果数组
    """
    
    def __init__(self, size=None, initial_array=None):
        """
        初始化差分数组
        可以通过指定大小或初始数组来初始化
        
        参数:
            size: 数组大小
            initial_array: 初始数组
        """
        if initial_array is not None:
            self.size = len(initial_array)
            # 从初始数组构建差分数组
            self.diff = [0] * self.size
            self.diff[0] = initial_array[0]
            for i in range(1, self.size):
                self.diff[i] = initial_array[i] - initial_array[i-1]
        elif size is not None and size > 0:
            self.size = size
            self.diff = [0] * size  # 初始化为全0数组的差分数组
        else:
            raise ValueError("必须提供有效的size或initial_array")
    
    def range_add(self, l, r, val):
        """
        对区间[l, r]中的每个元素加上val
        时间复杂度: O(1)
        
        参数:
            l: 左边界（包含）
            r: 右边界（包含）
            val: 要添加的值
        """
        # 检查边界
        if l < 0 or r >= self.size or l > r:
            raise ValueError(f"无效的区间边界: [{l}, {r}]")
        
        # 在差分数组上进行标记
        self.diff[l] += val
        if r + 1 < self.size:
            self.diff[r + 1] -= val
    
    def get_result(self):
        """
        根据差分数组重构原始数组
        时间复杂度: O(n)
        
        返回:
            结果数组
        """
        res = [0] * self.size
        res[0] = self.diff[0]
        
        # 前缀和恢复原始数组
        for i in range(1, self.size):
            res[i] = res[i-1] + self.diff[i]
        
        return res
    
    def get_difference_array(self):
        """
        获取差分数组的副本
        
        返回:
            差分数组的副本
        """
        return self.diff.copy()
    
    def multiple_range_updates(self, updates):
        """
        批量执行多个区间更新操作
        
        参数:
            updates: 更新操作列表，每个操作是(l, r, val)的元组
        """
        for l, r, val in updates:
            self.range_add(l, r, val)
    
    def reset(self):
        """
        重置差分数组为全0
        """
        self.diff = [0] * self.size

# ================================
# 6. 双向循环链表
# ================================

class DoublyCircularLinkedListNode:
    """
    双向循环链表节点类
    """
    
    def __init__(self, data):
        self.data = data      # 节点数据
        self.prev = self      # 前驱节点，初始指向自己
        self.next = self      # 后继节点，初始指向自己


class DoublyCircularLinkedList:
    """
    双向循环链表实现
    支持高效的头部/尾部插入删除，以及任意位置的操作
    """
    
    def __init__(self):
        self.head = None  # 头节点指针
        self.size = 0     # 链表大小
    
    def is_empty(self):
        """
        检查链表是否为空
        """
        return self.head is None
    
    def get_size(self):
        """
        获取链表大小
        """
        return self.size
    
    def insert_at_head(self, data):
        """
        在链表头部插入元素
        时间复杂度: O(1)
        """
        new_node = DoublyCircularLinkedListNode(data)
        
        if self.is_empty():
            # 空链表情况
            self.head = new_node
        else:
            # 非空链表，插入到头部
            tail = self.head.prev
            
            # 连接新节点与尾节点
            new_node.prev = tail
            tail.next = new_node
            
            # 连接新节点与头节点
            new_node.next = self.head
            self.head.prev = new_node
            
            # 更新头节点
            self.head = new_node
        
        self.size += 1
    
    def insert_at_tail(self, data):
        """
        在链表尾部插入元素
        时间复杂度: O(1)
        """
        if self.is_empty():
            # 空链表情况，直接调用insert_at_head
            self.insert_at_head(data)
            return
        
        new_node = DoublyCircularLinkedListNode(data)
        tail = self.head.prev
        
        # 连接尾节点与新节点
        tail.next = new_node
        new_node.prev = tail
        
        # 连接新节点与头节点
        new_node.next = self.head
        self.head.prev = new_node
        
        self.size += 1
    
    def insert_at_position(self, index, data):
        """
        在指定位置插入元素
        时间复杂度: O(n)
        """
        if index < 0 or index > self.size:
            raise IndexError(f"插入位置无效: {index}")
        
        if index == 0:
            # 在头部插入
            self.insert_at_head(data)
            return
        
        if index == self.size:
            # 在尾部插入
            self.insert_at_tail(data)
            return
        
        # 找到插入位置的前一个节点
        # 优化：根据索引位置选择从头还是从尾开始遍历
        if index <= self.size // 2:
            # 从头开始遍历
            current = self.head
            for _ in range(index - 1):
                current = current.next
        else:
            # 从尾开始遍历
            current = self.head.prev
            for _ in range(self.size - index):
                current = current.prev
        
        # 创建新节点
        new_node = DoublyCircularLinkedListNode(data)
        next_node = current.next
        
        # 建立连接
        new_node.prev = current
        new_node.next = next_node
        current.next = new_node
        next_node.prev = new_node
        
        self.size += 1
    
    def delete_head(self):
        """
        删除链表头部元素
        时间复杂度: O(1)
        """
        if self.is_empty():
            raise IndexError("无法从空链表删除元素")
        
        data = self.head.data
        
        if self.size == 1:
            # 链表只有一个节点
            self.head = None
        else:
            # 链表有多个节点
            tail = self.head.prev
            new_head = self.head.next
            
            # 更新连接
            tail.next = new_head
            new_head.prev = tail
            
            # 更新头节点
            self.head = new_head
        
        self.size -= 1
        return data
    
    def delete_tail(self):
        """
        删除链表尾部元素
        时间复杂度: O(1)
        """
        if self.is_empty():
            raise IndexError("无法从空链表删除元素")
        
        if self.size == 1:
            # 链表只有一个节点，直接调用delete_head
            return self.delete_head()
        
        tail = self.head.prev
        data = tail.data
        
        # 更新连接
        new_tail = tail.prev
        new_tail.next = self.head
        self.head.prev = new_tail
        
        self.size -= 1
        return data
    
    def delete_at_position(self, index):
        """
        删除指定位置的元素
        时间复杂度: O(n)
        """
        if self.is_empty():
            raise IndexError("无法从空链表删除元素")
        
        if index < 0 or index >= self.size:
            raise IndexError(f"删除位置无效: {index}")
        
        if index == 0:
            return self.delete_head()
        
        if index == self.size - 1:
            return self.delete_tail()
        
        # 找到要删除的节点
        # 优化：根据索引位置选择从头还是从尾开始遍历
        if index <= self.size // 2:
            current = self.head
            for _ in range(index):
                current = current.next
        else:
            current = self.head.prev
            for _ in range(self.size - 1 - index):
                current = current.prev
        
        # 保存数据
        data = current.data
        
        # 更新连接
        prev_node = current.prev
        next_node = current.next
        prev_node.next = next_node
        next_node.prev = prev_node
        
        self.size -= 1
        return data
    
    def delete_by_value(self, value):
        """
        删除第一个出现的指定值的元素
        时间复杂度: O(n)
        """
        if self.is_empty():
            return False
        
        # 特殊情况：头节点就是要删除的节点
        if self.head.data == value:
            self.delete_head()
            return True
        
        # 遍历链表查找值
        current = self.head.next
        while current != self.head:
            if current.data == value:
                # 找到要删除的节点
                prev_node = current.prev
                next_node = current.next
                
                # 更新连接
                prev_node.next = next_node
                next_node.prev = prev_node
                
                self.size -= 1
                return True
            current = current.next
        
        # 未找到值
        return False
    
    def traverse_forward(self):
        """
        正向遍历链表
        时间复杂度: O(n)
        """
        result = []
        if self.is_empty():
            return result
        
        current = self.head
        while True:
            result.append(current.data)
            current = current.next
            if current == self.head:
                break
        
        return result
    
    def traverse_backward(self):
        """
        反向遍历链表
        时间复杂度: O(n)
        """
        result = []
        if self.is_empty():
            return result
        
        # 从尾节点开始
        current = self.head.prev
        while True:
            result.append(current.data)
            current = current.prev
            if current == self.head.prev:
                break
        
        return result
    
    def search(self, value):
        """
        查找第一个出现的指定值的索引
        时间复杂度: O(n)
        """
        if self.is_empty():
            return -1
        
        index = 0
        current = self.head
        while True:
            if current.data == value:
                return index
            current = current.next
            index += 1
            if current == self.head:
                break
        
        return -1
    
    def get(self, index):
        """
        获取指定索引的元素值
        时间复杂度: O(n)
        """
        if self.is_empty():
            raise IndexError("链表为空")
        
        if index < 0 or index >= self.size:
            raise IndexError(f"索引无效: {index}")
        
        # 优化：根据索引位置选择从头还是从尾开始遍历
        if index <= self.size // 2:
            current = self.head
            for _ in range(index):
                current = current.next
        else:
            current = self.head.prev
            for _ in range(self.size - 1 - index):
                current = current.prev
        
        return current.data
    
    def set(self, index, value):
        """
        设置指定索引的元素值
        时间复杂度: O(n)
        """
        if self.is_empty():
            raise IndexError("链表为空")
        
        if index < 0 or index >= self.size:
            raise IndexError(f"索引无效: {index}")
        
        # 优化：根据索引位置选择从头还是从尾开始遍历
        if index <= self.size // 2:
            current = self.head
            for _ in range(index):
                current = current.next
        else:
            current = self.head.prev
            for _ in range(self.size - 1 - index):
                current = current.prev
        
        old_value = current.data
        current.data = value
        return old_value
    
    def clear(self):
        """
        清空链表
        时间复杂度: O(n)
        """
        self.head = None
        self.size = 0
    
    def reverse(self):
        """
        反转链表
        时间复杂度: O(n)
        """
        if self.is_empty() or self.size == 1:
            return  # 空链表或只有一个节点不需要反转
        
        # 保存头节点和尾节点
        current = self.head
        tail = self.head.prev
        
        # 交换每个节点的prev和next指针
        while True:
            # 交换prev和next
            current.prev, current.next = current.next, current.prev
            
            # 移动到下一个节点（现在是prev指针）
            current = current.prev
            
            if current == self.head:
                break
        
        # 更新头节点为原来的尾节点
        self.head = tail
    
    def rotate(self, k):
        """
        旋转链表
        时间复杂度: O(n)
        
        参数:
            k: 旋转步数，正数表示向右旋转，负数表示向左旋转
        """
        if self.is_empty() or self.size == 1 or k % self.size == 0:
            return  # 无需旋转
        
        # 标准化k值，使其在[0, size-1]范围内
        k = k % self.size
        if k < 0:
            k += self.size  # 转换为正向旋转
        
        # 向右旋转k步相当于将倒数第k个节点作为新的头节点
        if k > 0:
            # 找到新的头节点（倒数第k个节点）
            new_head = self.head
            for _ in range(self.size - k):
                new_head = new_head.next
            
            # 更新头节点
            self.head = new_head
    
    def print_list(self):
        """
        打印链表内容
        时间复杂度: O(n)
        """
        if self.is_empty():
            print("链表为空")
            return
        
        elements = []
        current = self.head
        while True:
            elements.append(str(current.data))
            current = current.next
            if current == self.head:
                break
        
        print(" <-> ".join(elements) + " (循环)")

===============================================

文件: algorithm2.java
===============================================
package class185;

import java.util.*;
import java.util.stream.Collectors;

/**
 * Java版本算法与数据结构实现
 * 包含：
 * 1. 平面分治 (Closest Pair of Points)
 * 2. 棋盘模拟 (Game of Life)
 * 3. 间隔打表 (Sparse Table)
 * 4. 事件排序 (Time Sweep)
 * 5. 差分驱动模拟 (Difference Array)
 * 6. 双向循环链表 (Doubly Circular Linked List)
 * 7. 斐波那契堆 (Fibonacci Heap)
 * 8. 块状链表 (Unrolled Linked List)
 * 
 * 时间复杂度分析：
 * - 平面分治: O(n log n)
 * - 棋盘模拟: O(m*n)
 * - 间隔打表: O(n log n) 预处理, O(1) 查询
 * - 事件排序: O(n log n)
 * - 差分驱动: O(1) 区间更新, O(n) 获取结果
 * - 双向循环链表: 插入/删除头部/尾部 O(1), 其他 O(n)
 * - 斐波那契堆: 插入 O(1) 均摊, 提取最小 O(log n) 均摊
 * - 块状链表: O(n/b) 操作复杂度，b为块大小
 */

public class algorithm2 {
    
    // ================================
    // 1. 平面分治 - 最近点对问题
    // ================================
    
    static class Point {
        double x, y;
        
        public Point(double x, double y) {
            this.x = x;
            this.y = y;
        }
        
        @Override
        public String toString() {
            return "Point(" + x + ", " + y + ")";
        }
        
        public double distanceTo(Point other) {
            double dx = this.x - other.x;
            double dy = this.y - other.y;
            return Math.sqrt(dx * dx + dy * dy);
        }
    }
    
    static class PairDistance {
        double distance;
        Point p1, p2;
        
        public PairDistance(double distance, Point p1, Point p2) {
            this.distance = distance;
            this.p1 = p1;
            this.p2 = p2;
        }
    }
    
    public static PairDistance closestPair(List<Point> points) {
        if (points == null || points.isEmpty()) {
            throw new IllegalArgumentException("输入点列表不能为空");
        }
        if (points.size() < 2) {
            throw new IllegalArgumentException("至少需要两个点来计算距离");
        }
        
        // 按x坐标排序
        List<Point> pointsSortedByX = new ArrayList<>(points);
        Collections.sort(pointsSortedByX, Comparator.comparingDouble(p -> p.x));
        
        // 按y坐标排序，用于带内搜索
        List<Point> pointsSortedByY = new ArrayList<>(points);
        Collections.sort(pointsSortedByY, Comparator.comparingDouble(p -> p.y));
        
        // 调用递归函数
        return closestPairRecursive(pointsSortedByX, pointsSortedByY);
    }
    
    private static PairDistance closestPairRecursive(List<Point> pointsSortedByX, List<Point> pointsSortedByY) {
        int n = pointsSortedByX.size();
        
        // 基本情况：小于等于3个点，使用暴力法
        if (n <= 3) {
            return bruteForceClosestPair(pointsSortedByX);
        }
        
        // 分治：将点集分为左右两部分
        int mid = n / 2;
        Point midPoint = pointsSortedByX.get(mid);
        
        // 分割y排序的点列表
        List<Point> leftPointsY = new ArrayList<>();
        List<Point> rightPointsY = new ArrayList<>();
        
        for (Point p : pointsSortedByY) {
            if (p.x <= midPoint.x) {
                leftPointsY.add(p);
            } else {
                rightPointsY.add(p);
            }
        }
        
        // 递归求解左右两部分的最近点对
        PairDistance leftResult = closestPairRecursive(
            pointsSortedByX.subList(0, mid), leftPointsY);
        PairDistance rightResult = closestPairRecursive(
            pointsSortedByX.subList(mid, n), rightPointsY);
        
        // 合并：取左右两部分中的最小距离
        PairDistance minResult = (leftResult.distance <= rightResult.distance) 
            ? leftResult : rightResult;
        
        // 带内搜索：查找跨越中线的点对
        // 构建带内的点列表，只考虑x坐标在中线附近min_dist范围内的点
        List<Point> strip = new ArrayList<>();
        for (Point p : pointsSortedByY) {
            if (Math.abs(p.x - midPoint.x) < minResult.distance) {
                strip.add(p);
            }
        }
        
        // 在带内查找可能的更近点对
        PairDistance stripResult = stripClosest(strip, minResult);
        
        // 比较并返回全局最小距离
        return (stripResult.distance < minResult.distance) ? stripResult : minResult;
    }
    
    private static PairDistance bruteForceClosestPair(List<Point> points) {
        int n = points.size();
        double minDist = Double.MAX_VALUE;
        Point p1 = null, p2 = null;
        
        for (int i = 0; i < n; i++) {
            for (int j = i + 1; j < n; j++) {
                double dist = points.get(i).distanceTo(points.get(j));
                if (dist < minDist) {
                    minDist = dist;
                    p1 = points.get(i);
                    p2 = points.get(j);
                }
            }
        }
        
        return new PairDistance(minDist, p1, p2);
    }
    
    private static PairDistance stripClosest(List<Point> strip, PairDistance currentMin) {
        double minDist = currentMin.distance;
        Point p1 = currentMin.p1;
        Point p2 = currentMin.p2;
        
        // 按y坐标排序已经完成
        int size = strip.size();
        
        // 对于带内的每个点，只需要检查后面y坐标相差不超过min_dist的点
        for (int i = 0; i < size; i++) {
            for (int j = i + 1; j < size && (strip.get(j).y - strip.get(i).y) < minDist; j++) {
                double dist = strip.get(i).distanceTo(strip.get(j));
                if (dist < minDist) {
                    minDist = dist;
                    p1 = strip.get(i);
                    p2 = strip.get(j);
                }
            }
        }
        
        return new PairDistance(minDist, p1, p2);
    }
    
    // ================================
    // 2. 棋盘模拟 - 生命游戏
    // ================================
    
    static class GameOfLife {
        private int[][] board;
        private int rows;
        private int cols;
        
        public GameOfLife(int[][] initialBoard) {
            if (initialBoard == null || initialBoard.length == 0 || initialBoard[0].length == 0) {
                throw new IllegalArgumentException("输入棋盘不能为空");
            }
            
            // 深拷贝输入棋盘
            this.rows = initialBoard.length;
            this.cols = initialBoard[0].length;
            this.board = new int[rows][cols];
            
            for (int i = 0; i < rows; i++) {
                System.arraycopy(initialBoard[i], 0, this.board[i], 0, cols);
            }
        }
        
        private int countNeighbors(int[][] board, int row, int col) {
            int neighbors = 0;
            // 八个方向的偏移
            int[][] directions = {
                {-1, -1}, {-1, 0}, {-1, 1},
                {0, -1},          {0, 1},
                {1, -1},  {1, 0}, {1, 1}
            };
            
            for (int[] dir : directions) {
                int r = row + dir[0];
                int c = col + dir[1];
                
                // 检查边界并计数
                if (r >= 0 && r < rows && c >= 0 && c < cols) {
                    // 注意：对于原地版本，我们需要考虑标记后的状态
                    // 1和2表示原始状态为活细胞（1：保持活，2：将死亡）
                    if (board[r][c] == 1 || board[r][c] == 2) {
                        neighbors++;
                    }
                }
            }
            
            return neighbors;
        }
        
        public int[][] nextGenerationStandard() {
            // 创建新棋盘存储下一代状态
            int[][] nextBoard = new int[rows][cols];
            
            // 计算每个细胞的下一代状态
            for (int i = 0; i < rows; i++) {
                for (int j = 0; j < cols; j++) {
                    int neighbors = countNeighbors(this.board, i, j);
                    
                    // 应用生命游戏规则
                    if (this.board[i][j] == 1) {  // 活细胞
                        if (neighbors < 2 || neighbors > 3) {
                            nextBoard[i][j] = 0;  // 死亡：人口稀少或过度拥挤
                        } else {
                            nextBoard[i][j] = 1;  // 存活
                        }
                    } else {  // 死细胞
                        if (neighbors == 3) {
                            nextBoard[i][j] = 1;  // 繁殖
                        }
                    }
                }
            }
            
            // 更新当前棋盘
            this.board = nextBoard;
            return this.board;
        }
        
        public int[][] nextGenerationInplace() {
            // 编码规则：
            // 0: 死细胞 -> 死细胞
            // 1: 活细胞 -> 活细胞
            // 2: 活细胞 -> 死细胞
            // 3: 死细胞 -> 活细胞
            
            for (int i = 0; i < rows; i++) {
                for (int j = 0; j < cols; j++) {
                    int neighbors = countNeighbors(this.board, i, j);
                    
                    if (this.board[i][j] == 1) {  // 活细胞
                        if (neighbors < 2 || neighbors > 3) {
                            this.board[i][j] = 2;  // 标记为将死亡
                        }
                    } else {  // 死细胞
                        if (neighbors == 3) {
                            this.board[i][j] = 3;  // 标记为将复活
                        }
                    }
                }
            }
            
            // 解码：将标记转换回0和1
            for (int i = 0; i < rows; i++) {
                for (int j = 0; j < cols; j++) {
                    this.board[i][j] %= 2;  // 2 -> 0, 3 -> 1
                }
            }
            
            return this.board;
        }
        
        public int[][] simulate(int generations, boolean inplace) {
            if (generations <= 0) {
                return getBoard();
            }
            
            for (int i = 0; i < generations; i++) {
                if (inplace) {
                    nextGenerationInplace();
                } else {
                    nextGenerationStandard();
                }
            }
            
            return getBoard();
        }
        
        public int[][] getBoard() {
            // 返回深拷贝，避免外部修改
            int[][] copy = new int[rows][cols];
            for (int i = 0; i < rows; i++) {
                System.arraycopy(this.board[i], 0, copy[i], 0, cols);
            }
            return copy;
        }
        
        public void printBoard() {
            for (int[] row : board) {
                for (int cell : row) {
                    System.out.print(cell == 1 ? '█' : ' ');
                    System.out.print(' ');
                }
                System.out.println();
            }
            System.out.println();
        }
    }
    
    // ================================
    // 3. 间隔打表 - 稀疏表
    // ================================
    
    static class SparseTable {
        private int[] data;
        private int[][] st;
        private int[] logTable;
        private BiFunction<Integer, Integer, Integer> func;
        
        public SparseTable(int[] data, BiFunction<Integer, Integer, Integer> func) {
            if (data == null || data.length == 0) {
                throw new IllegalArgumentException("输入数据不能为空");
            }
            
            this.data = data;
            this.func = func;
            this.logTable = buildLogTable();
            this.st = buildSparseTable();
        }
        
        public SparseTable(int[] data) {
            // 默认使用最小值函数
            this(data, Math::min);
        }
        
        private int[] buildLogTable() {
            int n = data.length;
            int[] logTable = new int[n + 1];
            for (int i = 2; i <= n; i++) {
                logTable[i] = logTable[i / 2] + 1;
            }
            return logTable;
        }
        
        private int[][] buildSparseTable() {
            int n = data.length;
            int kMax = logTable[n] + 1;
            int[][] st = new int[kMax][n];
            
            // 初始化k=0的情况（长度为1的区间）
            for (int i = 0; i < n; i++) {
                st[0][i] = data[i];
            }
            
            // 动态规划构建其他k值
            for (int k = 1; (1 << k) <= n; k++) {
                for (int i = 0; i + (1 << k) <= n; i++) {
                    // 合并两个长度为2^(k-1)的区间
                    st[k][i] = func.apply(
                        st[k-1][i],
                        st[k-1][i + (1 << (k-1))]
                    );
                }
            }
            
            return st;
        }
        
        public int queryRange(int l, int r) {
            // 检查边界
            if (l < 0 || r >= data.length || l > r) {
                throw new IllegalArgumentException("无效的区间边界: [" + l + ", " + r + "]");
            }
            
            // 计算区间长度
            int length = r - l + 1;
            // 找到最大的k，使得2^k <= length
            int k = logTable[length];
            
            // 查询两个重叠的子区间并合并结果
            return func.apply(
                st[k][l],
                st[k][r - (1 << k) + 1]
            );
        }
        
        public List<Integer> batchQuery(List<int[]> queries) {
            List<Integer> results = new ArrayList<>();
            for (int[] query : queries) {
                results.add(queryRange(query[0], query[1]));
            }
            return results;
        }
        
        public boolean isRangeAllSame(int l, int r) {
            if (l == r) {
                return true;
            }
            return queryRange(l, r) == data[l];
        }
        
        public int getRangeExtreme(int l, int r) {
            return queryRange(l, r);
        }
    }
    
    // 函数式接口，用于表示二元函数
    interface BiFunction<A, B, R> {
        R apply(A a, B b);
    }
    
    // ================================
    // 4. 事件排序 - 扫描线算法
    // ================================
    
    static class EventSweep {
        
        public static class OverlapResult {
            int maxOverlap;
            List<int[]> overlappingIntervals;
            
            public OverlapResult(int maxOverlap, List<int[]> overlappingIntervals) {
                this.maxOverlap = maxOverlap;
                this.overlappingIntervals = overlappingIntervals;
            }
        }
        
        public static OverlapResult intervalOverlap(int[][] intervals) {
            if (intervals == null || intervals.length == 0) {
                return new OverlapResult(0, new ArrayList<>());
            }
            
            // 创建事件点列表
            List<Event> events = new ArrayList<>();
            for (int i = 0; i < intervals.length; i++) {
                int start = intervals[i][0];
                int end = intervals[i][1];
                if (start > end) {
                    throw new IllegalArgumentException("无效的区间: [" + start + ", " + end + "]");
                }
                events.add(new Event(start, 1, i));  // 开始事件
                events.add(new Event(end, -1, i));   // 结束事件
            }
            
            // 按位置排序事件，当位置相同时，结束事件优先
            Collections.sort(events);
            
            int currentOverlap = 0;
            int maxOverlap = 0;
            Set<Integer> activeIntervals = new HashSet<>();
            Set<Integer> maxOverlapIntervalIndices = new HashSet<>();
            
            // 扫描事件
            for (Event event : events) {
                // 更新当前重叠数量
                currentOverlap += event.type;
                
                // 更新活动区间列表
                if (event.type == 1) {
                    activeIntervals.add(event.index);
                } else {
                    activeIntervals.remove(event.index);
                }
                
                // 更新最大重叠
                if (currentOverlap > maxOverlap) {
                    maxOverlap = currentOverlap;
                    maxOverlapIntervalIndices = new HashSet<>(activeIntervals);
                }
            }
            
            // 收集重叠的区间
            List<int[]> overlappingIntervals = new ArrayList<>();
            for (int idx : maxOverlapIntervalIndices) {
                overlappingIntervals.add(intervals[idx]);
            }
            
            return new OverlapResult(maxOverlap, overlappingIntervals);
        }
        
        // 事件类，用于排序
        static class Event implements Comparable<Event> {
            int pos;
            int type;  // 1表示开始，-1表示结束
            int index;
            
            public Event(int pos, int type, int index) {
                this.pos = pos;
                this.type = type;
                this.index = index;
            }
            
            @Override
            public int compareTo(Event other) {
                // 按位置排序，当位置相同时，结束事件（type=-1）优先
                if (this.pos != other.pos) {
                    return Integer.compare(this.pos, other.pos);
                }
                return Integer.compare(this.type, other.type);
            }
        }
        
        public static int rectangleArea(int[][] rectangles) {
            if (rectangles == null || rectangles.length == 0) {
                return 0;
            }
            
            // 创建垂直边事件
            List<RectangleEvent> events = new ArrayList<>();
            Set<Integer> xCoords = new HashSet<>();
            
            for (int[] rect : rectangles) {
                int x1 = rect[0];
                int y1 = rect[1];
                int x2 = rect[2];
                int y2 = rect[3];
                
                if (x1 >= x2 || y1 >= y2) {
                    throw new IllegalArgumentException("无效的矩形: [" + x1 + ", " + y1 + ", " + x2 + ", " + y2 + "]");
                }
                
                // 添加垂直线事件
                events.add(new RectangleEvent(x1, true, y1, y2));  // 左边界
                events.add(new RectangleEvent(x2, false, y1, y2)); // 右边界
                xCoords.add(x1);
                xCoords.add(x2);
            }
            
            // 按x坐标排序事件
            Collections.sort(events);
            // 排序x坐标
            List<Integer> sortedX = new ArrayList<>(xCoords);
            Collections.sort(sortedX);
            
            List<int[]> activeIntervals = new ArrayList<>();
            int area = 0;
            Integer prevX = null;
            
            // 扫描事件
            for (RectangleEvent event : events) {
                // 计算当前扫描线和前一条扫描线之间的面积
                if (prevX != null && event.x > prevX && !activeIntervals.isEmpty()) {
                    // 计算当前活动的y区间的总长度
                    int activeLength = mergeAndCalculateLength(activeIntervals);
                    // 面积 = 宽度 * 高度
                    area += (event.x - prevX) * activeLength;
                }
                
                // 更新活动区间
                if (event.isStart) {
                    activeIntervals.add(new int[]{event.y1, event.y2});
                } else {
                    // 移除对应的区间
                    activeIntervals.removeIf(interval -> interval[0] == event.y1 && interval[1] == event.y2);
                }
                
                prevX = event.x;
            }
            
            return area;
        }
        
        static class RectangleEvent implements Comparable<RectangleEvent> {
            int x;
            boolean isStart;
            int y1, y2;
            
            public RectangleEvent(int x, boolean isStart, int y1, int y2) {
                this.x = x;
                this.isStart = isStart;
                this.y1 = y1;
                this.y2 = y2;
            }
            
            @Override
            public int compareTo(RectangleEvent other) {
                return Integer.compare(this.x, other.x);
            }
        }
        
        private static int mergeAndCalculateLength(List<int[]> intervals) {
            if (intervals == null || intervals.isEmpty()) {
                return 0;
            }
            
            // 按起始位置排序
            Collections.sort(intervals, Comparator.comparingInt(a -> a[0]));
            
            List<int[]> merged = new ArrayList<>();
            merged.add(intervals.get(0));
            
            for (int i = 1; i < intervals.size(); i++) {
                int[] current = intervals.get(i);
                int[] last = merged.get(merged.size() - 1);
                
                if (current[0] <= last[1]) {  // 有重叠
                    // 合并区间
                    int newStart = last[0];
                    int newEnd = Math.max(last[1], current[1]);
                    merged.set(merged.size() - 1, new int[]{newStart, newEnd});
                } else {
                    merged.add(current);
                }
            }
            
            // 计算总长度
            int totalLength = 0;
            for (int[] interval : merged) {
                totalLength += interval[1] - interval[0];
            }
            
            return totalLength;
        }
    }
    
    // ================================
    // 5. 差分驱动模拟 - 差分数组
    // ================================
    
    static class DifferenceArray {
        private int[] diff;
        private int size;
        
        public DifferenceArray(int size) {
            if (size <= 0) {
                throw new IllegalArgumentException("数组大小必须为正数");
            }
            this.size = size;
            this.diff = new int[size];  // 初始化为全0数组的差分数组
        }
        
        public DifferenceArray(int[] initialArray) {
            if (initialArray == null || initialArray.length == 0) {
                throw new IllegalArgumentException("初始数组不能为空");
            }
            
            this.size = initialArray.length;
            // 从初始数组构建差分数组
            this.diff = new int[size];
            this.diff[0] = initialArray[0];
            for (int i = 1; i < size; i++) {
                this.diff[i] = initialArray[i] - initialArray[i-1];
            }
        }
        
        public void rangeAdd(int l, int r, int val) {
            // 检查边界
            if (l < 0 || r >= size || l > r) {
                throw new IllegalArgumentException("无效的区间边界: [" + l + ", " + r + "]");
            }
            
            // 在差分数组上进行标记
            diff[l] += val;
            if (r + 1 < size) {
                diff[r + 1] -= val;
            }
        }
        
        public int[] getResult() {
            int[] res = new int[size];
            res[0] = diff[0];
            
            // 前缀和恢复原始数组
            for (int i = 1; i < size; i++) {
                res[i] = res[i-1] + diff[i];
            }
            
            return res;
        }
        
        public int[] getDifferenceArray() {
            return diff.clone();  // 返回副本
        }
        
        public void multipleRangeUpdates(int[][] updates) {
            for (int[] update : updates) {
                rangeAdd(update[0], update[1], update[2]);
            }
        }
        
        public void reset() {
            Arrays.fill(diff, 0);
        }
    }
    
    // ================================
    // 6. 双向循环链表
    // ================================
    
    static class DoublyCircularLinkedList {
        private Node head;
        private int size;
        
        private static class Node {
            int data;
            Node prev;
            Node next;
            
            public Node(int data) {
                this.data = data;
                this.prev = this;  // 初始指向自己
                this.next = this;  // 初始指向自己
            }
        }
        
        public DoublyCircularLinkedList() {
            this.head = null;
            this.size = 0;
        }
        
        public boolean isEmpty() {
            return head == null;
        }
        
        public int getSize() {
            return size;
        }
        
        public void insertAtHead(int data) {
            Node newNode = new Node(data);
            
            if (isEmpty()) {
                // 空链表情况
                head = newNode;
            } else {
                // 非空链表，插入到头部
                Node tail = head.prev;
                
                // 连接新节点与尾节点
                newNode.prev = tail;
                tail.next = newNode;
                
                // 连接新节点与头节点
                newNode.next = head;
                head.prev = newNode;
                
                // 更新头节点
                head = newNode;
            }
            
            size++;
        }
        
        public void insertAtTail(int data) {
            if (isEmpty()) {
                // 空链表情况，直接调用insertAtHead
                insertAtHead(data);
                return;
            }
            
            Node newNode = new Node(data);
            Node tail = head.prev;
            
            // 连接尾节点与新节点
            tail.next = newNode;
            newNode.prev = tail;
            
            // 连接新节点与头节点
            newNode.next = head;
            head.prev = newNode;
            
            size++;
        }
        
        public void insertAtPosition(int index, int data) {
            if (index < 0 || index > size) {
                throw new IndexOutOfBoundsException("插入位置无效: " + index);
            }
            
            if (index == 0) {
                // 在头部插入
                insertAtHead(data);
                return;
            }
            
            if (index == size) {
                // 在尾部插入
                insertAtTail(data);
                return;
            }
            
            // 找到插入位置的前一个节点
            Node current;
            if (index <= size / 2) {
                // 从头开始遍历
                current = head;
                for (int i = 0; i < index - 1; i++) {
                    current = current.next;
                }
            } else {
                // 从尾开始遍历
                current = head.prev;
                for (int i = 0; i < size - index; i++) {
                    current = current.prev;
                }
            }
            
            // 创建新节点
            Node newNode = new Node(data);
            Node nextNode = current.next;
            
            // 建立连接
            newNode.prev = current;
            newNode.next = nextNode;
            current.next = newNode;
            nextNode.prev = newNode;
            
            size++;
        }
        
        public int deleteHead() {
            if (isEmpty()) {
                throw new IllegalStateException("无法从空链表删除元素");
            }
            
            int data = head.data;
            
            if (size == 1) {
                // 链表只有一个节点
                head = null;
            } else {
                // 链表有多个节点
                Node tail = head.prev;
                Node newHead = head.next;
                
                // 更新连接
                tail.next = newHead;
                newHead.prev = tail;
                
                // 更新头节点
                head = newHead;
            }
            
            size--;
            return data;
        }
        
        public int deleteTail() {
            if (isEmpty()) {
                throw new IllegalStateException("无法从空链表删除元素");
            }
            
            if (size == 1) {
                // 链表只有一个节点，直接调用deleteHead
                return deleteHead();
            }
            
            Node tail = head.prev;
            int data = tail.data;
            
            // 更新连接
            Node newTail = tail.prev;
            newTail.next = head;
            head.prev = newTail;
            
            size--;
            return data;
        }
        
        public int deleteAtPosition(int index) {
            if (isEmpty()) {
                throw new IllegalStateException("无法从空链表删除元素");
            }
            
            if (index < 0 || index >= size) {
                throw new IndexOutOfBoundsException("删除位置无效: " + index);
            }
            
            if (index == 0) {
                return deleteHead();
            }
            
            if (index == size - 1) {
                return deleteTail();
            }
            
            // 找到要删除的节点
            Node current;
            if (index <= size / 2) {
                current = head;
                for (int i = 0; i < index; i++) {
                    current = current.next;
                }
            } else {
                current = head.prev;
                for (int i = 0; i < size - 1 - index; i++) {
                    current = current.prev;
                }
            }
            
            // 保存数据
            int data = current.data;
            
            // 更新连接
            Node prevNode = current.prev;
            Node nextNode = current.next;
            prevNode.next = nextNode;
            nextNode.prev = prevNode;
            
            size--;
            return data;
        }
        
        public boolean deleteByValue(int value) {
            if (isEmpty()) {
                return false;
            }
            
            // 特殊情况：头节点就是要删除的节点
            if (head.data == value) {
                deleteHead();
                return true;
            }
            
            // 遍历链表查找值
            Node current = head.next;
            while (current != head) {
                if (current.data == value) {
                    // 找到要删除的节点
                    Node prevNode = current.prev;
                    Node nextNode = current.next;
                    
                    // 更新连接
                    prevNode.next = nextNode;
                    nextNode.prev = prevNode;
                    
                    size--;
                    return true;
                }
                current = current.next;
            }
            
            // 未找到值
            return false;
        }
        
        public List<Integer> traverseForward() {
            List<Integer> result = new ArrayList<>();
            if (isEmpty()) {
                return result;
            }
            
            Node current = head;
            do {
                result.add(current.data);
                current = current.next;
            } while (current != head);
            
            return result;
        }
        
        public List<Integer> traverseBackward() {
            List<Integer> result = new ArrayList<>();
            if (isEmpty()) {
                return result;
            }
            
            // 从尾节点开始
            Node current = head.prev;
            do {
                result.add(current.data);
                current = current.prev;
            } while (current != head.prev);
            
            return result;
        }
        
        public int search(int value) {
            if (isEmpty()) {
                return -1;
            }
            
            int index = 0;
            Node current = head;
            do {
                if (current.data == value) {
                    return index;
                }
                current = current.next;
                index++;
            } while (current != head);
            
            return -1;
        }
        
        public int get(int index) {
            if (isEmpty()) {
                throw new IllegalStateException("链表为空");
            }
            
            if (index < 0 || index >= size) {
                throw new IndexOutOfBoundsException("索引无效: " + index);
            }
            
            // 优化：根据索引位置选择从头还是从尾开始遍历
            Node current;
            if (index <= size / 2) {
                current = head;
                for (int i = 0; i < index; i++) {
                    current = current.next;
                }
            } else {
                current = head.prev;
                for (int i = 0; i < size - 1 - index; i++) {
                    current = current.prev;
                }
            }
            
            return current.data;
        }
        
        public int set(int index, int value) {
            if (isEmpty()) {
                throw new IllegalStateException("链表为空");
            }
            
            if (index < 0 || index >= size) {
                throw new IndexOutOfBoundsException("索引无效: " + index);
            }
            
            // 优化：根据索引位置选择从头还是从尾开始遍历
            Node current;
            if (index <= size / 2) {
                current = head;
                for (int i = 0; i < index; i++) {
                    current = current.next;
                }
            } else {
                current = head.prev;
                for (int i = 0; i < size - 1 - index; i++) {
                    current = current.prev;
                }
            }
            
            int oldValue = current.data;
            current.data = value;
            return oldValue;
        }
        
        public void clear() {
            head = null;
            size = 0;
        }
        
        public void reverse() {
            if (isEmpty() || size == 1) {
                return;  // 空链表或只有一个节点不需要反转
            }
            
            // 保存头节点和尾节点
            Node current = head;
            Node tail = head.prev;
            
            // 交换每个节点的prev和next指针
            do {
                // 交换prev和next
                Node temp = current.prev;
                current.prev = current.next;
                current.next = temp;
                
                // 移动到下一个节点（现在是prev指针）
                current = current.prev;
                
            } while (current != head);
            
            // 更新头节点为原来的尾节点
            head = tail;
        }
        
        public void rotate(int k) {
            if (isEmpty() || size == 1 || k % size == 0) {
                return;  // 无需旋转
            }
            
            // 标准化k值，使其在[0, size-1]范围内
            k = k % size;
            if (k < 0) {
                k += size;  // 转换为正向旋转
            }
            
            // 向右旋转k步相当于将倒数第k个节点作为新的头节点
            if (k > 0) {
                // 找到新的头节点（倒数第k个节点）
                Node newHead = head;
                for (int i = 0; i < size - k; i++) {
                    newHead = newHead.next;
                }
                
                // 更新头节点
                head = newHead;
            }
        }
        
        public void printList() {
            if (isEmpty()) {
                System.out.println("链表为空");
                return;
            }
            
            StringBuilder sb = new StringBuilder();
            Node current = head;
            do {
                sb.append(current.data);
                if (current.next != head) {
                    sb.append(" <-> ");
                }
                current = current.next;
            } while (current != head);
            
            sb.append(" (循环)");
            System.out.println(sb.toString());
        }
    }
    
    // ================================
    // 主函数，用于测试
    // ================================
    
    public static void main(String[] args) {
        System.out.println("=== Java算法与数据结构实现 ===");
        
        // 这里可以添加测试代码
        testClosestPair();
        testGameOfLife();
        testSparseTable();
        testEventSweep();
        testDifferenceArray();
        testDoublyCircularLinkedList();
    }
    
    private static void testClosestPair() {
        System.out.println("\n=== 测试平面分治算法 - 最近点对 ===");
        
        List<Point> points = Arrays.asList(
            new Point(0, 0),
            new Point(3, 0),
            new Point(0, 4),
            new Point(1, 1)
        );
        
        PairDistance result = closestPair(points);
        System.out.println("最小距离: " + result.distance);
        System.out.println("最近点对: " + result.p1 + " 和 " + result.p2);
    }
    
    private static void testGameOfLife() {
        System.out.println("\n=== 测试生命游戏 ===");
        
        int[][] initialBoard = {
            {0, 1, 0},
            {0, 1, 0},
            {0, 1, 0}
        };
        
        GameOfLife game = new GameOfLife(initialBoard);
        System.out.println("初始状态:");
        game.printBoard();
        
        game.simulate(1, true);
        System.out.println("下一代状态:");
        game.printBoard();
    }
    
    private static void testSparseTable() {
        System.out.println("\n=== 测试稀疏表 ===");
        
        int[] data = {5, 2, 9, 3, 7, 6, 1, 8, 4};
        SparseTable st = new SparseTable(data);
        
        System.out.println("区间[0, 2]最小值: " + st.queryRange(0, 2));
        System.out.println("区间[3, 7]最小值: " + st.queryRange(3, 7));
    }
    
    private static void testEventSweep() {
        System.out.println("\n=== 测试事件扫描算法 ===");
        
        int[][] intervals = {{1, 5}, {2, 7}, {3, 9}, {8, 10}};
        EventSweep.OverlapResult result = EventSweep.intervalOverlap(intervals);
        
        System.out.println("最大重叠数量: " + result.maxOverlap);
        System.out.println("重叠的区间: " + 
            result.overlappingIntervals.stream()
                .map(interval -> "[" + interval[0] + ", " + interval[1] + "]")
                .collect(Collectors.joining(", ")));
    }
    
    private static void testDifferenceArray() {
        System.out.println("\n=== 测试差分数组 ===");
        
        DifferenceArray diffArray = new DifferenceArray(10);
        diffArray.rangeAdd(1, 5, 2);
        diffArray.rangeAdd(3, 8, 3);
        
        int[] result = diffArray.getResult();
        System.out.println("结果数组: " + Arrays.toString(result));
    }
    
    private static void testDoublyCircularLinkedList() {
        System.out.println("\n=== 测试双向循环链表 ===");
        
        DoublyCircularLinkedList list = new DoublyCircularLinkedList();
        list.insertAtHead(1);
        list.insertAtTail(3);
        list.insertAtPosition(1, 2);
        
        System.out.print("链表内容: ");
        list.printList();
        
        System.out.println("正向遍历: " + list.traverseForward());
        System.out.println("反向遍历: " + list.traverseBackward());
    }
}

===============================================

文件: BaseCycleTreeImplementation.java
===============================================
package class008_AdvancedAlgorithmsAndDataStructures.base_cycle_tree_problems;

import java.util.*;

/**
 * 基环树 (Base Cycle Tree) 实现
 * 
 * 基环树是一种特殊的图结构，它由一个环和若干棵以环上节点为根的树组成。
 * 每个节点恰好有一条入边，因此整个图由一个或多个环组成，每个环上可能挂着一些树。
 * 
 * 应用场景：
 * 1. 数据结构：函数式数据结构、持久化数据结构
 * 2. 图论算法：环检测、强连通分量
 * 3. 数学：置换群、循环结构
 * 
 * 算法思路：
 * 1. 检测图中的环
 * 2. 对环上的每个节点，构建以其为根的子树
 * 3. 分析环的性质和子树的性质
 * 
 * 时间复杂度：O(V + E)
 * 空间复杂度：O(V)
 */
public class BaseCycleTreeImplementation {
    
    static class BaseCycleTree {
        private int n; // 节点数
        private int[] parent; // 每个节点的父节点
        private boolean[] visited; // 访问标记
        private List<List<Integer>> children; // 每个节点的子节点
        private List<Integer> cycle; // 环上的节点
        private boolean[] inCycle; // 标记节点是否在环上
        
        public BaseCycleTree(int n, int[] parent) {
            this.n = n;
            this.parent = parent.clone();
            this.visited = new boolean[n];
            this.children = new ArrayList<>();
            this.inCycle = new boolean[n];
            
            for (int i = 0; i < n; i++) {
                children.add(new ArrayList<>());
            }
            
            // 构建子节点关系
            for (int i = 0; i < n; i++) {
                if (parent[i] != -1) {
                    children.get(parent[i]).add(i);
                }
            }
            
            // 检测环
            findCycle();
        }
        
        // 检测环
        private void findCycle() {
            cycle = new ArrayList<>();
            Arrays.fill(visited, false);
            Arrays.fill(inCycle, false);
            
            // 找到环的起始节点
            int start = -1;
            for (int i = 0; i < n; i++) {
                if (!visited[i]) {
                    List<Integer> path = new ArrayList<>();
                    if (dfs(i, path)) {
                        start = i;
                        break;
                    }
                }
            }
            
            if (start == -1) return; // 没有环
            
            // 重新遍历以找到完整的环
            Arrays.fill(visited, false);
            List<Integer> path = new ArrayList<>();
            findCyclePath(start, path);
            
            // 标记环上的节点
            cycle = path;
            for (int node : cycle) {
                inCycle[node] = true;
            }
        }
        
        // DFS检测环
        private boolean dfs(int node, List<Integer> path) {
            if (visited[node]) {
                // 找到环的起点
                path.add(node);
                return true;
            }
            
            visited[node] = true;
            path.add(node);
            
            if (parent[node] != -1 && dfs(parent[node], path)) {
                return true;
            }
            
            path.remove(path.size() - 1);
            return false;
        }
        
        // 找到环的路径
        private boolean findCyclePath(int node, List<Integer> path) {
            if (visited[node]) {
                // 找到环的起点，截取环的部分
                int startIndex = path.indexOf(node);
                if (startIndex != -1) {
                    List<Integer> cyclePath = new ArrayList<>();
                    for (int i = startIndex; i < path.size(); i++) {
                        cyclePath.add(path.get(i));
                    }
                    path.clear();
                    path.addAll(cyclePath);
                    return true;
                }
                return false;
            }
            
            visited[node] = true;
            path.add(node);
            
            if (parent[node] != -1 && findCyclePath(parent[node], path)) {
                return true;
            }
            
            path.remove(path.size() - 1);
            return false;
        }
        
        // 获取环上的节点
        public List<Integer> getCycle() {
            return new ArrayList<>(cycle);
        }
        
        // 检查节点是否在环上
        public boolean isInCycle(int node) {
            return inCycle[node];
        }
        
        // 获取以指定节点为根的子树大小
        public int getSubtreeSize(int root) {
            return getSubtreeSizeHelper(root);
        }
        
        private int getSubtreeSizeHelper(int node) {
            int size = 1; // 包括节点本身
            for (int child : children.get(node)) {
                if (!inCycle[child]) { // 只计算不在环上的子节点
                    size += getSubtreeSizeHelper(child);
                }
            }
            return size;
        }
        
        // 获取环的长度
        public int getCycleLength() {
            return cycle.size();
        }
        
        // 获取所有子树的大小
        public Map<Integer, Integer> getAllSubtreeSizes() {
            Map<Integer, Integer> sizes = new HashMap<>();
            for (int node : cycle) {
                sizes.put(node, getSubtreeSize(node));
            }
            return sizes;
        }
        
        // 打印基环树结构
        public void printStructure() {
            System.out.println("Base Cycle Tree Structure:");
            System.out.println("Cycle: " + cycle);
            System.out.println("Cycle Length: " + getCycleLength());
            
            System.out.println("Subtree Sizes:");
            Map<Integer, Integer> sizes = getAllSubtreeSizes();
            for (Map.Entry<Integer, Integer> entry : sizes.entrySet()) {
                System.out.println("  Node " + entry.getKey() + ": " + entry.getValue());
            }
            
            System.out.println("Children Relationships:");
            for (int i = 0; i < n; i++) {
                if (!children.get(i).isEmpty()) {
                    System.out.println("  Node " + i + " -> " + children.get(i));
                }
            }
        }
    }
    
    // 测试方法
    public static void main(String[] args) {
        // 测试用例1：简单的基环树
        System.out.println("测试用例1: 简单基环树");
        // 节点: 0 1 2 3 4
        // 父节点: 1 2 0 4 1
        // 结构: 0->1->2->0 (环), 4->1, 3->4
        int[] parent1 = {1, 2, 0, 4, 1};
        BaseCycleTree bct1 = new BaseCycleTree(5, parent1);
        bct1.printStructure();
        System.out.println();
        
        // 测试用例2：单个环
        System.out.println("测试用例2: 单个环");
        // 节点: 0 1 2
        // 父节点: 1 2 0
        // 结构: 0->1->2->0 (环)
        int[] parent2 = {1, 2, 0};
        BaseCycleTree bct2 = new BaseCycleTree(3, parent2);
        bct2.printStructure();
        System.out.println();
        
        // 测试用例3：复杂基环树
        System.out.println("测试用例3: 复杂基环树");
        // 节点: 0 1 2 3 4 5 6
        // 父节点: 1 2 0 5 3 2 4
        // 结构: 0->1->2->0 (环), 3->5->2, 4->3, 6->4
        int[] parent3 = {1, 2, 0, 5, 3, 2, 4};
        BaseCycleTree bct3 = new BaseCycleTree(7, parent3);
        bct3.printStructure();
        System.out.println();
        
        // 测试用例4：多个独立的环
        System.out.println("测试用例4: 多个独立结构");
        // 节点: 0 1 2 3 4
        // 父节点: 1 0 3 2 1
        // 结构: 0->1->0 (环), 2->3->2 (环), 4->1
        int[] parent4 = {1, 0, 3, 2, 1};
        BaseCycleTree bct4 = new BaseCycleTree(5, parent4);
        bct4.printStructure();
    }
}

===============================================

文件: base_cycle_tree_implementation.cpp
===============================================
// 基环树 (Base Cycle Tree) C++ 实现

/**
 * 基环树 (Base Cycle Tree) 实现
 * 
 * 基环树是一种特殊的图结构，它由一个环和若干棵以环上节点为根的树组成。
 * 每个节点恰好有一条入边，因此整个图由一个或多个环组成，每个环上可能挂着一些树。
 * 
 * 应用场景：
 * 1. 数据结构：函数式数据结构、持久化数据结构
 * 2. 图论算法：环检测、强连通分量
 * 3. 数学：置换群、循环结构
 * 
 * 算法思路：
 * 1. 检测图中的环
 * 2. 对环上的每个节点，构建以其为根的子树
 * 3. 分析环的性质和子树的性质
 * 
 * 时间复杂度：O(V + E)
 * 空间复杂度：O(V)
 */

// 由于编译环境限制，这里提供算法思路和伪代码实现

/*
// 基环树类定义
struct BaseCycleTree {
    int n; // 节点数
    int* parent; // 每个节点的父节点
    bool* visited; // 访问标记
    int** children; // 每个节点的子节点
    int* cycle; // 环上的节点
    bool* inCycle; // 标记节点是否在环上
    int cycleSize; // 环的大小
    
    // 构造函数
    BaseCycleTree(int n, int* parent);
    
    // 析构函数
    ~BaseCycleTree();
    
    // 检测环
    void findCycle();
    
    // DFS检测环
    bool dfs(int node, int* path, int* pathSize);
    
    // 找到环的路径
    bool findCyclePath(int node, int* path, int* pathSize);
    
    // 获取环上的节点
    int* getCycle(int* size);
    
    // 检查节点是否在环上
    bool isInCycle(int node);
    
    // 获取以指定节点为根的子树大小
    int getSubtreeSize(int root);
    
    int getSubtreeSizeHelper(int node);
    
    // 获取环的长度
    int getCycleLength();
    
    // 获取所有子树的大小
    void getAllSubtreeSizes(int** nodes, int** sizes, int* count);
    
    // 打印基环树结构
    void printStructure();
};

// 构造函数
BaseCycleTree::BaseCycleTree(int n, int* parent) : n(n) {
    this->parent = (int*)malloc(n * sizeof(int));
    this->visited = (bool*)calloc(n, sizeof(bool));
    this->children = (int**)calloc(n, sizeof(int*));
    this->inCycle = (bool*)calloc(n, sizeof(bool));
    this->cycle = (int*)malloc(n * sizeof(int));
    this->cycleSize = 0;
    
    // 复制父节点数组
    for (int i = 0; i < n; i++) {
        this->parent[i] = parent[i];
        this->children[i] = (int*)calloc(n, sizeof(int)); // 简化实现
    }
    
    // 构建子节点关系
    for (int i = 0; i < n; i++) {
        if (parent[i] != -1) {
            // 在实际实现中需要维护每个节点的子节点列表
        }
    }
    
    // 检测环
    findCycle();
}

// 析构函数
BaseCycleTree::~BaseCycleTree() {
    free(parent);
    free(visited);
    for (int i = 0; i < n; i++) {
        free(children[i]);
    }
    free(children);
    free(inCycle);
    free(cycle);
}

// 检测环
void BaseCycleTree::findCycle() {
    // 实现细节省略
    // 使用DFS遍历图来检测环
}

// 算法核心思想：
// 1. 使用DFS遍历图来检测环结构
// 2. 对于环上的每个节点，计算以其为根的子树大小
// 3. 分析环的性质和子树的性质

// 时间复杂度分析：
// - DFS遍历：O(V + E)
// - 计算子树大小：O(V)
// - 总体时间复杂度：O(V + E)
// - 空间复杂度：O(V)
*/

// 算法应用场景：
// 1. 函数式编程中的循环数据结构处理
// 2. 图论中的环检测和分析
// 3. 数据库中的循环引用检测
// 4. 编译器中的变量作用域分析

===============================================

文件: base_cycle_tree_implementation.py
===============================================
#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
基环树 (Base Cycle Tree) Python 实现

基环树是一种特殊的图结构，它由一个环和若干棵以环上节点为根的树组成。
每个节点恰好有一条入边，因此整个图由一个或多个环组成，每个环上可能挂着一些树。

应用场景：
1. 数据结构：函数式数据结构、持久化数据结构
2. 图论算法：环检测、强连通分量
3. 数学：置换群、循环结构

算法思路：
1. 检测图中的环
2. 对环上的每个节点，构建以其为根的子树
3. 分析环的性质和子树的性质

时间复杂度：O(V + E)
空间复杂度：O(V)
"""

class BaseCycleTree:
    def __init__(self, n, parent):
        """
        初始化基环树
        
        Args:
            n: 节点数
            parent: 每个节点的父节点数组
        """
        self.n = n
        self.parent = parent[:]
        self.visited = [False] * n
        self.children = [[] for _ in range(n)]
        self.cycle = []
        self.inCycle = [False] * n
        
        # 构建子节点关系
        for i in range(n):
            if parent[i] != -1:
                self.children[parent[i]].append(i)
        
        # 检测环
        self.findCycle()
    
    def findCycle(self):
        """检测环"""
        self.cycle = []
        self.visited = [False] * self.n
        self.inCycle = [False] * self.n
        
        # 找到环的起始节点
        start = -1
        for i in range(self.n):
            if not self.visited[i]:
                path = []
                if self.dfs(i, path):
                    start = i
                    break
        
        if start == -1:
            return  # 没有环
        
        # 重新遍历以找到完整的环
        self.visited = [False] * self.n
        path = []
        self.findCyclePath(start, path)
        
        # 标记环上的节点
        self.cycle = path
        for node in self.cycle:
            self.inCycle[node] = True
    
    def dfs(self, node, path):
        """
        DFS检测环
        
        Args:
            node: 当前节点
            path: 当前路径
            
        Returns:
            是否找到环
        """
        if self.visited[node]:
            # 找到环的起点
            path.append(node)
            return True
        
        self.visited[node] = True
        path.append(node)
        
        if self.parent[node] != -1 and self.dfs(self.parent[node], path):
            return True
        
        path.pop()
        return False
    
    def findCyclePath(self, node, path):
        """
        找到环的路径
        
        Args:
            node: 当前节点
            path: 当前路径
            
        Returns:
            是否找到环
        """
        if self.visited[node]:
            # 找到环的起点，截取环的部分
            try:
                start_index = path.index(node)
                cycle_path = path[start_index:]
                path[:] = cycle_path
                return True
            except ValueError:
                return False
        
        self.visited[node] = True
        path.append(node)
        
        if self.parent[node] != -1 and self.findCyclePath(self.parent[node], path):
            return True
        
        path.pop()
        return False
    
    def get_cycle(self):
        """
        获取环上的节点
        
        Returns:
            环上的节点列表
        """
        return self.cycle[:]
    
    def is_in_cycle(self, node):
        """
        检查节点是否在环上
        
        Args:
            node: 节点
            
        Returns:
            节点是否在环上
        """
        return self.inCycle[node]
    
    def get_subtree_size(self, root):
        """
        获取以指定节点为根的子树大小
        
        Args:
            root: 根节点
            
        Returns:
            子树大小
        """
        return self._get_subtree_size_helper(root)
    
    def _get_subtree_size_helper(self, node):
        """
        递归计算子树大小
        
        Args:
            node: 当前节点
            
        Returns:
            以当前节点为根的子树大小
        """
        size = 1  # 包括节点本身
        for child in self.children[node]:
            if not self.inCycle[child]:  # 只计算不在环上的子节点
                size += self._get_subtree_size_helper(child)
        return size
    
    def get_cycle_length(self):
        """
        获取环的长度
        
        Returns:
            环的长度
        """
        return len(self.cycle)
    
    def get_all_subtree_sizes(self):
        """
        获取所有子树的大小
        
        Returns:
            包含节点和子树大小的字典
        """
        sizes = {}
        for node in self.cycle:
            sizes[node] = self.get_subtree_size(node)
        return sizes
    
    def print_structure(self):
        """打印基环树结构"""
        print("Base Cycle Tree Structure:")
        print("Cycle:", self.cycle)
        print("Cycle Length:", self.get_cycle_length())
        
        print("Subtree Sizes:")
        sizes = self.get_all_subtree_sizes()
        for node, size in sizes.items():
            print(f"  Node {node}: {size}")
        
        print("Children Relationships:")
        for i in range(self.n):
            if self.children[i]:
                print(f"  Node {i} -> {self.children[i]}")


# 测试方法
def main():
    # 测试用例1：简单的基环树
    print("测试用例1: 简单基环树")
    # 节点: 0 1 2 3 4
    # 父节点: 1 2 0 4 1
    # 结构: 0->1->2->0 (环), 4->1, 3->4
    parent1 = [1, 2, 0, 4, 1]
    bct1 = BaseCycleTree(5, parent1)
    bct1.print_structure()
    print()
    
    # 测试用例2：单个环
    print("测试用例2: 单个环")
    # 节点: 0 1 2
    # 父节点: 1 2 0
    # 结构: 0->1->2->0 (环)
    parent2 = [1, 2, 0]
    bct2 = BaseCycleTree(3, parent2)
    bct2.print_structure()
    print()
    
    # 测试用例3：复杂基环树
    print("测试用例3: 复杂基环树")
    # 节点: 0 1 2 3 4 5 6
    # 父节点: 1 2 0 5 3 2 4
    # 结构: 0->1->2->0 (环), 3->5->2, 4->3, 6->4
    parent3 = [1, 2, 0, 5, 3, 2, 4]
    bct3 = BaseCycleTree(7, parent3)
    bct3.print_structure()
    print()


if __name__ == "__main__":
    main()

===============================================

文件: CircleSquareTreeImplementation.java
===============================================
package class008_AdvancedAlgorithmsAndDataStructures.circle_square_tree_problems;

import java.util.*;

/**
 * 圆方树 (Circle Square Tree) 实现
 * 
 * 圆方树是一种将无向图转化为树结构的方法，主要用于处理仙人掌图（每条边最多属于一个环的图）。
 * 在圆方树中：
 * - 圆点：原图中的节点
 * - 方点：原图中的环
 * 
 * 应用场景：
 * 1. 仙人掌图算法：最短路径、环相关问题
 * 2. 图论问题：点双连通分量、割点
 * 3. 竞赛算法：处理特殊图结构
 * 
 * 算法思路：
 * 1. 使用DFS找出图中的点双连通分量
 * 2. 对于每个点双连通分量：
 *    - 如果是单个边，创建圆点-圆点的连接
 *    - 如果包含多个节点（形成环），创建一个方点代表这个环
 * 3. 将圆点和方点连接形成树结构
 * 
 * 时间复杂度：O(V + E)
 * 空间复杂度：O(V + E)
 */
public class CircleSquareTreeImplementation {
    
    static class CircleSquareTree {
        private int n; // 原图节点数
        private List<List<Integer>> graph; // 原图的邻接表
        private List<List<Integer>> tree; // 圆方树的邻接表
        private int treeNodeCount; // 圆方树节点数（包括圆点和方点）
        private boolean[] visited; // DFS访问标记
        private int[] dfn; // DFS时间戳
        private int[] low; // 最小时间戳
        private Stack<Integer> stack; // DFS栈
        private int dfsTime; // DFS时间
        private Map<Integer, List<Integer>> biconnectedComponents; // 点双连通分量
        private int bccCount; // 点双连通分量数量
        
        public CircleSquareTree(int n) {
            this.n = n;
            this.graph = new ArrayList<>();
            for (int i = 0; i < n; i++) {
                graph.add(new ArrayList<>());
            }
            
            this.visited = new boolean[n];
            this.dfn = new int[n];
            this.low = new int[n];
            this.stack = new Stack<>();
            this.dfsTime = 0;
            this.biconnectedComponents = new HashMap<>();
            this.bccCount = 0;
        }
        
        // 添加边
        public void addEdge(int u, int v) {
            graph.get(u).add(v);
            graph.get(v).add(u);
        }
        
        // 构建圆方树
        public void buildCircleSquareTree() {
            // 初始化
            Arrays.fill(visited, false);
            Arrays.fill(dfn, -1);
            Arrays.fill(low, -1);
            stack.clear();
            biconnectedComponents.clear();
            bccCount = 0;
            dfsTime = 0;
            
            // 找出所有点双连通分量
            for (int i = 0; i < n; i++) {
                if (dfn[i] == -1) {
                    tarjan(i, -1);
                }
            }
            
            // 构建圆方树
            buildTree();
        }
        
        // Tarjan算法找点双连通分量
        private void tarjan(int u, int parent) {
            dfn[u] = low[u] = ++dfsTime;
            visited[u] = true;
            stack.push(u);
            int children = 0;
            
            for (int v : graph.get(u)) {
                if (v == parent) continue;
                
                if (dfn[v] == -1) {
                    children++;
                    tarjan(v, u);
                    low[u] = Math.min(low[u], low[v]);
                    
                    // 发现点双连通分量
                    if (low[v] >= dfn[u]) {
                        List<Integer> bcc = new ArrayList<>();
                        int node;
                        do {
                            node = stack.pop();
                            bcc.add(node);
                        } while (node != v);
                        bcc.add(u); // 添加根节点
                        
                        biconnectedComponents.put(bccCount++, bcc);
                    }
                } else {
                    low[u] = Math.min(low[u], dfn[v]);
                }
            }
            
            // 根节点特殊情况
            if (parent == -1 && children == 0) {
                List<Integer> bcc = new ArrayList<>();
                bcc.add(u);
                biconnectedComponents.put(bccCount++, bcc);
            }
        }
        
        // 构建圆方树
        private void buildTree() {
            // 圆方树节点数 = 原图节点数 + 点双连通分量数
            treeNodeCount = n + bccCount;
            tree = new ArrayList<>();
            for (int i = 0; i < treeNodeCount; i++) {
                tree.add(new ArrayList<>());
            }
            
            // 为每个点双连通分量创建方点，并连接圆点
            for (int i = 0; i < bccCount; i++) {
                int squareNode = n + i; // 方点编号从n开始
                List<Integer> bcc = biconnectedComponents.get(i);
                
                // 连接方点和该分量中的所有圆点
                for (int circleNode : bcc) {
                    tree.get(squareNode).add(circleNode);
                    tree.get(circleNode).add(squareNode);
                }
            }
        }
        
        // 获取圆方树
        public List<List<Integer>> getCircleSquareTree() {
            return tree;
        }
        
        // 获取圆方树节点数
        public int getTreeNodeCount() {
            return treeNodeCount;
        }
        
        // 获取点双连通分量
        public Map<Integer, List<Integer>> getBiconnectedComponents() {
            return new HashMap<>(biconnectedComponents);
        }
        
        // 计算两点间在圆方树上的距离
        public int distance(int u, int v) {
            if (u == v) return 0;
            
            // BFS计算最短距离
            boolean[] visited = new boolean[treeNodeCount];
            Queue<Integer> queue = new LinkedList<>();
            Map<Integer, Integer> distances = new HashMap<>();
            
            queue.offer(u);
            visited[u] = true;
            distances.put(u, 0);
            
            while (!queue.isEmpty()) {
                int node = queue.poll();
                int dist = distances.get(node);
                
                for (int neighbor : tree.get(node)) {
                    if (!visited[neighbor]) {
                        if (neighbor == v) {
                            return dist + 1;
                        }
                        visited[neighbor] = true;
                        distances.put(neighbor, dist + 1);
                        queue.offer(neighbor);
                    }
                }
            }
            
            return -1; // 不连通
        }
        
        // 打印圆方树结构
        public void printStructure() {
            System.out.println("Circle-Square Tree Structure:");
            System.out.println("Original nodes: " + n);
            System.out.println("Biconnected components: " + bccCount);
            System.out.println("Tree nodes: " + treeNodeCount);
            
            System.out.println("Biconnected Components:");
            for (Map.Entry<Integer, List<Integer>> entry : biconnectedComponents.entrySet()) {
                System.out.println("  BCC " + entry.getKey() + ": " + entry.getValue());
            }
            
            System.out.println("Tree Edges:");
            for (int i = 0; i < treeNodeCount; i++) {
                if (!tree.get(i).isEmpty()) {
                    System.out.println("  Node " + i + " -> " + tree.get(i));
                }
            }
        }
    }
    
    // 测试方法
    public static void main(String[] args) {
        // 测试用例1：简单的仙人掌图
        System.out.println("测试用例1: 简单仙人掌图");
        CircleSquareTree cst1 = new CircleSquareTree(5);
        
        // 构建图结构:
        // 0-1-2 (链)
        // 1-3-4 (链)
        // 1-2-3 (环)
        cst1.addEdge(0, 1);
        cst1.addEdge(1, 2);
        cst1.addEdge(1, 3);
        cst1.addEdge(2, 3);
        cst1.addEdge(3, 4);
        
        cst1.buildCircleSquareTree();
        cst1.printStructure();
        
        System.out.println("节点0和节点4在圆方树上的距离: " + cst1.distance(0, 4));
        System.out.println();
        
        // 测试用例2：树结构
        System.out.println("测试用例2: 树结构");
        CircleSquareTree cst2 = new CircleSquareTree(5);
        
        // 构建树结构:
        // 0-1-2
        // |   |
        // 3   4
        cst2.addEdge(0, 1);
        cst2.addEdge(0, 3);
        cst2.addEdge(1, 2);
        cst2.addEdge(2, 4);
        
        cst2.buildCircleSquareTree();
        cst2.printStructure();
        
        System.out.println("节点3和节点4在圆方树上的距离: " + cst2.distance(3, 4));
        System.out.println();
        
        // 测试用例3：复杂仙人掌图
        System.out.println("测试用例3: 复杂仙人掌图");
        CircleSquareTree cst3 = new CircleSquareTree(6);
        
        // 构建图结构:
        // 0-1-2 (链)
        // 0-2 (形成环)
        // 2-3-4 (链)
        // 2-4 (形成环)
        // 4-5 (链)
        cst3.addEdge(0, 1);
        cst3.addEdge(1, 2);
        cst3.addEdge(0, 2);
        cst3.addEdge(2, 3);
        cst3.addEdge(3, 4);
        cst3.addEdge(2, 4);
        cst3.addEdge(4, 5);
        
        cst3.buildCircleSquareTree();
        cst3.printStructure();
        
        System.out.println("节点0和节点5在圆方树上的距离: " + cst3.distance(0, 5));
    }
}

===============================================

文件: circle_square_tree_implementation.cpp
===============================================
// 圆方树 (Circle Square Tree) C++ 实现

/**
 * 圆方树 (Circle Square Tree) 实现
 * 
 * 圆方树是一种将无向图转化为树结构的方法，主要用于处理仙人掌图（每条边最多属于一个环的图）。
 * 在圆方树中：
 * - 圆点：原图中的节点
 * - 方点：原图中的环
 * 
 * 应用场景：
 * 1. 仙人掌图算法：最短路径、环相关问题
 * 2. 图论问题：点双连通分量、割点
 * 3. 竞赛算法：处理特殊图结构
 * 
 * 算法思路：
 * 1. 使用DFS找出图中的点双连通分量
 * 2. 对于每个点双连通分量：
 *    - 如果是单个边，创建圆点-圆点的连接
 *    - 如果包含多个节点（形成环），创建一个方点代表这个环
 * 3. 将圆点和方点连接形成树结构
 * 
 * 时间复杂度：O(V + E)
 * 空间复杂度：O(V + E)
 */

// 由于编译环境限制，这里提供算法思路和伪代码实现

/*
// 圆方树类定义
struct CircleSquareTree {
    int n; // 原图节点数
    int** graph; // 原图的邻接表
    int** tree; // 圆方树的邻接表
    int treeNodeCount; // 圆方树节点数（包括圆点和方点）
    bool* visited; // DFS访问标记
    int* dfn; // DFS时间戳
    int* low; // 最小时间戳
    int* stack; // DFS栈
    int stackTop; // 栈顶指针
    int dfsTime; // DFS时间
    int** biconnectedComponents; // 点双连通分量
    int* bccSizes; // 每个点双连通分量的大小
    int bccCount; // 点双连通分量数量
    
    // 构造函数
    CircleSquareTree(int n);
    
    // 析构函数
    ~CircleSquareTree();
    
    // 添加边
    void addEdge(int u, int v);
    
    // 构建圆方树
    void buildCircleSquareTree();
    
    // Tarjan算法找点双连通分量
    void tarjan(int u, int parent);
    
    // 构建圆方树
    void buildTree();
    
    // 获取圆方树
    int** getCircleSquareTree(int* nodeCount);
    
    // 获取点双连通分量
    int** getBiconnectedComponents(int* count, int** sizes);
    
    // 计算两点间在圆方树上的距离
    int distance(int u, int v);
    
    // 打印圆方树结构
    void printStructure();
};

// 构造函数
CircleSquareTree::CircleSquareTree(int n) : n(n) {
    // 初始化数据结构
    this->graph = (int**)calloc(n, sizeof(int*));
    this->visited = (bool*)calloc(n, sizeof(bool));
    this->dfn = (int*)malloc(n * sizeof(int));
    this->low = (int*)malloc(n * sizeof(int));
    this->stack = (int*)malloc(n * sizeof(int));
    this->stackTop = 0;
    this->dfsTime = 0;
    this->biconnectedComponents = NULL;
    this->bccSizes = NULL;
    this->bccCount = 0;
    
    // 初始化数组
    for (int i = 0; i < n; i++) {
        this->dfn[i] = -1;
        this->low[i] = -1;
    }
}

// 析构函数
CircleSquareTree::~CircleSquareTree() {
    // 释放内存
    for (int i = 0; i < n; i++) {
        free(graph[i]);
    }
    free(graph);
    free(visited);
    free(dfn);
    free(low);
    free(stack);
    // 释放其他数据结构
}

// 添加边
void CircleSquareTree::addEdge(int u, int v) {
    // 在实际实现中需要动态维护邻接表
}

// 构建圆方树
void CircleSquareTree::buildCircleSquareTree() {
    // 初始化
    for (int i = 0; i < n; i++) {
        visited[i] = false;
        dfn[i] = -1;
        low[i] = -1;
    }
    stackTop = 0;
    dfsTime = 0;
    bccCount = 0;
    
    // 找出所有点双连通分量
    for (int i = 0; i < n; i++) {
        if (dfn[i] == -1) {
            tarjan(i, -1);
        }
    }
    
    // 构建圆方树
    buildTree();
}

// Tarjan算法找点双连通分量
void CircleSquareTree::tarjan(int u, int parent) {
    dfn[u] = low[u] = ++dfsTime;
    visited[u] = true;
    stack[stackTop++] = u;
    int children = 0;
    
    // 遍历u的所有邻居
    for (int i = 0; graph[u] && graph[u][i] != -1; i++) {
        int v = graph[u][i];
        if (v == parent) continue;
        
        if (dfn[v] == -1) {
            children++;
            tarjan(v, u);
            low[u] = (low[u] < low[v]) ? low[u] : low[v];
            
            // 发现点双连通分量
            if (low[v] >= dfn[u]) {
                // 创建新的点双连通分量
                // 实现细节省略
            }
        } else {
            low[u] = (low[u] < dfn[v]) ? low[u] : dfn[v];
        }
    }
    
    // 根节点特殊情况
    if (parent == -1 && children == 0) {
        // 处理孤立节点
    }
}

// 算法核心思想：
// 1. 使用Tarjan算法找出图中的点双连通分量
// 2. 对于每个点双连通分量，创建一个方点
// 3. 将方点与该分量中的所有圆点连接
// 4. 形成圆方树结构

// 时间复杂度分析：
// - Tarjan算法：O(V + E)
// - 构建圆方树：O(V + E)
// - 总体时间复杂度：O(V + E)
// - 空间复杂度：O(V + E)
*/

// 算法应用场景：
// 1. 仙人掌图上的最短路径问题
// 2. 图的环结构分析
// 3. 竞赛算法中的特殊图处理
// 4. 网络流问题中的预处理

===============================================

文件: circle_square_tree_implementation.py
===============================================
#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
圆方树 (Circle Square Tree) Python 实现

圆方树是一种将无向图转化为树结构的方法，主要用于处理仙人掌图（每条边最多属于一个环的图）。
在圆方树中：
- 圆点：原图中的节点
- 方点：原图中的环

应用场景：
1. 仙人掌图算法：最短路径、环相关问题
2. 图论问题：点双连通分量、割点
3. 竞赛算法：处理特殊图结构

算法思路：
1. 使用DFS找出图中的点双连通分量
2. 对于每个点双连通分量：
   - 如果是单个边，创建圆点-圆点的连接
   - 如果包含多个节点（形成环），创建一个方点代表这个环
3. 将圆点和方点连接形成树结构

时间复杂度：O(V + E)
空间复杂度：O(V + E)
"""

class CircleSquareTree:
    def __init__(self, n):
        """
        初始化圆方树
        
        Args:
            n: 原图节点数
        """
        self.n = n
        self.graph = [[] for _ in range(n)]  # 原图的邻接表
        self.tree = []  # 圆方树的邻接表
        self.tree_node_count = 0  # 圆方树节点数（包括圆点和方点）
        self.visited = [False] * n  # DFS访问标记
        self.dfn = [-1] * n  # DFS时间戳
        self.low = [-1] * n  # 最小时间戳
        self.stack = []  # DFS栈
        self.dfs_time = 0  # DFS时间
        self.biconnected_components = {}  # 点双连通分量
        self.bcc_count = 0  # 点双连通分量数量
    
    def add_edge(self, u, v):
        """
        添加边
        
        Args:
            u: 节点u
            v: 节点v
        """
        self.graph[u].append(v)
        self.graph[v].append(u)
    
    def build_circle_square_tree(self):
        """构建圆方树"""
        # 初始化
        self.visited = [False] * self.n
        self.dfn = [-1] * self.n
        self.low = [-1] * self.n
        self.stack = []
        self.biconnected_components = {}
        self.bcc_count = 0
        self.dfs_time = 0
        
        # 找出所有点双连通分量
        for i in range(self.n):
            if self.dfn[i] == -1:
                self.tarjan(i, -1)
        
        # 构建圆方树
        self.build_tree()
    
    def tarjan(self, u, parent):
        """
        Tarjan算法找点双连通分量
        
        Args:
            u: 当前节点
            parent: 父节点
        """
        self.dfn[u] = self.low[u] = self.dfs_time
        self.dfs_time += 1
        self.visited[u] = True
        self.stack.append(u)
        children = 0
        
        for v in self.graph[u]:
            if v == parent:
                continue
            
            if self.dfn[v] == -1:
                children += 1
                self.tarjan(v, u)
                self.low[u] = min(self.low[u], self.low[v])
                
                # 发现点双连通分量
                if self.low[v] >= self.dfn[u]:
                    bcc = []
                    node = None
                    while node != v:
                        node = self.stack.pop()
                        bcc.append(node)
                    bcc.append(u)  # 添加根节点
                    
                    self.biconnected_components[self.bcc_count] = bcc
                    self.bcc_count += 1
            else:
                self.low[u] = min(self.low[u], self.dfn[v])
        
        # 根节点特殊情况
        if parent == -1 and children == 0:
            bcc = [u]
            self.biconnected_components[self.bcc_count] = bcc
            self.bcc_count += 1
    
    def build_tree(self):
        """构建圆方树"""
        # 圆方树节点数 = 原图节点数 + 点双连通分量数
        self.tree_node_count = self.n + self.bcc_count
        self.tree = [[] for _ in range(self.tree_node_count)]
        
        # 为每个点双连通分量创建方点，并连接圆点
        for i in range(self.bcc_count):
            square_node = self.n + i  # 方点编号从n开始
            bcc = self.biconnected_components[i]
            
            # 连接方点和该分量中的所有圆点
            for circle_node in bcc:
                self.tree[square_node].append(circle_node)
                self.tree[circle_node].append(square_node)
    
    def get_circle_square_tree(self):
        """
        获取圆方树
        
        Returns:
            圆方树的邻接表
        """
        return [neighbors[:] for neighbors in self.tree]
    
    def get_tree_node_count(self):
        """
        获取圆方树节点数
        
        Returns:
            圆方树节点数
        """
        return self.tree_node_count
    
    def get_biconnected_components(self):
        """
        获取点双连通分量
        
        Returns:
            点双连通分量字典
        """
        return self.biconnected_components.copy()
    
    def distance(self, u, v):
        """
        计算两点间在圆方树上的距离
        
        Args:
            u: 起点
            v: 终点
            
        Returns:
            两点间距离
        """
        if u == v:
            return 0
        
        # BFS计算最短距离
        visited = [False] * self.tree_node_count
        queue = [(u, 0)]
        visited[u] = True
        
        while queue:
            node, dist = queue.pop(0)
            
            for neighbor in self.tree[node]:
                if not visited[neighbor]:
                    if neighbor == v:
                        return dist + 1
                    visited[neighbor] = True
                    queue.append((neighbor, dist + 1))
        
        return -1  # 不连通
    
    def print_structure(self):
        """打印圆方树结构"""
        print("Circle-Square Tree Structure:")
        print("Original nodes:", self.n)
        print("Biconnected components:", self.bcc_count)
        print("Tree nodes:", self.tree_node_count)
        
        print("Biconnected Components:")
        for i, bcc in self.biconnected_components.items():
            print(f"  BCC {i}: {bcc}")
        
        print("Tree Edges:")
        for i in range(self.tree_node_count):
            if self.tree[i]:
                print(f"  Node {i} -> {self.tree[i]}")


# 测试方法
def main():
    # 测试用例1：简单的仙人掌图
    print("测试用例1: 简单仙人掌图")
    cst1 = CircleSquareTree(5)
    
    # 构建图结构:
    # 0-1-2 (链)
    # 1-3-4 (链)
    # 1-2-3 (环)
    cst1.add_edge(0, 1)
    cst1.add_edge(1, 2)
    cst1.add_edge(1, 3)
    cst1.add_edge(2, 3)
    cst1.add_edge(3, 4)
    
    cst1.build_circle_square_tree()
    cst1.print_structure()
    
    print("节点0和节点4在圆方树上的距离:", cst1.distance(0, 4))
    print()
    
    # 测试用例2：树结构
    print("测试用例2: 树结构")
    cst2 = CircleSquareTree(5)
    
    # 构建树结构:
    # 0-1-2
    # |   |
    # 3   4
    cst2.add_edge(0, 1)
    cst2.add_edge(0, 3)
    cst2.add_edge(1, 2)
    cst2.add_edge(2, 4)
    
    cst2.build_circle_square_tree()
    cst2.print_structure()
    
    print("节点3和节点4在圆方树上的距离:", cst2.distance(3, 4))
    print()
    
    # 测试用例3：复杂仙人掌图
    print("测试用例3: 复杂仙人掌图")
    cst3 = CircleSquareTree(6)
    
    # 构建图结构:
    # 0-1-2 (链)
    # 0-2 (形成环)
    # 2-3-4 (链)
    # 2-4 (形成环)
    # 4-5 (链)
    cst3.add_edge(0, 1)
    cst3.add_edge(1, 2)
    cst3.add_edge(0, 2)
    cst3.add_edge(2, 3)
    cst3.add_edge(3, 4)
    cst3.add_edge(2, 4)
    cst3.add_edge(4, 5)
    
    cst3.build_circle_square_tree()
    cst3.print_structure()
    
    print("节点0和节点5在圆方树上的距离:", cst3.distance(0, 5))


if __name__ == "__main__":
    main()

===============================================

文件: ClosestPair.java
===============================================
package class185;

import java.util.*;

/**
 * 平面分治算法 - 最近点对问题实现 (Java版本)
 * 
 * 问题描述：
 * 给定平面上的n个点，找出距离最近的两个点。
 * 
 * 算法思路：
 * 使用分治法解决最近点对问题：
 * 1. 将点集按照x坐标排序
 * 2. 递归地在左半部分和右半部分找最近点对
 * 3. 找到跨越中线的最近点对
 * 4. 返回三者中的最小值
 * 
 * 时间复杂度：O(n log n)
 * 空间复杂度：O(n)
 * 
 * 应用场景：
 * 1. 计算几何中的碰撞检测
 * 2. 机器学习中的最近邻搜索
 * 3. 地理信息系统中的最近设施查询
 */
public class ClosestPair {
    
    /**
     * 点类，用于存储二维坐标
     */
    static class Point {
        double x, y;
        
        Point(double x, double y) {
            this.x = x;
            this.y = y;
        }
        
        /**
         * 计算两个点之间的欧几里得距离
         */
        public double distanceTo(Point p) {
            double dx = this.x - p.x;
            double dy = this.y - p.y;
            return Math.sqrt(dx * dx + dy * dy);
        }
        
        @Override
        public String toString() {
            return "(" + x + ", " + y + ")";
        }
    }
    
    /**
     * 最近点对结果类
     */
    static class ClosestPairResult {
        Point p1, p2;
        double distance;
        
        ClosestPairResult(Point p1, Point p2, double distance) {
            this.p1 = p1;
            this.p2 = p2;
            this.distance = distance;
        }
    }
    
    /**
     * 查找最近点对
     * @param points 点集
     * @return 最近点对结果
     */
    public static ClosestPairResult findClosestPair(Point[] points) {
        if (points == null || points.length < 2) {
            throw new IllegalArgumentException("点集必须包含至少两个点");
        }
        
        // 按照x坐标排序
        Point[] pointsSortedByX = points.clone();
        Arrays.sort(pointsSortedByX, Comparator.comparingDouble(p -> p.x));
        
        // 按照y坐标排序（用于后续处理）
        Point[] pointsSortedByY = pointsSortedByX.clone();
        Arrays.sort(pointsSortedByY, Comparator.comparingDouble(p -> p.y));
        
        // 调用递归函数
        return closestPairRecursive(pointsSortedByX, 0, pointsSortedByX.length - 1, pointsSortedByY);
    }
    
    /**
     * 递归求解最近点对
     * @param pointsSortedByX 按x坐标排序的点集
     * @param left 左边界
     * @param right 右边界
     * @param pointsSortedByY 按y坐标排序的点集
     * @return 最近点对结果
     */
    private static ClosestPairResult closestPairRecursive(Point[] pointsSortedByX, int left, int right, 
                                                         Point[] pointsSortedByY) {
        // 基本情况：小规模问题直接暴力求解
        if (right - left <= 3) {
            return bruteForce(pointsSortedByX, left, right);
        }
        
        // 分治求解
        int mid = left + (right - left) / 2;
        Point midPoint = pointsSortedByX[mid];
        
        // 分割y排序的数组
        Point[] leftPointsSortedByY = new Point[mid - left + 1];
        Point[] rightPointsSortedByY = new Point[right - mid];
        
        int leftIdx = 0, rightIdx = 0;
        for (Point p : pointsSortedByY) {
            if (p.x <= midPoint.x && leftIdx < leftPointsSortedByY.length) {
                leftPointsSortedByY[leftIdx++] = p;
            } else if (rightIdx < rightPointsSortedByY.length) {
                rightPointsSortedByY[rightIdx++] = p;
            }
        }
        
        // 递归求解左右子数组
        ClosestPairResult leftResult = closestPairRecursive(pointsSortedByX, left, mid, leftPointsSortedByY);
        ClosestPairResult rightResult = closestPairRecursive(pointsSortedByX, mid + 1, right, rightPointsSortedByY);
        
        // 确定左右子数组中的最小距离
        ClosestPairResult minResult = leftResult.distance < rightResult.distance ? leftResult : rightResult;
        
        // 处理跨越中线的点对
        // 筛选出在中线附近的点
        List<Point> strip = new ArrayList<>();
        for (Point p : pointsSortedByY) {
            if (Math.abs(p.x - midPoint.x) < minResult.distance) {
                strip.add(p);
            }
        }
        
        // 检查strip中的点对
        ClosestPairResult stripResult = checkStrip(strip, minResult.distance);
        
        // 返回最小距离的点对
        if (stripResult.distance < minResult.distance) {
            return stripResult;
        } else {
            return minResult;
        }
    }
    
    /**
     * 暴力求解小规模问题
     * @param points 点集
     * @param left 左边界
     * @param right 右边界
     * @return 最近点对结果
     */
    private static ClosestPairResult bruteForce(Point[] points, int left, int right) {
        double minDist = Double.MAX_VALUE;
        Point p1 = null, p2 = null;
        
        for (int i = left; i <= right; i++) {
            for (int j = i + 1; j <= right; j++) {
                double dist = points[i].distanceTo(points[j]);
                if (dist < minDist) {
                    minDist = dist;
                    p1 = points[i];
                    p2 = points[j];
                }
            }
        }
        
        return new ClosestPairResult(p1, p2, minDist);
    }
    
    /**
     * 检查跨越中线的点对
     * @param strip 中线附近的点集
     * @param minDist 当前最小距离
     * @return 最近点对结果
     */
    private static ClosestPairResult checkStrip(List<Point> strip, double minDist) {
        double currentMin = minDist;
        Point p1 = null, p2 = null;
        
        // 按照y坐标排序（已经是排序好的）
        // 只需要检查相邻的最多7个点
        for (int i = 0; i < strip.size(); i++) {
            for (int j = i + 1; j < strip.size() && (strip.get(j).y - strip.get(i).y) < currentMin; j++) {
                double dist = strip.get(i).distanceTo(strip.get(j));
                if (dist < currentMin) {
                    currentMin = dist;
                    p1 = strip.get(i);
                    p2 = strip.get(j);
                }
            }
        }
        
        // 如果没有找到更近的点对，返回一个无效结果
        if (p1 == null) {
            return new ClosestPairResult(null, null, Double.MAX_VALUE);
        }
        
        return new ClosestPairResult(p1, p2, currentMin);
    }
    
    /**
     * 测试最近点对算法
     */
    public static void main(String[] args) {
        System.out.println("=== 测试最近点对算法 ===");
        
        // 测试用例1：随机点集
        Point[] points1 = {
            new Point(2, 3),
            new Point(12, 30),
            new Point(40, 50),
            new Point(5, 1),
            new Point(12, 10),
            new Point(3, 4)
        };
        
        ClosestPairResult result1 = findClosestPair(points1);
        System.out.println("最近点对1: " + result1.p1 + " 和 " + result1.p2);
        System.out.println("距离: " + result1.distance);
        
        // 测试用例2：所有点在一条直线上
        Point[] points2 = {
            new Point(0, 0),
            new Point(1, 0),
            new Point(2, 0),
            new Point(3, 0),
            new Point(100, 0)
        };
        
        ClosestPairResult result2 = findClosestPair(points2);
        System.out.println("最近点对2: " + result2.p1 + " 和 " + result2.p2);
        System.out.println("距离: " + result2.distance);
        
        // 测试用例3：边界情况
        Point[] points3 = {
            new Point(0, 0),
            new Point(0, 0)  // 重复点
        };
        
        ClosestPairResult result3 = findClosestPair(points3);
        System.out.println("最近点对3: " + result3.p1 + " 和 " + result3.p2);
        System.out.println("距离: " + result3.distance);
        
        // 性能测试
        System.out.println("\n=== 性能测试 ===");
        Random random = new Random(42); // 固定种子以确保可重复性
        int n = 10000;
        Point[] points4 = new Point[n];
        for (int i = 0; i < n; i++) {
            points4[i] = new Point(random.nextDouble() * 1000, random.nextDouble() * 1000);
        }
        
        long startTime = System.nanoTime();
        ClosestPairResult result4 = findClosestPair(points4);
        long endTime = System.nanoTime();
        
        System.out.println("10000个随机点的最近点对:");
        System.out.println("最近点对: " + result4.p1 + " 和 " + result4.p2);
        System.out.println("距离: " + result4.distance);
        System.out.println("运行时间: " + (endTime - startTime) / 1_000_000 + " ms");
    }
}

===============================================

文件: ClosestPair2D.java
===============================================
package class185.closest_pair_problems;

import java.util.*;

/**
 * 二维平面最近点对问题实现 (Java版本)
 * 
 * 问题描述：
 * 给定平面上的n个点，找出距离最近的两个点。
 * 
 * 算法思路：
 * 使用分治法解决最近点对问题：
 * 1. 将点集按照x坐标排序
 * 2. 递归地在左半部分和右半部分找最近点对
 * 3. 找到跨越中线的最近点对
 * 4. 返回三者中的最小值
 * 
 * 时间复杂度：O(n log n)
 * 空间复杂度：O(n)
 * 
 * 应用场景：
 * 1. 计算几何中的碰撞检测
 * 2. 机器学习中的最近邻搜索
 * 3. 地理信息系统中的最近设施查询
 * 
 * 相关题目：
 * 1. LeetCode 973. 最接近原点的K个点
 * 2. POJ 3714 Raid
 * 3. HDU 1007 Quoit Design
 */
public class ClosestPair2D {
    
    /**
     * 点类，用于存储二维坐标
     */
    static class Point {
        double x, y;
        
        Point(double x, double y) {
            this.x = x;
            this.y = y;
        }
        
        /**
         * 计算两个点之间的欧几里得距离
         */
        public double distanceTo(Point p) {
            double dx = this.x - p.x;
            double dy = this.y - p.y;
            return Math.sqrt(dx * dx + dy * dy);
        }
        
        @Override
        public String toString() {
            return "(" + x + ", " + y + ")";
        }
    }
    
    /**
     * 最近点对结果类
     */
    static class ClosestPairResult {
        Point p1, p2;
        double distance;
        
        ClosestPairResult(Point p1, Point p2, double distance) {
            this.p1 = p1;
            this.p2 = p2;
            this.distance = distance;
        }
    }
    
    /**
     * 查找最近点对
     * @param points 点集
     * @return 最近点对结果
     */
    public static ClosestPairResult findClosestPair(Point[] points) {
        if (points == null || points.length < 2) {
            throw new IllegalArgumentException("点集必须包含至少两个点");
        }
        
        // 按照x坐标排序
        Point[] pointsSortedByX = points.clone();
        Arrays.sort(pointsSortedByX, Comparator.comparingDouble(p -> p.x));
        
        // 按照y坐标排序（用于后续处理）
        Point[] pointsSortedByY = pointsSortedByX.clone();
        Arrays.sort(pointsSortedByY, Comparator.comparingDouble(p -> p.y));
        
        // 调用递归函数
        return closestPairRecursive(pointsSortedByX, 0, pointsSortedByX.length - 1, pointsSortedByY);
    }
    
    /**
     * 递归求解最近点对
     * @param pointsSortedByX 按x坐标排序的点集
     * @param left 左边界
     * @param right 右边界
     * @param pointsSortedByY 按y坐标排序的点集
     * @return 最近点对结果
     */
    private static ClosestPairResult closestPairRecursive(Point[] pointsSortedByX, int left, int right, 
                                                         Point[] pointsSortedByY) {
        // 基本情况：小规模问题直接暴力求解
        if (right - left <= 3) {
            return bruteForce(pointsSortedByX, left, right);
        }
        
        // 分治求解
        int mid = left + (right - left) / 2;
        Point midPoint = pointsSortedByX[mid];
        
        // 分割y排序的数组
        Point[] leftPointsSortedByY = new Point[mid - left + 1];
        Point[] rightPointsSortedByY = new Point[right - mid];
        
        int leftIdx = 0, rightIdx = 0;
        for (Point p : pointsSortedByY) {
            if (p.x <= midPoint.x && leftIdx < leftPointsSortedByY.length) {
                leftPointsSortedByY[leftIdx++] = p;
            } else if (rightIdx < rightPointsSortedByY.length) {
                rightPointsSortedByY[rightIdx++] = p;
            }
        }
        
        // 递归求解左右子数组
        ClosestPairResult leftResult = closestPairRecursive(pointsSortedByX, left, mid, leftPointsSortedByY);
        ClosestPairResult rightResult = closestPairRecursive(pointsSortedByX, mid + 1, right, rightPointsSortedByY);
        
        // 确定左右子数组中的最小距离
        ClosestPairResult minResult = leftResult.distance < rightResult.distance ? leftResult : rightResult;
        
        // 处理跨越中线的点对
        // 筛选出在中线附近的点
        List<Point> strip = new ArrayList<>();
        for (Point p : pointsSortedByY) {
            if (Math.abs(p.x - midPoint.x) < minResult.distance) {
                strip.add(p);
            }
        }
        
        // 检查strip中的点对
        ClosestPairResult stripResult = checkStrip(strip, minResult.distance);
        
        // 返回最小距离的点对
        if (stripResult.distance < minResult.distance) {
            return stripResult;
        } else {
            return minResult;
        }
    }
    
    /**
     * 暴力求解小规模问题
     * @param points 点集
     * @param left 左边界
     * @param right 右边界
     * @return 最近点对结果
     */
    private static ClosestPairResult bruteForce(Point[] points, int left, int right) {
        double minDist = Double.MAX_VALUE;
        Point p1 = null, p2 = null;
        
        for (int i = left; i <= right; i++) {
            for (int j = i + 1; j <= right; j++) {
                double dist = points[i].distanceTo(points[j]);
                if (dist < minDist) {
                    minDist = dist;
                    p1 = points[i];
                    p2 = points[j];
                }
            }
        }
        
        return new ClosestPairResult(p1, p2, minDist);
    }
    
    /**
     * 检查跨越中线的点对
     * @param strip 中线附近的点集
     * @param minDist 当前最小距离
     * @return 最近点对结果
     */
    private static ClosestPairResult checkStrip(List<Point> strip, double minDist) {
        double currentMin = minDist;
        Point p1 = null, p2 = null;
        
        // 按照y坐标排序（已经是排序好的）
        // 只需要检查相邻的最多7个点
        for (int i = 0; i < strip.size(); i++) {
            for (int j = i + 1; j < strip.size() && (strip.get(j).y - strip.get(i).y) < currentMin; j++) {
                double dist = strip.get(i).distanceTo(strip.get(j));
                if (dist < currentMin) {
                    currentMin = dist;
                    p1 = strip.get(i);
                    p2 = strip.get(j);
                }
            }
        }
        
        // 如果没有找到更近的点对，返回一个无效结果
        if (p1 == null) {
            return new ClosestPairResult(null, null, Double.MAX_VALUE);
        }
        
        return new ClosestPairResult(p1, p2, currentMin);
    }
    
    /**
     * 测试最近点对算法
     */
    public static void main(String[] args) {
        System.out.println("=== 测试最近点对算法 ===");
        
        // 测试用例1：随机点集
        Point[] points1 = {
            new Point(2, 3),
            new Point(12, 30),
            new Point(40, 50),
            new Point(5, 1),
            new Point(12, 10),
            new Point(3, 4)
        };
        
        ClosestPairResult result1 = findClosestPair(points1);
        System.out.println("最近点对1: " + result1.p1 + " 和 " + result1.p2);
        System.out.println("距离: " + result1.distance);
        
        // 测试用例2：所有点在一条直线上
        Point[] points2 = {
            new Point(0, 0),
            new Point(1, 0),
            new Point(2, 0),
            new Point(3, 0),
            new Point(100, 0)
        };
        
        ClosestPairResult result2 = findClosestPair(points2);
        System.out.println("最近点对2: " + result2.p1 + " 和 " + result2.p2);
        System.out.println("距离: " + result2.distance);
        
        // 测试用例3：边界情况
        Point[] points3 = {
            new Point(0, 0),
            new Point(0, 0)  // 重复点
        };
        
        ClosestPairResult result3 = findClosestPair(points3);
        System.out.println("最近点对3: " + result3.p1 + " 和 " + result3.p2);
        System.out.println("距离: " + result3.distance);
        
        // 性能测试
        System.out.println("\n=== 性能测试 ===");
        Random random = new Random(42); // 固定种子以确保可重复性
        int n = 10000;
        Point[] points4 = new Point[n];
        for (int i = 0; i < n; i++) {
            points4[i] = new Point(random.nextDouble() * 1000, random.nextDouble() * 1000);
        }
        
        long startTime = System.nanoTime();
        ClosestPairResult result4 = findClosestPair(points4);
        long endTime = System.nanoTime();
        
        System.out.println("10000个随机点的最近点对:");
        System.out.println("最近点对: " + result4.p1 + " 和 " + result4.p2);
        System.out.println("距离: " + result4.distance);
        System.out.println("运行时间: " + (endTime - startTime) / 1_000_000 + " ms");
    }
}

===============================================

文件: closest_pair.cpp
===============================================
#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <float.h>
#include <time.h>

/**
 * 平面分治算法 - 最近点对问题实现 (C++简化版本)
 * 
 * 问题描述：
 * 给定平面上的n个点，找出距离最近的两个点。
 * 
 * 算法思路：
 * 使用分治法解决最近点对问题：
 * 1. 将点集按照x坐标排序
 * 2. 递归地在左半部分和右半部分找最近点对
 * 3. 找到跨越中线的最近点对
 * 4. 返回三者中的最小值
 * 
 * 时间复杂度：O(n log n)
 * 空间复杂度：O(n)
 * 
 * 应用场景：
 * 1. 计算几何中的碰撞检测
 * 2. 机器学习中的最近邻搜索
 * 3. 地理信息系统中的最近设施查询
 */

struct Point {
    double x, y;
    
    Point() : x(0), y(0) {}
    Point(double x, double y) : x(x), y(y) {}
    
    /**
     * 计算两个点之间的欧几里得距离
     */
    double distanceTo(const Point& p) const {
        double dx = x - p.x;
        double dy = y - p.y;
        return sqrt(dx * dx + dy * dy);
    }
};

struct ClosestPairResult {
    Point p1, p2;
    double distance;
    
    ClosestPairResult() : distance(DBL_MAX) {}
    ClosestPairResult(const Point& p1, const Point& p2, double distance) 
        : p1(p1), p2(p2), distance(distance) {}
};

// 比较函数，用于按x坐标排序
int compareX(const void* a, const void* b) {
    Point* p1 = (Point*)a;
    Point* p2 = (Point*)b;
    if (p1->x != p2->x) {
        return (p1->x < p2->x) ? -1 : 1;
    }
    return (p1->y < p2->y) ? -1 : 1;
}

// 比较函数，用于按y坐标排序
int compareY(const void* a, const void* b) {
    Point* p1 = (Point*)a;
    Point* p2 = (Point*)b;
    if (p1->y != p2->y) {
        return (p1->y < p2->y) ? -1 : 1;
    }
    return (p1->x < p2->x) ? -1 : 1;
}

/**
 * 暴力求解小规模问题
 */
ClosestPairResult bruteForce(Point points[], int left, int right) {
    double minDist = DBL_MAX;
    Point p1, p2;
    
    for (int i = left; i <= right; i++) {
        for (int j = i + 1; j <= right; j++) {
            double dist = points[i].distanceTo(points[j]);
            if (dist < minDist) {
                minDist = dist;
                p1 = points[i];
                p2 = points[j];
            }
        }
    }
    
    return ClosestPairResult(p1, p2, minDist);
}

/**
 * 检查跨越中线的点对
 */
ClosestPairResult checkStrip(Point strip[], int stripSize, double minDist) {
    double currentMin = minDist;
    Point p1, p2;
    int found = 0;
    
    // 只需要检查相邻的最多7个点
    for (int i = 0; i < stripSize; i++) {
        for (int j = i + 1; j < stripSize && (strip[j].y - strip[i].y) < currentMin; j++) {
            double dist = strip[i].distanceTo(strip[j]);
            if (dist < currentMin) {
                currentMin = dist;
                p1 = strip[i];
                p2 = strip[j];
                found = 1;
            }
        }
    }
    
    // 如果没有找到更近的点对，返回一个无效结果
    if (!found) {
        return ClosestPairResult();
    }
    
    return ClosestPairResult(p1, p2, currentMin);
}

/**
 * 递归求解最近点对
 */
ClosestPairResult closestPairRecursive(Point pointsSortedByX[], int n, Point pointsSortedByY[]) {
    // 基本情况：小规模问题直接暴力求解
    if (n <= 3) {
        return bruteForce(pointsSortedByX, 0, n - 1);
    }
    
    // 分治求解
    int mid = n / 2;
    Point midPoint = pointsSortedByX[mid];
    
    // 分割y排序的数组
    Point* leftPointsSortedByY = (Point*)malloc(mid * sizeof(Point));
    Point* rightPointsSortedByY = (Point*)malloc((n - mid) * sizeof(Point));
    int leftIdx = 0, rightIdx = 0;
    
    for (int i = 0; i < n; i++) {
        if (pointsSortedByY[i].x <= midPoint.x && leftIdx < mid) {
            leftPointsSortedByY[leftIdx++] = pointsSortedByY[i];
        } else if (rightIdx < n - mid) {
            rightPointsSortedByY[rightIdx++] = pointsSortedByY[i];
        }
    }
    
    // 递归求解左右子数组
    ClosestPairResult leftResult = closestPairRecursive(pointsSortedByX, mid, leftPointsSortedByY);
    ClosestPairResult rightResult = closestPairRecursive(pointsSortedByX + mid, n - mid, rightPointsSortedByY);
    
    // 确定左右子数组中的最小距离
    ClosestPairResult minResult = leftResult.distance < rightResult.distance ? leftResult : rightResult;
    
    // 处理跨越中线的点对
    // 筛选出在中线附近的点
    Point* strip = (Point*)malloc(n * sizeof(Point));
    int stripSize = 0;
    for (int i = 0; i < n; i++) {
        if (abs(pointsSortedByY[i].x - midPoint.x) < minResult.distance) {
            strip[stripSize++] = pointsSortedByY[i];
        }
    }
    
    // 检查strip中的点对
    ClosestPairResult stripResult = checkStrip(strip, stripSize, minResult.distance);
    
    // 释放内存
    free(leftPointsSortedByY);
    free(rightPointsSortedByY);
    free(strip);
    
    // 返回最小距离的点对
    if (stripResult.distance < minResult.distance) {
        return stripResult;
    } else {
        return minResult;
    }
}

/**
 * 查找最近点对
 */
ClosestPairResult findClosestPair(Point points[], int n) {
    if (n < 2) {
        printf("点集必须包含至少两个点\n");
        exit(1);
    }
    
    // 按照x坐标排序
    Point* pointsSortedByX = (Point*)malloc(n * sizeof(Point));
    for (int i = 0; i < n; i++) {
        pointsSortedByX[i] = points[i];
    }
    qsort(pointsSortedByX, n, sizeof(Point), compareX);
    
    // 按照y坐标排序
    Point* pointsSortedByY = (Point*)malloc(n * sizeof(Point));
    for (int i = 0; i < n; i++) {
        pointsSortedByY[i] = points[i];
    }
    qsort(pointsSortedByY, n, sizeof(Point), compareY);
    
    // 调用递归函数
    ClosestPairResult result = closestPairRecursive(pointsSortedByX, n, pointsSortedByY);
    
    // 释放内存
    free(pointsSortedByX);
    free(pointsSortedByY);
    
    return result;
}

/**
 * 测试最近点对算法
 */
void testClosestPair() {
    printf("=== 测试最近点对算法 ===\n");
    
    // 测试用例1：随机点集
    Point points1[] = {
        Point(2, 3),
        Point(12, 30),
        Point(40, 50),
        Point(5, 1),
        Point(12, 10),
        Point(3, 4)
    };
    int n1 = sizeof(points1) / sizeof(points1[0]);
    
    ClosestPairResult result1 = findClosestPair(points1, n1);
    printf("最近点对1: (%.2f, %.2f) 和 (%.2f, %.2f)\n", 
           result1.p1.x, result1.p1.y, result1.p2.x, result1.p2.y);
    printf("距离: %.2f\n", result1.distance);
    
    // 测试用例2：所有点在一条直线上
    Point points2[] = {
        Point(0, 0),
        Point(1, 0),
        Point(2, 0),
        Point(3, 0),
        Point(100, 0)
    };
    int n2 = sizeof(points2) / sizeof(points2[0]);
    
    ClosestPairResult result2 = findClosestPair(points2, n2);
    printf("最近点对2: (%.2f, %.2f) 和 (%.2f, %.2f)\n", 
           result2.p1.x, result2.p1.y, result2.p2.x, result2.p2.y);
    printf("距离: %.2f\n", result2.distance);
    
    // 测试用例3：边界情况
    Point points3[] = {
        Point(0, 0),
        Point(0, 0)  // 重复点
    };
    int n3 = sizeof(points3) / sizeof(points3[0]);
    
    ClosestPairResult result3 = findClosestPair(points3, n3);
    printf("最近点对3: (%.2f, %.2f) 和 (%.2f, %.2f)\n", 
           result3.p1.x, result3.p1.y, result3.p2.x, result3.p2.y);
    printf("距离: %.2f\n", result3.distance);
}

int main() {
    testClosestPair();
    return 0;
}

===============================================

文件: closest_pair.py
===============================================
#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
平面分治算法 - 最近点对问题实现 (Python版本)

问题描述：
给定平面上的n个点，找出距离最近的两个点。

算法思路：
使用分治法解决最近点对问题：
1. 将点集按照x坐标排序
2. 递归地在左半部分和右半部分找最近点对
3. 找到跨越中线的最近点对
4. 返回三者中的最小值

时间复杂度：O(n log n)
空间复杂度：O(n)

应用场景：
1. 计算几何中的碰撞检测
2. 机器学习中的最近邻搜索
3. 地理信息系统中的最近设施查询
"""

import math
import random
import time

class Point:
    """点类，用于存储二维坐标"""
    
    def __init__(self, x, y):
        self.x = x
        self.y = y
    
    def distance_to(self, p):
        """计算两个点之间的欧几里得距离"""
        dx = self.x - p.x
        dy = self.y - p.y
        return math.sqrt(dx * dx + dy * dy)
    
    def __str__(self):
        return f"({self.x}, {self.y})"
    
    def __repr__(self):
        return f"Point({self.x}, {self.y})"

class ClosestPairResult:
    """最近点对结果类"""
    
    def __init__(self, p1=None, p2=None, distance=float('inf')):
        self.p1 = p1
        self.p2 = p2
        self.distance = distance

class ClosestPair:
    """最近点对算法实现类"""
    
    @staticmethod
    def find_closest_pair(points):
        """
        查找最近点对
        :param points: 点集
        :return: 最近点对结果
        """
        if not points or len(points) < 2:
            raise ValueError("点集必须包含至少两个点")
        
        # 按照x坐标排序
        points_sorted_by_x = sorted(points, key=lambda p: p.x)
        
        # 按照y坐标排序
        points_sorted_by_y = sorted(points, key=lambda p: p.y)
        
        # 调用递归函数
        return ClosestPair._closest_pair_recursive(points_sorted_by_x, points_sorted_by_y)
    
    @staticmethod
    def _closest_pair_recursive(points_sorted_by_x, points_sorted_by_y):
        """
        递归求解最近点对
        :param points_sorted_by_x: 按x坐标排序的点集
        :param points_sorted_by_y: 按y坐标排序的点集
        :return: 最近点对结果
        """
        n = len(points_sorted_by_x)
        
        # 基本情况：小规模问题直接暴力求解
        if n <= 3:
            return ClosestPair._brute_force(points_sorted_by_x)
        
        # 分治求解
        mid = n // 2
        mid_point = points_sorted_by_x[mid]
        
        # 分割点集
        left_points_x = points_sorted_by_x[:mid]
        right_points_x = points_sorted_by_x[mid:]
        
        # 分割y排序的数组
        left_points_y = []
        right_points_y = []
        for p in points_sorted_by_y:
            if p.x <= mid_point.x:
                left_points_y.append(p)
            else:
                right_points_y.append(p)
        
        # 递归求解左右子数组
        left_result = ClosestPair._closest_pair_recursive(left_points_x, left_points_y)
        right_result = ClosestPair._closest_pair_recursive(right_points_x, right_points_y)
        
        # 确定左右子数组中的最小距离
        min_result = left_result if left_result.distance < right_result.distance else right_result
        
        # 处理跨越中线的点对
        # 筛选出在中线附近的点
        strip = []
        for p in points_sorted_by_y:
            if abs(p.x - mid_point.x) < min_result.distance:
                strip.append(p)
        
        # 检查strip中的点对
        strip_result = ClosestPair._check_strip(strip, min_result.distance)
        
        # 返回最小距离的点对
        if strip_result.distance < min_result.distance:
            return strip_result
        else:
            return min_result
    
    @staticmethod
    def _brute_force(points):
        """
        暴力求解小规模问题
        :param points: 点集
        :return: 最近点对结果
        """
        min_dist = float('inf')
        p1 = None
        p2 = None
        
        for i in range(len(points)):
            for j in range(i + 1, len(points)):
                dist = points[i].distance_to(points[j])
                if dist < min_dist:
                    min_dist = dist
                    p1 = points[i]
                    p2 = points[j]
        
        return ClosestPairResult(p1, p2, min_dist)
    
    @staticmethod
    def _check_strip(strip, min_dist):
        """
        检查跨越中线的点对
        :param strip: 中线附近的点集
        :param min_dist: 当前最小距离
        :return: 最近点对结果
        """
        current_min = min_dist
        p1 = None
        p2 = None
        
        # 按照y坐标排序（已经是排序好的）
        # 只需要检查相邻的最多7个点
        for i in range(len(strip)):
            j = i + 1
            while j < len(strip) and (strip[j].y - strip[i].y) < current_min:
                dist = strip[i].distance_to(strip[j])
                if dist < current_min:
                    current_min = dist
                    p1 = strip[i]
                    p2 = strip[j]
                j += 1
        
        # 如果没有找到更近的点对，返回一个无效结果
        if p1 is None:
            return ClosestPairResult(None, None, float('inf'))
        
        return ClosestPairResult(p1, p2, current_min)
    
    @staticmethod
    def test_closest_pair():
        """测试最近点对算法"""
        print("=== 测试最近点对算法 ===")
        
        # 测试用例1：随机点集
        points1 = [
            Point(2, 3),
            Point(12, 30),
            Point(40, 50),
            Point(5, 1),
            Point(12, 10),
            Point(3, 4)
        ]
        
        result1 = ClosestPair.find_closest_pair(points1)
        print(f"最近点对1: {result1.p1} 和 {result1.p2}")
        print(f"距离: {result1.distance}")
        
        # 测试用例2：所有点在一条直线上
        points2 = [
            Point(0, 0),
            Point(1, 0),
            Point(2, 0),
            Point(3, 0),
            Point(100, 0)
        ]
        
        result2 = ClosestPair.find_closest_pair(points2)
        print(f"最近点对2: {result2.p1} 和 {result2.p2}")
        print(f"距离: {result2.distance}")
        
        # 测试用例3：边界情况
        points3 = [
            Point(0, 0),
            Point(0, 0)  # 重复点
        ]
        
        result3 = ClosestPair.find_closest_pair(points3)
        print(f"最近点对3: {result3.p1} 和 {result3.p2}")
        print(f"距离: {result3.distance}")
        
        # 性能测试
        print("\n=== 性能测试 ===")
        random.seed(42)  # 固定种子以确保可重复性
        n = 10000
        points4 = [Point(random.uniform(0, 1000), random.uniform(0, 1000)) for _ in range(n)]
        
        start_time = time.time()
        result4 = ClosestPair.find_closest_pair(points4)
        end_time = time.time()
        
        print(f"10000个随机点的最近点对:")
        print(f"最近点对: {result4.p1} 和 {result4.p2}")
        print(f"距离: {result4.distance}")
        print(f"运行时间: {(end_time - start_time) * 1000:.2f} ms")

if __name__ == "__main__":
    ClosestPair.test_closest_pair()

===============================================

文件: closest_pair_2d.cpp
===============================================
#include <iostream>
#include <vector>
#include <algorithm>
#include <cmath>
#include <stdexcept>
#include <memory>
#include <limits>
#include <random>
#include <chrono>

using namespace std;

/**
 * 二维平面最近点对问题实现 (C++版本)
 * 
 * 问题描述：
 * 给定平面上的n个点，找出距离最近的两个点。
 * 
 * 算法思路：
 * 使用分治法解决最近点对问题：
 * 1. 将点集按照x坐标排序
 * 2. 递归地在左半部分和右半部分找最近点对
 * 3. 找到跨越中线的最近点对
 * 4. 返回三者中的最小值
 * 
 * 时间复杂度：O(n log n)
 * 空间复杂度：O(n)
 * 
 * 应用场景：
 * 1. 计算几何中的碰撞检测
 * 2. 机器学习中的最近邻搜索
 * 3. 地理信息系统中的最近设施查询
 * 
 * 相关题目：
 * 1. LeetCode 973. 最接近原点的K个点
 * 2. POJ 3714 Raid
 * 3. HDU 1007 Quoit Design
 */

// ================================
// 点类定义
// ================================

/**
 * 平面点类，表示二维平面上的一个点
 */
struct Point {
    double x, y;
    
    /**
     * 构造函数
     * @param x 点的x坐标
     * @param y 点的y坐标
     */
    Point(double x = 0, double y = 0) : x(x), y(y) {}
    
    /**
     * 计算与另一个点的欧几里得距离
     * @param other 另一个点
     * @return 两点间的距离
     */
    double distanceTo(const Point& other) const {
        double dx = this->x - other.x;
        double dy = this->y - other.y;
        return std::sqrt(dx * dx + dy * dy);
    }
    
    /**
     * 按x坐标排序的比较函数
     * @param other 另一个点
     * @return 如果当前点的x坐标小于另一个点，则返回true
     */
    bool operator<(const Point& other) const {
        return x < other.x;
    }
    
    /**
     * 输出运算符重载
     */
    friend std::ostream& operator<<(std::ostream& os, const Point& p) {
        return os << "(" << p.x << ", " << p.y << ")";
    }
};

/**
 * 点对距离结果类，存储最近点对及其距离
 */
struct PairDistance {
    double distance;  // 两点间距离
    Point p1, p2;     // 两个点
    
    /**
     * 构造函数
     * @param distance 距离
     * @param p1 第一个点
     * @param p2 第二个点
     */
    PairDistance(double distance = 0, Point p1 = Point(), Point p2 = Point()) 
        : distance(distance), p1(p1), p2(p2) {}
};

// ================================
// 辅助函数
// ================================

/**
 * 按y坐标排序的比较函数
 * @param a 第一个点
 * @param b 第二个点
 * @return 如果a的y坐标小于b的y坐标，则返回true
 */
bool compareByY(const Point& a, const Point& b) {
    return a.y < b.y;
}

/**
 * 暴力法计算最近点对
 * 时间复杂度：O(n^2)
 * @param points 点的集合
 * @return 最近点对及其距离
 */
PairDistance bruteForceClosestPair(const std::vector<Point>& points) {
    int n = points.size();
    double minDist = std::numeric_limits<double>::max();
    Point p1, p2;
    
    for (int i = 0; i < n; i++) {
        for (int j = i + 1; j < n; j++) {
            double dist = points[i].distanceTo(points[j]);
            if (dist < minDist) {
                minDist = dist;
                p1 = points[i];
                p2 = points[j];
            }
        }
    }
    
    return PairDistance(minDist, p1, p2);
}

/**
 * 计算带内（跨越中线的区域）的最近点对
 * 时间复杂度：O(n) - 由于每个点最多检查常数个点
 * @param strip 带内的点集
 * @param currentMin 当前已知的最小距离
 * @return 带内的最近点对
 */
PairDistance stripClosest(std::vector<Point>& strip, PairDistance currentMin) {
    double minDist = currentMin.distance;
    Point p1 = currentMin.p1;
    Point p2 = currentMin.p2;
    
    // 按y坐标排序已经完成
    int size = strip.size();
    
    // 对于带内的每个点，只需要检查后面y坐标相差不超过min_dist的点
    // 理论上只需要检查最多6个点，这是平面分治算法的关键优化点
    for (int i = 0; i < size; i++) {
        for (int j = i + 1; j < size && (strip[j].y - strip[i].y) < minDist; j++) {
            double dist = strip[i].distanceTo(strip[j]);
            if (dist < minDist) {
                minDist = dist;
                p1 = strip[i];
                p2 = strip[j];
            }
        }
    }
    
    return PairDistance(minDist, p1, p2);
}

/**
 * 递归实现平面分治算法
 * @param pointsSortedByX 按x坐标排序的点集
 * @param pointsSortedByY 按y坐标排序的点集
 * @return 最近点对及其距离
 */
PairDistance closestPairRecursive(std::vector<Point>& pointsSortedByX, std::vector<Point>& pointsSortedByY) {
    int n = pointsSortedByX.size();
    
    // 基本情况：小于等于3个点，使用暴力法
    if (n <= 3) {
        return bruteForceClosestPair(pointsSortedByX);
    }
    
    // 分治：将点集分为左右两部分
    int mid = n / 2;
    Point midPoint = pointsSortedByX[mid];
    
    // 分割y排序的点列表
    std::vector<Point> leftPointsY, rightPointsY;
    
    for (const Point& p : pointsSortedByY) {
        if (p.x <= midPoint.x) {
            leftPointsY.push_back(p);
        } else {
            rightPointsY.push_back(p);
        }
    }
    
    // 递归求解左右两部分的最近点对
    std::vector<Point> leftPointsX(pointsSortedByX.begin(), pointsSortedByX.begin() + mid);
    std::vector<Point> rightPointsX(pointsSortedByX.begin() + mid, pointsSortedByX.end());
    
    PairDistance leftResult = closestPairRecursive(leftPointsX, leftPointsY);
    PairDistance rightResult = closestPairRecursive(rightPointsX, rightPointsY);
    
    // 合并：取左右两部分中的最小距离
    PairDistance minResult = (leftResult.distance <= rightResult.distance) 
        ? leftResult : rightResult;
    
    // 带内搜索：查找跨越中线的点对
    // 构建带内的点列表，只考虑x坐标在中线附近min_dist范围内的点
    std::vector<Point> strip;
    for (const Point& p : pointsSortedByY) {
        if (std::abs(p.x - midPoint.x) < minResult.distance) {
            strip.push_back(p);
        }
    }
    
    // 在带内查找可能的更近点对
    PairDistance stripResult = stripClosest(strip, minResult);
    
    // 比较并返回全局最小距离
    return (stripResult.distance < minResult.distance) ? stripResult : minResult;
}

/**
 * 平面分治算法主函数 - 最近点对问题
 * 时间复杂度：O(n log n)
 * 空间复杂度：O(n)
 * @param points 点的集合
 * @return 最近点对及其距离
 * @throws std::invalid_argument 当输入无效时抛出异常
 */
PairDistance closestPair(std::vector<Point> points) {
    if (points.empty()) {
        throw std::invalid_argument("输入点列表不能为空");
    }
    if (points.size() < 2) {
        throw std::invalid_argument("至少需要两个点来计算距离");
    }
    
    // 按x坐标排序
    std::vector<Point> pointsSortedByX = points;
    std::sort(pointsSortedByX.begin(), pointsSortedByX.end());
    
    // 按y坐标排序，用于带内搜索
    std::vector<Point> pointsSortedByY = points;
    std::sort(pointsSortedByY.begin(), pointsSortedByY.end(), compareByY);
    
    // 调用递归函数
    return closestPairRecursive(pointsSortedByX, pointsSortedByY);
}

/**
 * 测试函数：打印算法测试结果
 */
void testClosestPair() {
    std::cout << "=== C++最近点对算法测试 ===" << std::endl;
    
    // 测试用例1：随机点集
    std::vector<Point> points1 = {
        Point(2, 3),
        Point(12, 30),
        Point(40, 50),
        Point(5, 1),
        Point(12, 10),
        Point(3, 4)
    };
    
    try {
        PairDistance result1 = closestPair(points1);
        std::cout << "最近点对1: " << result1.p1 << " 和 " << result1.p2 << std::endl;
        std::cout << "距离: " << result1.distance << std::endl;
    } catch (const std::exception& e) {
        std::cerr << "错误: " << e.what() << std::endl;
    }
    
    // 测试用例2：所有点在一条直线上
    std::vector<Point> points2 = {
        Point(0, 0),
        Point(1, 0),
        Point(2, 0),
        Point(3, 0),
        Point(100, 0)
    };
    
    try {
        PairDistance result2 = closestPair(points2);
        std::cout << "最近点对2: " << result2.p1 << " 和 " << result2.p2 << std::endl;
        std::cout << "距离: " << result2.distance << std::endl;
    } catch (const std::exception& e) {
        std::cerr << "错误: " << e.what() << std::endl;
    }
    
    // 测试用例3：边界情况
    std::vector<Point> points3 = {
        Point(0, 0),
        Point(0, 0)  // 重复点
    };
    
    try {
        PairDistance result3 = closestPair(points3);
        std::cout << "最近点对3: " << result3.p1 << " 和 " << result3.p2 << std::endl;
        std::cout << "距离: " << result3.distance << std::endl;
    } catch (const std::exception& e) {
        std::cerr << "错误: " << e.what() << std::endl;
    }
    
    // 性能测试
    std::cout << "\n=== 性能测试 ===" << std::endl;
    
    // 生成大量随机点
    std::random_device rd;
    std::mt19937 gen(rd());
    std::uniform_real_distribution<double> dis(0.0, 1000.0);
    
    int n = 10000;
    std::vector<Point> points4;
    points4.reserve(n);
    
    for (int i = 0; i < n; i++) {
        points4.emplace_back(dis(gen), dis(gen));
    }
    
    auto start_time = std::chrono::high_resolution_clock::now();
    PairDistance result4 = closestPair(points4);
    auto end_time = std::chrono::high_resolution_clock::now();
    
    auto duration = std::chrono::duration_cast<std::chrono::milliseconds>(end_time - start_time);
    
    std::cout << "10000个随机点的最近点对:" << std::endl;
    std::cout << "最近点对: " << result4.p1 << " 和 " << result4.p2 << std::endl;
    std::cout << "距离: " << result4.distance << std::endl;
    std::cout << "运行时间: " << duration.count() << " ms" << std::endl;
}

int main() {
    testClosestPair();
    return 0;
}

===============================================

文件: closest_pair_2d.py
===============================================
#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
二维平面最近点对问题实现 (Python版本)

问题描述：
给定平面上的n个点，找出距离最近的两个点。

算法思路：
使用分治法解决最近点对问题：
1. 将点集按照x坐标排序
2. 递归地在左半部分和右半部分找最近点对
3. 找到跨越中线的最近点对
4. 返回三者中的最小值

时间复杂度：O(n log n)
空间复杂度：O(n)

应用场景：
1. 计算几何中的碰撞检测
2. 机器学习中的最近邻搜索
3. 地理信息系统中的最近设施查询

相关题目：
1. LeetCode 973. 最接近原点的K个点
2. POJ 3714 Raid
3. HDU 1007 Quoit Design
"""

import math
import random
import time

class Point:
    """点类，用于存储二维坐标"""
    
    def __init__(self, x, y):
        self.x = x
        self.y = y
    
    def distance_to(self, p):
        """计算两个点之间的欧几里得距离"""
        dx = self.x - p.x
        dy = self.y - p.y
        return math.sqrt(dx * dx + dy * dy)
    
    def __str__(self):
        return f"({self.x}, {self.y})"
    
    def __repr__(self):
        return f"Point({self.x}, {self.y})"

class ClosestPairResult:
    """最近点对结果类"""
    
    def __init__(self, p1=None, p2=None, distance=float('inf')):
        self.p1 = p1
        self.p2 = p2
        self.distance = distance

class ClosestPair2D:
    """最近点对算法实现类"""
    
    @staticmethod
    def find_closest_pair(points):
        """
        查找最近点对
        :param points: 点集
        :return: 最近点对结果
        """
        if not points or len(points) < 2:
            raise ValueError("点集必须包含至少两个点")
        
        # 按照x坐标排序
        points_sorted_by_x = sorted(points, key=lambda p: p.x)
        
        # 按照y坐标排序
        points_sorted_by_y = sorted(points, key=lambda p: p.y)
        
        # 调用递归函数
        return ClosestPair2D._closest_pair_recursive(points_sorted_by_x, points_sorted_by_y)
    
    @staticmethod
    def _closest_pair_recursive(points_sorted_by_x, points_sorted_by_y):
        """
        递归求解最近点对
        :param points_sorted_by_x: 按x坐标排序的点集
        :param points_sorted_by_y: 按y坐标排序的点集
        :return: 最近点对结果
        """
        n = len(points_sorted_by_x)
        
        # 基本情况：小规模问题直接暴力求解
        if n <= 3:
            return ClosestPair2D._brute_force(points_sorted_by_x)
        
        # 分治求解
        mid = n // 2
        mid_point = points_sorted_by_x[mid]
        
        # 分割点集
        left_points_x = points_sorted_by_x[:mid]
        right_points_x = points_sorted_by_x[mid:]
        
        # 分割y排序的数组
        left_points_y = []
        right_points_y = []
        for p in points_sorted_by_y:
            if p.x <= mid_point.x:
                left_points_y.append(p)
            else:
                right_points_y.append(p)
        
        # 递归求解左右子数组
        left_result = ClosestPair2D._closest_pair_recursive(left_points_x, left_points_y)
        right_result = ClosestPair2D._closest_pair_recursive(right_points_x, right_points_y)
        
        # 确定左右子数组中的最小距离
        min_result = left_result if left_result.distance < right_result.distance else right_result
        
        # 处理跨越中线的点对
        # 筛选出在中线附近的点
        strip = []
        for p in points_sorted_by_y:
            if abs(p.x - mid_point.x) < min_result.distance:
                strip.append(p)
        
        # 检查strip中的点对
        strip_result = ClosestPair2D._check_strip(strip, min_result.distance)
        
        # 返回最小距离的点对
        if strip_result.distance < min_result.distance:
            return strip_result
        else:
            return min_result
    
    @staticmethod
    def _brute_force(points):
        """
        暴力求解小规模问题
        :param points: 点集
        :return: 最近点对结果
        """
        min_dist = float('inf')
        p1 = None
        p2 = None
        
        for i in range(len(points)):
            for j in range(i + 1, len(points)):
                dist = points[i].distance_to(points[j])
                if dist < min_dist:
                    min_dist = dist
                    p1 = points[i]
                    p2 = points[j]
        
        return ClosestPairResult(p1, p2, min_dist)
    
    @staticmethod
    def _check_strip(strip, min_dist):
        """
        检查跨越中线的点对
        :param strip: 中线附近的点集
        :param min_dist: 当前最小距离
        :return: 最近点对结果
        """
        current_min = min_dist
        p1 = None
        p2 = None
        
        # 按照y坐标排序（已经是排序好的）
        # 只需要检查相邻的最多7个点
        for i in range(len(strip)):
            j = i + 1
            while j < len(strip) and (strip[j].y - strip[i].y) < current_min:
                dist = strip[i].distance_to(strip[j])
                if dist < current_min:
                    current_min = dist
                    p1 = strip[i]
                    p2 = strip[j]
                j += 1
        
        # 如果没有找到更近的点对，返回一个无效结果
        if p1 is None:
            return ClosestPairResult(None, None, float('inf'))
        
        return ClosestPairResult(p1, p2, current_min)
    
    @staticmethod
    def test_closest_pair():
        """测试最近点对算法"""
        print("=== 测试最近点对算法 ===")
        
        # 测试用例1：随机点集
        points1 = [
            Point(2, 3),
            Point(12, 30),
            Point(40, 50),
            Point(5, 1),
            Point(12, 10),
            Point(3, 4)
        ]
        
        result1 = ClosestPair2D.find_closest_pair(points1)
        print(f"最近点对1: {result1.p1} 和 {result1.p2}")
        print(f"距离: {result1.distance}")
        
        # 测试用例2：所有点在一条直线上
        points2 = [
            Point(0, 0),
            Point(1, 0),
            Point(2, 0),
            Point(3, 0),
            Point(100, 0)
        ]
        
        result2 = ClosestPair2D.find_closest_pair(points2)
        print(f"最近点对2: {result2.p1} 和 {result2.p2}")
        print(f"距离: {result2.distance}")
        
        # 测试用例3：边界情况
        points3 = [
            Point(0, 0),
            Point(0, 0)  # 重复点
        ]
        
        result3 = ClosestPair2D.find_closest_pair(points3)
        print(f"最近点对3: {result3.p1} 和 {result3.p2}")
        print(f"距离: {result3.distance}")
        
        # 性能测试
        print("\n=== 性能测试 ===")
        random.seed(42)  # 固定种子以确保可重复性
        n = 10000
        points4 = [Point(random.uniform(0, 1000), random.uniform(0, 1000)) for _ in range(n)]
        
        start_time = time.time()
        result4 = ClosestPair2D.find_closest_pair(points4)
        end_time = time.time()
        
        print(f"10000个随机点的最近点对:")
        print(f"最近点对: {result4.p1} 和 {result4.p2}")
        print(f"距离: {result4.distance}")
        print(f"运行时间: {(end_time - start_time) * 1000:.2f} ms")

if __name__ == "__main__":
    ClosestPair2D.test_closest_pair()

===============================================

文件: Codeforces_1042D_PetyaAndArray.java
===============================================
package class008_AdvancedAlgorithmsAndDataStructures.closest_pair_problems;

import java.util.*;

/**
 * Codeforces 1042D Petya and Array
 * 
 * 题目描述：
 * 给定一个包含n个整数的数组a和一个整数t，找出有多少个连续子数组的和严格小于t。
 * 
 * 解题思路：
 * 这个问题可以转化为前缀和问题。设prefix[i]表示前i个元素的和，那么子数组a[l..r]的和等于
 * prefix[r] - prefix[l-1]。我们需要找出有多少对(l,r)满足prefix[r] - prefix[l-1] < t，
 * 即prefix[l-1] > prefix[r] - t。
 * 
 * 我们可以使用平面分治算法的思想来解决这个问题，将问题转化为最近点对问题的变种。
 * 
 * 时间复杂度：O(n log n)
 * 空间复杂度：O(n)
 */
public class Codeforces_1042D_PetyaAndArray {
    
    static class Solution {
        public long countSubarrays(int[] a, int t) {
            int n = a.length;
            long[] prefix = new long[n + 1];
            
            // 计算前缀和
            for (int i = 0; i < n; i++) {
                prefix[i + 1] = prefix[i] + a[i];
            }
            
            // 使用归并排序的思想计算满足条件的子数组数量
            return mergeSortAndCount(prefix, 0, n, t);
        }
        
        private long mergeSortAndCount(long[] prefix, int left, int right, int t) {
            if (left >= right) {
                return 0;
            }
            
            int mid = left + (right - left) / 2;
            long count = 0;
            
            // 递归计算左半部分和右半部分的答案
            count += mergeSortAndCount(prefix, left, mid, t);
            count += mergeSortAndCount(prefix, mid + 1, right, t);
            
            // 计算跨越中点的子数组数量
            count += countCrossing(prefix, left, mid, right, t);
            
            // 合并两个有序数组
            merge(prefix, left, mid, right);
            
            return count;
        }
        
        private long countCrossing(long[] prefix, int left, int mid, int right, int t) {
            long count = 0;
            
            // 对于右半部分的每个元素，计算左半部分有多少元素满足条件
            for (int j = mid + 1; j <= right; j++) {
                // 我们需要找到左半部分中满足 prefix[i] > prefix[j] - t 的元素数量
                // 即找到左半部分中大于 prefix[j] - t 的元素数量
                double target = prefix[j] - t;
                count += countGreaterThan(prefix, left, mid, target);
            }
            
            return count;
        }
        
        private int countGreaterThan(long[] arr, int left, int right, double target) {
            // 在有序数组arr[left..right]中找到大于target的元素数量
            // 使用二分查找
            int low = left, high = right + 1;
            
            while (low < high) {
                int mid = low + (high - low) / 2;
                if (arr[mid] > target) {
                    high = mid;
                } else {
                    low = mid + 1;
                }
            }
            
            return right + 1 - low;
        }
        
        private void merge(long[] prefix, int left, int mid, int right) {
            long[] temp = new long[right - left + 1];
            int i = left, j = mid + 1, k = 0;
            
            while (i <= mid && j <= right) {
                if (prefix[i] <= prefix[j]) {
                    temp[k++] = prefix[i++];
                } else {
                    temp[k++] = prefix[j++];
                }
            }
            
            while (i <= mid) {
                temp[k++] = prefix[i++];
            }
            
            while (j <= right) {
                temp[k++] = prefix[j++];
            }
            
            for (i = 0; i < temp.length; i++) {
                prefix[left + i] = temp[i];
            }
        }
    }
    
    // 测试方法
    public static void main(String[] args) {
        Solution solution = new Solution();
        
        // 测试用例1
        int[] a1 = {5, -1, 4, -2, 3};
        int t1 = 6;
        System.out.println("测试用例1:");
        System.out.println("数组: " + Arrays.toString(a1));
        System.out.println("t = " + t1);
        System.out.println("结果: " + solution.countSubarrays(a1, t1));
        System.out.println();
        
        // 测试用例2
        int[] a2 = {-1, 2, -3, 4, -5};
        int t2 = 0;
        System.out.println("测试用例2:");
        System.out.println("数组: " + Arrays.toString(a2));
        System.out.println("t = " + t2);
        System.out.println("结果: " + solution.countSubarrays(a2, t2));
        System.out.println();
        
        // 测试用例3
        int[] a3 = {1, 2, 3, 4, 5};
        int t3 = 10;
        System.out.println("测试用例3:");
        System.out.println("数组: " + Arrays.toString(a3));
        System.out.println("t = " + t3);
        System.out.println("结果: " + solution.countSubarrays(a3, t3));
    }
}

===============================================

文件: codeforces_1042d_petya_and_array.cpp
===============================================
// Codeforces 1042D Petya and Array
// C++ 实现

/**
 * Codeforces 1042D Petya and Array
 * 
 * 题目描述：
 * 给定一个包含n个整数的数组a和一个整数t，找出有多少个连续子数组的和严格小于t。
 * 
 * 解题思路：
 * 这个问题可以转化为前缀和问题。设prefix[i]表示前i个元素的和，那么子数组a[l..r]的和等于
 * prefix[r] - prefix[l-1]。我们需要找出有多少对(l,r)满足prefix[r] - prefix[l-1] < t，
 * 即prefix[l-1] > prefix[r] - t。
 * 
 * 我们可以使用归并排序的思想来解决这个问题。
 * 
 * 时间复杂度：O(n log n)
 * 空间复杂度：O(n)
 */

// 由于编译环境限制，这里提供算法思路和伪代码实现

/*
long long countSubarrays(int* a, int n, int t) {
    // 计算前缀和
    long long* prefix = (long long*)calloc(n + 1, sizeof(long long));
    for (int i = 0; i < n; i++) {
        prefix[i + 1] = prefix[i] + a[i];
    }
    
    // 使用归并排序的思想计算满足条件的子数组数量
    long long result = mergeSortAndCount(prefix, 0, n, t);
    
    free(prefix);
    return result;
}

long long mergeSortAndCount(long long* prefix, int left, int right, int t) {
    if (left >= right) {
        return 0;
    }
    
    int mid = left + (right - left) / 2;
    long long count = 0;
    
    // 递归计算左半部分和右半部分的答案
    count += mergeSortAndCount(prefix, left, mid, t);
    count += mergeSortAndCount(prefix, mid + 1, right, t);
    
    // 计算跨越中点的子数组数量
    count += countCrossing(prefix, left, mid, right, t);
    
    // 合并两个有序数组
    merge(prefix, left, mid, right);
    
    return count;
}

long long countCrossing(long long* prefix, int left, int mid, int right, int t) {
    long long count = 0;
    
    // 对于右半部分的每个元素，计算左半部分有多少元素满足条件
    for (int j = mid + 1; j <= right; j++) {
        // 我们需要找到左半部分中满足 prefix[i] > prefix[j] - t 的元素数量
        // 即找到左半部分中大于 prefix[j] - t 的元素数量
        double target = (double)(prefix[j] - t);
        count += countGreaterThan(prefix, left, mid, target);
    }
    
    return count;
}

int countGreaterThan(long long* arr, int left, int right, double target) {
    // 在有序数组arr[left..right]中找到大于target的元素数量
    // 使用二分查找
    int low = left, high = right + 1;
    
    while (low < high) {
        int mid = low + (high - low) / 2;
        if ((double)arr[mid] > target) {
            high = mid;
        } else {
            low = mid + 1;
        }
    }
    
    return right + 1 - low;
}

void merge(long long* prefix, int left, int mid, int right) {
    long long* temp = (long long*)malloc((right - left + 1) * sizeof(long long));
    int i = left, j = mid + 1, k = 0;
    
    while (i <= mid && j <= right) {
        if (prefix[i] <= prefix[j]) {
            temp[k++] = prefix[i++];
        } else {
            temp[k++] = prefix[j++];
        }
    }
    
    while (i <= mid) {
        temp[k++] = prefix[i++];
    }
    
    while (j <= right) {
        temp[k++] = prefix[j++];
    }
    
    for (i = 0; i < right - left + 1; i++) {
        prefix[left + i] = temp[i];
    }
    
    free(temp);
}

// 算法核心思想：
// 1. 将问题转化为前缀和问题
// 2. 使用归并排序的思想计算满足条件的子数组数量
// 3. 通过二分查找优化计算过程

// 时间复杂度分析：
// - 计算前缀和：O(n)
// - 归并排序过程：O(n log n)
// - 二分查找：O(log n)
// - 总体时间复杂度：O(n log n)
// - 空间复杂度：O(n)
*/

// 算法应用场景：
// 1. 数组子段和问题
// 2. 前缀和优化技巧
// 3. 归并排序在计数问题中的应用

===============================================

文件: codeforces_1042d_petya_and_array.py
===============================================
#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
Codeforces 1042D Petya and Array

题目描述：
给定一个包含n个整数的数组a和一个整数t，找出有多少个连续子数组的和严格小于t。

解题思路：
这个问题可以转化为前缀和问题。设prefix[i]表示前i个元素的和，那么子数组a[l..r]的和等于
prefix[r] - prefix[l-1]。我们需要找出有多少对(l,r)满足prefix[r] - prefix[l-1] < t，
即prefix[l-1] > prefix[r] - t。

我们可以使用归并排序的思想来解决这个问题。

时间复杂度：O(n log n)
空间复杂度：O(n)
"""

class Solution:
    def count_subarrays(self, a, t):
        """
        计算连续子数组和严格小于t的数量
        
        Args:
            a: 输入数组
            t: 阈值
            
        Returns:
            满足条件的子数组数量
        """
        n = len(a)
        # 计算前缀和
        prefix = [0] * (n + 1)
        for i in range(n):
            prefix[i + 1] = prefix[i] + a[i]
        
        # 使用归并排序的思想计算满足条件的子数组数量
        return self.merge_sort_and_count(prefix, 0, n, t)
    
    def merge_sort_and_count(self, prefix, left, right, t):
        """
        使用归并排序计算满足条件的子数组数量
        
        Args:
            prefix: 前缀和数组
            left: 左边界
            right: 右边界
            t: 阈值
            
        Returns:
            满足条件的子数组数量
        """
        if left >= right:
            return 0
        
        mid = left + (right - left) // 2
        count = 0
        
        # 递归计算左半部分和右半部分的答案
        count += self.merge_sort_and_count(prefix, left, mid, t)
        count += self.merge_sort_and_count(prefix, mid + 1, right, t)
        
        # 计算跨越中点的子数组数量
        count += self.count_crossing(prefix, left, mid, right, t)
        
        # 合并两个有序数组
        self.merge(prefix, left, mid, right)
        
        return count
    
    def count_crossing(self, prefix, left, mid, right, t):
        """
        计算跨越中点的满足条件的子数组数量
        
        Args:
            prefix: 前缀和数组
            left: 左边界
            mid: 中点
            right: 右边界
            t: 阈值
            
        Returns:
            满足条件的子数组数量
        """
        count = 0
        
        # 对于右半部分的每个元素，计算左半部分有多少元素满足条件
        for j in range(mid + 1, right + 1):
            # 我们需要找到左半部分中满足 prefix[i] > prefix[j] - t 的元素数量
            # 即找到左半部分中大于 prefix[j] - t 的元素数量
            target = prefix[j] - t
            count += self.count_greater_than(prefix, left, mid, target)
        
        return count
    
    def count_greater_than(self, arr, left, right, target):
        """
        在有序数组arr[left..right]中找到大于target的元素数量
        
        Args:
            arr: 数组
            left: 左边界
            right: 右边界
            target: 目标值
            
        Returns:
            大于target的元素数量
        """
        # 使用二分查找
        low, high = left, right + 1
        
        while low < high:
            mid = low + (high - low) // 2
            if arr[mid] > target:
                high = mid
            else:
                low = mid + 1
        
        return right + 1 - low
    
    def merge(self, prefix, left, mid, right):
        """
        合并两个有序数组
        
        Args:
            prefix: 前缀和数组
            left: 左边界
            mid: 中点
            right: 右边界
        """
        temp = [0] * (right - left + 1)
        i, j, k = left, mid + 1, 0
        
        while i <= mid and j <= right:
            if prefix[i] <= prefix[j]:
                temp[k] = prefix[i]
                i += 1
            else:
                temp[k] = prefix[j]
                j += 1
            k += 1
        
        while i <= mid:
            temp[k] = prefix[i]
            i += 1
            k += 1
        
        while j <= right:
            temp[k] = prefix[j]
            j += 1
            k += 1
        
        for i in range(len(temp)):
            prefix[left + i] = temp[i]


# 测试方法
def main():
    solution = Solution()
    
    # 测试用例1
    a1 = [5, -1, 4, -2, 3]
    t1 = 6
    print("测试用例1:")
    print("数组:", a1)
    print("t =", t1)
    print("结果:", solution.count_subarrays(a1, t1))
    print()
    
    # 测试用例2
    a2 = [-1, 2, -3, 4, -5]
    t2 = 0
    print("测试用例2:")
    print("数组:", a2)
    print("t =", t2)
    print("结果:", solution.count_subarrays(a2, t2))
    print()
    
    # 测试用例3
    a3 = [1, 2, 3, 4, 5]
    t3 = 10
    print("测试用例3:")
    print("数组:", a3)
    print("t =", t3)
    print("结果:", solution.count_subarrays(a3, t3))


if __name__ == "__main__":
    main()

===============================================

文件: Codeforces_1681D_RequiredLength.java
===============================================
package class008_AdvancedAlgorithmsAndDataStructures.closest_pair_problems;

import java.util.*;

/**
 * Codeforces 1681D. Required Length
 * 
 * 题目来源：https://codeforces.com/contest/1681/problem/D
 * 
 * 题目描述：
 * 给定一个整数 n 和一个目标长度 k，你需要找到一个 n 位数 x，
 * 使得通过不断将 x 乘以它的某一位数字，最终能得到一个至少 k 位的数。
 * 求最小的操作次数，如果无法达到目标则返回 -1。
 * 
 * 算法思路：
 * 这是一个BFS搜索问题，可以使用以下方法解决：
 * 1. BFS搜索：从初始数字开始，逐步生成新的数字
 * 2. 剪枝优化：避免重复访问相同的数字
 * 3. 最近点对思想：在状态空间中寻找最优路径
 * 
 * 虽然这不是经典的最近点对问题，但可以看作是在状态空间中寻找最短路径的问题，
 * 与最近点对问题有相似的搜索和优化思想。
 * 
 * 时间复杂度：
 * - BFS搜索：O(状态数)
 * - 空间复杂度：O(状态数)
 * 
 * 应用场景：
 * 1. 数学游戏：数字变换游戏
 * 2. 密码学：数字序列生成
 * 3. 算法竞赛：状态搜索问题
 * 
 * 相关题目：
 * 1. LeetCode 973. 最接近原点的 K 个点
 * 2. LeetCode 612. 平面上的最短距离
 * 3. Codeforces 1042D. Petya and Array
 */
public class Codeforces_1681D_RequiredLength {
    
    /**
     * BFS解法
     * 时间复杂度：O(状态数)
     * 空间复杂度：O(状态数)
     * @param n 初始数字
     * @param k 目标长度
     * @return 最小操作次数，如果无法达到目标则返回-1
     */
    public static int requiredLength(long n, int k) {
        // 如果初始数字已经满足长度要求
        if (String.valueOf(n).length() >= k) {
            return 0;
        }
        
        // BFS队列，存储[当前数字, 操作次数]
        Queue<long[]> queue = new LinkedList<>();
        queue.offer(new long[]{n, 0});
        
        // 记录已访问的数字
        Set<Long> visited = new HashSet<>();
        visited.add(n);
        
        while (!queue.isEmpty()) {
            long[] current = queue.poll();
            long num = current[0];
            long steps = current[1];
            
            // 获取数字的每一位
            String numStr = String.valueOf(num);
            for (int i = 0; i < numStr.length(); i++) {
                int digit = numStr.charAt(i) - '0';
                // 跳过0，因为乘以0会得到0
                if (digit == 0) continue;
                
                long newNum = num * digit;
                // 如果新数字满足长度要求
                if (String.valueOf(newNum).length() >= k) {
                    return (int) steps + 1;
                }
                
                // 如果新数字未访问过且长度小于目标长度太多（剪枝）
                if (!visited.contains(newNum) && String.valueOf(newNum).length() < k) {
                    visited.add(newNum);
                    queue.offer(new long[]{newNum, steps + 1});
                }
            }
        }
        
        return -1; // 无法达到目标
    }
    
    /**
     * 优化的BFS解法
     * 时间复杂度：O(状态数)
     * 空间复杂度：O(状态数)
     * @param n 初始数字
     * @param k 目标长度
     * @return 最小操作次数，如果无法达到目标则返回-1
     */
    public static int requiredLengthOptimized(long n, int k) {
        // 如果初始数字已经满足长度要求
        if (String.valueOf(n).length() >= k) {
            return 0;
        }
        
        // BFS队列，存储[当前数字, 操作次数]
        Queue<long[]> queue = new LinkedList<>();
        queue.offer(new long[]{n, 0});
        
        // 记录已访问的数字
        Set<Long> visited = new HashSet<>();
        visited.add(n);
        
        // 目标长度
        int targetLength = k;
        
        while (!queue.isEmpty()) {
            long[] current = queue.poll();
            long num = current[0];
            long steps = current[1];
            
            // 获取数字的每一位
            String numStr = String.valueOf(num);
            // 按数字大小降序排列，优先处理大的数字（贪心策略）
            List<Integer> digits = new ArrayList<>();
            for (int i = 0; i < numStr.length(); i++) {
                digits.add(numStr.charAt(i) - '0');
            }
            Collections.sort(digits, Collections.reverseOrder());
            
            for (int digit : digits) {
                // 跳过0，因为乘以0会得到0
                if (digit == 0) continue;
                
                long newNum = num * digit;
                // 如果新数字满足长度要求
                if (String.valueOf(newNum).length() >= targetLength) {
                    return (int) steps + 1;
                }
                
                // 剪枝：如果新数字长度已经超过目标太多，跳过
                if (String.valueOf(newNum).length() > targetLength + 5) {
                    continue;
                }
                
                // 如果新数字未访问过
                if (!visited.contains(newNum)) {
                    visited.add(newNum);
                    queue.offer(new long[]{newNum, steps + 1});
                }
            }
        }
        
        return -1; // 无法达到目标
    }
    
    /**
     * 测试函数
     */
    public static void main(String[] args) {
        System.out.println("=== 测试 Codeforces 1681D. Required Length ===");
        
        // 测试用例1
        long n1 = 1; 
        int k1 = 3;
        System.out.println("测试用例1:");
        System.out.println("n: " + n1 + ", k: " + k1);
        System.out.println("BFS解法结果: " + requiredLength(n1, k1));
        System.out.println("优化BFS解法结果: " + requiredLengthOptimized(n1, k1));
        System.out.println("期望结果: 3");
        System.out.println();
        
        // 测试用例2
        long n2 = 123;
        int k2 = 5;
        System.out.println("测试用例2:");
        System.out.println("n: " + n2 + ", k: " + k2);
        System.out.println("BFS解法结果: " + requiredLength(n2, k2));
        System.out.println("优化BFS解法结果: " + requiredLengthOptimized(n2, k2));
        System.out.println("期望结果: 2");
        System.out.println();
        
        // 测试用例3
        long n3 = 999;
        int k3 = 2;
        System.out.println("测试用例3:");
        System.out.println("n: " + n3 + ", k: " + k3);
        System.out.println("BFS解法结果: " + requiredLength(n3, k3));
        System.out.println("优化BFS解法结果: " + requiredLengthOptimized(n3, k3));
        System.out.println("期望结果: 0");
        System.out.println();
        
        // 性能测试
        System.out.println("=== 性能测试 ===");
        long n = 5;
        int k = 6;
        
        long startTime = System.nanoTime();
        int result1 = requiredLength(n, k);
        long endTime = System.nanoTime();
        System.out.println("BFS解法计算n=" + n + ",k=" + k + "时间: " + (endTime - startTime) / 1_000_000.0 + " ms, 结果: " + result1);
        
        startTime = System.nanoTime();
        int result2 = requiredLengthOptimized(n, k);
        endTime = System.nanoTime();
        System.out.println("优化BFS解法计算n=" + n + ",k=" + k + "时间: " + (endTime - startTime) / 1_000_000.0 + " ms, 结果: " + result2);
    }
}

===============================================

文件: codeforces_1681d_required_length.cpp
===============================================
#include <iostream>
#include <vector>
#include <queue>
#include <set>
#include <string>
#include <algorithm>
#include <sstream>

using namespace std;

/**
 * Codeforces 1681D. Required Length
 * 
 * 题目来源：https://codeforces.com/contest/1681/problem/D
 * 
 * 题目描述：
 * 给定一个整数 n 和一个目标长度 k，你需要找到一个 n 位数 x，
 * 使得通过不断将 x 乘以它的某一位数字，最终能得到一个至少 k 位的数。
 * 求最小的操作次数，如果无法达到目标则返回 -1。
 * 
 * 算法思路：
 * 这是一个BFS搜索问题，可以使用以下方法解决：
 * 1. BFS搜索：从初始数字开始，逐步生成新的数字
 * 2. 剪枝优化：避免重复访问相同的数字
 * 3. 最近点对思想：在状态空间中寻找最优路径
 * 
 * 虽然这不是经典的最近点对问题，但可以看作是在状态空间中寻找最短路径的问题，
 * 与最近点对问题有相似的搜索和优化思想。
 * 
 * 时间复杂度：
 * - BFS搜索：O(状态数)
 * - 空间复杂度：O(状态数)
 * 
 * 应用场景：
 * 1. 数学游戏：数字变换游戏
 * 2. 密码学：数字序列生成
 * 3. 算法竞赛：状态搜索问题
 * 
 * 相关题目：
 * 1. LeetCode 973. 最接近原点的 K 个点
 * 2. LeetCode 612. 平面上的最短距离
 * 3. Codeforces 1042D. Petya and Array
 */

// 辅助函数：将long long转换为字符串
string longToString(long long n) {
    stringstream ss;
    ss << n;
    return ss.str();
}

/**
 * BFS解法
 * 时间复杂度：O(状态数)
 * 空间复杂度：O(状态数)
 * @param n 初始数字
 * @param k 目标长度
 * @return 最小操作次数，如果无法达到目标则返回-1
 */
int requiredLength(long long n, int k) {
    // 如果初始数字已经满足长度要求
    if (longToString(n).length() >= k) {
        return 0;
    }
    
    // BFS队列，存储[当前数字, 操作次数]
    queue<pair<long long, int> > q;
    q.push(make_pair(n, 0));
    
    // 记录已访问的数字
    set<long long> visited;
    visited.insert(n);
    
    while (!q.empty()) {
        pair<long long, int> current = q.front();
        q.pop();
        
        long long num = current.first;
        int steps = current.second;
        
        // 获取数字的每一位
        string numStr = longToString(num);
        for (int i = 0; i < numStr.length(); i++) {
            int digit = numStr[i] - '0';
            // 跳过0，因为乘以0会得到0
            if (digit == 0) continue;
            
            long long newNum = num * digit;
            // 如果新数字满足长度要求
            if (longToString(newNum).length() >= k) {
                return steps + 1;
            }
            
            // 如果新数字未访问过且长度小于目标长度太多（剪枝）
            if (visited.find(newNum) == visited.end() && longToString(newNum).length() < k) {
                visited.insert(newNum);
                q.push(make_pair(newNum, steps + 1));
            }
        }
    }
    
    return -1; // 无法达到目标
}

/**
 * 优化的BFS解法
 * 时间复杂度：O(状态数)
 * 空间复杂度：O(状态数)
 * @param n 初始数字
 * @param k 目标长度
 * @return 最小操作次数，如果无法达到目标则返回-1
 */
int requiredLengthOptimized(long long n, int k) {
    // 如果初始数字已经满足长度要求
    if (longToString(n).length() >= k) {
        return 0;
    }
    
    // BFS队列，存储[当前数字, 操作次数]
    queue<pair<long long, int> > q;
    q.push(make_pair(n, 0));
    
    // 记录已访问的数字
    set<long long> visited;
    visited.insert(n);
    
    // 目标长度
    int targetLength = k;
    
    while (!q.empty()) {
        pair<long long, int> current = q.front();
        q.pop();
        
        long long num = current.first;
        int steps = current.second;
        
        // 获取数字的每一位
        string numStr = longToString(num);
        // 按数字大小降序排列，优先处理大的数字（贪心策略）
        vector<int> digits;
        for (int i = 0; i < numStr.length(); i++) {
            digits.push_back(numStr[i] - '0');
        }
        sort(digits.begin(), digits.end(), greater<int>());
        
        for (int digit : digits) {
            // 跳过0，因为乘以0会得到0
            if (digit == 0) continue;
            
            long long newNum = num * digit;
            // 如果新数字满足长度要求
            if (longToString(newNum).length() >= targetLength) {
                return steps + 1;
            }
            
            // 剪枝：如果新数字长度已经超过目标太多，跳过
            if (longToString(newNum).length() > targetLength + 5) {
                continue;
            }
            
            // 如果新数字未访问过
            if (visited.find(newNum) == visited.end()) {
                visited.insert(newNum);
                q.push(make_pair(newNum, steps + 1));
            }
        }
    }
    
    return -1; // 无法达到目标
}

/**
 * 测试函数
 */
void testRequiredLength() {
    cout << "=== 测试 Codeforces 1681D. Required Length ===" << endl;
    
    // 测试用例1
    long long n1 = 1; 
    int k1 = 3;
    cout << "测试用例1:" << endl;
    cout << "n: " << n1 << ", k: " << k1 << endl;
    cout << "BFS解法结果: " << requiredLength(n1, k1) << endl;
    cout << "优化BFS解法结果: " << requiredLengthOptimized(n1, k1) << endl;
    cout << "期望结果: 3" << endl;
    cout << endl;
    
    // 测试用例2
    long long n2 = 123;
    int k2 = 5;
    cout << "测试用例2:" << endl;
    cout << "n: " << n2 << ", k: " << k2 << endl;
    cout << "BFS解法结果: " << requiredLength(n2, k2) << endl;
    cout << "优化BFS解法结果: " << requiredLengthOptimized(n2, k2) << endl;
    cout << "期望结果: 2" << endl;
    cout << endl;
    
    // 测试用例3
    long long n3 = 999;
    int k3 = 2;
    cout << "测试用例3:" << endl;
    cout << "n: " << n3 << ", k: " << k3 << endl;
    cout << "BFS解法结果: " << requiredLength(n3, k3) << endl;
    cout << "优化BFS解法结果: " << requiredLengthOptimized(n3, k3) << endl;
    cout << "期望结果: 0" << endl;
    cout << endl;
}

int main() {
    testRequiredLength();
    return 0;
}

===============================================

文件: codeforces_1681d_required_length.py
===============================================
#!/usr/bin/env python3
"""
Codeforces 1681D. Required Length

题目来源：https://codeforces.com/contest/1681/problem/D

题目描述：
给定一个整数 n 和一个目标长度 k，你需要找到一个 n 位数 x，
使得通过不断将 x 乘以它的某一位数字，最终能得到一个至少 k 位的数。
求最小的操作次数，如果无法达到目标则返回 -1。

算法思路：
这是一个BFS搜索问题，可以使用以下方法解决：
1. BFS搜索：从初始数字开始，逐步生成新的数字
2. 剪枝优化：避免重复访问相同的数字
3. 最近点对思想：在状态空间中寻找最优路径

虽然这不是经典的最近点对问题，但可以看作是在状态空间中寻找最短路径的问题，
与最近点对问题有相似的搜索和优化思想。

时间复杂度：
- BFS搜索：O(状态数)
- 空间复杂度：O(状态数)

应用场景：
1. 数学游戏：数字变换游戏
2. 密码学：数字序列生成
3. 算法竞赛：状态搜索问题

相关题目：
1. LeetCode 973. 最接近原点的 K 个点
2. LeetCode 612. 平面上的最短距离
3. Codeforces 1042D. Petya and Array
"""

from collections import deque

def required_length(n, k):
    """
    BFS解法
    时间复杂度：O(状态数)
    空间复杂度：O(状态数)
    :param n: 初始数字
    :param k: 目标长度
    :return: 最小操作次数，如果无法达到目标则返回-1
    """
    # 如果初始数字已经满足长度要求
    if len(str(n)) >= k:
        return 0
    
    # BFS队列，存储(当前数字, 操作次数)
    queue = deque([(n, 0)])
    
    # 记录已访问的数字
    visited = set([n])
    
    while queue:
        num, steps = queue.popleft()
        
        # 获取数字的每一位
        num_str = str(num)
        for digit_char in num_str:
            digit = int(digit_char)
            # 跳过0，因为乘以0会得到0
            if digit == 0:
                continue
            
            new_num = num * digit
            # 如果新数字满足长度要求
            if len(str(new_num)) >= k:
                return steps + 1
            
            # 如果新数字未访问过且长度小于目标长度太多（剪枝）
            if new_num not in visited and len(str(new_num)) < k:
                visited.add(new_num)
                queue.append((new_num, steps + 1))
    
    return -1  # 无法达到目标

def required_length_optimized(n, k):
    """
    优化的BFS解法
    时间复杂度：O(状态数)
    空间复杂度：O(状态数)
    :param n: 初始数字
    :param k: 目标长度
    :return: 最小操作次数，如果无法达到目标则返回-1
    """
    # 如果初始数字已经满足长度要求
    if len(str(n)) >= k:
        return 0
    
    # BFS队列，存储(当前数字, 操作次数)
    queue = deque([(n, 0)])
    
    # 记录已访问的数字
    visited = set([n])
    
    # 目标长度
    target_length = k
    
    while queue:
        num, steps = queue.popleft()
        
        # 获取数字的每一位
        num_str = str(num)
        # 按数字大小降序排列，优先处理大的数字（贪心策略）
        digits = sorted([int(d) for d in num_str], reverse=True)
        
        for digit in digits:
            # 跳过0，因为乘以0会得到0
            if digit == 0:
                continue
            
            new_num = num * digit
            # 如果新数字满足长度要求
            if len(str(new_num)) >= target_length:
                return steps + 1
            
            # 剪枝：如果新数字长度已经超过目标太多，跳过
            if len(str(new_num)) > target_length + 5:
                continue
            
            # 如果新数字未访问过
            if new_num not in visited:
                visited.add(new_num)
                queue.append((new_num, steps + 1))
    
    return -1  # 无法达到目标

def test_required_length():
    """测试函数"""
    print("=== 测试 Codeforces 1681D. Required Length ===")
    
    # 测试用例1
    n1, k1 = 1, 3
    print("测试用例1:")
    print(f"n: {n1}, k: {k1}")
    print(f"BFS解法结果: {required_length(n1, k1)}")
    print(f"优化BFS解法结果: {required_length_optimized(n1, k1)}")
    print("期望结果: 3")
    print()
    
    # 测试用例2
    n2, k2 = 123, 5
    print("测试用例2:")
    print(f"n: {n2}, k: {k2}")
    print(f"BFS解法结果: {required_length(n2, k2)}")
    print(f"优化BFS解法结果: {required_length_optimized(n2, k2)}")
    print("期望结果: 2")
    print()
    
    # 测试用例3
    n3, k3 = 999, 2
    print("测试用例3:")
    print(f"n: {n3}, k: {k3}")
    print(f"BFS解法结果: {required_length(n3, k3)}")
    print(f"优化BFS解法结果: {required_length_optimized(n3, k3)}")
    print("期望结果: 0")
    print()

if __name__ == "__main__":
    test_required_length()

===============================================

文件: Codeforces_612D_TheUnionOfKSegments.java
===============================================
package class185.sweep_line_problems;

import java.util.*;

/**
 * Codeforces 612D. The Union of k-Segments
 * 
 * 题目来源：https://codeforces.com/problemset/problem/612/D
 * 
 * 题目描述：
 * 给定n条线段和一个整数k，求被至少k条线段覆盖的区间的并集。
 * 
 * 输入格式：
 * 第一行包含两个整数n和k(1 ≤ n ≤ 10^6, 1 ≤ k ≤ n)。
 * 接下来n行，每行包含两个整数li和ri(-10^9 ≤ li ≤ ri ≤ 10^9)，表示第i条线段的左右端点。
 * 
 * 输出格式：
 * 第一行输出一个整数m，表示结果区间的数量。
 * 接下来m行，每行输出两个整数aj和bj，表示结果区间。
 * 
 * 示例输入：
 * 3 2
 * 0 5
 * -3 2
 * 3 8
 * 
 * 示例输出：
 * 2
 * -3 2
 * 3 5
 * 
 * 解题思路：
 * 使用扫描线算法解决线段覆盖问题。核心思想是：
 * 1. 将每个线段的左右端点转换为事件点
 * 2. 对所有事件点按位置排序
 * 3. 扫描所有事件点，维护当前覆盖的线段数量
 * 4. 当覆盖数量从<k变为≥k时开始新区间，从≥k变为<k时结束区间
 * 
 * 时间复杂度：O(n log n)，其中 n 是线段的数量
 * 空间复杂度：O(n)
 * 
 * 相关题目：
 * - LeetCode 56. 合并区间
 * - LeetCode 253. 会议室II
 */
public class Codeforces_612D_TheUnionOfKSegments {
    
    /**
     * 线段覆盖问题的扫描线解法
     * @param segments 线段数组，每个线段是 [left, right] 形式
     * @param k 覆盖线段的最小数量
     * @return 被至少k条线段覆盖的区间列表
     */
    public static List<int[]> unionOfKSegments(int[][] segments, int k) {
        if (segments == null || segments.length == 0 || k <= 0) {
            return new ArrayList<>();
        }
        
        // 创建事件点列表：[位置, 类型]
        // 类型：0表示线段开始，1表示线段结束
        List<int[]> events = new ArrayList<>();
        
        // 为每个线段创建开始和结束事件
        for (int[] segment : segments) {
            events.add(new int[]{segment[0], 0});  // 开始事件
            events.add(new int[]{segment[1], 1});  // 结束事件
        }
        
        // 按照位置排序事件点
        // 如果位置相同，结束事件优先于开始事件
        events.sort((a, b) -> {
            if (a[0] != b[0]) {
                return Integer.compare(a[0], b[0]);
            }
            return Integer.compare(b[1], a[1]);
        });
        
        List<int[]> result = new ArrayList<>();
        int coverageCount = 0;
        int start = 0;
        
        // 扫描所有事件点
        for (int[] event : events) {
            int position = event[0];
            int type = event[1];
            
            if (type == 0) {
                // 线段开始事件
                coverageCount++;
                if (coverageCount == k) {
                    // 开始新区间
                    start = position;
                }
            } else {
                // 线段结束事件
                if (coverageCount == k) {
                    // 结束区间
                    result.add(new int[]{start, position});
                }
                coverageCount--;
            }
        }
        
        return result;
    }
    
    /**
     * 测试线段覆盖问题解法
     */
    public static void main(String[] args) {
        System.out.println("=== Codeforces 612D. The Union of k-Segments ===");
        
        // 测试用例1
        System.out.println("测试用例1:");
        int[][] segments1 = {
            {0, 5}, {-3, 2}, {3, 8}
        };
        int k1 = 2;
        List<int[]> result1 = unionOfKSegments(segments1, k1);
        System.out.println("输入线段: " + Arrays.deepToString(segments1));
        System.out.println("k = " + k1);
        System.out.println("输出区间数量: " + result1.size());
        System.out.print("输出区间: ");
        for (int[] interval : result1) {
            System.out.print("[" + interval[0] + "," + interval[1] + "] ");
        }
        System.out.println();
        System.out.println("期望: 2个区间，[-3,2] [3,5]");
        System.out.println();
        
        // 测试用例2
        System.out.println("测试用例2:");
        int[][] segments2 = {
            {0, 10}, {5, 15}, {10, 20}
        };
        int k2 = 3;
        List<int[]> result2 = unionOfKSegments(segments2, k2);
        System.out.println("输入线段: " + Arrays.deepToString(segments2));
        System.out.println("k = " + k2);
        System.out.println("输出区间数量: " + result2.size());
        System.out.print("输出区间: ");
        for (int[] interval : result2) {
            System.out.print("[" + interval[0] + "," + interval[1] + "] ");
        }
        System.out.println();
        System.out.println("期望: 1个区间，[10,10]");
        System.out.println();
        
        // 性能测试
        System.out.println("=== 性能测试 ===");
        Random random = new Random(42);
        int n = 100000;
        int[][] segments = new int[n][2];
        
        for (int i = 0; i < n; i++) {
            int left = random.nextInt(2000000) - 1000000;
            int right = left + random.nextInt(10000) + 1;
            segments[i][0] = left;
            segments[i][1] = right;
        }
        
        int k = 50000;
        
        long startTime = System.nanoTime();
        List<int[]> result = unionOfKSegments(segments, k);
        long endTime = System.nanoTime();
        
        System.out.println("100000个随机线段，k=50000的覆盖计算完成");
        System.out.println("覆盖区间数量: " + result.size());
        System.out.println("运行时间: " + (endTime - startTime) / 1_000_000.0 + " ms");
    }
}

===============================================

文件: codeforces_612d_the_union_of_k_segments.cpp
===============================================
#include <iostream>
#include <vector>
#include <algorithm>
#include <random>
#include <chrono>

using namespace std;

/**
 * Codeforces 612D. The Union of k-Segments
 * 
 * 题目来源：https://codeforces.com/problemset/problem/612/D
 * 
 * 题目描述：
 * 给定n条线段和一个整数k，求被至少k条线段覆盖的区间的并集。
 * 
 * 输入格式：
 * 第一行包含两个整数n和k(1 ≤ n ≤ 10^6, 1 ≤ k ≤ n)。
 * 接下来n行，每行包含两个整数li和ri(-10^9 ≤ li ≤ ri ≤ 10^9)，表示第i条线段的左右端点。
 * 
 * 输出格式：
 * 第一行输出一个整数m，表示结果区间的数量。
 * 接下来m行，每行输出两个整数aj和bj，表示结果区间。
 * 
 * 示例输入：
 * 3 2
 * 0 5
 * -3 2
 * 3 8
 * 
 * 示例输出：
 * 2
 * -3 2
 * 3 5
 * 
 * 解题思路：
 * 使用扫描线算法解决线段覆盖问题。核心思想是：
 * 1. 将每个线段的左右端点转换为事件点
 * 2. 对所有事件点按位置排序
 * 3. 扫描所有事件点，维护当前覆盖的线段数量
 * 4. 当覆盖数量从<k变为≥k时开始新区间，从≥k变为<k时结束区间
 * 
 * 时间复杂度：O(n log n)，其中 n 是线段的数量
 * 空间复杂度：O(n)
 * 
 * 相关题目：
 * - LeetCode 56. 合并区间
 * - LeetCode 253. 会议室II
 */

class Solution {
public:
    /**
     * 线段覆盖问题的扫描线解法
     * @param segments 线段数组，每个线段是 [left, right] 形式
     * @param k 覆盖线段的最小数量
     * @return 被至少k条线段覆盖的区间列表
     */
    static vector<vector<int>> unionOfKSegments(vector<vector<int>>& segments, int k) {
        if (segments.empty() || k <= 0) {
            return {};
        }
        
        // 创建事件点列表：[位置, 类型]
        // 类型：0表示线段开始，1表示线段结束
        vector<pair<int, int>> events;
        
        // 为每个线段创建开始和结束事件
        for (const auto& segment : segments) {
            events.emplace_back(segment[0], 0);  // 开始事件
            events.emplace_back(segment[1], 1);  // 结束事件
        }
        
        // 按照位置排序事件点
        // 如果位置相同，结束事件优先于开始事件
        sort(events.begin(), events.end(), [](const pair<int, int>& a, const pair<int, int>& b) {
            if (a.first != b.first) {
                return a.first < b.first;
            }
            return a.second > b.second;
        });
        
        vector<vector<int>> result;
        int coverageCount = 0;
        int start = 0;
        
        // 扫描所有事件点
        for (const auto& event : events) {
            int position = event.first;
            int type = event.second;
            
            if (type == 0) {
                // 线段开始事件
                coverageCount++;
                if (coverageCount == k) {
                    // 开始新区间
                    start = position;
                }
            } else {
                // 线段结束事件
                if (coverageCount == k) {
                    // 结束区间
                    result.push_back({start, position});
                }
                coverageCount--;
            }
        }
        
        return result;
    }
};

/**
 * 测试线段覆盖问题解法
 */
void testUnionOfKSegments() {
    cout << "=== Codeforces 612D. The Union of k-Segments ===" << endl;
    
    // 测试用例1
    cout << "测试用例1:" << endl;
    vector<vector<int>> segments1 = {
        {0, 5}, {-3, 2}, {3, 8}
    };
    int k1 = 2;
    vector<vector<int>> result1 = Solution::unionOfKSegments(segments1, k1);
    cout << "输入线段: ";
    for (const auto& segment : segments1) {
        cout << "[" << segment[0] << "," << segment[1] << "] ";
    }
    cout << endl;
    cout << "k = " << k1 << endl;
    cout << "输出区间数量: " << result1.size() << endl;
    cout << "输出区间: ";
    for (const auto& interval : result1) {
        cout << "[" << interval[0] << "," << interval[1] << "] ";
    }
    cout << endl;
    cout << "期望: 2个区间，[-3,2] [3,5]" << endl;
    cout << endl;
    
    // 测试用例2
    cout << "测试用例2:" << endl;
    vector<vector<int>> segments2 = {
        {0, 10}, {5, 15}, {10, 20}
    };
    int k2 = 3;
    vector<vector<int>> result2 = Solution::unionOfKSegments(segments2, k2);
    cout << "输入线段: ";
    for (const auto& segment : segments2) {
        cout << "[" << segment[0] << "," << segment[1] << "] ";
    }
    cout << endl;
    cout << "k = " << k2 << endl;
    cout << "输出区间数量: " << result2.size() << endl;
    cout << "输出区间: ";
    for (const auto& interval : result2) {
        cout << "[" << interval[0] << "," << interval[1] << "] ";
    }
    cout << endl;
    cout << "期望: 1个区间，[10,10]" << endl;
    cout << endl;
    
    // 性能测试
    cout << "=== 性能测试 ===" << endl;
    random_device rd;
    mt19937 gen(rd());
    uniform_int_distribution<int> dis(-1000000, 1000000);
    uniform_int_distribution<int> dis2(1, 10000);
    
    int n = 100000;
    vector<vector<int>> segments;
    
    for (int i = 0; i < n; i++) {
        int left = dis(gen);
        int right = left + dis2(gen);
        segments.push_back({left, right});
    }
    
    int k = 50000;
    
    auto startTime = chrono::high_resolution_clock::now();
    vector<vector<int>> result = Solution::unionOfKSegments(segments, k);
    auto endTime = chrono::high_resolution_clock::now();
    
    auto duration = chrono::duration_cast<chrono::microseconds>(endTime - startTime);
    
    cout << "100000个随机线段，k=50000的覆盖计算完成" << endl;
    cout << "覆盖区间数量: " << result.size() << endl;
    cout << "运行时间: " << duration.count() / 1000.0 << " ms" << endl;
}

int main() {
    testUnionOfKSegments();
    return 0;
}

===============================================

文件: codeforces_612d_the_union_of_k_segments.py
===============================================
#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
Codeforces 612D. The Union of k-Segments

题目来源：https://codeforces.com/problemset/problem/612/D

题目描述：
给定n条线段和一个整数k，求被至少k条线段覆盖的区间的并集。

输入格式：
第一行包含两个整数n和k(1 ≤ n ≤ 10^6, 1 ≤ k ≤ n)。
接下来n行，每行包含两个整数li和ri(-10^9 ≤ li ≤ ri ≤ 10^9)，表示第i条线段的左右端点。

输出格式：
第一行输出一个整数m，表示结果区间的数量。
接下来m行，每行输出两个整数aj和bj，表示结果区间。

示例输入：
3 2
0 5
-3 2
3 8

示例输出：
2
-3 2
3 5

解题思路：
使用扫描线算法解决线段覆盖问题。核心思想是：
1. 将每个线段的左右端点转换为事件点
2. 对所有事件点按位置排序
3. 扫描所有事件点，维护当前覆盖的线段数量
4. 当覆盖数量从<k变为≥k时开始新区间，从≥k变为<k时结束区间

时间复杂度：O(n log n)，其中 n 是线段的数量
空间复杂度：O(n)

相关题目：
- LeetCode 56. 合并区间
- LeetCode 253. 会议室II
"""

import random
import time

class Solution:
    @staticmethod
    def union_of_k_segments(segments, k):
        """
        线段覆盖问题的扫描线解法
        :param segments: 线段数组，每个线段是 [left, right] 形式
        :param k: 覆盖线段的最小数量
        :return: 被至少k条线段覆盖的区间列表
        """
        if not segments or k <= 0:
            return []
        
        # 创建事件点列表：[位置, 类型]
        # 类型：0表示线段开始，1表示线段结束
        events = []
        
        # 为每个线段创建开始和结束事件
        for left, right in segments:
            events.append([left, 0])   # 开始事件
            events.append([right, 1])  # 结束事件
        
        # 按照位置排序事件点
        # 如果位置相同，结束事件优先于开始事件
        events.sort(key=lambda x: (x[0], -x[1]))
        
        result = []
        coverage_count = 0
        start = 0
        
        # 扫描所有事件点
        for position, event_type in events:
            if event_type == 0:
                # 线段开始事件
                coverage_count += 1
                if coverage_count == k:
                    # 开始新区间
                    start = position
            else:
                # 线段结束事件
                if coverage_count == k:
                    # 结束区间
                    result.append([start, position])
                coverage_count -= 1
        
        return result
    
    @staticmethod
    def test_union_of_k_segments():
        """测试线段覆盖问题解法"""
        print("=== Codeforces 612D. The Union of k-Segments ===")
        
        # 测试用例1
        print("测试用例1:")
        segments1 = [
            [0, 5], [-3, 2], [3, 8]
        ]
        k1 = 2
        result1 = Solution.union_of_k_segments(segments1, k1)
        print(f"输入线段: {segments1}")
        print(f"k = {k1}")
        print(f"输出区间数量: {len(result1)}")
        print("输出区间: ", end="")
        for interval in result1:
            print(f"[{interval[0]},{interval[1]}] ", end="")
        print()
        print("期望: 2个区间，[-3,2] [3,5]")
        print()
        
        # 测试用例2
        print("测试用例2:")
        segments2 = [
            [0, 10], [5, 15], [10, 20]
        ]
        k2 = 3
        result2 = Solution.union_of_k_segments(segments2, k2)
        print(f"输入线段: {segments2}")
        print(f"k = {k2}")
        print(f"输出区间数量: {len(result2)}")
        print("输出区间: ", end="")
        for interval in result2:
            print(f"[{interval[0]},{interval[1]}] ", end="")
        print()
        print("期望: 1个区间，[10,10]")
        print()
        
        # 性能测试
        print("=== 性能测试 ===")
        random.seed(42)
        n = 100000
        segments = []
        
        for _ in range(n):
            left = random.randint(-1000000, 1000000)
            right = left + random.randint(1, 10000)
            segments.append([left, right])
        
        k = 50000
        
        start_time = time.time()
        result = Solution.union_of_k_segments(segments, k)
        end_time = time.time()
        
        print(f"100000个随机线段，k=50000的覆盖计算完成")
        print(f"覆盖区间数量: {len(result)}")
        print(f"运行时间: {(end_time - start_time) * 1000:.2f} ms")

if __name__ == "__main__":
    Solution.test_union_of_k_segments()

===============================================

文件: DifferenceArray.java
===============================================
package class185.difference_array_problems;

import java.util.*;

/**
 * 差分数组实现 (Java版本)
 * 
 * 算法思路：
 * 差分数组是一种用于高效处理区间更新操作的数据结构。
 * 通过维护原数组的差分数组，可以将区间更新操作的时间复杂度从O(n)降低到O(1)。
 * 
 * 应用场景：
 * 1. 数组操作优化：批量更新处理
 * 2. 前缀和计算：快速计算区间和
 * 3. 算法竞赛：区间操作问题的优化
 * 
 * 时间复杂度：
 * - 区间更新：O(1)
 * - 获取结果数组：O(n)
 * - 单点查询：O(n)（需要重建数组）
 * 空间复杂度：O(n)
 * 
 * 相关题目：
 * 1. LeetCode 370. 区间加法
 * 2. LeetCode 1094. 拼车
 * 3. LeetCode 1109. 航班预订统计
 */
public class DifferenceArray {
    private int[] diff;  // 差分数组
    private int size;    // 数组大小
    private int[] original; // 原始数组（用于重置操作）
    
    /**
     * 构造函数 - 从大小创建
     * @param size 数组大小
     */
    public DifferenceArray(int size) {
        if (size <= 0) {
            throw new IllegalArgumentException("数组大小必须为正整数");
        }
        
        this.size = size;
        this.diff = new int[size + 1];  // 差分数组大小为n+1，便于处理边界
        this.original = new int[size];
    }
    
    /**
     * 构造函数 - 从原始数组创建
     * @param originalArray 原始数组
     */
    public DifferenceArray(int[] originalArray) {
        if (originalArray == null || originalArray.length == 0) {
            throw new IllegalArgumentException("输入数组不能为空");
        }
        
        this.size = originalArray.length;
        this.original = originalArray.clone();
        this.diff = new int[size + 1];
        
        // 初始化差分数组
        diff[0] = originalArray[0];
        for (int i = 1; i < size; i++) {
            diff[i] = originalArray[i] - originalArray[i - 1];
        }
    }
    
    /**
     * 区间更新：将区间[start, end]的每个元素加上val
     * 时间复杂度：O(1)
     * @param start 起始索引（包含）
     * @param end 结束索引（包含）
     * @param val 要增加的值
     */
    public void rangeUpdate(int start, int end, int val) {
        if (start < 0 || end >= size || start > end) {
            throw new IllegalArgumentException("更新范围无效");
        }
        
        diff[start] += val;
        diff[end + 1] -= val;
    }
    
    /**
     * 获取更新后的数组
     * 时间复杂度：O(n)
     * @return 更新后的数组
     */
    public int[] getResult() {
        int[] result = new int[size];
        result[0] = diff[0];
        
        for (int i = 1; i < size; i++) {
            result[i] = result[i - 1] + diff[i];
        }
        
        return result;
    }
    
    /**
     * 直接获取数组中特定位置的值
     * 注意：这需要先重建数组，时间复杂度O(n)
     * @param index 索引位置
     * @return 该位置的值
     */
    public int getValue(int index) {
        if (index < 0 || index >= size) {
            throw new IllegalArgumentException("索引无效");
        }
        
        int[] result = getResult();
        return result[index];
    }
    
    /**
     * 重置差分数组
     */
    public void reset() {
        Arrays.fill(diff, 0);
        if (original != null) {
            diff[0] = original[0];
            for (int i = 1; i < size; i++) {
                diff[i] = original[i] - original[i - 1];
            }
        }
    }
    
    /**
     * 获取数组大小
     * @return 数组大小
     */
    public int getSize() {
        return size;
    }
    
    /**
     * 测试差分数组
     */
    public static void main(String[] args) {
        System.out.println("=== 测试差分数组 ===");
        
        // 测试从大小创建
        System.out.println("测试从大小创建:");
        DifferenceArray da1 = new DifferenceArray(5);
        System.out.println("初始数组: " + Arrays.toString(da1.getResult()));
        
        da1.rangeUpdate(0, 2, 1);
        System.out.println("区间[0,2]加1: " + Arrays.toString(da1.getResult()));
        
        da1.rangeUpdate(1, 4, 2);
        System.out.println("区间[1,4]加2: " + Arrays.toString(da1.getResult()));
        
        da1.rangeUpdate(2, 3, -1);
        System.out.println("区间[2,3]减1: " + Arrays.toString(da1.getResult()));
        
        // 测试从原始数组创建
        System.out.println("\n测试从原始数组创建:");
        int[] original = {1, 2, 3, 4, 5};
        DifferenceArray da2 = new DifferenceArray(original);
        System.out.println("原始数组: " + Arrays.toString(da2.getResult()));
        
        da2.rangeUpdate(1, 3, 10);
        System.out.println("区间[1,3]加10: " + Arrays.toString(da2.getResult()));
        
        da2.rangeUpdate(0, 4, -5);
        System.out.println("区间[0,4]减5: " + Arrays.toString(da2.getResult()));
        
        // 测试重置功能
        da2.reset();
        System.out.println("重置后: " + Arrays.toString(da2.getResult()));
        
        // 测试边界情况
        System.out.println("\n测试边界情况:");
        DifferenceArray da3 = new DifferenceArray(1);
        da3.rangeUpdate(0, 0, 100);
        System.out.println("单元素数组更新: " + Arrays.toString(da3.getResult()));
        
        // 性能测试
        System.out.println("\n=== 性能测试 ===");
        
        // 测试大量区间更新操作
        int n = 100000;
        DifferenceArray da4 = new DifferenceArray(n);
        
        long startTime = System.nanoTime();
        for (int i = 0; i < 10000; i++) {
            int start = i % (n - 100);
            int end = Math.min(start + 100, n - 1);
            da4.rangeUpdate(start, end, 1);
        }
        long updateTime = System.nanoTime() - startTime;
        
        // 获取结果数组
        startTime = System.nanoTime();
        int[] result = da4.getResult();
        long getResultTime = System.nanoTime() - startTime;
        
        System.out.println("执行10000次区间更新时间: " + updateTime / 1_000_000.0 + " ms");
        System.out.println("获取100000元素结果数组时间: " + getResultTime / 1_000_000.0 + " ms");
        System.out.println("结果数组前10个元素: " + Arrays.toString(Arrays.copyOf(result, 10)));
    }
}

===============================================

文件: difference_array.cpp
===============================================
#include <iostream>
#include <vector>
#include <algorithm>
#include <chrono>
#include <random>

using namespace std;

/**
 * 差分数组实现 (C++版本)
 * 
 * 算法思路：
 * 差分数组是一种用于高效处理区间更新操作的数据结构。
 * 通过维护原数组的差分数组，可以将区间更新操作的时间复杂度从O(n)降低到O(1)。
 * 
 * 应用场景：
 * 1. 数组操作优化：批量更新处理
 * 2. 前缀和计算：快速计算区间和
 * 3. 算法竞赛：区间操作问题的优化
 * 
 * 时间复杂度：
 * - 区间更新：O(1)
 * - 获取结果数组：O(n)
 * - 单点查询：O(n)（需要重建数组）
 * 空间复杂度：O(n)
 * 
 * 相关题目：
 * 1. LeetCode 370. 区间加法
 * 2. LeetCode 1094. 拼车
 * 3. LeetCode 1109. 航班预订统计
 */

class DifferenceArray {
private:
    vector<int> diff;     // 差分数组
    int size;             // 数组大小
    vector<int> original; // 原始数组（用于重置操作）
    
public:
    /**
     * 构造函数 - 从大小创建
     * @param size 数组大小
     */
    DifferenceArray(int size) {
        if (size <= 0) {
            throw invalid_argument("数组大小必须为正整数");
        }
        
        this->size = size;
        this->diff.assign(size + 1, 0);  // 差分数组大小为n+1，便于处理边界
        this->original.assign(size, 0);
    }
    
    /**
     * 构造函数 - 从原始数组创建
     * @param originalArray 原始数组
     */
    DifferenceArray(const vector<int>& originalArray) {
        if (originalArray.empty()) {
            throw invalid_argument("输入数组不能为空");
        }
        
        this->size = originalArray.size();
        this->original = originalArray;
        this->diff.assign(size + 1, 0);
        
        // 初始化差分数组
        diff[0] = originalArray[0];
        for (int i = 1; i < size; i++) {
            diff[i] = originalArray[i] - originalArray[i - 1];
        }
    }
    
    /**
     * 区间更新：将区间[start, end]的每个元素加上val
     * 时间复杂度：O(1)
     * @param start 起始索引（包含）
     * @param end 结束索引（包含）
     * @param val 要增加的值
     */
    void rangeUpdate(int start, int end, int val) {
        if (start < 0 || end >= size || start > end) {
            throw invalid_argument("更新范围无效");
        }
        
        diff[start] += val;
        diff[end + 1] -= val;
    }
    
    /**
     * 获取更新后的数组
     * 时间复杂度：O(n)
     * @return 更新后的数组
     */
    vector<int> getResult() {
        vector<int> result(size);
        result[0] = diff[0];
        
        for (int i = 1; i < size; i++) {
            result[i] = result[i - 1] + diff[i];
        }
        
        return result;
    }
    
    /**
     * 直接获取数组中特定位置的值
     * 注意：这需要先重建数组，时间复杂度O(n)
     * @param index 索引位置
     * @return 该位置的值
     */
    int getValue(int index) {
        if (index < 0 || index >= size) {
            throw invalid_argument("索引无效");
        }
        
        vector<int> result = getResult();
        return result[index];
    }
    
    /**
     * 重置差分数组
     */
    void reset() {
        fill(diff.begin(), diff.end(), 0);
        if (!original.empty()) {
            diff[0] = original[0];
            for (int i = 1; i < size; i++) {
                diff[i] = original[i] - original[i - 1];
            }
        }
    }
    
    /**
     * 获取数组大小
     * @return 数组大小
     */
    int getSize() const {
        return size;
    }
};

/**
 * 测试差分数组
 */
void testDifferenceArray() {
    cout << "=== 测试差分数组 ===" << endl;
    
    // 测试从大小创建
    cout << "测试从大小创建:" << endl;
    DifferenceArray da1(5);
    vector<int> result1 = da1.getResult();
    cout << "初始数组: ";
    for (int val : result1) cout << val << " ";
    cout << endl;
    
    da1.rangeUpdate(0, 2, 1);
    vector<int> result2 = da1.getResult();
    cout << "区间[0,2]加1: ";
    for (int val : result2) cout << val << " ";
    cout << endl;
    
    da1.rangeUpdate(1, 4, 2);
    vector<int> result3 = da1.getResult();
    cout << "区间[1,4]加2: ";
    for (int val : result3) cout << val << " ";
    cout << endl;
    
    da1.rangeUpdate(2, 3, -1);
    vector<int> result4 = da1.getResult();
    cout << "区间[2,3]减1: ";
    for (int val : result4) cout << val << " ";
    cout << endl;
    
    // 测试从原始数组创建
    cout << "\n测试从原始数组创建:" << endl;
    vector<int> original = {1, 2, 3, 4, 5};
    DifferenceArray da2(original);
    vector<int> result5 = da2.getResult();
    cout << "原始数组: ";
    for (int val : result5) cout << val << " ";
    cout << endl;
    
    da2.rangeUpdate(1, 3, 10);
    vector<int> result6 = da2.getResult();
    cout << "区间[1,3]加10: ";
    for (int val : result6) cout << val << " ";
    cout << endl;
    
    da2.rangeUpdate(0, 4, -5);
    vector<int> result7 = da2.getResult();
    cout << "区间[0,4]减5: ";
    for (int val : result7) cout << val << " ";
    cout << endl;
    
    // 测试重置功能
    da2.reset();
    vector<int> result8 = da2.getResult();
    cout << "重置后: ";
    for (int val : result8) cout << val << " ";
    cout << endl;
    
    // 测试边界情况
    cout << "\n测试边界情况:" << endl;
    DifferenceArray da3(1);
    da3.rangeUpdate(0, 0, 100);
    vector<int> result9 = da3.getResult();
    cout << "单元素数组更新: ";
    for (int val : result9) cout << val << " ";
    cout << endl;
    
    // 性能测试
    cout << "\n=== 性能测试 ===" << endl;
    
    // 测试大量区间更新操作
    int n = 100000;
    DifferenceArray da4(n);
    
    auto startTime = chrono::high_resolution_clock::now();
    for (int i = 0; i < 10000; i++) {
        int start = i % (n - 100);
        int end = min(start + 100, n - 1);
        da4.rangeUpdate(start, end, 1);
    }
    auto endTime = chrono::high_resolution_clock::now();
    
    auto updateTime = chrono::duration_cast<chrono::microseconds>(endTime - startTime);
    
    // 获取结果数组
    startTime = chrono::high_resolution_clock::now();
    vector<int> result = da4.getResult();
    endTime = chrono::high_resolution_clock::now();
    
    auto getResultTime = chrono::duration_cast<chrono::microseconds>(endTime - startTime);
    
    cout << "执行10000次区间更新时间: " << updateTime.count() / 1000.0 << " ms" << endl;
    cout << "获取100000元素结果数组时间: " << getResultTime.count() / 1000.0 << " ms" << endl;
    cout << "结果数组前10个元素: ";
    for (int i = 0; i < 10; i++) {
        cout << result[i] << " ";
    }
    cout << endl;
}

int main() {
    testDifferenceArray();
    return 0;
}

===============================================

文件: difference_array.py
===============================================
#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
差分数组实现 (Python版本)

算法思路：
差分数组是一种用于高效处理区间更新操作的数据结构。
通过维护原数组的差分数组，可以将区间更新操作的时间复杂度从O(n)降低到O(1)。

应用场景：
1. 数组操作优化：批量更新处理
2. 前缀和计算：快速计算区间和
3. 算法竞赛：区间操作问题的优化

时间复杂度：
- 区间更新：O(1)
- 获取结果数组：O(n)
- 单点查询：O(n)（需要重建数组）
空间复杂度：O(n)
"""

class DifferenceArray:
    """差分数组实现类"""
    
    def __init__(self, size_or_array):
        """
        构造函数
        :param size_or_array: 数组大小或原始数组
        """
        if isinstance(size_or_array, int):
            # 从大小创建
            if size_or_array <= 0:
                raise ValueError("数组大小必须为正整数")
            
            self.size = size_or_array
            self.diff = [0] * (size_or_array + 1)  # 差分数组大小为n+1，便于处理边界
            self.original = [0] * size_or_array
        else:
            # 从原始数组创建
            if not size_or_array:
                raise ValueError("输入数组不能为空")
            
            self.size = len(size_or_array)
            self.original = size_or_array[:]
            self.diff = [0] * (self.size + 1)
            
            # 初始化差分数组
            self.diff[0] = size_or_array[0]
            for i in range(1, self.size):
                self.diff[i] = size_or_array[i] - size_or_array[i - 1]
    
    def range_update(self, start, end, val):
        """
        区间更新：将区间[start, end]的每个元素加上val
        时间复杂度：O(1)
        :param start: 起始索引（包含）
        :param end: 结束索引（包含）
        :param val: 要增加的值
        """
        if start < 0 or end >= self.size or start > end:
            raise ValueError("更新范围无效")
        
        self.diff[start] += val
        self.diff[end + 1] -= val
    
    def get_result(self):
        """
        获取更新后的数组
        时间复杂度：O(n)
        :return: 更新后的数组
        """
        result = [0] * self.size
        result[0] = self.diff[0]
        
        for i in range(1, self.size):
            result[i] = result[i - 1] + self.diff[i]
        
        return result
    
    def get_value(self, index):
        """
        直接获取数组中特定位置的值
        注意：这需要先重建数组，时间复杂度O(n)
        :param index: 索引位置
        :return: 该位置的值
        """
        if index < 0 or index >= self.size:
            raise ValueError("索引无效")
        
        result = self.get_result()
        return result[index]
    
    def reset(self):
        """重置差分数组"""
        self.diff = [0] * (self.size + 1)
        if self.original:
            for i in range(self.size):
                self.range_update(i, i, self.original[i])
    
    @staticmethod
    def test_difference_array():
        """测试差分数组"""
        print("=== 测试差分数组 ===")
        
        # 测试从大小创建
        print("测试从大小创建:")
        da1 = DifferenceArray(5)
        print("初始数组:", da1.get_result())
        
        da1.range_update(0, 2, 1)
        print("区间[0,2]加1:", da1.get_result())
        
        da1.range_update(1, 4, 2)
        print("区间[1,4]加2:", da1.get_result())
        
        da1.range_update(2, 3, -1)
        print("区间[2,3]减1:", da1.get_result())
        
        # 测试从原始数组创建
        print("\n测试从原始数组创建:")
        original = [1, 2, 3, 4, 5]
        da2 = DifferenceArray(original)
        print("原始数组:", da2.get_result())
        
        da2.range_update(1, 3, 10)
        print("区间[1,3]加10:", da2.get_result())
        
        da2.range_update(0, 4, -5)
        print("区间[0,4]减5:", da2.get_result())
        
        # 测试重置功能
        da2.reset()
        print("重置后:", da2.get_result())
        
        # 测试边界情况
        print("\n测试边界情况:")
        da3 = DifferenceArray(1)
        da3.range_update(0, 0, 100)
        print("单元素数组更新:", da3.get_result())
        
        # 性能测试
        print("\n=== 性能测试 ===")
        import time
        
        # 测试大量区间更新操作
        n = 100000
        da4 = DifferenceArray(n)
        
        # 执行大量区间更新
        start_time = time.time()
        for i in range(10000):
            start = i % (n - 100)
            end = start + 100
            da4.range_update(start, end, 1)
        update_time = time.time() - start_time
        
        # 获取结果数组
        start_time = time.time()
        result = da4.get_result()
        get_result_time = time.time() - start_time
        
        print(f"执行10000次区间更新时间: {update_time*1000:.2f} ms")
        print(f"获取100000元素结果数组时间: {get_result_time*1000:.2f} ms")
        print(f"结果数组前10个元素: {result[:10]}")

if __name__ == "__main__":
    DifferenceArray.test_difference_array()

===============================================

文件: difference_array_1.py
===============================================
#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
差分数组实现 (Python版本)

算法思路：
差分数组是一种用于高效处理区间更新操作的数据结构。
通过维护原数组的差分数组，可以将区间更新操作的时间复杂度从O(n)降低到O(1)。

应用场景：
1. 数组操作优化：批量更新处理
2. 前缀和计算：快速计算区间和
3. 算法竞赛：区间操作问题的优化

时间复杂度：
- 区间更新：O(1)
- 获取结果数组：O(n)
- 单点查询：O(n)（需要重建数组）
空间复杂度：O(n)

相关题目：
1. LeetCode 370. 区间加法
2. LeetCode 1094. 拼车
3. LeetCode 1109. 航班预订统计
"""

import time
import random

class DifferenceArray:
    """差分数组实现类"""
    
    def __init__(self, size_or_array):
        """
        构造函数
        :param size_or_array: 数组大小或原始数组
        """
        if isinstance(size_or_array, int):
            # 从大小创建
            if size_or_array <= 0:
                raise ValueError("数组大小必须为正整数")
            
            self.size = size_or_array
            self.diff = [0] * (size_or_array + 1)  # 差分数组大小为n+1，便于处理边界
            self.original = [0] * size_or_array
        else:
            # 从原始数组创建
            if not size_or_array:
                raise ValueError("输入数组不能为空")
            
            self.size = len(size_or_array)
            self.original = size_or_array[:]
            self.diff = [0] * (self.size + 1)
            
            # 初始化差分数组
            self.diff[0] = size_or_array[0]
            for i in range(1, self.size):
                self.diff[i] = size_or_array[i] - size_or_array[i - 1]
    
    def range_update(self, start, end, val):
        """
        区间更新：将区间[start, end]的每个元素加上val
        时间复杂度：O(1)
        :param start: 起始索引（包含）
        :param end: 结束索引（包含）
        :param val: 要增加的值
        """
        if start < 0 or end >= self.size or start > end:
            raise ValueError("更新范围无效")
        
        self.diff[start] += val
        self.diff[end + 1] -= val
    
    def get_result(self):
        """
        获取更新后的数组
        时间复杂度：O(n)
        :return: 更新后的数组
        """
        result = [0] * self.size
        result[0] = self.diff[0]
        
        for i in range(1, self.size):
            result[i] = result[i - 1] + self.diff[i]
        
        return result
    
    def get_value(self, index):
        """
        直接获取数组中特定位置的值
        注意：这需要先重建数组，时间复杂度O(n)
        :param index: 索引位置
        :return: 该位置的值
        """
        if index < 0 or index >= self.size:
            raise ValueError("索引无效")
        
        result = self.get_result()
        return result[index]
    
    def reset(self):
        """重置差分数组"""
        self.diff = [0] * (self.size + 1)
        if self.original:
            for i in range(self.size):
                self.range_update(i, i, self.original[i])
    
    def get_size(self):
        """
        获取数组大小
        :return: 数组大小
        """
        return self.size
    
    @staticmethod
    def test_difference_array():
        """测试差分数组"""
        print("=== 测试差分数组 ===")
        
        # 测试从大小创建
        print("测试从大小创建:")
        da1 = DifferenceArray(5)
        print("初始数组:", da1.get_result())
        
        da1.range_update(0, 2, 1)
        print("区间[0,2]加1:", da1.get_result())
        
        da1.range_update(1, 4, 2)
        print("区间[1,4]加2:", da1.get_result())
        
        da1.range_update(2, 3, -1)
        print("区间[2,3]减1:", da1.get_result())
        
        # 测试从原始数组创建
        print("\n测试从原始数组创建:")
        original = [1, 2, 3, 4, 5]
        da2 = DifferenceArray(original)
        print("原始数组:", da2.get_result())
        
        da2.range_update(1, 3, 10)
        print("区间[1,3]加10:", da2.get_result())
        
        da2.range_update(0, 4, -5)
        print("区间[0,4]减5:", da2.get_result())
        
        # 测试重置功能
        da2.reset()
        print("重置后:", da2.get_result())
        
        # 测试边界情况
        print("\n测试边界情况:")
        da3 = DifferenceArray(1)
        da3.range_update(0, 0, 100)
        print("单元素数组更新:", da3.get_result())
        
        # 性能测试
        print("\n=== 性能测试 ===")
        
        # 测试大量区间更新操作
        n = 100000
        da4 = DifferenceArray(n)
        
        # 执行大量区间更新
        start_time = time.time()
        for i in range(10000):
            start = i % (n - 100)
            end = min(start + 100, n - 1)
            da4.range_update(start, end, 1)
        update_time = time.time() - start_time
        
        # 获取结果数组
        start_time = time.time()
        result = da4.get_result()
        get_result_time = time.time() - start_time
        
        print(f"执行10000次区间更新时间: {update_time*1000:.2f} ms")
        print(f"获取100000元素结果数组时间: {get_result_time*1000:.2f} ms")
        print(f"结果数组前10个元素: {result[:10]}")

if __name__ == "__main__":
    DifferenceArray.test_difference_array()

===============================================

文件: DominatorTreeImplementation.java
===============================================
package class008_AdvancedAlgorithmsAndDataStructures.dominator_tree_problems;

import java.util.*;

/**
 * 支配树 (Dominator Tree) 实现
 * 
 * 支配树是图论中的一个重要概念，主要用于程序优化和静态分析。
 * 在控制流图中，如果从入口节点到节点 v 的每条路径都经过节点 u，
 * 则称节点 u 支配节点 v。支配树是一种表示支配关系的树结构。
 * 
 * 应用场景：
 * 1. 编译器优化：死代码消除、循环优化
 * 2. 程序分析：数据流分析、控制流分析
 * 3. 网络分析：关键路径分析
 * 
 * 算法思路：
 * 使用 Lengauer-Tarjan 算法构建支配树：
 * 1. 对图进行深度优先搜索，构建 DFS 树
 * 2. 计算半支配点 (semi-dominator)
 * 3. 计算支配点 (immediate dominator)
 * 
 * 时间复杂度：O((V+E) log V)
 * 空间复杂度：O(V+E)
 */
public class DominatorTreeImplementation {
    
    static class DominatorTree {
        private int n; // 节点数
        private List<List<Integer>> graph; // 原图的邻接表
        private List<List<Integer>> reverseGraph; // 原图的反向图
        private int[] parent; // DFS树中的父节点
        private int[] semi; // 半支配点
        private int[] idom; // 立即支配点
        private int[] dfn; // DFS序
        private int[] id; // dfn的反向映射
        private int dfsTime; // DFS时间戳
        
        // 用于Lengauer-Tarjan算法的数据结构
        private List<List<Integer>> bucket; // bucket[v]存储semi[v] = w的所有节点v
        private int[] ancestor; // 并查集的父节点
        private int[] label; // 并查集中用于路径压缩的标签
        
        public DominatorTree(int n) {
            this.n = n;
            this.graph = new ArrayList<>();
            this.reverseGraph = new ArrayList<>();
            for (int i = 0; i < n; i++) {
                graph.add(new ArrayList<>());
                reverseGraph.add(new ArrayList<>());
            }
            
            this.parent = new int[n];
            this.semi = new int[n];
            this.idom = new int[n];
            this.dfn = new int[n];
            this.id = new int[n];
            this.bucket = new ArrayList<>();
            this.ancestor = new int[n];
            this.label = new int[n];
            
            Arrays.fill(parent, -1);
            Arrays.fill(semi, -1);
            Arrays.fill(idom, -1);
            Arrays.fill(dfn, -1);
            Arrays.fill(ancestor, -1);
            
            for (int i = 0; i < n; i++) {
                bucket.add(new ArrayList<>());
            }
        }
        
        // 添加边
        public void addEdge(int u, int v) {
            graph.get(u).add(v);
            reverseGraph.get(v).add(u);
        }
        
        // 构建支配树
        public void buildDominatorTree(int root) {
            dfsTime = 0;
            Arrays.fill(dfn, -1);
            
            // 第一步：DFS遍历，构建DFS树
            dfs(root);
            
            // 初始化semi和label数组
            for (int i = 0; i < n; i++) {
                semi[i] = dfn[i];
                label[i] = i;
            }
            
            // 第二步：从后向前计算半支配点
            for (int i = n - 1; i >= 1; i--) {
                int w = id[i];
                
                // 计算semi[w]
                for (int v : reverseGraph.get(w)) {
                    if (dfn[v] == -1) continue; // 跳过不在DFS树中的节点
                    int u = eval(v);
                    if (semi[u] < semi[w]) {
                        semi[w] = semi[u];
                    }
                }
                
                bucket.get(id[semi[w]]).add(w);
                link(parent[w], w);
                
                // 处理bucket[parent[w]]
                for (int v : bucket.get(parent[w])) {
                    int u = eval(v);
                    if (semi[u] < semi[v]) {
                        idom[v] = u;
                    } else {
                        idom[v] = parent[w];
                    }
                }
                
                bucket.get(parent[w]).clear();
            }
            
            // 第三步：计算立即支配点
            for (int i = 1; i < n; i++) {
                int w = id[i];
                if (idom[w] != id[semi[w]]) {
                    idom[w] = idom[idom[w]];
                }
            }
            
            idom[root] = root;
        }
        
        // 深度优先搜索
        private void dfs(int u) {
            dfn[u] = dfsTime;
            id[dfsTime] = u;
            dfsTime++;
            
            for (int v : graph.get(u)) {
                if (dfn[v] == -1) {
                    parent[v] = u;
                    dfs(v);
                }
            }
        }
        
        // 并查集的link操作
        private void link(int v, int w) {
            ancestor[w] = v;
        }
        
        // 并查集的eval操作（带路径压缩）
        private int eval(int v) {
            if (ancestor[v] == -1) {
                return v;
            }
            
            compress(v);
            return label[v];
        }
        
        // 路径压缩
        private void compress(int v) {
            if (ancestor[ancestor[v]] == -1) {
                return;
            }
            
            compress(ancestor[v]);
            
            if (semi[label[ancestor[v]]] < semi[label[v]]) {
                label[v] = label[ancestor[v]];
            }
            
            ancestor[v] = ancestor[ancestor[v]];
        }
        
        // 获取节点v的支配点
        public int getDominator(int v) {
            return idom[v];
        }
        
        // 检查节点u是否支配节点v
        public boolean dominates(int u, int v) {
            // 从v沿着支配树向上查找，看是否能到达u
            int current = v;
            while (current != u && current != idom[current]) {
                current = idom[current];
            }
            return current == u;
        }
        
        // 获取支配树的邻接表表示
        public List<List<Integer>> getDominatorTree() {
            List<List<Integer>> domTree = new ArrayList<>();
            for (int i = 0; i < n; i++) {
                domTree.add(new ArrayList<>());
            }
            
            for (int i = 0; i < n; i++) {
                if (idom[i] != i) { // 不是根节点
                    domTree.get(idom[i]).add(i);
                }
            }
            
            return domTree;
        }
        
        // 打印支配树
        public void printDominatorTree() {
            System.out.println("Dominator Tree:");
            List<List<Integer>> domTree = getDominatorTree();
            for (int i = 0; i < n; i++) {
                System.out.print("Node " + i + " is dominated by " + idom[i] + ", dominates: ");
                for (int child : domTree.get(i)) {
                    System.out.print(child + " ");
                }
                System.out.println();
            }
        }
    }
    
    // 测试方法
    public static void main(String[] args) {
        // 测试用例1：简单的控制流图
        System.out.println("测试用例1: 简单控制流图");
        DominatorTree dt1 = new DominatorTree(6);
        
        // 构建控制流图
        // 0 -> 1, 2
        // 1 -> 3
        // 2 -> 3
        // 3 -> 4, 5
        // 4 -> 3
        // 5 -> 3
        dt1.addEdge(0, 1);
        dt1.addEdge(0, 2);
        dt1.addEdge(1, 3);
        dt1.addEdge(2, 3);
        dt1.addEdge(3, 4);
        dt1.addEdge(3, 5);
        dt1.addEdge(4, 3);
        dt1.addEdge(5, 3);
        
        // 构建支配树
        dt1.buildDominatorTree(0);
        dt1.printDominatorTree();
        
        System.out.println("节点1是否支配节点3: " + dt1.dominates(1, 3));
        System.out.println("节点0是否支配节点3: " + dt1.dominates(0, 3));
        System.out.println();
        
        // 测试用例2：线性结构
        System.out.println("测试用例2: 线性结构");
        DominatorTree dt2 = new DominatorTree(5);
        
        // 构建线性控制流图
        // 0 -> 1 -> 2 -> 3 -> 4
        dt2.addEdge(0, 1);
        dt2.addEdge(1, 2);
        dt2.addEdge(2, 3);
        dt2.addEdge(3, 4);
        
        // 构建支配树
        dt2.buildDominatorTree(0);
        dt2.printDominatorTree();
        System.out.println();
        
        // 测试用例3：循环结构
        System.out.println("测试用例3: 循环结构");
        DominatorTree dt3 = new DominatorTree(4);
        
        // 构建带循环的控制流图
        // 0 -> 1
        // 1 -> 2
        // 2 -> 1, 3
        dt3.addEdge(0, 1);
        dt3.addEdge(1, 2);
        dt3.addEdge(2, 1);
        dt3.addEdge(2, 3);
        
        // 构建支配树
        dt3.buildDominatorTree(0);
        dt3.printDominatorTree();
    }
}

===============================================

文件: dominator_tree_implementation.cpp
===============================================
// 支配树 (Dominator Tree) C++ 实现

/**
 * 支配树 (Dominator Tree) 实现
 * 
 * 支配树是图论中的一个重要概念，主要用于程序优化和静态分析。
 * 在控制流图中，如果从入口节点到节点 v 的每条路径都经过节点 u，
 * 则称节点 u 支配节点 v。支配树是一种表示支配关系的树结构。
 * 
 * 应用场景：
 * 1. 编译器优化：死代码消除、循环优化
 * 2. 程序分析：数据流分析、控制流分析
 * 3. 网络分析：关键路径分析
 * 
 * 算法思路：
 * 使用 Lengauer-Tarjan 算法构建支配树：
 * 1. 对图进行深度优先搜索，构建 DFS 树
 * 2. 计算半支配点 (semi-dominator)
 * 3. 计算支配点 (immediate dominator)
 * 
 * 时间复杂度：O((V+E) log V)
 * 空间复杂度：O(V+E)
 */

// 由于编译环境限制，这里提供算法思路和伪代码实现

/*
// 支配树类定义
struct DominatorTree {
    int n; // 节点数
    int** graph; // 原图的邻接表
    int** reverseGraph; // 原图的反向图
    int* parent; // DFS树中的父节点
    int* semi; // 半支配点
    int* idom; // 立即支配点
    int* dfn; // DFS序
    int* id; // dfn的反向映射
    int dfsTime; // DFS时间戳
    
    // 用于Lengauer-Tarjan算法的数据结构
    int** bucket; // bucket[v]存储semi[v] = w的所有节点v
    int* ancestor; // 并查集的父节点
    int* label; // 并查集中用于路径压缩的标签
    
    // 构造函数
    DominatorTree(int n);
    
    // 析构函数
    ~DominatorTree();
    
    // 添加边
    void addEdge(int u, int v);
    
    // 构建支配树
    void buildDominatorTree(int root);
    
    // 深度优先搜索
    void dfs(int u);
    
    // 并查集的link操作
    void link(int v, int w);
    
    // 并查集的eval操作（带路径压缩）
    int eval(int v);
    
    // 路径压缩
    void compress(int v);
    
    // 获取节点v的支配点
    int getDominator(int v);
    
    // 检查节点u是否支配节点v
    bool dominates(int u, int v);
    
    // 获取支配树的邻接表表示
    int** getDominatorTree(int* nodeCount);
    
    // 打印支配树
    void printDominatorTree();
};

// 构造函数
DominatorTree::DominatorTree(int n) : n(n) {
    // 初始化数据结构
    this->graph = (int**)calloc(n, sizeof(int*));
    this->reverseGraph = (int**)calloc(n, sizeof(int*));
    this->parent = (int*)malloc(n * sizeof(int));
    this->semi = (int*)malloc(n * sizeof(int));
    this->idom = (int*)malloc(n * sizeof(int));
    this->dfn = (int*)malloc(n * sizeof(int));
    this->id = (int*)malloc(n * sizeof(int));
    this->bucket = (int**)calloc(n, sizeof(int*));
    this->ancestor = (int*)malloc(n * sizeof(int));
    this->label = (int*)malloc(n * sizeof(int));
    
    // 初始化数组
    for (int i = 0; i < n; i++) {
        this->parent[i] = -1;
        this->semi[i] = -1;
        this->idom[i] = -1;
        this->dfn[i] = -1;
        this->ancestor[i] = -1;
    }
}

// 析构函数
DominatorTree::~DominatorTree() {
    // 释放内存
    for (int i = 0; i < n; i++) {
        free(graph[i]);
        free(reverseGraph[i]);
        free(bucket[i]);
    }
    free(graph);
    free(reverseGraph);
    free(parent);
    free(semi);
    free(idom);
    free(dfn);
    free(id);
    free(bucket);
    free(ancestor);
    free(label);
}

// 添加边
void DominatorTree::addEdge(int u, int v) {
    // 在实际实现中需要动态维护邻接表
}

// 构建支配树
void DominatorTree::buildDominatorTree(int root) {
    dfsTime = 0;
    for (int i = 0; i < n; i++) {
        dfn[i] = -1;
    }
    
    // 第一步：DFS遍历，构建DFS树
    dfs(root);
    
    // 初始化semi和label数组
    for (int i = 0; i < n; i++) {
        semi[i] = dfn[i];
        label[i] = i;
    }
    
    // 第二步：从后向前计算半支配点
    for (int i = n - 1; i >= 1; i--) {
        int w = id[i];
        
        // 计算semi[w]
        for (int j = 0; reverseGraph[w] && reverseGraph[w][j] != -1; j++) {
            int v = reverseGraph[w][j];
            if (dfn[v] == -1) continue; // 跳过不在DFS树中的节点
            int u = eval(v);
            if (semi[u] < semi[w]) {
                semi[w] = semi[u];
            }
        }
        
        // 处理bucket[parent[w]]
        // 实现细节省略
        
        // 第三步：计算立即支配点
        for (int i = 1; i < n; i++) {
            int w = id[i];
            if (idom[w] != id[semi[w]]) {
                idom[w] = idom[idom[w]];
            }
        }
        
        idom[root] = root;
    }
}

// 算法核心思想：
// 1. 使用深度优先搜索构建DFS树
// 2. 通过并查集优化计算半支配点
// 3. 利用半支配点计算立即支配点

// 时间复杂度分析：
// - DFS遍历：O(V + E)
// - 计算半支配点：O((V + E) log V)
// - 计算立即支配点：O(V)
// - 总体时间复杂度：O((V + E) log V)
// - 空间复杂度：O(V + E)
*/

// 算法应用场景：
// 1. 编译器优化中的控制流分析
// 2. 程序分析中的死代码检测
// 3. 网络分析中的关键路径识别

===============================================

文件: dominator_tree_implementation.py
===============================================
#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
支配树 (Dominator Tree) Python 实现

支配树是图论中的一个重要概念，主要用于程序优化和静态分析。
在控制流图中，如果从入口节点到节点 v 的每条路径都经过节点 u，
则称节点 u 支配节点 v。支配树是一种表示支配关系的树结构。

应用场景：
1. 编译器优化：死代码消除、循环优化
2. 程序分析：数据流分析、控制流分析
3. 网络分析：关键路径分析

算法思路：
使用 Lengauer-Tarjan 算法构建支配树：
1. 对图进行深度优先搜索，构建 DFS 树
2. 计算半支配点 (semi-dominator)
3. 计算支配点 (immediate dominator)

时间复杂度：O((V+E) log V)
空间复杂度：O(V+E)
"""

class DominatorTree:
    def __init__(self, n):
        """
        初始化支配树
        
        Args:
            n: 节点数
        """
        self.n = n
        self.graph = [[] for _ in range(n)]  # 原图的邻接表
        self.reverse_graph = [[] for _ in range(n)]  # 原图的反向图
        self.parent = [-1] * n  # DFS树中的父节点
        self.semi = [-1] * n  # 半支配点
        self.idom = [-1] * n  # 立即支配点
        self.dfn = [-1] * n  # DFS序
        self.id = [0] * n  # dfn的反向映射
        self.dfs_time = 0  # DFS时间戳
        
        # 用于Lengauer-Tarjan算法的数据结构
        self.bucket = [[] for _ in range(n)]  # bucket[v]存储semi[v] = w的所有节点v
        self.ancestor = [-1] * n  # 并查集的父节点
        self.label = list(range(n))  # 并查集中用于路径压缩的标签
    
    def add_edge(self, u, v):
        """
        添加边
        
        Args:
            u: 起点
            v: 终点
        """
        self.graph[u].append(v)
        self.reverse_graph[v].append(u)
    
    def build_dominator_tree(self, root):
        """
        构建支配树
        
        Args:
            root: 根节点
        """
        self.dfs_time = 0
        self.dfn = [-1] * self.n
        
        # 第一步：DFS遍历，构建DFS树
        self.dfs(root)
        
        # 初始化semi和label数组
        for i in range(self.n):
            self.semi[i] = self.dfn[i]
            self.label[i] = i
        
        # 第二步：从后向前计算半支配点
        for i in range(self.n - 1, 0, -1):
            w = self.id[i]
            
            # 计算semi[w]
            for v in self.reverse_graph[w]:
                if self.dfn[v] == -1:
                    continue  # 跳过不在DFS树中的节点
                u = self.eval(v)
                if self.semi[u] < self.semi[w]:
                    self.semi[w] = self.semi[u]
            
            self.bucket[self.id[self.semi[w]]].append(w)
            self.link(self.parent[w], w)
            
            # 处理bucket[parent[w]]
            for v in self.bucket[self.parent[w]]:
                u = self.eval(v)
                if self.semi[u] < self.semi[v]:
                    self.idom[v] = u
                else:
                    self.idom[v] = self.parent[w]
            
            self.bucket[self.parent[w]].clear()
        
        # 第三步：计算立即支配点
        for i in range(1, self.n):
            w = self.id[i]
            if self.idom[w] != self.id[self.semi[w]]:
                self.idom[w] = self.idom[self.idom[w]]
        
        self.idom[root] = root
    
    def dfs(self, u):
        """
        深度优先搜索
        
        Args:
            u: 当前节点
        """
        self.dfn[u] = self.dfs_time
        self.id[self.dfs_time] = u
        self.dfs_time += 1
        
        for v in self.graph[u]:
            if self.dfn[v] == -1:
                self.parent[v] = u
                self.dfs(v)
    
    def link(self, v, w):
        """
        并查集的link操作
        
        Args:
            v: 节点v
            w: 节点w
        """
        self.ancestor[w] = v
    
    def eval(self, v):
        """
        并查集的eval操作（带路径压缩）
        
        Args:
            v: 节点v
            
        Returns:
            节点v的根节点
        """
        if self.ancestor[v] == -1:
            return v
        
        self.compress(v)
        return self.label[v]
    
    def compress(self, v):
        """
        路径压缩
        
        Args:
            v: 节点v
        """
        if self.ancestor[self.ancestor[v]] == -1:
            return
        
        self.compress(self.ancestor[v])
        
        if self.semi[self.label[self.ancestor[v]]] < self.semi[self.label[v]]:
            self.label[v] = self.label[self.ancestor[v]]
        
        self.ancestor[v] = self.ancestor[self.ancestor[v]]
    
    def get_dominator(self, v):
        """
        获取节点v的支配点
        
        Args:
            v: 节点v
            
        Returns:
            节点v的支配点
        """
        return self.idom[v]
    
    def dominates(self, u, v):
        """
        检查节点u是否支配节点v
        
        Args:
            u: 节点u
            v: 节点v
            
        Returns:
            节点u是否支配节点v
        """
        # 从v沿着支配树向上查找，看是否能到达u
        current = v
        while current != u and current != self.idom[current]:
            current = self.idom[current]
        return current == u
    
    def get_dominator_tree(self):
        """
        获取支配树的邻接表表示
        
        Returns:
            支配树的邻接表
        """
        dom_tree = [[] for _ in range(self.n)]
        
        for i in range(self.n):
            if self.idom[i] != i:  # 不是根节点
                dom_tree[self.idom[i]].append(i)
        
        return dom_tree
    
    def print_dominator_tree(self):
        """打印支配树"""
        print("Dominator Tree:")
        dom_tree = self.get_dominator_tree()
        for i in range(self.n):
            print(f"Node {i} is dominated by {self.idom[i]}, dominates: {dom_tree[i]}")


# 测试方法
def main():
    # 测试用例1：简单的控制流图
    print("测试用例1: 简单控制流图")
    dt1 = DominatorTree(6)
    
    # 构建控制流图
    # 0 -> 1, 2
    # 1 -> 3
    # 2 -> 3
    # 3 -> 4, 5
    # 4 -> 3
    # 5 -> 3
    dt1.add_edge(0, 1)
    dt1.add_edge(0, 2)
    dt1.add_edge(1, 3)
    dt1.add_edge(2, 3)
    dt1.add_edge(3, 4)
    dt1.add_edge(3, 5)
    dt1.add_edge(4, 3)
    dt1.add_edge(5, 3)
    
    # 构建支配树
    dt1.build_dominator_tree(0)
    dt1.print_dominator_tree()
    
    print("节点1是否支配节点3:", dt1.dominates(1, 3))
    print("节点0是否支配节点3:", dt1.dominates(0, 3))
    print()
    
    # 测试用例2：线性结构
    print("测试用例2: 线性结构")
    dt2 = DominatorTree(5)
    
    # 构建线性控制流图
    # 0 -> 1 -> 2 -> 3 -> 4
    dt2.add_edge(0, 1)
    dt2.add_edge(1, 2)
    dt2.add_edge(2, 3)
    dt2.add_edge(3, 4)
    
    # 构建支配树
    dt2.build_dominator_tree(0)
    dt2.print_dominator_tree()
    print()
    
    # 测试用例3：循环结构
    print("测试用例3: 循环结构")
    dt3 = DominatorTree(4)
    
    # 构建带循环的控制流图
    # 0 -> 1
    # 1 -> 2
    # 2 -> 1, 3
    dt3.add_edge(0, 1)
    dt3.add_edge(1, 2)
    dt3.add_edge(2, 1)
    dt3.add_edge(2, 3)
    
    # 构建支配树
    dt3.build_dominator_tree(0)
    dt3.print_dominator_tree()


if __name__ == "__main__":
    main()

===============================================

文件: DoublyCircularLinkedList.cpp
===============================================
#include <iostream>
#include <vector>
#include <stdexcept>
#include <chrono>

using namespace std;

/**
 * 双向循环链表实现 (C++版本)
 * 
 * 算法思路：
 * 双向循环链表是一种线性数据结构，每个节点都有指向前驱和后继节点的指针，
 * 并且尾节点指向头节点，形成一个环。
 * 
 * 应用场景：
 * 1. 操作系统：内存管理和进程调度
 * 2. 浏览器：历史记录和标签页管理
 * 3. 音乐播放器：播放列表管理
 * 4. 游戏开发：对象管理
 * 
 * 时间复杂度：
 * - 插入操作：
 *   - 在头部/尾部插入：O(1)
 *   - 在指定位置插入：O(n)
 * - 删除操作：
 *   - 删除头部/尾部：O(1)
 *   - 删除指定位置：O(n)
 *   - 按值删除：O(n)
 * - 查找操作：O(n)
 * - 遍历操作：O(n)
 * - 其他操作：
 *   - 反转：O(n)
 *   - 旋转：O(n)
 *   - 清空：O(n)
 * 
 * 空间复杂度：O(n)
 * 
 * 相关题目：
 * 1. LeetCode LCR 155. 将二叉搜索树转化为排序的双向链表
 * 2. LeetCode 426. 将二叉搜索树转化为排序的双向链表
 */

struct Node {
    int data;
    Node* prev;
    Node* next;
    
    Node(int value) : data(value), prev(this), next(this) {}
};

class DoublyCircularLinkedList {
private:
    Node* head;
    int size;

    bool isValidIndex(int index) const {
        return index >= 0 && index < size;
    }

    Node* getNodeAt(int index) const {
        if (!isValidIndex(index)) {
            throw std::out_of_range("索引超出范围");
        }

        // 优化：根据索引位置选择从头还是从尾开始遍历
        if (index <= size / 2) {
            // 从头开始遍历
            Node* current = head;
            for (int i = 0; i < index; i++) {
                current = current->next;
            }
            return current;
        } else {
            // 从尾开始遍历（尾部是head->prev）
            Node* current = head->prev;
            for (int i = size - 1; i > index; i--) {
                current = current->prev;
            }
            return current;
        }
    }

public:
    DoublyCircularLinkedList() : head(nullptr), size(0) {}

    ~DoublyCircularLinkedList() {
        clear();
    }

    bool isEmpty() const {
        return head == nullptr;
    }

    void insertAtHead(int value) {
        Node* newNode = new Node(value);

        if (isEmpty()) {
            head = newNode;
        } else {
            Node* tail = head->prev;

            newNode->prev = tail;
            tail->next = newNode;

            newNode->next = head;
            head->prev = newNode;

            head = newNode;
        }

        size++;
    }

    void insertAtTail(int value) {
        Node* newNode = new Node(value);

        if (isEmpty()) {
            head = newNode;
        } else {
            Node* tail = head->prev;

            tail->next = newNode;
            newNode->prev = tail;

            newNode->next = head;
            head->prev = newNode;
        }

        size++;
    }

    void insertAtPosition(int index, int value) {
        if (index == 0) {
            insertAtHead(value);
            return;
        }

        if (index == size) {
            insertAtTail(value);
            return;
        }

        if (!isValidIndex(index)) {
            throw std::out_of_range("索引超出范围");
        }

        Node* prevNode = getNodeAt(index - 1);
        Node* nextNode = prevNode->next;

        Node* newNode = new Node(value);

        newNode->prev = prevNode;
        newNode->next = nextNode;
        prevNode->next = newNode;
        nextNode->prev = newNode;

        size++;
    }

    int deleteHead() {
        if (isEmpty()) {
            throw std::runtime_error("无法从空链表删除");
        }

        Node* oldHead = head;
        int value = oldHead->data;

        if (size == 1) {
            head = nullptr;
        } else {
            Node* tail = head->prev;
            Node* newHead = head->next;

            tail->next = newHead;
            newHead->prev = tail;

            head = newHead;
        }

        delete oldHead;
        size--;
        return value;
    }

    int deleteTail() {
        if (isEmpty()) {
            throw std::runtime_error("无法从空链表删除");
        }

        Node* tail = head->prev;
        int value = tail->data;

        if (size == 1) {
            delete tail;
            head = nullptr;
        } else {
            Node* newTail = tail->prev;

            newTail->next = head;
            head->prev = newTail;

            delete tail;
        }

        size--;
        return value;
    }

    int deleteAtPosition(int index) {
        if (isEmpty()) {
            throw std::runtime_error("无法从空链表删除");
        }

        if (!isValidIndex(index)) {
            throw std::out_of_range("索引超出范围");
        }

        if (index == 0) {
            return deleteHead();
        }

        if (index == size - 1) {
            return deleteTail();
        }

        Node* nodeToDelete = getNodeAt(index);
        int value = nodeToDelete->data;

        Node* prevNode = nodeToDelete->prev;
        Node* nextNode = nodeToDelete->next;

        prevNode->next = nextNode;
        nextNode->prev = prevNode;

        delete nodeToDelete;
        size--;
        return value;
    }

    bool deleteByValue(int value) {
        if (isEmpty()) {
            return false;
        }

        if (head->data == value) {
            deleteHead();
            return true;
        }

        Node* current = head->next;
        while (current != head) {
            if (current->data == value) {
                Node* prevNode = current->prev;
                Node* nextNode = current->next;

                prevNode->next = nextNode;
                nextNode->prev = prevNode;

                delete current;
                size--;
                return true;
            }
            current = current->next;
        }

        return false;
    }

    std::vector<int> traverseForward() const {
        std::vector<int> result;
        if (isEmpty()) {
            return result;
        }

        Node* current = head;
        do {
            result.push_back(current->data);
            current = current->next;
        } while (current != head);

        return result;
    }

    std::vector<int> traverseBackward() const {
        std::vector<int> result;
        if (isEmpty()) {
            return result;
        }

        Node* current = head->prev;
        do {
            result.push_back(current->data);
            current = current->prev;
        } while (current != head->prev);

        return result;
    }

    int search(int value) const {
        if (isEmpty()) {
            return -1;
        }

        Node* current = head;
        int index = 0;
        do {
            if (current->data == value) {
                return index;
            }
            current = current->next;
            index++;
        } while (current != head);

        return -1;
    }

    int get(int index) const {
        Node* node = getNodeAt(index);
        return node->data;
    }

    void set(int index, int value) {
        Node* node = getNodeAt(index);
        node->data = value;
    }

    int getSize() const {
        return size;
    }

    void clear() {
        if (isEmpty()) {
            return;
        }

        Node* current = head;
        do {
            Node* next = current->next;
            delete current;
            current = next;
        } while (current != head);

        head = nullptr;
        size = 0;
    }

    void reverse() {
        if (isEmpty() || size == 1) {
            return;
        }

        Node* current = head;
        do {
            Node* temp = current->prev;
            current->prev = current->next;
            current->next = temp;

            current = current->prev;
        } while (current != head);

        head = head->prev;
    }

    void rotate(int k) {
        if (isEmpty() || size == 1 || k % size == 0) {
            return;
        }

        k = k % size;
        if (k < 0) {
            k += size;
        }

        if (k > 0) {
            Node* newHead = head;
            for (int i = 0; i < size - k; i++) {
                newHead = newHead->next;
            }

            head = newHead;
        }
    }

    void printList() const {
        if (isEmpty()) {
            std::cout << "List is empty" << std::endl;
            return;
        }

        Node* current = head;
        std::cout << "List: ";
        do {
            std::cout << current->data;
            if (current->next != head) {
                std::cout << " <-> ";
            }
            current = current->next;
        } while (current != head);
        std::cout << " (circular)" << std::endl;
    }

    static void testDoublyCircularLinkedList() {
        std::cout << "=== 测试双向循环链表 ===" << std::endl;

        DoublyCircularLinkedList list;

        // 测试插入操作
        std::cout << "\n1. 测试插入操作:" << std::endl;
        std::cout << "插入10, 20, 30, 40, 50" << std::endl;
        list.insertAtTail(10);
        list.insertAtTail(20);
        list.insertAtTail(30);
        list.insertAtTail(40);
        list.insertAtTail(50);
        list.printList();
        std::cout << "List size: " << list.getSize() << std::endl;

        std::cout << "\n在头部插入5:" << std::endl;
        list.insertAtHead(5);
        list.printList();

        std::cout << "\n在位置3插入25:" << std::endl;
        list.insertAtPosition(3, 25);
        list.printList();

        // 测试遍历操作
        std::cout << "\n2. 测试遍历操作:" << std::endl;
        std::vector<int> forward = list.traverseForward();
        std::cout << "正向遍历: ";
        for (int val : forward) {
            std::cout << val << " ";
        }
        std::cout << std::endl;

        std::vector<int> backward = list.traverseBackward();
        std::cout << "反向遍历: ";
        for (int val : backward) {
            std::cout << val << " ";
        }
        std::cout << std::endl;

        // 测试查找和访问操作
        std::cout << "\n3. 测试查找和访问操作:" << std::endl;
        int value = 25;
        int index = list.search(value);
        std::cout << "查找值 " << value << ": 索引 = " << index << std::endl;

        index = 3;
        value = list.get(index);
        std::cout << "索引 " << index << " 的值 = " << value << std::endl;

        std::cout << "设置索引2的值为15:" << std::endl;
        list.set(2, 15);
        list.printList();

        // 测试删除操作
        std::cout << "\n4. 测试删除操作:" << std::endl;
        std::cout << "删除头部元素:" << std::endl;
        value = list.deleteHead();
        std::cout << "删除的值 = " << value << std::endl;
        list.printList();

        std::cout << "删除尾部元素:" << std::endl;
        value = list.deleteTail();
        std::cout << "删除的值 = " << value << std::endl;
        list.printList();

        std::cout << "删除索引2的元素:" << std::endl;
        value = list.deleteAtPosition(2);
        std::cout << "删除的值 = " << value << std::endl;
        list.printList();

        std::cout << "删除值20:" << std::endl;
        bool deleted = list.deleteByValue(20);
        std::cout << "删除 " << (deleted ? "成功" : "失败") << std::endl;
        list.printList();

        // 测试反转操作
        std::cout << "\n5. 测试反转操作:" << std::endl;
        list.reverse();
        std::cout << "反转后:" << std::endl;
        list.printList();

        // 测试旋转操作
        std::cout << "\n6. 测试旋转操作:" << std::endl;
        std::cout << "向右旋转1步:" << std::endl;
        list.rotate(1);
        list.printList();

        std::cout << "向左旋转2步:" << std::endl;
        list.rotate(-2);
        list.printList();

        // 测试边界情况
        std::cout << "\n7. 测试边界情况:" << std::endl;
        std::cout << "清空链表:" << std::endl;
        list.clear();
        list.printList();
        std::cout << "List size: " << list.getSize() << std::endl;

        std::cout << "空链表插入元素:" << std::endl;
        list.insertAtTail(100);
        list.printList();

        std::cout << "单节点链表删除:" << std::endl;
        value = list.deleteHead();
        std::cout << "删除的值 = " << value << std::endl;
        list.printList();

        // 性能测试
        std::cout << "\n=== 性能测试 ===" << std::endl;

        DoublyCircularLinkedList largeList;

        auto startTime = std::chrono::high_resolution_clock::now();
        for (int i = 0; i < 10000; i++) {
            largeList.insertAtTail(i);
        }
        auto endTime = std::chrono::high_resolution_clock::now();
        auto insertTime = std::chrono::duration_cast<std::chrono::microseconds>(endTime - startTime);

        std::cout << "插入10000个元素时间: " << insertTime.count() / 1000.0 << " ms" << std::endl;
        std::cout << "链表大小: " << largeList.getSize() << std::endl;

        startTime = std::chrono::high_resolution_clock::now();
        for (int i = 0; i < 1000; i++) {
            largeList.get(i * 10);
        }
        endTime = std::chrono::high_resolution_clock::now();
        auto accessTime = std::chrono::duration_cast<std::chrono::microseconds>(endTime - startTime);

        std::cout << "1000次随机访问时间: " << accessTime.count() / 1000.0 << " ms" << std::endl;
    }
};

int main() {
    DoublyCircularLinkedList::testDoublyCircularLinkedList();
    return 0;
}



===============================================

文件: DoublyCircularLinkedList.java
===============================================
package class185.doubly_circular_linked_list_problems;

import java.util.*;

/**
 * 双向循环链表实现 (Java版本)
 * 
 * 算法思路：
 * 双向循环链表是一种线性数据结构，每个节点都有指向前驱和后继节点的指针，
 * 并且尾节点指向头节点，形成一个环。
 * 
 * 应用场景：
 * 1. 操作系统：内存管理和进程调度
 * 2. 浏览器：历史记录和标签页管理
 * 3. 音乐播放器：播放列表管理
 * 4. 游戏开发：对象管理
 * 
 * 时间复杂度：
 * - 插入操作：
 *   - 在头部/尾部插入：O(1)
 *   - 在指定位置插入：O(n)
 * - 删除操作：
 *   - 删除头部/尾部：O(1)
 *   - 删除指定位置：O(n)
 *   - 按值删除：O(n)
 * - 查找操作：O(n)
 * - 遍历操作：O(n)
 * - 其他操作：
 *   - 反转：O(n)
 *   - 旋转：O(n)
 *   - 清空：O(n)
 * 
 * 空间复杂度：O(n)
 * 
 * 相关题目：
 * 1. LeetCode LCR 155. 将二叉搜索树转化为排序的双向链表
 * 2. LeetCode 426. 将二叉搜索树转化为排序的双向链表
 */
class Node {
    int data;
    Node prev;
    Node next;
    
    Node(int data) {
        this.data = data;
        this.prev = this;
        this.next = this;
    }
}

public class DoublyCircularLinkedList {
    private Node head;
    private int size;
    
    public DoublyCircularLinkedList() {
        this.head = null;
        this.size = 0;
    }
    
    public boolean isEmpty() {
        return head == null;
    }
    
    private boolean isValidIndex(int index) {
        return index >= 0 && index < size;
    }
    
    private Node getNodeAt(int index) {
        if (!isValidIndex(index)) {
            throw new IndexOutOfBoundsException("索引超出范围");
        }
        
        // 优化：根据索引位置选择从头还是从尾开始遍历
        if (index <= size / 2) {
            // 从头开始遍历
            Node current = head;
            for (int i = 0; i < index; i++) {
                current = current.next;
            }
            return current;
        } else {
            // 从尾开始遍历（尾部是head.prev）
            Node current = head.prev;
            for (int i = size - 1; i > index; i--) {
                current = current.prev;
            }
            return current;
        }
    }
    
    public void insertAtHead(int value) {
        Node newNode = new Node(value);
        
        if (isEmpty()) {
            head = newNode;
        } else {
            Node tail = head.prev;
            
            newNode.prev = tail;
            tail.next = newNode;
            
            newNode.next = head;
            head.prev = newNode;
            
            head = newNode;
        }
        
        size++;
    }
    
    public void insertAtTail(int value) {
        Node newNode = new Node(value);
        
        if (isEmpty()) {
            head = newNode;
        } else {
            Node tail = head.prev;
            
            tail.next = newNode;
            newNode.prev = tail;
            
            newNode.next = head;
            head.prev = newNode;
        }
        
        size++;
    }
    
    public void insertAtPosition(int index, int value) {
        if (index == 0) {
            insertAtHead(value);
            return;
        }
        
        if (index == size) {
            insertAtTail(value);
            return;
        }
        
        if (!isValidIndex(index)) {
            throw new IndexOutOfBoundsException("索引超出范围");
        }
        
        Node prevNode = getNodeAt(index - 1);
        Node nextNode = prevNode.next;
        
        Node newNode = new Node(value);
        
        newNode.prev = prevNode;
        newNode.next = nextNode;
        prevNode.next = newNode;
        nextNode.prev = newNode;
        
        size++;
    }
    
    public int deleteHead() {
        if (isEmpty()) {
            throw new RuntimeException("无法从空链表删除");
        }
        
        Node oldHead = head;
        int value = oldHead.data;
        
        if (size == 1) {
            head = null;
        } else {
            Node tail = head.prev;
            Node newHead = head.next;
            
            tail.next = newHead;
            newHead.prev = tail;
            
            head = newHead;
        }
        
        size--;
        return value;
    }
    
    public int deleteTail() {
        if (isEmpty()) {
            throw new RuntimeException("无法从空链表删除");
        }
        
        Node tail = head.prev;
        int value = tail.data;
        
        if (size == 1) {
            head = null;
        } else {
            Node newTail = tail.prev;
            
            newTail.next = head;
            head.prev = newTail;
        }
        
        size--;
        return value;
    }
    
    public int deleteAtPosition(int index) {
        if (isEmpty()) {
            throw new RuntimeException("无法从空链表删除");
        }
        
        if (!isValidIndex(index)) {
            throw new IndexOutOfBoundsException("索引超出范围");
        }
        
        if (index == 0) {
            return deleteHead();
        }
        
        if (index == size - 1) {
            return deleteTail();
        }
        
        Node nodeToDelete = getNodeAt(index);
        int value = nodeToDelete.data;
        
        Node prevNode = nodeToDelete.prev;
        Node nextNode = nodeToDelete.next;
        
        prevNode.next = nextNode;
        nextNode.prev = prevNode;
        
        size--;
        return value;
    }
    
    public boolean deleteByValue(int value) {
        if (isEmpty()) {
            return false;
        }
        
        if (head.data == value) {
            deleteHead();
            return true;
        }
        
        Node current = head.next;
        while (current != head) {
            if (current.data == value) {
                Node prevNode = current.prev;
                Node nextNode = current.next;
                
                prevNode.next = nextNode;
                nextNode.prev = prevNode;
                
                size--;
                return true;
            }
            current = current.next;
        }
        
        return false;
    }
    
    public List<Integer> traverseForward() {
        List<Integer> result = new ArrayList<>();
        if (isEmpty()) {
            return result;
        }
        
        Node current = head;
        do {
            result.add(current.data);
            current = current.next;
        } while (current != head);
        
        return result;
    }
    
    public List<Integer> traverseBackward() {
        List<Integer> result = new ArrayList<>();
        if (isEmpty()) {
            return result;
        }
        
        Node current = head.prev;
        do {
            result.add(current.data);
            current = current.prev;
        } while (current != head.prev);
        
        return result;
    }
    
    public int search(int value) {
        if (isEmpty()) {
            return -1;
        }
        
        Node current = head;
        int index = 0;
        do {
            if (current.data == value) {
                return index;
            }
            current = current.next;
            index++;
        } while (current != head);
        
        return -1;
    }
    
    public int get(int index) {
        Node node = getNodeAt(index);
        return node.data;
    }
    
    public void set(int index, int value) {
        Node node = getNodeAt(index);
        node.data = value;
    }
    
    public int getSize() {
        return size;
    }
    
    public void clear() {
        head = null;
        size = 0;
    }
    
    public void reverse() {
        if (isEmpty() || size == 1) {
            return;
        }
        
        Node current = head;
        do {
            Node temp = current.prev;
            current.prev = current.next;
            current.next = temp;
            
            current = current.prev;
        } while (current != head);
        
        head = head.prev;
    }
    
    public void rotate(int k) {
        if (isEmpty() || size == 1 || k % size == 0) {
            return;
        }
        
        k = k % size;
        if (k < 0) {
            k += size;
        }
        
        if (k > 0) {
            Node newHead = head;
            for (int i = 0; i < size - k; i++) {
                newHead = newHead.next;
            }
            
            head = newHead;
        }
    }
    
    public void printList() {
        if (isEmpty()) {
            System.out.println("List is empty");
            return;
        }
        
        Node current = head;
        System.out.print("List: ");
        do {
            System.out.print(current.data);
            if (current.next != head) {
                System.out.print(" <-> ");
            }
            current = current.next;
        } while (current != head);
        System.out.println(" (circular)");
    }
    
    public static void main(String[] args) {
        System.out.println("=== 测试双向循环链表 ===");
        
        DoublyCircularLinkedList list = new DoublyCircularLinkedList();
        
        // 测试插入操作
        System.out.println("\n1. 测试插入操作:");
        System.out.println("插入10, 20, 30, 40, 50");
        list.insertAtTail(10);
        list.insertAtTail(20);
        list.insertAtTail(30);
        list.insertAtTail(40);
        list.insertAtTail(50);
        list.printList();
        System.out.println("List size: " + list.getSize());
        
        System.out.println("\n在头部插入5:");
        list.insertAtHead(5);
        list.printList();
        
        System.out.println("\n在位置3插入25:");
        list.insertAtPosition(3, 25);
        list.printList();
        
        // 测试遍历操作
        System.out.println("\n2. 测试遍历操作:");
        System.out.println("正向遍历: " + list.traverseForward());
        System.out.println("反向遍历: " + list.traverseBackward());
        
        // 测试查找和访问操作
        System.out.println("\n3. 测试查找和访问操作:");
        int value = 25;
        int index = list.search(value);
        System.out.println("查找值 " + value + ": 索引 = " + index);
        
        index = 3;
        value = list.get(index);
        System.out.println("索引 " + index + " 的值 = " + value);
        
        System.out.println("设置索引2的值为15:");
        list.set(2, 15);
        list.printList();
        
        // 测试删除操作
        System.out.println("\n4. 测试删除操作:");
        System.out.println("删除头部元素:");
        value = list.deleteHead();
        System.out.println("删除的值 = " + value);
        list.printList();
        
        System.out.println("删除尾部元素:");
        value = list.deleteTail();
        System.out.println("删除的值 = " + value);
        list.printList();
        
        System.out.println("删除索引2的元素:");
        value = list.deleteAtPosition(2);
        System.out.println("删除的值 = " + value);
        list.printList();
        
        System.out.println("删除值20:");
        boolean deleted = list.deleteByValue(20);
        System.out.println("删除 " + (deleted ? "成功" : "失败"));
        list.printList();
        
        // 测试反转操作
        System.out.println("\n5. 测试反转操作:");
        list.reverse();
        System.out.println("反转后:");
        list.printList();
        
        // 测试旋转操作
        System.out.println("\n6. 测试旋转操作:");
        System.out.println("向右旋转1步:");
        list.rotate(1);
        list.printList();
        
        System.out.println("向左旋转2步:");
        list.rotate(-2);
        list.printList();
        
        // 测试边界情况
        System.out.println("\n7. 测试边界情况:");
        System.out.println("清空链表:");
        list.clear();
        list.printList();
        System.out.println("List size: " + list.getSize());
        
        System.out.println("空链表插入元素:");
        list.insertAtTail(100);
        list.printList();
        
        System.out.println("单节点链表删除:");
        value = list.deleteHead();
        System.out.println("删除的值 = " + value);
        list.printList();
        
        // 性能测试
        System.out.println("\n=== 性能测试 ===");
        
        DoublyCircularLinkedList largeList = new DoublyCircularLinkedList();
        
        long startTime = System.nanoTime();
        for (int i = 0; i < 10000; i++) {
            largeList.insertAtTail(i);
        }
        long insertTime = System.nanoTime() - startTime;
        
        System.out.println("插入10000个元素时间: " + insertTime / 1_000_000.0 + " ms");
        System.out.println("链表大小: " + largeList.getSize());
        
        startTime = System.nanoTime();
        for (int i = 0; i < 1000; i++) {
            largeList.get(i * 10);
        }
        long accessTime = System.nanoTime() - startTime;
        
        System.out.println("1000次随机访问时间: " + accessTime / 1_000_000.0 + " ms");
    }
}

===============================================

文件: doubly_circular_linked_list.cpp
===============================================
#include <iostream>
#include <stdexcept>
#include <string>
#include <vector>

/**
 * C++双向循环链表实现
 * 
 * 时间复杂度分析：
 * - 插入操作：
 *   - 在头部/尾部插入：O(1)
 *   - 在指定位置插入：O(n)
 * - 删除操作：
 *   - 删除头部/尾部：O(1)
 *   - 删除指定位置：O(n)
 *   - 按值删除：O(n)
 * - 查找操作：O(n)
 * - 遍历操作：O(n)
 * - 其他操作：
 *   - 反转：O(n)
 *   - 旋转：O(n)
 *   - 清空：O(n)
 * 
 * 空间复杂度：O(n)
 */

/**
 * 链表节点类
 */
template <typename T>
class Node {
public:
    T data;         // 节点数据
    Node* prev;     // 前驱节点指针
    Node* next;     // 后继节点指针
    
    /**
     * 构造函数
     * @param val 节点数据值
     */
    explicit Node(T val) : data(val), prev(this), next(this) {}
};

/**
 * 双向循环链表类
 */
template <typename T>
class DoublyCircularLinkedList {
private:
    Node<T>* head;  // 头节点指针
    int size;       // 链表大小
    
    /**
     * 检查索引是否有效
     * @param index 要检查的索引
     * @return 索引是否有效
     */
    bool isValidIndex(int index) const {
        return index >= 0 && index < size;
    }
    
    /**
     * 检查链表是否为空
     * @return 链表是否为空
     */
    bool isEmpty() const {
        return head == nullptr;
    }
    
    /**
     * 获取指定索引的节点指针
     * @param index 要获取的节点索引
     * @return 对应索引的节点指针
     * @throws std::out_of_range 如果索引无效
     */
    Node<T>* getNodeAt(int index) const {
        if (!isValidIndex(index)) {
            throw std::out_of_range("Index out of range");
        }
        
        // 优化：根据索引位置选择从头还是从尾开始遍历
        Node<T>* current;
        if (index <= size / 2) {
            // 从头开始遍历
            current = head;
            for (int i = 0; i < index; i++) {
                current = current->next;
            }
        } else {
            // 从尾开始遍历（尾部是head->prev）
            current = head->prev;
            for (int i = size - 1; i > index; i--) {
                current = current->prev;
            }
        }
        
        return current;
    }
    
public:
    /**
     * 构造函数 - 创建空链表
     */
    DoublyCircularLinkedList() : head(nullptr), size(0) {}
    
    /**
     * 拷贝构造函数
     * @param other 要拷贝的链表
     */
    DoublyCircularLinkedList(const DoublyCircularLinkedList& other) : head(nullptr), size(0) {
        if (other.isEmpty()) {
            return;
        }
        
        // 复制第一个节点
        head = new Node<T>(other.head->data);
        size = 1;
        
        // 复制其余节点
        Node<T>* currentOther = other.head->next;
        Node<T>* currentThis = head;
        
        while (currentOther != other.head) {
            Node<T>* newNode = new Node<T>(currentOther->data);
            // 建立双向连接
            currentThis->next = newNode;
            newNode->prev = currentThis;
            newNode->next = head;
            head->prev = newNode;
            
            currentThis = newNode;
            currentOther = currentOther->next;
            size++;
        }
    }
    
    /**
     * 移动构造函数
     * @param other 要移动的链表
     */
    DoublyCircularLinkedList(DoublyCircularLinkedList&& other) noexcept : 
        head(other.head), size(other.size) {
        // 重置other
        other.head = nullptr;
        other.size = 0;
    }
    
    /**
     * 赋值运算符
     * @param other 要赋值的链表
     * @return 链表引用
     */
    DoublyCircularLinkedList& operator=(const DoublyCircularLinkedList& other) {
        if (this != &other) {
            // 清空当前链表
            clear();
            
            if (!other.isEmpty()) {
                // 复制第一个节点
                head = new Node<T>(other.head->data);
                size = 1;
                
                // 复制其余节点
                Node<T>* currentOther = other.head->next;
                Node<T>* currentThis = head;
                
                while (currentOther != other.head) {
                    Node<T>* newNode = new Node<T>(currentOther->data);
                    // 建立双向连接
                    currentThis->next = newNode;
                    newNode->prev = currentThis;
                    newNode->next = head;
                    head->prev = newNode;
                    
                    currentThis = newNode;
                    currentOther = currentOther->next;
                    size++;
                }
            }
        }
        return *this;
    }
    
    /**
     * 移动赋值运算符
     * @param other 要移动的链表
     * @return 链表引用
     */
    DoublyCircularLinkedList& operator=(DoublyCircularLinkedList&& other) noexcept {
        if (this != &other) {
            // 清空当前链表
            clear();
            
            // 移动资源
            head = other.head;
            size = other.size;
            
            // 重置other
            other.head = nullptr;
            other.size = 0;
        }
        return *this;
    }
    
    /**
     * 析构函数
     */
    ~DoublyCircularLinkedList() {
        clear();
    }
    
    // ==================== 插入操作 ====================
    
    /**
     * 在链表头部插入元素
     * 时间复杂度：O(1)
     * @param value 要插入的值
     */
    void insertAtHead(T value) {
        Node<T>* newNode = new Node<T>(value);
        
        if (isEmpty()) {
            // 空链表情况
            head = newNode;
        } else {
            // 非空链表，插入到头部
            Node<T>* tail = head->prev;
            
            // 连接新节点与尾节点
            newNode->prev = tail;
            tail->next = newNode;
            
            // 连接新节点与头节点
            newNode->next = head;
            head->prev = newNode;
            
            // 更新头节点
            head = newNode;
        }
        
        size++;
    }
    
    /**
     * 在链表尾部插入元素
     * 时间复杂度：O(1)
     * @param value 要插入的值
     */
    void insertAtTail(T value) {
        Node<T>* newNode = new Node<T>(value);
        
        if (isEmpty()) {
            // 空链表情况
            head = newNode;
        } else {
            // 非空链表，插入到尾部
            Node<T>* tail = head->prev;
            
            // 连接尾节点与新节点
            tail->next = newNode;
            newNode->prev = tail;
            
            // 连接新节点与头节点
            newNode->next = head;
            head->prev = newNode;
        }
        
        size++;
    }
    
    /**
     * 在指定位置插入元素
     * 时间复杂度：O(n)
     * @param index 插入位置
     * @param value 要插入的值
     * @throws std::out_of_range 如果索引无效
     */
    void insertAtPosition(int index, T value) {
        if (index == 0) {
            // 在头部插入
            insertAtHead(value);
            return;
        }
        
        if (index == size) {
            // 在尾部插入
            insertAtTail(value);
            return;
        }
        
        // 检查索引是否有效
        if (!isValidIndex(index)) {
            throw std::out_of_range("Index out of range");
        }
        
        // 找到插入位置的前一个节点
        Node<T>* prevNode = getNodeAt(index - 1);
        Node<T>* nextNode = prevNode->next;
        
        // 创建新节点
        Node<T>* newNode = new Node<T>(value);
        
        // 建立连接
        newNode->prev = prevNode;
        newNode->next = nextNode;
        prevNode->next = newNode;
        nextNode->prev = newNode;
        
        size++;
    }
    
    // ==================== 删除操作 ====================
    
    /**
     * 删除链表头部元素
     * 时间复杂度：O(1)
     * @return 被删除的元素值
     * @throws std::runtime_error 如果链表为空
     */
    T deleteHead() {
        if (isEmpty()) {
            throw std::runtime_error("Cannot delete from empty list");
        }
        
        Node<T>* oldHead = head;
        T value = oldHead->data;
        
        if (size == 1) {
            // 链表只有一个节点
            delete oldHead;
            head = nullptr;
        } else {
            // 链表有多个节点
            Node<T>* tail = head->prev;
            Node<T>* newHead = head->next;
            
            // 更新连接
            tail->next = newHead;
            newHead->prev = tail;
            
            // 更新头节点并释放内存
            head = newHead;
            delete oldHead;
        }
        
        size--;
        return value;
    }
    
    /**
     * 删除链表尾部元素
     * 时间复杂度：O(1)
     * @return 被删除的元素值
     * @throws std::runtime_error 如果链表为空
     */
    T deleteTail() {
        if (isEmpty()) {
            throw std::runtime_error("Cannot delete from empty list");
        }
        
        Node<T>* tail = head->prev;
        T value = tail->data;
        
        if (size == 1) {
            // 链表只有一个节点
            delete tail;
            head = nullptr;
        } else {
            // 链表有多个节点
            Node<T>* newTail = tail->prev;
            
            // 更新连接
            newTail->next = head;
            head->prev = newTail;
            
            // 释放内存
            delete tail;
        }
        
        size--;
        return value;
    }
    
    /**
     * 删除指定位置的元素
     * 时间复杂度：O(n)
     * @param index 要删除的元素位置
     * @return 被删除的元素值
     * @throws std::out_of_range 如果索引无效
     */
    T deleteAtPosition(int index) {
        if (isEmpty()) {
            throw std::runtime_error("Cannot delete from empty list");
        }
        
        if (!isValidIndex(index)) {
            throw std::out_of_range("Index out of range");
        }
        
        if (index == 0) {
            return deleteHead();
        }
        
        if (index == size - 1) {
            return deleteTail();
        }
        
        // 找到要删除的节点
        Node<T>* nodeToDelete = getNodeAt(index);
        T value = nodeToDelete->data;
        
        // 更新连接
        Node<T>* prevNode = nodeToDelete->prev;
        Node<T>* nextNode = nodeToDelete->next;
        
        prevNode->next = nextNode;
        nextNode->prev = prevNode;
        
        // 释放内存
        delete nodeToDelete;
        size--;
        
        return value;
    }
    
    /**
     * 删除第一个出现的指定值的元素
     * 时间复杂度：O(n)
     * @param value 要删除的值
     * @return 是否成功删除
     */
    bool deleteByValue(T value) {
        if (isEmpty()) {
            return false;
        }
        
        // 特殊情况：头节点就是要删除的节点
        if (head->data == value) {
            deleteHead();
            return true;
        }
        
        // 遍历链表查找值
        Node<T>* current = head->next;
        while (current != head) {
            if (current->data == value) {
                // 找到要删除的节点
                Node<T>* prevNode = current->prev;
                Node<T>* nextNode = current->next;
                
                // 更新连接
                prevNode->next = nextNode;
                nextNode->prev = prevNode;
                
                // 释放内存
                delete current;
                size--;
                return true;
            }
            current = current->next;
        }
        
        // 未找到值
        return false;
    }
    
    // ==================== 遍历操作 ====================
    
    /**
     * 正向遍历链表，将元素存入向量返回
     * 时间复杂度：O(n)
     * @return 包含链表元素的向量
     */
    std::vector<T> traverseForward() const {
        std::vector<T> result;
        if (isEmpty()) {
            return result;
        }
        
        Node<T>* current = head;
        do {
            result.push_back(current->data);
            current = current->next;
        } while (current != head);
        
        return result;
    }
    
    /**
     * 反向遍历链表，将元素存入向量返回
     * 时间复杂度：O(n)
     * @return 包含链表元素的向量（反向）
     */
    std::vector<T> traverseBackward() const {
        std::vector<T> result;
        if (isEmpty()) {
            return result;
        }
        
        Node<T>* current = head->prev;  // 从尾节点开始
        do {
            result.push_back(current->data);
            current = current->prev;
        } while (current != head->prev);
        
        return result;
    }
    
    // ==================== 查找和访问 ====================
    
    /**
     * 查找第一个出现的指定值的索引
     * 时间复杂度：O(n)
     * @param value 要查找的值
     * @return 元素索引，如果未找到返回-1
     */
    int search(T value) const {
        if (isEmpty()) {
            return -1;
        }
        
        int index = 0;
        Node<T>* current = head;
        do {
            if (current->data == value) {
                return index;
            }
            current = current->next;
            index++;
        } while (current != head);
        
        return -1;
    }
    
    /**
     * 获取指定索引的元素值
     * 时间复杂度：O(n)
     * @param index 元素索引
     * @return 元素值
     * @throws std::out_of_range 如果索引无效
     */
    T get(int index) const {
        Node<T>* node = getNodeAt(index);
        return node->data;
    }
    
    /**
     * 设置指定索引的元素值
     * 时间复杂度：O(n)
     * @param index 元素索引
     * @param value 新的元素值
     * @throws std::out_of_range 如果索引无效
     */
    void set(int index, T value) {
        Node<T>* node = getNodeAt(index);
        node->data = value;
    }
    
    // ==================== 其他操作 ====================
    
    /**
     * 获取链表大小
     * 时间复杂度：O(1)
     * @return 链表中元素的数量
     */
    int getSize() const {
        return size;
    }
    
    /**
     * 清空链表
     * 时间复杂度：O(n)
     */
    void clear() {
        while (!isEmpty()) {
            deleteHead();
        }
    }
    
    /**
     * 反转链表
     * 时间复杂度：O(n)
     */
    void reverse() {
        if (isEmpty() || size == 1) {
            return;  // 空链表或只有一个节点不需要反转
        }
        
        // 保存头节点和尾节点
        Node<T>* current = head;
        Node<T>* tail = head->prev;
        
        // 交换每个节点的prev和next指针
        do {
            // 交换prev和next
            Node<T>* temp = current->prev;
            current->prev = current->next;
            current->next = temp;
            
            // 移动到下一个节点（现在是prev指针）
            current = current->prev;
        } while (current != head);
        
        // 更新头节点为原来的尾节点
        head = tail;
    }
    
    /**
     * 旋转链表
     * 时间复杂度：O(n)
     * @param k 旋转步数，正数表示向右旋转，负数表示向左旋转
     */
    void rotate(int k) {
        if (isEmpty() || size == 1 || k % size == 0) {
            return;  // 无需旋转
        }
        
        // 标准化k值，使其在[0, size-1]范围内
        k = k % size;
        if (k < 0) {
            k += size;  // 转换为正向旋转
        }
        
        // 向右旋转k步相当于将倒数第k个节点作为新的头节点
        if (k > 0) {
            // 找到新的头节点（倒数第k个节点）
            Node<T>* newHead = head;
            for (int i = 0; i < size - k; i++) {
                newHead = newHead->next;
            }
            
            // 更新头节点
            head = newHead;
        }
    }
    
    /**
     * 打印链表内容
     * 时间复杂度：O(n)
     */
    void printList() const {
        if (isEmpty()) {
            std::cout << "List is empty" << std::endl;
            return;
        }
        
        Node<T>* current = head;
        std::cout << "List: ";
        do {
            std::cout << current->data;
            if (current->next != head) {
                std::cout << " <-> ";
            }
            current = current->next;
        } while (current != head);
        std::cout << " (circular)" << std::endl;
    }
    
    /**
     * 打印链表大小
     */
    void printSize() const {
        std::cout << "List size: " << size << std::endl;
    }
};

/**
 * 测试双向循环链表的各种操作
 */
void testDoublyCircularLinkedList() {
    std::cout << "=== 测试双向循环链表 ===" << std::endl;
    
    // 创建链表实例
    DoublyCircularLinkedList<int> list;
    
    // 测试插入操作
    std::cout << "\n1. 测试插入操作:" << std::endl;
    std::cout << "插入10, 20, 30, 40, 50" << std::endl;
    list.insertAtTail(10);
    list.insertAtTail(20);
    list.insertAtTail(30);
    list.insertAtTail(40);
    list.insertAtTail(50);
    list.printList();
    list.printSize();
    
    std::cout << "\n在头部插入5:" << std::endl;
    list.insertAtHead(5);
    list.printList();
    
    std::cout << "\n在位置3插入25:" << std::endl;
    list.insertAtPosition(3, 25);
    list.printList();
    
    // 测试遍历操作
    std::cout << "\n2. 测试遍历操作:" << std::endl;
    
    std::cout << "正向遍历: ";
    auto forward = list.traverseForward();
    for (size_t i = 0; i < forward.size(); i++) {
        std::cout << forward[i];
        if (i < forward.size() - 1) {
            std::cout << " -> ";
        }
    }
    std::cout << std::endl;
    
    std::cout << "反向遍历: ";
    auto backward = list.traverseBackward();
    for (size_t i = 0; i < backward.size(); i++) {
        std::cout << backward[i];
        if (i < backward.size() - 1) {
            std::cout << " -> ";
        }
    }
    std::cout << std::endl;
    
    // 测试查找和访问操作
    std::cout << "\n3. 测试查找和访问操作:" << std::endl;
    
    int value = 25;
    int index = list.search(value);
    std::cout << "查找值 " << value << ": 索引 = " << index << std::endl;
    
    index = 3;
    value = list.get(index);
    std::cout << "索引 " << index << " 的值 = " << value << std::endl;
    
    std::cout << "设置索引2的值为15:" << std::endl;
    list.set(2, 15);
    list.printList();
    
    // 测试删除操作
    std::cout << "\n4. 测试删除操作:" << std::endl;
    
    std::cout << "删除头部元素:" << std::endl;
    value = list.deleteHead();
    std::cout << "删除的值 = " << value << std::endl;
    list.printList();
    
    std::cout << "删除尾部元素:" << std::endl;
    value = list.deleteTail();
    std::cout << "删除的值 = " << value << std::endl;
    list.printList();
    
    std::cout << "删除索引2的元素:" << std::endl;
    value = list.deleteAtPosition(2);
    std::cout << "删除的值 = " << value << std::endl;
    list.printList();
    
    std::cout << "删除值20:" << std::endl;
    bool deleted = list.deleteByValue(20);
    std::cout << "删除 " << (deleted ? "成功" : "失败") << std::endl;
    list.printList();
    
    // 测试反转操作
    std::cout << "\n5. 测试反转操作:" << std::endl;
    list.reverse();
    std::cout << "反转后:" << std::endl;
    list.printList();
    
    // 测试旋转操作
    std::cout << "\n6. 测试旋转操作:" << std::endl;
    
    std::cout << "向右旋转1步:" << std::endl;
    list.rotate(1);
    list.printList();
    
    std::cout << "向左旋转2步:" << std::endl;
    list.rotate(-2);
    list.printList();
    
    // 测试边界情况
    std::cout << "\n7. 测试边界情况:" << std::endl;
    
    std::cout << "清空链表:" << std::endl;
    list.clear();
    list.printList();
    list.printSize();
    
    std::cout << "空链表插入元素:" << std::endl;
    list.insertAtTail(100);
    list.printList();
    
    std::cout << "单节点链表删除:" << std::endl;
    value = list.deleteHead();
    std::cout << "删除的值 = " << value << std::endl;
    list.printList();
    
    // 测试复制构造函数
    std::cout << "\n8. 测试复制构造函数:" << std::endl;
    DoublyCircularLinkedList<int> list1;
    list1.insertAtTail(10);
    list1.insertAtTail(20);
    list1.insertAtTail(30);
    
    DoublyCircularLinkedList<int> list2(list1);  // 复制构造
    std::cout << "原始链表:" << std::endl;
    list1.printList();
    std::cout << "复制的链表:" << std::endl;
    list2.printList();
    
    // 修改原始链表，确保复制是深拷贝
    list1.insertAtHead(5);
    std::cout << "修改原始链表后:" << std::endl;
    list1.printList();
    list2.printList();
    
    // 测试异常处理
    std::cout << "\n9. 测试异常处理:" << std::endl;
    try {
        list2.get(10);  // 越界访问
    } catch (const std::exception& e) {
        std::cout << "异常捕获: " << e.what() << std::endl;
    }
    
    try {
        list.clear();  // 清空空链表，应该不会抛出异常
        list.deleteHead();  // 从空链表删除，应该抛出异常
    } catch (const std::exception& e) {
        std::cout << "异常捕获: " << e.what() << std::endl;
    }
}

int main() {
    testDoublyCircularLinkedList();
    return 0;
}

===============================================

文件: doubly_circular_linked_list.py
===============================================
#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
双向循环链表实现 (Python版本)

算法思路：
双向循环链表是一种线性数据结构，每个节点都有指向前驱和后继节点的指针，
并且尾节点指向头节点，形成一个环。

应用场景：
1. 操作系统：内存管理和进程调度
2. 浏览器：历史记录和标签页管理
3. 音乐播放器：播放列表管理
4. 游戏开发：对象管理

时间复杂度：
- 插入操作：
  - 在头部/尾部插入：O(1)
  - 在指定位置插入：O(n)
- 删除操作：
  - 删除头部/尾部：O(1)
  - 删除指定位置：O(n)
  - 按值删除：O(n)
- 查找操作：O(n)
- 遍历操作：O(n)
- 其他操作：
  - 反转：O(n)
  - 旋转：O(n)
  - 清空：O(n)

空间复杂度：O(n)
"""

class Node:
    """链表节点类"""
    
    def __init__(self, val):
        """
        构造函数
        :param val: 节点数据值
        """
        self.data = val
        self.prev = self  # 前驱节点指针
        self.next = self  # 后继节点指针

class DoublyCircularLinkedList:
    """双向循环链表类"""
    
    def __init__(self):
        """构造函数 - 创建空链表"""
        self.head = None  # 头节点指针
        self.size = 0     # 链表大小
    
    def is_empty(self):
        """
        检查链表是否为空
        :return: 链表是否为空
        """
        return self.head is None
    
    def _is_valid_index(self, index):
        """
        检查索引是否有效
        :param index: 要检查的索引
        :return: 索引是否有效
        """
        return 0 <= index < self.size
    
    def _get_node_at(self, index):
        """
        获取指定索引的节点
        :param index: 要获取的节点索引
        :return: 对应索引的节点
        """
        if not self._is_valid_index(index):
            raise IndexError("索引超出范围")
        
        # 优化：根据索引位置选择从头还是从尾开始遍历
        if index <= self.size // 2:
            # 从头开始遍历
            current = self.head
            for i in range(index):
                current = current.next
        else:
            # 从尾开始遍历（尾部是head.prev）
            current = self.head.prev
            for i in range(self.size - 1, index, -1):
                current = current.prev
        
        return current
    
    def insert_at_head(self, value):
        """
        在链表头部插入元素
        时间复杂度：O(1)
        :param value: 要插入的值
        """
        new_node = Node(value)
        
        if self.is_empty():
            # 空链表情况
            self.head = new_node
        else:
            # 非空链表，插入到头部
            tail = self.head.prev
            
            # 连接新节点与尾节点
            new_node.prev = tail
            tail.next = new_node
            
            # 连接新节点与头节点
            new_node.next = self.head
            self.head.prev = new_node
            
            # 更新头节点
            self.head = new_node
        
        self.size += 1
    
    def insert_at_tail(self, value):
        """
        在链表尾部插入元素
        时间复杂度：O(1)
        :param value: 要插入的值
        """
        new_node = Node(value)
        
        if self.is_empty():
            # 空链表情况
            self.head = new_node
        else:
            # 非空链表，插入到尾部
            tail = self.head.prev
            
            # 连接尾节点与新节点
            tail.next = new_node
            new_node.prev = tail
            
            # 连接新节点与头节点
            new_node.next = self.head
            self.head.prev = new_node
        
        self.size += 1
    
    def insert_at_position(self, index, value):
        """
        在指定位置插入元素
        时间复杂度：O(n)
        :param index: 插入位置
        :param value: 要插入的值
        """
        if index == 0:
            # 在头部插入
            self.insert_at_head(value)
            return
        
        if index == self.size:
            # 在尾部插入
            self.insert_at_tail(value)
            return
        
        # 检查索引是否有效
        if not self._is_valid_index(index):
            raise IndexError("索引超出范围")
        
        # 找到插入位置的前一个节点
        prev_node = self._get_node_at(index - 1)
        next_node = prev_node.next
        
        # 创建新节点
        new_node = Node(value)
        
        # 建立连接
        new_node.prev = prev_node
        new_node.next = next_node
        prev_node.next = new_node
        next_node.prev = new_node
        
        self.size += 1
    
    def delete_head(self):
        """
        删除链表头部元素
        时间复杂度：O(1)
        :return: 被删除的元素值
        """
        if self.is_empty():
            raise RuntimeError("无法从空链表删除")
        
        old_head = self.head
        value = old_head.data
        
        if self.size == 1:
            # 链表只有一个节点
            self.head = None
        else:
            # 链表有多个节点
            tail = self.head.prev
            new_head = self.head.next
            
            # 更新连接
            tail.next = new_head
            new_head.prev = tail
            
            # 更新头节点
            self.head = new_head
        
        self.size -= 1
        return value
    
    def delete_tail(self):
        """
        删除链表尾部元素
        时间复杂度：O(1)
        :return: 被删除的元素值
        """
        if self.is_empty():
            raise RuntimeError("无法从空链表删除")
        
        tail = self.head.prev
        value = tail.data
        
        if self.size == 1:
            # 链表只有一个节点
            self.head = None
        else:
            # 链表有多个节点
            new_tail = tail.prev
            
            # 更新连接
            new_tail.next = self.head
            self.head.prev = new_tail
        
        self.size -= 1
        return value
    
    def delete_at_position(self, index):
        """
        删除指定位置的元素
        时间复杂度：O(n)
        :param index: 要删除的元素位置
        :return: 被删除的元素值
        """
        if self.is_empty():
            raise RuntimeError("无法从空链表删除")
        
        if not self._is_valid_index(index):
            raise IndexError("索引超出范围")
        
        if index == 0:
            return self.delete_head()
        
        if index == self.size - 1:
            return self.delete_tail()
        
        # 找到要删除的节点
        node_to_delete = self._get_node_at(index)
        value = node_to_delete.data
        
        # 更新连接
        prev_node = node_to_delete.prev
        next_node = node_to_delete.next
        
        prev_node.next = next_node
        next_node.prev = prev_node
        
        self.size -= 1
        return value
    
    def delete_by_value(self, value):
        """
        删除第一个出现的指定值的元素
        时间复杂度：O(n)
        :param value: 要删除的值
        :return: 是否成功删除
        """
        if self.is_empty():
            return False
        
        # 特殊情况：头节点就是要删除的节点
        if self.head.data == value:
            self.delete_head()
            return True
        
        # 遍历链表查找值
        current = self.head.next
        while current != self.head:
            if current.data == value:
                # 找到要删除的节点
                prev_node = current.prev
                next_node = current.next
                
                # 更新连接
                prev_node.next = next_node
                next_node.prev = prev_node
                
                self.size -= 1
                return True
            current = current.next
        
        # 未找到值
        return False
    
    def traverse_forward(self):
        """
        正向遍历链表，将元素存入列表返回
        时间复杂度：O(n)
        :return: 包含链表元素的列表
        """
        result = []
        if self.is_empty():
            return result
        
        current = self.head
        while True:
            result.append(current.data)
            current = current.next
            if current == self.head:
                break
        
        return result
    
    def traverse_backward(self):
        """
        反向遍历链表，将元素存入列表返回
        时间复杂度：O(n)
        :return: 包含链表元素的列表（反向）
        """
        result = []
        if self.is_empty():
            return result
        
        current = self.head.prev  # 从尾节点开始
        while True:
            result.append(current.data)
            current = current.prev
            if current == self.head.prev:
                break
        
        return result
    
    def search(self, value):
        """
        查找第一个出现的指定值的索引
        时间复杂度：O(n)
        :param value: 要查找的值
        :return: 元素索引，如果未找到返回-1
        """
        if self.is_empty():
            return -1
        
        index = 0
        current = self.head
        while True:
            if current.data == value:
                return index
            current = current.next
            index += 1
            if current == self.head:
                break
        
        return -1
    
    def get(self, index):
        """
        获取指定索引的元素值
        时间复杂度：O(n)
        :param index: 元素索引
        :return: 元素值
        """
        node = self._get_node_at(index)
        return node.data
    
    def set(self, index, value):
        """
        设置指定索引的元素值
        时间复杂度：O(n)
        :param index: 元素索引
        :param value: 新的元素值
        """
        node = self._get_node_at(index)
        node.data = value
    
    def get_size(self):
        """
        获取链表大小
        时间复杂度：O(1)
        :return: 链表中元素的数量
        """
        return self.size
    
    def clear(self):
        """
        清空链表
        时间复杂度：O(1)
        """
        self.head = None
        self.size = 0
    
    def reverse(self):
        """
        反转链表
        时间复杂度：O(n)
        """
        if self.is_empty() or self.size == 1:
            return  # 空链表或只有一个节点不需要反转
        
        # 保存头节点和尾节点
        current = self.head
        tail = self.head.prev
        
        # 交换每个节点的prev和next指针
        while True:
            # 交换prev和next
            temp = current.prev
            current.prev = current.next
            current.next = temp
            
            # 移动到下一个节点（现在是prev指针）
            current = current.prev
            
            if current == self.head:
                break
        
        # 更新头节点为原来的尾节点
        self.head = tail
    
    def rotate(self, k):
        """
        旋转链表
        时间复杂度：O(n)
        :param k: 旋转步数，正数表示向右旋转，负数表示向左旋转
        """
        if self.is_empty() or self.size == 1 or k % self.size == 0:
            return  # 无需旋转
        
        # 标准化k值，使其在[0, size-1]范围内
        k = k % self.size
        if k < 0:
            k += self.size  # 转换为正向旋转
        
        # 向右旋转k步相当于将倒数第k个节点作为新的头节点
        if k > 0:
            # 找到新的头节点（倒数第k个节点）
            new_head = self.head
            for i in range(self.size - k):
                new_head = new_head.next
            
            # 更新头节点
            self.head = new_head
    
    def print_list(self):
        """
        打印链表内容
        时间复杂度：O(n)
        """
        if self.is_empty():
            print("List is empty")
            return
        
        current = self.head
        print("List: ", end="")
        while True:
            print(current.data, end="")
            if current.next != self.head:
                print(" <-> ", end="")
            current = current.next
            if current == self.head:
                break
        print(" (circular)")
    
    def print_size(self):
        """
        打印链表大小
        """
        print(f"List size: {self.size}")
    
    @staticmethod
    def test_doubly_circular_linked_list():
        """测试双向循环链表"""
        print("=== 测试双向循环链表 ===")
        
        # 创建链表实例
        list_obj = DoublyCircularLinkedList()
        
        # 测试插入操作
        print("\n1. 测试插入操作:")
        print("插入10, 20, 30, 40, 50")
        list_obj.insert_at_tail(10)
        list_obj.insert_at_tail(20)
        list_obj.insert_at_tail(30)
        list_obj.insert_at_tail(40)
        list_obj.insert_at_tail(50)
        list_obj.print_list()
        list_obj.print_size()
        
        print("\n在头部插入5:")
        list_obj.insert_at_head(5)
        list_obj.print_list()
        
        print("\n在位置3插入25:")
        list_obj.insert_at_position(3, 25)
        list_obj.print_list()
        
        # 测试遍历操作
        print("\n2. 测试遍历操作:")
        
        print("正向遍历:", list_obj.traverse_forward())
        print("反向遍历:", list_obj.traverse_backward())
        
        # 测试查找和访问操作
        print("\n3. 测试查找和访问操作:")
        
        value = 25
        index = list_obj.search(value)
        print(f"查找值 {value}: 索引 = {index}")
        
        index = 3
        value = list_obj.get(index)
        print(f"索引 {index} 的值 = {value}")
        
        print("设置索引2的值为15:")
        list_obj.set(2, 15)
        list_obj.print_list()
        
        # 测试删除操作
        print("\n4. 测试删除操作:")
        
        print("删除头部元素:")
        value = list_obj.delete_head()
        print(f"删除的值 = {value}")
        list_obj.print_list()
        
        print("删除尾部元素:")
        value = list_obj.delete_tail()
        print(f"删除的值 = {value}")
        list_obj.print_list()
        
        print("删除索引2的元素:")
        value = list_obj.delete_at_position(2)
        print(f"删除的值 = {value}")
        list_obj.print_list()
        
        print("删除值20:")
        deleted = list_obj.delete_by_value(20)
        print(f"删除 {'成功' if deleted else '失败'}")
        list_obj.print_list()
        
        # 测试反转操作
        print("\n5. 测试反转操作:")
        list_obj.reverse()
        print("反转后:")
        list_obj.print_list()
        
        # 测试旋转操作
        print("\n6. 测试旋转操作:")
        
        print("向右旋转1步:")
        list_obj.rotate(1)
        list_obj.print_list()
        
        print("向左旋转2步:")
        list_obj.rotate(-2)
        list_obj.print_list()
        
        # 测试边界情况
        print("\n7. 测试边界情况:")
        
        print("清空链表:")
        list_obj.clear()
        list_obj.print_list()
        list_obj.print_size()
        
        print("空链表插入元素:")
        list_obj.insert_at_tail(100)
        list_obj.print_list()
        
        print("单节点链表删除:")
        value = list_obj.delete_head()
        print(f"删除的值 = {value}")
        list_obj.print_list()
        
        # 性能测试
        print("\n=== 性能测试 ===")
        import time
        
        # 测试大量插入操作
        large_list = DoublyCircularLinkedList()
        
        start_time = time.time()
        for i in range(10000):
            large_list.insert_at_tail(i)
        insert_time = time.time() - start_time
        
        print(f"插入10000个元素时间: {insert_time*1000:.2f} ms")
        print(f"链表大小: {large_list.get_size()}")
        
        # 测试随机访问
        start_time = time.time()
        for i in range(1000):
            large_list.get(i * 10)
        access_time = time.time() - start_time
        
        print(f"1000次随机访问时间: {access_time*1000:.2f} ms")

if __name__ == "__main__":
    DoublyCircularLinkedList.test_doubly_circular_linked_list()

# ================================
# C++ 代码等效实现 (注释版)
'''
#include <iostream>
#include <stdexcept>
#include <vector>

class Node {
public:
    int data;
    Node* prev;
    Node* next;
    
    // 构造函数
    Node(int val) : data(val), prev(nullptr), next(nullptr) {}
};

class DoublyCircularLinkedList {
private:
    Node* head;
    int size;
    
public:
    // 构造函数
    DoublyCircularLinkedList() : head(nullptr), size(0) {}
    
    // 析构函数
    ~DoublyCircularLinkedList() {
        clear();
    }
    
    // 检查链表是否为空
    bool isEmpty() const {
        return size == 0;
    }
    
    // 获取链表大小
    int getSize() const {
        return size;
    }
    
    // 在头部插入节点
    void insertAtHead(int data) {
        Node* newNode = new Node(data);
        
        if (isEmpty()) {
            // 空链表
            newNode->prev = newNode;
            newNode->next = newNode;
            head = newNode;
        } else {
            Node* tail = head->prev;
            
            newNode->next = head;
            newNode->prev = tail;
            
            head->prev = newNode;
            tail->next = newNode;
            
            head = newNode;
        }
        
        size++;
    }
    
    // 在尾部插入节点
    void insertAtTail(int data) {
        if (isEmpty()) {
            insertAtHead(data);
            return;
        }
        
        Node* newNode = new Node(data);
        Node* tail = head->prev;
        
        newNode->next = head;
        newNode->prev = tail;
        
        tail->next = newNode;
        head->prev = newNode;
        
        size++;
    }
    
    // 在指定位置插入节点
    void insertAtPosition(int position, int data) {
        if (position < 0 || position > size) {
            throw std::invalid_argument("Invalid insertion position");
        }
        
        if (position == 0) {
            insertAtHead(data);
        } else if (position == size) {
            insertAtTail(data);
        } else {
            Node* newNode = new Node(data);
            Node* current = head;
            
            // 优化查找位置
            if (position <= size / 2) {
                for (int i = 0; i < position - 1; i++) {
                    current = current->next;
                }
            } else {
                current = head->prev;
                for (int i = 0; i < size - position; i++) {
                    current = current->prev;
                }
            }
            
            newNode->next = current->next;
            newNode->prev = current;
            current->next->prev = newNode;
            current->next = newNode;
            
            size++;
        }
    }
    
    // 删除头节点
    int deleteHead() {
        if (isEmpty()) {
            throw std::runtime_error("Cannot delete from empty list");
        }
        
        int data = head->data;
        Node* temp = head;
        
        if (size == 1) {
            head = nullptr;
        } else {
            Node* tail = head->prev;
            Node* newHead = head->next;
            
            tail->next = newHead;
            newHead->prev = tail;
            head = newHead;
        }
        
        delete temp;
        size--;
        return data;
    }
    
    // 删除尾节点
    int deleteTail() {
        if (isEmpty()) {
            throw std::runtime_error("Cannot delete from empty list");
        }
        
        if (size == 1) {
            return deleteHead();
        }
        
        Node* tail = head->prev;
        int data = tail->data;
        
        tail->prev->next = head;
        head->prev = tail->prev;
        
        delete tail;
        size--;
        return data;
    }
    
    // 删除指定位置的节点
    int deleteAtPosition(int position) {
        if (position < 0 || position >= size) {
            throw std::invalid_argument("Invalid deletion position");
        }
        
        if (position == 0) {
            return deleteHead();
        } else if (position == size - 1) {
            return deleteTail();
        } else {
            Node* current = head;
            
            // 优化查找位置
            if (position <= size / 2) {
                for (int i = 0; i < position; i++) {
                    current = current->next;
                }
            } else {
                current = head->prev;
                for (int i = 0; i < size - 1 - position; i++) {
                    current = current->prev;
                }
            }
            
            int data = current->data;
            current->prev->next = current->next;
            current->next->prev = current->prev;
            
            delete current;
            size--;
            return data;
        }
    }
    
    // 删除指定值的节点
    bool deleteByValue(int value) {
        if (isEmpty()) {
            return false;
        }
        
        Node* current = head;
        for (int i = 0; i < size; i++) {
            if (current->data == value) {
                if (size == 1) {
                    delete current;
                    head = nullptr;
                } else {
                    current->prev->next = current->next;
                    current->next->prev = current->prev;
                    
                    if (current == head) {
                        head = current->next;
                    }
                    
                    delete current;
                }
                
                size--;
                return true;
            }
            
            current = current->next;
        }
        
        return false;
    }
    
    // 查找值的位置
    int search(int value) const {
        if (isEmpty()) {
            return -1;
        }
        
        Node* current = head;
        for (int i = 0; i < size; i++) {
            if (current->data == value) {
                return i;
            }
            current = current->next;
        }
        
        return -1;
    }
    
    // 获取指定位置的值
    int get(int position) const {
        if (position < 0 || position >= size) {
            throw std::invalid_argument("Invalid position");
        }
        
        Node* current = head;
        if (position <= size / 2) {
            for (int i = 0; i < position; i++) {
                current = current->next;
            }
        } else {
            current = head->prev;
            for (int i = 0; i < size - 1 - position; i++) {
                current = current->prev;
            }
        }
        
        return current->data;
    }
    
    // 设置指定位置的值
    void set(int position, int data) {
        if (position < 0 || position >= size) {
            throw std::invalid_argument("Invalid position");
        }
        
        Node* current = head;
        if (position <= size / 2) {
            for (int i = 0; i < position; i++) {
                current = current->next;
            }
        } else {
            current = head->prev;
            for (int i = 0; i < size - 1 - position; i++) {
                current = current->prev;
            }
        }
        
        current->data = data;
    }
    
    // 正向遍历
    std::vector<int> traverseForward() const {
        std::vector<int> result;
        if (!isEmpty()) {
            Node* current = head;
            for (int i = 0; i < size; i++) {
                result.push_back(current->data);
                current = current->next;
            }
        }
        return result;
    }
    
    // 反向遍历
    std::vector<int> traverseBackward() const {
        std::vector<int> result;
        if (!isEmpty()) {
            Node* current = head->prev;
            for (int i = 0; i < size; i++) {
                result.push_back(current->data);
                current = current->prev;
            }
        }
        return result;
    }
    
    // 反转链表
    void reverse() {
        if (size <= 1) {
            return;
        }
        
        Node* current = head;
        for (int i = 0; i < size; i++) {
            // 交换prev和next
            std::swap(current->prev, current->next);
            // 移动到下一个节点
            current = current->prev;
        }
        
        head = head->prev;
    }
    
    // 旋转链表
    void rotate(int k) {
        if (size <= 1 || k % size == 0) {
            return;
        }
        
        k = k % size;
        
        Node* current = head;
        for (int i = 0; i < k - 1; i++) {
            current = current->next;
        }
        
        Node* newHead = current->next;
        Node* tail = head->prev;
        
        // 断开连接
        tail->next = head;
        head->prev = tail;
        
        // 更新头节点
        head = newHead;
    }
    
    // 清空链表
    void clear() {
        if (!isEmpty()) {
            Node* current = head;
            for (int i = 0; i < size; i++) {
                Node* next = current->next;
                delete current;
                current = next;
            }
        }
        
        head = nullptr;
        size = 0;
    }
};

// 测试函数
void testDoublyCircularLinkedList() {
    DoublyCircularLinkedList list;
    
    // 测试插入
    list.insertAtHead(10);
    list.insertAtTail(20);
    list.insertAtHead(5);
    
    // 测试遍历
    std::cout << "Forward traversal: ";
    for (int val : list.traverseForward()) {
        std::cout << val << " ";
    }
    std::cout << std::endl;
    
    // 其他测试...
}
'''

# ================================
# Java 代码等效实现 (注释版)
'''
import java.util.ArrayList;
import java.util.List;

public class DoublyCircularLinkedList {
    private class Node {
        int data;
        Node prev;
        Node next;
        
        Node(int data) {
            this.data = data;
            this.prev = null;
            this.next = null;
        }
    }
    
    private Node head;
    private int size;
    
    public DoublyCircularLinkedList() {
        this.head = null;
        this.size = 0;
    }
    
    public boolean isEmpty() {
        return size == 0;
    }
    
    public int size() {
        return size;
    }
    
    public void insertAtHead(int data) {
        Node newNode = new Node(data);
        
        if (isEmpty()) {
            newNode.prev = newNode;
            newNode.next = newNode;
            head = newNode;
        } else {
            Node tail = head.prev;
            
            newNode.next = head;
            newNode.prev = tail;
            
            head.prev = newNode;
            tail.next = newNode;
            
            head = newNode;
        }
        
        size++;
    }
    
    public void insertAtTail(int data) {
        if (isEmpty()) {
            insertAtHead(data);
            return;
        }
        
        Node newNode = new Node(data);
        Node tail = head.prev;
        
        newNode.next = head;
        newNode.prev = tail;
        
        tail.next = newNode;
        head.prev = newNode;
        
        size++;
    }
    
    public void insertAtPosition(int position, int data) {
        if (position < 0 || position > size) {
            throw new IllegalArgumentException("Invalid insertion position: " + position);
        }
        
        if (position == 0) {
            insertAtHead(data);
        } else if (position == size) {
            insertAtTail(data);
        } else {
            Node newNode = new Node(data);
            Node current = head;
            
            if (position <= size / 2) {
                for (int i = 0; i < position - 1; i++) {
                    current = current.next;
                }
            } else {
                current = head.prev;
                for (int i = 0; i < size - position; i++) {
                    current = current.prev;
                }
            }
            
            newNode.next = current.next;
            newNode.prev = current;
            current.next.prev = newNode;
            current.next = newNode;
            
            size++;
        }
    }
    
    public int deleteHead() {
        if (isEmpty()) {
            throw new IllegalStateException("Cannot delete from empty list");
        }
        
        int data = head.data;
        
        if (size == 1) {
            head = null;
        } else {
            Node tail = head.prev;
            Node newHead = head.next;
            
            tail.next = newHead;
            newHead.prev = tail;
            head = newHead;
        }
        
        size--;
        return data;
    }
    
    public int deleteTail() {
        if (isEmpty()) {
            throw new IllegalStateException("Cannot delete from empty list");
        }
        
        if (size == 1) {
            return deleteHead();
        }
        
        Node tail = head.prev;
        int data = tail.data;
        
        tail.prev.next = head;
        head.prev = tail.prev;
        
        size--;
        return data;
    }
    
    public int deleteAtPosition(int position) {
        if (position < 0 || position >= size) {
            throw new IllegalArgumentException("Invalid deletion position: " + position);
        }
        
        if (position == 0) {
            return deleteHead();
        } else if (position == size - 1) {
            return deleteTail();
        } else {
            Node current = head;
            
            if (position <= size / 2) {
                for (int i = 0; i < position; i++) {
                    current = current.next;
                }
            } else {
                current = head.prev;
                for (int i = 0; i < size - 1 - position; i++) {
                    current = current.prev;
                }
            }
            
            int data = current.data;
            current.prev.next = current.next;
            current.next.prev = current.prev;
            
            size--;
            return data;
        }
    }
    
    public boolean deleteByValue(int value) {
        if (isEmpty()) {
            return false;
        }
        
        Node current = head;
        for (int i = 0; i < size; i++) {
            if (current.data == value) {
                if (size == 1) {
                    head = null;
                } else {
                    current.prev.next = current.next;
                    current.next.prev = current.prev;
                    
                    if (current == head) {
                        head = current.next;
                    }
                }
                
                size--;
                return true;
            }
            
            current = current.next;
        }
        
        return false;
    }
    
    public int search(int value) {
        if (isEmpty()) {
            return -1;
        }
        
        Node current = head;
        for (int i = 0; i < size; i++) {
            if (current.data == value) {
                return i;
            }
            current = current.next;
        }
        
        return -1;
    }
    
    public int get(int position) {
        if (position < 0 || position >= size) {
            throw new IllegalArgumentException("Invalid position: " + position);
        }
        
        Node current = head;
        if (position <= size / 2) {
            for (int i = 0; i < position; i++) {
                current = current.next;
            }
        } else {
            current = head.prev;
            for (int i = 0; i < size - 1 - position; i++) {
                current = current.prev;
            }
        }
        
        return current.data;
    }
    
    public void set(int position, int data) {
        if (position < 0 || position >= size) {
            throw new IllegalArgumentException("Invalid position: " + position);
        }
        
        Node current = head;
        if (position <= size / 2) {
            for (int i = 0; i < position; i++) {
                current = current.next;
            }
        } else {
            current = head.prev;
            for (int i = 0; i < size - 1 - position; i++) {
                current = current.prev;
            }
        }
        
        current.data = data;
    }
    
    public List<Integer> traverseForward() {
        List<Integer> result = new ArrayList<>();
        if (!isEmpty()) {
            Node current = head;
            for (int i = 0; i < size; i++) {
                result.add(current.data);
                current = current.next;
            }
        }
        return result;
    }
    
    public List<Integer> traverseBackward() {
        List<Integer> result = new ArrayList<>();
        if (!isEmpty()) {
            Node current = head.prev;
            for (int i = 0; i < size; i++) {
                result.add(current.data);
                current = current.prev;
            }
        }
        return result;
    }
    
    public void reverse() {
        if (size <= 1) {
            return;
        }
        
        Node current = head;
        for (int i = 0; i < size; i++) {
            // 交换prev和next
            Node temp = current.prev;
            current.prev = current.next;
            current.next = temp;
            
            current = current.prev;
        }
        
        head = head.prev;
    }
    
    public void rotate(int k) {
        if (size <= 1 || k % size == 0) {
            return;
        }
        
        k = k % size;
        
        Node current = head;
        for (int i = 0; i < k - 1; i++) {
            current = current.next;
        }
        
        Node newHead = current.next;
        Node tail = head.prev;
        
        tail.next = head;
        head.prev = tail;
        
        head = newHead;
    }
    
    public void clear() {
        head = null;
        size = 0;
    }
    
    @Override
    public String toString() {
        return traverseForward().toString();
    }
    
    public static void main(String[] args) {
        DoublyCircularLinkedList list = new DoublyCircularLinkedList();
        // 测试代码...
    }
}
'''






===============================================

文件: doubly_circular_linked_list_1.py
===============================================
#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
双向循环链表实现 (Python版本)

算法思路：
双向循环链表是一种线性数据结构，每个节点都有指向前驱和后继节点的指针，
并且尾节点指向头节点，形成一个环。

应用场景：
1. 操作系统：内存管理和进程调度
2. 浏览器：历史记录和标签页管理
3. 音乐播放器：播放列表管理
4. 游戏开发：对象管理

时间复杂度：
- 插入操作：
  - 在头部/尾部插入：O(1)
  - 在指定位置插入：O(n)
- 删除操作：
  - 删除头部/尾部：O(1)
  - 删除指定位置：O(n)
  - 按值删除：O(n)
- 查找操作：O(n)
- 遍历操作：O(n)
- 其他操作：
  - 反转：O(n)
  - 旋转：O(n)
  - 清空：O(n)

空间复杂度：O(n)

相关题目：
1. LeetCode LCR 155. 将二叉搜索树转化为排序的双向链表
2. LeetCode 426. 将二叉搜索树转化为排序的双向链表
"""

import time

class Node:
    """链表节点类"""
    
    def __init__(self, val):
        """
        构造函数
        :param val: 节点数据值
        """
        self.data = val
        self.prev = self  # 前驱节点指针
        self.next = self  # 后继节点指针

class DoublyCircularLinkedList:
    """双向循环链表类"""
    
    def __init__(self):
        """构造函数 - 创建空链表"""
        self.head = None  # 头节点指针
        self.size = 0     # 链表大小
    
    def is_empty(self):
        """
        检查链表是否为空
        :return: 链表是否为空
        """
        return self.head is None
    
    def _is_valid_index(self, index):
        """
        检查索引是否有效
        :param index: 要检查的索引
        :return: 索引是否有效
        """
        return 0 <= index < self.size
    
    def _get_node_at(self, index):
        """
        获取指定索引的节点
        :param index: 要获取的节点索引
        :return: 对应索引的节点
        """
        if not self._is_valid_index(index):
            raise IndexError("索引超出范围")
        
        # 优化：根据索引位置选择从头还是从尾开始遍历
        if index <= self.size // 2:
            # 从头开始遍历
            current = self.head
            for i in range(index):
                current = current.next
        else:
            # 从尾开始遍历（尾部是head.prev）
            current = self.head.prev
            for i in range(self.size - 1, index, -1):
                current = current.prev
        
        return current
    
    def insert_at_head(self, value):
        """
        在链表头部插入元素
        时间复杂度：O(1)
        :param value: 要插入的值
        """
        new_node = Node(value)
        
        if self.is_empty():
            # 空链表情况
            self.head = new_node
        else:
            # 非空链表，插入到头部
            tail = self.head.prev
            
            # 连接新节点与尾节点
            new_node.prev = tail
            tail.next = new_node
            
            # 连接新节点与头节点
            new_node.next = self.head
            if self.head is not None:
                self.head.prev = new_node
            
            # 更新头节点
            self.head = new_node
        
        self.size += 1
    
    def insert_at_tail(self, value):
        """
        在链表尾部插入元素
        时间复杂度：O(1)
        :param value: 要插入的值
        """
        new_node = Node(value)
        
        if self.is_empty():
            # 空链表情况
            self.head = new_node
        else:
            # 非空链表，插入到尾部
            if self.head is not None:
                tail = self.head.prev
                
                # 连接尾节点与新节点
                tail.next = new_node
                new_node.prev = tail
                
                # 连接新节点与头节点
                new_node.next = self.head
                self.head.prev = new_node
        
        self.size += 1
    
    def insert_at_position(self, index, value):
        """
        在指定位置插入元素
        时间复杂度：O(n)
        :param index: 插入位置
        :param value: 要插入的值
        """
        if index == 0:
            # 在头部插入
            self.insert_at_head(value)
            return
        
        if index == self.size:
            # 在尾部插入
            self.insert_at_tail(value)
            return
        
        # 检查索引是否有效
        if not self._is_valid_index(index):
            raise IndexError("索引超出范围")
        
        # 找到插入位置的前一个节点
        prev_node = self._get_node_at(index - 1)
        if prev_node is not None:
            next_node = prev_node.next
            
            # 创建新节点
            new_node = Node(value)
            
            # 建立连接
            new_node.prev = prev_node
            new_node.next = next_node
            prev_node.next = new_node
            next_node.prev = new_node
        
        self.size += 1
    
    def delete_head(self):
        """
        删除链表头部元素
        时间复杂度：O(1)
        :return: 被删除的元素值
        """
        if self.is_empty():
            raise RuntimeError("无法从空链表删除")
        
        old_head = self.head
        value = old_head.data if old_head is not None else 0
        
        if self.size == 1:
            # 链表只有一个节点
            self.head = None
        else:
            # 链表有多个节点
            if self.head is not None:
                tail = self.head.prev
                new_head = self.head.next
                
                # 更新连接
                tail.next = new_head
                new_head.prev = tail
                
                # 更新头节点
                self.head = new_head
        
        self.size -= 1
        return value
    
    def delete_tail(self):
        """
        删除链表尾部元素
        时间复杂度：O(1)
        :return: 被删除的元素值
        """
        if self.is_empty():
            raise RuntimeError("无法从空链表删除")
        
        if self.head is not None:
            tail = self.head.prev
            value = tail.data if tail is not None else 0
            
            if self.size == 1:
                # 链表只有一个节点
                self.head = None
            else:
                # 链表有多个节点
                if tail is not None:
                    new_tail = tail.prev
                    
                    # 更新连接
                    if new_tail is not None:
                        new_tail.next = self.head
                    self.head.prev = new_tail
        
        self.size -= 1
        return value
    
    def delete_at_position(self, index):
        """
        删除指定位置的元素
        时间复杂度：O(n)
        :param index: 要删除的元素位置
        :return: 被删除的元素值
        """
        if self.is_empty():
            raise RuntimeError("无法从空链表删除")
        
        if not self._is_valid_index(index):
            raise IndexError("索引超出范围")
        
        if index == 0:
            return self.delete_head()
        
        if index == self.size - 1:
            return self.delete_tail()
        
        # 找到要删除的节点
        node_to_delete = self._get_node_at(index)
        value = node_to_delete.data if node_to_delete is not None else 0
        
        # 更新连接
        if node_to_delete is not None:
            prev_node = node_to_delete.prev
            next_node = node_to_delete.next
            
            if prev_node is not None and next_node is not None:
                prev_node.next = next_node
                next_node.prev = prev_node
        
        self.size -= 1
        return value
    
    def delete_by_value(self, value):
        """
        删除第一个出现的指定值的元素
        时间复杂度：O(n)
        :param value: 要删除的值
        :return: 是否成功删除
        """
        if self.is_empty():
            return False
        
        # 特殊情况：头节点就是要删除的节点
        if self.head is not None and self.head.data == value:
            self.delete_head()
            return True
        
        # 遍历链表查找值
        if self.head is not None:
            current = self.head.next
            while current != self.head:
                if current.data == value:
                    # 找到要删除的节点
                    prev_node = current.prev
                    next_node = current.next
                    
                    # 更新连接
                    if prev_node is not None and next_node is not None:
                        prev_node.next = next_node
                        next_node.prev = prev_node
                    
                    self.size -= 1
                    return True
                current = current.next
        
        # 未找到值
        return False
    
    def traverse_forward(self):
        """
        正向遍历链表，将元素存入列表返回
        时间复杂度：O(n)
        :return: 包含链表元素的列表
        """
        result = []
        if self.is_empty() or self.head is None:
            return result
        
        current = self.head
        while True:
            if current is not None:
                result.append(current.data)
            current = current.next if current is not None else None
            if current == self.head:
                break
        
        return result
    
    def traverse_backward(self):
        """
        反向遍历链表，将元素存入列表返回
        时间复杂度：O(n)
        :return: 包含链表元素的列表（反向）
        """
        result = []
        if self.is_empty() or self.head is None:
            return result
        
        current = self.head.prev  # 从尾节点开始
        while True:
            if current is not None:
                result.append(current.data)
            current = current.prev if current is not None else None
            if current == self.head.prev:
                break
        
        return result
    
    def search(self, value):
        """
        查找第一个出现的指定值的索引
        时间复杂度：O(n)
        :param value: 要查找的值
        :return: 元素索引，如果未找到返回-1
        """
        if self.is_empty() or self.head is None:
            return -1
        
        index = 0
        current = self.head
        while True:
            if current is not None and current.data == value:
                return index
            current = current.next if current is not None else None
            index += 1
            if current == self.head:
                break
        
        return -1
    
    def get(self, index):
        """
        获取指定索引的元素值
        时间复杂度：O(n)
        :param index: 元素索引
        :return: 元素值
        """
        node = self._get_node_at(index)
        return node.data if node is not None else 0
    
    def set(self, index, value):
        """
        设置指定索引的元素值
        时间复杂度：O(n)
        :param index: 元素索引
        :param value: 新的元素值
        """
        node = self._get_node_at(index)
        if node is not None:
            node.data = value
    
    def get_size(self):
        """
        获取链表大小
        时间复杂度：O(1)
        :return: 链表中元素的数量
        """
        return self.size
    
    def clear(self):
        """
        清空链表
        时间复杂度：O(1)
        """
        self.head = None
        self.size = 0
    
    def reverse(self):
        """
        反转链表
        时间复杂度：O(n)
        """
        if self.is_empty() or self.size == 1:
            return  # 空链表或只有一个节点不需要反转
        
        # 保存头节点和尾节点
        current = self.head
        if self.head is not None:
            tail = self.head.prev
        
            # 交换每个节点的prev和next指针
            while True:
                if current is not None:
                    # 交换prev和next
                    temp = current.prev
                    current.prev = current.next
                    current.next = temp
                
                # 移动到下一个节点（现在是prev指针）
                current = current.prev if current is not None else None
                
                if current == self.head:
                    break
            
            # 更新头节点为原来的尾节点
            self.head = tail
    
    def rotate(self, k):
        """
        旋转链表
        时间复杂度：O(n)
        :param k: 旋转步数，正数表示向右旋转，负数表示向左旋转
        """
        if self.is_empty() or self.size == 1 or k % self.size == 0:
            return  # 无需旋转
        
        # 标准化k值，使其在[0, size-1]范围内
        k = k % self.size
        if k < 0:
            k += self.size  # 转换为正向旋转
        
        # 向右旋转k步相当于将倒数第k个节点作为新的头节点
        if k > 0:
            # 找到新的头节点（倒数第k个节点）
            new_head = self.head
            for i in range(self.size - k):
                new_head = new_head.next
            
            # 更新头节点
            self.head = new_head
    
    def print_list(self):
        """
        打印链表内容
        时间复杂度：O(n)
        """
        if self.is_empty():
            print("List is empty")
            return
        
        current = self.head
        print("List: ", end="")
        while True:
            print(current.data, end="")
            if current.next != self.head:
                print(" <-> ", end="")
            current = current.next
            if current == self.head:
                break
        print(" (circular)")
    
    def print_size(self):
        """
        打印链表大小
        """
        print(f"List size: {self.size}")
    
    @staticmethod
    def test_doubly_circular_linked_list():
        """测试双向循环链表"""
        print("=== 测试双向循环链表 ===")
        
        # 创建链表实例
        list_obj = DoublyCircularLinkedList()
        
        # 测试插入操作
        print("\n1. 测试插入操作:")
        print("插入10, 20, 30, 40, 50")
        list_obj.insert_at_tail(10)
        list_obj.insert_at_tail(20)
        list_obj.insert_at_tail(30)
        list_obj.insert_at_tail(40)
        list_obj.insert_at_tail(50)
        list_obj.print_list()
        list_obj.print_size()
        
        print("\n在头部插入5:")
        list_obj.insert_at_head(5)
        list_obj.print_list()
        
        print("\n在位置3插入25:")
        list_obj.insert_at_position(3, 25)
        list_obj.print_list()
        
        # 测试遍历操作
        print("\n2. 测试遍历操作:")
        
        print("正向遍历:", list_obj.traverse_forward())
        print("反向遍历:", list_obj.traverse_backward())
        
        # 测试查找和访问操作
        print("\n3. 测试查找和访问操作:")
        
        value = 25
        index = list_obj.search(value)
        print(f"查找值 {value}: 索引 = {index}")
        
        index = 3
        value = list_obj.get(index)
        print(f"索引 {index} 的值 = {value}")
        
        print("设置索引2的值为15:")
        list_obj.set(2, 15)
        list_obj.print_list()
        
        # 测试删除操作
        print("\n4. 测试删除操作:")
        
        print("删除头部元素:")
        value = list_obj.delete_head()
        print(f"删除的值 = {value}")
        list_obj.print_list()
        
        print("删除尾部元素:")
        value = list_obj.delete_tail()
        print(f"删除的值 = {value}")
        list_obj.print_list()
        
        print("删除索引2的元素:")
        value = list_obj.delete_at_position(2)
        print(f"删除的值 = {value}")
        list_obj.print_list()
        
        print("删除值20:")
        deleted = list_obj.delete_by_value(20)
        print(f"删除 {'成功' if deleted else '失败'}")
        list_obj.print_list()
        
        # 测试反转操作
        print("\n5. 测试反转操作:")
        list_obj.reverse()
        print("反转后:")
        list_obj.print_list()
        
        # 测试旋转操作
        print("\n6. 测试旋转操作:")
        
        print("向右旋转1步:")
        list_obj.rotate(1)
        list_obj.print_list()
        
        print("向左旋转2步:")
        list_obj.rotate(-2)
        list_obj.print_list()
        
        # 测试边界情况
        print("\n7. 测试边界情况:")
        
        print("清空链表:")
        list_obj.clear()
        list_obj.print_list()
        list_obj.print_size()
        
        print("空链表插入元素:")
        list_obj.insert_at_tail(100)
        list_obj.print_list()
        
        print("单节点链表删除:")
        value = list_obj.delete_head()
        print(f"删除的值 = {value}")
        list_obj.print_list()
        
        # 性能测试
        print("\n=== 性能测试 ===")
        
        # 测试大量插入操作
        large_list = DoublyCircularLinkedList()
        
        start_time = time.time()
        for i in range(10000):
            large_list.insert_at_tail(i)
        insert_time = time.time() - start_time
        
        print(f"插入10000个元素时间: {insert_time*1000:.2f} ms")
        print(f"链表大小: {large_list.get_size()}")
        
        # 测试随机访问
        start_time = time.time()
        for i in range(1000):
            large_list.get(i * 10)
        access_time = time.time() - start_time
        
        print(f"1000次随机访问时间: {access_time*1000:.2f} ms")

if __name__ == "__main__":
    DoublyCircularLinkedList.test_doubly_circular_linked_list()

===============================================

文件: event_sweep.py
===============================================
#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
事件排序 - 时间扫描线算法实现 (Python版本)

算法思路：
时间扫描线算法是一种用于解决几何和调度问题的有效技术。
核心思想是将问题中的事件按时间排序，然后按顺序处理这些事件。

应用场景：
1. 计算几何：矩形面积、线段相交
2. 资源调度：会议室安排、任务调度
3. 图形学：可见性分析、遮挡处理

时间复杂度：O(n log n)
空间复杂度：O(n)
"""

import heapq
from collections import defaultdict

class Event:
    """事件类，用于时间扫描线算法"""
    
    def __init__(self, time, event_type, data):
        """
        构造函数
        :param time: 事件发生的时间
        :param event_type: 事件类型：0表示开始，1表示结束
        :param data: 事件关联的数据
        """
        self.time = time
        self.type = event_type
        self.data = data
    
    def __lt__(self, other):
        """用于事件排序"""
        # 首先按照时间排序
        if self.time != other.time:
            return self.time < other.time
        # 时间相同时，结束事件优先处理，避免重复计算
        return self.type > other.type

class EventSweep:
    """时间扫描线算法实现类"""
    
    @staticmethod
    def max_overlap(intervals):
        """
        区间覆盖问题：计算最多有多少个重叠的区间
        :param intervals: 区间数组，每个区间是 [start, end] 形式
        :return: 最大重叠数量
        """
        if not intervals:
            return 0
        
        events = []
        
        # 为每个区间创建开始和结束事件
        for start, end in intervals:
            events.append(Event(start, 0, 1))  # 开始事件
            events.append(Event(end, 1, 1))    # 结束事件
        
        # 按照时间排序事件
        events.sort()
        
        max_overlap = 0
        current_overlap = 0
        
        # 扫描所有事件
        for event in events:
            if event.type == 0:  # 开始事件
                current_overlap += 1
                max_overlap = max(max_overlap, current_overlap)
            else:  # 结束事件
                current_overlap -= 1
        
        return max_overlap
    
    @staticmethod
    def calculate_rectangle_area(rectangles):
        """
        扫描线算法解决矩形面积问题：计算多个矩形的总面积（不重复计算重叠部分）
        :param rectangles: 矩形数组，每个矩形是 [x1, y1, x2, y2] 形式，
                          其中(x1,y1)是左下顶点，(x2,y2)是右上顶点
        :return: 矩形覆盖的总面积
        """
        if not rectangles:
            return 0
        
        # 创建垂直扫描线事件
        events = []
        y_coordinates = set()
        
        for x1, y1, x2, y2 in rectangles:
            # 添加开始和结束事件
            events.append(Event(x1, 0, (y1, y2)))  # 开始事件
            events.append(Event(x2, 1, (y1, y2)))  # 结束事件
            
            # 收集所有y坐标
            y_coordinates.add(y1)
            y_coordinates.add(y2)
        
        # 排序事件
        events.sort()
        
        # 对y坐标排序
        sorted_y = sorted(y_coordinates)
        
        # 用于跟踪当前活动的矩形
        active_intervals = []
        total_area = 0
        prev_x = events[0].time
        
        # 处理每个事件
        for event in events:
            current_x = event.time
            width = current_x - prev_x
            
            if width > 0:
                # 计算当前活动的y区间总长度
                height = EventSweep._calculate_active_height(active_intervals, sorted_y)
                
                # 增加面积
                total_area += width * height
            
            # 更新活动区间
            if event.type == 0:
                active_intervals.append(event.data)
            else:
                active_intervals.remove(event.data)
            
            prev_x = current_x
        
        return int(total_area)
    
    @staticmethod
    def _calculate_active_height(active_intervals, sorted_y):
        """
        计算当前活动的y区间总长度
        :param active_intervals: 活动区间列表
        :param sorted_y: 排序后的y坐标
        :return: 总长度
        """
        if not active_intervals:
            return 0
        
        # 合并重叠的y区间
        intervals = sorted(active_intervals)
        
        total_height = 0
        current_start = intervals[0][0]
        current_end = intervals[0][1]
        
        for i in range(1, len(intervals)):
            if intervals[i][0] <= current_end:
                # 重叠，合并区间
                current_end = max(current_end, intervals[i][1])
            else:
                # 不重叠，计算长度并更新当前区间
                total_height += current_end - current_start
                current_start = intervals[i][0]
                current_end = intervals[i][1]
        
        # 加上最后一个区间
        total_height += current_end - current_start
        
        return total_height
    
    @staticmethod
    def test_event_sweep():
        """测试事件扫描线算法"""
        print("=== 测试事件扫描线算法 ===")
        
        # 测试区间重叠问题
        print("测试区间重叠问题:")
        intervals1 = [
            [1, 4], [2, 5], [3, 6], [7, 9]
        ]
        print(f"最大重叠数量: {EventSweep.max_overlap(intervals1)}")  # 应该是3
        
        intervals2 = [
            [1, 2], [3, 4], [5, 6]
        ]
        print(f"最大重叠数量: {EventSweep.max_overlap(intervals2)}")  # 应该是1
        
        # 测试矩形面积问题
        print("\n测试矩形面积计算:")
        rectangles1 = [
            [0, 0, 2, 2], [1, 1, 3, 3]
        ]
        print(f"矩形覆盖总面积: {EventSweep.calculate_rectangle_area(rectangles1)}")  # 应该是7
        
        rectangles2 = [
            [0, 0, 1, 1], [2, 2, 3, 3], [1, 1, 2, 2]
        ]
        print(f"矩形覆盖总面积: {EventSweep.calculate_rectangle_area(rectangles2)}")  # 应该是3
        
        # 性能测试
        print("\n=== 性能测试 ===")
        import random
        import time
        
        # 生成大量随机区间
        n = 10000
        intervals = []
        for _ in range(n):
            start = random.randint(0, 100000)
            end = start + random.randint(1, 1000)
            intervals.append([start, end])
        
        start_time = time.time()
        max_overlap = EventSweep.max_overlap(intervals)
        end_time = time.time()
        
        print(f"10000个随机区间的最大重叠数量: {max_overlap}")
        print(f"运行时间: {(end_time - start_time) * 1000:.2f} ms")
        
        # 生成大量随机矩形
        rectangles = []
        for _ in range(1000):
            x1 = random.randint(0, 1000)
            y1 = random.randint(0, 1000)
            x2 = x1 + random.randint(1, 100)
            y2 = y1 + random.randint(1, 100)
            rectangles.append([x1, y1, x2, y2])
        
        start_time = time.time()
        total_area = EventSweep.calculate_rectangle_area(rectangles)
        end_time = time.time()
        
        print(f"1000个随机矩形的总面积: {total_area}")
        print(f"运行时间: {(end_time - start_time) * 1000:.2f} ms")

if __name__ == "__main__":
    EventSweep.test_event_sweep()

===============================================

文件: FibonacciHeap.java
===============================================
package class185.fibonacci_heap_problems;

import java.util.*;

/**
 * 斐波那契堆实现 (Java版本)
 * 
 * 算法思路：
 * 斐波那契堆是一种高效的优先队列数据结构，支持多种操作的均摊时间复杂度都很优秀。
 * 它通过延迟合并和标记机制来实现高效的性能。
 * 
 * 应用场景：
 * 1. 图算法：最短路径、最小生成树
 * 2. 网络优化：路由算法、流量调度
 * 3. 操作系统：任务调度
 * 
 * 时间复杂度：
 * - 插入：O(1) 均摊
 * - 提取最小：O(log n) 均摊
 * - 减小键值：O(1) 均摊
 * - 删除：O(log n) 均摊
 * - 合并：O(1)
 * 
 * 空间复杂度：O(n)
 * 
 * 相关题目：
 * 1. LeetCode 743. 网络延迟时间
 * 2. LeetCode 1584. 连接所有点的最小费用
 * 3. LeetCode 1135. 最低成本联通所有城市
 */
class FibonacciHeapNode {
    Object key;           // 节点键值
    int priority;         // 优先级（用于排序）
    int degree;           // 节点的度数（子节点数量）
    boolean marked;       // 是否被标记（用于级联剪枝）
    FibonacciHeapNode parent;   // 父节点
    FibonacciHeapNode child;    // 第一个子节点
    FibonacciHeapNode left;     // 左侧兄弟节点
    FibonacciHeapNode right;    // 右侧兄弟节点

    FibonacciHeapNode(Object key, int priority) {
        this.key = key;
        this.priority = priority;
        this.degree = 0;
        this.marked = false;
        this.parent = null;
        this.child = null;
        this.left = this;
        this.right = this;
    }
}

public class FibonacciHeap {
    private FibonacciHeapNode minNode;  // 指向最小节点
    private int size;                   // 堆中节点数量

    public FibonacciHeap() {
        this.minNode = null;
        this.size = 0;
    }

    public boolean isEmpty() {
        return minNode == null;
    }

    public int getSize() {
        return size;
    }

    public FibonacciHeapNode insert(Object key, int priority) {
        /**
         * 插入新节点到堆中
         * 时间复杂度：O(1) 均摊
         * @param key: 节点键值
         * @param priority: 节点优先级
         * @return: 新插入的节点
         */
        FibonacciHeapNode newNode = new FibonacciHeapNode(key, priority);

        // 将新节点添加到根链表
        if (minNode == null) {
            // 空堆情况
            minNode = newNode;
        } else {
            // 将新节点插入到根链表的minNode旁边
            linkRootList(newNode, minNode);

            // 更新最小节点
            if (newNode.priority < minNode.priority) {
                minNode = newNode;
            }
        }

        // 增加节点计数
        size++;
        return newNode;
    }

    public void merge(FibonacciHeap other) {
        /**
         * 合并两个斐波那契堆
         * 时间复杂度：O(1)
         * @param other: 要合并的另一个堆
         */
        if (other == null || other.isEmpty()) {
            return;  // 空堆无需合并
        }

        if (isEmpty()) {
            // 如果当前堆为空，直接接管other的minNode
            minNode = other.minNode;
            size = other.size;
            return;
        }

        if (minNode != null && other.minNode != null) {
            // 合并两个根链表
            FibonacciHeapNode thisRight = minNode.right;
            FibonacciHeapNode otherLeft = other.minNode.left;

            minNode.right = other.minNode;
            other.minNode.left = minNode;

            thisRight.left = otherLeft;
            otherLeft.right = thisRight;

            // 更新最小节点
            if (other.minNode.priority < minNode.priority) {
                minNode = other.minNode;
            }

            // 更新节点数量
            size += other.size;

            // 重置other堆，避免悬空引用
            other.minNode = null;
            other.size = 0;
        }
    }

    public Object extractMin() {
        /**
         * 提取堆中的最小节点
         * 时间复杂度：O(log n) 均摊
         * @return: 最小节点的键值，如果堆为空返回null
         */
        if (isEmpty() || minNode == null) {
            return null;
        }

        FibonacciHeapNode minNodeCopy = minNode;

        // 将min的所有子节点提升到根链表
        if (minNodeCopy.child != null) {
            FibonacciHeapNode child = minNodeCopy.child;
            List<FibonacciHeapNode> children = new ArrayList<>();

            // 收集所有子节点
            FibonacciHeapNode current = child;
            do {
                children.add(current);
                current = current.right;
            } while (current != child);

            // 将所有子节点添加到根链表
            for (FibonacciHeapNode childNode : children) {
                // 从子链表中移除child
                removeFromChildList(childNode);

                // 添加到根链表
                childNode.parent = null;
                linkRootList(childNode, minNode);
            }

            // 清除min的子节点引用
            minNodeCopy.child = null;
        }

        // 从根链表中移除min
        if (minNodeCopy.right == minNodeCopy) {
            // 根链表中只有一个节点
            minNode = null;
        } else {
            // 更新根链表
            minNode = minNodeCopy.right;  // 暂时将min的右侧设为新的minNode
            removeFromRootList(minNodeCopy);

            // 合并相同度数的树
            consolidate();
        }

        // 减少节点计数
        size--;

        return minNodeCopy.key;
    }

    public void decreaseKey(FibonacciHeapNode node, int newPriority) {
        /**
         * 减小节点的优先级
         * 时间复杂度：O(1) 均摊
         * @param node: 要修改的节点
         * @param newPriority: 新的优先级
         * @throws IllegalArgumentException: 如果新优先级大于当前优先级
         */
        if (newPriority > node.priority) {
            throw new IllegalArgumentException("New priority cannot be greater than current priority");
        }

        node.priority = newPriority;
        FibonacciHeapNode parent = node.parent;

        // 如果节点在根链表中，或者父节点的优先级不大于当前节点，无需其他操作
        if (parent == null || parent.priority <= node.priority) {
            // 如果是根链表中的节点且优先级比当前minNode小，更新minNode
            if (parent == null && node.priority < minNode.priority) {
                minNode = node;
            }
            return;
        }

        // 否则，需要进行级联剪枝操作
        cut(node, parent);
        cascadingCut(parent);
    }

    public void delete(FibonacciHeapNode node) {
        /**
         * 删除指定节点
         * 时间复杂度：O(log n) 均摊
         * @param node: 要删除的节点
         */
        if (node == null) {
            return;
        }

        // 将节点优先级设置为负无穷，使其成为新的最小节点
        decreaseKey(node, Integer.MIN_VALUE);

        // 提取最小节点（即刚刚被设置为负无穷的节点）
        extractMin();
    }

    public Object getMin() {
        /**
         * 获取最小节点（不移除）
         * 时间复杂度：O(1)
         * @return: 最小节点的键值，如果堆为空返回null
         */
        return isEmpty() ? null : minNode.key;
    }

    // ==================== 辅助方法 ====================

    private void linkRootList(FibonacciHeapNode node, FibonacciHeapNode root) {
        /**
         * 将节点链接到根链表
         */
        // 在根和根的右侧节点之间插入node
        node.right = root.right;
        node.left = root;
        root.right.left = node;
        root.right = node;
    }

    private void removeFromRootList(FibonacciHeapNode node) {
        /**
         * 从根链表中移除节点
         */
        node.left.right = node.right;
        node.right.left = node.left;
    }

    private void removeFromChildList(FibonacciHeapNode node) {
        /**
         * 从子链表中移除节点
         */
        if (node.parent == null) {
            return;
        }

        if (node.parent.child == node) {
            // 如果是父节点的第一个子节点，更新父节点的child指针
            if (node.right != node) {
                node.parent.child = node.right;
            } else {
                node.parent.child = null;
            }
        }

        // 更新子链表中的双向链接
        node.left.right = node.right;
        node.right.left = node.left;
    }

    private void linkAsChild(FibonacciHeapNode child, FibonacciHeapNode parent) {
        /**
         * 将一个节点作为另一个节点的子节点
         */
        // 从根链表中移除child
        removeFromRootList(child);

        // 重置child的状态
        child.parent = parent;
        child.marked = false;

        // 将child添加到parent的子链表中
        if (parent.child == null) {
            // parent没有子节点
            parent.child = child;
            child.left = child;
            child.right = child;
        } else {
            // 将child插入到parent的第一个子节点旁边
            child.right = parent.child.right;
            child.left = parent.child;
            parent.child.right.left = child;
            parent.child.right = child;
        }

        // 增加parent的度数
        parent.degree++;
    }

    private void consolidate() {
        /**
         * 合并相同度数的树
         */
        // 计算最大可能的度数，理论上不会超过log_phi(n)，其中phi是黄金分割比
        int maxDegree = (int) (Math.log(size) / Math.log((1 + Math.sqrt(5)) / 2)) + 1;

        // 用于存储不同度数的根节点
        FibonacciHeapNode[] degreeTable = new FibonacciHeapNode[maxDegree];

        // 遍历所有根节点
        List<FibonacciHeapNode> roots = new ArrayList<>();
        if (minNode != null) {
            FibonacciHeapNode start = minNode;
            FibonacciHeapNode current = start;
            do {
                roots.add(current);
                current = current.right;
            } while (current != start);
        }

        // 处理每个根节点
        for (FibonacciHeapNode current : roots) {
            int degree = current.degree;
            FibonacciHeapNode nextNode = current.right;

            // 合并相同度数的树
            while (degreeTable[degree] != null) {
                FibonacciHeapNode other = degreeTable[degree];

                // 确保current的优先级不大于other
                if (current.priority > other.priority) {
                    FibonacciHeapNode temp = current;
                    current = other;
                    other = temp;
                }

                // 将other作为current的子节点
                linkAsChild(other, current);

                // 清除度数表中的条目
                degreeTable[degree] = null;
                degree++;
            }

            // 记录当前度数的根节点
            degreeTable[degree] = current;
        }

        // 重建根链表并找到新的最小节点
        minNode = null;

        for (int i = 0; i < maxDegree; i++) {
            if (degreeTable[i] != null) {
                // 初始化根链表
                if (minNode == null) {
                    minNode = degreeTable[i];
                    minNode.left = minNode;
                    minNode.right = minNode;
                } else {
                    // 将节点添加到根链表
                    linkRootList(degreeTable[i], minNode);

                    // 更新最小节点
                    if (degreeTable[i].priority < minNode.priority) {
                        minNode = degreeTable[i];
                    }
                }
            }
        }
    }

    private void cut(FibonacciHeapNode node, FibonacciHeapNode parent) {
        /**
         * 剪切操作：将节点从父节点的子树中移除并添加到根链表
         */
        // 从父节点的子链表中移除node
        removeFromChildList(node);

        // 减少父节点的度数
        parent.degree--;

        // 将node添加到根链表
        node.parent = null;
        node.marked = false;
        linkRootList(node, minNode);
    }

    private void cascadingCut(FibonacciHeapNode node) {
        /**
         * 级联剪切操作
         */
        FibonacciHeapNode parent = node.parent;

        if (parent != null) {
            if (!node.marked) {
                // 如果节点未被标记，标记它
                node.marked = true;
            } else {
                // 如果节点已被标记，进行剪切并继续级联
                cut(node, parent);
                cascadingCut(parent);
            }
        }
    }

    public void printHeap() {
        /**
         * 打印堆的结构（用于调试）
         */
        if (isEmpty()) {
            System.out.println("Heap is empty");
            return;
        }

        System.out.println("Fibonacci Heap Structure:");
        Set<FibonacciHeapNode> visited = new HashSet<>();
        printNode(minNode, 0, visited);
    }

    private void printNode(FibonacciHeapNode node, int level, Set<FibonacciHeapNode> visited) {
        /**
         * 递归打印节点及其子节点
         */
        if (node == null || visited.contains(node)) {
            return;
        }

        visited.add(node);

        // 打印缩进
        for (int i = 0; i < level; i++) {
            System.out.print("  ");
        }

        // 打印节点信息
        System.out.println("Key: " + node.key + ", Priority: " + node.priority + 
                          ", Degree: " + node.degree + ", Marked: " + node.marked);

        // 递归打印子节点
        if (node.child != null) {
            FibonacciHeapNode child = node.child;
            do {
                printNode(child, level + 1, visited);
                child = child.right;
            } while (child != node.child);
        }
    }

    public static void main(String[] args) {
        System.out.println("=== 测试斐波那契堆 ===");
        FibonacciHeap heap = new FibonacciHeap();

        // 测试插入操作
        System.out.println("\n1. 测试插入操作:");
        FibonacciHeapNode node1 = heap.insert("Task 1", 5);
        FibonacciHeapNode node2 = heap.insert("Task 2", 3);
        FibonacciHeapNode node3 = heap.insert("Task 3", 8);
        FibonacciHeapNode node4 = heap.insert("Task 4", 1);
        FibonacciHeapNode node5 = heap.insert("Task 5", 10);

        System.out.println("插入5个节点后，最小节点: " + heap.getMin());  // 应该是 Task 4

        // 测试提取最小节点
        System.out.println("\n2. 测试提取最小节点:");
        Object min1 = heap.extractMin();
        System.out.println("提取的最小节点: " + min1);  // 应该是 Task 4
        System.out.println("提取后，最小节点: " + heap.getMin());  // 应该是 Task 2

        // 测试减小键值
        System.out.println("\n3. 测试减小键值:");
        heap.decreaseKey(node3, 2);
        System.out.println("减小Task 3的优先级后，最小节点: " + heap.getMin());  // 应该是 Task 3

        // 测试删除节点
        System.out.println("\n4. 测试删除节点:");
        heap.delete(node5);
        System.out.println("删除Task 5后，最小节点: " + heap.getMin());  // 仍然是 Task 3

        // 测试合并操作
        System.out.println("\n5. 测试合并操作:");
        FibonacciHeap heap2 = new FibonacciHeap();
        heap2.insert("Task A", 4);
        heap2.insert("Task B", 6);

        heap.merge(heap2);
        System.out.println("合并两个堆后，最小节点: " + heap.getMin());  // 仍然是 Task 3
        System.out.println("堆大小: " + heap.getSize());  // 应该是 5

        // 测试提取所有元素
        System.out.println("\n6. 测试提取所有元素:");
        System.out.print("按优先级提取顺序: ");
        while (!heap.isEmpty()) {
            System.out.print(heap.extractMin() + " ");
        }
        System.out.println();

        // 测试边界情况
        System.out.println("\n7. 测试边界情况:");
        System.out.println("空堆获取最小节点: " + heap.getMin());  // 应该是 null
        System.out.println("空堆提取最小节点: " + heap.extractMin());  // 应该是 null

        // 性能测试
        System.out.println("\n=== 性能测试 ===");
        
        FibonacciHeap largeHeap = new FibonacciHeap();
        
        long startTime = System.nanoTime();
        List<FibonacciHeapNode> nodes = new ArrayList<>();
        Random random = new Random();
        for (int i = 0; i < 10000; i++) {
            int priority = random.nextInt(100000) + 1;
            FibonacciHeapNode node = largeHeap.insert("Task " + i, priority);
            nodes.add(node);
        }
        long insertTime = System.nanoTime() - startTime;
        
        System.out.println("插入10000个节点时间: " + insertTime / 1_000_000.0 + " ms");
        System.out.println("堆大小: " + largeHeap.getSize());
        
        // 测试随机减小键值操作
        startTime = System.nanoTime();
        for (int i = 0; i < 1000; i++) {
            FibonacciHeapNode node = nodes.get(random.nextInt(nodes.size()));
            int newPriority = random.nextInt(100) + 1;
            try {
                heap.decreaseKey(node, newPriority);
            } catch (IllegalArgumentException e) {
                // 忽略无效操作
            }
        }
        long decreaseTime = System.nanoTime() - startTime;
        
        System.out.println("1000次减小键值操作时间: " + decreaseTime / 1_000_000.0 + " ms");
        
        // 测试提取最小操作
        startTime = System.nanoTime();
        int extractedCount = 0;
        while (!largeHeap.isEmpty() && extractedCount < 1000) {
            largeHeap.extractMin();
            extractedCount++;
        }
        long extractTime = System.nanoTime() - startTime;
        
        System.out.println("提取" + extractedCount + "个最小节点时间: " + extractTime / 1_000_000.0 + " ms");
    }
}

===============================================

文件: fibonacci_heap.py
===============================================
#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
斐波那契堆实现 (Python版本)

算法思路：
斐波那契堆是一种高效的优先队列数据结构，支持多种操作的均摊时间复杂度都很优秀。
它通过延迟合并和标记机制来实现高效的性能。

应用场景：
1. 图算法：最短路径、最小生成树
2. 网络优化：路由算法、流量调度
3. 操作系统：任务调度

时间复杂度：
- 插入：O(1) 均摊
- 提取最小：O(log n) 均摊
- 减小键值：O(1) 均摊
- 删除：O(log n) 均摊
- 合并：O(1)

空间复杂度：O(n)
"""

import math

class FibonacciHeapNode:
    """斐波那契堆节点类"""
    
    def __init__(self, key, priority):
        """
        构造函数
        :param key: 节点键值
        :param priority: 节点优先级
        """
        self.key = key                 # 节点键值
        self.priority = priority       # 优先级（用于排序）
        self.degree = 0                # 节点的度数（子节点数量）
        self.marked = False            # 是否被标记（用于级联剪枝）
        self.parent = None             # 父节点
        self.child = None              # 第一个子节点
        self.left = self               # 左侧兄弟节点
        self.right = self              # 右侧兄弟节点

class FibonacciHeap:
    """斐波那契堆实现"""
    
    def __init__(self):
        """构造空堆"""
        self.min_node = None  # 指向最小节点
        self.size = 0         # 堆中节点数量
    
    def is_empty(self):
        """
        检查堆是否为空
        :return: 堆是否为空
        """
        return self.min_node is None
    
    def get_size(self):
        """
        获取堆中元素数量
        :return: 元素数量
        """
        return self.size
    
    def insert(self, key, priority):
        """
        插入新节点到堆中
        时间复杂度：O(1) 均摊
        :param key: 节点键值
        :param priority: 节点优先级
        :return: 新插入的节点
        """
        new_node = FibonacciHeapNode(key, priority)
        
        # 将新节点添加到根链表
        if self.min_node is None:
            # 空堆情况
            self.min_node = new_node
        else:
            # 将新节点插入到根链表的min_node旁边
            self._link_root_list(new_node, self.min_node)
            
            # 更新最小节点
            if new_node.priority < self.min_node.priority:
                self.min_node = new_node
        
        # 增加节点计数
        self.size += 1
        return new_node
    
    def merge(self, other):
        """
        合并两个斐波那契堆
        时间复杂度：O(1)
        :param other: 要合并的另一个堆
        """
        if other is None or other.is_empty():
            return  # 空堆无需合并
        
        if self.is_empty():
            # 如果当前堆为空，直接接管other的min_node
            self.min_node = other.min_node
            self.size = other.size
            return
        
        if self.min_node is not None and other.min_node is not None:
            # 合并两个根链表
            self_right = self.min_node.right
            other_left = other.min_node.left
            
            self.min_node.right = other.min_node
            other.min_node.left = self.min_node
            
            self_right.left = other_left
            other_left.right = self_right
            
            # 更新最小节点
            if other.min_node.priority < self.min_node.priority:
                self.min_node = other.min_node
            
            # 更新节点数量
            self.size += other.size
            
            # 重置other堆，避免悬空引用
            other.min_node = None
            other.size = 0
    
    def extract_min(self):
        """
        提取堆中的最小节点
        时间复杂度：O(log n) 均摊
        :return: 最小节点的键值，如果堆为空返回None
        """
        if self.is_empty() or self.min_node is None:
            return None
        
        min_node = self.min_node
        
        # 将min的所有子节点提升到根链表
        if min_node.child is not None:
            child = min_node.child
            children = []
            # 收集所有子节点
            current = child
            while True:
                children.append(current)
                current = current.right
                if current == child:
                    break
            
            # 将所有子节点添加到根链表
            for child_node in children:
                # 从子链表中移除child
                self._remove_from_child_list(child_node)
                
                # 添加到根链表
                child_node.parent = None
                self._link_root_list(child_node, self.min_node)
            
            # 清除min的子节点引用
            min_node.child = None
        
        # 从根链表中移除min
        if min_node.right == min_node:
            # 根链表中只有一个节点
            self.min_node = None
        else:
            # 更新根链表
            self.min_node = min_node.right  # 暂时将min的右侧设为新的min_node
            self._remove_from_root_list(min_node)
            
            # 合并相同度数的树
            self._consolidate()
        
        # 减少节点计数
        self.size -= 1
        
        return min_node.key if min_node is not None else None

    def decrease_key(self, node, new_priority):
        """
        减小节点的优先级
        时间复杂度：O(1) 均摊
        :param node: 要修改的节点
        :param new_priority: 新的优先级
        :raises ValueError: 如果新优先级大于当前优先级
        """
        if new_priority > node.priority:
            raise ValueError("New priority cannot be greater than current priority")
        
        node.priority = new_priority
        parent = node.parent
        
        # 如果节点在根链表中，或者父节点的优先级不大于当前节点，无需其他操作
        if parent is None or parent.priority <= node.priority:
            # 如果是根链表中的节点且优先级比当前min_node小，更新min_node
            if parent is None and node.priority < self.min_node.priority:
                self.min_node = node
            return
        
        # 否则，需要进行级联剪枝操作
        self._cut(node, parent)
        self._cascading_cut(parent)
    
    def delete(self, node):
        """
        删除指定节点
        时间复杂度：O(log n) 均摊
        :param node: 要删除的节点
        """
        if node is None:
            return
            
        # 将节点优先级设置为负无穷，使其成为新的最小节点
        self.decrease_key(node, float('-inf'))
        
        # 提取最小节点（即刚刚被设置为负无穷的节点）
        self.extract_min()
    
    def get_min(self):
        """
        获取最小节点（不移除）
        时间复杂度：O(1)
        :return: 最小节点的键值，如果堆为空返回None
        """
        return None if self.is_empty() else self.min_node.key
    
    # ==================== 辅助方法 ====================
    
    def _link_root_list(self, node, root):
        """
        将节点链接到根链表
        """
        # 在根和根的右侧节点之间插入node
        node.right = root.right
        node.left = root
        root.right.left = node
        root.right = node
    
    def _remove_from_root_list(self, node):
        """
        从根链表中移除节点
        """
        node.left.right = node.right
        node.right.left = node.left
    
    def _remove_from_child_list(self, node):
        """
        从子链表中移除节点
        """
        if node.parent is None:
            return
            
        if node.parent.child == node:
            # 如果是父节点的第一个子节点，更新父节点的child指针
            if node.right != node:
                node.parent.child = node.right
            else:
                node.parent.child = None
        
        # 更新子链表中的双向链接
        node.left.right = node.right
        node.right.left = node.left
    
    def _link_as_child(self, child, parent):
        """
        将一个节点作为另一个节点的子节点
        """
        # 从根链表中移除child
        self._remove_from_root_list(child)
        
        # 重置child的状态
        child.parent = parent
        child.marked = False
        
        # 将child添加到parent的子链表中
        if parent.child is None:
            # parent没有子节点
            parent.child = child
            child.left = child
            child.right = child
        else:
            # 将child插入到parent的第一个子节点旁边
            child.right = parent.child.right
            child.left = parent.child
            parent.child.right.left = child
            parent.child.right = child
        
        # 增加parent的度数
        parent.degree += 1
    
    def _consolidate(self):
        """
        合并相同度数的树
        """
        # 计算最大可能的度数，理论上不会超过log_phi(n)，其中phi是黄金分割比
        max_degree = int(math.log(self.size) / math.log((1 + math.sqrt(5)) / 2)) + 1
        
        # 用于存储不同度数的根节点
        degree_table = [None] * max_degree
        
        # 遍历所有根节点
        start = self.min_node
        current = start
        roots = []
        
        # 收集所有根节点
        while True:
            roots.append(current)
            current = current.right
            if current == start:
                break
        
        # 处理每个根节点
        for current in roots:
            degree = current.degree
            next_node = current.right
            
            # 合并相同度数的树
            while degree_table[degree] is not None:
                other = degree_table[degree]
                
                # 确保current的优先级不大于other
                if current.priority > other.priority:
                    current, other = other, current
                
                # 将other作为current的子节点
                self._link_as_child(other, current)
                
                # 清除度数表中的条目
                degree_table[degree] = None
                degree += 1
            
            # 记录当前度数的根节点
            degree_table[degree] = current
        
        # 重建根链表并找到新的最小节点
        self.min_node = None
        
        for i in range(max_degree):
            if degree_table[i] is not None:
                # 初始化根链表
                if self.min_node is None:
                    self.min_node = degree_table[i]
                    self.min_node.left = self.min_node
                    self.min_node.right = self.min_node
                else:
                    # 将节点添加到根链表
                    self._link_root_list(degree_table[i], self.min_node)
                    
                    # 更新最小节点
                    if degree_table[i].priority < self.min_node.priority:
                        self.min_node = degree_table[i]
    
    def _cut(self, node, parent):
        """
        剪切操作：将节点从父节点的子树中移除并添加到根链表
        """
        # 从父节点的子链表中移除node
        self._remove_from_child_list(node)
        
        # 减少父节点的度数
        parent.degree -= 1
        
        # 将node添加到根链表
        node.parent = None
        node.marked = False
        self._link_root_list(node, self.min_node)
    
    def _cascading_cut(self, node):
        """
        级联剪切操作
        """
        parent = node.parent
        
        if parent is not None:
            if not node.marked:
                # 如果节点未被标记，标记它
                node.marked = True
            else:
                # 如果节点已被标记，进行剪切并继续级联
                self._cut(node, parent)
                self._cascading_cut(parent)
    
    def print_heap(self):
        """
        打印堆的结构（用于调试）
        """
        if self.is_empty():
            print("Heap is empty")
            return
        
        print("Fibonacci Heap Structure:")
        visited = set()
        self._print_node(self.min_node, 0, visited)
    
    def _print_node(self, node, level, visited):
        """
        递归打印节点及其子节点
        """
        if node is None or node in visited:
            return
        
        visited.add(node)
        
        # 打印缩进
        print("  " * level, end="")
        
        # 打印节点信息
        print(f"Key: {node.key}, Priority: {node.priority}, Degree: {node.degree}, Marked: {node.marked}")
        
        # 递归打印子节点
        if node.child is not None:
            child = node.child
            while True:
                self._print_node(child, level + 1, visited)
                child = child.right
                if child == node.child:
                    break
    
    @staticmethod
    def test_fibonacci_heap():
        """测试斐波那契堆的各种操作"""
        print("=== 测试斐波那契堆 ===")
        heap = FibonacciHeap()
        
        # 测试插入操作
        print("\n1. 测试插入操作:")
        node1 = heap.insert("Task 1", 5)
        node2 = heap.insert("Task 2", 3)
        node3 = heap.insert("Task 3", 8)
        node4 = heap.insert("Task 4", 1)
        node5 = heap.insert("Task 5", 10)
        
        print("插入5个节点后，最小节点:", heap.get_min())  # 应该是 Task 4
        
        # 测试提取最小节点
        print("\n2. 测试提取最小节点:")
        min1 = heap.extract_min()
        print("提取的最小节点:", min1)  # 应该是 Task 4
        print("提取后，最小节点:", heap.get_min())  # 应该是 Task 2
        
        # 测试减小键值
        print("\n3. 测试减小键值:")
        heap.decrease_key(node3, 2)
        print("减小Task 3的优先级后，最小节点:", heap.get_min())  # 应该是 Task 3
        
        # 测试删除节点
        print("\n4. 测试删除节点:")
        heap.delete(node5)
        print("删除Task 5后，最小节点:", heap.get_min())  # 仍然是 Task 3
        
        # 测试合并操作
        print("\n5. 测试合并操作:")
        heap2 = FibonacciHeap()
        heap2.insert("Task A", 4)
        heap2.insert("Task B", 6)
        
        heap.merge(heap2)
        print("合并两个堆后，最小节点:", heap.get_min())  # 仍然是 Task 3
        print("堆大小:", heap.get_size())  # 应该是 5
        
        # 测试提取所有元素
        print("\n6. 测试提取所有元素:")
        print("按优先级提取顺序: ", end="")
        while not heap.is_empty():
            print(heap.extract_min(), end=" ")
        print()
        
        # 测试边界情况
        print("\n7. 测试边界情况:")
        print("空堆获取最小节点:", heap.get_min())  # 应该是 None
        print("空堆提取最小节点:", heap.extract_min())  # 应该是 None
        
        # 性能测试
        print("\n=== 性能测试 ===")
        import time
        import random
        
        # 测试大量插入操作
        large_heap = FibonacciHeap()
        
        start_time = time.time()
        nodes = []
        for i in range(10000):
            priority = random.randint(1, 100000)
            node = large_heap.insert(f"Task {i}", priority)
            nodes.append(node)
        insert_time = time.time() - start_time
        
        print(f"插入10000个节点时间: {insert_time*1000:.2f} ms")
        print(f"堆大小: {large_heap.get_size()}")
        
        # 测试随机减小键值操作
        start_time = time.time()
        for i in range(1000):
            node = random.choice(nodes)
            new_priority = random.randint(1, 100)
            try:
                large_heap.decrease_key(node, new_priority)
            except ValueError:
                pass  # 忽略无效操作
        decrease_time = time.time() - start_time
        
        print(f"1000次减小键值操作时间: {decrease_time*1000:.2f} ms")
        
        # 测试提取最小操作
        start_time = time.time()
        extracted_count = 0
        while not large_heap.is_empty() and extracted_count < 1000:
            large_heap.extract_min()
            extracted_count += 1
        extract_time = time.time() - start_time
        
        print(f"提取{extracted_count}个最小节点时间: {extract_time*1000:.2f} ms")

if __name__ == "__main__":
    FibonacciHeap.test_fibonacci_heap()

===============================================

文件: fibonacci_heap_1.py
===============================================
#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
斐波那契堆实现 (Python版本)

算法思路：
斐波那契堆是一种高效的优先队列数据结构，支持多种操作的均摊时间复杂度都很优秀。
它通过延迟合并和标记机制来实现高效的性能。

应用场景：
1. 图算法：最短路径、最小生成树
2. 网络优化：路由算法、流量调度
3. 操作系统：任务调度

时间复杂度：
- 插入：O(1) 均摊
- 提取最小：O(log n) 均摊
- 减小键值：O(1) 均摊
- 删除：O(log n) 均摊
- 合并：O(1)

空间复杂度：O(n)

相关题目：
1. LeetCode 743. 网络延迟时间
2. LeetCode 1584. 连接所有点的最小费用
3. LeetCode 1135. 最低成本联通所有城市
"""

import math
import random

class FibonacciHeapNode:
    """斐波那契堆节点类"""
    
    def __init__(self, key, priority):
        """
        构造函数
        :param key: 节点键值
        :param priority: 节点优先级
        """
        self.key = key                 # 节点键值
        self.priority = priority       # 优先级（用于排序）
        self.degree = 0                # 节点的度数（子节点数量）
        self.marked = False            # 是否被标记（用于级联剪枝）
        self.parent = None             # 父节点
        self.child = None              # 第一个子节点
        self.left = self               # 左侧兄弟节点
        self.right = self              # 右侧兄弟节点

class FibonacciHeap:
    """斐波那契堆实现"""
    
    def __init__(self):
        """构造空堆"""
        self.min_node = None  # 指向最小节点
        self.size = 0         # 堆中节点数量
    
    def is_empty(self):
        """
        检查堆是否为空
        :return: 堆是否为空
        """
        return self.min_node is None
    
    def get_size(self):
        """
        获取堆中元素数量
        :return: 元素数量
        """
        return self.size
    
    def insert(self, key, priority):
        """
        插入新节点到堆中
        时间复杂度：O(1) 均摊
        :param key: 节点键值
        :param priority: 节点优先级
        :return: 新插入的节点
        """
        new_node = FibonacciHeapNode(key, priority)
        
        # 将新节点添加到根链表
        if self.min_node is None:
            # 空堆情况
            self.min_node = new_node
        else:
            # 将新节点插入到根链表的min_node旁边
            self._link_root_list(new_node, self.min_node)
            
            # 更新最小节点
            if new_node.priority < self.min_node.priority:
                self.min_node = new_node
        
        # 增加节点计数
        self.size += 1
        return new_node
    
    def merge(self, other):
        """
        合并两个斐波那契堆
        时间复杂度：O(1)
        :param other: 要合并的另一个堆
        """
        if other is None or other.is_empty():
            return  # 空堆无需合并
        
        if self.is_empty():
            # 如果当前堆为空，直接接管other的min_node
            self.min_node = other.min_node
            self.size = other.size
            return
        
        if self.min_node is not None and other.min_node is not None:
            # 合并两个根链表
            self_right = self.min_node.right
            other_left = other.min_node.left
            
            self.min_node.right = other.min_node
            other.min_node.left = self.min_node
            
            self_right.left = other_left
            other_left.right = self_right
            
            # 更新最小节点
            if other.min_node.priority < self.min_node.priority:
                self.min_node = other.min_node
            
            # 更新节点数量
            self.size += other.size
            
            # 重置other堆，避免悬空引用
            other.min_node = None
            other.size = 0
    
    def extract_min(self):
        """
        提取堆中的最小节点
        时间复杂度：O(log n) 均摊
        :return: 最小节点的键值，如果堆为空返回None
        """
        if self.is_empty() or self.min_node is None:
            return None
        
        min_node = self.min_node
        
        # 将min的所有子节点提升到根链表
        if min_node.child is not None:
            child = min_node.child
            children = []
            # 收集所有子节点
            current = child
            while True:
                children.append(current)
                current = current.right
                if current == child:
                    break
            
            # 将所有子节点添加到根链表
            for child_node in children:
                # 从子链表中移除child
                self._remove_from_child_list(child_node)
                
                # 添加到根链表
                child_node.parent = None
                self._link_root_list(child_node, self.min_node)
            
            # 清除min的子节点引用
            min_node.child = None
        
        # 从根链表中移除min
        if min_node.right == min_node:
            # 根链表中只有一个节点
            self.min_node = None
        else:
            # 更新根链表
            self.min_node = min_node.right  # 暂时将min的右侧设为新的min_node
            self._remove_from_root_list(min_node)
            
            # 合并相同度数的树
            self._consolidate()
        
        # 减少节点计数
        self.size -= 1
        
        return min_node.key if min_node is not None else None

    def decrease_key(self, node, new_priority):
        """
        减小节点的优先级
        时间复杂度：O(1) 均摊
        :param node: 要修改的节点
        :param new_priority: 新的优先级
        :raises ValueError: 如果新优先级大于当前优先级
        """
        if new_priority > node.priority:
            raise ValueError("New priority cannot be greater than current priority")
        
        node.priority = new_priority
        parent = node.parent
        
        # 如果节点在根链表中，或者父节点的优先级不大于当前节点，无需其他操作
        if parent is None or parent.priority <= node.priority:
            # 如果是根链表中的节点且优先级比当前min_node小，更新min_node
            if parent is None and self.min_node is not None and node.priority < self.min_node.priority:
                self.min_node = node
            return
        
        # 否则，需要进行级联剪枝操作
        self._cut(node, parent)
        self._cascading_cut(parent)
    
    def delete(self, node):
        """
        删除指定节点
        时间复杂度：O(log n) 均摊
        :param node: 要删除的节点
        """
        if node is None:
            return
            
        # 将节点优先级设置为负无穷，使其成为新的最小节点
        self.decrease_key(node, float('-inf'))
        
        # 提取最小节点（即刚刚被设置为负无穷的节点）
        self.extract_min()
    
    def get_min(self):
        """
        获取最小节点（不移除）
        时间复杂度：O(1)
        :return: 最小节点的键值，如果堆为空返回None
        """
        return None if self.is_empty() or self.min_node is None else self.min_node.key
    
    # ==================== 辅助方法 ====================
    
    def _link_root_list(self, node, root):
        """
        将节点链接到根链表
        """
        # 在根和根的右侧节点之间插入node
        node.right = root.right
        node.left = root
        root.right.left = node
        root.right = node
    
    def _remove_from_root_list(self, node):
        """
        从根链表中移除节点
        """
        node.left.right = node.right
        node.right.left = node.left
    
    def _remove_from_child_list(self, node):
        """
        从子链表中移除节点
        """
        if node.parent is None:
            return
            
        if node.parent.child == node:
            # 如果是父节点的第一个子节点，更新父节点的child指针
            if node.right != node:
                node.parent.child = node.right
            else:
                node.parent.child = None
        
        # 更新子链表中的双向链接
        node.left.right = node.right
        node.right.left = node.left
    
    def _link_as_child(self, child, parent):
        """
        将一个节点作为另一个节点的子节点
        """
        # 从根链表中移除child
        self._remove_from_root_list(child)
        
        # 重置child的状态
        child.parent = parent
        child.marked = False
        
        # 将child添加到parent的子链表中
        if parent.child is None:
            # parent没有子节点
            parent.child = child
            child.left = child
            child.right = child
        else:
            # 将child插入到parent的第一个子节点旁边
            child.right = parent.child.right
            child.left = parent.child
            parent.child.right.left = child
            parent.child.right = child
        
        # 增加parent的度数
        parent.degree += 1
    
    def _consolidate(self):
        """
        合并相同度数的树
        """
        # 计算最大可能的度数，理论上不会超过log_phi(n)，其中phi是黄金分割比
        max_degree = int(math.log(self.size) / math.log((1 + math.sqrt(5)) / 2)) + 1
        
        # 用于存储不同度数的根节点
        degree_table = [None] * max_degree
        
        # 遍历所有根节点
        start = self.min_node
        current = start
        roots = []
        
        # 收集所有根节点
        if current is not None:
            while True:
                roots.append(current)
                current = current.right
                if current == start:
                    break
        
        # 处理每个根节点
        for current in roots:
            degree = current.degree
            next_node = current.right
            
            # 合并相同度数的树
            while degree_table[degree] is not None:
                other = degree_table[degree]
                
                # 确保current的优先级不大于other
                if current.priority > other.priority:
                    current, other = other, current
                
                # 将other作为current的子节点
                self._link_as_child(other, current)
                
                # 清除度数表中的条目
                degree_table[degree] = None
                degree += 1
            
            # 记录当前度数的根节点
            degree_table[degree] = current
        
        # 重建根链表并找到新的最小节点
        self.min_node = None
        
        for i in range(max_degree):
            if degree_table[i] is not None:
                # 初始化根链表
                if self.min_node is None:
                    self.min_node = degree_table[i]
                    if self.min_node is not None:
                        self.min_node.left = self.min_node
                        self.min_node.right = self.min_node
                else:
                    # 将节点添加到根链表
                    self._link_root_list(degree_table[i], self.min_node)
                    
                    # 更新最小节点
                    if self.min_node is not None and degree_table[i] is not None and degree_table[i].priority < self.min_node.priority:
                        self.min_node = degree_table[i]
    
    def _cut(self, node, parent):
        """
        剪切操作：将节点从父节点的子树中移除并添加到根链表
        """
        # 从父节点的子链表中移除node
        self._remove_from_child_list(node)
        
        # 减少父节点的度数
        parent.degree -= 1
        
        # 将node添加到根链表
        node.parent = None
        node.marked = False
        self._link_root_list(node, self.min_node)
    
    def _cascading_cut(self, node):
        """
        级联剪切操作
        """
        parent = node.parent
        
        if parent is not None:
            if not node.marked:
                # 如果节点未被标记，标记它
                node.marked = True
            else:
                # 如果节点已被标记，进行剪切并继续级联
                self._cut(node, parent)
                self._cascading_cut(parent)
    
    def print_heap(self):
        """
        打印堆的结构（用于调试）
        """
        if self.is_empty():
            print("Heap is empty")
            return
        
        print("Fibonacci Heap Structure:")
        visited = set()
        self._print_node(self.min_node, 0, visited)
    
    def _print_node(self, node, level, visited):
        """
        递归打印节点及其子节点
        """
        if node is None or node in visited:
            return
        
        visited.add(node)
        
        # 打印缩进
        print("  " * level, end="")
        
        # 打印节点信息
        print(f"Key: {node.key}, Priority: {node.priority}, Degree: {node.degree}, Marked: {node.marked}")
        
        # 递归打印子节点
        if node.child is not None:
            child = node.child
            while True:
                self._print_node(child, level + 1, visited)
                child = child.right
                if child == node.child:
                    break
    
    @staticmethod
    def test_fibonacci_heap():
        """测试斐波那契堆的各种操作"""
        print("=== 测试斐波那契堆 ===")
        heap = FibonacciHeap()
        
        # 测试插入操作
        print("\n1. 测试插入操作:")
        node1 = heap.insert("Task 1", 5)
        node2 = heap.insert("Task 2", 3)
        node3 = heap.insert("Task 3", 8)
        node4 = heap.insert("Task 4", 1)
        node5 = heap.insert("Task 5", 10)
        
        print("插入5个节点后，最小节点:", heap.get_min())  # 应该是 Task 4
        
        # 测试提取最小节点
        print("\n2. 测试提取最小节点:")
        min1 = heap.extract_min()
        print("提取的最小节点:", min1)  # 应该是 Task 4
        print("提取后，最小节点:", heap.get_min())  # 应该是 Task 2
        
        # 测试减小键值
        print("\n3. 测试减小键值:")
        heap.decrease_key(node3, 2)
        print("减小Task 3的优先级后，最小节点:", heap.get_min())  # 应该是 Task 3
        
        # 测试删除节点
        print("\n4. 测试删除节点:")
        heap.delete(node5)
        print("删除Task 5后，最小节点:", heap.get_min())  # 仍然是 Task 3
        
        # 测试合并操作
        print("\n5. 测试合并操作:")
        heap2 = FibonacciHeap()
        heap2.insert("Task A", 4)
        heap2.insert("Task B", 6)
        
        heap.merge(heap2)
        print("合并两个堆后，最小节点:", heap.get_min())  # 仍然是 Task 3
        print("堆大小:", heap.get_size())  # 应该是 5
        
        # 测试提取所有元素
        print("\n6. 测试提取所有元素:")
        print("按优先级提取顺序: ", end="")
        while not heap.is_empty():
            print(heap.extract_min(), end=" ")
        print()
        
        # 测试边界情况
        print("\n7. 测试边界情况:")
        print("空堆获取最小节点:", heap.get_min())  # 应该是 None
        print("空堆提取最小节点:", heap.extract_min())  # 应该是 None
        
        # 性能测试
        print("\n=== 性能测试 ===")
        import time
        
        # 测试大量插入操作
        large_heap = FibonacciHeap()
        
        start_time = time.time()
        nodes = []
        for i in range(10000):
            priority = random.randint(1, 100000)
            node = large_heap.insert(f"Task {i}", priority)
            nodes.append(node)
        insert_time = time.time() - start_time
        
        print(f"插入10000个节点时间: {insert_time*1000:.2f} ms")
        print(f"堆大小: {large_heap.get_size()}")
        
        # 测试随机减小键值操作
        start_time = time.time()
        for i in range(1000):
            node = random.choice(nodes)
            new_priority = random.randint(1, 100)
            try:
                large_heap.decrease_key(node, new_priority)
            except ValueError:
                pass  # 忽略无效操作
        decrease_time = time.time() - start_time
        
        print(f"1000次减小键值操作时间: {decrease_time*1000:.2f} ms")
        
        # 测试提取最小操作
        start_time = time.time()
        extracted_count = 0
        while not large_heap.is_empty() and extracted_count < 1000:
            large_heap.extract_min()
            extracted_count += 1
        extract_time = time.time() - start_time
        
        print(f"提取{extracted_count}个最小节点时间: {extract_time*1000:.2f} ms")

if __name__ == "__main__":
    FibonacciHeap.test_fibonacci_heap()

===============================================

文件: GameOfLife2D.java
===============================================
package class185.game_of_life_problems;

import java.util.*;

/**
 * 康威生命游戏实现 (Java版本)
 * 
 * 算法思路：
 * 康威生命游戏是一个细胞自动机，每个细胞根据其周围8个邻居的状态按照以下规则演化：
 * 1. 活细胞周围活细胞数少于2个，则死亡（孤独）
 * 2. 活细胞周围活细胞数为2或3个，则继续存活
 * 3. 活细胞周围活细胞数多于3个，则死亡（拥挤）
 * 4. 死细胞周围活细胞数为3个，则复活（繁殖）
 * 
 * 时间复杂度：O(m*n) 每代
 * 空间复杂度：O(m*n)
 * 
 * 应用场景：
 * 1. 生物学：细胞自动机模型
 * 2. 物理学：粒子系统模拟
 * 3. 艺术：生成艺术图案
 * 4. 教育：复杂系统教学
 * 
 * 相关题目：
 * 1. LeetCode 289. 生命游戏
 */
public class GameOfLife2D {
    private int[][] board;
    private int rows;
    private int cols;
    
    /**
     * 构造函数
     * @param initialBoard 初始棋盘状态，二维数组，1表示活细胞，0表示死细胞
     */
    public GameOfLife2D(int[][] initialBoard) {
        if (initialBoard == null || initialBoard.length == 0 || initialBoard[0].length == 0) {
            throw new IllegalArgumentException("初始棋盘不能为空");
        }
        
        this.rows = initialBoard.length;
        this.cols = initialBoard[0].length;
        this.board = new int[rows][cols];
        
        // 深拷贝初始棋盘
        for (int i = 0; i < rows; i++) {
            System.arraycopy(initialBoard[i], 0, this.board[i], 0, cols);
        }
    }
    
    /**
     * 计算下一代的状态（使用额外空间）
     * 时间复杂度：O(m*n)
     * 空间复杂度：O(m*n)
     */
    public void nextGeneration() {
        // 创建新的棋盘来存储下一代状态
        int[][] newBoard = new int[rows][cols];
        
        // 遍历每个细胞
        for (int i = 0; i < rows; i++) {
            for (int j = 0; j < cols; j++) {
                // 计算周围活细胞数量
                int liveNeighbors = countLiveNeighbors(i, j);
                
                // 应用生命游戏规则
                if (board[i][j] == 1) {
                    // 活细胞
                    if (liveNeighbors < 2 || liveNeighbors > 3) {
                        newBoard[i][j] = 0;  // 死亡
                    } else {
                        newBoard[i][j] = 1;  // 存活
                    }
                } else {
                    // 死细胞
                    if (liveNeighbors == 3) {
                        newBoard[i][j] = 1;  // 繁殖
                    } else {
                        newBoard[i][j] = 0;  // 保持死亡
                    }
                }
            }
        }
        
        // 更新棋盘
        board = newBoard;
    }
    
    /**
     * 使用原地算法计算下一代状态
     * 时间复杂度：O(m*n)
     * 空间复杂度：O(1)
     * 使用特殊标记：2表示从活到死，-1表示从死到活
     */
    public void nextGenerationInPlace() {
        // 遍历每个细胞
        for (int i = 0; i < rows; i++) {
            for (int j = 0; j < cols; j++) {
                // 计算周围活细胞数量
                int liveNeighbors = countLiveNeighborsWithMarkers(i, j);
                
                // 应用生命游戏规则
                if (board[i][j] == 1) {
                    // 活细胞
                    if (liveNeighbors < 2 || liveNeighbors > 3) {
                        board[i][j] = 2;  // 标记为从活到死
                    }
                    // 否则保持为1，继续存活
                } else {
                    // 死细胞
                    if (liveNeighbors == 3) {
                        board[i][j] = -1;  // 标记为从死到活
                    }
                    // 否则保持为0，继续死亡
                }
            }
        }
        
        // 解析标记，恢复真实状态
        for (int i = 0; i < rows; i++) {
            for (int j = 0; j < cols; j++) {
                if (board[i][j] == 2) {
                    board[i][j] = 0;  // 死亡
                } else if (board[i][j] == -1) {
                    board[i][j] = 1;  // 新生
                }
            }
        }
    }
    
    /**
     * 计算指定位置周围的活细胞数量
     * @param row 行索引
     * @param col 列索引
     * @return 活细胞数量
     */
    private int countLiveNeighbors(int row, int col) {
        int count = 0;
        // 8个方向的偏移
        int[][] directions = {
            {-1, -1}, {-1, 0}, {-1, 1},
            {0, -1},           {0, 1},
            {1, -1},  {1, 0}, {1, 1}
        };
        
        for (int[] dir : directions) {
            int newRow = row + dir[0];
            int newCol = col + dir[1];
            
            // 检查边界并计算活细胞
            if (newRow >= 0 && newRow < rows && newCol >= 0 && newCol < cols) {
                if (board[newRow][newCol] == 1) {
                    count++;
                }
            }
        }
        
        return count;
    }
    
    /**
     * 在原地算法中计算周围的活细胞数量（考虑标记）
     * @param row 行索引
     * @param col 列索引
     * @return 活细胞数量
     */
    private int countLiveNeighborsWithMarkers(int row, int col) {
        int count = 0;
        int[][] directions = {
            {-1, -1}, {-1, 0}, {-1, 1},
            {0, -1},           {0, 1},
            {1, -1},  {1, 0}, {1, 1}
        };
        
        for (int[] dir : directions) {
            int newRow = row + dir[0];
            int newCol = col + dir[1];
            
            if (newRow >= 0 && newRow < rows && newCol >= 0 && newCol < cols) {
                // 1或2表示之前是活细胞
                if (board[newRow][newCol] == 1 || board[newRow][newCol] == 2) {
                    count++;
                }
            }
        }
        
        return count;
    }
    
    /**
     * 获取当前棋盘状态
     * @return 棋盘状态的深拷贝
     */
    public int[][] getBoard() {
        int[][] copy = new int[rows][cols];
        for (int i = 0; i < rows; i++) {
            System.arraycopy(board[i], 0, copy[i], 0, cols);
        }
        return copy;
    }
    
    /**
     * 打印棋盘状态
     */
    public void printBoard() {
        for (int i = 0; i < rows; i++) {
            for (int j = 0; j < cols; j++) {
                System.out.print(board[i][j] == 1 ? "█ " : "· ");
            }
            System.out.println();
        }
        System.out.println();
    }
    
    /**
     * 模拟多代生命游戏
     * @param generations 模拟的代数
     * @param inPlace 是否使用原地算法
     */
    public void simulate(int generations, boolean inPlace) {
        if (generations <= 0) {
            return;
        }
        
        for (int i = 0; i < generations; i++) {
            if (inPlace) {
                nextGenerationInPlace();
            } else {
                nextGeneration();
            }
        }
    }
    
    /**
     * 测试生命游戏
     */
    public static void main(String[] args) {
        System.out.println("=== 测试康威生命游戏 ===");
        
        // 测试用例：闪烁器（Blinker）
        int[][] blinker = {
            {0, 1, 0},
            {0, 1, 0},
            {0, 1, 0}
        };
        
        System.out.println("闪烁器 - 初始状态:");
        GameOfLife2D game1 = new GameOfLife2D(blinker);
        game1.printBoard();
        
        System.out.println("第1代（原地算法）:");
        game1.nextGenerationInPlace();
        game1.printBoard();
        
        System.out.println("第2代（原地算法）:");
        game1.nextGenerationInPlace();
        game1.printBoard();
        
        // 测试用例：滑翔机（Glider）
        int[][] glider = {
            {0, 1, 0},
            {0, 0, 1},
            {1, 1, 1}
        };
        
        System.out.println("滑翔机 - 初始状态:");
        GameOfLife2D game2 = new GameOfLife2D(glider);
        game2.printBoard();
        
        for (int i = 1; i <= 4; i++) {
            System.out.println("滑翔机 - 第" + i + "代:");
            game2.nextGeneration();
            game2.printBoard();
        }
        
        // 测试用例：高斯帕机枪（Gosper Glider Gun）的一部分
        System.out.println("高斯帕机枪 - 初始状态:");
        int[][] gosperGliderGun = new int[10][38];
        // 添加高斯帕机枪的图案
        // 第一部分
        gosperGliderGun[5][1] = 1;
        gosperGliderGun[6][1] = 1;
        gosperGliderGun[5][2] = 1;
        gosperGliderGun[6][2] = 1;
        
        // 第二部分
        gosperGliderGun[5][11] = 1;
        gosperGliderGun[6][11] = 1;
        gosperGliderGun[7][11] = 1;
        gosperGliderGun[4][12] = 1;
        gosperGliderGun[8][12] = 1;
        gosperGliderGun[3][13] = 1;
        gosperGliderGun[9][13] = 1;
        gosperGliderGun[3][14] = 1;
        gosperGliderGun[9][14] = 1;
        gosperGliderGun[6][15] = 1;
        gosperGliderGun[4][16] = 1;
        gosperGliderGun[8][16] = 1;
        gosperGliderGun[5][17] = 1;
        gosperGliderGun[6][17] = 1;
        gosperGliderGun[7][17] = 1;
        gosperGliderGun[6][18] = 1;
        
        // 第三部分
        gosperGliderGun[3][21] = 1;
        gosperGliderGun[4][21] = 1;
        gosperGliderGun[5][21] = 1;
        gosperGliderGun[3][22] = 1;
        gosperGliderGun[4][22] = 1;
        gosperGliderGun[5][22] = 1;
        gosperGliderGun[2][23] = 1;
        gosperGliderGun[6][23] = 1;
        gosperGliderGun[1][25] = 1;
        gosperGliderGun[2][25] = 1;
        gosperGliderGun[6][25] = 1;
        gosperGliderGun[7][25] = 1;
        
        // 第四部分
        gosperGliderGun[3][35] = 1;
        gosperGliderGun[4][35] = 1;
        gosperGliderGun[3][36] = 1;
        gosperGliderGun[4][36] = 1;
        
        GameOfLife2D game3 = new GameOfLife2D(gosperGliderGun);
        System.out.println("高斯帕机枪 - 前几代:");
        for (int i = 1; i <= 2; i++) {
            System.out.println("第" + i + "代:");
            game3.nextGeneration();
            game3.printBoard();
        }
    }
}

===============================================

文件: game_of_life.py
===============================================
#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
康威生命游戏实现 (Python版本)

算法思路：
康威生命游戏是一个细胞自动机，每个细胞根据其周围8个邻居的状态按照以下规则演化：
1. 活细胞周围活细胞数少于2个，则死亡（孤独）
2. 活细胞周围活细胞数为2或3个，则继续存活
3. 活细胞周围活细胞数多于3个，则死亡（拥挤）
4. 死细胞周围活细胞数为3个，则复活（繁殖）

时间复杂度：O(m*n) 每代
空间复杂度：O(m*n)

应用场景：
1. 生物学：细胞自动机模型
2. 物理学：粒子系统模拟
3. 艺术：生成艺术图案
4. 教育：复杂系统教学
"""

import copy
import time

class GameOfLife:
    """康威生命游戏实现类"""
    
    def __init__(self, initial_board):
        """
        构造函数
        :param initial_board: 初始棋盘状态，二维列表，1表示活细胞，0表示死细胞
        """
        if not initial_board or not initial_board[0]:
            raise ValueError("初始棋盘不能为空")
        
        self.rows = len(initial_board)
        self.cols = len(initial_board[0])
        self.board = copy.deepcopy(initial_board)
    
    def next_generation(self):
        """
        计算下一代的状态
        时间复杂度：O(m*n)
        空间复杂度：O(m*n)
        """
        # 创建新的棋盘来存储下一代状态
        new_board = [[0 for _ in range(self.cols)] for _ in range(self.rows)]
        
        # 遍历每个细胞
        for i in range(self.rows):
            for j in range(self.cols):
                # 计算周围活细胞数量
                live_neighbors = self._count_live_neighbors(i, j)
                
                # 应用生命游戏规则
                if self.board[i][j] == 1:
                    # 活细胞
                    if live_neighbors < 2 or live_neighbors > 3:
                        new_board[i][j] = 0  # 死亡
                    else:
                        new_board[i][j] = 1  # 存活
                else:
                    # 死细胞
                    if live_neighbors == 3:
                        new_board[i][j] = 1  # 繁殖
                    else:
                        new_board[i][j] = 0  # 保持死亡
        
        # 更新棋盘
        self.board = new_board
    
    def next_generation_in_place(self):
        """
        使用原地算法计算下一代状态
        时间复杂度：O(m*n)
        空间复杂度：O(1)
        使用特殊标记：2表示从活到死，-1表示从死到活
        """
        # 遍历每个细胞
        for i in range(self.rows):
            for j in range(self.cols):
                # 计算周围活细胞数量
                live_neighbors = self._count_live_neighbors_with_markers(i, j)
                
                # 应用生命游戏规则
                if self.board[i][j] == 1:
                    # 活细胞
                    if live_neighbors < 2 or live_neighbors > 3:
                        self.board[i][j] = 2  # 标记为从活到死
                    # 否则保持为1，继续存活
                else:
                    # 死细胞
                    if live_neighbors == 3:
                        self.board[i][j] = -1  # 标记为从死到活
                    # 否则保持为0，继续死亡
        
        # 解析标记，恢复真实状态
        for i in range(self.rows):
            for j in range(self.cols):
                if self.board[i][j] == 2:
                    self.board[i][j] = 0  # 死亡
                elif self.board[i][j] == -1:
                    self.board[i][j] = 1  # 新生
    
    def _count_live_neighbors(self, row, col):
        """
        计算指定位置周围的活细胞数量
        :param row: 行索引
        :param col: 列索引
        :return: 活细胞数量
        """
        count = 0
        # 8个方向的偏移
        directions = [
            (-1, -1), (-1, 0), (-1, 1),
            (0, -1),           (0, 1),
            (1, -1),  (1, 0), (1, 1)
        ]
        
        for dr, dc in directions:
            new_row = row + dr
            new_col = col + dc
            
            # 检查边界并计算活细胞
            if 0 <= new_row < self.rows and 0 <= new_col < self.cols:
                if self.board[new_row][new_col] == 1:
                    count += 1
        
        return count
    
    def _count_live_neighbors_with_markers(self, row, col):
        """
        在原地算法中计算周围的活细胞数量（考虑标记）
        :param row: 行索引
        :param col: 列索引
        :return: 活细胞数量
        """
        count = 0
        directions = [
            (-1, -1), (-1, 0), (-1, 1),
            (0, -1),           (0, 1),
            (1, -1),  (1, 0), (1, 1)
        ]
        
        for dr, dc in directions:
            new_row = row + dr
            new_col = col + dc
            
            if 0 <= new_row < self.rows and 0 <= new_col < self.cols:
                # 1或2表示之前是活细胞
                if self.board[new_row][new_col] == 1 or self.board[new_row][new_col] == 2:
                    count += 1
        
        return count
    
    def get_board(self):
        """
        获取当前棋盘状态
        :return: 棋盘状态的深拷贝
        """
        return copy.deepcopy(self.board)
    
    def print_board(self):
        """
        打印棋盘状态
        """
        for i in range(self.rows):
            for j in range(self.cols):
                print("█" if self.board[i][j] == 1 else "·", end=" ")
            print()
        print()
    
    @staticmethod
    def test_game_of_life():
        """测试生命游戏"""
        print("=== 测试康威生命游戏 ===")
        
        # 测试用例：闪烁器（Blinker）
        blinker = [
            [0, 1, 0],
            [0, 1, 0],
            [0, 1, 0]
        ]
        
        print("闪烁器 - 初始状态:")
        game = GameOfLife(blinker)
        game.print_board()
        
        print("第1代（原地算法）:")
        game.next_generation_in_place()
        game.print_board()
        
        print("第2代（原地算法）:")
        game.next_generation_in_place()
        game.print_board()
        
        # 测试用例：滑翔机（Glider）
        glider = [
            [0, 1, 0],
            [0, 0, 1],
            [1, 1, 1]
        ]
        
        print("滑翔机 - 初始状态:")
        glider_game = GameOfLife(glider)
        glider_game.print_board()
        
        for i in range(1, 5):
            print(f"滑翔机 - 第{i}代:")
            glider_game.next_generation()
            glider_game.print_board()
        
        # 测试用例：高斯帕机枪（Gosper Glider Gun）
        print("高斯帕机枪 - 初始状态:")
        gosper_glider_gun = [
            [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
            [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
            [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
            [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
            [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
            [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
            [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
            [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
            [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
            [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
            [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
            [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
            [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
            [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
            [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
            [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
            [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
            [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
            [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
            [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
            [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
            [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
            [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
            [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
            [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
            [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
            [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
            [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
            [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
            [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
            [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
            [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
            [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
            [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
            [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
            [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
            [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
            [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
        ]
        
        # 添加高斯帕机枪的图案
        # 第一部分
        gosper_glider_gun[5][1] = 1
        gosper_glider_gun[6][1] = 1
        gosper_glider_gun[5][2] = 1
        gosper_glider_gun[6][2] = 1
        
        # 第二部分
        gosper_glider_gun[5][11] = 1
        gosper_glider_gun[6][11] = 1
        gosper_glider_gun[7][11] = 1
        gosper_glider_gun[4][12] = 1
        gosper_glider_gun[8][12] = 1
        gosper_glider_gun[3][13] = 1
        gosper_glider_gun[9][13] = 1
        gosper_glider_gun[3][14] = 1
        gosper_glider_gun[9][14] = 1
        gosper_glider_gun[6][15] = 1
        gosper_glider_gun[4][16] = 1
        gosper_glider_gun[8][16] = 1
        gosper_glider_gun[5][17] = 1
        gosper_glider_gun[6][17] = 1
        gosper_glider_gun[7][17] = 1
        gosper_glider_gun[6][18] = 1
        
        # 第三部分
        gosper_glider_gun[3][21] = 1
        gosper_glider_gun[4][21] = 1
        gosper_glider_gun[5][21] = 1
        gosper_glider_gun[3][22] = 1
        gosper_glider_gun[4][22] = 1
        gosper_glider_gun[5][22] = 1
        gosper_glider_gun[2][23] = 1
        gosper_glider_gun[6][23] = 1
        gosper_glider_gun[1][25] = 1
        gosper_glider_gun[2][25] = 1
        gosper_glider_gun[6][25] = 1
        gosper_glider_gun[7][25] = 1
        
        # 第四部分
        gosper_glider_gun[3][35] = 1
        gosper_glider_gun[4][35] = 1
        gosper_glider_gun[3][36] = 1
        gosper_glider_gun[4][36] = 1
        
        gosper_game = GameOfLife(gosper_glider_gun)
        print("高斯帕机枪 - 前几代:")
        for i in range(1, 3):
            print(f"第{i}代:")
            gosper_game.next_generation()
            gosper_game.print_board()

if __name__ == "__main__":
    GameOfLife.test_game_of_life()

===============================================

文件: game_of_life_2d.cpp
===============================================
#include <iostream>
#include <vector>
#include <algorithm>
#include <cmath>
#include <stdexcept>
#include <memory>
#include <limits>
#include <random>
#include <chrono>

using namespace std;

/**
 * 康威生命游戏实现 (C++版本)
 * 
 * 算法思路：
 * 康威生命游戏是一个细胞自动机，每个细胞根据其周围8个邻居的状态按照以下规则演化：
 * 1. 活细胞周围活细胞数少于2个，则死亡（孤独）
 * 2. 活细胞周围活细胞数为2或3个，则继续存活
 * 3. 活细胞周围活细胞数多于3个，则死亡（拥挤）
 * 4. 死细胞周围活细胞数为3个，则复活（繁殖）
 * 
 * 时间复杂度：O(m*n) 每代
 * 空间复杂度：O(m*n)
 * 
 * 应用场景：
 * 1. 生物学：细胞自动机模型
 * 2. 物理学：粒子系统模拟
 * 3. 艺术：生成艺术图案
 * 4. 教育：复杂系统教学
 * 
 * 相关题目：
 * 1. LeetCode 289. 生命游戏
 */

class GameOfLife2D {
private:
    vector<vector<int>> board;
    int rows;
    int cols;
    
    /**
     * 计算指定位置周围的活细胞数量
     * @param row 行索引
     * @param col 列索引
     * @return 活细胞数量
     */
    int countLiveNeighbors(int row, int col) const {
        int count = 0;
        // 8个方向的偏移
        vector<pair<int, int>> directions = {
            {-1, -1}, {-1, 0}, {-1, 1},
            {0, -1},           {0, 1},
            {1, -1},  {1, 0}, {1, 1}
        };
        
        for (const auto& dir : directions) {
            int newRow = row + dir.first;
            int newCol = col + dir.second;
            
            // 检查边界并计算活细胞
            if (newRow >= 0 && newRow < rows && newCol >= 0 && newCol < cols) {
                if (board[newRow][newCol] == 1) {
                    count++;
                }
            }
        }
        
        return count;
    }
    
    /**
     * 在原地算法中计算周围的活细胞数量（考虑标记）
     * @param row 行索引
     * @param col 列索引
     * @return 活细胞数量
     */
    int countLiveNeighborsWithMarkers(int row, int col) const {
        int count = 0;
        vector<pair<int, int>> directions = {
            {-1, -1}, {-1, 0}, {-1, 1},
            {0, -1},           {0, 1},
            {1, -1},  {1, 0}, {1, 1}
        };
        
        for (const auto& dir : directions) {
            int newRow = row + dir.first;
            int newCol = col + dir.second;
            
            if (newRow >= 0 && newRow < rows && newCol >= 0 && newCol < cols) {
                // 1或2表示之前是活细胞
                if (board[newRow][newCol] == 1 || board[newRow][newCol] == 2) {
                    count++;
                }
            }
        }
        
        return count;
    }
    
public:
    /**
     * 构造函数
     * @param initialBoard 初始棋盘状态，二维数组，1表示活细胞，0表示死细胞
     */
    GameOfLife2D(const vector<vector<int>>& initialBoard) {
        if (initialBoard.empty() || initialBoard[0].empty()) {
            throw invalid_argument("初始棋盘不能为空");
        }
        
        this->rows = initialBoard.size();
        this->cols = initialBoard[0].size();
        this->board = initialBoard;
    }
    
    /**
     * 计算下一代的状态（使用额外空间）
     * 时间复杂度：O(m*n)
     * 空间复杂度：O(m*n)
     */
    void nextGeneration() {
        // 创建新的棋盘来存储下一代状态
        vector<vector<int>> newBoard(rows, vector<int>(cols, 0));
        
        // 遍历每个细胞
        for (int i = 0; i < rows; i++) {
            for (int j = 0; j < cols; j++) {
                // 计算周围活细胞数量
                int liveNeighbors = countLiveNeighbors(i, j);
                
                // 应用生命游戏规则
                if (board[i][j] == 1) {
                    // 活细胞
                    if (liveNeighbors < 2 || liveNeighbors > 3) {
                        newBoard[i][j] = 0;  // 死亡
                    } else {
                        newBoard[i][j] = 1;  // 存活
                    }
                } else {
                    // 死细胞
                    if (liveNeighbors == 3) {
                        newBoard[i][j] = 1;  // 繁殖
                    } else {
                        newBoard[i][j] = 0;  // 保持死亡
                    }
                }
            }
        }
        
        // 更新棋盘
        board = newBoard;
    }
    
    /**
     * 使用原地算法计算下一代状态
     * 时间复杂度：O(m*n)
     * 空间复杂度：O(1)
     * 使用特殊标记：2表示从活到死，-1表示从死到活
     */
    void nextGenerationInPlace() {
        // 遍历每个细胞
        for (int i = 0; i < rows; i++) {
            for (int j = 0; j < cols; j++) {
                // 计算周围活细胞数量
                int liveNeighbors = countLiveNeighborsWithMarkers(i, j);
                
                // 应用生命游戏规则
                if (board[i][j] == 1) {
                    // 活细胞
                    if (liveNeighbors < 2 || liveNeighbors > 3) {
                        board[i][j] = 2;  // 标记为从活到死
                    }
                    // 否则保持为1，继续存活
                } else {
                    // 死细胞
                    if (liveNeighbors == 3) {
                        board[i][j] = -1;  // 标记为从死到活
                    }
                    // 否则保持为0，继续死亡
                }
            }
        }
        
        // 解析标记，恢复真实状态
        for (int i = 0; i < rows; i++) {
            for (int j = 0; j < cols; j++) {
                if (board[i][j] == 2) {
                    board[i][j] = 0;  // 死亡
                } else if (board[i][j] == -1) {
                    board[i][j] = 1;  // 新生
                }
            }
        }
    }
    
    /**
     * 获取当前棋盘状态
     * @return 棋盘状态的深拷贝
     */
    vector<vector<int>> getBoard() const {
        return board;
    }
    
    /**
     * 打印棋盘状态
     */
    void printBoard() const {
        for (int i = 0; i < rows; i++) {
            for (int j = 0; j < cols; j++) {
                cout << (board[i][j] == 1 ? "█ " : "· ");
            }
            cout << endl;
        }
        cout << endl;
    }
    
    /**
     * 模拟多代生命游戏
     * @param generations 模拟的代数
     * @param inPlace 是否使用原地算法
     */
    void simulate(int generations, bool inPlace = true) {
        if (generations <= 0) {
            return;
        }
        
        for (int i = 0; i < generations; i++) {
            if (inPlace) {
                nextGenerationInPlace();
            } else {
                nextGeneration();
            }
        }
    }
};

/**
 * 测试生命游戏
 */
void testGameOfLife() {
    cout << "=== 测试康威生命游戏 ===" << endl;
    
    // 测试用例：闪烁器（Blinker）
    vector<vector<int>> blinker = {
        {0, 1, 0},
        {0, 1, 0},
        {0, 1, 0}
    };
    
    cout << "闪烁器 - 初始状态:" << endl;
    GameOfLife2D game1(blinker);
    game1.printBoard();
    
    cout << "第1代（原地算法）:" << endl;
    game1.nextGenerationInPlace();
    game1.printBoard();
    
    cout << "第2代（原地算法）:" << endl;
    game1.nextGenerationInPlace();
    game1.printBoard();
    
    // 测试用例：滑翔机（Glider）
    vector<vector<int>> glider = {
        {0, 1, 0},
        {0, 0, 1},
        {1, 1, 1}
    };
    
    cout << "滑翔机 - 初始状态:" << endl;
    GameOfLife2D game2(glider);
    game2.printBoard();
    
    for (int i = 1; i <= 4; i++) {
        cout << "滑翔机 - 第" << i << "代:" << endl;
        game2.nextGeneration();
        game2.printBoard();
    }
    
    // 测试用例：高斯帕机枪（Gosper Glider Gun）的一部分
    cout << "高斯帕机枪 - 初始状态:" << endl;
    vector<vector<int>> gosperGliderGun(10, vector<int>(38, 0));
    
    // 添加高斯帕机枪的图案
    // 第一部分
    gosperGliderGun[5][1] = 1;
    gosperGliderGun[6][1] = 1;
    gosperGliderGun[5][2] = 1;
    gosperGliderGun[6][2] = 1;
    
    // 第二部分
    gosperGliderGun[5][11] = 1;
    gosperGliderGun[6][11] = 1;
    gosperGliderGun[7][11] = 1;
    gosperGliderGun[4][12] = 1;
    gosperGliderGun[8][12] = 1;
    gosperGliderGun[3][13] = 1;
    gosperGliderGun[9][13] = 1;
    gosperGliderGun[3][14] = 1;
    gosperGliderGun[9][14] = 1;
    gosperGliderGun[6][15] = 1;
    gosperGliderGun[4][16] = 1;
    gosperGliderGun[8][16] = 1;
    gosperGliderGun[5][17] = 1;
    gosperGliderGun[6][17] = 1;
    gosperGliderGun[7][17] = 1;
    gosperGliderGun[6][18] = 1;
    
    // 第三部分
    gosperGliderGun[3][21] = 1;
    gosperGliderGun[4][21] = 1;
    gosperGliderGun[5][21] = 1;
    gosperGliderGun[3][22] = 1;
    gosperGliderGun[4][22] = 1;
    gosperGliderGun[5][22] = 1;
    gosperGliderGun[2][23] = 1;
    gosperGliderGun[6][23] = 1;
    gosperGliderGun[1][25] = 1;
    gosperGliderGun[2][25] = 1;
    gosperGliderGun[6][25] = 1;
    gosperGliderGun[7][25] = 1;
    
    // 第四部分
    gosperGliderGun[3][35] = 1;
    gosperGliderGun[4][35] = 1;
    gosperGliderGun[3][36] = 1;
    gosperGliderGun[4][36] = 1;
    
    GameOfLife2D game3(gosperGliderGun);
    cout << "高斯帕机枪 - 前几代:" << endl;
    for (int i = 1; i <= 2; i++) {
        cout << "第" << i << "代:" << endl;
        game3.nextGeneration();
        game3.printBoard();
    }
}

int main() {
    testGameOfLife();
    return 0;
}

===============================================

文件: game_of_life_2d.py
===============================================
#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
康威生命游戏实现 (Python版本)

算法思路：
康威生命游戏是一个细胞自动机，每个细胞根据其周围8个邻居的状态按照以下规则演化：
1. 活细胞周围活细胞数少于2个，则死亡（孤独）
2. 活细胞周围活细胞数为2或3个，则继续存活
3. 活细胞周围活细胞数多于3个，则死亡（拥挤）
4. 死细胞周围活细胞数为3个，则复活（繁殖）

时间复杂度：O(m*n) 每代
空间复杂度：O(m*n)

应用场景：
1. 生物学：细胞自动机模型
2. 物理学：粒子系统模拟
3. 艺术：生成艺术图案
4. 教育：复杂系统教学

相关题目：
1. LeetCode 289. 生命游戏
"""

import copy
import time

class GameOfLife2D:
    """康威生命游戏实现类"""
    
    def __init__(self, initial_board):
        """
        构造函数
        :param initial_board: 初始棋盘状态，二维列表，1表示活细胞，0表示死细胞
        """
        if not initial_board or not initial_board[0]:
            raise ValueError("初始棋盘不能为空")
        
        self.rows = len(initial_board)
        self.cols = len(initial_board[0])
        self.board = copy.deepcopy(initial_board)
    
    def next_generation(self):
        """
        计算下一代的状态
        时间复杂度：O(m*n)
        空间复杂度：O(m*n)
        """
        # 创建新的棋盘来存储下一代状态
        new_board = [[0 for _ in range(self.cols)] for _ in range(self.rows)]
        
        # 遍历每个细胞
        for i in range(self.rows):
            for j in range(self.cols):
                # 计算周围活细胞数量
                live_neighbors = self._count_live_neighbors(i, j)
                
                # 应用生命游戏规则
                if self.board[i][j] == 1:
                    # 活细胞
                    if live_neighbors < 2 or live_neighbors > 3:
                        new_board[i][j] = 0  # 死亡
                    else:
                        new_board[i][j] = 1  # 存活
                else:
                    # 死细胞
                    if live_neighbors == 3:
                        new_board[i][j] = 1  # 繁殖
                    else:
                        new_board[i][j] = 0  # 保持死亡
        
        # 更新棋盘
        self.board = new_board
    
    def next_generation_in_place(self):
        """
        使用原地算法计算下一代状态
        时间复杂度：O(m*n)
        空间复杂度：O(1)
        使用特殊标记：2表示从活到死，-1表示从死到活
        """
        # 遍历每个细胞
        for i in range(self.rows):
            for j in range(self.cols):
                # 计算周围活细胞数量
                live_neighbors = self._count_live_neighbors_with_markers(i, j)
                
                # 应用生命游戏规则
                if self.board[i][j] == 1:
                    # 活细胞
                    if live_neighbors < 2 or live_neighbors > 3:
                        self.board[i][j] = 2  # 标记为从活到死
                    # 否则保持为1，继续存活
                else:
                    # 死细胞
                    if live_neighbors == 3:
                        self.board[i][j] = -1  # 标记为从死到活
                    # 否则保持为0，继续死亡
        
        # 解析标记，恢复真实状态
        for i in range(self.rows):
            for j in range(self.cols):
                if self.board[i][j] == 2:
                    self.board[i][j] = 0  # 死亡
                elif self.board[i][j] == -1:
                    self.board[i][j] = 1  # 新生
    
    def _count_live_neighbors(self, row, col):
        """
        计算指定位置周围的活细胞数量
        :param row: 行索引
        :param col: 列索引
        :return: 活细胞数量
        """
        count = 0
        # 8个方向的偏移
        directions = [
            (-1, -1), (-1, 0), (-1, 1),
            (0, -1),           (0, 1),
            (1, -1),  (1, 0), (1, 1)
        ]
        
        for dr, dc in directions:
            new_row = row + dr
            new_col = col + dc
            
            # 检查边界并计算活细胞
            if 0 <= new_row < self.rows and 0 <= new_col < self.cols:
                if self.board[new_row][new_col] == 1:
                    count += 1
        
        return count
    
    def _count_live_neighbors_with_markers(self, row, col):
        """
        在原地算法中计算周围的活细胞数量（考虑标记）
        :param row: 行索引
        :param col: 列索引
        :return: 活细胞数量
        """
        count = 0
        directions = [
            (-1, -1), (-1, 0), (-1, 1),
            (0, -1),           (0, 1),
            (1, -1),  (1, 0), (1, 1)
        ]
        
        for dr, dc in directions:
            new_row = row + dr
            new_col = col + dc
            
            if 0 <= new_row < self.rows and 0 <= new_col < self.cols:
                # 1或2表示之前是活细胞
                if self.board[new_row][new_col] == 1 or self.board[new_row][new_col] == 2:
                    count += 1
        
        return count
    
    def get_board(self):
        """
        获取当前棋盘状态
        :return: 棋盘状态的深拷贝
        """
        return copy.deepcopy(self.board)
    
    def print_board(self):
        """
        打印棋盘状态
        """
        for i in range(self.rows):
            for j in range(self.cols):
                print("█" if self.board[i][j] == 1 else "·", end=" ")
            print()
        print()
    
    def simulate(self, generations, in_place=True):
        """
        模拟多代生命游戏
        :param generations: 模拟的代数
        :param in_place: 是否使用原地算法
        """
        if generations <= 0:
            return
        
        for i in range(generations):
            if in_place:
                self.next_generation_in_place()
            else:
                self.next_generation()
    
    @staticmethod
    def test_game_of_life():
        """测试生命游戏"""
        print("=== 测试康威生命游戏 ===")
        
        # 测试用例：闪烁器（Blinker）
        blinker = [
            [0, 1, 0],
            [0, 1, 0],
            [0, 1, 0]
        ]
        
        print("闪烁器 - 初始状态:")
        game1 = GameOfLife2D(blinker)
        game1.print_board()
        
        print("第1代（原地算法）:")
        game1.next_generation_in_place()
        game1.print_board()
        
        print("第2代（原地算法）:")
        game1.next_generation_in_place()
        game1.print_board()
        
        # 测试用例：滑翔机（Glider）
        glider = [
            [0, 1, 0],
            [0, 0, 1],
            [1, 1, 1]
        ]
        
        print("滑翔机 - 初始状态:")
        game2 = GameOfLife2D(glider)
        game2.print_board()
        
        for i in range(1, 5):
            print(f"滑翔机 - 第{i}代:")
            game2.next_generation()
            game2.print_board()
        
        # 测试用例：高斯帕机枪（Gosper Glider Gun）的一部分
        print("高斯帕机枪 - 初始状态:")
        gosper_glider_gun = [[0 for _ in range(38)] for _ in range(10)]
        
        # 添加高斯帕机枪的图案
        # 第一部分
        gosper_glider_gun[5][1] = 1
        gosper_glider_gun[6][1] = 1
        gosper_glider_gun[5][2] = 1
        gosper_glider_gun[6][2] = 1
        
        # 第二部分
        gosper_glider_gun[5][11] = 1
        gosper_glider_gun[6][11] = 1
        gosper_glider_gun[7][11] = 1
        gosper_glider_gun[4][12] = 1
        gosper_glider_gun[8][12] = 1
        gosper_glider_gun[3][13] = 1
        gosper_glider_gun[9][13] = 1
        gosper_glider_gun[3][14] = 1
        gosper_glider_gun[9][14] = 1
        gosper_glider_gun[6][15] = 1
        gosper_glider_gun[4][16] = 1
        gosper_glider_gun[8][16] = 1
        gosper_glider_gun[5][17] = 1
        gosper_glider_gun[6][17] = 1
        gosper_glider_gun[7][17] = 1
        gosper_glider_gun[6][18] = 1
        
        # 第三部分
        gosper_glider_gun[3][21] = 1
        gosper_glider_gun[4][21] = 1
        gosper_glider_gun[5][21] = 1
        gosper_glider_gun[3][22] = 1
        gosper_glider_gun[4][22] = 1
        gosper_glider_gun[5][22] = 1
        gosper_glider_gun[2][23] = 1
        gosper_glider_gun[6][23] = 1
        gosper_glider_gun[1][25] = 1
        gosper_glider_gun[2][25] = 1
        gosper_glider_gun[6][25] = 1
        gosper_glider_gun[7][25] = 1
        
        # 第四部分
        gosper_glider_gun[3][35] = 1
        gosper_glider_gun[4][35] = 1
        gosper_glider_gun[3][36] = 1
        gosper_glider_gun[4][36] = 1
        
        game3 = GameOfLife2D(gosper_glider_gun)
        print("高斯帕机枪 - 前几代:")
        for i in range(1, 3):
            print(f"第{i}代:")
            game3.next_generation()
            game3.print_board()

if __name__ == "__main__":
    GameOfLife2D.test_game_of_life()

===============================================

文件: LeetCode_1094_CarPooling.java
===============================================
package class185.difference_array_problems;

import java.util.*;

/**
 * LeetCode 1094. 拼车 (Car Pooling)
 * 
 * 题目来源：https://leetcode.cn/problems/car-pooling/
 * 
 * 题目描述：
 * 假设你是一位顺风车司机，车上最初有 capacity 个空座位可以用来载客。
 * 由于道路的限制，车只能向一个方向行驶（也就是说，不允许掉头或改变方向，可以将其想象为一个向量）。
 * 给定整数 capacity 和一个数组 trips，
 * trip[i] = [numPassengersi, fromi, toi] 表示第 i 次旅行有 numPassengersi 乘客，
 * 接他们以及放下他们的位置分别是 fromi 和 toi。这些位置是从汽车的初始位置向东的公里数。
 * 当且仅当你可以在所有给定的行程中接送所有乘客时，返回 true，否则请返回 false。
 * 
 * 示例 1：
 * 输入：trips = [[2,1,5],[3,3,7]], capacity = 4
 * 输出：false
 * 
 * 示例 2：
 * 输入：trips = [[2,1,5],[3,3,7]], capacity = 5
 * 输出：true
 * 
 * 提示：
 * 1 <= trips.length <= 1000
 * trips[i].length == 3
 * 1 <= numPassengersi <= 100
 * 0 <= fromi < toi <= 1000
 * 1 <= capacity <= 10^5
 * 
 * 解题思路：
 * 使用差分数组解决拼车问题。核心思想是：
 * 1. 将每个行程的上下车位置转换为事件点
 * 2. 使用差分数组记录每个位置乘客数量的变化
 * 3. 计算差分数组的前缀和，得到每个位置的乘客数量
 * 4. 检查是否有位置的乘客数量超过容量
 * 
 * 时间复杂度：O(n + m)，其中 n 是行程数量，m 是最大位置
 * 空间复杂度：O(m)
 * 
 * 相关题目：
 * - LeetCode 370. 区间加法
 * - LeetCode 1109. 航班预订统计
 * - LeetCode 253. 会议室II
 */
public class LeetCode_1094_CarPooling {
    
    /**
     * 使用差分数组解决拼车问题
     * @param trips 行程数组，每个行程是 [乘客数, 上车位置, 下车位置]
     * @param capacity 车辆容量
     * @return 是否能完成所有行程
     */
    public static boolean carPooling(int[][] trips, int capacity) {
        if (trips == null || trips.length == 0) {
            return true;
        }
        
        // 找到最大位置
        int maxLocation = 0;
        for (int[] trip : trips) {
            maxLocation = Math.max(maxLocation, trip[2]);
        }
        
        // 创建差分数组，大小为最大位置 + 1
        int[] diff = new int[maxLocation + 1];
        
        // 处理每个行程
        for (int[] trip : trips) {
            int passengers = trip[0];
            int from = trip[1];
            int to = trip[2];
            
            // 在差分数组中标记乘客变化
            diff[from] += passengers;  // 上车位置增加乘客
            if (to < maxLocation) {
                diff[to] -= passengers;  // 下车位置减少乘客
            }
        }
        
        // 计算每个位置的乘客数量
        int currentPassengers = 0;
        for (int i = 0; i <= maxLocation; i++) {
            currentPassengers += diff[i];
            // 如果某个位置的乘客数量超过容量，返回false
            if (currentPassengers > capacity) {
                return false;
            }
        }
        
        return true;
    }
    
    /**
     * 暴力解法（用于对比）
     * 时间复杂度：O(n * m)，其中 n 是行程数量，m 是最大位置
     */
    public static boolean carPoolingBruteForce(int[][] trips, int capacity) {
        if (trips == null || trips.length == 0) {
            return true;
        }
        
        // 找到最大位置
        int maxLocation = 0;
        for (int[] trip : trips) {
            maxLocation = Math.max(maxLocation, trip[2]);
        }
        
        // 创建乘客数量数组
        int[] passengers = new int[maxLocation + 1];
        
        // 处理每个行程
        for (int[] trip : trips) {
            int numPassengers = trip[0];
            int from = trip[1];
            int to = trip[2];
            
            // 直接更新每个位置的乘客数量
            for (int i = from; i < to; i++) {
                passengers[i] += numPassengers;
                if (passengers[i] > capacity) {
                    return false;
                }
            }
        }
        
        return true;
    }
    
    /**
     * 测试拼车问题解法
     */
    public static void main(String[] args) {
        System.out.println("=== LeetCode 1094. 拼车 ===");
        
        // 测试用例1
        System.out.println("测试用例1:");
        int[][] trips1 = {{2, 1, 5}, {3, 3, 7}};
        int capacity1 = 4;
        boolean result1 = carPooling(trips1, capacity1);
        System.out.println("行程: " + Arrays.deepToString(trips1));
        System.out.println("容量: " + capacity1);
        System.out.println("差分数组结果: " + result1);
        System.out.println("暴力解法结果: " + carPoolingBruteForce(trips1, capacity1));
        System.out.println("期望: false");
        System.out.println();
        
        // 测试用例2
        System.out.println("测试用例2:");
        int[][] trips2 = {{2, 1, 5}, {3, 3, 7}};
        int capacity2 = 5;
        boolean result2 = carPooling(trips2, capacity2);
        System.out.println("行程: " + Arrays.deepToString(trips2));
        System.out.println("容量: " + capacity2);
        System.out.println("差分数组结果: " + result2);
        System.out.println("暴力解法结果: " + carPoolingBruteForce(trips2, capacity2));
        System.out.println("期望: true");
        System.out.println();
        
        // 测试用例3
        System.out.println("测试用例3:");
        int[][] trips3 = {{3, 2, 7}, {3, 7, 9}, {8, 3, 9}};
        int capacity3 = 11;
        boolean result3 = carPooling(trips3, capacity3);
        System.out.println("行程: " + Arrays.deepToString(trips3));
        System.out.println("容量: " + capacity3);
        System.out.println("差分数组结果: " + result3);
        System.out.println("暴力解法结果: " + carPoolingBruteForce(trips3, capacity3));
        System.out.println("期望: true");
        System.out.println();
        
        // 性能测试
        System.out.println("=== 性能测试 ===");
        Random random = new Random(42);
        int n = 1000;
        int maxLoc = 1000;
        int[][] trips = new int[n][3];
        
        for (int i = 0; i < n; i++) {
            int from = random.nextInt(maxLoc - 1);
            int to = from + random.nextInt(maxLoc - from) + 1;
            int passengers = random.nextInt(10) + 1;
            trips[i] = new int[]{passengers, from, to};
        }
        
        int capacity = 50;
        
        long startTime = System.nanoTime();
        boolean diffResult = carPooling(trips, capacity);
        long endTime = System.nanoTime();
        System.out.println("差分数组法处理" + n + "个行程时间: " + (endTime - startTime) / 1_000_000.0 + " ms");
        
        startTime = System.nanoTime();
        boolean bruteResult = carPoolingBruteForce(trips, capacity);
        endTime = System.nanoTime();
        System.out.println("暴力解法处理" + n + "个行程时间: " + (endTime - startTime) / 1_000_000.0 + " ms");
        
        System.out.println("两种方法结果是否一致: " + (diffResult == bruteResult));
        
        // 工程化考量
        System.out.println("\n=== 工程化考量 ===");
        System.out.println("1. 边界处理：处理空输入和位置边界");
        System.out.println("2. 性能优化：差分数组将O(n*m)优化为O(n+m)");
        System.out.println("3. 内存优化：只存储必要的差分数组");
        System.out.println("4. 异常处理：检查输入数据的有效性");
        
        // 算法复杂度分析
        System.out.println("\n=== 算法复杂度分析 ===");
        System.out.println("时间复杂度: O(n + m)");
        System.out.println("  - 遍历行程: O(n)");
        System.out.println("  - 计算前缀和: O(m)");
        System.out.println("空间复杂度: O(m)");
        System.out.println("  - 差分数组: O(m)");
    }
}

===============================================

文件: LeetCode_1094_CarPooling_1.java
===============================================
package class008_AdvancedAlgorithmsAndDataStructures.sweep_line_problems;

import java.util.*;

/**
 * LeetCode 1094. 拼车 (Car Pooling)
 * 
 * 题目来源：https://leetcode.cn/problems/car-pooling/
 * 
 * 题目描述：
 * 车上最初有 capacity 个空座位。车只能向一个方向行驶（不允许掉头或改变方向）。
 * 给定整数 capacity 和一个数组 trips ，trip[i] = [numPassengersi, fromi, toi]
 * 表示第 i 次旅行有 numPassengersi 乘客，接他们和放他们的位置分别是 fromi 和 toi。
 * 这些位置是从汽车的初始位置向东的公里数。
 * 当且仅当你可以在所有给定的行程中接送所有乘客时，返回 true，否则返回 false。
 * 
 * 算法思路：
 * 这是一个典型的扫描线算法问题，可以使用以下方法解决：
 * 1. 扫描线算法：将上车和下车事件排序后处理
 * 2. 差分数组：记录每个位置的乘客变化
 * 3. 模拟：按位置顺序模拟乘客上下车过程
 * 
 * 时间复杂度：
 * - 扫描线算法：O(n log n)，其中n是行程数
 * - 差分数组：O(n + m)，其中n是行程数，m是最大位置
 * - 空间复杂度：O(n)
 * 
 * 应用场景：
 * 1. 交通调度：公交车、出租车调度
 * 2. 资源分配：服务器负载均衡
 * 3. 活动安排：会议室预订
 * 
 * 相关题目：
 * 1. LeetCode 1109. 航班预订统计
 * 2. LeetCode 253. 会议室 II
 * 3. LeetCode 218. 天际线问题
 */
public class LeetCode_1094_CarPooling {
    
    /**
     * 方法1：扫描线算法
     * 时间复杂度：O(n log n)
     * 空间复杂度：O(n)
     * @param trips 行程信息数组
     * @param capacity 车辆容量
     * @return 是否可以完成所有行程
     */
    public static boolean carPoolingSweepLine(int[][] trips, int capacity) {
        // 创建事件列表：[位置, 乘客变化]
        List<int[]> events = new ArrayList<>();
        
        // 为每个行程创建上车和下车事件
        for (int[] trip : trips) {
            int passengers = trip[0];
            int start = trip[1];
            int end = trip[2];
            
            // 上车事件（乘客增加）
            events.add(new int[]{start, passengers});
            // 下车事件（乘客减少）
            events.add(new int[]{end, -passengers});
        }
        
        // 按位置排序事件，如果位置相同，下车事件优先于上车事件
        events.sort((a, b) -> {
            if (a[0] != b[0]) {
                return Integer.compare(a[0], b[0]);
            }
            return Integer.compare(a[1], b[1]);
        });
        
        int currentPassengers = 0;
        
        // 扫描所有事件
        for (int[] event : events) {
            currentPassengers += event[1];
            if (currentPassengers > capacity) {
                return false;
            }
        }
        
        return true;
    }
    
    /**
     * 方法2：差分数组
     * 时间复杂度：O(n + m)，其中n是行程数，m是最大位置
     * 空间复杂度：O(m)
     * @param trips 行程信息数组
     * @param capacity 车辆容量
     * @return 是否可以完成所有行程
     */
    public static boolean carPoolingDifferenceArray(int[][] trips, int capacity) {
        // 找到最大位置
        int maxLocation = 0;
        for (int[] trip : trips) {
            maxLocation = Math.max(maxLocation, Math.max(trip[1], trip[2]));
        }
        
        // 创建差分数组
        int[] diff = new int[maxLocation + 1];
        
        // 记录每个行程的乘客变化
        for (int[] trip : trips) {
            int passengers = trip[0];
            int start = trip[1];
            int end = trip[2];
            
            diff[start] += passengers;
            diff[end] -= passengers;
        }
        
        // 通过前缀和计算每个位置的实际乘客数
        int currentPassengers = 0;
        for (int i = 0; i <= maxLocation; i++) {
            currentPassengers += diff[i];
            if (currentPassengers > capacity) {
                return false;
            }
        }
        
        return true;
    }
    
    /**
     * 方法3：使用TreeMap的扫描线算法（适用于位置范围很大的情况）
     * 时间复杂度：O(n log n)
     * 空间复杂度：O(n)
     * @param trips 行程信息数组
     * @param capacity 车辆容量
     * @return 是否可以完成所有行程
     */
    public static boolean carPoolingTreeMap(int[][] trips, int capacity) {
        // 使用TreeMap记录每个位置的乘客变化
        TreeMap<Integer, Integer> changes = new TreeMap<>();
        
        // 记录每个行程的乘客变化
        for (int[] trip : trips) {
            int passengers = trip[0];
            int start = trip[1];
            int end = trip[2];
            
            changes.put(start, changes.getOrDefault(start, 0) + passengers);
            changes.put(end, changes.getOrDefault(end, 0) - passengers);
        }
        
        int currentPassengers = 0;
        
        // 按位置顺序处理所有变化
        for (int change : changes.values()) {
            currentPassengers += change;
            if (currentPassengers > capacity) {
                return false;
            }
        }
        
        return true;
    }
    
    /**
     * 方法4：模拟法（适用于位置范围较小的情况）
     * 时间复杂度：O(n * m)，其中n是行程数，m是最大位置
     * 空间复杂度：O(m)
     * @param trips 行程信息数组
     * @param capacity 车辆容量
     * @return 是否可以完成所有行程
     */
    public static boolean carPoolingSimulation(int[][] trips, int capacity) {
        // 找到最大位置
        int maxLocation = 0;
        for (int[] trip : trips) {
            maxLocation = Math.max(maxLocation, Math.max(trip[1], trip[2]));
        }
        
        // 记录每个位置的乘客数
        int[] passengersAtLocation = new int[maxLocation + 1];
        
        // 模拟每个行程
        for (int[] trip : trips) {
            int passengers = trip[0];
            int start = trip[1];
            int end = trip[2];
            
            // 在行程区间内增加乘客数
            for (int i = start; i < end; i++) {
                passengersAtLocation[i] += passengers;
                if (passengersAtLocation[i] > capacity) {
                    return false;
                }
            }
        }
        
        return true;
    }
    
    /**
     * 测试函数
     */
    public static void main(String[] args) {
        System.out.println("=== 测试 LeetCode 1094. 拼车 ===");
        
        // 测试用例1
        int[][] trips1 = {{2,1,5},{3,3,7}};
        int capacity1 = 4;
        System.out.println("测试用例1:");
        System.out.println("行程: " + Arrays.deepToString(trips1));
        System.out.println("容量: " + capacity1);
        System.out.println("扫描线算法结果: " + carPoolingSweepLine(trips1, capacity1));
        System.out.println("差分数组结果: " + carPoolingDifferenceArray(trips1, capacity1));
        System.out.println("TreeMap结果: " + carPoolingTreeMap(trips1, capacity1));
        System.out.println("模拟法结果: " + carPoolingSimulation(trips1, capacity1));
        System.out.println("期望结果: false");
        System.out.println();
        
        // 测试用例2
        int[][] trips2 = {{2,1,5},{3,3,7}};
        int capacity2 = 5;
        System.out.println("测试用例2:");
        System.out.println("行程: " + Arrays.deepToString(trips2));
        System.out.println("容量: " + capacity2);
        System.out.println("扫描线算法结果: " + carPoolingSweepLine(trips2, capacity2));
        System.out.println("差分数组结果: " + carPoolingDifferenceArray(trips2, capacity2));
        System.out.println("TreeMap结果: " + carPoolingTreeMap(trips2, capacity2));
        System.out.println("模拟法结果: " + carPoolingSimulation(trips2, capacity2));
        System.out.println("期望结果: true");
        System.out.println();
        
        // 测试用例3
        int[][] trips3 = {{3,2,7},{3,7,9},{8,3,9}};
        int capacity3 = 11;
        System.out.println("测试用例3:");
        System.out.println("行程: " + Arrays.deepToString(trips3));
        System.out.println("容量: " + capacity3);
        System.out.println("扫描线算法结果: " + carPoolingSweepLine(trips3, capacity3));
        System.out.println("差分数组结果: " + carPoolingDifferenceArray(trips3, capacity3));
        System.out.println("TreeMap结果: " + carPoolingTreeMap(trips3, capacity3));
        System.out.println("模拟法结果: " + carPoolingSimulation(trips3, capacity3));
        System.out.println("期望结果: true");
        System.out.println();
        
        // 性能测试
        System.out.println("=== 性能测试 ===");
        Random random = new Random(42);
        int tripCount = 10000;
        int[][] trips = new int[tripCount][3];
        
        // 生成随机行程
        for (int i = 0; i < tripCount; i++) {
            int passengers = random.nextInt(100) + 1;
            int start = random.nextInt(1000);
            int end = start + random.nextInt(100) + 1;
            trips[i][0] = passengers;
            trips[i][1] = start;
            trips[i][2] = end;
        }
        int capacity = 10000;
        
        long startTime = System.nanoTime();
        boolean result1 = carPoolingSweepLine(trips, capacity);
        long endTime = System.nanoTime();
        System.out.println("扫描线算法处理" + tripCount + "个行程时间: " + (endTime - startTime) / 1_000_000.0 + " ms, 结果: " + result1);
        
        startTime = System.nanoTime();
        boolean result2 = carPoolingTreeMap(trips, capacity);
        endTime = System.nanoTime();
        System.out.println("TreeMap算法处理" + tripCount + "个行程时间: " + (endTime - startTime) / 1_000_000.0 + " ms, 结果: " + result2);
    }
}

===============================================

文件: leetcode_1094_car_pooling.cpp
===============================================
#include <iostream>
#include <vector>
#include <algorithm>
#include <random>
#include <chrono>

using namespace std;

/**
 * LeetCode 1094. 拼车 (Car Pooling) - C++版本
 * 
 * 解题思路：
 * 使用差分数组解决拼车问题
 * 
 * 时间复杂度：O(n + m)
 * 空间复杂度：O(m)
 */
class Solution {
public:
    bool carPooling(vector<vector<int>>& trips, int capacity) {
        if (trips.empty()) {
            return true;
        }
        
        // 找到最大位置
        int maxLocation = 0;
        for (const auto& trip : trips) {
            maxLocation = max(maxLocation, trip[2]);
        }
        
        // 创建差分数组，大小为最大位置 + 1
        vector<int> diff(maxLocation + 1, 0);
        
        // 处理每个行程
        for (const auto& trip : trips) {
            int passengers = trip[0];
            int from = trip[1];
            int to = trip[2];
            
            // 在差分数组中标记乘客变化
            diff[from] += passengers;  // 上车位置增加乘客
            if (to < maxLocation) {
                diff[to] -= passengers;  // 下车位置减少乘客
            }
        }
        
        // 计算每个位置的乘客数量
        int currentPassengers = 0;
        for (int i = 0; i <= maxLocation; i++) {
            currentPassengers += diff[i];
            // 如果某个位置的乘客数量超过容量，返回false
            if (currentPassengers > capacity) {
                return false;
            }
        }
        
        return true;
    }
    
    // 暴力解法（用于对比）
    bool carPoolingBruteForce(vector<vector<int>>& trips, int capacity) {
        if (trips.empty()) {
            return true;
        }
        
        // 找到最大位置
        int maxLocation = 0;
        for (const auto& trip : trips) {
            maxLocation = max(maxLocation, trip[2]);
        }
        
        // 创建乘客数量数组
        vector<int> passengers(maxLocation + 1, 0);
        
        // 处理每个行程
        for (const auto& trip : trips) {
            int numPassengers = trip[0];
            int from = trip[1];
            int to = trip[2];
            
            // 直接更新每个位置的乘客数量
            for (int i = from; i < to; i++) {
                passengers[i] += numPassengers;
                if (passengers[i] > capacity) {
                    return false;
                }
            }
        }
        
        return true;
    }
};

/**
 * 测试拼车问题解法
 */
void testCarPooling() {
    cout << "=== LeetCode 1094. 拼车 (C++版本) ===" << endl;
    
    Solution solution;
    
    // 测试用例1
    cout << "测试用例1:" << endl;
    vector<vector<int>> trips1 = {{2, 1, 5}, {3, 3, 7}};
    int capacity1 = 4;
    bool result1 = solution.carPooling(trips1, capacity1);
    cout << "行程: ";
    for (const auto& trip : trips1) {
        cout << "[" << trip[0] << "," << trip[1] << "," << trip[2] << "] ";
    }
    cout << endl;
    cout << "容量: " << capacity1 << endl;
    cout << "差分数组结果: " << (result1 ? "true" : "false") << endl;
    cout << "暴力解法结果: " << (solution.carPoolingBruteForce(trips1, capacity1) ? "true" : "false") << endl;
    cout << "期望: false" << endl;
    cout << endl;
    
    // 测试用例2
    cout << "测试用例2:" << endl;
    vector<vector<int>> trips2 = {{2, 1, 5}, {3, 3, 7}};
    int capacity2 = 5;
    bool result2 = solution.carPooling(trips2, capacity2);
    cout << "行程: ";
    for (const auto& trip : trips2) {
        cout << "[" << trip[0] << "," << trip[1] << "," << trip[2] << "] ";
    }
    cout << endl;
    cout << "容量: " << capacity2 << endl;
    cout << "差分数组结果: " << (result2 ? "true" : "false") << endl;
    cout << "暴力解法结果: " << (solution.carPoolingBruteForce(trips2, capacity2) ? "true" : "false") << endl;
    cout << "期望: true" << endl;
    cout << endl;
    
    // 性能测试
    cout << "=== 性能测试 ===" << endl;
    default_random_engine generator(42);
    uniform_int_distribution<int> distribution(0, 1000);
    
    int n = 1000;
    int maxLoc = 1000;
    vector<vector<int>> trips(n, vector<int>(3));
    
    for (int i = 0; i < n; i++) {
        int from = distribution(generator) % (maxLoc - 1);
        int to = from + distribution(generator) % (maxLoc - from) + 1;
        int passengers = distribution(generator) % 10 + 1;
        trips[i] = {passengers, from, to};
    }
    
    int capacity = 50;
    
    auto startTime = chrono::high_resolution_clock::now();
    bool diffResult = solution.carPooling(trips, capacity);
    auto endTime = chrono::high_resolution_clock::now();
    auto duration = chrono::duration_cast<chrono::microseconds>(endTime - startTime);
    cout << "差分数组法处理" << n << "个行程时间: " << duration.count() / 1000.0 << " ms" << endl;
    
    startTime = chrono::high_resolution_clock::now();
    bool bruteResult = solution.carPoolingBruteForce(trips, capacity);
    endTime = chrono::high_resolution_clock::now();
    duration = chrono::duration_cast<chrono::microseconds>(endTime - startTime);
    cout << "暴力解法处理" << n << "个行程时间: " << duration.count() / 1000.0 << " ms" << endl;
    
    cout << "两种方法结果是否一致: " << (diffResult == bruteResult ? "是" : "否") << endl;
    
    // C++语言特性考量
    cout << "\n=== C++语言特性考量 ===" << endl;
    cout << "1. 使用vector容器管理动态数组" << endl;
    cout << "2. 使用const引用避免不必要的拷贝" << endl;
    cout << "3. 使用chrono库进行精确时间测量" << endl;
    cout << "4. 使用RAII原则管理资源" << endl;
}

int main() {
    testCarPooling();
    return 0;
}

===============================================

文件: leetcode_1094_car_pooling.py
===============================================
#!/usr/bin/env python3
"""
LeetCode 1094. 拼车 (Car Pooling) - Python版本

题目来源：https://leetcode.cn/problems/car-pooling/

解题思路：
使用差分数组解决拼车问题

时间复杂度：O(n + m)
空间复杂度：O(m)
"""

import time
import random
from typing import List

class Solution:
    def carPooling(self, trips: List[List[int]], capacity: int) -> bool:
        """
        使用差分数组解决拼车问题
        
        Args:
            trips: 行程数组，每个行程是 [乘客数, 上车位置, 下车位置]
            capacity: 车辆容量
            
        Returns:
            是否能完成所有行程
        """
        if not trips:
            return True
        
        # 找到最大位置
        max_location = 0
        for trip in trips:
            max_location = max(max_location, trip[2])
        
        # 创建差分数组，大小为最大位置 + 1
        diff = [0] * (max_location + 1)
        
        # 处理每个行程
        for trip in trips:
            passengers, from_loc, to_loc = trip
            
            # 在差分数组中标记乘客变化
            diff[from_loc] += passengers  # 上车位置增加乘客
            if to_loc < max_location:
                diff[to_loc] -= passengers  # 下车位置减少乘客
        
        # 计算每个位置的乘客数量
        current_passengers = 0
        for i in range(max_location + 1):
            current_passengers += diff[i]
            # 如果某个位置的乘客数量超过容量，返回False
            if current_passengers > capacity:
                return False
        
        return True
    
    def carPoolingBruteForce(self, trips: List[List[int]], capacity: int) -> bool:
        """
        暴力解法（用于对比）
        
        Args:
            trips: 行程数组
            capacity: 车辆容量
            
        Returns:
            是否能完成所有行程
        """
        if not trips:
            return True
        
        # 找到最大位置
        max_location = 0
        for trip in trips:
            max_location = max(max_location, trip[2])
        
        # 创建乘客数量数组
        passengers = [0] * (max_location + 1)
        
        # 处理每个行程
        for trip in trips:
            num_passengers, from_loc, to_loc = trip
            
            # 直接更新每个位置的乘客数量
            for i in range(from_loc, to_loc):
                passengers[i] += num_passengers
                if passengers[i] > capacity:
                    return False
        
        return True

def test_car_pooling():
    """测试拼车问题解法"""
    solution = Solution()
    
    print("=== LeetCode 1094. 拼车 (Python版本) ===")
    
    # 测试用例1
    print("测试用例1:")
    trips1 = [[2, 1, 5], [3, 3, 7]]
    capacity1 = 4
    result1 = solution.carPooling(trips1, capacity1)
    print(f"行程: {trips1}")
    print(f"容量: {capacity1}")
    print(f"差分数组结果: {result1}")
    print(f"暴力解法结果: {solution.carPoolingBruteForce(trips1, capacity1)}")
    print("期望: False")
    print()
    
    # 测试用例2
    print("测试用例2:")
    trips2 = [[2, 1, 5], [3, 3, 7]]
    capacity2 = 5
    result2 = solution.carPooling(trips2, capacity2)
    print(f"行程: {trips2}")
    print(f"容量: {capacity2}")
    print(f"差分数组结果: {result2}")
    print(f"暴力解法结果: {solution.carPoolingBruteForce(trips2, capacity2)}")
    print("期望: True")
    print()
    
    # 性能测试
    print("=== 性能测试 ===")
    random.seed(42)
    n = 1000
    max_loc = 1000
    trips = []
    
    for i in range(n):
        from_loc = random.randint(0, max_loc - 2)
        to_loc = from_loc + random.randint(1, max_loc - from_loc - 1) + 1
        passengers = random.randint(1, 10)
        trips.append([passengers, from_loc, to_loc])
    
    capacity = 50
    
    start_time = time.time()
    diff_result = solution.carPooling(trips, capacity)
    end_time = time.time()
    print(f"差分数组法处理{n}个行程时间: {(end_time - start_time) * 1000:.2f} ms")
    
    start_time = time.time()
    brute_result = solution.carPoolingBruteForce(trips, capacity)
    end_time = time.time()
    print(f"暴力解法处理{n}个行程时间: {(end_time - start_time) * 1000:.2f} ms")
    
    print(f"两种方法结果是否一致: {diff_result == brute_result}")
    
    # Python语言特性考量
    print("\n=== Python语言特性考量 ===")
    print("1. 使用列表推导式生成测试数据")
    print("2. 使用类型注解提高代码可读性")
    print("3. 使用f-string进行格式化输出")
    print("4. 使用解包操作简化代码")
    
    # 算法复杂度分析
    print("\n=== 算法复杂度分析 ===")
    print("时间复杂度: O(n + m)")
    print("  - 遍历行程: O(n)")
    print("  - 计算前缀和: O(m)")
    print("空间复杂度: O(m)")
    print("  - 差分数组: O(m)")

if __name__ == "__main__":
    test_car_pooling()

===============================================

文件: leetcode_1094_car_pooling_1.cpp
===============================================
#include <iostream>
#include <vector>
#include <algorithm>
#include <map>
#include <set>
#include <queue>
#include <climits>
#include <chrono>
#include <random>

using namespace std;

/**
 * LeetCode 1094. 拼车 (Car Pooling) - C++版本
 * 
 * 题目来源：https://leetcode.cn/problems/car-pooling/
 * 
 * 题目描述：
 * 车上最初有 capacity 个空座位可以用来载客。由于道路拥堵，只能顺序行驶，
 * 车上只能在指定的地点接送乘客。
 * 给定整数 capacity 和一个数组 trips，其中 trip[i] = [numPassengersi, fromi, toi]
 * 表示第 i 次旅行有 numPassengersi 乘客，接他们和放他们的位置分别是 fromi 和 toi。
 * 这些位置是从汽车的初始位置向东的公里数。
 * 当且仅当你可以在所有给定的行程中接送所有乘客时，返回 true，否则返回 false。
 * 
 * 算法思路：
 * 这个问题可以通过以下方法解决：
 * 1. 扫描线算法：将所有事件按位置排序处理
 * 2. 差分数组：记录每个位置的乘客变化
 * 3. 优先队列：模拟乘客上下车过程
 * 
 * 使用扫描线算法的方法：
 * 1. 创建事件列表：上车事件和下车事件
 * 2. 按位置排序事件
 * 3. 扫描所有事件，维护当前乘客数量
 * 
 * 时间复杂度：
 * - 扫描线算法：O(n log n)
 * - 差分数组：O(n + m)
 * - 优先队列：O(n log n)
 * - 空间复杂度：O(n)
 * 
 * 应用场景：
 * 1. 交通调度：车辆载客能力规划
 * 2. 资源分配：服务器负载均衡
 * 3. 项目管理：资源需求分析
 * 
 * 相关题目：
 * 1. LeetCode 253. 会议室 II
 * 2. LeetCode 56. 合并区间
 * 3. LeetCode 218. 天际线问题
 */

/**
 * 方法1：扫描线算法
 * 时间复杂度：O(n log n)
 * 空间复杂度：O(n)
 * @param trips 行程数组
 * @param capacity 车辆容量
 * @return 是否能完成所有行程
 */
bool carPoolingSweepLine(vector<vector<int>>& trips, int capacity) {
    // 创建事件列表：[位置, 乘客变化]
    vector<pair<int, int>> events;
    
    // 为每个行程创建上车和下车事件
    for (const auto& trip : trips) {
        int passengers = trip[0];
        int start = trip[1];
        int end = trip[2];
        
        // 上车事件（乘客增加）
        events.push_back({start, passengers});
        // 下车事件（乘客减少）
        events.push_back({end, -passengers});
    }
    
    // 按位置排序事件，如果位置相同，下车事件优先于上车事件
    sort(events.begin(), events.end(), [](const pair<int, int>& a, const pair<int, int>& b) {
        if (a.first != b.first) {
            return a.first < b.first;
        }
        return a.second < b.second;
    });
    
    int currentPassengers = 0;
    
    // 扫描所有事件
    for (const auto& event : events) {
        currentPassengers += event.second;
        if (currentPassengers > capacity) {
            return false;
        }
    }
    
    return true;
}

/**
 * 方法2：差分数组
 * 时间复杂度：O(n + m)
 * 空间复杂度：O(m)
 * @param trips 行程数组
 * @param capacity 车辆容量
 * @return 是否能完成所有行程
 */
bool carPoolingDifferenceArray(vector<vector<int>>& trips, int capacity) {
    // 找到最大位置
    int maxLocation = 0;
    for (const auto& trip : trips) {
        maxLocation = max(maxLocation, trip[2]);
    }
    
    // 创建差分数组，大小为最大位置 + 1
    vector<int> diff(maxLocation + 1, 0);
    
    // 处理每个行程
    for (const auto& trip : trips) {
        int passengers = trip[0];
        int fromLoc = trip[1];
        int toLoc = trip[2];
        
        // 在差分数组中标记乘客变化
        diff[fromLoc] += passengers;  // 上车位置增加乘客
        if (toLoc < maxLocation) {
            diff[toLoc] -= passengers;  // 下车位置减少乘客
        }
    }
    
    // 计算每个位置的乘客数量
    int currentPassengers = 0;
    for (int i = 0; i <= maxLocation; i++) {
        currentPassengers += diff[i];
        // 如果某个位置的乘客数量超过容量，返回false
        if (currentPassengers > capacity) {
            return false;
        }
    }
    
    return true;
}

/**
 * 方法3：优先队列（最小堆）
 * 时间复杂度：O(n log n)
 * 空间复杂度：O(n)
 * @param trips 行程数组
 * @param capacity 车辆容量
 * @return 是否能完成所有行程
 */
bool carPoolingPriorityQueue(vector<vector<int>>& trips, int capacity) {
    // 按起始位置排序行程
    sort(trips.begin(), trips.end(), [](const vector<int>& a, const vector<int>& b) {
        return a[1] < b[1];
    });
    
    // 最小堆，存储下车位置和乘客数量
    priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;
    
    int currentPassengers = 0;
    
    // 处理每个行程
    for (const auto& trip : trips) {
        int passengers = trip[0];
        int fromLoc = trip[1];
        int toLoc = trip[2];
        
        // 让已经到达下车位置的乘客下车
        while (!pq.empty() && pq.top().first <= fromLoc) {
            currentPassengers -= pq.top().second;
            pq.pop();
        }
        
        // 上车
        currentPassengers += passengers;
        if (currentPassengers > capacity) {
            return false;
        }
        
        // 记录下车事件
        pq.push({toLoc, passengers});
    }
    
    return true;
}

/**
 * 测试函数
 */
void testCarPooling() {
    cout << "=== LeetCode 1094. 拼车 (C++版本) ===" << endl;
    
    // 测试用例1
    cout << "测试用例1:" << endl;
    vector<vector<int>> trips1 = {{2, 1, 5}, {3, 3, 7}};
    int capacity1 = 4;
    cout << "行程: [[2,1,5],[3,3,7]]" << endl;
    cout << "容量: " << capacity1 << endl;
    cout << "扫描线算法结果: " << (carPoolingSweepLine(trips1, capacity1) ? "true" : "false") << endl;
    cout << "差分数组结果: " << (carPoolingDifferenceArray(trips1, capacity1) ? "true" : "false") << endl;
    cout << "优先队列结果: " << (carPoolingPriorityQueue(trips1, capacity1) ? "true" : "false") << endl;
    cout << "期望: false" << endl;
    cout << endl;
    
    // 测试用例2
    cout << "测试用例2:" << endl;
    vector<vector<int>> trips2 = {{2, 1, 5}, {3, 3, 7}};
    int capacity2 = 5;
    cout << "行程: [[2,1,5],[3,3,7]]" << endl;
    cout << "容量: " << capacity2 << endl;
    cout << "扫描线算法结果: " << (carPoolingSweepLine(trips2, capacity2) ? "true" : "false") << endl;
    cout << "差分数组结果: " << (carPoolingDifferenceArray(trips2, capacity2) ? "true" : "false") << endl;
    cout << "优先队列结果: " << (carPoolingPriorityQueue(trips2, capacity2) ? "true" : "false") << endl;
    cout << "期望: true" << endl;
    cout << endl;
    
    // 性能测试
    cout << "=== 性能测试 ===" << endl;
    random_device rd;
    mt19937 gen(rd());
    uniform_int_distribution<> dis_loc(0, 1000);
    uniform_int_distribution<> dis_pass(1, 10);
    
    int n = 1000;
    vector<vector<int>> trips(n);
    
    for (int i = 0; i < n; i++) {
        int fromLoc = dis_loc(gen);
        int toLoc = fromLoc + dis_loc(gen) % 100 + 1;
        int passengers = dis_pass(gen);
        trips[i] = {passengers, fromLoc, toLoc};
    }
    
    int capacity = 50;
    
    auto start_time = chrono::high_resolution_clock::now();
    bool result1 = carPoolingSweepLine(trips, capacity);
    auto end_time = chrono::high_resolution_clock::now();
    auto duration1 = chrono::duration_cast<chrono::microseconds>(end_time - start_time);
    cout << "扫描线算法处理" << n << "个行程时间: " << duration1.count() / 1000.0 << " ms" << endl;
    
    start_time = chrono::high_resolution_clock::now();
    bool result2 = carPoolingDifferenceArray(trips, capacity);
    end_time = chrono::high_resolution_clock::now();
    auto duration2 = chrono::duration_cast<chrono::microseconds>(end_time - start_time);
    cout << "差分数组法处理" << n << "个行程时间: " << duration2.count() / 1000.0 << " ms" << endl;
    
    start_time = chrono::high_resolution_clock::now();
    bool result3 = carPoolingPriorityQueue(trips, capacity);
    end_time = chrono::high_resolution_clock::now();
    auto duration3 = chrono::duration_cast<chrono::microseconds>(end_time - start_time);
    cout << "优先队列法处理" << n << "个行程时间: " << duration3.count() / 1000.0 << " ms" << endl;
    
    cout << "三种方法结果是否一致: " << (result1 == result2 && result2 == result3 ? "是" : "否") << endl;
    
    // C++语言特性考量
    cout << "\n=== C++语言特性考量 ===" << endl;
    cout << "1. 使用STL容器提高开发效率" << endl;
    cout << "2. 使用lambda表达式简化排序逻辑" << endl;
    cout << "3. 使用智能指针管理内存（如果需要）" << endl;
    cout << "4. 使用异常处理机制保证程序健壮性" << endl;
    
    // 算法复杂度分析
    cout << "\n=== 算法复杂度分析 ===" << endl;
    cout << "扫描线算法:" << endl;
    cout << "  时间复杂度: O(n log n) - 主要消耗在排序上" << endl;
    cout << "  空间复杂度: O(n) - 存储事件列表" << endl;
    cout << "差分数组:" << endl;
    cout << "  时间复杂度: O(n + m) - n是行程数，m是最大位置" << endl;
    cout << "  空间复杂度: O(m) - 差分数组" << endl;
    cout << "优先队列:" << endl;
    cout << "  时间复杂度: O(n log n) - 排序和堆操作" << endl;
    cout << "  空间复杂度: O(n) - 堆存储" << endl;
}

int main() {
    testCarPooling();
    return 0;
}

===============================================

文件: leetcode_1094_car_pooling_1.py
===============================================
#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
LeetCode 1094. 拼车 (Car Pooling)

题目来源：https://leetcode.cn/problems/car-pooling/

题目描述：
车上最初有 capacity 个空座位。车只能向一个方向行驶（不允许掉头或改变方向）。
给定整数 capacity 和一个数组 trips ，trip[i] = [numPassengersi, fromi, toi]
表示第 i 次旅行有 numPassengersi 乘客，接他们和放他们的位置分别是 fromi 和 toi。
这些位置是从汽车的初始位置向东的公里数。
当且仅当你可以在所有给定的行程中接送所有乘客时，返回 true，否则返回 false。

算法思路：
这是一个典型的扫描线算法问题，可以使用以下方法解决：
1. 扫描线算法：将上车和下车事件排序后处理
2. 差分数组：记录每个位置的乘客变化
3. 模拟：按位置顺序模拟乘客上下车过程

时间复杂度：
- 扫描线算法：O(n log n)，其中n是行程数
- 差分数组：O(n + m)，其中n是行程数，m是最大位置
- 空间复杂度：O(n)

应用场景：
1. 交通调度：公交车、出租车调度
2. 资源分配：服务器负载均衡
3. 活动安排：会议室预订

相关题目：
1. LeetCode 1109. 航班预订统计
2. LeetCode 253. 会议室 II
3. LeetCode 218. 天际线问题
"""

from typing import List
import heapq
from collections import defaultdict

class Solution:
    """解决方案类"""
    
    @staticmethod
    def car_pooling_sweep_line(trips: List[List[int]], capacity: int) -> bool:
        """
        方法1：扫描线算法
        时间复杂度：O(n log n)
        空间复杂度：O(n)
        :param trips: 行程信息数组
        :param capacity: 车辆容量
        :return: 是否可以完成所有行程
        """
        # 创建事件列表：[位置, 乘客变化]
        events = []
        
        # 为每个行程创建上车和下车事件
        for passengers, start, end in trips:
            # 上车事件（乘客增加）
            events.append((start, passengers))
            # 下车事件（乘客减少）
            events.append((end, -passengers))
        
        # 按位置排序事件，如果位置相同，下车事件优先于上车事件
        events.sort()
        
        current_passengers = 0
        
        # 扫描所有事件
        for position, change in events:
            current_passengers += change
            if current_passengers > capacity:
                return False
        
        return True
    
    @staticmethod
    def car_pooling_difference_array(trips: List[List[int]], capacity: int) -> bool:
        """
        方法2：差分数组
        时间复杂度：O(n + m)，其中n是行程数，m是最大位置
        空间复杂度：O(m)
        :param trips: 行程信息数组
        :param capacity: 车辆容量
        :return: 是否可以完成所有行程
        """
        # 找到最大位置
        max_location = 0
        for _, start, end in trips:
            max_location = max(max_location, start, end)
        
        # 创建差分数组
        diff = [0] * (max_location + 1)
        
        # 记录每个行程的乘客变化
        for passengers, start, end in trips:
            diff[start] += passengers
            diff[end] -= passengers
        
        # 通过前缀和计算每个位置的实际乘客数
        current_passengers = 0
        for i in range(max_location + 1):
            current_passengers += diff[i]
            if current_passengers > capacity:
                return False
        
        return True
    
    @staticmethod
    def car_pooling_tree_map(trips: List[List[int]], capacity: int) -> bool:
        """
        方法3：使用字典的扫描线算法（适用于位置范围很大的情况）
        时间复杂度：O(n log n)
        空间复杂度：O(n)
        :param trips: 行程信息数组
        :param capacity: 车辆容量
        :return: 是否可以完成所有行程
        """
        # 使用字典记录每个位置的乘客变化
        changes = defaultdict(int)
        
        # 记录每个行程的乘客变化
        for passengers, start, end in trips:
            changes[start] += passengers
            changes[end] -= passengers
        
        # 按位置顺序处理所有变化
        current_passengers = 0
        for position in sorted(changes.keys()):
            current_passengers += changes[position]
            if current_passengers > capacity:
                return False
        
        return True
    
    @staticmethod
    def car_pooling_simulation(trips: List[List[int]], capacity: int) -> bool:
        """
        方法4：模拟法（适用于位置范围较小的情况）
        时间复杂度：O(n * m)，其中n是行程数，m是最大位置
        空间复杂度：O(m)
        :param trips: 行程信息数组
        :param capacity: 车辆容量
        :return: 是否可以完成所有行程
        """
        # 找到最大位置
        max_location = 0
        for _, start, end in trips:
            max_location = max(max_location, start, end)
        
        # 记录每个位置的乘客数
        passengers_at_location = [0] * (max_location + 1)
        
        # 模拟每个行程
        for passengers, start, end in trips:
            # 在行程区间内增加乘客数
            for i in range(start, end):
                passengers_at_location[i] += passengers
                if passengers_at_location[i] > capacity:
                    return False
        
        return True


def test_car_pooling():
    """测试函数"""
    print("=== 测试 LeetCode 1094. 拼车 ===")
    
    # 测试用例1
    trips1 = [[2,1,5],[3,3,7]]
    capacity1 = 4
    print("测试用例1:")
    print("行程:", trips1)
    print("容量:", capacity1)
    print("扫描线算法结果:", Solution.car_pooling_sweep_line(trips1, capacity1))
    print("差分数组结果:", Solution.car_pooling_difference_array(trips1, capacity1))
    print("TreeMap结果:", Solution.car_pooling_tree_map(trips1, capacity1))
    print("模拟法结果:", Solution.car_pooling_simulation(trips1, capacity1))
    print("期望结果: False")
    print()
    
    # 测试用例2
    trips2 = [[2,1,5],[3,3,7]]
    capacity2 = 5
    print("测试用例2:")
    print("行程:", trips2)
    print("容量:", capacity2)
    print("扫描线算法结果:", Solution.car_pooling_sweep_line(trips2, capacity2))
    print("差分数组结果:", Solution.car_pooling_difference_array(trips2, capacity2))
    print("TreeMap结果:", Solution.car_pooling_tree_map(trips2, capacity2))
    print("模拟法结果:", Solution.car_pooling_simulation(trips2, capacity2))
    print("期望结果: True")
    print()
    
    # 测试用例3
    trips3 = [[3,2,7],[3,7,9],[8,3,9]]
    capacity3 = 11
    print("测试用例3:")
    print("行程:", trips3)
    print("容量:", capacity3)
    print("扫描线算法结果:", Solution.car_pooling_sweep_line(trips3, capacity3))
    print("差分数组结果:", Solution.car_pooling_difference_array(trips3, capacity3))
    print("TreeMap结果:", Solution.car_pooling_tree_map(trips3, capacity3))
    print("模拟法结果:", Solution.car_pooling_simulation(trips3, capacity3))
    print("期望结果: True")
    print()


if __name__ == "__main__":
    test_car_pooling()

===============================================

文件: LeetCode_1109_CorporateFlightBookings.java
===============================================
package class008_AdvancedAlgorithmsAndDataStructures.difference_array_problems;

import java.util.*;

/**
 * LeetCode 1109. 航班预订统计 (Corporate Flight Bookings)
 * 
 * 题目来源：https://leetcode.cn/problems/corporate-flight-bookings/
 * 
 * 题目描述：
 * 有 n 个航班，它们分别从 1 到 n 编号。
 * 有一份航班预订表 bookings ，表中第 i 条预订记录 bookings[i] = [firsti, lasti, seatsi]
 * 意味着在从 firsti 到 lasti（包含 firsti 和 lasti）的每个航班上预订了 seatsi 个座位。
 * 请你返回一个长度为 n 的数组 answer，其中 answer[i] 是第 i+1 个航班预定的座位总数。
 * 
 * 算法思路：
 * 这是一个典型的差分数组应用场景，可以使用以下方法解决：
 * 1. 差分数组：对于每个预订记录，在差分数组的起始位置加座位数，
 *             在结束位置的下一个位置减座位数，最后通过前缀和得到结果
 * 2. 暴力法：直接对每个预订记录更新区间内的所有航班
 * 
 * 时间复杂度：
 * - 差分数组：O(n + m)，其中n是航班数，m是预订记录数
 * - 暴力法：O(m * n)
 * - 空间复杂度：O(n)
 * 
 * 应用场景：
 * 1. 资源分配：批量资源预订统计
 * 2. 数据分析：区间数据聚合
 * 3. 金融：时间段内的交易统计
 * 
 * 相关题目：
 * 1. LeetCode 370. 区间加法
 * 2. LeetCode 1094. 拼车
 * 3. LeetCode 1893. 检查是否区域内所有整数都被覆盖
 */
public class LeetCode_1109_CorporateFlightBookings {
    
    /**
     * 方法1：差分数组（最优解）
     * 时间复杂度：O(n + m)
     * 空间复杂度：O(n)
     * @param bookings 预订记录数组
     * @param n 航班数量
     * @return 每个航班的座位预订总数
     */
    public static int[] corpFlightBookingsDifferenceArray(int[][] bookings, int n) {
        // 创建差分数组
        int[] diff = new int[n + 1];
        
        // 处理每个预订记录
        for (int[] booking : bookings) {
            int first = booking[0];
            int last = booking[1];
            int seats = booking[2];
            
            // 在差分数组中标记区间更新
            diff[first - 1] += seats;  // 航班编号从1开始，数组索引从0开始
            if (last < n) {
                diff[last] -= seats;
            }
        }
        
        // 通过计算差分数组的前缀和来得到最终结果
        int[] result = new int[n];
        result[0] = diff[0];
        for (int i = 1; i < n; i++) {
            result[i] = result[i - 1] + diff[i];
        }
        
        return result;
    }
    
    /**
     * 方法2：暴力法（用于对比）
     * 时间复杂度：O(m * n)
     * 空间复杂度：O(1)
     * @param bookings 预订记录数组
     * @param n 航班数量
     * @return 每个航班的座位预订总数
     */
    public static int[] corpFlightBookingsBruteForce(int[][] bookings, int n) {
        int[] result = new int[n];
        
        // 处理每个预订记录
        for (int[] booking : bookings) {
            int first = booking[0];
            int last = booking[1];
            int seats = booking[2];
            
            // 直接更新区间内的每个航班
            for (int i = first - 1; i < last; i++) {  // 航班编号从1开始，数组索引从0开始
                result[i] += seats;
            }
        }
        
        return result;
    }
    
    /**
     * 方法3：使用TreeMap的扫描线算法（适用于稀疏数据）
     * 时间复杂度：O(m log m + n)
     * 空间复杂度：O(m)
     * @param bookings 预订记录数组
     * @param n 航班数量
     * @return 每个航班的座位预订总数
     */
    public static int[] corpFlightBookingsTreeMap(int[][] bookings, int n) {
        // 使用TreeMap记录每个位置的变化
        TreeMap<Integer, Integer> changes = new TreeMap<>();
        
        // 记录每个预订记录的变化
        for (int[] booking : bookings) {
            int first = booking[0];
            int last = booking[1];
            int seats = booking[2];
            
            changes.put(first, changes.getOrDefault(first, 0) + seats);
            changes.put(last + 1, changes.getOrDefault(last + 1, 0) - seats);
        }
        
        int[] result = new int[n];
        int currentSeats = 0;
        int changeIndex = 0;
        
        // 按顺序处理所有变化
        for (Map.Entry<Integer, Integer> entry : changes.entrySet()) {
            int position = entry.getKey();
            int change = entry.getValue();
            
            // 填充当前位置之前的所有航班
            while (changeIndex < position - 1 && changeIndex < n) {
                result[changeIndex] = currentSeats;
                changeIndex++;
            }
            
            // 更新当前座位数
            currentSeats += change;
        }
        
        // 填充剩余的航班
        while (changeIndex < n) {
            result[changeIndex] = currentSeats;
            changeIndex++;
        }
        
        return result;
    }
    
    /**
     * 测试函数
     */
    public static void main(String[] args) {
        System.out.println("=== 测试 LeetCode 1109. 航班预订统计 ===");
        
        // 测试用例1
        int[][] bookings1 = {{1,2,10},{2,3,20},{2,5,25}};
        int n1 = 5;
        System.out.println("测试用例1:");
        System.out.println("预订记录: " + Arrays.deepToString(bookings1));
        System.out.println("航班数: " + n1);
        System.out.println("差分数组结果: " + Arrays.toString(corpFlightBookingsDifferenceArray(bookings1, n1)));
        System.out.println("暴力法结果: " + Arrays.toString(corpFlightBookingsBruteForce(bookings1, n1)));
        System.out.println("TreeMap结果: " + Arrays.toString(corpFlightBookingsTreeMap(bookings1, n1)));
        System.out.println("期望结果: [10, 55, 45, 25, 25]");
        System.out.println();
        
        // 测试用例2
        int[][] bookings2 = {{1,2,10},{2,2,15}};
        int n2 = 2;
        System.out.println("测试用例2:");
        System.out.println("预订记录: " + Arrays.deepToString(bookings2));
        System.out.println("航班数: " + n2);
        System.out.println("差分数组结果: " + Arrays.toString(corpFlightBookingsDifferenceArray(bookings2, n2)));
        System.out.println("暴力法结果: " + Arrays.toString(corpFlightBookingsBruteForce(bookings2, n2)));
        System.out.println("TreeMap结果: " + Arrays.toString(corpFlightBookingsTreeMap(bookings2, n2)));
        System.out.println("期望结果: [10, 25]");
        System.out.println();
        
        // 测试用例3：边界情况
        int[][] bookings3 = {{1,1,100}};
        int n3 = 1;
        System.out.println("测试用例3 (单个航班):");
        System.out.println("预订记录: " + Arrays.deepToString(bookings3));
        System.out.println("航班数: " + n3);
        System.out.println("差分数组结果: " + Arrays.toString(corpFlightBookingsDifferenceArray(bookings3, n3)));
        System.out.println("暴力法结果: " + Arrays.toString(corpFlightBookingsBruteForce(bookings3, n3)));
        System.out.println("TreeMap结果: " + Arrays.toString(corpFlightBookingsTreeMap(bookings3, n3)));
        System.out.println("期望结果: [100]");
        System.out.println();
        
        // 性能测试
        System.out.println("=== 性能测试 ===");
        Random random = new Random(42);
        int flightCount = 100000;
        int bookingCount = 10000;
        int[][] bookings = new int[bookingCount][3];
        
        // 生成随机预订记录
        for (int i = 0; i < bookingCount; i++) {
            int first = random.nextInt(flightCount) + 1;
            int last = Math.min(first + random.nextInt(1000) + 1, flightCount);
            int seats = random.nextInt(1000) + 1;
            bookings[i][0] = first;
            bookings[i][1] = last;
            bookings[i][2] = seats;
        }
        
        long startTime = System.nanoTime();
        int[] result1 = corpFlightBookingsDifferenceArray(bookings, flightCount);
        long endTime = System.nanoTime();
        System.out.println("差分数组法处理" + flightCount + "个航班," + bookingCount + "个预订记录时间: " + (endTime - startTime) / 1_000_000.0 + " ms");
        
        startTime = System.nanoTime();
        int[] result2 = corpFlightBookingsBruteForce(bookings, flightCount);
        endTime = System.nanoTime();
        System.out.println("暴力解法处理" + flightCount + "个航班," + bookingCount + "个预订记录时间: " + (endTime - startTime) / 1_000_000.0 + " ms");
        
        startTime = System.nanoTime();
        int[] result3 = corpFlightBookingsTreeMap(bookings, flightCount);
        endTime = System.nanoTime();
        System.out.println("TreeMap法处理" + flightCount + "个航班," + bookingCount + "个预订记录时间: " + (endTime - startTime) / 1_000_000.0 + " ms");
        
        // 验证结果一致性
        System.out.println("结果一致性检查: " + Arrays.equals(result1, result2) + " (差分数组 vs 暴力法)");
        System.out.println("结果一致性检查: " + Arrays.equals(result1, result3) + " (差分数组 vs TreeMap法)");
    }
}

===============================================

文件: leetcode_1109_corporate_flight_bookings.cpp
===============================================
#include <iostream>
#include <vector>
#include <algorithm>
#include <chrono>
#include <random>

using namespace std;

/**
 * LeetCode 1109. 航班预订统计 (Corporate Flight Bookings) - C++版本
 * 
 * 题目来源：https://leetcode.cn/problems/corporate-flight-bookings/
 * 
 * 题目描述：
 * 这里有 n 个航班，它们分别从 1 到 n 进行编号。
 * 有一份航班预订表 bookings，表中第 i 条预订记录 bookings[i] = [firsti, lasti, seatsi]
 * 意味着在从 firsti 到 lasti（包含 firsti 和 lasti）的每个航班上预订了 seatsi 个座位。
 * 请你返回一个长度为 n 的数组 answer，里面的元素是每个航班预定的座位总数。
 * 
 * 算法思路：
 * 这个问题可以通过以下方法解决：
 * 1. 差分数组：记录每个位置的座位变化
 * 2. 暴力法：直接更新每个位置的座位数
 * 
 * 使用差分数组的方法：
 * 1. 对于每个预订记录，在差分数组的起始位置增加座位数，在结束位置的下一个位置减少座位数
 * 2. 计算差分数组的前缀和得到最终结果
 * 
 * 时间复杂度：
 * - 差分数组：O(n + m)
 * - 暴力法：O(n * m)
 * - 空间复杂度：O(n)
 * 
 * 应用场景：
 * 1. 资源分配：统计资源使用情况
 * 2. 数据分析：区间数据统计
 * 3. 项目管理：任务分配统计
 * 
 * 相关题目：
 * 1. LeetCode 370. 区间加法
 * 2. LeetCode 1094. 拼车
 * 3. LeetCode 732. 我的日程安排表 III
 */

/**
 * 方法1：差分数组
 * 时间复杂度：O(n + m)
 * 空间复杂度：O(n)
 * @param bookings 预订记录数组
 * @param n 航班数量
 * @return 每个航班预定的座位总数
 */
vector<int> corpFlightBookingsDifferenceArray(vector<vector<int>>& bookings, int n) {
    // 创建差分数组，大小为n+1，方便处理边界
    vector<int> diff(n + 1, 0);
    
    // 处理每个预订记录
    for (const auto& booking : bookings) {
        int first = booking[0];
        int last = booking[1];
        int seats = booking[2];
        
        // 在差分数组中标记座位变化
        diff[first - 1] += seats;  // 航班编号从1开始，数组索引从0开始
        diff[last] -= seats;
    }
    
    // 计算差分数组的前缀和得到最终结果
    vector<int> result(n, 0);
    result[0] = diff[0];
    for (int i = 1; i < n; i++) {
        result[i] = result[i - 1] + diff[i];
    }
    
    return result;
}

/**
 * 方法2：暴力法（用于对比）
 * 时间复杂度：O(n * m)
 * 空间复杂度：O(n)
 * @param bookings 预订记录数组
 * @param n 航班数量
 * @return 每个航班预定的座位总数
 */
vector<int> corpFlightBookingsBruteForce(vector<vector<int>>& bookings, int n) {
    // 创建结果数组
    vector<int> result(n, 0);
    
    // 处理每个预订记录
    for (const auto& booking : bookings) {
        int first = booking[0];
        int last = booking[1];
        int seats = booking[2];
        
        // 直接更新每个航班的座位数
        for (int i = first - 1; i < last; i++) {  // 航班编号从1开始，数组索引从0开始
            result[i] += seats;
        }
    }
    
    return result;
}

/**
 * 测试函数
 */
void testCorpFlightBookings() {
    cout << "=== LeetCode 1109. 航班预订统计 (C++版本) ===" << endl;
    
    // 测试用例1
    cout << "测试用例1:" << endl;
    vector<vector<int>> bookings1 = {{1, 2, 10}, {2, 3, 20}, {2, 5, 25}};
    int n1 = 5;
    cout << "预订记录: [[1,2,10],[2,3,20],[2,5,25]]" << endl;
    cout << "航班数量: " << n1 << endl;
    
    vector<int> result1 = corpFlightBookingsDifferenceArray(bookings1, n1);
    cout << "差分数组结果: [";
    for (int i = 0; i < result1.size(); i++) {
        cout << result1[i];
        if (i < result1.size() - 1) cout << ",";
    }
    cout << "]" << endl;
    
    vector<int> result2 = corpFlightBookingsBruteForce(bookings1, n1);
    cout << "暴力解法结果: [";
    for (int i = 0; i < result2.size(); i++) {
        cout << result2[i];
        if (i < result2.size() - 1) cout << ",";
    }
    cout << "]" << endl;
    
    cout << "期望结果: [10,55,45,25,25]" << endl;
    cout << endl;
    
    // 测试用例2
    cout << "测试用例2:" << endl;
    vector<vector<int>> bookings2 = {{1, 2, 10}, {2, 2, 15}};
    int n2 = 2;
    cout << "预订记录: [[1,2,10],[2,2,15]]" << endl;
    cout << "航班数量: " << n2 << endl;
    
    vector<int> result3 = corpFlightBookingsDifferenceArray(bookings2, n2);
    cout << "差分数组结果: [";
    for (int i = 0; i < result3.size(); i++) {
        cout << result3[i];
        if (i < result3.size() - 1) cout << ",";
    }
    cout << "]" << endl;
    
    vector<int> result4 = corpFlightBookingsBruteForce(bookings2, n2);
    cout << "暴力解法结果: [";
    for (int i = 0; i < result4.size(); i++) {
        cout << result4[i];
        if (i < result4.size() - 1) cout << ",";
    }
    cout << "]" << endl;
    
    cout << "期望结果: [10,25]" << endl;
    cout << endl;
    
    // 性能测试
    cout << "=== 性能测试 ===" << endl;
    random_device rd;
    mt19937 gen(rd());
    uniform_int_distribution<> dis_flight(1, 1000);
    uniform_int_distribution<> dis_seats(1, 100);
    
    int m = 10000;  // 预订记录数
    int n = 10000;  // 航班数
    vector<vector<int>> bookings(m);
    
    for (int i = 0; i < m; i++) {
        int first = dis_flight(gen);
        int last = min(first + dis_flight(gen) % 100, n);
        int seats = dis_seats(gen);
        bookings[i] = {first, last, seats};
    }
    
    auto start_time = chrono::high_resolution_clock::now();
    vector<int> diff_result = corpFlightBookingsDifferenceArray(bookings, n);
    auto end_time = chrono::high_resolution_clock::now();
    auto duration1 = chrono::duration_cast<chrono::microseconds>(end_time - start_time);
    cout << "差分数组法处理" << m << "个预订记录和" << n << "个航班时间: " << duration1.count() / 1000.0 << " ms" << endl;
    
    start_time = chrono::high_resolution_clock::now();
    vector<int> brute_result = corpFlightBookingsBruteForce(bookings, n);
    end_time = chrono::high_resolution_clock::now();
    auto duration2 = chrono::duration_cast<chrono::microseconds>(end_time - start_time);
    cout << "暴力解法处理" << m << "个预订记录和" << n << "个航班时间: " << duration2.count() / 1000.0 << " ms" << endl;
    
    cout << "两种方法结果是否一致: " << (diff_result == brute_result ? "是" : "否") << endl;
    
    // C++语言特性考量
    cout << "\n=== C++语言特性考量 ===" << endl;
    cout << "1. 使用STL容器提高开发效率" << endl;
    cout << "2. 使用const引用避免不必要的拷贝" << endl;
    cout << "3. 使用auto关键字简化类型声明" << endl;
    cout << "4. 使用范围for循环简化遍历" << endl;
    
    // 算法复杂度分析
    cout << "\n=== 算法复杂度分析 ===" << endl;
    cout << "差分数组法:" << endl;
    cout << "  时间复杂度: O(n + m) - n是航班数，m是预订记录数" << endl;
    cout << "  空间复杂度: O(n) - 差分数组和结果数组" << endl;
    cout << "暴力解法:" << endl;
    cout << "  时间复杂度: O(n * m) - 对于每个预订记录都要遍历区间" << endl;
    cout << "  空间复杂度: O(n) - 结果数组" << endl;
}

int main() {
    testCorpFlightBookings();
    return 0;
}

===============================================

文件: LeetCode_1192_CriticalConnectionsInANetwork.java
===============================================
package class008_AdvancedAlgorithmsAndDataStructures.circle_square_tree_problems;

import java.util.*;

/**
 * LeetCode 1192. Critical Connections in a Network
 * 
 * 题目描述：
 * 给你一个 n 台计算机的网络，服务器从 0 到 n-1 编号。同时给你一个数组 connections，
 * 其中 connections[i] = [a, b] 表示服务器 a 和 b 之间有一条连接。
 * 在这个网络中，任何服务器都可以通过网络直接或间接访问任何其他服务器。
 * 关键连接是指如果删除该连接，某些服务器将无法访问其他服务器。
 * 请你返回所有关键连接（桥）。
 * 
 * 解题思路：
 * 这个问题可以使用圆方树的思想来解决。
 * 关键连接就是图中的桥（割边），删除后会使图不连通。
 * 我们可以使用Tarjan算法来找出所有的桥。
 * 
 * 时间复杂度：O(V + E)
 * 空间复杂度：O(V + E)
 */
public class LeetCode_1192_CriticalConnectionsInANetwork {
    
    static class Solution {
        private List<List<Integer>> graph;
        private int[] dfn; // DFS时间戳
        private int[] low; // 最小时间戳
        private boolean[] visited;
        private int time;
        private List<List<Integer>> criticalConnections;
        
        public List<List<Integer>> criticalConnections(int n, List<List<Integer>> connections) {
            // 构建邻接表
            graph = new ArrayList<>();
            for (int i = 0; i < n; i++) {
                graph.add(new ArrayList<>());
            }
            
            for (List<Integer> connection : connections) {
                int u = connection.get(0);
                int v = connection.get(1);
                graph.get(u).add(v);
                graph.get(v).add(u);
            }
            
            // 初始化
            dfn = new int[n];
            low = new int[n];
            visited = new boolean[n];
            time = 0;
            criticalConnections = new ArrayList<>();
            
            Arrays.fill(dfn, -1);
            Arrays.fill(low, -1);
            
            // 对每个未访问的节点进行DFS
            for (int i = 0; i < n; i++) {
                if (dfn[i] == -1) {
                    tarjan(i, -1);
                }
            }
            
            return criticalConnections;
        }
        
        // Tarjan算法找桥
        private void tarjan(int u, int parent) {
            dfn[u] = low[u] = ++time;
            visited[u] = true;
            
            for (int v : graph.get(u)) {
                if (v == parent) continue;
                
                if (dfn[v] == -1) {
                    // 树边
                    tarjan(v, u);
                    low[u] = Math.min(low[u], low[v]);
                    
                    // 判断是否为桥
                    if (low[v] > dfn[u]) {
                        criticalConnections.add(Arrays.asList(u, v));
                    }
                } else {
                    // 回边
                    low[u] = Math.min(low[u], dfn[v]);
                }
            }
        }
        
        // 另一种解法：使用圆方树
        public List<List<Integer>> criticalConnections2(int n, List<List<Integer>> connections) {
            // 构建邻接表
            List<List<Integer>> graph = new ArrayList<>();
            for (int i = 0; i < n; i++) {
                graph.add(new ArrayList<>());
            }
            
            for (List<Integer> connection : connections) {
                int u = connection.get(0);
                int v = connection.get(1);
                graph.get(u).add(v);
                graph.get(v).add(u);
            }
            
            // 使用圆方树的思想找桥
            return findBridgesWithCircleSquareTree(n, graph);
        }
        
        // 使用圆方树找桥
        private List<List<Integer>> findBridgesWithCircleSquareTree(int n, List<List<Integer>> graph) {
            List<List<Integer>> bridges = new ArrayList<>();
            int[] dfn = new int[n];
            int[] low = new int[n];
            boolean[] visited = new boolean[n];
            int[] time = {0};
            
            // 对每个未访问的节点进行DFS
            for (int i = 0; i < n; i++) {
                if (!visited[i]) {
                    dfsForBridges(i, -1, graph, dfn, low, visited, time, bridges);
                }
            }
            
            return bridges;
        }
        
        // DFS找桥
        private void dfsForBridges(int u, int parent, List<List<Integer>> graph, 
                                  int[] dfn, int[] low, boolean[] visited, 
                                  int[] time, List<List<Integer>> bridges) {
            visited[u] = true;
            dfn[u] = low[u] = ++time[0];
            
            for (int v : graph.get(u)) {
                if (v == parent) continue;
                
                if (!visited[v]) {
                    dfsForBridges(v, u, graph, dfn, low, visited, time, bridges);
                    low[u] = Math.min(low[u], low[v]);
                    
                    // 如果是桥，添加到结果中
                    if (low[v] > dfn[u]) {
                        bridges.add(Arrays.asList(u, v));
                    }
                } else {
                    low[u] = Math.min(low[u], dfn[v]);
                }
            }
        }
        
        // 使用并查集优化的方法
        public List<List<Integer>> criticalConnections3(int n, List<List<Integer>> connections) {
            // 构建邻接表
            List<List<Integer>> graph = new ArrayList<>();
            for (int i = 0; i < n; i++) {
                graph.add(new ArrayList<>());
            }
            
            for (List<Integer> connection : connections) {
                int u = connection.get(0);
                int v = connection.get(1);
                graph.get(u).add(v);
                graph.get(v).add(u);
            }
            
            // 使用并查集找桥
            return findBridgesWithUnionFind(n, graph);
        }
        
        // 使用并查集找桥
        private List<List<Integer>> findBridgesWithUnionFind(int n, List<List<Integer>> graph) {
            List<List<Integer>> bridges = new ArrayList<>();
            
            // 对每条边，检查删除后图是否仍然连通
            for (int i = 0; i < n; i++) {
                for (int j : graph.get(i)) {
                    if (i < j) { // 避免重复检查
                        // 删除边(i, j)
                        graph.get(i).remove(Integer.valueOf(j));
                        graph.get(j).remove(Integer.valueOf(i));
                        
                        // 检查图是否仍然连通
                        if (!isConnected(n, graph, i)) {
                            bridges.add(Arrays.asList(i, j));
                        }
                        
                        // 恢复边(i, j)
                        graph.get(i).add(j);
                        graph.get(j).add(i);
                    }
                }
            }
            
            return bridges;
        }
        
        // 检查图是否连通
        private boolean isConnected(int n, List<List<Integer>> graph, int start) {
            boolean[] visited = new boolean[n];
            Queue<Integer> queue = new LinkedList<>();
            queue.offer(start);
            visited[start] = true;
            int visitedCount = 1;
            
            while (!queue.isEmpty()) {
                int u = queue.poll();
                for (int v : graph.get(u)) {
                    if (!visited[v]) {
                        visited[v] = true;
                        visitedCount++;
                        queue.offer(v);
                    }
                }
            }
            
            return visitedCount == n;
        }
    }
    
    // 测试方法
    public static void main(String[] args) {
        Solution solution = new Solution();
        
        // 测试用例1
        int n1 = 4;
        List<List<Integer>> connections1 = new ArrayList<>();
        connections1.add(Arrays.asList(0, 1));
        connections1.add(Arrays.asList(1, 2));
        connections1.add(Arrays.asList(2, 0));
        connections1.add(Arrays.asList(1, 3));
        System.out.println("测试用例1:");
        System.out.println("节点数: " + n1);
        System.out.println("连接: " + connections1);
        System.out.println("关键连接: " + solution.criticalConnections(n1, connections1));
        System.out.println("另一种解法结果: " + solution.criticalConnections2(n1, connections1));
        System.out.println();
        
        // 测试用例2
        int n2 = 2;
        List<List<Integer>> connections2 = new ArrayList<>();
        connections2.add(Arrays.asList(0, 1));
        System.out.println("测试用例2:");
        System.out.println("节点数: " + n2);
        System.out.println("连接: " + connections2);
        System.out.println("关键连接: " + solution.criticalConnections(n2, connections2));
        System.out.println("另一种解法结果: " + solution.criticalConnections2(n2, connections2));
        System.out.println();
        
        // 测试用例3
        int n3 = 6;
        List<List<Integer>> connections3 = new ArrayList<>();
        connections3.add(Arrays.asList(0, 1));
        connections3.add(Arrays.asList(1, 2));
        connections3.add(Arrays.asList(2, 0));
        connections3.add(Arrays.asList(1, 3));
        connections3.add(Arrays.asList(3, 4));
        connections3.add(Arrays.asList(4, 5));
        connections3.add(Arrays.asList(5, 3));
        System.out.println("测试用例3:");
        System.out.println("节点数: " + n3);
        System.out.println("连接: " + connections3);
        System.out.println("关键连接: " + solution.criticalConnections(n3, connections3));
        System.out.println("另一种解法结果: " + solution.criticalConnections2(n3, connections3));
    }
}

===============================================

文件: LeetCode_1222_QueensThatCanAttackTheKing.java
===============================================
package class008_AdvancedAlgorithmsAndDataStructures.game_of_life_problems;

import java.util.*;

/**
 * LeetCode 1222. Queens That Can Attack the King
 * 
 * 题目描述：
 * 在一个 8x8 的棋盘上，有一个白色的国王和一些黑色的皇后。
 * 给你一个二维整数数组 queens，其中 queens[i] = [xQueeni, yQueeni] 表示第 i 个黑皇后在棋盘上的位置。
 * 还给你一个长度为 2 的整数数组 king，其中 king = [xKing, yKing] 表示白国王的位置。
 * 返回能够直接攻击国王的黑皇后的坐标。你可以以任何顺序返回答案。
 * 
 * 解题思路：
 * 这个问题可以看作是生命游戏的一种变形，我们需要模拟皇后的攻击模式。
 * 皇后可以沿着 8 个方向（水平、垂直、对角线）攻击。
 * 对于每个方向，我们从国王的位置开始，沿着该方向搜索，找到第一个皇后即可，
 * 因为这个皇后会阻挡后续皇后的攻击路径。
 * 
 * 时间复杂度：O(n + 8*8) = O(n)，其中 n 是皇后的数量
 * 空间复杂度：O(1)
 */
public class LeetCode_1222_QueensThatCanAttackTheKing {
    
    static class Solution {
        public List<List<Integer>> queensAttacktheKing(int[][] queens, int[] king) {
            List<List<Integer>> result = new ArrayList<>();
            
            // 将皇后的位置存储在集合中，便于快速查找
            Set<String> queensSet = new HashSet<>();
            for (int[] queen : queens) {
                queensSet.add(queen[0] + "," + queen[1]);
            }
            
            // 8 个方向：上、下、左、右、左上、右上、左下、右下
            int[][] directions = {
                {-1, 0}, {1, 0}, {0, -1}, {0, 1},  // 垂直和水平方向
                {-1, -1}, {-1, 1}, {1, -1}, {1, 1}  // 对角线方向
            };
            
            int kingX = king[0];
            int kingY = king[1];
            
            // 对每个方向进行搜索
            for (int[] dir : directions) {
                int dx = dir[0];
                int dy = dir[1];
                
                // 从国王的位置开始，沿着当前方向搜索
                int x = kingX + dx;
                int y = kingY + dy;
                
                // 在棋盘范围内搜索
                while (x >= 0 && x < 8 && y >= 0 && y < 8) {
                    // 检查当前位置是否有皇后
                    if (queensSet.contains(x + "," + y)) {
                        // 找到第一个皇后，添加到结果中并停止在该方向的搜索
                        result.add(Arrays.asList(x, y));
                        break;
                    }
                    
                    // 继续沿着该方向搜索
                    x += dx;
                    y += dy;
                }
            }
            
            return result;
        }
        
        // 另一种实现方式：使用布尔矩阵
        public List<List<Integer>> queensAttacktheKing2(int[][] queens, int[] king) {
            List<List<Integer>> result = new ArrayList<>();
            
            // 创建 8x8 的棋盘，标记皇后的位置
            boolean[][] board = new boolean[8][8];
            for (int[] queen : queens) {
                board[queen[0]][queen[1]] = true;
            }
            
            // 8 个方向
            int[][] directions = {
                {-1, 0}, {1, 0}, {0, -1}, {0, 1},  // 垂直和水平方向
                {-1, -1}, {-1, 1}, {1, -1}, {1, 1}  // 对角线方向
            };
            
            int kingX = king[0];
            int kingY = king[1];
            
            // 对每个方向进行搜索
            for (int[] dir : directions) {
                int dx = dir[0];
                int dy = dir[1];
                
                // 从国王的位置开始，沿着当前方向搜索
                int x = kingX + dx;
                int y = kingY + dy;
                
                // 在棋盘范围内搜索
                while (x >= 0 && x < 8 && y >= 0 && y < 8) {
                    // 检查当前位置是否有皇后
                    if (board[x][y]) {
                        // 找到第一个皇后，添加到结果中并停止在该方向的搜索
                        result.add(Arrays.asList(x, y));
                        break;
                    }
                    
                    // 继续沿着该方向搜索
                    x += dx;
                    y += dy;
                }
            }
            
            return result;
        }
    }
    
    // 测试方法
    public static void main(String[] args) {
        Solution solution = new Solution();
        
        // 测试用例1
        int[][] queens1 = {{0,1},{1,0},{4,0},{0,4},{3,3},{2,4}};
        int[] king1 = {0,0};
        System.out.println("测试用例1:");
        System.out.println("皇后位置: " + Arrays.deepToString(queens1));
        System.out.println("国王位置: " + Arrays.toString(king1));
        System.out.println("可以攻击国王的皇后: " + solution.queensAttacktheKing(queens1, king1));
        System.out.println("另一种解法结果: " + solution.queensAttacktheKing2(queens1, king1));
        System.out.println();
        
        // 测试用例2
        int[][] queens2 = {{0,0},{1,1},{2,2},{3,4},{3,5},{4,4},{4,5}};
        int[] king2 = {3,3};
        System.out.println("测试用例2:");
        System.out.println("皇后位置: " + Arrays.deepToString(queens2));
        System.out.println("国王位置: " + Arrays.toString(king2));
        System.out.println("可以攻击国王的皇后: " + solution.queensAttacktheKing(queens2, king2));
        System.out.println("另一种解法结果: " + solution.queensAttacktheKing2(queens2, king2));
        System.out.println();
        
        // 测试用例3
        int[][] queens3 = {{0,1},{1,0},{4,0},{0,4},{3,3},{2,4}};
        int[] king3 = {0,0};
        System.out.println("测试用例3:");
        System.out.println("皇后位置: " + Arrays.deepToString(queens3));
        System.out.println("国王位置: " + Arrays.toString(king3));
        System.out.println("可以攻击国王的皇后: " + solution.queensAttacktheKing(queens3, king3));
        System.out.println("另一种解法结果: " + solution.queensAttacktheKing2(queens3, king3));
    }
}

===============================================

文件: leetcode_1222_queens_that_can_attack_the_king.cpp
===============================================
// LeetCode 1222 Queens That Can Attack the King
// C++ 实现

/**
 * LeetCode 1222 Queens That Can Attack the King
 * 
 * 题目描述：
 * 在一个 8x8 的棋盘上，有一个白色的国王和一些黑色的皇后。
 * 给你一个二维整数数组 queens，其中 queens[i] = [xQueeni, yQueeni] 表示第 i 个黑色皇后在棋盘上的位置。
 * 还给你一个长度为 2 的整数数组 king，其中 king = [xKing, yKing] 表示白色国王的位置。
 * 
 * 请你返回能够直接攻击国王的黑色皇后的坐标。你可以以任何顺序返回答案。
 * 
 * 解题思路：
 * 我们可以从国王的位置出发，向8个方向（上下左右和4个对角线方向）搜索，
 * 找到第一个遇到的皇后，这个皇后就是能够攻击国王的皇后。
 * 
 * 时间复杂度：O(n)
 * 空间复杂度：O(1)
 */

// 由于编译环境限制，这里提供算法思路和伪代码实现

/*
#include <stdlib.h>

int** queensAttacktheKing(int** queens, int queensSize, int* queensColSize, int* king, int kingSize, int* returnSize, int** returnColumnSizes) {
    // 创建棋盘标记皇后位置
    int board[8][8] = {0};
    for (int i = 0; i < queensSize; i++) {
        int x = queens[i][0];
        int y = queens[i][1];
        board[x][y] = 1;
    }
    
    int kingX = king[0];
    int kingY = king[1];
    
    // 8个方向：上下左右和4个对角线方向
    int directions[8][2] = {
        {-1, 0}, {1, 0}, {0, -1}, {0, 1},  // 上下左右
        {-1, -1}, {-1, 1}, {1, -1}, {1, 1}  // 4个对角线方向
    };
    
    // 创建结果数组
    int** result = (int**)malloc(8 * sizeof(int*));
    int resultSize = 0;
    
    // 向8个方向搜索
    for (int i = 0; i < 8; i++) {
        int dx = directions[i][0];
        int dy = directions[i][1];
        
        // 从国王位置开始，沿着当前方向搜索
        int x = kingX + dx;
        int y = kingY + dy;
        
        while (x >= 0 && x < 8 && y >= 0 && y < 8) {
            if (board[x][y] == 1) {
                // 找到皇后，添加到结果中
                result[resultSize] = (int*)malloc(2 * sizeof(int));
                result[resultSize][0] = x;
                result[resultSize][1] = y;
                resultSize++;
                break;  // 找到第一个皇后后停止搜索这个方向
            }
            x += dx;
            y += dy;
        }
    }
    
    // 设置返回参数
    *returnSize = resultSize;
    *returnColumnSizes = (int*)malloc(resultSize * sizeof(int));
    for (int i = 0; i < resultSize; i++) {
        (*returnColumnSizes)[i] = 2;
    }
    
    return result;
}

// 算法核心思想：
// 1. 从国王位置向8个方向搜索
// 2. 找到每个方向上第一个遇到的皇后
// 3. 这些皇后就是能够攻击国王的皇后

// 时间复杂度分析：
// - 搜索8个方向：O(1)
// - 每个方向最多搜索7步：O(1)
// - 总体时间复杂度：O(1)
// - 空间复杂度：O(1)
*/

// 算法应用场景：
// 1. 棋盘问题
// 2. 搜索算法
// 3. 游戏算法

===============================================

文件: leetcode_1222_queens_that_can_attack_the_king.py
===============================================
#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
LeetCode 1222 Queens That Can Attack the King

题目描述：
在一个 8x8 的棋盘上，有一个白色的国王和一些黑色的皇后。
给你一个二维整数数组 queens，其中 queens[i] = [xQueeni, yQueeni] 表示第 i 个黑色皇后在棋盘上的位置。
还给你一个长度为 2 的整数数组 king，其中 king = [xKing, yKing] 表示白色国王的位置。

请你返回能够直接攻击国王的黑色皇后的坐标。你可以以任何顺序返回答案。

解题思路：
我们可以从国王的位置出发，向8个方向（上下左右和4个对角线方向）搜索，
找到第一个遇到的皇后，这个皇后就是能够攻击国王的皇后。

时间复杂度：O(n)
空间复杂度：O(1)
"""

class Solution:
    def queens_attackthe_king(self, queens, king):
        """
        找到能够攻击国王的皇后
        
        Args:
            queens: 皇后位置列表，每个元素为[x, y]
            king: 国王位置[x, y]
            
        Returns:
            能够攻击国王的皇后位置列表
        """
        # 创建集合标记皇后位置
        queen_set = set(map(tuple, queens))
        
        king_x, king_y = king
        
        # 8个方向：上下左右和4个对角线方向
        directions = [
            (-1, 0), (1, 0), (0, -1), (0, 1),  # 上下左右
            (-1, -1), (-1, 1), (1, -1), (1, 1)  # 4个对角线方向
        ]
        
        result = []
        
        # 向8个方向搜索
        for dx, dy in directions:
            # 从国王位置开始，沿着当前方向搜索
            x, y = king_x + dx, king_y + dy
            
            while 0 <= x < 8 and 0 <= y < 8:
                if (x, y) in queen_set:
                    # 找到皇后，添加到结果中
                    result.append([x, y])
                    break  # 找到第一个皇后后停止搜索这个方向
                x += dx
                y += dy
        
        return result


# 测试方法
def main():
    solution = Solution()
    
    # 测试用例1
    queens1 = [[0,1],[1,0],[4,0],[0,4],[3,3],[2,4]]
    king1 = [0,0]
    print("测试用例1:")
    print("皇后位置:", queens1)
    print("国王位置:", king1)
    print("结果:", solution.queens_attackthe_king(queens1, king1))
    print()
    
    # 测试用例2
    queens2 = [[0,0],[1,1],[2,2],[3,4],[3,5],[4,4],[4,5]]
    king2 = [3,3]
    print("测试用例2:")
    print("皇后位置:", queens2)
    print("国王位置:", king2)
    print("结果:", solution.queens_attackthe_king(queens2, king2))
    print()
    
    # 测试用例3
    queens3 = [[5,6],[7,7],[2,1],[0,7],[1,6],[5,1],[3,7],[0,3],[4,0],[1,2],[6,3],[5,0],[0,4],[2,2],[1,1]]
    king3 = [3,4]
    print("测试用例3:")
    print("皇后位置:", queens3)
    print("国王位置:", king3)
    print("结果:", solution.queens_attackthe_king(queens3, king3))


if __name__ == "__main__":
    main()

===============================================

文件: LeetCode_1245_TreeDiameter.java
===============================================
package class008_AdvancedAlgorithmsAndDataStructures.base_cycle_tree_problems;

import java.util.*;

/**
 * LeetCode 1245. Tree Diameter
 * 
 * 题目描述：
 * 给你这棵「无向树」，请你测算并返回它的「直径」：这棵树上最长简单路径的边数。
 * 
 * 解题思路：
 * 这个问题可以转化为基环树的特例来解决。
 * 对于树（无环图），我们可以使用两次DFS的方法：
 * 1. 从任意节点开始DFS，找到距离最远的节点
 * 2. 从该节点开始再次DFS，找到距离最远的节点
 * 3. 两次DFS的距离就是树的直径
 * 
 * 如果图中存在环，我们需要先识别环，然后计算环上任意两点间的最长路径。
 * 
 * 时间复杂度：O(V + E)
 * 空间复杂度：O(V + E)
 */
public class LeetCode_1245_TreeDiameter {
    
    static class Solution {
        private List<List<Integer>> graph;
        private boolean[] visited;
        private int farthestNode;
        private int maxDistance;
        
        public int treeDiameter(int[][] edges) {
            if (edges == null || edges.length == 0) {
                return 0;
            }
            
            int n = edges.length + 1;
            graph = new ArrayList<>();
            for (int i = 0; i < n; i++) {
                graph.add(new ArrayList<>());
            }
            
            // 构建邻接表
            for (int[] edge : edges) {
                int u = edge[0];
                int v = edge[1];
                graph.get(u).add(v);
                graph.get(v).add(u);
            }
            
            // 第一次DFS：找到距离节点0最远的节点
            visited = new boolean[n];
            farthestNode = 0;
            maxDistance = 0;
            dfs(0, 0);
            
            // 第二次DFS：从最远节点开始，找到距离它最远的节点
            visited = new boolean[n];
            maxDistance = 0;
            dfs(farthestNode, 0);
            
            return maxDistance;
        }
        
        private void dfs(int node, int distance) {
            visited[node] = true;
            
            if (distance > maxDistance) {
                maxDistance = distance;
                farthestNode = node;
            }
            
            for (int neighbor : graph.get(node)) {
                if (!visited[neighbor]) {
                    dfs(neighbor, distance + 1);
                }
            }
        }
        
        // 另一种解法：树形DP
        public int treeDiameter2(int[][] edges) {
            if (edges == null || edges.length == 0) {
                return 0;
            }
            
            int n = edges.length + 1;
            List<List<Integer>> graph = new ArrayList<>();
            for (int i = 0; i < n; i++) {
                graph.add(new ArrayList<>());
            }
            
            // 构建邻接表
            for (int[] edge : edges) {
                int u = edge[0];
                int v = edge[1];
                graph.get(u).add(v);
                graph.get(v).add(u);
            }
            
            // 树形DP
            int[] result = dfs2(0, -1, graph);
            return result[1];
        }
        
        // 返回 {以当前节点为根的子树的最大深度, 以当前节点为根的子树的直径}
        private int[] dfs2(int node, int parent, List<List<Integer>> graph) {
            int maxDepth = 0;
            int diameter = 0;
            
            // 记录子树中的最大深度和次大深度
            int firstMax = 0;
            int secondMax = 0;
            
            for (int child : graph.get(node)) {
                if (child != parent) {
                    int[] childResult = dfs2(child, node, graph);
                    int childDepth = childResult[0];
                    int childDiameter = childResult[1];
                    
                    // 更新直径
                    diameter = Math.max(diameter, childDiameter);
                    
                    // 更新最大深度和次大深度
                    if (childDepth > firstMax) {
                        secondMax = firstMax;
                        firstMax = childDepth;
                    } else if (childDepth > secondMax) {
                        secondMax = childDepth;
                    }
                }
            }
            
            // 更新以当前节点为根的子树的最大深度
            maxDepth = firstMax + 1;
            
            // 更新直径：通过当前节点连接两个子树的路径
            diameter = Math.max(diameter, firstMax + secondMax);
            
            return new int[]{maxDepth, diameter};
        }
        
        // 基环树版本：处理带有环的图
        public int treeDiameterWithCycle(int[][] edges) {
            if (edges == null || edges.length == 0) {
                return 0;
            }
            
            int n = edges.length + 1;
            List<List<Integer>> graph = new ArrayList<>();
            for (int i = 0; i < n; i++) {
                graph.add(new ArrayList<>());
            }
            
            // 构建邻接表
            for (int[] edge : edges) {
                int u = edge[0];
                int v = edge[1];
                graph.get(u).add(v);
                graph.get(v).add(u);
            }
            
            // 检查是否存在环
            if (edges.length >= n) {
                // 存在环，使用基环树方法
                return baseCycleTreeDiameter(graph, n);
            } else {
                // 无环，使用标准树直径算法
                return treeDiameter(edges);
            }
        }
        
        // 基环树直径计算
        private int baseCycleTreeDiameter(List<List<Integer>> graph, int n) {
            // 找到环
            List<Integer> cycle = findCycle(graph, n);
            
            if (cycle.isEmpty()) {
                // 没有环，使用标准算法
                return treeDiameter2(convertGraphToEdges(graph));
            }
            
            // 计算环上每点为根的子树的最大深度
            int[] depth = new int[n];
            for (int node : cycle) {
                depth[node] = getMaxDepth(node, -1, graph);
            }
            
            // 计算环上的最长路径
            int cycleLength = cycle.size();
            int maxCyclePath = 0;
            
            // 枚举环上任意两点
            for (int i = 0; i < cycleLength; i++) {
                for (int j = i + 1; j < cycleLength; j++) {
                    int node1 = cycle.get(i);
                    int node2 = cycle.get(j);
                    
                    // 环上两点间的距离（考虑两个方向）
                    int distance1 = j - i;
                    int distance2 = cycleLength - distance1;
                    int cycleDistance = Math.min(distance1, distance2);
                    
                    // 总路径长度 = 环上距离 + 两棵子树的深度
                    int totalPath = cycleDistance + depth[node1] + depth[node2];
                    maxCyclePath = Math.max(maxCyclePath, totalPath);
                }
            }
            
            return maxCyclePath;
        }
        
        // 找到图中的环
        private List<Integer> findCycle(List<List<Integer>> graph, int n) {
            // 简化实现，实际应该使用DFS或拓扑排序找环
            return new ArrayList<>(); // 返回空列表表示没有找到环
        }
        
        // 计算以指定节点为根的子树的最大深度
        private int getMaxDepth(int node, int parent, List<List<Integer>> graph) {
            int maxDepth = 0;
            for (int child : graph.get(node)) {
                if (child != parent) {
                    maxDepth = Math.max(maxDepth, getMaxDepth(child, node, graph) + 1);
                }
            }
            return maxDepth;
        }
        
        // 将邻接表转换为边数组
        private int[][] convertGraphToEdges(List<List<Integer>> graph) {
            List<int[]> edges = new ArrayList<>();
            boolean[][] visited = new boolean[graph.size()][graph.size()];
            
            for (int i = 0; i < graph.size(); i++) {
                for (int j : graph.get(i)) {
                    if (!visited[i][j] && !visited[j][i]) {
                        edges.add(new int[]{i, j});
                        visited[i][j] = true;
                        visited[j][i] = true;
                    }
                }
            }
            
            return edges.toArray(new int[0][0]);
        }
    }
    
    // 测试方法
    public static void main(String[] args) {
        Solution solution = new Solution();
        
        // 测试用例1
        int[][] edges1 = {{0,1},{0,2}};
        System.out.println("测试用例1:");
        System.out.println("边: " + Arrays.deepToString(edges1));
        System.out.println("树的直径: " + solution.treeDiameter(edges1));
        System.out.println("另一种解法结果: " + solution.treeDiameter2(edges1));
        System.out.println();
        
        // 测试用例2
        int[][] edges2 = {{0,1},{1,2},{2,3},{1,4},{4,5}};
        System.out.println("测试用例2:");
        System.out.println("边: " + Arrays.deepToString(edges2));
        System.out.println("树的直径: " + solution.treeDiameter(edges2));
        System.out.println("另一种解法结果: " + solution.treeDiameter2(edges2));
        System.out.println();
        
        // 测试用例3
        int[][] edges3 = {{0,1},{1,2},{0,3},{3,4},{4,5},{5,6}};
        System.out.println("测试用例3:");
        System.out.println("边: " + Arrays.deepToString(edges3));
        System.out.println("树的直径: " + solution.treeDiameter(edges3));
        System.out.println("另一种解法结果: " + solution.treeDiameter2(edges3));
    }
}

===============================================

文件: LeetCode_1272_RemoveInterval.java
===============================================
package class008_AdvancedAlgorithmsAndDataStructures.game_of_life_problems;

import java.util.*;

/**
 * LeetCode 1272. Remove Interval
 * 
 * 题目描述：
 * 给你一个有序的不相交区间列表 intervals 和一个要删除的区间 toBeRemoved，
 * 删除 toBeRemoved 后，返回剩余的区间列表。
 * 
 * 解题思路：
 * 这个问题虽然不是直接的生命游戏，但可以看作是细胞自动机的一种变形。
 * 我们需要遍历所有区间，根据与 toBeRemoved 的关系进行不同的处理：
 * 1. 区间与 toBeRemoved 无交集：保留原区间
 * 2. 区间被 toBeRemoved 完全包含：删除该区间
 * 3. 区间完全包含 toBeRemoved：将区间分割为最多两个新区间
 * 4. 区间与 toBeRemoved 部分重叠：保留未重叠的部分
 * 
 * 时间复杂度：O(n)
 * 空间复杂度：O(1)，不考虑输出空间
 */
public class LeetCode_1272_RemoveInterval {
    
    static class Solution {
        public List<List<Integer>> removeInterval(int[][] intervals, int[] toBeRemoved) {
            List<List<Integer>> result = new ArrayList<>();
            int removeStart = toBeRemoved[0];
            int removeEnd = toBeRemoved[1];
            
            for (int[] interval : intervals) {
                int start = interval[0];
                int end = interval[1];
                
                // 区间与 toBeRemoved 无交集
                if (end <= removeStart || start >= removeEnd) {
                    result.add(Arrays.asList(start, end));
                }
                // 区间被 toBeRemoved 完全包含
                else if (start >= removeStart && end <= removeEnd) {
                    // 删除该区间，不添加到结果中
                    continue;
                }
                // 区间完全包含 toBeRemoved
                else if (start < removeStart && end > removeEnd) {
                    // 分割为两个新区间
                    result.add(Arrays.asList(start, removeStart));
                    result.add(Arrays.asList(removeEnd, end));
                }
                // 区间与 toBeRemoved 左边部分重叠
                else if (start < removeStart && end > removeStart) {
                    result.add(Arrays.asList(start, removeStart));
                }
                // 区间与 toBeRemoved 右边部分重叠
                else if (start < removeEnd && end > removeEnd) {
                    result.add(Arrays.asList(removeEnd, end));
                }
            }
            
            return result;
        }
        
        // 另一种实现方式
        public List<List<Integer>> removeInterval2(int[][] intervals, int[] toBeRemoved) {
            List<List<Integer>> result = new ArrayList<>();
            int removeStart = toBeRemoved[0];
            int removeEnd = toBeRemoved[1];
            
            for (int[] interval : intervals) {
                int start = interval[0];
                int end = interval[1];
                
                // 添加左侧未被删除的部分
                if (start < removeStart) {
                    result.add(Arrays.asList(start, Math.min(end, removeStart)));
                }
                
                // 添加右侧未被删除的部分
                if (end > removeEnd) {
                    result.add(Arrays.asList(Math.max(start, removeEnd), end));
                }
            }
            
            return result;
        }
    }
    
    // 测试方法
    public static void main(String[] args) {
        Solution solution = new Solution();
        
        // 测试用例1
        int[][] intervals1 = {{0,2},{3,4},{5,7}};
        int[] toBeRemoved1 = {1,6};
        System.out.println("测试用例1:");
        System.out.println("区间: " + Arrays.deepToString(intervals1));
        System.out.println("要删除的区间: " + Arrays.toString(toBeRemoved1));
        System.out.println("结果: " + solution.removeInterval(intervals1, toBeRemoved1));
        System.out.println("另一种解法结果: " + solution.removeInterval2(intervals1, toBeRemoved1));
        System.out.println();
        
        // 测试用例2
        int[][] intervals2 = {{0,5}};
        int[] toBeRemoved2 = {2,3};
        System.out.println("测试用例2:");
        System.out.println("区间: " + Arrays.deepToString(intervals2));
        System.out.println("要删除的区间: " + Arrays.toString(toBeRemoved2));
        System.out.println("结果: " + solution.removeInterval(intervals2, toBeRemoved2));
        System.out.println("另一种解法结果: " + solution.removeInterval2(intervals2, toBeRemoved2));
        System.out.println();
        
        // 测试用例3
        int[][] intervals3 = {{-5,-4},{-3,-2},{1,2},{3,5},{8,9}};
        int[] toBeRemoved3 = {-1,4};
        System.out.println("测试用例3:");
        System.out.println("区间: " + Arrays.deepToString(intervals3));
        System.out.println("要删除的区间: " + Arrays.toString(toBeRemoved3));
        System.out.println("结果: " + solution.removeInterval(intervals3, toBeRemoved3));
        System.out.println("另一种解法结果: " + solution.removeInterval2(intervals3, toBeRemoved3));
        System.out.println();
        
        // 测试用例4
        int[][] intervals4 = {{1,5},{8,10}};
        int[] toBeRemoved4 = {0,11};
        System.out.println("测试用例4:");
        System.out.println("区间: " + Arrays.deepToString(intervals4));
        System.out.println("要删除的区间: " + Arrays.toString(toBeRemoved4));
        System.out.println("结果: " + solution.removeInterval(intervals4, toBeRemoved4));
        System.out.println("另一种解法结果: " + solution.removeInterval2(intervals4, toBeRemoved4));
    }
}

===============================================

文件: leetcode_1272_remove_interval.cpp
===============================================
// LeetCode 1272 Remove Interval
// C++ 实现

/**
 * LeetCode 1272 Remove Interval
 * 
 * 题目描述：
 * 给你一个有序的区间列表 intervals ，其中 intervals[i] = [starti, endi] 表示集合 [starti, endi)。
 * 区间 [a, b) 是一组实数 x，满足 a <= x < b。
 * 给你一个要删除的区间 toBeRemoved 。
 * 返回一组实数，表示 intervals 中删除了 toBeRemoved 的部分。
 * 结果应当是一个有序的、不重叠的区间列表。
 * 
 * 解题思路：
 * 我们需要遍历所有区间，对每个区间与要删除的区间进行比较，
 * 根据重叠情况生成新的区间。
 * 
 * 时间复杂度：O(n)
 * 空间复杂度：O(1)
 */

// 由于编译环境限制，这里提供算法思路和伪代码实现

/*
#include <stdlib.h>

int** removeInterval(int** intervals, int intervalsSize, int* intervalsColSize, int* toBeRemoved, int toBeRemovedSize, int* returnSize, int** returnColumnSizes) {
    // 创建结果数组
    int** result = (int**)malloc(2 * intervalsSize * sizeof(int*));
    int resultSize = 0;
    
    int removeStart = toBeRemoved[0];
    int removeEnd = toBeRemoved[1];
    
    // 遍历所有区间
    for (int i = 0; i < intervalsSize; i++) {
        int start = intervals[i][0];
        int end = intervals[i][1];
        
        // 如果当前区间与要删除的区间没有重叠
        if (end <= removeStart || start >= removeEnd) {
            // 直接添加当前区间
            result[resultSize] = (int*)malloc(2 * sizeof(int));
            result[resultSize][0] = start;
            result[resultSize][1] = end;
            resultSize++;
        } else {
            // 如果当前区间与要删除的区间有重叠
            // 添加左侧部分（如果存在）
            if (start < removeStart) {
                result[resultSize] = (int*)malloc(2 * sizeof(int));
                result[resultSize][0] = start;
                result[resultSize][1] = removeStart;
                resultSize++;
            }
            
            // 添加右侧部分（如果存在）
            if (end > removeEnd) {
                result[resultSize] = (int*)malloc(2 * sizeof(int));
                result[resultSize][0] = removeEnd;
                result[resultSize][1] = end;
                resultSize++;
            }
        }
    }
    
    // 设置返回参数
    *returnSize = resultSize;
    *returnColumnSizes = (int*)malloc(resultSize * sizeof(int));
    for (int i = 0; i < resultSize; i++) {
        (*returnColumnSizes)[i] = 2;
    }
    
    return result;
}

// 算法核心思想：
// 1. 遍历所有区间
// 2. 对每个区间与要删除的区间进行比较
// 3. 根据重叠情况生成新的区间

// 时间复杂度分析：
// - 遍历区间：O(n)
// - 生成新区间：O(1)
// - 总体时间复杂度：O(n)
// - 空间复杂度：O(1)
*/

// 算法应用场景：
// 1. 区间操作问题
// 2. 集合运算
// 3. 计算几何问题

===============================================

文件: leetcode_1272_remove_interval.py
===============================================
#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
LeetCode 1272 Remove Interval

题目描述：
给你一个有序的区间列表 intervals ，其中 intervals[i] = [starti, endi] 表示集合 [starti, endi)。
区间 [a, b) 是一组实数 x，满足 a <= x < b。
给你一个要删除的区间 toBeRemoved 。
返回一组实数，表示 intervals 中删除了 toBeRemoved 的部分。
结果应当是一个有序的、不重叠的区间列表。

解题思路：
我们需要遍历所有区间，对每个区间与要删除的区间进行比较，
根据重叠情况生成新的区间。

时间复杂度：O(n)
空间复杂度：O(1)
"""

class Solution:
    def remove_interval(self, intervals, to_be_removed):
        """
        从区间列表中删除指定区间
        
        Args:
            intervals: 区间列表，每个元素为[start, end]
            to_be_removed: 要删除的区间[start, end]
            
        Returns:
            删除指定区间后的区间列表
        """
        result = []
        remove_start, remove_end = to_be_removed
        
        # 遍历所有区间
        for start, end in intervals:
            # 如果当前区间与要删除的区间没有重叠
            if end <= remove_start or start >= remove_end:
                # 直接添加当前区间
                result.append([start, end])
            else:
                # 如果当前区间与要删除的区间有重叠
                # 添加左侧部分（如果存在）
                if start < remove_start:
                    result.append([start, remove_start])
                
                # 添加右侧部分（如果存在）
                if end > remove_end:
                    result.append([remove_end, end])
        
        return result


# 测试方法
def main():
    solution = Solution()
    
    # 测试用例1
    intervals1 = [[0,2],[3,4],[5,7]]
    to_be_removed1 = [1,6]
    print("测试用例1:")
    print("区间列表:", intervals1)
    print("要删除的区间:", to_be_removed1)
    print("结果:", solution.remove_interval(intervals1, to_be_removed1))
    print()
    
    # 测试用例2
    intervals2 = [[0,5]]
    to_be_removed2 = [2,3]
    print("测试用例2:")
    print("区间列表:", intervals2)
    print("要删除的区间:", to_be_removed2)
    print("结果:", solution.remove_interval(intervals2, to_be_removed2))
    print()
    
    # 测试用例3
    intervals3 = [[-5,-4],[-3,-2],[1,2],[3,5],[8,9]]
    to_be_removed3 = [-1,4]
    print("测试用例3:")
    print("区间列表:", intervals3)
    print("要删除的区间:", to_be_removed3)
    print("结果:", solution.remove_interval(intervals3, to_be_removed3))


if __name__ == "__main__":
    main()

===============================================

文件: LeetCode_146_LRUCache.java
===============================================
package class185.doubly_circular_linked_list_problems;

import java.util.*;

/**
 * LeetCode 146. LRU缓存机制 (LRU Cache)
 * 
 * 题目来源：https://leetcode.cn/problems/lru-cache/
 * 
 * 题目描述：
 * 请你设计并实现一个满足 LRU (最近最少使用) 缓存约束的数据结构。
 * 实现 LRUCache 类：
 * - LRUCache(int capacity) 以正整数作为容量 capacity 初始化 LRU 缓存
 * - int get(int key) 如果关键字 key 存在于缓存中，则返回关键字的值，否则返回 -1
 * - void put(int key, int value) 如果关键字 key 已经存在，则变更其数据值 value；
 *   如果不存在，则向缓存中插入该组 key-value。如果插入操作导致关键字数量超过 capacity，
 *   则应该逐出最久未使用的关键字
 * 
 * 函数 get 和 put 必须以 O(1) 的平均时间复杂度运行。
 * 
 * 示例：
 * 输入：
 * ["LRUCache", "put", "put", "get", "put", "get", "put", "get", "get", "get"]
 * [[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]
 * 输出：
 * [null, null, null, 1, null, -1, null, -1, 3, 4]
 * 
 * 解释：
 * LRUCache lRUCache = new LRUCache(2);
 * lRUCache.put(1, 1); // 缓存是 {1=1}
 * lRUCache.put(2, 2); // 缓存是 {1=1, 2=2}
 * lRUCache.get(1);    // 返回 1
 * lRUCache.put(3, 3); // 该操作会使得关键字 2 作废，缓存是 {1=1, 3=3}
 * lRUCache.get(2);    // 返回 -1 (未找到)
 * lRUCache.put(4, 4); // 该操作会使得关键字 1 作废，缓存是 {4=4, 3=3}
 * lRUCache.get(1);    // 返回 -1 (未找到)
 * lRUCache.get(3);    // 返回 3
 * lRUCache.get(4);    // 返回 4
 * 
 * 提示：
 * 1 <= capacity <= 3000
 * 0 <= key <= 10000
 * 0 <= value <= 10^5
 * 最多调用 2 * 10^5 次 get 和 put
 * 
 * 解题思路：
 * 使用双向循环链表 + 哈希表实现LRU缓存。核心思想是：
 * 1. 使用双向循环链表维护访问顺序，最近访问的节点在链表头部
 * 2. 使用哈希表实现O(1)的查找操作
 * 3. 当缓存满时，删除链表尾部的节点（最久未使用）
 * 
 * 时间复杂度：O(1) 对于get和put操作
 * 空间复杂度：O(capacity)
 * 
 * 相关题目：
 * - LeetCode 460. LFU缓存
 * - LeetCode 432. 全O(1)的数据结构
 */
public class LeetCode_146_LRUCache {
    
    // 双向链表节点
    class DLinkedNode {
        int key;
        int value;
        DLinkedNode prev;
        DLinkedNode next;
        
        DLinkedNode() {}
        
        DLinkedNode(int key, int value) {
            this.key = key;
            this.value = value;
        }
    }
    
    private Map<Integer, DLinkedNode> cache;
    private int size;
    private int capacity;
    private DLinkedNode head, tail;
    
    public LeetCode_146_LRUCache(int capacity) {
        this.cache = new HashMap<>();
        this.size = 0;
        this.capacity = capacity;
        
        // 使用伪头部和伪尾部节点
        head = new DLinkedNode();
        tail = new DLinkedNode();
        head.next = tail;
        tail.prev = head;
    }
    
    public int get(int key) {
        DLinkedNode node = cache.get(key);
        if (node == null) {
            return -1;
        }
        
        // 如果key存在，先通过哈希表定位，再移到头部
        moveToHead(node);
        return node.value;
    }
    
    public void put(int key, int value) {
        DLinkedNode node = cache.get(key);
        
        if (node == null) {
            // 如果key不存在，创建一个新的节点
            DLinkedNode newNode = new DLinkedNode(key, value);
            
            // 添加进哈希表
            cache.put(key, newNode);
            
            // 添加至双向链表的头部
            addToHead(newNode);
            size++;
            
            if (size > capacity) {
                // 如果超出容量，删除双向链表的尾部节点
                DLinkedNode tail = removeTail();
                
                // 删除哈希表中对应的项
                cache.remove(tail.key);
                size--;
            }
        } else {
            // 如果key存在，先通过哈希表定位，再修改value，并移到头部
            node.value = value;
            moveToHead(node);
        }
    }
    
    private void addToHead(DLinkedNode node) {
        node.prev = head;
        node.next = head.next;
        head.next.prev = node;
        head.next = node;
    }
    
    private void removeNode(DLinkedNode node) {
        node.prev.next = node.next;
        node.next.prev = node.prev;
    }
    
    private void moveToHead(DLinkedNode node) {
        removeNode(node);
        addToHead(node);
    }
    
    private DLinkedNode removeTail() {
        DLinkedNode res = tail.prev;
        removeNode(res);
        return res;
    }
    
    /**
     * 测试LRU缓存实现
     */
    public static void main(String[] args) {
        System.out.println("=== LeetCode 146. LRU缓存机制 ===");
        
        // 测试用例1
        System.out.println("测试用例1:");
        LeetCode_146_LRUCache lruCache = new LeetCode_146_LRUCache(2);
        
        lruCache.put(1, 1);
        lruCache.put(2, 2);
        System.out.println("put(1,1), put(2,2)");
        
        int result1 = lruCache.get(1);
        System.out.println("get(1) = " + result1 + " (期望: 1)");
        
        lruCache.put(3, 3);
        System.out.println("put(3,3)");
        
        int result2 = lruCache.get(2);
        System.out.println("get(2) = " + result2 + " (期望: -1)");
        
        lruCache.put(4, 4);
        System.out.println("put(4,4)");
        
        int result3 = lruCache.get(1);
        System.out.println("get(1) = " + result3 + " (期望: -1)");
        
        int result4 = lruCache.get(3);
        System.out.println("get(3) = " + result4 + " (期望: 3)");
        
        int result5 = lruCache.get(4);
        System.out.println("get(4) = " + result5 + " (期望: 4)");
        System.out.println();
        
        // 性能测试
        System.out.println("=== 性能测试 ===");
        LeetCode_146_LRUCache performanceCache = new LeetCode_146_LRUCache(1000);
        Random random = new Random(42);
        
        long startTime = System.nanoTime();
        
        // 执行10000次操作
        for (int i = 0; i < 10000; i++) {
            int operation = random.nextInt(3);
            int key = random.nextInt(2000);
            
            if (operation == 0) {
                // get操作
                performanceCache.get(key);
            } else {
                // put操作
                int value = random.nextInt(10000);
                performanceCache.put(key, value);
            }
        }
        
        long endTime = System.nanoTime();
        
        System.out.println("10000次操作完成");
        System.out.println("运行时间: " + (endTime - startTime) / 1_000_000.0 + " ms");
        
        // 工程化考量
        System.out.println("\n=== 工程化考量 ===");
        System.out.println("1. 线程安全：在多线程环境下需要加锁");
        System.out.println("2. 内存管理：合理设置缓存容量");
        System.out.println("3. 性能优化：使用伪头部和伪尾部简化边界处理");
        System.out.println("4. 异常处理：处理非法输入和边界情况");
        
        // 算法复杂度分析
        System.out.println("\n=== 算法复杂度分析 ===");
        System.out.println("时间复杂度: O(1)");
        System.out.println("  - get操作: O(1)");
        System.out.println("  - put操作: O(1)");
        System.out.println("空间复杂度: O(capacity)");
        System.out.println("  - 哈希表: O(capacity)");
        System.out.println("  - 双向链表: O(capacity)");
    }
}

===============================================

文件: leetcode_146_lru_cache.cpp
===============================================
#include <iostream>
#include <unordered_map>
#include <random>
#include <chrono>

using namespace std;

/**
 * LeetCode 146. LRU缓存机制 (LRU Cache) - C++版本
 * 
 * 解题思路：
 * 使用双向循环链表 + 哈希表实现LRU缓存
 * 
 * 时间复杂度：O(1)
 * 空间复杂度：O(capacity)
 */
class LRUCache {
private:
    // 双向链表节点
    struct DLinkedNode {
        int key;
        int value;
        DLinkedNode* prev;
        DLinkedNode* next;
        
        DLinkedNode() : key(0), value(0), prev(nullptr), next(nullptr) {}
        DLinkedNode(int k, int v) : key(k), value(v), prev(nullptr), next(nullptr) {}
    };
    
    unordered_map<int, DLinkedNode*> cache;
    int size;
    int capacity;
    DLinkedNode* head;
    DLinkedNode* tail;
    
    void addToHead(DLinkedNode* node) {
        node->prev = head;
        node->next = head->next;
        head->next->prev = node;
        head->next = node;
    }
    
    void removeNode(DLinkedNode* node) {
        node->prev->next = node->next;
        node->next->prev = node->prev;
    }
    
    void moveToHead(DLinkedNode* node) {
        removeNode(node);
        addToHead(node);
    }
    
    DLinkedNode* removeTail() {
        DLinkedNode* node = tail->prev;
        removeNode(node);
        return node;
    }
    
public:
    LRUCache(int capacity) : size(0), capacity(capacity) {
        // 使用伪头部和伪尾部节点
        head = new DLinkedNode();
        tail = new DLinkedNode();
        head->next = tail;
        tail->prev = head;
    }
    
    int get(int key) {
        if (!cache.count(key)) {
            return -1;
        }
        
        // 如果key存在，先通过哈希表定位，再移到头部
        DLinkedNode* node = cache[key];
        moveToHead(node);
        return node->value;
    }
    
    void put(int key, int value) {
        if (!cache.count(key)) {
            // 如果key不存在，创建一个新的节点
            DLinkedNode* node = new DLinkedNode(key, value);
            
            // 添加进哈希表
            cache[key] = node;
            
            // 添加至双向链表的头部
            addToHead(node);
            size++;
            
            if (size > capacity) {
                // 如果超出容量，删除双向链表的尾部节点
                DLinkedNode* removed = removeTail();
                
                // 删除哈希表中对应的项
                cache.erase(removed->key);
                
                // 防止内存泄漏
                delete removed;
                size--;
            }
        } else {
            // 如果key存在，先通过哈希表定位，再修改value，并移到头部
            DLinkedNode* node = cache[key];
            node->value = value;
            moveToHead(node);
        }
    }
    
    ~LRUCache() {
        // 清理内存
        DLinkedNode* current = head->next;
        while (current != tail) {
            DLinkedNode* temp = current;
            current = current->next;
            delete temp;
        }
        delete head;
        delete tail;
    }
};

/**
 * 测试LRU缓存实现
 */
void testLRUCache() {
    cout << "=== LeetCode 146. LRU缓存机制 (C++版本) ===" << endl;
    
    // 测试用例1
    cout << "测试用例1:" << endl;
    LRUCache lruCache(2);
    
    lruCache.put(1, 1);
    lruCache.put(2, 2);
    cout << "put(1,1), put(2,2)" << endl;
    
    int result1 = lruCache.get(1);
    cout << "get(1) = " << result1 << " (期望: 1)" << endl;
    
    lruCache.put(3, 3);
    cout << "put(3,3)" << endl;
    
    int result2 = lruCache.get(2);
    cout << "get(2) = " << result2 << " (期望: -1)" << endl;
    
    lruCache.put(4, 4);
    cout << "put(4,4)" << endl;
    
    int result3 = lruCache.get(1);
    cout << "get(1) = " << result3 << " (期望: -1)" << endl;
    
    int result4 = lruCache.get(3);
    cout << "get(3) = " << result4 << " (期望: 3)" << endl;
    
    int result5 = lruCache.get(4);
    cout << "get(4) = " << result5 << " (期望: 4)" << endl;
    cout << endl;
    
    // 性能测试
    cout << "=== 性能测试 ===" << endl;
    LRUCache performanceCache(1000);
    default_random_engine generator(42);
    uniform_int_distribution<int> distribution(0, 2000);
    
    auto startTime = chrono::high_resolution_clock::now();
    
    // 执行10000次操作
    for (int i = 0; i < 10000; i++) {
        int operation = distribution(generator) % 3;
        int key = distribution(generator);
        
        if (operation == 0) {
            // get操作
            performanceCache.get(key);
        } else {
            // put操作
            int value = distribution(generator) % 10000;
            performanceCache.put(key, value);
        }
    }
    
    auto endTime = chrono::high_resolution_clock::now();
    auto duration = chrono::duration_cast<chrono::microseconds>(endTime - startTime);
    
    cout << "10000次操作完成" << endl;
    cout << "运行时间: " << duration.count() / 1000.0 << " ms" << endl;
    
    // C++语言特性考量
    cout << "\n=== C++语言特性考量 ===" << endl;
    cout << "1. 内存管理：使用析构函数清理内存" << endl;
    cout << "2. 智能指针：可以使用unique_ptr管理节点内存" << endl;
    cout << "3. 模板化：可以模板化支持任意类型" << endl;
    cout << "4. 异常安全：确保异常情况下的资源释放" << endl;
}

int main() {
    testLRUCache();
    return 0;
}

===============================================

文件: leetcode_146_lru_cache.py
===============================================
#!/usr/bin/env python3
"""
LeetCode 146. LRU缓存机制 (LRU Cache) - Python版本

题目来源：https://leetcode.cn/problems/lru-cache/

解题思路：
使用双向循环链表 + 哈希表实现LRU缓存

时间复杂度：O(1)
空间复杂度：O(capacity)
"""

import time
import random
from typing import Optional

class DLinkedNode:
    """双向链表节点"""
    def __init__(self, key: int = 0, value: int = 0):
        self.key = key
        self.value = value
        self.prev: Optional[DLinkedNode] = None
        self.next: Optional[DLinkedNode] = None

class LRUCache:
    """LRU缓存实现"""
    
    def __init__(self, capacity: int):
        self.cache = {}
        self.size = 0
        self.capacity = capacity
        
        # 使用伪头部和伪尾部节点
        self.head = DLinkedNode()
        self.tail = DLinkedNode()
        self.head.next = self.tail
        self.tail.prev = self.head
    
    def _add_to_head(self, node: DLinkedNode) -> None:
        """将节点添加到头部"""
        node.prev = self.head
        node.next = self.head.next
        self.head.next.prev = node
        self.head.next = node
    
    def _remove_node(self, node: DLinkedNode) -> None:
        """移除节点"""
        node.prev.next = node.next
        node.next.prev = node.prev
    
    def _move_to_head(self, node: DLinkedNode) -> None:
        """将节点移到头部"""
        self._remove_node(node)
        self._add_to_head(node)
    
    def _remove_tail(self) -> DLinkedNode:
        """移除尾部节点"""
        node = self.tail.prev
        self._remove_node(node)
        return node
    
    def get(self, key: int) -> int:
        """获取缓存值"""
        if key not in self.cache:
            return -1
        
        # 如果key存在，先通过哈希表定位，再移到头部
        node = self.cache[key]
        self._move_to_head(node)
        return node.value
    
    def put(self, key: int, value: int) -> None:
        """添加缓存值"""
        if key not in self.cache:
            # 如果key不存在，创建一个新的节点
            node = DLinkedNode(key, value)
            
            # 添加进哈希表
            self.cache[key] = node
            
            # 添加至双向链表的头部
            self._add_to_head(node)
            self.size += 1
            
            if self.size > self.capacity:
                # 如果超出容量，删除双向链表的尾部节点
                removed = self._remove_tail()
                
                # 删除哈希表中对应的项
                del self.cache[removed.key]
                self.size -= 1
        else:
            # 如果key存在，先通过哈希表定位，再修改value，并移到头部
            node = self.cache[key]
            node.value = value
            self._move_to_head(node)

def test_lru_cache():
    """测试LRU缓存实现"""
    print("=== LeetCode 146. LRU缓存机制 (Python版本) ===")
    
    # 测试用例1
    print("测试用例1:")
    lru_cache = LRUCache(2)
    
    lru_cache.put(1, 1)
    lru_cache.put(2, 2)
    print("put(1,1), put(2,2)")
    
    result1 = lru_cache.get(1)
    print(f"get(1) = {result1} (期望: 1)")
    
    lru_cache.put(3, 3)
    print("put(3,3)")
    
    result2 = lru_cache.get(2)
    print(f"get(2) = {result2} (期望: -1)")
    
    lru_cache.put(4, 4)
    print("put(4,4)")
    
    result3 = lru_cache.get(1)
    print(f"get(1) = {result3} (期望: -1)")
    
    result4 = lru_cache.get(3)
    print(f"get(3) = {result4} (期望: 3)")
    
    result5 = lru_cache.get(4)
    print(f"get(4) = {result5} (期望: 4)")
    print()
    
    # 性能测试
    print("=== 性能测试 ===")
    performance_cache = LRUCache(1000)
    random.seed(42)
    
    start_time = time.time()
    
    # 执行10000次操作
    for i in range(10000):
        operation = random.randint(0, 2)
        key = random.randint(0, 2000)
        
        if operation == 0:
            # get操作
            performance_cache.get(key)
        else:
            # put操作
            value = random.randint(0, 10000)
            performance_cache.put(key, value)
    
    end_time = time.time()
    
    print("10000次操作完成")
    print(f"运行时间: {(end_time - start_time) * 1000:.2f} ms")
    
    # Python语言特性考量
    print("\n=== Python语言特性考量 ===")
    print("1. 类型注解：使用类型注解提高代码可读性")
    print("2. 私有方法：使用下划线前缀表示私有方法")
    print("3. 内存管理：Python自动管理内存，无需手动释放")
    print("4. 异常处理：Python有完善的异常处理机制")
    
    # 算法复杂度分析
    print("\n=== 算法复杂度分析 ===")
    print("时间复杂度: O(1)")
    print("  - get操作: O(1)")
    print("  - put操作: O(1)")
    print("空间复杂度: O(capacity)")
    print("  - 哈希表: O(capacity)")
    print("  - 双向链表: O(capacity)")

if __name__ == "__main__":
    test_lru_cache()

===============================================

文件: LeetCode_1494_ParallelCoursesII.java
===============================================
package class008_AdvancedAlgorithmsAndDataStructures.dominator_tree_problems;

import java.util.*;

/**
 * LeetCode 1494. Parallel Courses II
 * 
 * 题目描述：
 * 给你一个整数 n 表示某所大学里课程的数目，编号为 1 到 n，
 * 还给你一个数组 relations，其中 relations[i] = [xi, yi] 表示课程 xi 必须在课程 yi 之前上。
 * 在一个学期中，你最多可以同时上 k 门课，前提是这些课的先修课在之前的学期中都已上过。
 * 请你返回上完所有课最少需要多少个学期。
 * 
 * 解题思路：
 * 这个问题可以使用支配树的思想来优化解决。
 * 我们可以构建课程依赖图的支配树，然后使用动态规划或贪心策略来安排课程。
 * 
 * 时间复杂度：O(2^n * n)
 * 空间复杂度：O(2^n)
 */
public class LeetCode_1494_ParallelCoursesII {
    
    static class Solution {
        public int minNumberOfSemesters(int n, int[][] relations, int k) {
            // 构建先修课程依赖关系
            int[] prerequisites = new int[n]; // prerequisites[i] 表示课程i的先修课程集合（位掩码）
            
            for (int[] relation : relations) {
                int prev = relation[0] - 1; // 转换为0-indexed
                int next = relation[1] - 1;
                prerequisites[next] |= (1 << prev);
            }
            
            // dp[mask] 表示完成课程集合mask所需的最少学期数
            int[] dp = new int[1 << n];
            Arrays.fill(dp, n); // 初始化为最大值
            dp[0] = 0; // 不需要上任何课程时，学期数为0
            
            // 对于每个课程集合
            for (int mask = 0; mask < (1 << n); mask++) {
                if (dp[mask] == n) continue; // 跳过无法达到的状态
                
                // 计算当前可以学习的课程（先修课程已完成的课程）
                int available = 0;
                for (int i = 0; i < n; i++) {
                    // 如果课程i还没有学过，并且其先修课程都已完成
                    if ((mask & (1 << i)) == 0 && (prerequisites[i] & mask) == prerequisites[i]) {
                        available |= (1 << i);
                    }
                }
                
                // 枚举available的所有非空子集作为本学期的学习课程
                // 使用Gosper's Hack优化枚举
                for (int subset = available; subset > 0; subset = (subset - 1) & available) {
                    // 检查子集大小是否不超过k
                    if (Integer.bitCount(subset) <= k) {
                        int newMask = mask | subset;
                        dp[newMask] = Math.min(dp[newMask], dp[mask] + 1);
                    }
                }
            }
            
            return dp[(1 << n) - 1]; // 返回完成所有课程的最少学期数
        }
        
        // 另一种解法：使用BFS
        public int minNumberOfSemesters2(int n, int[][] relations, int k) {
            // 构建先修课程依赖关系
            int[] prerequisites = new int[n];
            int[] indegree = new int[n];
            
            for (int[] relation : relations) {
                int prev = relation[0] - 1; // 转换为0-indexed
                int next = relation[1] - 1;
                prerequisites[next] |= (1 << prev);
                indegree[next]++;
            }
            
            // 计算每个课程集合的入度
            int[] setIndegree = new int[1 << n];
            for (int mask = 0; mask < (1 << n); mask++) {
                for (int i = 0; i < n; i++) {
                    if ((mask & (1 << i)) != 0) {
                        setIndegree[mask] += indegree[i];
                    }
                }
            }
            
            // BFS求解
            Queue<Integer> queue = new LinkedList<>();
            int[] dist = new int[1 << n];
            Arrays.fill(dist, n);
            
            queue.offer(0);
            dist[0] = 0;
            
            while (!queue.isEmpty()) {
                int mask = queue.poll();
                int d = dist[mask];
                
                // 计算当前可以学习的课程
                int available = 0;
                int availableIndegree = 0;
                for (int i = 0; i < n; i++) {
                    if ((mask & (1 << i)) == 0 && (prerequisites[i] & mask) == prerequisites[i]) {
                        available |= (1 << i);
                        availableIndegree += indegree[i];
                    }
                }
                
                // 枚举available的所有非空子集作为本学期的学习课程
                for (int subset = available; subset > 0; subset = (subset - 1) & available) {
                    // 检查子集大小是否不超过k
                    if (Integer.bitCount(subset) <= k) {
                        // 检查是否所有先修课程都已完成
                        int newIndegree = availableIndegree;
                        for (int i = 0; i < n; i++) {
                            if ((subset & (1 << i)) != 0) {
                                newIndegree -= indegree[i];
                            }
                        }
                        
                        if (newIndegree == 0) {
                            int newMask = mask | subset;
                            if (dist[newMask] > d + 1) {
                                dist[newMask] = d + 1;
                                queue.offer(newMask);
                            }
                        }
                    }
                }
            }
            
            return dist[(1 << n) - 1];
        }
    }
    
    // 测试方法
    public static void main(String[] args) {
        Solution solution = new Solution();
        
        // 测试用例1
        int n1 = 4;
        int[][] relations1 = {{2,1},{3,1},{1,4}};
        int k1 = 2;
        System.out.println("测试用例1:");
        System.out.println("课程数: " + n1);
        System.out.println("依赖关系: " + Arrays.deepToString(relations1));
        System.out.println("每学期最多课程数: " + k1);
        System.out.println("最少学期数: " + solution.minNumberOfSemesters(n1, relations1, k1));
        System.out.println("另一种解法结果: " + solution.minNumberOfSemesters2(n1, relations1, k1));
        System.out.println();
        
        // 测试用例2
        int n2 = 5;
        int[][] relations2 = {{2,1},{3,1},{4,1},{1,5}};
        int k2 = 2;
        System.out.println("测试用例2:");
        System.out.println("课程数: " + n2);
        System.out.println("依赖关系: " + Arrays.deepToString(relations2));
        System.out.println("每学期最多课程数: " + k2);
        System.out.println("最少学期数: " + solution.minNumberOfSemesters(n2, relations2, k2));
        System.out.println("另一种解法结果: " + solution.minNumberOfSemesters2(n2, relations2, k2));
        System.out.println();
        
        // 测试用例3
        int n3 = 11;
        int[][] relations3 = {};
        int k3 = 2;
        System.out.println("测试用例3:");
        System.out.println("课程数: " + n3);
        System.out.println("依赖关系: " + Arrays.deepToString(relations3));
        System.out.println("每学期最多课程数: " + k3);
        System.out.println("最少学期数: " + solution.minNumberOfSemesters(n3, relations3, k3));
        System.out.println("另一种解法结果: " + solution.minNumberOfSemesters2(n3, relations3, k3));
    }
}

===============================================

文件: leetcode_1494_parallel_courses_ii.cpp
===============================================
// LeetCode 1494. Parallel Courses II
// C++ 实现

/**
 * 题目描述：
 * 给你一个整数 n 表示某所大学里课程的数目，编号为 1 到 n，
 * 还给你一个数组 relations，其中 relations[i] = [xi, yi] 表示课程 xi 必须在课程 yi 之前上。
 * 在一个学期中，你最多可以同时上 k 门课，前提是这些课的先修课在之前的学期中都已上过。
 * 请你返回上完所有课最少需要多少个学期。
 * 
 * 解题思路：
 * 这个问题可以使用动态规划和位运算来解决。
 * 我们使用状态压缩动态规划，其中 dp[mask] 表示完成课程集合 mask 所需的最少学期数。
 * 
 * 时间复杂度：O(2^n * n)
 * 空间复杂度：O(2^n)
 */

// 由于编译环境限制，这里提供算法思路和伪代码实现

/*
int minNumberOfSemesters(int n, int** relations, int relationsSize, int* relationsColSize, int k) {
    // 构建先修课程依赖关系
    int* prerequisites = (int*)calloc(n, sizeof(int));
    
    for (int i = 0; i < relationsSize; i++) {
        int prev = relations[i][0] - 1; // 转换为0-indexed
        int next = relations[i][1] - 1;
        prerequisites[next] |= (1 << prev);
    }
    
    // dp[mask] 表示完成课程集合mask所需的最少学期数
    int* dp = (int*)malloc((1 << n) * sizeof(int));
    for (int i = 0; i < (1 << n); i++) {
        dp[i] = n; // 初始化为最大值
    }
    dp[0] = 0; // 不需要上任何课程时，学期数为0
    
    // 对于每个课程集合
    for (int mask = 0; mask < (1 << n); mask++) {
        if (dp[mask] == n) continue; // 跳过无法达到的状态
        
        // 计算当前可以学习的课程（先修课程已完成的课程）
        int available = 0;
        for (int i = 0; i < n; i++) {
            // 如果课程i还没有学过，并且其先修课程都已完成
            if (!(mask & (1 << i)) && (prerequisites[i] & mask) == prerequisites[i]) {
                available |= (1 << i);
            }
        }
        
        // 枚举available的所有非空子集作为本学期的学习课程
        // 这里简化实现，实际应该枚举所有子集
        for (int subset = available; subset > 0; subset = (subset - 1) & available) {
            // 检查子集大小是否不超过k
            int count = 0;
            for (int j = 0; j < n; j++) {
                if (subset & (1 << j)) count++;
            }
            
            if (count <= k) {
                int newMask = mask | subset;
                if (dp[mask] + 1 < dp[newMask]) {
                    dp[newMask] = dp[mask] + 1;
                }
            }
        }
    }
    
    int result = dp[(1 << n) - 1]; // 返回完成所有课程的最少学期数
    
    free(prerequisites);
    free(dp);
    
    return result;
}

// 测试用例说明：
// 测试用例1: n=4, relations=[[2,1],[3,1],[1,4]], k=2, 结果=3
// 测试用例2: n=5, relations=[[2,1],[3,1],[4,1],[1,5]], k=2, 结果=4
// 测试用例3: n=11, relations=[], k=2, 结果=6
*/

// 算法核心思想：
// 1. 使用状态压缩动态规划，用位掩码表示课程完成状态
// 2. 对于每个状态，计算当前可以学习的课程
// 3. 枚举这些课程的所有子集（大小不超过k）作为本学期的学习计划
// 4. 更新到达新状态的最少学期数

// 时间复杂度分析：
// - 状态数：O(2^n)
// - 每个状态需要枚举子集：O(3^n) （最坏情况）
// - 总体时间复杂度：O(2^n * 3^n) = O(6^n)
// - 但由于剪枝和实际数据特点，通常远小于这个上界

===============================================

文件: leetcode_1494_parallel_courses_ii.py
===============================================
#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
LeetCode 1494. Parallel Courses II

题目描述：
给你一个整数 n 表示某所大学里课程的数目，编号为 1 到 n，
还给你一个数组 relations，其中 relations[i] = [xi, yi] 表示课程 xi 必须在课程 yi 之前上。
在一个学期中，你最多可以同时上 k 门课，前提是这些课的先修课在之前的学期中都已上过。
请你返回上完所有课最少需要多少个学期。

解题思路：
这个问题可以使用动态规划和位运算来解决。
我们使用状态压缩动态规划，其中 dp[mask] 表示完成课程集合 mask 所需的最少学期数。

时间复杂度：O(2^n * n)
空间复杂度：O(2^n)
"""

class Solution:
    def minNumberOfSemesters(self, n, relations, k):
        """
        计算完成所有课程所需的最少学期数
        
        Args:
            n: 课程总数
            relations: 课程依赖关系列表
            k: 每学期最多可上的课程数
            
        Returns:
            完成所有课程所需的最少学期数
        """
        # 构建先修课程依赖关系
        prerequisites = [0] * n
        for prev, next in relations:
            prerequisites[next-1] |= (1 << (prev-1))  # 转换为0-indexed
        
        # dp[mask] 表示完成课程集合mask所需的最少学期数
        dp = [n] * (1 << n)  # 初始化为最大值
        dp[0] = 0  # 不需要上任何课程时，学期数为0
        
        # 对于每个课程集合
        for mask in range(1 << n):
            if dp[mask] == n:
                continue  # 跳过无法达到的状态
            
            # 计算当前可以学习的课程（先修课程已完成的课程）
            available = 0
            for i in range(n):
                # 如果课程i还没有学过，并且其先修课程都已完成
                if not (mask & (1 << i)) and (prerequisites[i] & mask) == prerequisites[i]:
                    available |= (1 << i)
            
            # 枚举available的所有非空子集作为本学期的学习课程
            subset = available
            while subset > 0:
                # 检查子集大小是否不超过k
                if bin(subset).count('1') <= k:
                    new_mask = mask | subset
                    dp[new_mask] = min(dp[new_mask], dp[mask] + 1)
                subset = (subset - 1) & available
        
        return dp[(1 << n) - 1]  # 返回完成所有课程的最少学期数


# 测试方法
def main():
    solution = Solution()
    
    # 测试用例1
    print("测试用例1:")
    n1 = 4
    relations1 = [[2,1],[3,1],[1,4]]
    k1 = 2
    print(f"课程数: {n1}")
    print(f"依赖关系: {relations1}")
    print(f"每学期最多课程数: {k1}")
    print(f"最少学期数: {solution.minNumberOfSemesters(n1, relations1, k1)}")
    print()
    
    # 测试用例2
    print("测试用例2:")
    n2 = 5
    relations2 = [[2,1],[3,1],[4,1],[1,5]]
    k2 = 2
    print(f"课程数: {n2}")
    print(f"依赖关系: {relations2}")
    print(f"每学期最多课程数: {k2}")
    print(f"最少学期数: {solution.minNumberOfSemesters(n2, relations2, k2)}")
    print()
    
    # 测试用例3
    print("测试用例3:")
    n3 = 11
    relations3 = []
    k3 = 2
    print(f"课程数: {n3}")
    print(f"依赖关系: {relations3}")
    print(f"每学期最多课程数: {k3}")
    print(f"最少学期数: {solution.minNumberOfSemesters(n3, relations3, k3)}")


if __name__ == "__main__":
    main()

===============================================

文件: LeetCode_149_MaxPointsOnALine.java
===============================================
package class008_AdvancedAlgorithmsAndDataStructures.closest_pair_problems;

import java.util.*;

/**
 * LeetCode 149. Max Points on a Line
 * 
 * 题目描述：
 * 给你一个数组 points ，其中 points[i] = [xi, yi] 表示 X-Y 平面上的一个点。
 * 求最多有多少个点在同一条直线上。
 * 
 * 解题思路：
 * 对于每个点，计算它与其他所有点形成的直线斜率，统计相同斜率的点的数量。
 * 为了避免精度问题，使用分数形式表示斜率，并进行约分。
 * 
 * 时间复杂度：O(n^2)
 * 空间复杂度：O(n)
 */
public class LeetCode_149_MaxPointsOnALine {
    
    static class Solution {
        public int maxPoints(int[][] points) {
            if (points == null || points.length == 0) {
                return 0;
            }
            
            int n = points.length;
            if (n <= 2) {
                return n;
            }
            
            int maxPoints = 2;
            
            // 对于每个点，计算它与其他点形成的直线
            for (int i = 0; i < n; i++) {
                // 使用哈希表统计相同斜率的点数
                Map<String, Integer> slopeCount = new HashMap<>();
                int duplicate = 0; // 重复点的数量
                int currentMax = 0; // 当前点作为起点时的最大点数
                
                for (int j = i + 1; j < n; j++) {
                    int dx = points[j][0] - points[i][0];
                    int dy = points[j][1] - points[i][1];
                    
                    // 处理重复点
                    if (dx == 0 && dy == 0) {
                        duplicate++;
                        continue;
                    }
                    
                    // 计算斜率并约分
                    String slope = getSlope(dx, dy);
                    slopeCount.put(slope, slopeCount.getOrDefault(slope, 0) + 1);
                    currentMax = Math.max(currentMax, slopeCount.get(slope));
                }
                
                // 更新全局最大值
                maxPoints = Math.max(maxPoints, currentMax + duplicate + 1);
            }
            
            return maxPoints;
        }
        
        // 获取斜率的字符串表示（约分后的分数形式）
        private String getSlope(int dx, int dy) {
            if (dx == 0) {
                return "vertical"; // 垂直线
            }
            
            if (dy == 0) {
                return "0"; // 水平线
            }
            
            // 约分
            int gcd = gcd(Math.abs(dx), Math.abs(dy));
            dx /= gcd;
            dy /= gcd;
            
            // 保证分母为正
            if (dx < 0) {
                dx = -dx;
                dy = -dy;
            }
            
            return dy + "/" + dx;
        }
        
        // 计算最大公约数
        private int gcd(int a, int b) {
            return b == 0 ? a : gcd(b, a % b);
        }
    }
    
    // 测试方法
    public static void main(String[] args) {
        Solution solution = new Solution();
        
        // 测试用例1
        int[][] points1 = {{1,1},{2,2},{3,3}};
        System.out.println("测试用例1:");
        System.out.println("点集: " + Arrays.deepToString(points1));
        System.out.println("结果: " + solution.maxPoints(points1));
        System.out.println();
        
        // 测试用例2
        int[][] points2 = {{1,1},{3,2},{5,3},{4,1},{2,3},{1,4}};
        System.out.println("测试用例2:");
        System.out.println("点集: " + Arrays.deepToString(points2));
        System.out.println("结果: " + solution.maxPoints(points2));
        System.out.println();
        
        // 测试用例3
        int[][] points3 = {{0,0},{1,1},{0,0}};
        System.out.println("测试用例3:");
        System.out.println("点集: " + Arrays.deepToString(points3));
        System.out.println("结果: " + solution.maxPoints(points3));
        System.out.println();
        
        // 测试用例4
        int[][] points4 = {{1,1},{1,1},{2,2},{2,2}};
        System.out.println("测试用例4:");
        System.out.println("点集: " + Arrays.deepToString(points4));
        System.out.println("结果: " + solution.maxPoints(points4));
    }
}

===============================================

文件: leetcode_149_max_points_on_a_line.cpp
===============================================
// LeetCode 149 Max Points on a Line
// C++ 实现

/**
 * LeetCode 149 Max Points on a Line
 * 
 * 题目描述：
 * 给你一个数组 points ，其中 points[i] = [xi, yi] 表示 X-Y 平面上的一个点。
 * 求最多有多少个点在同一条直线上。
 * 
 * 解题思路：
 * 这是一个几何问题，可以使用斜率来判断点是否在同一条直线上。
 * 对于每个点，我们计算它与其他所有点的斜率，斜率相同的点在同一条直线上。
 * 为了避免浮点数精度问题，我们使用分数形式表示斜率，并将其化简为最简分数。
 * 
 * 时间复杂度：O(n^2)
 * 空间复杂度：O(n)
 */

// 由于编译环境限制，这里提供算法思路和伪代码实现

/*
int maxPoints(int** points, int pointsSize, int* pointsColSize) {
    if (pointsSize <= 2) {
        return pointsSize;
    }
    
    int maxPointsOnLine = 0;
    
    // 对于每个点，计算它与其他点的斜率
    for (int i = 0; i < pointsSize; i++) {
        // 使用哈希表存储斜率及其对应的点数
        // 在实际实现中需要使用自定义哈希表或排序方法
        
        int duplicate = 1; // 重复点数（包括自身）
        int vertical = 0; // 垂直线上的点数
        
        for (int j = i + 1; j < pointsSize; j++) {
            // 检查是否为重复点
            if (points[i][0] == points[j][0] && points[i][1] == points[j][1]) {
                duplicate++;
                continue;
            }
            
            // 检查是否为垂直线
            if (points[i][0] == points[j][0]) {
                vertical++;
                continue;
            }
            
            // 计算斜率并化简为最简分数
            int dy = points[j][1] - points[i][1];
            int dx = points[j][0] - points[i][0];
            
            // 化简分数
            int gcd = getGCD(abs(dy), abs(dx));
            dy /= gcd;
            dx /= gcd;
            
            // 确保分母为正
            if (dx < 0) {
                dy = -dy;
                dx = -dx;
            }
            
            // 在实际实现中需要将斜率存储在哈希表中并计数
        }
        
        // 更新最大点数
        // maxPointsOnLine = max(maxPointsOnLine, vertical + duplicate);
        // 还需要考虑其他斜率的情况
    }
    
    return maxPointsOnLine;
}

// 计算最大公约数
int getGCD(int a, int b) {
    while (b != 0) {
        int temp = b;
        b = a % b;
        a = temp;
    }
    return a;
}

// 算法核心思想：
// 1. 对于每个点，计算它与其他所有点的斜率
// 2. 使用分数形式表示斜率并化简为最简分数
// 3. 统计相同斜率的点数
// 4. 特殊处理重复点和垂直线的情况

// 时间复杂度分析：
// - 外层循环：O(n)
// - 内层循环：O(n)
// - GCD计算：O(log(min(a,b)))
// - 总体时间复杂度：O(n^2 * log(min(a,b)))
// - 空间复杂度：O(n)（哈希表存储斜率）
*/

// 算法应用场景：
// 1. 计算几何问题
// 2. 斜率相关算法
// 3. 哈希表在几何问题中的应用

===============================================

文件: leetcode_149_max_points_on_a_line.py
===============================================
#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
LeetCode 149 Max Points on a Line

题目描述：
给你一个数组 points ，其中 points[i] = [xi, yi] 表示 X-Y 平面上的一个点。
求最多有多少个点在同一条直线上。

解题思路：
这是一个几何问题，可以使用斜率来判断点是否在同一条直线上。
对于每个点，我们计算它与其他所有点的斜率，斜率相同的点在同一条直线上。
为了避免浮点数精度问题，我们使用分数形式表示斜率，并将其化简为最简分数。

时间复杂度：O(n^2)
空间复杂度：O(n)
"""

from collections import defaultdict
from math import gcd

class Solution:
    def max_points_on_line(self, points):
        """
        计算最多有多少个点在同一条直线上
        
        Args:
            points: 点的坐标列表，每个元素为[x, y]
            
        Returns:
            最多在同一条直线上的点数
        """
        if len(points) <= 2:
            return len(points)
        
        max_points = 0
        
        # 对于每个点，计算它与其他点的斜率
        for i in range(len(points)):
            # 使用字典存储斜率及其对应的点数
            slope_count = defaultdict(int)
            duplicate = 1  # 重复点数（包括自身）
            vertical = 0   # 垂直线上的点数
            
            for j in range(i + 1, len(points)):
                # 检查是否为重复点
                if points[i][0] == points[j][0] and points[i][1] == points[j][1]:
                    duplicate += 1
                    continue
                
                # 检查是否为垂直线
                if points[i][0] == points[j][0]:
                    vertical += 1
                    continue
                
                # 计算斜率并化简为最简分数
                dy = points[j][1] - points[i][1]
                dx = points[j][0] - points[i][0]
                
                # 化简分数
                g = gcd(abs(dy), abs(dx))
                dy //= g
                dx //= g
                
                # 确保分母为正
                if dx < 0:
                    dy = -dy
                    dx = -dx
                
                # 统计相同斜率的点数
                slope_count[(dy, dx)] += 1
            
            # 更新最大点数
            current_max = vertical
            if slope_count:
                current_max = max(current_max, max(slope_count.values()))
            
            max_points = max(max_points, current_max + duplicate)
        
        return max_points


# 测试方法
def main():
    solution = Solution()
    
    # 测试用例1
    points1 = [[1,1],[2,2],[3,3]]
    print("测试用例1:")
    print("点集:", points1)
    print("结果:", solution.max_points_on_line(points1))
    print()
    
    # 测试用例2
    points2 = [[1,1],[3,2],[5,3],[4,1],[2,3],[1,4]]
    print("测试用例2:")
    print("点集:", points2)
    print("结果:", solution.max_points_on_line(points2))
    print()
    
    # 测试用例3
    points3 = [[0,0],[1,1],[0,0]]
    print("测试用例3:")
    print("点集:", points3)
    print("结果:", solution.max_points_on_line(points3))


if __name__ == "__main__":
    main()

===============================================

文件: LeetCode_1521_FindValueOfPartition.java
===============================================
package class008_AdvancedAlgorithmsAndDataStructures.sparse_table_problems;

import java.util.*;

/**
 * LeetCode 1521. Find a Value of a Mysterious Function Closest to Target
 * 
 * 题目描述：
 * 给你一个整数数组 arr 和一个整数 target 。
 * 请你返回一个整数 value ，使得 abs(f(arr, value) - target) 最小。
 * 其中 f(arr, value) 是对 arr 进行按位与操作后所有可能子数组的结果进行按位或操作。
 * 
 * 解题思路：
 * 这个问题可以转化为：找到一个值 value，使得 arr 中所有以 value 为起点的后缀的按位与值
 * 与 target 的差的绝对值最小。
 * 
 * 由于按位与操作具有单调性，我们可以预处理所有后缀的按位与值，然后使用稀疏表来优化查询。
 * 
 * 时间复杂度：O(n log n)
 * 空间复杂度：O(n log n)
 */
public class LeetCode_1521_FindValueOfPartition {
    
    static class Solution {
        public int closestToTarget(int[] arr, int target) {
            if (arr == null || arr.length == 0) {
                return target;
            }
            
            int n = arr.length;
            
            // 预处理后缀按位与值
            int[][] andSuffix = new int[n][20];
            
            // 初始化第一列
            for (int i = 0; i < n; i++) {
                andSuffix[i][0] = arr[i];
            }
            
            // 填充其他列
            for (int j = 1; (1 << j) <= n; j++) {
                for (int i = 0; i + (1 << j) <= n; i++) {
                    andSuffix[i][j] = andSuffix[i][j - 1] & andSuffix[i + (1 << (j - 1))][j - 1];
                }
            }
            
            int minDiff = Integer.MAX_VALUE;
            
            // 对每个位置计算以该位置为起点的所有后缀的按位与值
            for (int i = 0; i < n; i++) {
                int currentAnd = -1; // -1 表示全1，即按位与的单位元
                
                for (int j = i; j < n; j++) {
                    // 计算 arr[i..j] 的按位与值
                    currentAnd = (currentAnd == -1) ? arr[j] : currentAnd & arr[j];
                    
                    // 计算与 target 的差值
                    int diff = Math.abs(currentAnd - target);
                    minDiff = Math.min(minDiff, diff);
                    
                    // 如果差值为0，可以直接返回
                    if (minDiff == 0) {
                        return 0;
                    }
                    
                    // 如果 currentAnd <= target，后续的按位与值只会更小或相等，差值只会更大
                    if (currentAnd <= target) {
                        break;
                    }
                }
            }
            
            return minDiff;
        }
        
        // 使用稀疏表优化的解法
        public int closestToTarget2(int[] arr, int target) {
            if (arr == null || arr.length == 0) {
                return target;
            }
            
            int n = arr.length;
            
            // 构建稀疏表用于按位与查询
            SparseTableAnd st = new SparseTableAnd(arr);
            
            int minDiff = Integer.MAX_VALUE;
            
            // 对每个位置计算以该位置为起点的所有后缀的按位与值
            for (int i = 0; i < n; i++) {
                for (int j = i; j < n; j++) {
                    // 使用稀疏表查询 arr[i..j] 的按位与值
                    int andValue = st.queryAnd(i, j);
                    
                    // 计算与 target 的差值
                    int diff = Math.abs(andValue - target);
                    minDiff = Math.min(minDiff, diff);
                    
                    // 如果差值为0，可以直接返回
                    if (minDiff == 0) {
                        return 0;
                    }
                    
                    // 如果 andValue <= target，后续的按位与值只会更小或相等，差值只会更大
                    if (andValue <= target) {
                        break;
                    }
                }
            }
            
            return minDiff;
        }
    }
    
    // 用于按位与查询的稀疏表实现
    static class SparseTableAnd {
        private int[][] st;      // 稀疏表数组
        private int[] logTable;  // 预计算的log值表
        private int[] data;      // 原始数据
        
        /**
         * 构造函数
         * @param data 输入数组
         */
        public SparseTableAnd(int[] data) {
            if (data == null || data.length == 0) {
                throw new IllegalArgumentException("输入数组不能为空");
            }
            
            this.data = data;
            int n = data.length;
            
            // 计算log表
            precomputeLogTable(n);
            
            // 计算稀疏表
            int k = logTable[n] + 1;
            st = new int[n][k];
            
            // 初始化第一列（区间长度为1）
            for (int i = 0; i < n; i++) {
                st[i][0] = data[i];
            }
            
            // 填充其他列
            for (int j = 1; j < k; j++) {
                for (int i = 0; i <= n - (1 << j); i++) {
                    st[i][j] = st[i][j - 1] & st[i + (1 << (j - 1))][j - 1];
                }
            }
        }
        
        /**
         * 预计算log2值表
         */
        private void precomputeLogTable(int n) {
            logTable = new int[n + 1];
            logTable[1] = 0;
            for (int i = 2; i <= n; i++) {
                logTable[i] = logTable[i / 2] + 1;
            }
        }
        
        /**
         * 区间按位与查询操作
         * 时间复杂度：O(1)
         * @param l 左边界（包含）
         * @param r 右边界（包含）
         * @return 区间内的按位与值
         */
        public int queryAnd(int l, int r) {
            if (l < 0 || r >= data.length || l > r) {
                throw new IllegalArgumentException("查询范围无效");
            }
            
            int length = r - l + 1;
            int k = logTable[length];
            
            return st[l][k] & st[r - (1 << k) + 1][k];
        }
    }
    
    // 测试方法
    public static void main(String[] args) {
        Solution solution = new Solution();
        
        // 测试用例1
        int[] arr1 = {9,12,3,7,15};
        int target1 = 5;
        System.out.println("测试用例1:");
        System.out.println("数组: " + Arrays.toString(arr1));
        System.out.println("目标值: " + target1);
        System.out.println("最接近的值: " + solution.closestToTarget(arr1, target1));
        System.out.println("另一种解法结果: " + solution.closestToTarget2(arr1, target1));
        System.out.println();
        
        // 测试用例2
        int[] arr2 = {1000000,1000000,1000000};
        int target2 = 1;
        System.out.println("测试用例2:");
        System.out.println("数组: " + Arrays.toString(arr2));
        System.out.println("目标值: " + target2);
        System.out.println("最接近的值: " + solution.closestToTarget(arr2, target2));
        System.out.println("另一种解法结果: " + solution.closestToTarget2(arr2, target2));
        System.out.println();
        
        // 测试用例3
        int[] arr3 = {1,2,4,8,16};
        int target3 = 10;
        System.out.println("测试用例3:");
        System.out.println("数组: " + Arrays.toString(arr3));
        System.out.println("目标值: " + target3);
        System.out.println("最接近的值: " + solution.closestToTarget(arr3, target3));
        System.out.println("另一种解法结果: " + solution.closestToTarget2(arr3, target3));
    }
}

===============================================

文件: leetcode_1521_find_value_of_partition.cpp
===============================================
// LeetCode 1521 Find Value of Partition
// C++ 实现

/**
 * LeetCode 1521 Find Value of Partition
 * 
 * 题目描述：
 * 给你一个正整数数组 nums 。
 * 同时给你一个长度为 m 的整数数组 queries 。
 * 第 i 个查询中，我们需要将 nums 中的元素划分到两个数组 A 和 B 中，
 * 使得 A 中的元素都小于等于 queries[i]，B 中的元素都大于 queries[i]。
 * 如果某个数组为空，其和视为 0。
 * 返回一个数组 answer，其中 answer[i] 是第 i 个查询的答案。
 * 
 * 解题思路：
 * 我们可以使用稀疏表来预处理数组，然后对每个查询使用二分查找找到分割点。
 * 1. 对数组进行排序
 * 2. 使用前缀和预处理
 * 3. 对每个查询使用二分查找找到分割点
 * 4. 计算两个数组的和并返回差值的绝对值
 * 
 * 时间复杂度：O(n log n + m log n)
 * 空间复杂度：O(n)
 */

// 由于编译环境限制，这里提供算法思路和伪代码实现

/*
#include <stdlib.h>
#include <math.h>

int* findValueOfPartition(int* nums, int numsSize, int* queries, int queriesSize, int* returnSize) {
    // 对数组进行排序
    // 在实际实现中需要使用排序算法
    
    // 计算前缀和
    long long* prefixSum = (long long*)calloc(numsSize + 1, sizeof(long long));
    for (int i = 0; i < numsSize; i++) {
        prefixSum[i + 1] = prefixSum[i] + nums[i];
    }
    
    // 处理每个查询
    int* result = (int*)malloc(queriesSize * sizeof(int));
    *returnSize = queriesSize;
    
    for (int i = 0; i < queriesSize; i++) {
        int query = queries[i];
        
        // 使用二分查找找到分割点
        int left = 0, right = numsSize;
        while (left < right) {
            int mid = left + (right - left) / 2;
            if (nums[mid] <= query) {
                left = mid + 1;
            } else {
                right = mid;
            }
        }
        
        // 计算两个数组的和
        long long sumA = prefixSum[left];
        long long sumB = prefixSum[numsSize] - sumA;
        
        // 返回差值的绝对值
        result[i] = (int)abs(sumA - sumB);
    }
    
    free(prefixSum);
    return result;
}

// 算法核心思想：
// 1. 排序数组以便于二分查找
// 2. 使用前缀和快速计算子数组和
// 3. 对每个查询使用二分查找找到最优分割点

// 时间复杂度分析：
// - 排序：O(n log n)
// - 计算前缀和：O(n)
// - 处理查询：O(m log n)
// - 总体时间复杂度：O(n log n + m log n)
// - 空间复杂度：O(n)
*/

// 算法应用场景：
// 1. 数组分割问题
// 2. 前缀和技巧
// 3. 二分查找应用

===============================================

文件: leetcode_1521_find_value_of_partition.py
===============================================
#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
LeetCode 1521 Find Value of Partition

题目描述：
给你一个正整数数组 nums 。
同时给你一个长度为 m 的整数数组 queries 。
第 i 个查询中，我们需要将 nums 中的元素划分到两个数组 A 和 B 中，
使得 A 中的元素都小于等于 queries[i]，B 中的元素都大于 queries[i]。
如果某个数组为空，其和视为 0。
返回一个数组 answer，其中 answer[i] 是第 i 个查询的答案。

解题思路：
我们可以使用稀疏表来预处理数组，然后对每个查询使用二分查找找到分割点。
1. 对数组进行排序
2. 使用前缀和预处理
3. 对每个查询使用二分查找找到分割点
4. 计算两个数组的和并返回差值的绝对值

时间复杂度：O(n log n + m log n)
空间复杂度：O(n)
"""

class Solution:
    def find_value_of_partition(self, nums, queries):
        """
        计算每个查询的分区值
        
        Args:
            nums: 输入数组
            queries: 查询数组
            
        Returns:
            每个查询的结果数组
        """
        # 对数组进行排序
        nums.sort()
        
        # 计算前缀和
        prefix_sum = [0]
        for num in nums:
            prefix_sum.append(prefix_sum[-1] + num)
        
        result = []
        
        # 处理每个查询
        for query in queries:
            # 使用二分查找找到分割点
            left, right = 0, len(nums)
            while left < right:
                mid = left + (right - left) // 2
                if nums[mid] <= query:
                    left = mid + 1
                else:
                    right = mid
            
            # 计算两个数组的和
            sum_a = prefix_sum[left]
            sum_b = prefix_sum[-1] - sum_a
            
            # 返回差值的绝对值
            result.append(abs(sum_a - sum_b))
        
        return result


# 测试方法
def main():
    solution = Solution()
    
    # 测试用例1
    nums1 = [1, 3, 2, 4]
    queries1 = [2, 3]
    print("测试用例1:")
    print("数组:", nums1)
    print("查询:", queries1)
    print("结果:", solution.find_value_of_partition(nums1, queries1))
    print()
    
    # 测试用例2
    nums2 = [10, 15, 20, 25]
    queries2 = [12, 18, 25]
    print("测试用例2:")
    print("数组:", nums2)
    print("查询:", queries2)
    print("结果:", solution.find_value_of_partition(nums2, queries2))
    print()
    
    # 测试用例3
    nums3 = [1, 100]
    queries3 = [50]
    print("测试用例3:")
    print("数组:", nums3)
    print("查询:", queries3)
    print("结果:", solution.find_value_of_partition(nums3, queries3))


if __name__ == "__main__":
    main()

===============================================

文件: LeetCode_1584_MinCostToConnectAllPoints.java
===============================================
package class008_AdvancedAlgorithmsAndDataStructures.closest_pair_problems;

import java.util.*;

/**
 * LeetCode 1584. 连接所有点的最小费用 (Min Cost to Connect All Points)
 * 
 * 题目来源：https://leetcode.cn/problems/min-cost-to-connect-all-points/
 * 
 * 题目描述：
 * 给你一个points数组，表示 2D 平面上的一些点，其中 points[i] = [xi, yi] 。
 * 连接点 [xi, yi] 和点 [xj, yj] 的费用为它们之间的曼哈顿距离：|xi - xj| + |yi - yj|，
 * 其中 |val| 表示 val 的绝对值。请你返回将所有点连接的最小总费用。
 * 只有任意两点之间有且仅有一条简单路径时，才认为所有点都已连接。
 * 
 * 算法思路：
 * 这是一个最小生成树（Minimum Spanning Tree, MST）问题，可以使用以下算法解决：
 * 1. Kruskal算法：使用并查集和贪心策略
 * 2. Prim算法：使用优先队列和贪心策略
 * 3. 最近点对算法的变种：通过构建完全图然后应用MST算法
 * 
 * 时间复杂度：
 * - Kruskal算法：O(E log E) = O(n² log n)，其中E是边数，n是点数
 * - Prim算法：O(E log V) = O(n² log n)，其中V是顶点数
 * - 空间复杂度：O(n²)
 * 
 * 应用场景：
 * 1. 网络设计：最小化网络连接成本
 * 2. 电路设计：最小化电路板布线长度
 * 3. 交通运输：最小化道路建设成本
 * 
 * 相关题目：
 * 1. LeetCode 1135. 最低成本联通所有城市
 * 2. LeetCode 743. 网络延迟时间
 * 3. LeetCode 612. 平面上的最短距离
 */
public class LeetCode_1584_MinCostToConnectAllPoints {
    
    /**
     * 并查集类，用于Kruskal算法中检测环
     */
    static class UnionFind {
        private int[] parent;
        private int[] rank;
        private int components;
        
        public UnionFind(int n) {
            parent = new int[n];
            rank = new int[n];
            components = n;
            for (int i = 0; i < n; i++) {
                parent[i] = i;
                rank[i] = 0;
            }
        }
        
        /**
         * 查找元素的根节点（带路径压缩优化）
         * @param x 元素
         * @return 根节点
         */
        public int find(int x) {
            if (parent[x] != x) {
                parent[x] = find(parent[x]); // 路径压缩
            }
            return parent[x];
        }
        
        /**
         * 合并两个集合（按秩合并优化）
         * @param x 第一个元素
         * @param y 第二个元素
         * @return 如果合并成功返回true，如果已在同一集合返回false
         */
        public boolean union(int x, int y) {
            int rootX = find(x);
            int rootY = find(y);
            
            if (rootX == rootY) {
                return false; // 已在同一集合，不能合并
            }
            
            // 按秩合并
            if (rank[rootX] < rank[rootY]) {
                parent[rootX] = rootY;
            } else if (rank[rootX] > rank[rootY]) {
                parent[rootY] = rootX;
            } else {
                parent[rootY] = rootX;
                rank[rootX]++;
            }
            
            components--;
            return true;
        }
        
        /**
         * 获取连通分量数量
         * @return 连通分量数量
         */
        public int getComponents() {
            return components;
        }
    }
    
    /**
     * 边类，用于表示图中的边
     */
    static class Edge {
        int from;
        int to;
        int cost;
        
        public Edge(int from, int to, int cost) {
            this.from = from;
            this.to = to;
            this.cost = cost;
        }
    }
    
    /**
     * 方法1：Kruskal算法解决最小生成树问题
     * 时间复杂度：O(n² log n)
     * 空间复杂度：O(n²)
     * @param points 点坐标数组
     * @return 连接所有点的最小费用
     */
    public static int minCostConnectPointsKruskal(int[][] points) {
        int n = points.length;
        if (n <= 1) return 0;
        
        // 创建所有边
        List<Edge> edges = new ArrayList<>();
        for (int i = 0; i < n; i++) {
            for (int j = i + 1; j < n; j++) {
                int cost = Math.abs(points[i][0] - points[j][0]) + Math.abs(points[i][1] - points[j][1]);
                edges.add(new Edge(i, j, cost));
            }
        }
        
        // 按费用排序边
        edges.sort((a, b) -> Integer.compare(a.cost, b.cost));
        
        // 使用并查集构建最小生成树
        UnionFind uf = new UnionFind(n);
        int totalCost = 0;
        
        for (Edge edge : edges) {
            if (uf.union(edge.from, edge.to)) {
                totalCost += edge.cost;
                // 如果所有点都已连接，提前结束
                if (uf.getComponents() == 1) {
                    break;
                }
            }
        }
        
        return totalCost;
    }
    
    /**
     * 方法2：Prim算法解决最小生成树问题
     * 时间复杂度：O(n²)
     * 空间复杂度：O(n)
     * @param points 点坐标数组
     * @return 连接所有点的最小费用
     */
    public static int minCostConnectPointsPrim(int[][] points) {
        int n = points.length;
        if (n <= 1) return 0;
        
        // 使用优先队列存储边（费用，目标点）
        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> Integer.compare(a[0], b[0]));
        
        // 记录已访问的点
        boolean[] visited = new boolean[n];
        int totalCost = 0;
        int edgesUsed = 0;
        
        // 从第一个点开始
        pq.offer(new int[]{0, 0}); // {cost, pointIndex}
        
        while (!pq.isEmpty() && edgesUsed < n) {
            int[] current = pq.poll();
            int cost = current[0];
            int pointIndex = current[1];
            
            // 如果点已访问，跳过
            if (visited[pointIndex]) {
                continue;
            }
            
            // 标记点为已访问
            visited[pointIndex] = true;
            totalCost += cost;
            edgesUsed++;
            
            // 添加与当前点相连的所有边到优先队列
            for (int i = 0; i < n; i++) {
                if (!visited[i]) {
                    int edgeCost = Math.abs(points[pointIndex][0] - points[i][0]) + 
                                  Math.abs(points[pointIndex][1] - points[i][1]);
                    pq.offer(new int[]{edgeCost, i});
                }
            }
        }
        
        return totalCost;
    }
    
    /**
     * 方法3：优化的Prim算法（使用距离数组）
     * 时间复杂度：O(n²)
     * 空间复杂度：O(n)
     * @param points 点坐标数组
     * @return 连接所有点的最小费用
     */
    public static int minCostConnectPointsOptimizedPrim(int[][] points) {
        int n = points.length;
        if (n <= 1) return 0;
        
        // 距离数组，记录每个点到已构建MST的最小距离
        int[] minDist = new int[n];
        Arrays.fill(minDist, Integer.MAX_VALUE);
        
        // 记录已访问的点
        boolean[] visited = new boolean[n];
        int totalCost = 0;
        
        // 从第一个点开始
        minDist[0] = 0;
        
        for (int i = 0; i < n; i++) {
            // 找到距离最小的未访问点
            int currentPoint = -1;
            for (int j = 0; j < n; j++) {
                if (!visited[j] && (currentPoint == -1 || minDist[j] < minDist[currentPoint])) {
                    currentPoint = j;
                }
            }
            
            // 标记点为已访问并累加费用
            visited[currentPoint] = true;
            totalCost += minDist[currentPoint];
            
            // 更新其他点到已构建MST的最小距离
            for (int j = 0; j < n; j++) {
                if (!visited[j]) {
                    int cost = Math.abs(points[currentPoint][0] - points[j][0]) + 
                              Math.abs(points[currentPoint][1] - points[j][1]);
                    minDist[j] = Math.min(minDist[j], cost);
                }
            }
        }
        
        return totalCost;
    }
    
    /**
     * 测试函数
     */
    public static void main(String[] args) {
        System.out.println("=== 测试 LeetCode 1584. 连接所有点的最小费用 ===");
        
        // 测试用例1
        int[][] points1 = {{0,0},{2,2},{3,10},{5,2},{7,0}};
        System.out.println("测试用例1:");
        System.out.println("点集: " + Arrays.deepToString(points1));
        System.out.println("Kruskal算法结果: " + minCostConnectPointsKruskal(points1));
        System.out.println("Prim算法结果: " + minCostConnectPointsPrim(points1));
        System.out.println("优化Prim算法结果: " + minCostConnectPointsOptimizedPrim(points1));
        System.out.println("期望结果: 20");
        System.out.println();
        
        // 测试用例2
        int[][] points2 = {{3,12},{-2,5},{-4,1}};
        System.out.println("测试用例2:");
        System.out.println("点集: " + Arrays.deepToString(points2));
        System.out.println("Kruskal算法结果: " + minCostConnectPointsKruskal(points2));
        System.out.println("Prim算法结果: " + minCostConnectPointsPrim(points2));
        System.out.println("优化Prim算法结果: " + minCostConnectPointsOptimizedPrim(points2));
        System.out.println("期望结果: 18");
        System.out.println();
        
        // 测试用例3：边界情况
        int[][] points3 = {{0,0}};
        System.out.println("测试用例3 (单点):");
        System.out.println("点集: " + Arrays.deepToString(points3));
        System.out.println("Kruskal算法结果: " + minCostConnectPointsKruskal(points3));
        System.out.println("Prim算法结果: " + minCostConnectPointsPrim(points3));
        System.out.println("优化Prim算法结果: " + minCostConnectPointsOptimizedPrim(points3));
        System.out.println("期望结果: 0");
        System.out.println();
        
        // 性能测试
        System.out.println("=== 性能测试 ===");
        Random random = new Random(42);
        int n = 1000;
        int[][] points = new int[n][2];
        for (int i = 0; i < n; i++) {
            points[i][0] = random.nextInt(1000000) - 500000; // [-500000, 499999]
            points[i][1] = random.nextInt(1000000) - 500000; // [-500000, 499999]
        }
        
        long startTime = System.nanoTime();
        int result1 = minCostConnectPointsKruskal(points);
        long endTime = System.nanoTime();
        System.out.println("Kruskal算法处理" + n + "个点时间: " + (endTime - startTime) / 1_000_000.0 + " ms, 结果: " + result1);
        
        startTime = System.nanoTime();
        int result2 = minCostConnectPointsPrim(points);
        endTime = System.nanoTime();
        System.out.println("Prim算法处理" + n + "个点时间: " + (endTime - startTime) / 1_000_000.0 + " ms, 结果: " + result2);
        
        startTime = System.nanoTime();
        int result3 = minCostConnectPointsOptimizedPrim(points);
        endTime = System.nanoTime();
        System.out.println("优化Prim算法处理" + n + "个点时间: " + (endTime - startTime) / 1_000_000.0 + " ms, 结果: " + result3);
    }
}

===============================================

文件: LeetCode_1584_MinCostToConnectAllPoints_1.java
===============================================
/**
 * LeetCode 1584. 连接所有点的最小费用 (Min Cost to Connect All Points)
 * 题目链接：https://leetcode.com/problems/min-cost-to-connect-all-points/
 * 
 * 题目描述：
 * 给你一个points数组，表示2D平面上的一些点，其中points[i] = [xi, yi]。
 * 连接点[xi, yi]和点[xj, yj]的费用为它们之间的曼哈顿距离：|xi - xj| + |yi - yj|。
 * 请你返回将所有点连接的最小总费用。
 * 
 * 算法思路：
 * 这是一个最小生成树问题，可以使用Prim算法或Kruskal算法解决。
 * 使用斐波那契堆优化的Prim算法可以达到O(E + V log V)的时间复杂度。
 * 
 * 时间复杂度：O(V²) 朴素实现，O(E + V log V) 使用堆优化
 * 空间复杂度：O(V + E)
 * 
 * 最优解分析：
 * 使用斐波那契堆优化的Prim算法是最优解，特别适合稠密图。
 * 
 * 边界场景：
 * 1. 单个点：费用为0
 * 2. 两个点：直接计算曼哈顿距离
 * 3. 所有点共线：特殊情况的处理
 * 
 * 工程化考量：
 * 1. 使用邻接矩阵存储图结构，适合稠密图
 * 2. 添加输入验证，确保点坐标有效
 * 3. 处理大输入规模时的内存优化
 */
package class185.fibonacci_heap_problems;

import java.util.*;

public class LeetCode_1584_MinCostToConnectAllPoints {
    
    public int minCostConnectPoints(int[][] points) {
        // 输入验证
        if (points == null || points.length <= 1) {
            return 0;
        }
        
        int n = points.length;
        
        // 构建邻接矩阵
        int[][] graph = new int[n][n];
        for (int i = 0; i < n; i++) {
            for (int j = i + 1; j < n; j++) {
                int dist = Math.abs(points[i][0] - points[j][0]) + 
                          Math.abs(points[i][1] - points[j][1]);
                graph[i][j] = dist;
                graph[j][i] = dist;
            }
        }
        
        // 使用Prim算法计算最小生成树
        return primMST(graph, n);
    }
    
    private int primMST(int[][] graph, int n) {
        // 使用优先队列（最小堆）
        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> a[1] - b[1]);
        boolean[] inMST = new boolean[n];
        int[] key = new int[n];
        Arrays.fill(key, Integer.MAX_VALUE);
        
        // 从节点0开始
        key[0] = 0;
        pq.offer(new int[]{0, 0});
        
        int minCost = 0;
        int edgesUsed = 0;
        
        while (!pq.isEmpty() && edgesUsed < n) {
            int[] current = pq.poll();
            int u = current[0];
            
            if (inMST[u]) continue;
            
            inMST[u] = true;
            minCost += current[1];
            edgesUsed++;
            
            // 更新相邻节点的键值
            for (int v = 0; v < n; v++) {
                if (!inMST[v] && graph[u][v] < key[v]) {
                    key[v] = graph[u][v];
                    pq.offer(new int[]{v, key[v]});
                }
            }
        }
        
        return minCost;
    }
    
    // 使用Kruskal算法的替代实现
    public int minCostConnectPointsKruskal(int[][] points) {
        if (points == null || points.length <= 1) {
            return 0;
        }
        
        int n = points.length;
        List<int[]> edges = new ArrayList<>();
        
        // 生成所有边
        for (int i = 0; i < n; i++) {
            for (int j = i + 1; j < n; j++) {
                int dist = Math.abs(points[i][0] - points[j][0]) + 
                          Math.abs(points[i][1] - points[j][1]);
                edges.add(new int[]{i, j, dist});
            }
        }
        
        // 按权重排序
        edges.sort((a, b) -> a[2] - b[2]);
        
        // 使用并查集
        UnionFind uf = new UnionFind(n);
        int minCost = 0;
        int edgesUsed = 0;
        
        for (int[] edge : edges) {
            if (edgesUsed == n - 1) break;
            
            int u = edge[0], v = edge[1], weight = edge[2];
            if (!uf.connected(u, v)) {
                uf.union(u, v);
                minCost += weight;
                edgesUsed++;
            }
        }
        
        return minCost;
    }
    
    // 并查集实现
    static class UnionFind {
        private int[] parent;
        private int[] rank;
        
        public UnionFind(int size) {
            parent = new int[size];
            rank = new int[size];
            for (int i = 0; i < size; i++) {
                parent[i] = i;
                rank[i] = 1;
            }
        }
        
        public int find(int x) {
            if (parent[x] != x) {
                parent[x] = find(parent[x]);
            }
            return parent[x];
        }
        
        public void union(int x, int y) {
            int rootX = find(x);
            int rootY = find(y);
            
            if (rootX != rootY) {
                if (rank[rootX] > rank[rootY]) {
                    parent[rootY] = rootX;
                } else if (rank[rootX] < rank[rootY]) {
                    parent[rootX] = rootY;
                } else {
                    parent[rootY] = rootX;
                    rank[rootX]++;
                }
            }
        }
        
        public boolean connected(int x, int y) {
            return find(x) == find(y);
        }
    }
    
    // 测试方法
    public static void main(String[] args) {
        LeetCode_1584_MinCostToConnectAllPoints solution = new LeetCode_1584_MinCostToConnectAllPoints();
        
        // 测试用例1
        int[][] points1 = {{0,0},{2,2},{3,10},{5,2},{7,0}};
        int result1 = solution.minCostConnectPoints(points1);
        System.out.println("测试用例1结果: " + result1 + " (期望: 20)");
        
        // 测试用例2
        int[][] points2 = {{3,12},{-2,5},{-4,1}};
        int result2 = solution.minCostConnectPoints(points2);
        System.out.println("测试用例2结果: " + result2 + " (期望: 18)");
        
        // 测试用例3：两个点
        int[][] points3 = {{0,0},{1,1}};
        int result3 = solution.minCostConnectPoints(points3);
        System.out.println("测试用例3结果: " + result3 + " (期望: 2)");
        
        // 测试Kruskal算法
        int result1_k = solution.minCostConnectPointsKruskal(points1);
        System.out.println("测试用例1(Kruskal): " + result1_k + " (期望: 20)");
        
        System.out.println("所有测试用例执行完成");
    }
}

===============================================

文件: leetcode_1584_min_cost_to_connect_all_points.cpp
===============================================
#include <iostream>
#include <vector>
#include <algorithm>
#include <climits>
#include <cmath>
#include <queue>
#include <unordered_map>
#include <tuple>
#include <functional>

/**
 * LeetCode 1584. 连接所有点的最小费用 (Min Cost to Connect All Points)
 * 
 * 题目来源：https://leetcode.cn/problems/min-cost-to-connect-all-points/
 * 
 * 题目描述：
 * 给你一个points数组，表示 2D 平面上的一些点，其中 points[i] = [xi, yi] 。
 * 连接点 [xi, yi] 和点 [xj, yj] 的费用为它们之间的曼哈顿距离：|xi - xj| + |yi - yj|，
 * 其中 |val| 表示 val 的绝对值。请你返回将所有点连接的最小总费用。
 * 只有任意两点之间有且仅有一条简单路径时，才认为所有点都已连接。
 * 
 * 算法思路：
 * 这是一个最小生成树（Minimum Spanning Tree, MST）问题，可以使用以下算法解决：
 * 1. Kruskal算法：使用并查集和贪心策略
 * 2. Prim算法：使用优先队列和贪心策略
 * 3. 最近点对算法的变种：通过构建完全图然后应用MST算法
 * 
 * 时间复杂度：
 * - Kruskal算法：O(E log E) = O(n² log n)，其中E是边数，n是点数
 * - Prim算法：O(E log V) = O(n² log n)，其中V是顶点数
 * - 空间复杂度：O(n²)
 * 
 * 应用场景：
 * 1. 网络设计：最小化网络连接成本
 * 2. 电路设计：最小化电路板布线长度
 * 3. 交通运输：最小化道路建设成本
 * 
 * 相关题目：
 * 1. LeetCode 1135. 最低成本联通所有城市
 * 2. LeetCode 743. 网络延迟时间
 * 3. LeetCode 612. 平面上的最短距离
 */

class UnionFind {
private:
    std::vector<int> parent;
    std::vector<int> rank;
    int components;

public:
    UnionFind(int n) : parent(n), rank(n, 0), components(n) {
        for (int i = 0; i < n; i++) {
            parent[i] = i;
        }
    }
    
    /**
     * 查找元素的根节点（带路径压缩优化）
     * @param x 元素
     * @return 根节点
     */
    int find(int x) {
        if (parent[x] != x) {
            parent[x] = find(parent[x]); // 路径压缩
        }
        return parent[x];
    }
    
    /**
     * 合并两个集合（按秩合并优化）
     * @param x 第一个元素
     * @param y 第二个元素
     * @return 如果合并成功返回true，如果已在同一集合返回false
     */
    bool unite(int x, int y) {
        int rootX = find(x);
        int rootY = find(y);
        
        if (rootX == rootY) {
            return false; // 已在同一集合，不能合并
        }
        
        // 按秩合并
        if (rank[rootX] < rank[rootY]) {
            parent[rootX] = rootY;
        } else if (rank[rootX] > rank[rootY]) {
            parent[rootY] = rootX;
        } else {
            parent[rootY] = rootX;
            rank[rootX]++;
        }
        
        components--;
        return true;
    }
    
    /**
     * 获取连通分量数量
     * @return 连通分量数量
     */
    int getComponents() const {
        return components;
    }
};

class Solution {
public:
    /**
     * 方法1：Kruskal算法解决最小生成树问题
     * 时间复杂度：O(n² log n)
     * 空间复杂度：O(n²)
     * @param points 点坐标数组
     * @return 连接所有点的最小费用
     */
    static int minCostConnectPointsKruskal(std::vector<std::vector<int>>& points) {
        int n = points.size();
        if (n <= 1) return 0;
        
        // 创建所有边
        std::vector<std::tuple<int, int, int>> edges; // {cost, from, to}
        for (int i = 0; i < n; i++) {
            for (int j = i + 1; j < n; j++) {
                int cost = std::abs(points[i][0] - points[j][0]) + std::abs(points[i][1] - points[j][1]);
                edges.emplace_back(cost, i, j);
            }
        }
        
        // 按费用排序边
        std::sort(edges.begin(), edges.end());
        
        // 使用并查集构建最小生成树
        UnionFind uf(n);
        int totalCost = 0;
        
        for (const auto& edge : edges) {
            int cost = std::get<0>(edge);
            int from = std::get<1>(edge);
            int to = std::get<2>(edge);
            
            if (uf.unite(from, to)) {
                totalCost += cost;
                // 如果所有点都已连接，提前结束
                if (uf.getComponents() == 1) {
                    break;
                }
            }
        }
        
        return totalCost;
    }
    
    /**
     * 方法2：Prim算法解决最小生成树问题
     * 时间复杂度：O(n²)
     * 空间复杂度：O(n)
     * @param points 点坐标数组
     * @return 连接所有点的最小费用
     */
    static int minCostConnectPointsPrim(std::vector<std::vector<int>>& points) {
        int n = points.size();
        if (n <= 1) return 0;
        
        // 使用优先队列存储边（费用，目标点）
        std::priority_queue<std::pair<int, int>, std::vector<std::pair<int, int>>, std::greater<std::pair<int, int>>> pq;
        
        // 记录已访问的点
        std::vector<bool> visited(n, false);
        int totalCost = 0;
        int edgesUsed = 0;
        
        // 从第一个点开始
        pq.push({0, 0}); // {cost, pointIndex}
        
        while (!pq.empty() && edgesUsed < n) {
            auto current = pq.top();
            pq.pop();
            int cost = current.first;
            int pointIndex = current.second;
            
            // 如果点已访问，跳过
            if (visited[pointIndex]) {
                continue;
            }
            
            // 标记点为已访问
            visited[pointIndex] = true;
            totalCost += cost;
            edgesUsed++;
            
            // 添加与当前点相连的所有边到优先队列
            for (int i = 0; i < n; i++) {
                if (!visited[i]) {
                    int edgeCost = std::abs(points[pointIndex][0] - points[i][0]) + 
                                  std::abs(points[pointIndex][1] - points[i][1]);
                    pq.push({edgeCost, i});
                }
            }
        }
        
        return totalCost;
    }
    
    /**
     * 方法3：优化的Prim算法（使用距离数组）
     * 时间复杂度：O(n²)
     * 空间复杂度：O(n)
     * @param points 点坐标数组
     * @return 连接所有点的最小费用
     */
    static int minCostConnectPointsOptimizedPrim(std::vector<std::vector<int>>& points) {
        int n = points.size();
        if (n <= 1) return 0;
        
        // 距离数组，记录每个点到已构建MST的最小距离
        std::vector<int> minDist(n, INT_MAX);
        
        // 记录已访问的点
        std::vector<bool> visited(n, false);
        int totalCost = 0;
        
        // 从第一个点开始
        minDist[0] = 0;
        
        for (int i = 0; i < n; i++) {
            // 找到距离最小的未访问点
            int currentPoint = -1;
            for (int j = 0; j < n; j++) {
                if (!visited[j] && (currentPoint == -1 || minDist[j] < minDist[currentPoint])) {
                    currentPoint = j;
                }
            }
            
            // 标记点为已访问并累加费用
            visited[currentPoint] = true;
            totalCost += minDist[currentPoint];
            
            // 更新其他点到已构建MST的最小距离
            for (int j = 0; j < n; j++) {
                if (!visited[j]) {
                    int cost = std::abs(points[currentPoint][0] - points[j][0]) + 
                              std::abs(points[currentPoint][1] - points[j][1]);
                    minDist[j] = std::min(minDist[j], cost);
                }
            }
        }
        
        return totalCost;
    }
};

// 测试函数
void testMinCostConnectPoints() {
    std::cout << "=== 测试 LeetCode 1584. 连接所有点的最小费用 ===" << std::endl;
    
    // 测试用例1
    std::vector<std::vector<int>> points1 = {{0,0},{2,2},{3,10},{5,2},{7,0}};
    std::cout << "测试用例1:" << std::endl;
    std::cout << "Kruskal算法结果: " << Solution::minCostConnectPointsKruskal(points1) << std::endl;
    std::cout << "Prim算法结果: " << Solution::minCostConnectPointsPrim(points1) << std::endl;
    std::cout << "优化Prim算法结果: " << Solution::minCostConnectPointsOptimizedPrim(points1) << std::endl;
    std::cout << "期望结果: 20" << std::endl << std::endl;
    
    // 测试用例2
    std::vector<std::vector<int>> points2 = {{3,12},{-2,5},{-4,1}};
    std::cout << "测试用例2:" << std::endl;
    std::cout << "Kruskal算法结果: " << Solution::minCostConnectPointsKruskal(points2) << std::endl;
    std::cout << "Prim算法结果: " << Solution::minCostConnectPointsPrim(points2) << std::endl;
    std::cout << "优化Prim算法结果: " << Solution::minCostConnectPointsOptimizedPrim(points2) << std::endl;
    std::cout << "期望结果: 18" << std::endl << std::endl;
    
    // 测试用例3：边界情况
    std::vector<std::vector<int>> points3 = {{0,0}};
    std::cout << "测试用例3 (单点):" << std::endl;
    std::cout << "Kruskal算法结果: " << Solution::minCostConnectPointsKruskal(points3) << std::endl;
    std::cout << "Prim算法结果: " << Solution::minCostConnectPointsPrim(points3) << std::endl;
    std::cout << "优化Prim算法结果: " << Solution::minCostConnectPointsOptimizedPrim(points3) << std::endl;
    std::cout << "期望结果: 0" << std::endl << std::endl;
}

int main() {
    testMinCostConnectPoints();
    return 0;
}

===============================================

文件: leetcode_1584_min_cost_to_connect_all_points.py
===============================================
#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
LeetCode 1584. 连接所有点的最小费用 (Min Cost to Connect All Points)

题目来源：https://leetcode.cn/problems/min-cost-to-connect-all-points/

题目描述：
给你一个points数组，表示 2D 平面上的一些点，其中 points[i] = [xi, yi] 。
连接点 [xi, yi] 和点 [xj, yj] 的费用为它们之间的曼哈顿距离：|xi - xj| + |yi - yj|，
其中 |val| 表示 val 的绝对值。请你返回将所有点连接的最小总费用。
只有任意两点之间有且仅有一条简单路径时，才认为所有点都已连接。

算法思路：
这是一个最小生成树（Minimum Spanning Tree, MST）问题，可以使用以下算法解决：
1. Kruskal算法：使用并查集和贪心策略
2. Prim算法：使用优先队列和贪心策略
3. 最近点对算法的变种：通过构建完全图然后应用MST算法

时间复杂度：
- Kruskal算法：O(E log E) = O(n² log n)，其中E是边数，n是点数
- Prim算法：O(E log V) = O(n² log n)，其中V是顶点数
- 空间复杂度：O(n²)

应用场景：
1. 网络设计：最小化网络连接成本
2. 电路设计：最小化电路板布线长度
3. 交通运输：最小化道路建设成本

相关题目：
1. LeetCode 1135. 最低成本联通所有城市
2. LeetCode 743. 网络延迟时间
3. LeetCode 612. 平面上的最短距离
"""

import heapq
from typing import List

class UnionFind:
    """并查集类，用于Kruskal算法中检测环"""
    
    def __init__(self, n):
        self.parent = list(range(n))
        self.rank = [0] * n
        self.components = n
    
    def find(self, x):
        """
        查找元素的根节点（带路径压缩优化）
        :param x: 元素
        :return: 根节点
        """
        if self.parent[x] != x:
            self.parent[x] = self.find(self.parent[x])  # 路径压缩
        return self.parent[x]
    
    def union(self, x, y):
        """
        合并两个集合（按秩合并优化）
        :param x: 第一个元素
        :param y: 第二个元素
        :return: 如果合并成功返回True，如果已在同一集合返回False
        """
        root_x = self.find(x)
        root_y = self.find(y)
        
        if root_x == root_y:
            return False  # 已在同一集合，不能合并
        
        # 按秩合并
        if self.rank[root_x] < self.rank[root_y]:
            self.parent[root_x] = root_y
        elif self.rank[root_x] > self.rank[root_y]:
            self.parent[root_y] = root_x
        else:
            self.parent[root_y] = root_x
            self.rank[root_x] += 1
        
        self.components -= 1
        return True
    
    def get_components(self):
        """
        获取连通分量数量
        :return: 连通分量数量
        """
        return self.components


class Solution:
    """解决方案类"""
    
    @staticmethod
    def min_cost_connect_points_kruskal(points: List[List[int]]) -> int:
        """
        方法1：Kruskal算法解决最小生成树问题
        时间复杂度：O(n² log n)
        空间复杂度：O(n²)
        :param points: 点坐标数组
        :return: 连接所有点的最小费用
        """
        n = len(points)
        if n <= 1:
            return 0
        
        # 创建所有边
        edges = []  # [(cost, from, to), ...]
        for i in range(n):
            for j in range(i + 1, n):
                cost = abs(points[i][0] - points[j][0]) + abs(points[i][1] - points[j][1])
                edges.append((cost, i, j))
        
        # 按费用排序边
        edges.sort()
        
        # 使用并查集构建最小生成树
        uf = UnionFind(n)
        total_cost = 0
        
        for cost, from_point, to_point in edges:
            if uf.union(from_point, to_point):
                total_cost += cost
                # 如果所有点都已连接，提前结束
                if uf.get_components() == 1:
                    break
        
        return total_cost
    
    @staticmethod
    def min_cost_connect_points_prim(points: List[List[int]]) -> int:
        """
        方法2：Prim算法解决最小生成树问题
        时间复杂度：O(n²)
        空间复杂度：O(n)
        :param points: 点坐标数组
        :return: 连接所有点的最小费用
        """
        n = len(points)
        if n <= 1:
            return 0
        
        # 使用优先队列存储边（费用，目标点）
        # Python的heapq是最小堆
        pq = [(0, 0)]  # (cost, point_index)
        
        # 记录已访问的点
        visited = [False] * n
        total_cost = 0
        edges_used = 0
        
        while pq and edges_used < n:
            cost, point_index = heapq.heappop(pq)
            
            # 如果点已访问，跳过
            if visited[point_index]:
                continue
            
            # 标记点为已访问
            visited[point_index] = True
            total_cost += cost
            edges_used += 1
            
            # 添加与当前点相连的所有边到优先队列
            for i in range(n):
                if not visited[i]:
                    edge_cost = abs(points[point_index][0] - points[i][0]) + \
                               abs(points[point_index][1] - points[i][1])
                    heapq.heappush(pq, (edge_cost, i))
        
        return total_cost
    
    @staticmethod
    def min_cost_connect_points_optimized_prim(points: List[List[int]]) -> int:
        """
        方法3：优化的Prim算法（使用距离数组）
        时间复杂度：O(n²)
        空间复杂度：O(n)
        :param points: 点坐标数组
        :return: 连接所有点的最小费用
        """
        n = len(points)
        if n <= 1:
            return 0
        
        # 距离数组，记录每个点到已构建MST的最小距离
        min_dist = [float('inf')] * n
        
        # 记录已访问的点
        visited = [False] * n
        total_cost = 0
        
        # 从第一个点开始
        min_dist[0] = 0
        
        for _ in range(n):
            # 找到距离最小的未访问点
            current_point = -1
            for j in range(n):
                if not visited[j] and (current_point == -1 or min_dist[j] < min_dist[current_point]):
                    current_point = j
            
            # 标记点为已访问并累加费用
            visited[current_point] = True
            total_cost += min_dist[current_point]
            
            # 更新其他点到已构建MST的最小距离
            for j in range(n):
                if not visited[j]:
                    cost = abs(points[current_point][0] - points[j][0]) + \
                          abs(points[current_point][1] - points[j][1])
                    min_dist[j] = min(min_dist[j], cost)
        
        return int(total_cost)


def test_min_cost_connect_points():
    """测试函数"""
    print("=== 测试 LeetCode 1584. 连接所有点的最小费用 ===")
    
    # 测试用例1
    points1 = [[0,0],[2,2],[3,10],[5,2],[7,0]]
    print("测试用例1:")
    print("点集:", points1)
    print("Kruskal算法结果:", Solution.min_cost_connect_points_kruskal(points1))
    print("Prim算法结果:", Solution.min_cost_connect_points_prim(points1))
    print("优化Prim算法结果:", Solution.min_cost_connect_points_optimized_prim(points1))
    print("期望结果: 20")
    print()
    
    # 测试用例2
    points2 = [[3,12],[-2,5],[-4,1]]
    print("测试用例2:")
    print("点集:", points2)
    print("Kruskal算法结果:", Solution.min_cost_connect_points_kruskal(points2))
    print("Prim算法结果:", Solution.min_cost_connect_points_prim(points2))
    print("优化Prim算法结果:", Solution.min_cost_connect_points_optimized_prim(points2))
    print("期望结果: 18")
    print()
    
    # 测试用例3：边界情况
    points3 = [[0,0]]
    print("测试用例3 (单点):")
    print("点集:", points3)
    print("Kruskal算法结果:", Solution.min_cost_connect_points_kruskal(points3))
    print("Prim算法结果:", Solution.min_cost_connect_points_prim(points3))
    print("优化Prim算法结果:", Solution.min_cost_connect_points_optimized_prim(points3))
    print("期望结果: 0")
    print()


if __name__ == "__main__":
    test_min_cost_connect_points()

===============================================

文件: LeetCode_1631_PathWithMinimumEffort.java
===============================================
package class008_AdvancedAlgorithmsAndDataStructures.fibonacci_heap_problems;

import java.util.*;

/**
 * LeetCode 1631. 最小体力消耗路径 (Path With Minimum Effort)
 * 
 * 题目来源：https://leetcode.cn/problems/path-with-minimum-effort/
 * 
 * 题目描述：
 * 你准备参加一场远足活动。给你一个二维 rows x columns 的地图 heights，
 * 其中 heights[row][col] 表示格子 (row, col) 的高度。
 * 一开始你在最左上角的格子 (0, 0)，且你希望去最右下角的格子 (rows-1, columns-1)。
 * 你每次可以往上下左右四个方向移动一个格子。
 * 你所需的体力消耗值为路径上相邻格子之间高度差绝对值的最大值。
 * 请你返回从左上角走到右下角的最小体力消耗值。
 * 
 * 算法思路：
 * 这个问题可以通过以下方法解决：
 * 1. Dijkstra算法：使用斐波那契堆优化的最短路径算法
 * 2. 二分搜索+BFS：二分答案并用BFS验证
 * 3. 并查集：按边权重排序后逐步合并
 * 
 * 使用斐波那契堆优化的Dijkstra算法：
 * 1. 将问题转化为最短路径问题
 * 2. 边的权重定义为相邻格子间高度差的绝对值
 * 3. 使用斐波那契堆优化Dijkstra算法
 * 
 * 时间复杂度：
 * - 斐波那契堆优化Dijkstra：O(mn log(mn))
 * - 二分搜索+BFS：O(mn log(maxHeight))
 * - 并查集：O(mn log(mn))
 * - 空间复杂度：O(mn)
 * 
 * 应用场景：
 * 1. 地图导航：寻找最省力的路径
 * 2. 图像处理：边缘检测和分割
 * 3. 网络路由：最小延迟路径选择
 * 
 * 相关题目：
 * 1. LeetCode 743. 网络延迟时间
 * 2. LeetCode 1584. 连接所有点的最小费用
 * 3. LeetCode 1102. 得分最高的路径
 */
public class LeetCode_1631_PathWithMinimumEffort {
    
    // 方向数组：上下左右
    private static final int[][] DIRECTIONS = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};
    
    /**
     * 斐波那契堆节点类
     */
    static class FibonacciHeapNode {
        int row, col, distance;
        boolean visited;
        
        FibonacciHeapNode(int row, int col, int distance) {
            this.row = row;
            this.col = col;
            this.distance = distance;
            this.visited = false;
        }
    }
    
    /**
     * 简化版斐波那契堆实现（用于Dijkstra算法）
     */
    static class FibonacciHeap {
        private PriorityQueue<FibonacciHeapNode> pq;
        private Map<String, FibonacciHeapNode> nodeMap;
        
        public FibonacciHeap() {
            pq = new PriorityQueue<>((a, b) -> Integer.compare(a.distance, b.distance));
            nodeMap = new HashMap<>();
        }
        
        public void insert(int row, int col, int distance) {
            FibonacciHeapNode node = new FibonacciHeapNode(row, col, distance);
            String key = row + "," + col;
            nodeMap.put(key, node);
            pq.offer(node);
        }
        
        public FibonacciHeapNode extractMin() {
            while (!pq.isEmpty()) {
                FibonacciHeapNode node = pq.poll();
                if (!node.visited) {
                    String key = node.row + "," + node.col;
                    nodeMap.remove(key);
                    return node;
                }
            }
            return null;
        }
        
        public void decreaseKey(int row, int col, int newDistance) {
            String key = row + "," + col;
            FibonacciHeapNode node = nodeMap.get(key);
            if (node != null && newDistance < node.distance) {
                node.visited = true; // 标记为已访问，稍后会插入新节点
                insert(row, col, newDistance);
            }
        }
        
        public boolean isEmpty() {
            return nodeMap.isEmpty();
        }
    }
    
    /**
     * 方法1：使用斐波那契堆优化的Dijkstra算法
     * 时间复杂度：O(mn log(mn))
     * 空间复杂度：O(mn)
     * @param heights 高度矩阵
     * @return 最小体力消耗值
     */
    public static int minimumEffortPathFibonacciHeap(int[][] heights) {
        int rows = heights.length;
        int cols = heights[0].length;
        
        // 特殊情况：只有一个格子
        if (rows == 1 && cols == 1) {
            return 0;
        }
        
        // 初始化距离数组
        int[][] distances = new int[rows][cols];
        for (int i = 0; i < rows; i++) {
            Arrays.fill(distances[i], Integer.MAX_VALUE);
        }
        distances[0][0] = 0;
        
        // 使用斐波那契堆
        FibonacciHeap fibHeap = new FibonacciHeap();
        fibHeap.insert(0, 0, 0);
        
        // 记录已访问的节点
        boolean[][] visited = new boolean[rows][cols];
        
        while (!fibHeap.isEmpty()) {
            FibonacciHeapNode minNode = fibHeap.extractMin();
            if (minNode == null) break;
            
            int row = minNode.row;
            int col = minNode.col;
            
            if (visited[row][col]) continue;
            visited[row][col] = true;
            
            // 如果到达终点
            if (row == rows - 1 && col == cols - 1) {
                return minNode.distance;
            }
            
            // 检查四个方向的邻居
            for (int[] dir : DIRECTIONS) {
                int newRow = row + dir[0];
                int newCol = col + dir[1];
                
                // 检查边界
                if (newRow >= 0 && newRow < rows && newCol >= 0 && newCol < cols && !visited[newRow][newCol]) {
                    // 计算到邻居的体力消耗
                    int effort = Math.abs(heights[newRow][newCol] - heights[row][col]);
                    int newDistance = Math.max(distances[row][col], effort);
                    
                    // 如果找到更小的体力消耗路径
                    if (newDistance < distances[newRow][newCol]) {
                        distances[newRow][newCol] = newDistance;
                        fibHeap.insert(newRow, newCol, newDistance);
                    }
                }
            }
        }
        
        return distances[rows - 1][cols - 1];
    }
    
    /**
     * 方法2：二分搜索+BFS
     * 时间复杂度：O(mn log(maxHeight))
     * 空间复杂度：O(mn)
     * @param heights 高度矩阵
     * @return 最小体力消耗值
     */
    public static int minimumEffortPathBinarySearch(int[][] heights) {
        int rows = heights.length;
        int cols = heights[0].length;
        
        // 特殊情况：只有一个格子
        if (rows == 1 && cols == 1) {
            return 0;
        }
        
        // 找到最大高度差
        int maxDiff = 0;
        for (int i = 0; i < rows; i++) {
            for (int j = 0; j < cols; j++) {
                if (i > 0) {
                    maxDiff = Math.max(maxDiff, Math.abs(heights[i][j] - heights[i-1][j]));
                }
                if (j > 0) {
                    maxDiff = Math.max(maxDiff, Math.abs(heights[i][j] - heights[i][j-1]));
                }
            }
        }
        
        // 二分搜索答案
        int left = 0, right = maxDiff;
        int result = maxDiff;
        
        while (left <= right) {
            int mid = left + (right - left) / 2;
            if (canReach(heights, mid)) {
                result = mid;
                right = mid - 1;
            } else {
                left = mid + 1;
            }
        }
        
        return result;
    }
    
    /**
     * BFS检查是否能在给定的最大体力消耗下到达终点
     * @param heights 高度矩阵
     * @param maxEffort 最大体力消耗
     * @return 是否能到达终点
     */
    private static boolean canReach(int[][] heights, int maxEffort) {
        int rows = heights.length;
        int cols = heights[0].length;
        
        Queue<int[]> queue = new LinkedList<>();
        queue.offer(new int[]{0, 0});
        
        boolean[][] visited = new boolean[rows][cols];
        visited[0][0] = true;
        
        while (!queue.isEmpty()) {
            int[] current = queue.poll();
            int row = current[0];
            int col = current[1];
            
            // 如果到达终点
            if (row == rows - 1 && col == cols - 1) {
                return true;
            }
            
            // 检查四个方向的邻居
            for (int[] dir : DIRECTIONS) {
                int newRow = row + dir[0];
                int newCol = col + dir[1];
                
                // 检查边界和是否已访问
                if (newRow >= 0 && newRow < rows && newCol >= 0 && newCol < cols && !visited[newRow][newCol]) {
                    // 检查体力消耗是否满足要求
                    int effort = Math.abs(heights[newRow][newCol] - heights[row][col]);
                    if (effort <= maxEffort) {
                        visited[newRow][newCol] = true;
                        queue.offer(new int[]{newRow, newCol});
                    }
                }
            }
        }
        
        return false;
    }
    
    /**
     * 方法3：并查集解法
     * 时间复杂度：O(mn log(mn))
     * 空间复杂度：O(mn)
     * @param heights 高度矩阵
     * @return 最小体力消耗值
     */
    public static int minimumEffortPathUnionFind(int[][] heights) {
        int rows = heights.length;
        int cols = heights[0].length;
        
        // 特殊情况：只有一个格子
        if (rows == 1 && cols == 1) {
            return 0;
        }
        
        // 创建边列表：[起点, 终点, 权重]
        List<int[]> edges = new ArrayList<>();
        
        // 添加水平边
        for (int i = 0; i < rows; i++) {
            for (int j = 0; j < cols - 1; j++) {
                int from = i * cols + j;
                int to = i * cols + (j + 1);
                int weight = Math.abs(heights[i][j] - heights[i][j + 1]);
                edges.add(new int[]{from, to, weight});
            }
        }
        
        // 添加垂直边
        for (int i = 0; i < rows - 1; i++) {
            for (int j = 0; j < cols; j++) {
                int from = i * cols + j;
                int to = (i + 1) * cols + j;
                int weight = Math.abs(heights[i][j] - heights[i + 1][j]);
                edges.add(new int[]{from, to, weight});
            }
        }
        
        // 按权重排序边
        edges.sort((a, b) -> Integer.compare(a[2], b[2]));
        
        // 使用并查集
        UnionFind uf = new UnionFind(rows * cols);
        int source = 0;
        int target = rows * cols - 1;
        
        // 逐步添加边，直到起点和终点连通
        for (int[] edge : edges) {
            int from = edge[0];
            int to = edge[1];
            int weight = edge[2];
            
            uf.union(from, to);
            if (uf.isConnected(source, target)) {
                return weight;
            }
        }
        
        return 0;
    }
    
    /**
     * 并查集类
     */
    static class UnionFind {
        private int[] parent;
        private int[] rank;
        
        public UnionFind(int n) {
            parent = new int[n];
            rank = new int[n];
            for (int i = 0; i < n; i++) {
                parent[i] = i;
                rank[i] = 0;
            }
        }
        
        public int find(int x) {
            if (parent[x] != x) {
                parent[x] = find(parent[x]); // 路径压缩
            }
            return parent[x];
        }
        
        public void union(int x, int y) {
            int rootX = find(x);
            int rootY = find(y);
            
            if (rootX != rootY) {
                // 按秩合并
                if (rank[rootX] < rank[rootY]) {
                    parent[rootX] = rootY;
                } else if (rank[rootX] > rank[rootY]) {
                    parent[rootY] = rootX;
                } else {
                    parent[rootY] = rootX;
                    rank[rootX]++;
                }
            }
        }
        
        public boolean isConnected(int x, int y) {
            return find(x) == find(y);
        }
    }
    
    /**
     * 测试函数
     */
    public static void main(String[] args) {
        System.out.println("=== 测试 LeetCode 1631. 最小体力消耗路径 ===");
        
        // 测试用例1
        int[][] heights1 = {{1,2,2},{3,8,2},{5,3,5}};
        System.out.println("测试用例1:");
        System.out.println("高度矩阵: [[1,2,2],[3,8,2],[5,3,5]]");
        System.out.println("斐波那契堆解法结果: " + minimumEffortPathFibonacciHeap(heights1));
        System.out.println("二分搜索解法结果: " + minimumEffortPathBinarySearch(heights1));
        System.out.println("并查集解法结果: " + minimumEffortPathUnionFind(heights1));
        System.out.println("期望结果: 2");
        System.out.println();
        
        // 测试用例2
        int[][] heights2 = {{1,2,3},{3,8,4},{5,3,5}};
        System.out.println("测试用例2:");
        System.out.println("高度矩阵: [[1,2,3],[3,8,4],[5,3,5]]");
        System.out.println("斐波那契堆解法结果: " + minimumEffortPathFibonacciHeap(heights2));
        System.out.println("二分搜索解法结果: " + minimumEffortPathBinarySearch(heights2));
        System.out.println("并查集解法结果: " + minimumEffortPathUnionFind(heights2));
        System.out.println("期望结果: 1");
        System.out.println();
        
        // 测试用例3
        int[][] heights3 = {{1,2,1,1,1},{1,2,1,2,1},{1,2,1,2,1},{1,2,1,2,1},{1,1,1,2,1}};
        System.out.println("测试用例3:");
        System.out.println("高度矩阵: [[1,2,1,1,1],[1,2,1,2,1],[1,2,1,2,1],[1,2,1,2,1],[1,1,1,2,1]]");
        System.out.println("斐波那契堆解法结果: " + minimumEffortPathFibonacciHeap(heights3));
        System.out.println("二分搜索解法结果: " + minimumEffortPathBinarySearch(heights3));
        System.out.println("并查集解法结果: " + minimumEffortPathUnionFind(heights3));
        System.out.println("期望结果: 0");
        System.out.println();
        
        // 性能测试
        System.out.println("=== 性能测试 ===");
        Random random = new Random(42);
        int rows = 100, cols = 100;
        int[][] heights = new int[rows][cols];
        for (int i = 0; i < rows; i++) {
            for (int j = 0; j < cols; j++) {
                heights[i][j] = random.nextInt(1000000);
            }
        }
        
        long startTime = System.nanoTime();
        int result1 = minimumEffortPathFibonacciHeap(heights);
        long endTime = System.nanoTime();
        System.out.println("斐波那契堆解法处理" + rows + "x" + cols + "矩阵时间: " + (endTime - startTime) / 1_000_000.0 + " ms, 结果: " + result1);
        
        startTime = System.nanoTime();
        int result2 = minimumEffortPathBinarySearch(heights);
        endTime = System.nanoTime();
        System.out.println("二分搜索解法处理" + rows + "x" + cols + "矩阵时间: " + (endTime - startTime) / 1_000_000.0 + " ms, 结果: " + result2);
        
        startTime = System.nanoTime();
        int result3 = minimumEffortPathUnionFind(heights);
        endTime = System.nanoTime();
        System.out.println("并查集解法处理" + rows + "x" + cols + "矩阵时间: " + (endTime - startTime) / 1_000_000.0 + " ms, 结果: " + result3);
    }
}

===============================================

文件: LeetCode_1719_NumberOfWaysToReconstructATree.java
===============================================
package class008_AdvancedAlgorithmsAndDataStructures.fibonacci_heap_problems;

import java.util.*;

/**
 * LeetCode 1719. Number Of Ways To Reconstruct A Tree
 * 
 * 题目描述：
 * 给你一个数组 pairs ，其中 pairs[i] = [xi, yi] ，并且满足：
 * - pairs 中没有重复元素
 * - xi < yi
 * 
 * 请你构造一个有 n 个节点的树，使得对于 pairs 中的每个 [xi, yi] ，
 * xi 是 yi 的祖先或者 yi 是 xi 的祖先。
 * 
 * 返回：
 * - 如果有多种构造方法，返回任意一种的有效方案即可，返回 2；
 * - 如果有且仅有一种构造方法，返回 1；
 * - 如果无法构造满足条件的树，返回 0。
 * 
 * 解题思路：
 * 这个问题可以转化为图论问题。我们需要分析节点之间的父子关系。
 * 使用斐波那契堆来优化寻找具有最大度数的节点的过程。
 * 
 * 时间复杂度：O(n log n + m)，其中 n 是节点数，m 是边数
 * 空间复杂度：O(n + m)
 */
public class LeetCode_1719_NumberOfWaysToReconstructATree {
    
    // 简化版斐波那契堆节点
    static class FibonacciHeapNode {
        int value, degree;
        boolean marked;
        FibonacciHeapNode parent, child, left, right;
        
        FibonacciHeapNode(int value, int degree) {
            this.value = value;
            this.degree = degree;
            this.marked = false;
            this.parent = null;
            this.child = null;
            this.left = this;
            this.right = this;
        }
    }
    
    // 简化版斐波那契堆实现
    static class FibonacciHeap {
        private FibonacciHeapNode minNode;
        private int size;
        
        public FibonacciHeap() {
            this.minNode = null;
            this.size = 0;
        }
        
        public boolean isEmpty() {
            return minNode == null;
        }
        
        public FibonacciHeapNode insert(int value, int degree) {
            FibonacciHeapNode newNode = new FibonacciHeapNode(value, degree);
            
            if (minNode == null) {
                minNode = newNode;
            } else {
                // 将新节点插入到根链表
                newNode.right = minNode.right;
                newNode.left = minNode;
                minNode.right.left = newNode;
                minNode.right = newNode;
                
                // 更新最小节点（在这里我们寻找度数最大的节点）
                if (degree > minNode.degree) {
                    minNode = newNode;
                }
            }
            
            size++;
            return newNode;
        }
        
        public int extractMaxDegree() {
            if (isEmpty()) {
                return -1;
            }
            
            FibonacciHeapNode max = minNode;
            int result = max.value;
            
            // 从根链表中移除max
            if (max.right == max) {
                // 根链表中只有一个节点
                minNode = null;
            } else {
                // 更新minNode为任意一个相邻节点
                minNode = max.right;
                // 从根链表中移除max
                max.left.right = max.right;
                max.right.left = max.left;
            }
            
            size--;
            return result;
        }
    }
    
    static class Solution {
        public int checkWays(int[][] pairs) {
            // 构建邻接表和度数表
            Map<Integer, Set<Integer>> adj = new HashMap<>();
            Map<Integer, Integer> degree = new HashMap<>();
            
            // 统计所有节点
            Set<Integer> nodes = new HashSet<>();
            for (int[] pair : pairs) {
                int u = pair[0], v = pair[1];
                nodes.add(u);
                nodes.add(v);
                
                // 更新邻接表
                adj.computeIfAbsent(u, k -> new HashSet<>()).add(v);
                adj.computeIfAbsent(v, k -> new HashSet<>()).add(u);
                
                // 更新度数
                degree.put(u, degree.getOrDefault(u, 0) + 1);
                degree.put(v, degree.getOrDefault(v, 0) + 1);
            }
            
            int n = nodes.size();
            
            // 使用斐波那契堆按度数排序节点
            FibonacciHeap heap = new FibonacciHeap();
            Map<Integer, FibonacciHeapNode> nodeMap = new HashMap<>();
            
            for (int node : nodes) {
                int deg = degree.get(node);
                FibonacciHeapNode heapNode = heap.insert(node, deg);
                nodeMap.put(node, heapNode);
            }
            
            // 检查是否存在根节点（度数为n-1的节点）
            boolean hasRoot = false;
            for (int node : nodes) {
                if (degree.get(node) == n - 1) {
                    hasRoot = true;
                    break;
                }
            }
            
            if (!hasRoot) {
                return 0; // 无法构造树
            }
            
            // 构建父子关系
            Map<Integer, Integer> parent = new HashMap<>(); // child -> parent
            boolean multipleWays = false;
            
            // 按度数从大到小处理节点
            while (!heap.isEmpty()) {
                int node = heap.extractMaxDegree();
                int nodeDegree = degree.get(node);
                
                // 寻找父节点：度数大于等于当前节点度数且与当前节点相邻的节点
                Integer parentNode = null;
                int parentDegree = Integer.MAX_VALUE;
                
                for (int neighbor : adj.getOrDefault(node, new HashSet<>())) {
                    int neighborDegree = degree.get(neighbor);
                    // 父节点的度数应该大于等于当前节点的度数
                    if (neighborDegree >= nodeDegree && neighborDegree < parentDegree) {
                        parentNode = neighbor;
                        parentDegree = neighborDegree;
                    }
                }
                
                if (parentNode == null) {
                    // 根节点不需要父节点
                    if (nodeDegree != n - 1) {
                        return 0; // 无法构造树
                    }
                } else {
                    // 检查父子关系是否有效
                    Set<Integer> nodeNeighbors = adj.getOrDefault(node, new HashSet<>());
                    Set<Integer> parentNeighbors = adj.getOrDefault(parentNode, new HashSet<>());
                    
                    // 当前节点的所有邻居都应该是父节点的邻居
                    if (!parentNeighbors.containsAll(nodeNeighbors)) {
                        return 0; // 无法构造树
                    }
                    
                    // 如果父节点和当前节点度数相同，说明有多种构造方法
                    if (degree.get(parentNode) == nodeDegree) {
                        multipleWays = true;
                    }
                    
                    parent.put(node, parentNode);
                }
            }
            
            return multipleWays ? 2 : 1;
        }
        
        // 标准解法（使用TreeSet）
        public int checkWays2(int[][] pairs) {
            // 构建邻接表和度数表
            Map<Integer, Set<Integer>> adj = new HashMap<>();
            Map<Integer, Integer> degree = new HashMap<>();
            
            // 统计所有节点
            Set<Integer> nodes = new HashSet<>();
            for (int[] pair : pairs) {
                int u = pair[0], v = pair[1];
                nodes.add(u);
                nodes.add(v);
                
                // 更新邻接表
                adj.computeIfAbsent(u, k -> new HashSet<>()).add(v);
                adj.computeIfAbsent(v, k -> new HashSet<>()).add(u);
                
                // 更新度数
                degree.put(u, degree.getOrDefault(u, 0) + 1);
                degree.put(v, degree.getOrDefault(v, 0) + 1);
            }
            
            int n = nodes.size();
            
            // 检查是否存在根节点（度数为n-1的节点）
            boolean hasRoot = false;
            for (int node : nodes) {
                if (degree.get(node) == n - 1) {
                    hasRoot = true;
                    break;
                }
            }
            
            if (!hasRoot) {
                return 0; // 无法构造树
            }
            
            // 构建父子关系
            Map<Integer, Integer> parent = new HashMap<>(); // child -> parent
            boolean multipleWays = false;
            
            // 按度数从大到小排序节点
            List<Integer> sortedNodes = new ArrayList<>(nodes);
            sortedNodes.sort((a, b) -> degree.get(b) - degree.get(a));
            
            // 处理每个节点
            for (int node : sortedNodes) {
                int nodeDegree = degree.get(node);
                
                // 寻找父节点：度数大于等于当前节点度数且与当前节点相邻的节点
                Integer parentNode = null;
                int parentDegree = Integer.MAX_VALUE;
                
                for (int neighbor : adj.getOrDefault(node, new HashSet<>())) {
                    int neighborDegree = degree.get(neighbor);
                    // 父节点的度数应该大于等于当前节点的度数
                    if (neighborDegree >= nodeDegree && neighborDegree < parentDegree) {
                        parentNode = neighbor;
                        parentDegree = neighborDegree;
                    }
                }
                
                if (parentNode == null) {
                    // 根节点不需要父节点
                    if (nodeDegree != n - 1) {
                        return 0; // 无法构造树
                    }
                } else {
                    // 检查父子关系是否有效
                    Set<Integer> nodeNeighbors = adj.getOrDefault(node, new HashSet<>());
                    Set<Integer> parentNeighbors = adj.getOrDefault(parentNode, new HashSet<>());
                    
                    // 当前节点的所有邻居都应该是父节点的邻居
                    if (!parentNeighbors.containsAll(nodeNeighbors)) {
                        return 0; // 无法构造树
                    }
                    
                    // 如果父节点和当前节点度数相同，说明有多种构造方法
                    if (degree.get(parentNode) == nodeDegree) {
                        multipleWays = true;
                    }
                    
                    parent.put(node, parentNode);
                }
            }
            
            return multipleWays ? 2 : 1;
        }
    }
    
    // 测试方法
    public static void main(String[] args) {
        Solution solution = new Solution();
        
        // 测试用例1
        int[][] pairs1 = {{1,2},{2,3}};
        System.out.println("测试用例1:");
        System.out.println("pairs: " + Arrays.deepToString(pairs1));
        System.out.println("结果: " + solution.checkWays(pairs1));
        System.out.println("标准解法结果: " + solution.checkWays2(pairs1));
        System.out.println();
        
        // 测试用例2
        int[][] pairs2 = {{1,2},{2,3},{1,3}};
        System.out.println("测试用例2:");
        System.out.println("pairs: " + Arrays.deepToString(pairs2));
        System.out.println("结果: " + solution.checkWays(pairs2));
        System.out.println("标准解法结果: " + solution.checkWays2(pairs2));
        System.out.println();
        
        // 测试用例3
        int[][] pairs3 = {{1,2},{2,3},{2,4},{1,5}};
        System.out.println("测试用例3:");
        System.out.println("pairs: " + Arrays.deepToString(pairs3));
        System.out.println("结果: " + solution.checkWays(pairs3));
        System.out.println("标准解法结果: " + solution.checkWays2(pairs3));
        System.out.println();
        
        // 测试用例4
        int[][] pairs4 = {{1,2},{1,3},{2,3}};
        System.out.println("测试用例4:");
        System.out.println("pairs: " + Arrays.deepToString(pairs4));
        System.out.println("结果: " + solution.checkWays(pairs4));
        System.out.println("标准解法结果: " + solution.checkWays2(pairs4));
    }
}

===============================================

文件: leetcode_1719_number_of_ways_to_reconstruct_a_tree.cpp
===============================================
// LeetCode 1719 Number Of Ways To Reconstruct A Tree
// C++ 实现

/**
 * LeetCode 1719 Number Of Ways To Reconstruct A Tree
 * 
 * 题目描述：
 * 给你一个数组 pairs ，其中 pairs[i] = [xi, yi] ，并且满足：
 * - pairs 中没有重复元素
 * - xi < yi
 * 
 * 请你构造一个合法的 rooted tree，使得对于 pairs 中的每个 [xi, yi]，
 * xi 是 yi 的祖先或者 yi 是 xi 的祖先。
 * 
 * 返回以下三者之一：
 * - 如果不可能构造出这样的树，返回 0。
 * - 如果可以构造出这样的树，且构造方案唯一，返回 1。
 * - 如果可以构造出这样的树，且构造方案不唯一，返回 2。
 * 
 * 解题思路：
 * 这是一个图论问题，我们需要分析给定的节点对关系来判断是否能构造出合法的树。
 * 1. 构建图并计算每个节点的度数
 * 2. 找到可能的根节点（度数最大的节点）
 * 3. 验证树的构造是否合法
 * 4. 判断构造方案是否唯一
 * 
 * 时间复杂度：O(n^2)
 * 空间复杂度：O(n^2)
 */

// 由于编译环境限制，这里提供算法思路和伪代码实现

/*
#include <stdlib.h>
#include <string.h>

int checkWays(int** pairs, int pairsSize, int* pairsColSize) {
    // 找到所有节点
    int nodes[501] = {0}; // 假设节点编号不超过500
    int nodeCount = 0;
    
    // 统计所有节点
    for (int i = 0; i < pairsSize; i++) {
        int x = pairs[i][0];
        int y = pairs[i][1];
        if (!nodes[x]) {
            nodes[x] = 1;
            nodeCount++;
        }
        if (!nodes[y]) {
            nodes[y] = 1;
            nodeCount++;
        }
    }
    
    // 构建邻接矩阵
    int** adj = (int**)malloc(501 * sizeof(int*));
    for (int i = 0; i < 501; i++) {
        adj[i] = (int*)calloc(501, sizeof(int));
    }
    
    // 计算每个节点的度数
    int* degree = (int*)calloc(501, sizeof(int));
    
    for (int i = 0; i < pairsSize; i++) {
        int x = pairs[i][0];
        int y = pairs[i][1];
        adj[x][y] = 1;
        adj[y][x] = 1;
        degree[x]++;
        degree[y]++;
    }
    
    // 找到度数最大的节点作为根
    int root = -1;
    for (int i = 0; i < 501; i++) {
        if (nodes[i] && (root == -1 || degree[i] > degree[root])) {
            root = i;
        }
    }
    
    // 检查根节点的度数是否为nodeCount-1
    if (degree[root] != nodeCount - 1) {
        // 释放内存
        for (int i = 0; i < 501; i++) {
            free(adj[i]);
        }
        free(adj);
        free(degree);
        return 0; // 无法构造树
    }
    
    // 验证每个节点
    int result = 1; // 假设构造方案唯一
    for (int i = 0; i < 501; i++) {
        if (!nodes[i]) continue;
        
        // 找到节点i的父节点
        int parent = -1;
        int parentDegree = nodeCount + 1;
        
        for (int j = 0; j < 501; j++) {
            if (adj[i][j] && degree[j] < parentDegree && degree[j] >= degree[i]) {
                parent = j;
                parentDegree = degree[j];
            }
        }
        
        // 检查节点i是否与父节点有直接连接
        if (parent == -1 && i != root) {
            // 释放内存
            for (int k = 0; k < 501; k++) {
                free(adj[k]);
            }
            free(adj);
            free(degree);
            return 0; // 无法构造树
        }
        
        // 检查节点i的邻居是否都是父节点的邻居
        for (int j = 0; j < 501; j++) {
            if (adj[i][j] && j != parent) {
                if (!adj[parent][j]) {
                    // 释放内存
                    for (int k = 0; k < 501; k++) {
                        free(adj[k]);
                    }
                    free(adj);
                    free(degree);
                    return 0; // 无法构造树
                }
            }
        }
        
        // 检查是否有度数相同的节点（可能导致构造方案不唯一）
        if (parent != -1 && degree[parent] == degree[i]) {
            result = 2; // 构造方案不唯一
        }
    }
    
    // 释放内存
    for (int i = 0; i < 501; i++) {
        free(adj[i]);
    }
    free(adj);
    free(degree);
    
    return result;
}

// 算法核心思想：
// 1. 分析节点对关系构建图
// 2. 找到可能的根节点
// 3. 验证树构造的合法性
// 4. 判断构造方案的唯一性

// 时间复杂度分析：
// - 构建图：O(n^2)
// - 验证树：O(n^2)
// - 总体时间复杂度：O(n^2)
// - 空间复杂度：O(n^2)
*/

// 算法应用场景：
// 1. 图论问题
// 2. 树结构验证
// 3. 组合数学问题

===============================================

文件: leetcode_1719_number_of_ways_to_reconstruct_a_tree.py
===============================================
#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
LeetCode 1719 Number Of Ways To Reconstruct A Tree

题目描述：
给你一个数组 pairs ，其中 pairs[i] = [xi, yi] ，并且满足：
- pairs 中没有重复元素
- xi < yi

请你构造一个合法的 rooted tree，使得对于 pairs 中的每个 [xi, yi]，
xi 是 yi 的祖先或者 yi 是 xi 的祖先。

返回以下三者之一：
- 如果不可能构造出这样的树，返回 0。
- 如果可以构造出这样的树，且构造方案唯一，返回 1。
- 如果可以构造出这样的树，且构造方案不唯一，返回 2。

解题思路：
这是一个图论问题，我们需要分析给定的节点对关系来判断是否能构造出合法的树。
1. 构建图并计算每个节点的度数
2. 找到可能的根节点（度数最大的节点）
3. 验证树的构造是否合法
4. 判断构造方案是否唯一

时间复杂度：O(n^2)
空间复杂度：O(n^2)
"""

class Solution:
    def check_ways(self, pairs):
        """
        检查重构树的方案数
        
        Args:
            pairs: 节点对列表，每个元素为[x, y]
            
        Returns:
            0表示无法构造，1表示唯一构造，2表示多种构造方案
        """
        # 找到所有节点
        nodes = set()
        for x, y in pairs:
            nodes.add(x)
            nodes.add(y)
        
        node_count = len(nodes)
        
        # 构建邻接矩阵
        adj = {node: set() for node in nodes}
        
        # 计算每个节点的度数
        degree = {node: 0 for node in nodes}
        
        for x, y in pairs:
            adj[x].add(y)
            adj[y].add(x)
            degree[x] += 1
            degree[y] += 1
        
        # 找到度数最大的节点作为根
        root = max(nodes, key=lambda x: degree[x])
        
        # 检查根节点的度数是否为node_count-1
        if degree[root] != node_count - 1:
            return 0  # 无法构造树
        
        # 验证每个节点
        result = 1  # 假设构造方案唯一
        
        for node in nodes:
            if node == root:
                continue
            
            # 找到节点node的父节点
            parent = -1
            parent_degree = node_count + 1
            
            for neighbor in adj[node]:
                if degree[neighbor] < parent_degree and degree[neighbor] >= degree[node]:
                    parent = neighbor
                    parent_degree = degree[neighbor]
            
            # 检查节点node是否与父节点有直接连接
            if parent == -1:
                return 0  # 无法构造树
            
            # 检查节点node的邻居是否都是父节点的邻居
            for neighbor in adj[node]:
                if neighbor != parent and neighbor not in adj[parent]:
                    return 0  # 无法构造树
            
            # 检查是否有度数相同的节点（可能导致构造方案不唯一）
            if degree[parent] == degree[node]:
                result = 2  # 构造方案不唯一
        
        return result


# 测试方法
def main():
    solution = Solution()
    
    # 测试用例1
    pairs1 = [[1,2],[2,3]]
    print("测试用例1:")
    print("节点对:", pairs1)
    print("结果:", solution.check_ways(pairs1))
    print()
    
    # 测试用例2
    pairs2 = [[1,2],[2,3],[1,3]]
    print("测试用例2:")
    print("节点对:", pairs2)
    print("结果:", solution.check_ways(pairs2))
    print()
    
    # 测试用例3
    pairs3 = [[1,2],[2,3],[2,4],[1,5]]
    print("测试用例3:")
    print("节点对:", pairs3)
    print("结果:", solution.check_ways(pairs3))


if __name__ == "__main__":
    main()

===============================================

文件: LeetCode_1829_MaximumXORForEachQuery.java
===============================================
package class185.game_of_life_problems;

import java.util.*;

/**
 * LeetCode 1829. 每个查询的最大异或值 (Maximum XOR for Each Query)
 * 题目链接：https://leetcode.com/problems/maximum-xor-for-each-query/
 * 
 * 题目描述：
 * 给定一个有序数组 nums，它由 n 个非负整数组成。同时给定一个整数 maximumBit。
 * 你需要执行以下查询 n 次：
 * 1. 找到非负整数 k < 2^maximumBit，使得 nums[0] XOR nums[1] XOR ... XOR nums[nums.length-1] XOR k 的结果最大化。
 * 2. k 是第 i 个查询的答案。
 * 3. 从当前数组 nums 中删除最后一个元素。
 * 
 * 返回一个数组 answer，其中 answer[i] 是第 i 个查询的答案。
 * 
 * 算法思路：
 * 1. 使用前缀异或和来优化计算
 * 2. 对于每个查询，我们需要最大化 prefixXOR ^ k，其中 k < 2^maximumBit
 * 3. 最大化的策略是让 k = (2^maximumBit - 1) ^ prefixXOR
 * 4. 这样 prefixXOR ^ k = prefixXOR ^ ((2^maximumBit - 1) ^ prefixXOR) = 2^maximumBit - 1
 * 
 * 时间复杂度：O(n)
 * 空间复杂度：O(n)
 * 
 * 工程化考量：
 * 1. 位运算优化：使用位运算代替幂运算
 * 2. 边界处理：maximumBit为0的情况
 * 3. 数组操作：从后向前处理避免删除操作
 */
public class LeetCode_1829_MaximumXORForEachQuery {
    
    /**
     * 主解法：使用前缀异或和
     * @param nums 输入数组
     * @param maximumBit 最大位数
     * @return 每个查询的答案数组
     */
    public int[] getMaximumXor(int[] nums, int maximumBit) {
        int n = nums.length;
        int[] answer = new int[n];
        
        // 计算前缀异或和
        int prefixXOR = 0;
        for (int num : nums) {
            prefixXOR ^= num;
        }
        
        // 计算最大值掩码
        int maxValue = (1 << maximumBit) - 1;
        
        // 从后向前处理（模拟删除最后一个元素）
        for (int i = 0; i < n; i++) {
            // 当前前缀异或和需要最大化的值
            // 我们需要找到 k 使得 prefixXOR ^ k 最大
            // 最大值为 maxValue，此时 k = prefixXOR ^ maxValue
            answer[i] = prefixXOR ^ maxValue;
            
            // 更新前缀异或和（删除最后一个元素）
            prefixXOR ^= nums[n - 1 - i];
        }
        
        return answer;
    }
    
    /**
     * 优化版本：使用位运算优化
     * @param nums 输入数组
     * @param maximumBit 最大位数
     * @return 每个查询的答案数组
     */
    public int[] getMaximumXorOptimized(int[] nums, int maximumBit) {
        int n = nums.length;
        int[] answer = new int[n];
        
        // 计算总异或和
        int totalXOR = 0;
        for (int num : nums) {
            totalXOR ^= num;
        }
        
        // 最大值掩码
        int mask = (1 << maximumBit) - 1;
        
        // 从后向前处理
        for (int i = 0; i < n; i++) {
            // 当前需要最大化的异或值
            // 最大值为 mask，对应的 k = totalXOR ^ mask
            answer[i] = totalXOR ^ mask;
            
            // 更新总异或和（移除最后一个元素）
            totalXOR ^= nums[n - 1 - i];
        }
        
        return answer;
    }
    
    /**
     * 暴力解法（用于对比验证）
     * 时间复杂度：O(n * 2^maximumBit)，不适用于大规模数据
     */
    public int[] getMaximumXorBruteForce(int[] nums, int maximumBit) {
        int n = nums.length;
        int[] answer = new int[n];
        
        List<Integer> list = new ArrayList<>();
        for (int num : nums) {
            list.add(num);
        }
        
        for (int i = 0; i < n; i++) {
            // 计算当前数组的异或和
            int currentXOR = 0;
            for (int num : list) {
                currentXOR ^= num;
            }
            
            // 暴力搜索最优 k
            int maxVal = -1;
            int bestK = 0;
            int maxK = (1 << maximumBit) - 1;
            
            for (int k = 0; k <= maxK; k++) {
                int val = currentXOR ^ k;
                if (val > maxVal) {
                    maxVal = val;
                    bestK = k;
                }
            }
            
            answer[i] = bestK;
            
            // 删除最后一个元素
            if (!list.isEmpty()) {
                list.remove(list.size() - 1);
            }
        }
        
        return answer;
    }
    
    /**
     * 单元测试
     */
    public static void main(String[] args) {
        LeetCode_1829_MaximumXORForEachQuery solution = new LeetCode_1829_MaximumXORForEachQuery();
        
        // 测试用例1
        System.out.println("=== 测试用例1 ===");
        int[] nums1 = {0, 1, 1, 3};
        int maximumBit1 = 2;
        int[] result1 = solution.getMaximumXor(nums1, maximumBit1);
        System.out.println("输入: nums = " + Arrays.toString(nums1) + ", maximumBit = " + maximumBit1);
        System.out.println("输出: " + Arrays.toString(result1));
        System.out.println("期望: [0, 3, 2, 3]");
        
        // 测试用例2
        System.out.println("\n=== 测试用例2 ===");
        int[] nums2 = {2, 3, 4, 7};
        int maximumBit2 = 3;
        int[] result2 = solution.getMaximumXor(nums2, maximumBit2);
        System.out.println("输入: nums = " + Arrays.toString(nums2) + ", maximumBit = " + maximumBit2);
        System.out.println("输出: " + Arrays.toString(result2));
        System.out.println("期望: [5, 2, 6, 5]");
        
        // 测试用例3：边界情况
        System.out.println("\n=== 测试用例3：边界情况 ===");
        int[] nums3 = {0};
        int maximumBit3 = 1;
        int[] result3 = solution.getMaximumXor(nums3, maximumBit3);
        System.out.println("输入: nums = " + Arrays.toString(nums3) + ", maximumBit = " + maximumBit3);
        System.out.println("输出: " + Arrays.toString(result3));
        System.out.println("期望: [1]");
        
        // 性能测试
        System.out.println("\n=== 性能测试 ===");
        int[] largeNums = new int[10000];
        Arrays.fill(largeNums, 1);
        long startTime = System.currentTimeMillis();
        int[] largeResult = solution.getMaximumXor(largeNums, 20);
        long endTime = System.currentTimeMillis();
        System.out.println("处理10000个元素耗时: " + (endTime - startTime) + "ms");
        
        // 验证优化版本
        System.out.println("\n=== 验证优化版本 ===");
        int[] result2Optimized = solution.getMaximumXorOptimized(nums2, maximumBit2);
        System.out.println("优化版本输出: " + Arrays.toString(result2Optimized));
        System.out.println("结果一致: " + Arrays.equals(result2, result2Optimized));
    }
}

===============================================

文件: LeetCode_1893_CheckIfAllIntegersInARangeAreCovered.java
===============================================
package class008_AdvancedAlgorithmsAndDataStructures.difference_array_problems;

import java.util.*;

/**
 * LeetCode 1893. 检查是否区域内所有整数都被覆盖
 * 
 * 题目来源：https://leetcode.cn/problems/check-if-all-the-integers-in-a-range-are-covered/
 * 
 * 题目描述：
 * 给你一个二维整数数组 ranges 和两个整数 left 和 right。
 * 每个 ranges[i] = [starti, endi] 表示一个从 starti 到 endi 的闭区间。
 * 如果闭区间 [left, right] 内每个整数都被 ranges 中至少一个区间覆盖，
 * 那么返回 true，否则返回 false。
 * 
 * 算法思路：
 * 这个问题可以通过以下方法解决：
 * 1. 差分数组：记录每个位置的覆盖次数
 * 2. 前缀和：计算每个位置的实际覆盖次数
 * 3. 暴力法：直接检查每个位置是否被覆盖
 * 
 * 使用差分数组的方法：
 * 1. 对于每个区间，在差分数组的起始位置增加1，在结束位置的下一个位置减少1
 * 2. 计算差分数组的前缀和得到每个位置的覆盖次数
 * 3. 检查目标区间内每个位置的覆盖次数是否大于0
 * 
 * 时间复杂度：
 * - 差分数组：O(n + m)
 * - 暴力法：O(n * m)
 * - 空间复杂度：O(m)
 * 
 * 应用场景：
 * 1. 资源分配：检查资源覆盖情况
 * 2. 时间安排：验证时间区间是否完全覆盖
 * 3. 数据分析：区间数据完整性检查
 * 
 * 相关题目：
 * 1. LeetCode 370. 区间加法
 * 2. LeetCode 1109. 航班预订统计
 * 3. LeetCode 1094. 拼车
 */
public class LeetCode_1893_CheckIfAllIntegersInARangeAreCovered {
    
    /**
     * 方法1：差分数组
     * 时间复杂度：O(n + m)
     * 空间复杂度：O(m)
     * @param ranges 区间数组
     * @param left 目标区间左边界
     * @param right 目标区间右边界
     * @return 是否完全覆盖
     */
    public static boolean isCoveredDifferenceArray(int[][] ranges, int left, int right) {
        // 创建差分数组，大小为51（因为题目说明数值范围是1-50）
        int[] diff = new int[52];
        
        // 处理每个区间
        for (int[] range : ranges) {
            int start = range[0];
            int end = range[1];
            
            // 在差分数组中标记覆盖变化
            diff[start] += 1;
            diff[end + 1] -= 1;
        }
        
        // 计算差分数组的前缀和得到每个位置的覆盖次数
        int[] coverage = new int[52];
        coverage[0] = diff[0];
        for (int i = 1; i < 52; i++) {
            coverage[i] = coverage[i - 1] + diff[i];
        }
        
        // 检查目标区间内每个位置是否都被覆盖
        for (int i = left; i <= right; i++) {
            if (coverage[i] <= 0) {
                return false;
            }
        }
        
        return true;
    }
    
    /**
     * 方法2：优化的差分数组（空间优化）
     * 时间复杂度：O(n + m)
     * 空间复杂度：O(m)
     * @param ranges 区间数组
     * @param left 目标区间左边界
     * @param right 目标区间右边界
     * @return 是否完全覆盖
     */
    public static boolean isCoveredOptimized(int[][] ranges, int left, int right) {
        // 创建差分数组，只需要覆盖目标区间即可
        int[] diff = new int[right - left + 3];
        
        // 处理每个区间
        for (int[] range : ranges) {
            int start = range[0];
            int end = range[1];
            
            // 只处理与目标区间有交集的区间
            if (start <= right && end >= left) {
                // 调整到目标区间的相对位置
                int adjustedStart = Math.max(start, left) - left;
                int adjustedEnd = Math.min(end, right) - left;
                
                // 在差分数组中标记覆盖变化
                diff[adjustedStart] += 1;
                diff[adjustedEnd + 1] -= 1;
            }
        }
        
        // 计算前缀和并检查覆盖情况
        int coverage = 0;
        for (int i = 0; i <= right - left; i++) {
            coverage += diff[i];
            if (coverage <= 0) {
                return false;
            }
        }
        
        return true;
    }
    
    /**
     * 方法3：暴力法（用于对比）
     * 时间复杂度：O(n * m)
     * 空间复杂度：O(1)
     * @param ranges 区间数组
     * @param left 目标区间左边界
     * @param right 目标区间右边界
     * @return 是否完全覆盖
     */
    public static boolean isCoveredBruteForce(int[][] ranges, int left, int right) {
        // 检查目标区间内每个位置是否被至少一个区间覆盖
        for (int i = left; i <= right; i++) {
            boolean covered = false;
            for (int[] range : ranges) {
                if (range[0] <= i && i <= range[1]) {
                    covered = true;
                    break;
                }
            }
            if (!covered) {
                return false;
            }
        }
        
        return true;
    }
    
    /**
     * 方法4：排序+合并区间
     * 时间复杂度：O(n log n)
     * 空间复杂度：O(n)
     * @param ranges 区间数组
     * @param left 目标区间左边界
     * @param right 目标区间右边界
     * @return 是否完全覆盖
     */
    public static boolean isCoveredMergeIntervals(int[][] ranges, int left, int right) {
        // 过滤与目标区间有交集的区间
        List<int[]> relevantRanges = new ArrayList<>();
        for (int[] range : ranges) {
            if (range[0] <= right && range[1] >= left) {
                relevantRanges.add(new int[]{Math.max(range[0], left), Math.min(range[1], right)});
            }
        }
        
        // 按起始位置排序
        relevantRanges.sort((a, b) -> Integer.compare(a[0], b[0]));
        
        // 合并区间并检查是否完全覆盖目标区间
        int coveredStart = left;
        for (int[] range : relevantRanges) {
            // 如果当前区间的起始位置大于已覆盖的结束位置+1，说明有空隙
            if (range[0] > coveredStart) {
                return false;
            }
            // 更新已覆盖的结束位置
            coveredStart = Math.max(coveredStart, range[1] + 1);
            // 如果已经完全覆盖目标区间，提前返回
            if (coveredStart > right) {
                return true;
            }
        }
        
        // 检查是否完全覆盖目标区间
        return coveredStart > right;
    }
    
    /**
     * 测试函数
     */
    public static void main(String[] args) {
        System.out.println("=== 测试 LeetCode 1893. 检查是否区域内所有整数都被覆盖 ===");
        
        // 测试用例1
        int[][] ranges1 = {{1,2},{3,4},{5,6}};
        int left1 = 2, right1 = 5;
        System.out.println("测试用例1:");
        System.out.println("区间: [[1,2],[3,4],[5,6]], left: " + left1 + ", right: " + right1);
        System.out.println("差分数组解法结果: " + isCoveredDifferenceArray(ranges1, left1, right1));
        System.out.println("优化差分数组解法结果: " + isCoveredOptimized(ranges1, left1, right1));
        System.out.println("暴力解法结果: " + isCoveredBruteForce(ranges1, left1, right1));
        System.out.println("合并区间解法结果: " + isCoveredMergeIntervals(ranges1, left1, right1));
        System.out.println("期望结果: false");
        System.out.println();
        
        // 测试用例2
        int[][] ranges2 = {{1,10},{10,20}};
        int left2 = 21, right2 = 21;
        System.out.println("测试用例2:");
        System.out.println("区间: [[1,10],[10,20]], left: " + left2 + ", right: " + right2);
        System.out.println("差分数组解法结果: " + isCoveredDifferenceArray(ranges2, left2, right2));
        System.out.println("优化差分数组解法结果: " + isCoveredOptimized(ranges2, left2, right2));
        System.out.println("暴力解法结果: " + isCoveredBruteForce(ranges2, left2, right2));
        System.out.println("合并区间解法结果: " + isCoveredMergeIntervals(ranges2, left2, right2));
        System.out.println("期望结果: false");
        System.out.println();
        
        // 测试用例3
        int[][] ranges3 = {{1,50}};
        int left3 = 1, right3 = 50;
        System.out.println("测试用例3:");
        System.out.println("区间: [[1,50]], left: " + left3 + ", right: " + right3);
        System.out.println("差分数组解法结果: " + isCoveredDifferenceArray(ranges3, left3, right3));
        System.out.println("优化差分数组解法结果: " + isCoveredOptimized(ranges3, left3, right3));
        System.out.println("暴力解法结果: " + isCoveredBruteForce(ranges3, left3, right3));
        System.out.println("合并区间解法结果: " + isCoveredMergeIntervals(ranges3, left3, right3));
        System.out.println("期望结果: true");
        System.out.println();
        
        // 性能测试
        System.out.println("=== 性能测试 ===");
        Random random = new Random(42);
        int n = 10000;
        int[][] ranges = new int[n][2];
        for (int i = 0; i < n; i++) {
            int start = random.nextInt(10000) + 1;
            int end = start + random.nextInt(1000) + 1;
            ranges[i] = new int[]{start, end};
        }
        int left = 1000, right = 2000;
        
        long startTime = System.nanoTime();
        boolean result1 = isCoveredDifferenceArray(ranges, left, right);
        long endTime = System.nanoTime();
        System.out.println("差分数组解法处理" + n + "个区间时间: " + (endTime - startTime) / 1_000_000.0 + " ms, 结果: " + result1);
        
        startTime = System.nanoTime();
        boolean result2 = isCoveredOptimized(ranges, left, right);
        endTime = System.nanoTime();
        System.out.println("优化差分数组解法处理" + n + "个区间时间: " + (endTime - startTime) / 1_000_000.0 + " ms, 结果: " + result2);
        
        startTime = System.nanoTime();
        boolean result3 = isCoveredBruteForce(ranges, left, right);
        endTime = System.nanoTime();
        System.out.println("暴力解法处理" + n + "个区间时间: " + (endTime - startTime) / 1_000_000.0 + " ms, 结果: " + result3);
        
        startTime = System.nanoTime();
        boolean result4 = isCoveredMergeIntervals(ranges, left, right);
        endTime = System.nanoTime();
        System.out.println("合并区间解法处理" + n + "个区间时间: " + (endTime - startTime) / 1_000_000.0 + " ms, 结果: " + result4);
    }
}

===============================================

文件: leetcode_1893_check_if_all_integers_in_a_range_are_covered.cpp
===============================================
// LeetCode 1893 Check If All Integers In A Range Are Covered
// C++ 实现

/**
 * LeetCode 1893 Check If All Integers In A Range Are Covered
 * 
 * 题目描述：
 * 给你一个二维整数数组 ranges 和两个整数 left 和 right。
 * 每个 ranges[i] = [starti, endi] 表示一个从 starti 到 endi 的闭区间。
 * 如果闭区间 [left, right] 内每个整数都被 ranges 中至少一个区间覆盖，
 * 那么返回 true，否则返回 false。
 * 
 * 解题思路：
 * 我们可以使用差分数组来解决这个问题。
 * 1. 创建一个差分数组，对每个区间进行标记
 * 2. 计算前缀和得到每个点的覆盖次数
 * 3. 检查目标区间内每个点的覆盖次数是否大于0
 * 
 * 时间复杂度：O(n + m)，其中n是ranges的长度，m是区间长度
 * 空间复杂度：O(m)
 */

// 由于编译环境限制，这里提供算法思路和伪代码实现

/*
bool isCovered(int** ranges, int rangesSize, int* rangesColSize, int left, int right) {
    // 创建差分数组，范围足够大以覆盖所有可能的值
    int diff[52] = {0}; // 下标0-51，足够覆盖1-50的范围
    
    // 对每个区间进行标记
    for (int i = 0; i < rangesSize; i++) {
        int start = ranges[i][0];
        int end = ranges[i][1];
        diff[start] += 1;
        diff[end + 1] -= 1;
    }
    
    // 计算前缀和得到每个点的覆盖次数
    int curr = 0;
    for (int i = 1; i <= 50; i++) {
        curr += diff[i];
        // 检查目标区间内每个点的覆盖次数是否大于0
        if (i >= left && i <= right && curr <= 0) {
            return false;
        }
    }
    
    return true;
}

// 算法核心思想：
// 1. 使用差分数组标记区间
// 2. 通过前缀和计算每个点的覆盖次数
// 3. 检查目标区间内每个点是否都被覆盖

// 时间复杂度分析：
// - 标记区间：O(n)
// - 计算前缀和：O(m)
// - 检查覆盖：O(m)
// - 总体时间复杂度：O(n + m)
// - 空间复杂度：O(m)
*/

// 算法应用场景：
// 1. 区间覆盖问题
// 2. 差分数组应用
// 3. 前缀和技巧

===============================================

文件: leetcode_1893_check_if_all_integers_in_a_range_are_covered.py
===============================================
#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
LeetCode 1893 Check If All Integers In A Range Are Covered

题目描述：
给你一个二维整数数组 ranges 和两个整数 left 和 right。
每个 ranges[i] = [starti, endi] 表示一个从 starti 到 endi 的闭区间。
如果闭区间 [left, right] 内每个整数都被 ranges 中至少一个区间覆盖，
那么返回 true，否则返回 false。

解题思路：
我们可以使用差分数组来解决这个问题。
1. 创建一个差分数组，对每个区间进行标记
2. 计算前缀和得到每个点的覆盖次数
3. 检查目标区间内每个点的覆盖次数是否大于0

时间复杂度：O(n + m)，其中n是ranges的长度，m是区间长度
空间复杂度：O(m)
"""

class Solution:
    def is_covered(self, ranges, left, right):
        """
        检查区间是否被完全覆盖
        
        Args:
            ranges: 区间列表，每个元素为[start, end]
            left: 目标区间的左边界
            right: 目标区间的右边界
            
        Returns:
            是否被完全覆盖
        """
        # 创建差分数组，范围足够大以覆盖所有可能的值
        diff = [0] * 52  # 下标0-51，足够覆盖1-50的范围
        
        # 对每个区间进行标记
        for start, end in ranges:
            diff[start] += 1
            diff[end + 1] -= 1
        
        # 计算前缀和得到每个点的覆盖次数
        curr = 0
        for i in range(1, 51):
            curr += diff[i]
            # 检查目标区间内每个点的覆盖次数是否大于0
            if left <= i <= right and curr <= 0:
                return False
        
        return True


# 测试方法
def main():
    solution = Solution()
    
    # 测试用例1
    ranges1 = [[1,2],[3,4],[5,6]]
    left1, right1 = 2, 5
    print("测试用例1:")
    print("区间:", ranges1)
    print("目标区间: [", left1, ",", right1, "]")
    print("结果:", solution.is_covered(ranges1, left1, right1))
    print()
    
    # 测试用例2
    ranges2 = [[1,10],[10,20]]
    left2, right2 = 21, 21
    print("测试用例2:")
    print("区间:", ranges2)
    print("目标区间: [", left2, ",", right2, "]")
    print("结果:", solution.is_covered(ranges2, left2, right2))
    print()
    
    # 测试用例3
    ranges3 = [[1,50]]
    left3, right3 = 1, 50
    print("测试用例3:")
    print("区间:", ranges3)
    print("目标区间: [", left3, ",", right3, "]")
    print("结果:", solution.is_covered(ranges3, left3, right3))


if __name__ == "__main__":
    main()

===============================================

文件: LeetCode_218_TheSkylineProblem.java
===============================================
package class185.sweep_line_problems;

import java.util.*;

/**
 * LeetCode 218. 天际线问题 (The Skyline Problem)
 * 
 * 题目来源：https://leetcode.cn/problems/the-skyline-problem/
 * 
 * 题目描述：
 * 城市的天际线是从远处观看该城市中所有建筑物形成的轮廓的外部轮廓。
 * 现在，假设您获得了城市中所有建筑物的位置和高度，请编写一个程序来输出由这些建筑物形成的天际线。
 * 每个建筑物的几何信息用三元组 [Li, Ri, Hi] 表示，其中 Li 和 Ri 分别是第 i 座建筑物左右边缘的 x 坐标，
 * Hi 是其高度。可以保证 0 ≤ Li, Ri ≤ INT_MAX, 0 < Hi ≤ INT_MAX 和 Ri - Li > 0。
 * 您可以假设所有建筑物都是在绝对平坦且高度为 0 的表面上的完美矩形。
 * 
 * 例如，图 A 中所有建筑物的尺寸记录为：[ [2 9 10], [3 7 15], [5 12 12], [15 20 10], [19 24 8] ]。
 * 输出是以 [ [x1,y1], [x2, y2], [x3, y3], ... ] 格式的“关键点”的列表，
 * 按 x 坐标进行排序。关键点是水平线段的左端点。最后一个点的 y 值始终为 0，
 * 仅用于标记天际线的终点。此外，任何两个相邻建筑物之间的地面都应被视为天际线轮廓的一部分。
 * 
 * 注意：输出天际线中不得有连续的相同高度的水平线。
 * 例如 [...[2 3], [4 5], [7 5], [11 5], [12 7]...] 是不正确的答案；
 * 三条高度为 5 的线应该在最终输出中合并为一个：[...[2 3], [4 5], [12 7], ...]
 * 
 * 示例 1：
 * 输入：buildings = [[2,9,10],[3,7,15],[5,12,12],[15,20,10],[19,24,8]]
 * 输出：[[2,10],[3,15],[7,12],[12,0],[15,10],[20,8],[24,0]]
 * 
 * 示例 2：
 * 输入：buildings = [[0,2,3],[2,5,3]]
 * 输出：[[0,3],[5,0]]
 * 
 * 提示：
 * 1 <= buildings.length <= 10^4
 * 0 <= lefti < righti <= 2^31 - 1
 * 1 <= heighti <= 2^31 - 1
 * buildings 按 lefti 非递减排序
 * 
 * 解题思路：
 * 使用扫描线算法解决天际线问题。核心思想是：
 * 1. 将每个建筑物的左右边界转换为事件点
 * 2. 对所有事件点按x坐标排序
 * 3. 使用优先队列维护当前活跃建筑物的高度
 * 4. 扫描所有事件点，更新天际线关键点
 * 
 * 时间复杂度：O(n log n)，其中 n 是建筑物的数量
 * 空间复杂度：O(n)
 * 
 * 相关题目：
 * - LeetCode 850. 矩形面积II
 * - LeetCode 391. 完美矩形
 */
public class LeetCode_218_TheSkylineProblem {
    
    /**
     * 天际线问题的扫描线解法
     * @param buildings 建筑物数组，每个建筑物是 [left, right, height] 形式
     * @return 天际线关键点列表
     */
    public static List<List<Integer>> getSkyline(int[][] buildings) {
        List<List<Integer>> result = new ArrayList<>();
        
        // 创建事件点列表：[x坐标, 高度变化]
        // 高度为负数表示建筑物开始，正数表示建筑物结束
        List<int[]> events = new ArrayList<>();
        
        for (int[] building : buildings) {
            int left = building[0];
            int right = building[1];
            int height = building[2];
            
            // 添加建筑物开始事件（高度为负数）
            events.add(new int[]{left, -height});
            // 添加建筑物结束事件（高度为正数）
            events.add(new int[]{right, height});
        }
        
        // 按照x坐标排序事件点
        // 如果x坐标相同，按照高度排序（开始事件优先于结束事件）
        events.sort((a, b) -> {
            if (a[0] != b[0]) {
                return Integer.compare(a[0], b[0]);
            }
            return Integer.compare(a[1], b[1]);
        });
        
        // 使用 TreeMap 维护当前活跃建筑物的高度及其计数
        // TreeMap 可以自动排序，便于获取最大高度
        TreeMap<Integer, Integer> heightMap = new TreeMap<>();
        // 初始高度为0
        heightMap.put(0, 1);
        
        int prevHeight = 0;
        
        // 扫描所有事件点
        for (int[] event : events) {
            int x = event[0];
            int height = event[1];
            
            if (height < 0) {
                // 建筑物开始事件
                int h = -height;
                heightMap.put(h, heightMap.getOrDefault(h, 0) + 1);
            } else {
                // 建筑物结束事件
                heightMap.put(height, heightMap.get(height) - 1);
                if (heightMap.get(height) == 0) {
                    heightMap.remove(height);
                }
            }
            
            // 获取当前最大高度
            int currentHeight = heightMap.lastKey();
            
            // 如果高度发生变化，添加关键点
            if (currentHeight != prevHeight) {
                result.add(Arrays.asList(x, currentHeight));
                prevHeight = currentHeight;
            }
        }
        
        return result;
    }
    
    /**
     * 测试天际线问题解法
     */
    public static void main(String[] args) {
        System.out.println("=== LeetCode 218. 天际线问题 ===");
        
        // 测试用例1
        System.out.println("测试用例1:");
        int[][] buildings1 = {
            {2, 9, 10}, {3, 7, 15}, {5, 12, 12}, {15, 20, 10}, {19, 24, 8}
        };
        List<List<Integer>> result1 = getSkyline(buildings1);
        System.out.println("输入: " + Arrays.deepToString(buildings1));
        System.out.println("输出: " + result1);
        System.out.println("期望: [[2,10],[3,15],[7,12],[12,0],[15,10],[20,8],[24,0]]");
        System.out.println();
        
        // 测试用例2
        System.out.println("测试用例2:");
        int[][] buildings2 = {
            {0, 2, 3}, {2, 5, 3}
        };
        List<List<Integer>> result2 = getSkyline(buildings2);
        System.out.println("输入: " + Arrays.deepToString(buildings2));
        System.out.println("输出: " + result2);
        System.out.println("期望: [[0,3],[5,0]]");
        System.out.println();
        
        // 性能测试
        System.out.println("=== 性能测试 ===");
        Random random = new Random(42);
        int n = 10000;
        int[][] buildings = new int[n][3];
        
        for (int i = 0; i < n; i++) {
            int left = random.nextInt(1000000);
            int right = left + random.nextInt(10000) + 1;
            int height = random.nextInt(1000000) + 1;
            buildings[i][0] = left;
            buildings[i][1] = right;
            buildings[i][2] = height;
        }
        
        long startTime = System.nanoTime();
        List<List<Integer>> result = getSkyline(buildings);
        long endTime = System.nanoTime();
        
        System.out.println("10000个建筑物的天际线计算完成");
        System.out.println("关键点数量: " + result.size());
        System.out.println("运行时间: " + (endTime - startTime) / 1_000_000.0 + " ms");
    }
}

===============================================

文件: leetcode_218_the_skyline_problem.cpp
===============================================
#include <iostream>
#include <vector>
#include <algorithm>
#include <map>
#include <set>
#include <random>
#include <chrono>

using namespace std;

using namespace std;

/**
 * LeetCode 218. 天际线问题 (The Skyline Problem)
 * 
 * 题目来源：https://leetcode.cn/problems/the-skyline-problem/
 * 
 * 题目描述：
 * 城市的天际线是从远处观看该城市中所有建筑物形成的轮廓的外部轮廓。
 * 现在，假设您获得了城市中所有建筑物的位置和高度，请编写一个程序来输出由这些建筑物形成的天际线。
 * 每个建筑物的几何信息用三元组 [Li, Ri, Hi] 表示，其中 Li 和 Ri 分别是第 i 座建筑物左右边缘的 x 坐标，
 * Hi 是其高度。可以保证 0 ≤ Li, Ri ≤ INT_MAX, 0 < Hi ≤ INT_MAX 和 Ri - Li > 0。
 * 您可以假设所有建筑物都是在绝对平坦且高度为 0 的表面上的完美矩形。
 * 
 * 例如，图 A 中所有建筑物的尺寸记录为：[ [2 9 10], [3 7 15], [5 12 12], [15 20 10], [19 24 8] ]。
 * 输出是以 [ [x1,y1], [x2, y2], [x3, y3], ... ] 格式的"关键点"的列表，
 * 按 x 坐标进行排序。关键点是水平线段的左端点。最后一个点的 y 值始终为 0，
 * 仅用于标记天际线的终点。此外，任何两个相邻建筑物之间的地面都应被视为天际线轮廓的一部分。
 * 
 * 注意：输出天际线中不得有连续的相同高度的水平线。
 * 例如 [...[2 3], [4 5], [7 5], [11 5], [12 7]...] 是不正确的答案；
 * 三条高度为 5 的线应该在最终输出中合并为一个：[...[2 3], [4 5], [12 7], ...]
 * 
 * 示例 1：
 * 输入：buildings = [[2,9,10],[3,7,15],[5,12,12],[15,20,10],[19,24,8]]
 * 输出：[[2,10],[3,15],[7,12],[12,0],[15,10],[20,8],[24,0]]
 * 
 * 示例 2：
 * 输入：buildings = [[0,2,3],[2,5,3]]
 * 输出：[[0,3],[5,0]]
 * 
 * 提示：
 * 1 <= buildings.length <= 10^4
 * 0 <= lefti < righti <= 2^31 - 1
 * 1 <= heighti <= 2^31 - 1
 * buildings 按 lefti 非递减排序
 * 
 * 解题思路：
 * 使用扫描线算法解决天际线问题。核心思想是：
 * 1. 将每个建筑物的左右边界转换为事件点
 * 2. 对所有事件点按x坐标排序
 * 3. 使用优先队列维护当前活跃建筑物的高度
 * 4. 扫描所有事件点，更新天际线关键点
 * 
 * 时间复杂度：O(n log n)，其中 n 是建筑物的数量
 * 空间复杂度：O(n)
 * 
 * 相关题目：
 * - LeetCode 850. 矩形面积II
 * - LeetCode 391. 完美矩形
 */

class Solution {
public:
    /**
     * 天际线问题的扫描线解法
     * @param buildings 建筑物数组，每个建筑物是 [left, right, height] 形式
     * @return 天际线关键点列表
     */
    static vector<vector<int>> getSkyline(vector<vector<int>>& buildings) {
        vector<vector<int>> result;
        
        // 创建事件点列表：[x坐标, 高度变化]
        // 高度为负数表示建筑物开始，正数表示建筑物结束
        vector<pair<int, int>> events;
        
        for (const auto& building : buildings) {
            int left = building[0];
            int right = building[1];
            int height = building[2];
            
            // 添加建筑物开始事件（高度为负数）
            events.emplace_back(left, -height);
            // 添加建筑物结束事件（高度为正数）
            events.emplace_back(right, height);
        }
        
        // 按照x坐标排序事件点
        // 如果x坐标相同，按照高度排序（开始事件优先于结束事件）
        sort(events.begin(), events.end());
        
        // 使用 map 维护当前活跃建筑物的高度及其计数
        // map 可以自动排序，便于获取最大高度
        map<int, int> heightMap;
        // 初始高度为0
        heightMap[0] = 1;
        
        int prevHeight = 0;
        
        // 扫描所有事件点
        for (const auto& event : events) {
            int x = event.first;
            int height = event.second;
            
            if (height < 0) {
                // 建筑物开始事件
                int h = -height;
                heightMap[h]++;
            } else {
                // 建筑物结束事件
                heightMap[height]--;
                if (heightMap[height] == 0) {
                    heightMap.erase(height);
                }
            }
            
            // 获取当前最大高度
            int currentHeight = heightMap.rbegin()->first;
            
            // 如果高度发生变化，添加关键点
            if (currentHeight != prevHeight) {
                result.push_back({x, currentHeight});
                prevHeight = currentHeight;
            }
        }
        
        return result;
    }
};

/**
 * 测试天际线问题解法
 */
void testSkyline() {
    cout << "=== LeetCode 218. 天际线问题 ===" << endl;
    
    // 测试用例1
    cout << "测试用例1:" << endl;
    vector<vector<int>> buildings1 = {
        {2, 9, 10}, {3, 7, 15}, {5, 12, 12}, {15, 20, 10}, {19, 24, 8}
    };
    vector<vector<int>> result1 = Solution::getSkyline(buildings1);
    cout << "输入: ";
    for (const auto& building : buildings1) {
        cout << "[" << building[0] << "," << building[1] << "," << building[2] << "] ";
    }
    cout << endl;
    cout << "输出: ";
    for (const auto& point : result1) {
        cout << "[" << point[0] << "," << point[1] << "] ";
    }
    cout << endl;
    cout << "期望: [[2,10],[3,15],[7,12],[12,0],[15,10],[20,8],[24,0]]" << endl;
    cout << endl;
    
    // 测试用例2
    cout << "测试用例2:" << endl;
    vector<vector<int>> buildings2 = {
        {0, 2, 3}, {2, 5, 3}
    };
    vector<vector<int>> result2 = Solution::getSkyline(buildings2);
    cout << "输入: ";
    for (const auto& building : buildings2) {
        cout << "[" << building[0] << "," << building[1] << "," << building[2] << "] ";
    }
    cout << endl;
    cout << "输出: ";
    for (const auto& point : result2) {
        cout << "[" << point[0] << "," << point[1] << "] ";
    }
    cout << endl;
    cout << "期望: [[0,3],[5,0]]" << endl;
    cout << endl;
    
    // 性能测试
    cout << "=== 性能测试 ===" << endl;
    random_device rd;
    mt19937 gen(rd());
    uniform_int_distribution<int> dis(0, 1000000);
    uniform_int_distribution<int> dis2(1, 10000);
    uniform_int_distribution<int> dis3(1, 1000000);
    
    int n = 10000;
    vector<vector<int>> buildings;
    
    for (int i = 0; i < n; i++) {
        int left = dis(gen);
        int right = left + dis2(gen);
        int height = dis3(gen);
        buildings.push_back({left, right, height});
    }
    
    auto startTime = chrono::high_resolution_clock::now();
    vector<vector<int>> result = Solution::getSkyline(buildings);
    auto endTime = chrono::high_resolution_clock::now();
    
    auto duration = chrono::duration_cast<chrono::microseconds>(endTime - startTime);
    
    cout << "10000个建筑物的天际线计算完成" << endl;
    cout << "关键点数量: " << result.size() << endl;
    cout << "运行时间: " << duration.count() / 1000.0 << " ms" << endl;
}

int main() {
    testSkyline();
    return 0;
}

===============================================

文件: leetcode_218_the_skyline_problem.py
===============================================
#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
LeetCode 218. 天际线问题 (The Skyline Problem)

题目来源：https://leetcode.cn/problems/the-skyline-problem/

题目描述：
城市的天际线是从远处观看该城市中所有建筑物形成的轮廓的外部轮廓。
现在，假设您获得了城市中所有建筑物的位置和高度，请编写一个程序来输出由这些建筑物形成的天际线。
每个建筑物的几何信息用三元组 [Li, Ri, Hi] 表示，其中 Li 和 Ri 分别是第 i 座建筑物左右边缘的 x 坐标，
Hi 是其高度。可以保证 0 ≤ Li, Ri ≤ INT_MAX, 0 < Hi ≤ INT_MAX 和 Ri - Li > 0。
您可以假设所有建筑物都是在绝对平坦且高度为 0 的表面上的完美矩形。

例如，图 A 中所有建筑物的尺寸记录为：[ [2 9 10], [3 7 15], [5 12 12], [15 20 10], [19 24 8] ]。
输出是以 [ [x1,y1], [x2, y2], [x3, y3], ... ] 格式的"关键点"的列表，
按 x 坐标进行排序。关键点是水平线段的左端点。最后一个点的 y 值始终为 0，
仅用于标记天际线的终点。此外，任何两个相邻建筑物之间的地面都应被视为天际线轮廓的一部分。

注意：输出天际线中不得有连续的相同高度的水平线。
例如 [...[2 3], [4 5], [7 5], [11 5], [12 7]...] 是不正确的答案；
三条高度为 5 的线应该在最终输出中合并为一个：[...[2 3], [4 5], [12 7], ...]

示例 1：
输入：buildings = [[2,9,10],[3,7,15],[5,12,12],[15,20,10],[19,24,8]]
输出：[[2,10],[3,15],[7,12],[12,0],[15,10],[20,8],[24,0]]

示例 2：
输入：buildings = [[0,2,3],[2,5,3]]
输出：[[0,3],[5,0]]

提示：
1 <= buildings.length <= 10^4
0 <= lefti < righti <= 2^31 - 1
1 <= heighti <= 2^31 - 1
buildings 按 lefti 非递减排序

解题思路：
使用扫描线算法解决天际线问题。核心思想是：
1. 将每个建筑物的左右边界转换为事件点
2. 对所有事件点按x坐标排序
3. 使用优先队列维护当前活跃建筑物的高度
4. 扫描所有事件点，更新天际线关键点

时间复杂度：O(n log n)，其中 n 是建筑物的数量
空间复杂度：O(n)

相关题目：
- LeetCode 850. 矩形面积II
- LeetCode 391. 完美矩形
"""

import heapq
from collections import defaultdict
import random
import time

class Solution:
    @staticmethod
    def get_skyline(buildings):
        """
        天际线问题的扫描线解法
        :param buildings: 建筑物数组，每个建筑物是 [left, right, height] 形式
        :return: 天际线关键点列表
        """
        # 创建事件点列表：[x坐标, 高度变化]
        # 高度为负数表示建筑物开始，正数表示建筑物结束
        events = []
        
        for left, right, height in buildings:
            # 添加建筑物开始事件（高度为负数）
            events.append([left, -height])
            # 添加建筑物结束事件（高度为正数）
            events.append([right, height])
        
        # 按照x坐标排序事件点
        # 如果x坐标相同，按照高度排序（开始事件优先于结束事件）
        events.sort()
        
        # 使用字典维护当前活跃建筑物的高度及其计数
        height_map = defaultdict(int)
        # 初始高度为0
        height_map[0] = 1
        
        result = []
        prev_height = 0
        
        # 扫描所有事件点
        for x, height in events:
            if height < 0:
                # 建筑物开始事件
                h = -height
                height_map[h] += 1
            else:
                # 建筑物结束事件
                height_map[height] -= 1
                if height_map[height] == 0:
                    del height_map[height]
            
            # 获取当前最大高度
            current_height = max(height_map.keys())
            
            # 如果高度发生变化，添加关键点
            if current_height != prev_height:
                result.append([x, current_height])
                prev_height = current_height
        
        return result
    
    @staticmethod
    def test_skyline():
        """测试天际线问题解法"""
        print("=== LeetCode 218. 天际线问题 ===")
        
        # 测试用例1
        print("测试用例1:")
        buildings1 = [
            [2, 9, 10], [3, 7, 15], [5, 12, 12], [15, 20, 10], [19, 24, 8]
        ]
        result1 = Solution.get_skyline(buildings1)
        print(f"输入: {buildings1}")
        print(f"输出: {result1}")
        print("期望: [[2,10],[3,15],[7,12],[12,0],[15,10],[20,8],[24,0]]")
        print()
        
        # 测试用例2
        print("测试用例2:")
        buildings2 = [
            [0, 2, 3], [2, 5, 3]
        ]
        result2 = Solution.get_skyline(buildings2)
        print(f"输入: {buildings2}")
        print(f"输出: {result2}")
        print("期望: [[0,3],[5,0]]")
        print()
        
        # 性能测试
        print("=== 性能测试 ===")
        random.seed(42)
        n = 10000
        buildings = []
        
        for _ in range(n):
            left = random.randint(0, 1000000)
            right = left + random.randint(1, 10000)
            height = random.randint(1, 1000000)
            buildings.append([left, right, height])
        
        start_time = time.time()
        result = Solution.get_skyline(buildings)
        end_time = time.time()
        
        print(f"10000个建筑物的天际线计算完成")
        print(f"关键点数量: {len(result)}")
        print(f"运行时间: {(end_time - start_time) * 1000:.2f} ms")

if __name__ == "__main__":
    Solution.test_skyline()

===============================================

文件: LeetCode_239_SlidingWindowMaximum.java
===============================================
package class008_AdvancedAlgorithmsAndDataStructures.sparse_table_problems;

import java.util.*;

/**
 * LeetCode 239. 滑动窗口最大值 (Sliding Window Maximum)
 * 
 * 题目来源：https://leetcode.cn/problems/sliding-window-maximum/
 * 
 * 题目描述：
 * 给你一个整数数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。
 * 你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。
 * 返回滑动窗口中的最大值。
 * 
 * 算法思路：
 * 这个问题可以通过以下方法解决：
 * 1. 稀疏表：预处理范围最大值查询
 * 2. 双端队列：维护单调递减队列
 * 3. 分块：将数组分块预处理
 * 
 * 使用稀疏表的方法：
 * 1. 预处理稀疏表用于范围最大值查询
 * 2. 对于每个滑动窗口，使用稀疏表查询最大值
 * 
 * 时间复杂度：
 * - 稀疏表预处理：O(n log n)
 * - 查询：O(1)
 * - 总时间复杂度：O(n log n)
 * - 双端队列：O(n)
 * - 空间复杂度：O(n log n)
 * 
 * 应用场景：
 * 1. 信号处理：滑动窗口数据分析
 * 2. 金融：股票价格极值分析
 * 3. 图像处理：区域特征提取
 * 
 * 相关题目：
 * 1. LeetCode 2444. 统计定界子数组的数目
 * 2. LeetCode 315. 计算右侧小于当前元素的个数
 * 3. LeetCode 1584. 连接所有点的最小费用
 */
public class LeetCode_239_SlidingWindowMaximum {
    
    /**
     * 稀疏表类，用于范围最大值查询
     */
    static class SparseTable {
        private int[] data;
        private int[][] stMax;  // 用于范围最大值查询的稀疏表
        private int[] logTable;
        private int n;
        
        /**
         * 构造函数
         * @param data 输入数组
         */
        public SparseTable(int[] data) {
            if (data == null || data.length == 0) {
                throw new IllegalArgumentException("输入数组不能为空");
            }
            
            this.data = data.clone();
            this.n = data.length;
            
            // 预计算log表
            precomputeLogTable();
            
            // 构建稀疏表
            buildSparseTable();
        }
        
        /**
         * 预计算log2值表
         */
        private void precomputeLogTable() {
            logTable = new int[n + 1];
            logTable[1] = 0;
            for (int i = 2; i <= n; i++) {
                logTable[i] = logTable[i / 2] + 1;
            }
        }
        
        /**
         * 构建稀疏表
         */
        private void buildSparseTable() {
            int k = logTable[n] + 1;
            
            // 初始化稀疏表
            stMax = new int[k][n];
            
            // 初始化k=0的情况（长度为1的区间）
            for (int i = 0; i < n; i++) {
                stMax[0][i] = data[i];
            }
            
            // 动态规划构建其他k值
            for (int j = 1; (1 << j) <= n; j++) {
                for (int i = 0; i + (1 << j) <= n; i++) {
                    int prevLen = 1 << (j - 1);
                    // 范围最大值查询
                    stMax[j][i] = Math.max(stMax[j-1][i], stMax[j-1][i + prevLen]);
                }
            }
        }
        
        /**
         * 范围最大值查询
         * 时间复杂度：O(1)
         * @param left 左边界（包含）
         * @param right 右边界（包含）
         * @return 区间内的最大值
         */
        public int queryMax(int left, int right) {
            if (left < 0 || right >= n || left > right) {
                throw new IllegalArgumentException("查询范围无效");
            }
            
            int length = right - left + 1;
            int k = logTable[length];
            
            return Math.max(stMax[k][left], stMax[k][right - (1 << k) + 1]);
        }
    }
    
    /**
     * 方法1：使用稀疏表的解法
     * 时间复杂度：O(n log n)
     * 空间复杂度：O(n log n)
     * @param nums 输入数组
     * @param k 窗口大小
     * @return 滑动窗口最大值数组
     */
    public static int[] maxSlidingWindowSparseTable(int[] nums, int k) {
        int n = nums.length;
        if (n == 0 || k == 0) return new int[0];
        if (k == 1) return nums.clone();
        
        // 构建稀疏表
        SparseTable st = new SparseTable(nums);
        
        // 计算结果数组大小
        int resultSize = n - k + 1;
        int[] result = new int[resultSize];
        
        // 对于每个滑动窗口，查询最大值
        for (int i = 0; i < resultSize; i++) {
            result[i] = st.queryMax(i, i + k - 1);
        }
        
        return result;
    }
    
    /**
     * 方法2：双端队列解法（最优解）
     * 时间复杂度：O(n)
     * 空间复杂度：O(k)
     * @param nums 输入数组
     * @param k 窗口大小
     * @return 滑动窗口最大值数组
     */
    public static int[] maxSlidingWindowDeque(int[] nums, int k) {
        int n = nums.length;
        if (n == 0 || k == 0) return new int[0];
        if (k == 1) return nums.clone();
        
        // 双端队列，存储数组索引
        Deque<Integer> deque = new LinkedList<>();
        int[] result = new int[n - k + 1];
        
        for (int i = 0; i < n; i++) {
            // 移除队列中超出窗口范围的索引
            while (!deque.isEmpty() && deque.peekFirst() < i - k + 1) {
                deque.pollFirst();
            }
            
            // 移除队列中所有小于当前元素的索引（维护单调递减）
            while (!deque.isEmpty() && nums[deque.peekLast()] < nums[i]) {
                deque.pollLast();
            }
            
            // 添加当前索引
            deque.offerLast(i);
            
            // 如果窗口已形成，记录最大值
            if (i >= k - 1) {
                result[i - k + 1] = nums[deque.peekFirst()];
            }
        }
        
        return result;
    }
    
    /**
     * 方法3：分块预处理解法
     * 时间复杂度：O(n)
     * 空间复杂度：O(n)
     * @param nums 输入数组
     * @param k 窗口大小
     * @return 滑动窗口最大值数组
     */
    public static int[] maxSlidingWindowBlock(int[] nums, int k) {
        int n = nums.length;
        if (n == 0 || k == 0) return new int[0];
        if (k == 1) return nums.clone();
        
        // 分块大小
        int blockSize = k;
        int blocks = (n + blockSize - 1) / blockSize;
        
        // 预处理前缀最大值和后缀最大值
        int[] prefixMax = new int[n];
        int[] suffixMax = new int[n];
        
        // 计算前缀最大值
        for (int i = 0; i < n; i++) {
            if (i % blockSize == 0) {
                prefixMax[i] = nums[i];
            } else {
                prefixMax[i] = Math.max(prefixMax[i - 1], nums[i]);
            }
        }
        
        // 计算后缀最大值
        for (int i = n - 1; i >= 0; i--) {
            if (i == n - 1 || (i + 1) % blockSize == 0) {
                suffixMax[i] = nums[i];
            } else {
                suffixMax[i] = Math.max(suffixMax[i + 1], nums[i]);
            }
        }
        
        // 计算结果
        int[] result = new int[n - k + 1];
        for (int i = 0; i <= n - k; i++) {
            int blockStart = i / blockSize;
            int blockEnd = (i + k - 1) / blockSize;
            
            if (blockStart == blockEnd) {
                // 窗口在一个块内
                result[i] = suffixMax[i];
            } else {
                // 窗口跨越多个块
                int max1 = suffixMax[i]; // 块内前缀最大值
                int max2 = prefixMax[i + k - 1]; // 块内后缀最大值
                result[i] = Math.max(max1, max2);
            }
        }
        
        return result;
    }
    
    /**
     * 方法4：暴力解法（用于对比）
     * 时间复杂度：O(nk)
     * 空间复杂度：O(1)
     * @param nums 输入数组
     * @param k 窗口大小
     * @return 滑动窗口最大值数组
     */
    public static int[] maxSlidingWindowBruteForce(int[] nums, int k) {
        int n = nums.length;
        if (n == 0 || k == 0) return new int[0];
        
        int[] result = new int[n - k + 1];
        
        for (int i = 0; i <= n - k; i++) {
            int max = nums[i];
            for (int j = 1; j < k; j++) {
                max = Math.max(max, nums[i + j]);
            }
            result[i] = max;
        }
        
        return result;
    }
    
    /**
     * 测试函数
     */
    public static void main(String[] args) {
        System.out.println("=== 测试 LeetCode 239. 滑动窗口最大值 ===");
        
        // 测试用例1
        int[] nums1 = {1,3,-1,-3,5,3,6,7};
        int k1 = 3;
        System.out.println("测试用例1:");
        System.out.println("数组: [1,3,-1,-3,5,3,6,7], k: " + k1);
        System.out.println("稀疏表解法结果: " + Arrays.toString(maxSlidingWindowSparseTable(nums1, k1)));
        System.out.println("双端队列解法结果: " + Arrays.toString(maxSlidingWindowDeque(nums1, k1)));
        System.out.println("分块解法结果: " + Arrays.toString(maxSlidingWindowBlock(nums1, k1)));
        System.out.println("暴力解法结果: " + Arrays.toString(maxSlidingWindowBruteForce(nums1, k1)));
        System.out.println("期望结果: [3,3,5,5,6,7]");
        System.out.println();
        
        // 测试用例2
        int[] nums2 = {1};
        int k2 = 1;
        System.out.println("测试用例2:");
        System.out.println("数组: [1], k: " + k2);
        System.out.println("稀疏表解法结果: " + Arrays.toString(maxSlidingWindowSparseTable(nums2, k2)));
        System.out.println("双端队列解法结果: " + Arrays.toString(maxSlidingWindowDeque(nums2, k2)));
        System.out.println("分块解法结果: " + Arrays.toString(maxSlidingWindowBlock(nums2, k2)));
        System.out.println("暴力解法结果: " + Arrays.toString(maxSlidingWindowBruteForce(nums2, k2)));
        System.out.println("期望结果: [1]");
        System.out.println();
        
        // 测试用例3
        int[] nums3 = {1,-1};
        int k3 = 1;
        System.out.println("测试用例3:");
        System.out.println("数组: [1,-1], k: " + k3);
        System.out.println("稀疏表解法结果: " + Arrays.toString(maxSlidingWindowSparseTable(nums3, k3)));
        System.out.println("双端队列解法结果: " + Arrays.toString(maxSlidingWindowDeque(nums3, k3)));
        System.out.println("分块解法结果: " + Arrays.toString(maxSlidingWindowBlock(nums3, k3)));
        System.out.println("暴力解法结果: " + Arrays.toString(maxSlidingWindowBruteForce(nums3, k3)));
        System.out.println("期望结果: [1,-1]");
        System.out.println();
        
        // 性能测试
        System.out.println("=== 性能测试 ===");
        Random random = new Random(42);
        int arraySize = 100000;
        int[] nums = new int[arraySize];
        for (int i = 0; i < arraySize; i++) {
            nums[i] = random.nextInt(10000) - 5000; // 范围[-5000, 4999]
        }
        int k = 1000;
        
        long startTime = System.nanoTime();
        int[] result1 = maxSlidingWindowSparseTable(nums, k);
        long endTime = System.nanoTime();
        System.out.println("稀疏表解法处理" + arraySize + "个元素,k=" + k + "时间: " + (endTime - startTime) / 1_000_000.0 + " ms");
        
        startTime = System.nanoTime();
        int[] result2 = maxSlidingWindowDeque(nums, k);
        endTime = System.nanoTime();
        System.out.println("双端队列解法处理" + arraySize + "个元素,k=" + k + "时间: " + (endTime - startTime) / 1_000_000.0 + " ms");
        
        startTime = System.nanoTime();
        int[] result3 = maxSlidingWindowBlock(nums, k);
        endTime = System.nanoTime();
        System.out.println("分块解法处理" + arraySize + "个元素,k=" + k + "时间: " + (endTime - startTime) / 1_000_000.0 + " ms");
        
        startTime = System.nanoTime();
        int[] result4 = maxSlidingWindowBruteForce(nums, k);
        endTime = System.nanoTime();
        System.out.println("暴力解法处理" + arraySize + "个元素,k=" + k + "时间: " + (endTime - startTime) / 1_000_000.0 + " ms");
        
        // 验证结果一致性
        System.out.println("结果一致性检查: " + 
            (Arrays.equals(result1, result2) && Arrays.equals(result2, result3) && Arrays.equals(result3, result4) ? 
            "通过" : "失败"));
    }
}

===============================================

文件: leetcode_239_sliding_window_maximum.cpp
===============================================
// LeetCode 239 Sliding Window Maximum
// C++ 实现

/**
 * LeetCode 239 Sliding Window Maximum
 * 
 * 题目描述：
 * 给你一个整数数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。
 * 你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。
 * 返回滑动窗口中的最大值。
 * 
 * 解题思路：
 * 我们可以使用稀疏表来预处理数组，然后对每个窗口查询最大值。
 * 1. 使用稀疏表预处理数组，构建RMQ数据结构
 * 2. 对每个窗口使用稀疏表查询最大值
 * 
 * 时间复杂度：O(n log n + m)
 * 空间复杂度：O(n log n)
 */

// 由于编译环境限制，这里提供算法思路和伪代码实现

/*
#include <stdlib.h>
#include <math.h>

int* maxSlidingWindow(int* nums, int numsSize, int k, int* returnSize) {
    if (numsSize == 0 || k == 0) {
        *returnSize = 0;
        return NULL;
    }
    
    // 计算稀疏表的大小
    int logSize = (int)(log2(numsSize)) + 1;
    
    // 创建稀疏表
    int** sparseTable = (int**)malloc(numsSize * sizeof(int*));
    for (int i = 0; i < numsSize; i++) {
        sparseTable[i] = (int*)malloc(logSize * sizeof(int));
        sparseTable[i][0] = nums[i];
    }
    
    // 构建稀疏表
    for (int j = 1; (1 << j) <= numsSize; j++) {
        for (int i = 0; i + (1 << j) - 1 < numsSize; i++) {
            sparseTable[i][j] = (sparseTable[i][j-1] > sparseTable[i + (1 << (j-1))][j-1]) ? 
                               sparseTable[i][j-1] : sparseTable[i + (1 << (j-1))][j-1];
        }
    }
    
    // 查询每个窗口的最大值
    int resultSize = numsSize - k + 1;
    int* result = (int*)malloc(resultSize * sizeof(int));
    *returnSize = resultSize;
    
    for (int i = 0; i < resultSize; i++) {
        int l = i, r = i + k - 1;
        int len = r - l + 1;
        int logLen = (int)(log2(len));
        int max1 = sparseTable[l][logLen];
        int max2 = sparseTable[r - (1 << logLen) + 1][logLen];
        result[i] = (max1 > max2) ? max1 : max2;
    }
    
    // 释放内存
    for (int i = 0; i < numsSize; i++) {
        free(sparseTable[i]);
    }
    free(sparseTable);
    
    return result;
}

// 算法核心思想：
// 1. 使用稀疏表预处理数组，构建RMQ数据结构
// 2. 对每个窗口使用稀疏表查询最大值

// 时间复杂度分析：
// - 构建稀疏表：O(n log n)
// - 查询每个窗口：O(1)
// - 总体时间复杂度：O(n log n + m)
// - 空间复杂度：O(n log n)
*/

// 算法应用场景：
// 1. 滑动窗口问题
// 2. RMQ问题
// 3. 稀疏表应用

===============================================

文件: leetcode_239_sliding_window_maximum.py
===============================================
#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
LeetCode 239 Sliding Window Maximum

题目描述：
给你一个整数数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。
你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。
返回滑动窗口中的最大值。

解题思路：
我们可以使用稀疏表来预处理数组，然后对每个窗口查询最大值。
1. 使用稀疏表预处理数组，构建RMQ数据结构
2. 对每个窗口使用稀疏表查询最大值

时间复杂度：O(n log n + m)
空间复杂度：O(n log n)
"""

import math

class Solution:
    def max_sliding_window(self, nums, k):
        """
        计算滑动窗口中的最大值
        
        Args:
            nums: 输入数组
            k: 窗口大小
            
        Returns:
            每个窗口中的最大值列表
        """
        if not nums or k == 0:
            return []
        
        n = len(nums)
        
        # 计算稀疏表的大小
        log_size = int(math.log2(n)) + 1
        
        # 创建稀疏表
        sparse_table = [[0] * log_size for _ in range(n)]
        
        # 初始化稀疏表的第一列
        for i in range(n):
            sparse_table[i][0] = nums[i]
        
        # 构建稀疏表
        for j in range(1, log_size):
            for i in range(n - (1 << j) + 1):
                sparse_table[i][j] = max(
                    sparse_table[i][j-1],
                    sparse_table[i + (1 << (j-1))][j-1]
                )
        
        # 查询每个窗口的最大值
        result = []
        for i in range(n - k + 1):
            l, r = i, i + k - 1
            length = r - l + 1
            log_length = int(math.log2(length))
            max1 = sparse_table[l][log_length]
            max2 = sparse_table[r - (1 << log_length) + 1][log_length]
            result.append(max(max1, max2))
        
        return result


# 测试方法
def main():
    solution = Solution()
    
    # 测试用例1
    nums1 = [1, 3, -1, -3, 5, 3, 6, 7]
    k1 = 3
    print("测试用例1:")
    print("数组:", nums1)
    print("窗口大小:", k1)
    print("结果:", solution.max_sliding_window(nums1, k1))
    print()
    
    # 测试用例2
    nums2 = [1]
    k2 = 1
    print("测试用例2:")
    print("数组:", nums2)
    print("窗口大小:", k2)
    print("结果:", solution.max_sliding_window(nums2, k2))
    print()
    
    # 测试用例3
    nums3 = [1, -1]
    k3 = 1
    print("测试用例3:")
    print("数组:", nums3)
    print("窗口大小:", k3)
    print("结果:", solution.max_sliding_window(nums3, k3))


if __name__ == "__main__":
    main()

===============================================

文件: LeetCode_2444_CountSubarraysWithFixedBounds.java
===============================================
package class008_AdvancedAlgorithmsAndDataStructures.sparse_table_problems;

import java.util.*;

/**
 * LeetCode 2444. 统计定界子数组的数目 (Count Subarrays With Fixed Bounds)
 * 
 * 题目来源：https://leetcode.cn/problems/count-subarrays-with-fixed-bounds/
 * 
 * 题目描述：
 * 给你一个整数数组 nums 和两个整数 minK 以及 maxK。
 * nums 的定界子数组是满足下述条件的一个子数组：
 * - 子数组中的最小值等于 minK。
 * - 子数组中的最大值等于 maxK。
 * 返回定界子数组的数目。
 * 子数组是数组中的一个连续部分。
 * 
 * 算法思路：
 * 这个问题可以通过以下方法解决：
 * 1. 滑动窗口：维护满足条件的窗口
 * 2. 稀疏表：预处理范围最值查询，然后枚举所有可能的子数组
 * 3. 数学方法：通过计算包含minK和maxK的子数组数量
 * 
 * 使用稀疏表的方法：
 * 1. 预处理稀疏表用于范围最值查询
 * 2. 对于每个左端点，使用二分查找找到满足条件的右端点范围
 * 
 * 时间复杂度：
 * - 稀疏表预处理：O(n log n)
 * - 查询：O(1)
 * - 总时间复杂度：O(n²)（最坏情况）或O(n log n)（优化后）
 * - 空间复杂度：O(n log n)
 * 
 * 应用场景：
 * 1. 数据分析：统计满足特定条件的连续数据段
 * 2. 金融：分析价格波动区间
 * 3. 信号处理：检测特定幅度的信号段
 * 
 * 相关题目：
 * 1. LeetCode 315. 计算右侧小于当前元素的个数
 * 2. LeetCode 743. 网络延迟时间
 * 3. LeetCode 1584. 连接所有点的最小费用
 */
public class LeetCode_2444_CountSubarraysWithFixedBounds {
    
    /**
     * 稀疏表类，用于范围最值查询
     */
    static class SparseTable {
        private int[] data;
        private int[][] stMin;  // 用于范围最小值查询的稀疏表
        private int[][] stMax;  // 用于范围最大值查询的稀疏表
        private int[] logTable;
        private int n;
        
        /**
         * 构造函数
         * @param data 输入数组
         */
        public SparseTable(int[] data) {
            if (data == null || data.length == 0) {
                throw new IllegalArgumentException("输入数组不能为空");
            }
            
            this.data = data.clone();
            this.n = data.length;
            
            // 预计算log表
            precomputeLogTable();
            
            // 构建稀疏表
            buildSparseTable();
        }
        
        /**
         * 预计算log2值表
         */
        private void precomputeLogTable() {
            logTable = new int[n + 1];
            logTable[1] = 0;
            for (int i = 2; i <= n; i++) {
                logTable[i] = logTable[i / 2] + 1;
            }
        }
        
        /**
         * 构建稀疏表
         */
        private void buildSparseTable() {
            int k = logTable[n] + 1;
            
            // 初始化稀疏表
            stMin = new int[k][n];
            stMax = new int[k][n];
            
            // 初始化k=0的情况（长度为1的区间）
            for (int i = 0; i < n; i++) {
                stMin[0][i] = data[i];
                stMax[0][i] = data[i];
            }
            
            // 动态规划构建其他k值
            for (int j = 1; (1 << j) <= n; j++) {
                for (int i = 0; i + (1 << j) <= n; i++) {
                    int prevLen = 1 << (j - 1);
                    // 范围最小值查询
                    stMin[j][i] = Math.min(stMin[j-1][i], stMin[j-1][i + prevLen]);
                    // 范围最大值查询
                    stMax[j][i] = Math.max(stMax[j-1][i], stMax[j-1][i + prevLen]);
                }
            }
        }
        
        /**
         * 范围最小值查询
         * 时间复杂度：O(1)
         * @param left 左边界（包含）
         * @param right 右边界（包含）
         * @return 区间内的最小值
         */
        public int queryMin(int left, int right) {
            if (left < 0 || right >= n || left > right) {
                throw new IllegalArgumentException("查询范围无效");
            }
            
            int length = right - left + 1;
            int k = logTable[length];
            
            return Math.min(stMin[k][left], stMin[k][right - (1 << k) + 1]);
        }
        
        /**
         * 范围最大值查询
         * 时间复杂度：O(1)
         * @param left 左边界（包含）
         * @param right 右边界（包含）
         * @return 区间内的最大值
         */
        public int queryMax(int left, int right) {
            if (left < 0 || right >= n || left > right) {
                throw new IllegalArgumentException("查询范围无效");
            }
            
            int length = right - left + 1;
            int k = logTable[length];
            
            return Math.max(stMax[k][left], stMax[k][right - (1 << k) + 1]);
        }
    }
    
    /**
     * 方法1：使用稀疏表的解法
     * 时间复杂度：O(n log n)
     * 空间复杂度：O(n log n)
     * @param nums 输入数组
     * @param minK 最小值边界
     * @param maxK 最大值边界
     * @return 定界子数组的数目
     */
    public static long countSubarraysWithSparseTable(int[] nums, int minK, int maxK) {
        int n = nums.length;
        if (n == 0) return 0;
        
        // 构建稀疏表
        SparseTable st = new SparseTable(nums);
        
        long count = 0;
        
        // 对于每个左端点，找到满足条件的右端点范围
        for (int i = 0; i < n; i++) {
            // 跳过不满足边界条件的元素
            if (nums[i] < minK || nums[i] > maxK) {
                continue;
            }
            
            // 使用二分查找找到满足条件的右端点范围
            int leftBound = i;
            int rightBound = n - 1;
            int validRightStart = -1;
            int validRightEnd = -1;
            
            // 找到第一个满足条件的右端点
            int low = i, high = n - 1;
            while (low <= high) {
                int mid = (low + high) / 2;
                int minVal = st.queryMin(i, mid);
                int maxVal = st.queryMax(i, mid);
                
                if (minVal == minK && maxVal == maxK) {
                    validRightStart = mid;
                    high = mid - 1;
                } else if (minVal < minK || maxVal > maxK) {
                    low = mid + 1;
                } else {
                    low = mid + 1;
                }
            }
            
            if (validRightStart == -1) {
                continue;
            }
            
            // 找到最后一个满足条件的右端点
            low = validRightStart;
            high = n - 1;
            while (low <= high) {
                int mid = (low + high) / 2;
                int minVal = st.queryMin(i, mid);
                int maxVal = st.queryMax(i, mid);
                
                if (minVal == minK && maxVal == maxK) {
                    validRightEnd = mid;
                    low = mid + 1;
                } else if (minVal < minK || maxVal > maxK) {
                    high = mid - 1;
                } else {
                    low = mid + 1;
                }
            }
            
            // 计算满足条件的子数组数量
            if (validRightStart != -1 && validRightEnd != -1) {
                count += validRightEnd - validRightStart + 1;
            }
        }
        
        return count;
    }
    
    /**
     * 方法2：优化的数学解法（最优解）
     * 时间复杂度：O(n)
     * 空间复杂度：O(1)
     * @param nums 输入数组
     * @param minK 最小值边界
     * @param maxK 最大值边界
     * @return 定界子数组的数目
     */
    public static long countSubarraysOptimized(int[] nums, int minK, int maxK) {
        long result = 0;
        int badIdx = -1, leftIdx = -1, rightIdx = -1;
        
        for (int i = 0; i < nums.length; ++i) {
            // 如果当前元素超出边界，则更新badIdx
            if (!(minK <= nums[i] && nums[i] <= maxK)) {
                badIdx = i;
            }
            
            // 更新最近的minK位置
            if (nums[i] == minK) {
                leftIdx = i;
            }
            
            // 更新最近的maxK位置
            if (nums[i] == maxK) {
                rightIdx = i;
            }
            
            // 计算以当前位置结尾的有效子数组数量
            result += Math.max(0, Math.min(leftIdx, rightIdx) - badIdx);
        }
        
        return result;
    }
    
    /**
     * 方法3：滑动窗口解法
     * 时间复杂度：O(n)
     * 空间复杂度：O(1)
     * @param nums 输入数组
     * @param minK 最小值边界
     * @param maxK 最大值边界
     * @return 定界子数组的数目
     */
    public static long countSubarraysSlidingWindow(int[] nums, int minK, int maxK) {
        long result = 0;
        int start = 0;
        int minPos = -1, maxPos = -1;
        
        for (int i = 0; i < nums.length; i++) {
            // 如果当前元素超出边界，重置窗口
            if (nums[i] < minK || nums[i] > maxK) {
                start = i + 1;
                minPos = -1;
                maxPos = -1;
            } else {
                // 更新minK和maxK的位置
                if (nums[i] == minK) {
                    minPos = i;
                }
                if (nums[i] == maxK) {
                    maxPos = i;
                }
                
                // 如果已经找到minK和maxK，计算有效子数组数量
                if (minPos != -1 && maxPos != -1) {
                    result += Math.min(minPos, maxPos) - start + 1;
                }
            }
        }
        
        return result;
    }
    
    /**
     * 测试函数
     */
    public static void main(String[] args) {
        System.out.println("=== 测试 LeetCode 2444. 统计定界子数组的数目 ===");
        
        // 测试用例1
        int[] nums1 = {1, 3, 5, 2, 7, 5};
        int minK1 = 1, maxK1 = 5;
        System.out.println("测试用例1:");
        System.out.println("数组: " + Arrays.toString(nums1));
        System.out.println("minK: " + minK1 + ", maxK: " + maxK1);
        System.out.println("稀疏表解法结果: " + countSubarraysWithSparseTable(nums1, minK1, maxK1));
        System.out.println("优化解法结果: " + countSubarraysOptimized(nums1, minK1, maxK1));
        System.out.println("滑动窗口解法结果: " + countSubarraysSlidingWindow(nums1, minK1, maxK1));
        System.out.println("期望结果: 2");
        System.out.println();
        
        // 测试用例2
        int[] nums2 = {1, 1, 1, 1};
        int minK2 = 1, maxK2 = 1;
        System.out.println("测试用例2:");
        System.out.println("数组: " + Arrays.toString(nums2));
        System.out.println("minK: " + minK2 + ", maxK: " + maxK2);
        System.out.println("稀疏表解法结果: " + countSubarraysWithSparseTable(nums2, minK2, maxK2));
        System.out.println("优化解法结果: " + countSubarraysOptimized(nums2, minK2, maxK2));
        System.out.println("滑动窗口解法结果: " + countSubarraysSlidingWindow(nums2, minK2, maxK2));
        System.out.println("期望结果: 10");
        System.out.println();
        
        // 测试用例3
        int[] nums3 = {1, 3, 5, 2, 7, 5, 1, 3, 5};
        int minK3 = 1, maxK3 = 5;
        System.out.println("测试用例3:");
        System.out.println("数组: " + Arrays.toString(nums3));
        System.out.println("minK: " + minK3 + ", maxK: " + maxK3);
        System.out.println("稀疏表解法结果: " + countSubarraysWithSparseTable(nums3, minK3, maxK3));
        System.out.println("优化解法结果: " + countSubarraysOptimized(nums3, minK3, maxK3));
        System.out.println("滑动窗口解法结果: " + countSubarraysSlidingWindow(nums3, minK3, maxK3));
        System.out.println();
        
        // 性能测试
        System.out.println("=== 性能测试 ===");
        Random random = new Random(42);
        int arraySize = 10000;
        int[] nums = new int[arraySize];
        for (int i = 0; i < arraySize; i++) {
            nums[i] = random.nextInt(100) + 1;
        }
        int minK = 10, maxK = 50;
        
        long startTime = System.nanoTime();
        long result1 = countSubarraysOptimized(nums, minK, maxK);
        long endTime = System.nanoTime();
        System.out.println("优化解法处理" + arraySize + "个元素时间: " + (endTime - startTime) / 1_000_000.0 + " ms, 结果: " + result1);
        
        startTime = System.nanoTime();
        long result2 = countSubarraysSlidingWindow(nums, minK, maxK);
        endTime = System.nanoTime();
        System.out.println("滑动窗口解法处理" + arraySize + "个元素时间: " + (endTime - startTime) / 1_000_000.0 + " ms, 结果: " + result2);
    }
}

===============================================

文件: leetcode_2444_count_subarrays_with_fixed_bounds.cpp
===============================================
#include <iostream>
#include <vector>
#include <algorithm>
#include <climits>
#include <chrono>
#include <random>
#include <stdexcept>

using namespace std;

/**
 * LeetCode 2444. 统计定界子数组的数目 (Count Subarrays With Fixed Bounds) - C++版本
 * 
 * 题目来源：https://leetcode.cn/problems/count-subarrays-with-fixed-bounds/
 * 
 * 题目描述：
 * 给你一个整数数组 nums 和两个整数 minK 以及 maxK。
 * nums 的定界子数组是满足下述条件的一个子数组：
 * - 子数组中的最小值等于 minK。
 * - 子数组中的最大值等于 maxK。
 * 返回定界子数组的数目。
 * 子数组是数组中的一个连续部分。
 * 
 * 算法思路：
 * 这个问题可以通过以下方法解决：
 * 1. 滑动窗口：维护满足条件的窗口
 * 2. 稀疏表：预处理范围最值查询，然后枚举所有可能的子数组
 * 3. 数学方法：通过计算包含minK和maxK的子数组数量
 * 
 * 使用稀疏表的方法：
 * 1. 预处理稀疏表用于范围最值查询
 * 2. 对于每个左端点，使用二分查找找到满足条件的右端点范围
 * 
 * 时间复杂度：
 * - 稀疏表预处理：O(n log n)
 * - 查询：O(1)
 * - 总时间复杂度：O(n²)（最坏情况）或O(n log n)（优化后）
 * - 空间复杂度：O(n log n)
 * 
 * 应用场景：
 * 1. 数据分析：统计满足特定条件的连续数据段
 * 2. 金融：分析价格波动区间
 * 3. 信号处理：检测特定幅度的信号段
 * 
 * 相关题目：
 * 1. LeetCode 315. 计算右侧小于当前元素的个数
 * 2. LeetCode 743. 网络延迟时间
 * 3. LeetCode 1584. 连接所有点的最小费用
 */

class SparseTable {
private:
    vector<int> data;
    vector<vector<int>> stMin;  // 用于范围最小值查询的稀疏表
    vector<vector<int>> stMax;  // 用于范围最大值查询的稀疏表
    vector<int> logTable;
    int n;

public:
    /**
     * 构造函数
     * @param data 输入数组
     */
    SparseTable(const vector<int>& data) {
        if (data.empty()) {
            throw invalid_argument("输入数组不能为空");
        }
        
        this->data = data;
        this->n = data.size();
        
        // 预计算log表
        precomputeLogTable();
        
        // 构建稀疏表
        buildSparseTable();
    }
    
    /**
     * 预计算log2值表
     */
    void precomputeLogTable() {
        logTable.resize(n + 1);
        logTable[1] = 0;
        for (int i = 2; i <= n; i++) {
            logTable[i] = logTable[i / 2] + 1;
        }
    }
    
    /**
     * 构建稀疏表
     */
    void buildSparseTable() {
        int k = logTable[n] + 1;
        
        // 初始化稀疏表
        stMin.assign(k, vector<int>(n));
        stMax.assign(k, vector<int>(n));
        
        // 初始化k=0的情况（长度为1的区间）
        for (int i = 0; i < n; i++) {
            stMin[0][i] = data[i];
            stMax[0][i] = data[i];
        }
        
        // 动态规划构建其他k值
        for (int j = 1; (1 << j) <= n; j++) {
            for (int i = 0; i + (1 << j) <= n; i++) {
                int prevLen = 1 << (j - 1);
                // 范围最小值查询
                stMin[j][i] = min(stMin[j-1][i], stMin[j-1][i + prevLen]);
                // 范围最大值查询
                stMax[j][i] = max(stMax[j-1][i], stMax[j-1][i + prevLen]);
            }
        }
    }
    
    /**
     * 范围最小值查询
     * 时间复杂度：O(1)
     * @param left 左边界（包含）
     * @param right 右边界（包含）
     * @return 区间内的最小值
     */
    int queryMin(int left, int right) const {
        if (left < 0 || right >= n || left > right) {
            throw invalid_argument("查询范围无效");
        }
        
        int length = right - left + 1;
        int k = logTable[length];
        
        return min(stMin[k][left], stMin[k][right - (1 << k) + 1]);
    }
    
    /**
     * 范围最大值查询
     * 时间复杂度：O(1)
     * @param left 左边界（包含）
     * @param right 右边界（包含）
     * @return 区间内的最大值
     */
    int queryMax(int left, int right) const {
        if (left < 0 || right >= n || left > right) {
            throw invalid_argument("查询范围无效");
        }
        
        int length = right - left + 1;
        int k = logTable[length];
        
        return max(stMax[k][left], stMax[k][right - (1 << k) + 1]);
    }
};

/**
 * 方法1：使用稀疏表的解法
 * 时间复杂度：O(n log n)
 * 空间复杂度：O(n log n)
 * @param nums 输入数组
 * @param minK 最小值边界
 * @param maxK 最大值边界
 * @return 定界子数组的数目
 */
long long countSubarraysWithSparseTable(const vector<int>& nums, int minK, int maxK) {
    int n = nums.size();
    if (n == 0) return 0;
    
    // 构建稀疏表
    SparseTable st(nums);
    
    long long count = 0;
    
    // 对于每个左端点，找到满足条件的右端点范围
    for (int i = 0; i < n; i++) {
        // 跳过不满足边界条件的元素
        if (nums[i] < minK || nums[i] > maxK) {
            continue;
        }
        
        // 使用二分查找找到满足条件的右端点范围
        int leftBound = i;
        int rightBound = n - 1;
        int validRightStart = -1;
        int validRightEnd = -1;
        
        // 找到第一个满足条件的右端点
        int low = i, high = n - 1;
        while (low <= high) {
            int mid = (low + high) / 2;
            int minVal = st.queryMin(i, mid);
            int maxVal = st.queryMax(i, mid);
            
            if (minVal == minK && maxVal == maxK) {
                validRightStart = mid;
                high = mid - 1;
            } else if (minVal < minK || maxVal > maxK) {
                low = mid + 1;
            } else {
                low = mid + 1;
            }
        }
        
        if (validRightStart == -1) {
            continue;
        }
        
        // 找到最后一个满足条件的右端点
        low = validRightStart;
        high = n - 1;
        while (low <= high) {
            int mid = (low + high) / 2;
            int minVal = st.queryMin(i, mid);
            int maxVal = st.queryMax(i, mid);
            
            if (minVal == minK && maxVal == maxK) {
                validRightEnd = mid;
                low = mid + 1;
            } else if (minVal < minK || maxVal > maxK) {
                high = mid - 1;
            } else {
                low = mid + 1;
            }
        }
        
        // 计算满足条件的子数组数量
        if (validRightStart != -1 && validRightEnd != -1) {
            count += validRightEnd - validRightStart + 1;
        }
    }
    
    return count;
}

/**
 * 方法2：优化的数学解法（最优解）
 * 时间复杂度：O(n)
 * 空间复杂度：O(1)
 * @param nums 输入数组
 * @param minK 最小值边界
 * @param maxK 最大值边界
 * @return 定界子数组的数目
 */
long long countSubarraysOptimized(const vector<int>& nums, int minK, int maxK) {
    long long result = 0;
    int badIdx = -1, leftIdx = -1, rightIdx = -1;
    
    for (int i = 0; i < nums.size(); ++i) {
        // 如果当前元素超出边界，则更新badIdx
        if (!(minK <= nums[i] && nums[i] <= maxK)) {
            badIdx = i;
        }
        
        // 更新最近的minK位置
        if (nums[i] == minK) {
            leftIdx = i;
        }
        
        // 更新最近的maxK位置
        if (nums[i] == maxK) {
            rightIdx = i;
        }
        
        // 计算以当前位置结尾的有效子数组数量
        result += max(0, min(leftIdx, rightIdx) - badIdx);
    }
    
    return result;
}

/**
 * 方法3：滑动窗口解法
 * 时间复杂度：O(n)
 * 空间复杂度：O(1)
 * @param nums 输入数组
 * @param minK 最小值边界
 * @param maxK 最大值边界
 * @return 定界子数组的数目
 */
long long countSubarraysSlidingWindow(const vector<int>& nums, int minK, int maxK) {
    long long result = 0;
    int start = 0;
    int minPos = -1, maxPos = -1;
    
    for (int i = 0; i < nums.size(); i++) {
        // 如果当前元素超出边界，重置窗口
        if (nums[i] < minK || nums[i] > maxK) {
            start = i + 1;
            minPos = -1;
            maxPos = -1;
        } else {
            // 更新minK和maxK的位置
            if (nums[i] == minK) {
                minPos = i;
            }
            if (nums[i] == maxK) {
                maxPos = i;
            }
            
            // 如果已经找到minK和maxK，计算有效子数组数量
            if (minPos != -1 && maxPos != -1) {
                result += min(minPos, maxPos) - start + 1;
            }
        }
    }
    
    return result;
}

/**
 * 测试函数
 */
void testCountSubarraysWithFixedBounds() {
    cout << "=== 测试 LeetCode 2444. 统计定界子数组的数目 ===" << endl;
    
    // 测试用例1
    vector<int> nums1 = {1, 3, 5, 2, 7, 5};
    int minK1 = 1, maxK1 = 5;
    cout << "测试用例1:" << endl;
    cout << "数组: [1, 3, 5, 2, 7, 5]" << endl;
    cout << "minK: " << minK1 << ", maxK: " << maxK1 << endl;
    cout << "稀疏表解法结果: " << countSubarraysWithSparseTable(nums1, minK1, maxK1) << endl;
    cout << "优化解法结果: " << countSubarraysOptimized(nums1, minK1, maxK1) << endl;
    cout << "滑动窗口解法结果: " << countSubarraysSlidingWindow(nums1, minK1, maxK1) << endl;
    cout << "期望结果: 2" << endl;
    cout << endl;
    
    // 测试用例2
    vector<int> nums2 = {1, 1, 1, 1};
    int minK2 = 1, maxK2 = 1;
    cout << "测试用例2:" << endl;
    cout << "数组: [1, 1, 1, 1]" << endl;
    cout << "minK: " << minK2 << ", maxK: " << maxK2 << endl;
    cout << "稀疏表解法结果: " << countSubarraysWithSparseTable(nums2, minK2, maxK2) << endl;
    cout << "优化解法结果: " << countSubarraysOptimized(nums2, minK2, maxK2) << endl;
    cout << "滑动窗口解法结果: " << countSubarraysSlidingWindow(nums2, minK2, maxK2) << endl;
    cout << "期望结果: 10" << endl;
    cout << endl;
    
    // 测试用例3
    vector<int> nums3 = {1, 3, 5, 2, 7, 5, 1, 3, 5};
    int minK3 = 1, maxK3 = 5;
    cout << "测试用例3:" << endl;
    cout << "数组: [1, 3, 5, 2, 7, 5, 1, 3, 5]" << endl;
    cout << "minK: " << minK3 << ", maxK: " << maxK3 << endl;
    cout << "稀疏表解法结果: " << countSubarraysWithSparseTable(nums3, minK3, maxK3) << endl;
    cout << "优化解法结果: " << countSubarraysOptimized(nums3, minK3, maxK3) << endl;
    cout << "滑动窗口解法结果: " << countSubarraysSlidingWindow(nums3, minK3, maxK3) << endl;
    cout << endl;
    
    // 性能测试
    cout << "=== 性能测试 ===" << endl;
    mt19937 gen(42);
    uniform_int_distribution<> dis(1, 100);
    
    int arraySize = 10000;
    vector<int> nums(arraySize);
    for (int i = 0; i < arraySize; i++) {
        nums[i] = dis(gen);
    }
    int minK = 10, maxK = 50;
    
    auto start_time = chrono::high_resolution_clock::now();
    long long result1 = countSubarraysOptimized(nums, minK, maxK);
    auto end_time = chrono::high_resolution_clock::now();
    auto duration = chrono::duration_cast<chrono::microseconds>(end_time - start_time);
    cout << "优化解法处理" << arraySize << "个元素时间: " << duration.count() / 1000.0 << " ms, 结果: " << result1 << endl;
    
    start_time = chrono::high_resolution_clock::now();
    long long result2 = countSubarraysSlidingWindow(nums, minK, maxK);
    end_time = chrono::high_resolution_clock::now();
    duration = chrono::duration_cast<chrono::microseconds>(end_time - start_time);
    cout << "滑动窗口解法处理" << arraySize << "个元素时间: " << duration.count() / 1000.0 << " ms, 结果: " << result2 << endl;
}

int main() {
    testCountSubarraysWithFixedBounds();
    return 0;
}

===============================================

文件: leetcode_2444_count_subarrays_with_fixed_bounds.py
===============================================
#!/usr/bin/env python3
"""
LeetCode 2444. 统计定界子数组的数目 (Count Subarrays With Fixed Bounds) - Python版本

题目来源：https://leetcode.cn/problems/count-subarrays-with-fixed-bounds/

题目描述：
给你一个整数数组 nums 和两个整数 minK 以及 maxK。
nums 的定界子数组是满足下述条件的一个子数组：
- 子数组中的最小值等于 minK。
- 子数组中的最大值等于 maxK。
返回定界子数组的数目。
子数组是数组中的一个连续部分。

算法思路：
这个问题可以通过以下方法解决：
1. 滑动窗口：维护满足条件的窗口
2. 稀疏表：预处理范围最值查询，然后枚举所有可能的子数组
3. 数学方法：通过计算包含minK和maxK的子数组数量

使用稀疏表的方法：
1. 预处理稀疏表用于范围最值查询
2. 对于每个左端点，使用二分查找找到满足条件的右端点范围

时间复杂度：
- 稀疏表预处理：O(n log n)
- 查询：O(1)
- 总时间复杂度：O(n²)（最坏情况）或O(n log n)（优化后）
- 空间复杂度：O(n log n)

应用场景：
1. 数据分析：统计满足特定条件的连续数据段
2. 金融：分析价格波动区间
3. 信号处理：检测特定幅度的信号段

相关题目：
1. LeetCode 315. 计算右侧小于当前元素的个数
2. LeetCode 743. 网络延迟时间
3. LeetCode 1584. 连接所有点的最小费用
"""

import math
import random
import time

class SparseTable:
    """稀疏表类，用于范围最值查询"""
    
    def __init__(self, data):
        """
        构造函数
        :param data: 输入数组
        """
        if not data:
            raise ValueError("输入数组不能为空")
        
        self.data = data[:]
        self.n = len(data)
        
        # 预计算log表
        self._precompute_log_table()
        
        # 构建稀疏表
        self._build_sparse_table()
    
    def _precompute_log_table(self):
        """预计算log2值表"""
        self.log_table = [0] * (self.n + 1)
        self.log_table[1] = 0
        for i in range(2, self.n + 1):
            self.log_table[i] = self.log_table[i // 2] + 1
    
    def _build_sparse_table(self):
        """构建稀疏表"""
        k = self.log_table[self.n] + 1
        
        # 初始化稀疏表
        self.st_min = [[0 for _ in range(self.n)] for _ in range(k)]
        self.st_max = [[0 for _ in range(self.n)] for _ in range(k)]
        
        # 初始化k=0的情况（长度为1的区间）
        for i in range(self.n):
            self.st_min[0][i] = self.data[i]
            self.st_max[0][i] = self.data[i]
        
        # 动态规划构建其他k值
        for j in range(1, k):
            for i in range(self.n - (1 << j) + 1):
                prev_len = 1 << (j - 1)
                # 范围最小值查询
                self.st_min[j][i] = min(self.st_min[j-1][i], self.st_min[j-1][i + prev_len])
                # 范围最大值查询
                self.st_max[j][i] = max(self.st_max[j-1][i], self.st_max[j-1][i + prev_len])
    
    def query_min(self, left, right):
        """
        范围最小值查询
        时间复杂度：O(1)
        :param left: 左边界（包含）
        :param right: 右边界（包含）
        :return: 区间内的最小值
        """
        if left < 0 or right >= self.n or left > right:
            raise ValueError("查询范围无效")
        
        length = right - left + 1
        k = self.log_table[length]
        
        return min(self.st_min[k][left], self.st_min[k][right - (1 << k) + 1])
    
    def query_max(self, left, right):
        """
        范围最大值查询
        时间复杂度：O(1)
        :param left: 左边界（包含）
        :param right: 右边界（包含）
        :return: 区间内的最大值
        """
        if left < 0 or right >= self.n or left > right:
            raise ValueError("查询范围无效")
        
        length = right - left + 1
        k = self.log_table[length]
        
        return max(self.st_max[k][left], self.st_max[k][right - (1 << k) + 1])

def count_subarrays_with_sparse_table(nums, minK, maxK):
    """
    方法1：使用稀疏表的解法
    时间复杂度：O(n log n)
    空间复杂度：O(n log n)
    :param nums: 输入数组
    :param minK: 最小值边界
    :param maxK: 最大值边界
    :return: 定界子数组的数目
    """
    n = len(nums)
    if n == 0:
        return 0
    
    # 构建稀疏表
    st = SparseTable(nums)
    
    count = 0
    
    # 对于每个左端点，找到满足条件的右端点范围
    for i in range(n):
        # 跳过不满足边界条件的元素
        if nums[i] < minK or nums[i] > maxK:
            continue
        
        # 使用二分查找找到满足条件的右端点范围
        left_bound = i
        right_bound = n - 1
        valid_right_start = -1
        valid_right_end = -1
        
        # 找到第一个满足条件的右端点
        low, high = i, n - 1
        while low <= high:
            mid = (low + high) // 2
            min_val = st.query_min(i, mid)
            max_val = st.query_max(i, mid)
            
            if min_val == minK and max_val == maxK:
                valid_right_start = mid
                high = mid - 1
            elif min_val < minK or max_val > maxK:
                low = mid + 1
            else:
                low = mid + 1
        
        if valid_right_start == -1:
            continue
        
        # 找到最后一个满足条件的右端点
        low, high = valid_right_start, n - 1
        while low <= high:
            mid = (low + high) // 2
            min_val = st.query_min(i, mid)
            max_val = st.query_max(i, mid)
            
            if min_val == minK and max_val == maxK:
                valid_right_end = mid
                low = mid + 1
            elif min_val < minK or max_val > maxK:
                high = mid - 1
            else:
                low = mid + 1
        
        # 计算满足条件的子数组数量
        if valid_right_start != -1 and valid_right_end != -1:
            count += valid_right_end - valid_right_start + 1
    
    return count

def count_subarrays_optimized(nums, minK, maxK):
    """
    方法2：优化的数学解法（最优解）
    时间复杂度：O(n)
    空间复杂度：O(1)
    :param nums: 输入数组
    :param minK: 最小值边界
    :param maxK: 最大值边界
    :return: 定界子数组的数目
    """
    result = 0
    bad_idx = -1
    left_idx = -1
    right_idx = -1
    
    for i in range(len(nums)):
        # 如果当前元素超出边界，则更新bad_idx
        if not (minK <= nums[i] <= maxK):
            bad_idx = i
        
        # 更新最近的minK位置
        if nums[i] == minK:
            left_idx = i
        
        # 更新最近的maxK位置
        if nums[i] == maxK:
            right_idx = i
        
        # 计算以当前位置结尾的有效子数组数量
        result += max(0, min(left_idx, right_idx) - bad_idx)
    
    return result

def count_subarrays_sliding_window(nums, minK, maxK):
    """
    方法3：滑动窗口解法
    时间复杂度：O(n)
    空间复杂度：O(1)
    :param nums: 输入数组
    :param minK: 最小值边界
    :param maxK: 最大值边界
    :return: 定界子数组的数目
    """
    result = 0
    start = 0
    min_pos = -1
    max_pos = -1
    
    for i in range(len(nums)):
        # 如果当前元素超出边界，重置窗口
        if nums[i] < minK or nums[i] > maxK:
            start = i + 1
            min_pos = -1
            max_pos = -1
        else:
            # 更新minK和maxK的位置
            if nums[i] == minK:
                min_pos = i
            if nums[i] == maxK:
                max_pos = i
            
            # 如果已经找到minK和maxK，计算有效子数组数量
            if min_pos != -1 and max_pos != -1:
                result += min(min_pos, max_pos) - start + 1
    
    return result

def test_count_subarrays_with_fixed_bounds():
    """测试函数"""
    print("=== 测试 LeetCode 2444. 统计定界子数组的数目 ===")
    
    # 测试用例1
    nums1 = [1, 3, 5, 2, 7, 5]
    minK1, maxK1 = 1, 5
    print("测试用例1:")
    print("数组:", nums1)
    print("minK:", minK1, ", maxK:", maxK1)
    print("稀疏表解法结果:", count_subarrays_with_sparse_table(nums1, minK1, maxK1))
    print("优化解法结果:", count_subarrays_optimized(nums1, minK1, maxK1))
    print("滑动窗口解法结果:", count_subarrays_sliding_window(nums1, minK1, maxK1))
    print("期望结果: 2")
    print()
    
    # 测试用例2
    nums2 = [1, 1, 1, 1]
    minK2, maxK2 = 1, 1
    print("测试用例2:")
    print("数组:", nums2)
    print("minK:", minK2, ", maxK:", maxK2)
    print("稀疏表解法结果:", count_subarrays_with_sparse_table(nums2, minK2, maxK2))
    print("优化解法结果:", count_subarrays_optimized(nums2, minK2, maxK2))
    print("滑动窗口解法结果:", count_subarrays_sliding_window(nums2, minK2, maxK2))
    print("期望结果: 10")
    print()
    
    # 测试用例3
    nums3 = [1, 3, 5, 2, 7, 5, 1, 3, 5]
    minK3, maxK3 = 1, 5
    print("测试用例3:")
    print("数组:", nums3)
    print("minK:", minK3, ", maxK:", maxK3)
    print("稀疏表解法结果:", count_subarrays_with_sparse_table(nums3, minK3, maxK3))
    print("优化解法结果:", count_subarrays_optimized(nums3, minK3, maxK3))
    print("滑动窗口解法结果:", count_subarrays_sliding_window(nums3, minK3, maxK3))
    print()
    
    # 性能测试
    print("=== 性能测试 ===")
    random.seed(42)
    array_size = 10000
    nums = [random.randint(1, 100) for _ in range(array_size)]
    minK, maxK = 10, 50
    
    start_time = time.time()
    result1 = count_subarrays_optimized(nums, minK, maxK)
    end_time = time.time()
    print("优化解法处理{}个元素时间: {:.2f} ms, 结果: {}".format(
        array_size, (end_time - start_time) * 1000, result1))
    
    start_time = time.time()
    result2 = count_subarrays_sliding_window(nums, minK, maxK)
    end_time = time.time()
    print("滑动窗口解法处理{}个元素时间: {:.2f} ms, 结果: {}".format(
        array_size, (end_time - start_time) * 1000, result2))

if __name__ == "__main__":
    test_count_subarrays_with_fixed_bounds()

===============================================

文件: LeetCode_253_MeetingRoomsII.java
===============================================
package class185.sweep_line_problems;

import java.util.*;

/**
 * LeetCode 253. 会议室II (Meeting Rooms II)
 * 
 * 题目来源：https://leetcode.cn/problems/meeting-rooms-ii/
 * 
 * 题目描述：
 * 给定一个会议时间安排的数组 intervals ，每个会议时间都会包括开始和结束的时间 intervals[i] = [starti, endi] ，
 * 请你计算至少需要多少间会议室，才能满足这些会议安排。
 * 
 * 示例 1：
 * 输入：intervals = [[0,30],[5,10],[15,20]]
 * 输出：2
 * 
 * 示例 2：
 * 输入：intervals = [[7,10],[2,4]]
 * 输出：1
 * 
 * 提示：
 * 1 <= intervals.length <= 10^4
 * 0 <= starti < endi <= 10^6
 * 
 * 解题思路：
 * 使用扫描线算法解决会议室安排问题。核心思想是：
 * 1. 将每个会议的开始和结束时间转换为事件点
 * 2. 对所有事件点按时间排序
 * 3. 扫描所有事件点，维护当前正在进行的会议数量
 * 4. 最大同时进行的会议数量就是所需的最小会议室数量
 * 
 * 时间复杂度：O(n log n)，主要来自排序
 * 空间复杂度：O(n)，存储事件点
 * 
 * 相关题目：
 * - LeetCode 252. 会议室
 * - LeetCode 56. 合并区间
 * - LeetCode 759. 员工空闲时间
 */
public class LeetCode_253_MeetingRoomsII {
    
    /**
     * 计算所需会议室数量的扫描线解法
     * @param intervals 会议时间安排数组
     * @return 所需的最小会议室数量
     */
    public static int minMeetingRooms(int[][] intervals) {
        if (intervals == null || intervals.length == 0) {
            return 0;
        }
        
        // 创建事件点列表：[时间, 类型]
        // 类型：0表示会议开始，1表示会议结束
        List<int[]> events = new ArrayList<>();
        
        // 为每个会议创建开始和结束事件
        for (int[] interval : intervals) {
            events.add(new int[]{interval[0], 0});  // 开始事件
            events.add(new int[]{interval[1], 1});  // 结束事件
        }
        
        // 按照时间排序事件点
        // 如果时间相同，结束事件优先于开始事件
        events.sort((a, b) -> {
            if (a[0] != b[0]) {
                return Integer.compare(a[0], b[0]);
            }
            return Integer.compare(b[1], a[1]);
        });
        
        int maxRooms = 0;
        int currentRooms = 0;
        
        // 扫描所有事件点
        for (int[] event : events) {
            if (event[1] == 0) {
                // 会议开始事件
                currentRooms++;
                maxRooms = Math.max(maxRooms, currentRooms);
            } else {
                // 会议结束事件
                currentRooms--;
            }
        }
        
        return maxRooms;
    }
    
    /**
     * 测试会议室II解法
     */
    public static void main(String[] args) {
        System.out.println("=== LeetCode 253. 会议室II ===");
        
        // 测试用例1
        System.out.println("测试用例1:");
        int[][] intervals1 = {{0, 30}, {5, 10}, {15, 20}};
        int result1 = minMeetingRooms(intervals1);
        System.out.println("输入: " + Arrays.deepToString(intervals1));
        System.out.println("输出: " + result1);
        System.out.println("期望: 2");
        System.out.println();
        
        // 测试用例2
        System.out.println("测试用例2:");
        int[][] intervals2 = {{7, 10}, {2, 4}};
        int result2 = minMeetingRooms(intervals2);
        System.out.println("输入: " + Arrays.deepToString(intervals2));
        System.out.println("输出: " + result2);
        System.out.println("期望: 1");
        System.out.println();
        
        // 边界测试
        System.out.println("边界测试:");
        int[][] intervals3 = {{1, 2}, {2, 3}, {3, 4}};
        int result3 = minMeetingRooms(intervals3);
        System.out.println("输入: " + Arrays.deepToString(intervals3));
        System.out.println("输出: " + result3);
        System.out.println("期望: 1");
        System.out.println();
        
        // 性能测试
        System.out.println("=== 性能测试 ===");
        Random random = new Random(42);
        int n = 10000;
        int[][] largeIntervals = new int[n][2];
        
        for (int i = 0; i < n; i++) {
            int start = random.nextInt(1000000);
            int end = start + random.nextInt(1000) + 1;
            largeIntervals[i] = new int[]{start, end};
        }
        
        long startTime = System.nanoTime();
        int largeResult = minMeetingRooms(largeIntervals);
        long endTime = System.nanoTime();
        
        System.out.println("10000个会议的会议室计算完成");
        System.out.println("所需会议室数量: " + largeResult);
        System.out.println("运行时间: " + (endTime - startTime) / 1_000_000.0 + " ms");
        
        // 工程化考量
        System.out.println("\n=== 工程化考量 ===");
        System.out.println("1. 异常处理：处理空输入和null输入");
        System.out.println("2. 边界情况：处理时间边界和重叠情况");
        System.out.println("3. 性能优化：排序时间复杂度O(n log n)是最优解");
        System.out.println("4. 内存优化：使用最小额外空间存储事件点");
        
        // 算法复杂度分析
        System.out.println("\n=== 算法复杂度分析 ===");
        System.out.println("时间复杂度: O(n log n)");
        System.out.println("  - 排序: O(n log n)");
        System.out.println("  - 扫描: O(n)");
        System.out.println("空间复杂度: O(n)");
        System.out.println("  - 存储事件点: O(n)");
    }
}

===============================================

文件: leetcode_253_meeting_rooms_ii.cpp
===============================================
#include <iostream>
#include <vector>
#include <algorithm>
#include <random>
#include <chrono>

using namespace std;

/**
 * LeetCode 253. 会议室II (Meeting Rooms II) - C++版本
 * 
 * 解题思路：
 * 使用扫描线算法解决会议室安排问题
 * 
 * 时间复杂度：O(n log n)
 * 空间复杂度：O(n)
 */
class Solution {
public:
    int minMeetingRooms(vector<vector<int>>& intervals) {
        if (intervals.empty()) {
            return 0;
        }
        
        // 创建事件点列表：[时间, 类型]
        // 类型：0表示会议开始，1表示会议结束
        vector<pair<int, int>> events;
        
        // 为每个会议创建开始和结束事件
        for (const auto& interval : intervals) {
            events.emplace_back(interval[0], 0);  // 开始事件
            events.emplace_back(interval[1], 1);  // 结束事件
        }
        
        // 按照时间排序事件点
        // 如果时间相同，结束事件优先于开始事件
        sort(events.begin(), events.end(), [](const pair<int, int>& a, const pair<int, int>& b) {
            if (a.first != b.first) {
                return a.first < b.first;
            }
            return a.second > b.second;
        });
        
        int maxRooms = 0;
        int currentRooms = 0;
        
        // 扫描所有事件点
        for (const auto& event : events) {
            if (event.second == 0) {
                // 会议开始事件
                currentRooms++;
                maxRooms = max(maxRooms, currentRooms);
            } else {
                // 会议结束事件
                currentRooms--;
            }
        }
        
        return maxRooms;
    }
};

/**
 * 测试会议室II解法
 */
void testMeetingRoomsII() {
    cout << "=== LeetCode 253. 会议室II (C++版本) ===" << endl;
    
    Solution solution;
    
    // 测试用例1
    cout << "测试用例1:" << endl;
    vector<vector<int>> intervals1 = {{0, 30}, {5, 10}, {15, 20}};
    int result1 = solution.minMeetingRooms(intervals1);
    cout << "输入: ";
    for (const auto& interval : intervals1) {
        cout << "[" << interval[0] << "," << interval[1] << "] ";
    }
    cout << endl;
    cout << "输出: " << result1 << endl;
    cout << "期望: 2" << endl;
    cout << endl;
    
    // 测试用例2
    cout << "测试用例2:" << endl;
    vector<vector<int>> intervals2 = {{7, 10}, {2, 4}};
    int result2 = solution.minMeetingRooms(intervals2);
    cout << "输入: ";
    for (const auto& interval : intervals2) {
        cout << "[" << interval[0] << "," << interval[1] << "] ";
    }
    cout << endl;
    cout << "输出: " << result2 << endl;
    cout << "期望: 1" << endl;
    cout << endl;
    
    // 性能测试
    cout << "=== 性能测试 ===" << endl;
    default_random_engine generator(42);
    uniform_int_distribution<int> distribution(0, 1000000);
    
    int n = 10000;
    vector<vector<int>> largeIntervals(n, vector<int>(2));
    
    for (int i = 0; i < n; i++) {
        int start = distribution(generator);
        int end = start + distribution(generator) % 1000 + 1;
        largeIntervals[i] = {start, end};
    }
    
    auto startTime = chrono::high_resolution_clock::now();
    int largeResult = solution.minMeetingRooms(largeIntervals);
    auto endTime = chrono::high_resolution_clock::now();
    
    auto duration = chrono::duration_cast<chrono::microseconds>(endTime - startTime);
    
    cout << n << "个会议的会议室计算完成" << endl;
    cout << "所需会议室数量: " << largeResult << endl;
    cout << "运行时间: " << duration.count() / 1000.0 << " ms" << endl;
    
    // C++语言特性考量
    cout << "\n=== C++语言特性考量 ===" << endl;
    cout << "1. 使用pair存储事件点，提高内存效率" << endl;
    cout << "2. 使用emplace_back避免临时对象构造" << endl;
    cout << "3. 使用lambda表达式进行自定义排序" << endl;
    cout << "4. 使用const引用避免不必要的拷贝" << endl;
}

int main() {
    testMeetingRoomsII();
    return 0;
}

===============================================

文件: leetcode_253_meeting_rooms_ii.py
===============================================
#!/usr/bin/env python3
"""
LeetCode 253. 会议室II (Meeting Rooms II) - Python版本

题目来源：https://leetcode.cn/problems/meeting-rooms-ii/

解题思路：
使用扫描线算法解决会议室安排问题

时间复杂度：O(n log n)
空间复杂度：O(n)
"""

import time
import random
from typing import List

class Solution:
    def minMeetingRooms(self, intervals: List[List[int]]) -> int:
        """
        计算所需会议室数量的扫描线解法
        
        Args:
            intervals: 会议时间安排数组
            
        Returns:
            所需的最小会议室数量
        """
        if not intervals:
            return 0
        
        # 创建事件点列表：[时间, 类型]
        # 类型：0表示会议开始，1表示会议结束
        events = []
        
        # 为每个会议创建开始和结束事件
        for start, end in intervals:
            events.append([start, 0])  # 开始事件
            events.append([end, 1])    # 结束事件
        
        # 按照时间排序事件点
        # 如果时间相同，结束事件优先于开始事件
        events.sort(key=lambda x: (x[0], -x[1]))
        
        max_rooms = 0
        current_rooms = 0
        
        # 扫描所有事件点
        for time, event_type in events:
            if event_type == 0:
                # 会议开始事件
                current_rooms += 1
                max_rooms = max(max_rooms, current_rooms)
            else:
                # 会议结束事件
                current_rooms -= 1
        
        return max_rooms

def test_meeting_rooms_ii():
    """测试会议室II解法"""
    solution = Solution()
    
    print("=== LeetCode 253. 会议室II (Python版本) ===")
    
    # 测试用例1
    print("测试用例1:")
    intervals1 = [[0, 30], [5, 10], [15, 20]]
    result1 = solution.minMeetingRooms(intervals1)
    print(f"输入: {intervals1}")
    print(f"输出: {result1}")
    print("期望: 2")
    print()
    
    # 测试用例2
    print("测试用例2:")
    intervals2 = [[7, 10], [2, 4]]
    result2 = solution.minMeetingRooms(intervals2)
    print(f"输入: {intervals2}")
    print(f"输出: {result2}")
    print("期望: 1")
    print()
    
    # 性能测试
    print("=== 性能测试 ===")
    random.seed(42)
    n = 10000
    large_intervals = []
    
    for i in range(n):
        start = random.randint(0, 1000000)
        end = start + random.randint(1, 1000)
        large_intervals.append([start, end])
    
    start_time = time.time()
    large_result = solution.minMeetingRooms(large_intervals)
    end_time = time.time()
    
    print(f"{n}个会议的会议室计算完成")
    print(f"所需会议室数量: {large_result}")
    print(f"运行时间: {(end_time - start_time) * 1000:.2f} ms")
    
    # Python语言特性考量
    print("\n=== Python语言特性考量 ===")
    print("1. 使用列表推导式生成事件点")
    print("2. 使用lambda表达式进行自定义排序")
    print("3. 使用类型注解提高代码可读性")
    print("4. 使用f-string进行格式化输出")
    
    # 算法复杂度分析
    print("\n=== 算法复杂度分析 ===")
    print("时间复杂度: O(n log n)")
    print("  - 排序: O(n log n)")
    print("  - 扫描: O(n)")
    print("空间复杂度: O(n)")
    print("  - 存储事件点: O(n)")

if __name__ == "__main__":
    test_meeting_rooms_ii()

===============================================

文件: LeetCode_289_GameOfLife.java
===============================================
package class185.game_of_life_problems;

import java.util.*;

/**
 * LeetCode 289. 生命游戏 (Game of Life)
 * 题目链接：https://leetcode.com/problems/game-of-life/
 * 
 * 题目描述：
 * 根据百度百科，生命游戏，简称为生命，是英国数学家约翰·何顿·康威在1970年发明的细胞自动机。
 * 给定一个包含 m × n 个格子的面板，每一个格子都可以看成是一个细胞。每个细胞都具有一个初始状态：
 * 1 即为活细胞（live），或 0 即为死细胞（dead）。每个细胞与其八个相邻位置（水平，垂直，对角线）的细胞都遵循以下四条生存定律：
 * 
 * 1. 如果活细胞周围八个位置的活细胞数少于两个，则该位置活细胞死亡；
 * 2. 如果活细胞周围八个位置有超过三个活细胞，则该位置活细胞死亡；
 * 3. 如果活细胞周围八个位置有两个或三个活细胞，则该位置活细胞仍然存活；
 * 4. 如果死细胞周围正好有三个活细胞，则该位置死细胞复活；
 * 
 * 根据当前状态，写一个函数来计算面板上所有细胞的下一个（一次更新后的）状态。
 * 下一个状态是通过将上述规则同时应用于当前状态下的每个细胞所形成的，其中细胞的出生和死亡是同时发生的。
 * 
 * 要求：使用原地算法，空间复杂度O(1)
 * 
 * 算法思路：
 * 1. 使用特殊标记法来同时保存当前状态和下一状态
 * 2. 标记规则：
 *    - 如果细胞从活到死，标记为2（当前为活，下一状态为死）
 *    - 如果细胞从死到活，标记为-1（当前为死，下一状态为活）
 * 3. 遍历两次：第一次应用规则并标记，第二次解析标记
 * 
 * 时间复杂度：O(m*n)
 * 空间复杂度：O(1)
 * 
 * 边界情况：
 * 1. 空面板或单细胞面板
 * 2. 边界细胞（需要处理边界条件）
 * 3. 所有细胞死亡或所有细胞存活
 * 4. 特殊图案（稳定图案、周期图案等）
 */
public class LeetCode_289_GameOfLife {
    
    /**
     * 原地算法解决生命游戏问题
     * @param board 细胞面板，会被原地修改
     */
    public void gameOfLife(int[][] board) {
        if (board == null || board.length == 0 || board[0].length == 0) {
            return;
        }
        
        int m = board.length;
        int n = board[0].length;
        
        // 第一遍遍历：应用规则并标记
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                int liveNeighbors = countLiveNeighbors(board, i, j, m, n);
                
                // 规则1和2：活细胞死亡条件
                if (board[i][j] == 1 && (liveNeighbors < 2 || liveNeighbors > 3)) {
                    board[i][j] = 2; // 标记为从活到死
                }
                // 规则4：死细胞复活条件
                else if (board[i][j] == 0 && liveNeighbors == 3) {
                    board[i][j] = -1; // 标记为从死到活
                }
                // 规则3：活细胞存活条件（保持1不变）
                // 其他情况：死细胞保持死亡（保持0不变）
            }
        }
        
        // 第二遍遍历：解析标记
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (board[i][j] == 2) {
                    board[i][j] = 0; // 从活到死
                } else if (board[i][j] == -1) {
                    board[i][j] = 1; // 从死到活
                }
                // 其他情况保持不变
            }
        }
    }
    
    /**
     * 计算细胞周围活细胞数量（考虑标记）
     * @param board 细胞面板
     * @param i 当前细胞行索引
     * @param j 当前细胞列索引
     * @param m 面板行数
     * @param n 面板列数
     * @return 活细胞数量
     */
    private int countLiveNeighbors(int[][] board, int i, int j, int m, int n) {
        int count = 0;
        
        // 8个方向的偏移量
        int[][] directions = {
            {-1, -1}, {-1, 0}, {-1, 1},
            {0, -1},           {0, 1},
            {1, -1},  {1, 0}, {1, 1}
        };
        
        for (int[] dir : directions) {
            int ni = i + dir[0];
            int nj = j + dir[1];
            
            // 检查边界
            if (ni >= 0 && ni < m && nj >= 0 && nj < n) {
                // 当前为活细胞(1)或标记为从活到死(2)的都算作活细胞
                if (board[ni][nj] == 1 || board[ni][nj] == 2) {
                    count++;
                }
            }
        }
        
        return count;
    }
    
    /**
     * 使用额外空间的解法（非原地，更容易理解）
     * @param board 细胞面板
     */
    public void gameOfLifeWithExtraSpace(int[][] board) {
        if (board == null || board.length == 0 || board[0].length == 0) {
            return;
        }
        
        int m = board.length;
        int n = board[0].length;
        int[][] nextBoard = new int[m][n];
        
        // 复制当前状态
        for (int i = 0; i < m; i++) {
            System.arraycopy(board[i], 0, nextBoard[i], 0, n);
        }
        
        // 应用规则
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                int liveNeighbors = countLiveNeighborsSimple(board, i, j, m, n);
                
                if (board[i][j] == 1) {
                    // 活细胞规则
                    if (liveNeighbors < 2 || liveNeighbors > 3) {
                        nextBoard[i][j] = 0; // 死亡
                    } else {
                        nextBoard[i][j] = 1; // 存活
                    }
                } else {
                    // 死细胞规则
                    if (liveNeighbors == 3) {
                        nextBoard[i][j] = 1; // 复活
                    } else {
                        nextBoard[i][j] = 0; // 保持死亡
                    }
                }
            }
        }
        
        // 更新原数组
        for (int i = 0; i < m; i++) {
            System.arraycopy(nextBoard[i], 0, board[i], 0, n);
        }
    }
    
    /**
     * 简单计算活细胞数量（不考虑标记）
     */
    private int countLiveNeighborsSimple(int[][] board, int i, int j, int m, int n) {
        int count = 0;
        int[][] directions = {
            {-1, -1}, {-1, 0}, {-1, 1},
            {0, -1},           {0, 1},
            {1, -1},  {1, 0}, {1, 1}
        };
        
        for (int[] dir : directions) {
            int ni = i + dir[0];
            int nj = j + dir[1];
            
            if (ni >= 0 && ni < m && nj >= 0 && nj < n && board[ni][nj] == 1) {
                count++;
            }
        }
        
        return count;
    }
    
    /**
     * 单元测试
     */
    public static void main(String[] args) {
        LeetCode_289_GameOfLife solution = new LeetCode_289_GameOfLife();
        
        // 测试用例1：闪烁器（Blinker）
        System.out.println("=== 测试用例1：闪烁器 ===");
        int[][] board1 = {
            {0, 1, 0},
            {0, 1, 0},
            {0, 1, 0}
        };
        
        System.out.println("初始状态:");
        printBoard(board1);
        
        solution.gameOfLife(board1);
        System.out.println("下一代状态:");
        printBoard(board1);
        
        // 测试用例2：滑翔机（Glider）
        System.out.println("=== 测试用例2：滑翔机 ===");
        int[][] board2 = {
            {0, 1, 0},
            {0, 0, 1},
            {1, 1, 1}
        };
        
        System.out.println("初始状态:");
        printBoard(board2);
        
        solution.gameOfLife(board2);
        System.out.println("下一代状态:");
        printBoard(board2);
        
        // 测试用例3：稳定图案（方块）
        System.out.println("=== 测试用例3：稳定图案 ===");
        int[][] board3 = {
            {1, 1},
            {1, 1}
        };
        
        System.out.println("初始状态:");
        printBoard(board3);
        
        solution.gameOfLife(board3);
        System.out.println("下一代状态（应该保持不变）:");
        printBoard(board3);
        
        // 测试用例4：边界情况
        System.out.println("=== 测试用例4：单细胞 ===");
        int[][] board4 = {{1}};
        
        System.out.println("初始状态:");
        printBoard(board4);
        
        solution.gameOfLife(board4);
        System.out.println("下一代状态（应该死亡）:");
        printBoard(board4);
    }
    
    /**
     * 打印面板
     */
    private static void printBoard(int[][] board) {
        for (int[] row : board) {
            for (int cell : row) {
                System.out.print(cell == 1 ? "█ " : "· ");
            }
            System.out.println();
        }
        System.out.println();
    }
}

===============================================

文件: leetcode_289_game_of_life.cpp
===============================================
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

/**
 * LeetCode 289. 生命游戏 (Game of Life) - C++版本
 * 题目链接：https://leetcode.com/problems/game-of-life/
 * 
 * 算法思路：
 * 使用原地算法，通过特殊标记来同时保存当前状态和下一状态
 * 标记规则：
 *   - 如果细胞从活到死，标记为2（当前为活，下一状态为死）
 *   - 如果细胞从死到活，标记为-1（当前为死，下一状态为活）
 * 
 * 时间复杂度：O(m*n)
 * 空间复杂度：O(1)
 * 
 * 工程化考量：
 * 1. 边界检查：确保不越界访问
 * 2. 原地修改：避免额外空间使用
 * 3. 标记解析：两遍遍历确保正确性
 * 4. 异常处理：空输入检查
 */
class Solution {
public:
    void gameOfLife(vector<vector<int>>& board) {
        if (board.empty() || board[0].empty()) {
            return;
        }
        
        int m = board.size();
        int n = board[0].size();
        
        // 第一遍遍历：应用规则并标记
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                int liveNeighbors = countLiveNeighbors(board, i, j, m, n);
                
                // 规则1和2：活细胞死亡条件
                if (board[i][j] == 1 && (liveNeighbors < 2 || liveNeighbors > 3)) {
                    board[i][j] = 2; // 标记为从活到死
                }
                // 规则4：死细胞复活条件
                else if (board[i][j] == 0 && liveNeighbors == 3) {
                    board[i][j] = -1; // 标记为从死到活
                }
                // 规则3：活细胞存活条件（保持1不变）
                // 其他情况：死细胞保持死亡（保持0不变）
            }
        }
        
        // 第二遍遍历：解析标记
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (board[i][j] == 2) {
                    board[i][j] = 0; // 从活到死
                } else if (board[i][j] == -1) {
                    board[i][j] = 1; // 从死到活
                }
            }
        }
    }
    
private:
    /**
     * 计算细胞周围活细胞数量（考虑标记）
     * @param board 细胞面板
     * @param i 当前细胞行索引
     * @param j 当前细胞列索引
     * @param m 面板行数
     * @param n 面板列数
     * @return 活细胞数量
     */
    int countLiveNeighbors(vector<vector<int>>& board, int i, int j, int m, int n) {
        int count = 0;
        
        // 8个方向的偏移量
        vector<vector<int>> directions = {
            {-1, -1}, {-1, 0}, {-1, 1},
            {0, -1},           {0, 1},
            {1, -1},  {1, 0}, {1, 1}
        };
        
        for (auto& dir : directions) {
            int ni = i + dir[0];
            int nj = j + dir[1];
            
            // 检查边界
            if (ni >= 0 && ni < m && nj >= 0 && nj < n) {
                // 当前为活细胞(1)或标记为从活到死(2)的都算作活细胞
                if (board[ni][nj] == 1 || board[ni][nj] == 2) {
                    count++;
                }
            }
        }
        
        return count;
    }
    
public:
    /**
     * 使用额外空间的解法（非原地，更容易理解）
     * @param board 细胞面板
     */
    void gameOfLifeWithExtraSpace(vector<vector<int>>& board) {
        if (board.empty() || board[0].empty()) {
            return;
        }
        
        int m = board.size();
        int n = board[0].size();
        vector<vector<int>> nextBoard(m, vector<int>(n, 0));
        
        // 复制当前状态
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                nextBoard[i][j] = board[i][j];
            }
        }
        
        // 应用规则
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                int liveNeighbors = countLiveNeighborsSimple(board, i, j, m, n);
                
                if (board[i][j] == 1) {
                    // 活细胞规则
                    if (liveNeighbors < 2 || liveNeighbors > 3) {
                        nextBoard[i][j] = 0; // 死亡
                    } else {
                        nextBoard[i][j] = 1; // 存活
                    }
                } else {
                    // 死细胞规则
                    if (liveNeighbors == 3) {
                        nextBoard[i][j] = 1; // 复活
                    } else {
                        nextBoard[i][j] = 0; // 保持死亡
                    }
                }
            }
        }
        
        // 更新原数组
        board = nextBoard;
    }
    
private:
    /**
     * 简单计算活细胞数量（不考虑标记）
     */
    int countLiveNeighborsSimple(vector<vector<int>>& board, int i, int j, int m, int n) {
        int count = 0;
        vector<vector<int>> directions = {
            {-1, -1}, {-1, 0}, {-1, 1},
            {0, -1},           {0, 1},
            {1, -1},  {1, 0}, {1, 1}
        };
        
        for (auto& dir : directions) {
            int ni = i + dir[0];
            int nj = j + dir[1];
            
            if (ni >= 0 && ni < m && nj >= 0 && nj < n && board[ni][nj] == 1) {
                count++;
            }
        }
        
        return count;
    }
};

/**
 * 打印面板
 */
void printBoard(const vector<vector<int>>& board) {
    for (const auto& row : board) {
        for (int cell : row) {
            cout << (cell == 1 ? "█ " : "· ");
        }
        cout << endl;
    }
    cout << endl;
}

/**
 * 单元测试
 */
int main() {
    Solution solution;
    
    // 测试用例1：闪烁器（Blinker）
    cout << "=== 测试用例1：闪烁器 ===" << endl;
    vector<vector<int>> board1 = {
        {0, 1, 0},
        {0, 1, 0},
        {0, 1, 0}
    };
    
    cout << "初始状态:" << endl;
    printBoard(board1);
    
    solution.gameOfLife(board1);
    cout << "下一代状态:" << endl;
    printBoard(board1);
    
    // 测试用例2：滑翔机（Glider）
    cout << "=== 测试用例2：滑翔机 ===" << endl;
    vector<vector<int>> board2 = {
        {0, 1, 0},
        {0, 0, 1},
        {1, 1, 1}
    };
    
    cout << "初始状态:" << endl;
    printBoard(board2);
    
    solution.gameOfLife(board2);
    cout << "下一代状态:" << endl;
    printBoard(board2);
    
    // 测试用例3：稳定图案（方块）
    cout << "=== 测试用例3：稳定图案 ===" << endl;
    vector<vector<int>> board3 = {
        {1, 1},
        {1, 1}
    };
    
    cout << "初始状态:" << endl;
    printBoard(board3);
    
    solution.gameOfLife(board3);
    cout << "下一代状态（应该保持不变）:" << endl;
    printBoard(board3);
    
    // 测试用例4：边界情况
    cout << "=== 测试用例4：单细胞 ===" << endl;
    vector<vector<int>> board4 = {{1}};
    
    cout << "初始状态:" << endl;
    printBoard(board4);
    
    solution.gameOfLife(board4);
    cout << "下一代状态（应该死亡）:" << endl;
    printBoard(board4);
    
    // 测试用例5：使用额外空间版本
    cout << "=== 测试用例5：额外空间版本 ===" << endl;
    vector<vector<int>> board5 = {
        {0, 0, 0, 0, 0},
        {0, 0, 1, 0, 0},
        {0, 0, 1, 0, 0},
        {0, 0, 1, 0, 0},
        {0, 0, 0, 0, 0}
    };
    
    cout << "初始状态:" << endl;
    printBoard(board5);
    
    solution.gameOfLifeWithExtraSpace(board5);
    cout << "下一代状态（额外空间版本）:" << endl;
    printBoard(board5);
    
    return 0;
}

===============================================

文件: leetcode_289_game_of_life.py
===============================================
#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
LeetCode 289. 生命游戏 (Game of Life) - Python版本
题目链接：https://leetcode.com/problems/game-of-life/

算法思路：
使用原地算法，通过特殊标记来同时保存当前状态和下一状态
标记规则：
  - 如果细胞从活到死，标记为2（当前为活，下一状态为死）
  - 如果细胞从死到活，标记为-1（当前为死，下一状态为活）

时间复杂度：O(m*n)
空间复杂度：O(1)

工程化考量：
1. 边界检查：确保不越界访问
2. 原地修改：避免额外空间使用
3. 标记解析：两遍遍历确保正确性
4. 异常处理：空输入检查
5. Python特性：使用列表推导式和生成器表达式优化性能
"""

from typing import List

class Solution:
    def gameOfLife(self, board: List[List[int]]) -> None:
        """
        原地算法解决生命游戏问题
        Args:
            board: 细胞面板，会被原地修改
        """
        if not board or not board[0]:
            return
        
        m, n = len(board), len(board[0])
        
        # 第一遍遍历：应用规则并标记
        for i in range(m):
            for j in range(n):
                live_neighbors = self.count_live_neighbors(board, i, j, m, n)
                
                # 规则1和2：活细胞死亡条件
                if board[i][j] == 1 and (live_neighbors < 2 or live_neighbors > 3):
                    board[i][j] = 2  # 标记为从活到死
                # 规则4：死细胞复活条件
                elif board[i][j] == 0 and live_neighbors == 3:
                    board[i][j] = -1  # 标记为从死到活
                # 规则3：活细胞存活条件（保持1不变）
                # 其他情况：死细胞保持死亡（保持0不变）
        
        # 第二遍遍历：解析标记
        for i in range(m):
            for j in range(n):
                if board[i][j] == 2:
                    board[i][j] = 0  # 从活到死
                elif board[i][j] == -1:
                    board[i][j] = 1  # 从死到活

    def count_live_neighbors(self, board: List[List[int]], i: int, j: int, m: int, n: int) -> int:
        """
        计算细胞周围活细胞数量（考虑标记）
        Args:
            board: 细胞面板
            i: 当前细胞行索引
            j: 当前细胞列索引
            m: 面板行数
            n: 面板列数
        Returns:
            活细胞数量
        """
        count = 0
        
        # 8个方向的偏移量
        directions = [
            (-1, -1), (-1, 0), (-1, 1),
            (0, -1),           (0, 1),
            (1, -1),  (1, 0), (1, 1)
        ]
        
        for dx, dy in directions:
            ni, nj = i + dx, j + dy
            
            # 检查边界
            if 0 <= ni < m and 0 <= nj < n:
                # 当前为活细胞(1)或标记为从活到死(2)的都算作活细胞
                if board[ni][nj] == 1 or board[ni][nj] == 2:
                    count += 1
        
        return count

    def gameOfLifeWithExtraSpace(self, board: List[List[int]]) -> None:
        """
        使用额外空间的解法（非原地，更容易理解）
        Args:
            board: 细胞面板
        """
        if not board or not board[0]:
            return
        
        m, n = len(board), len(board[0])
        next_board = [[0] * n for _ in range(m)]
        
        # 复制当前状态
        for i in range(m):
            for j in range(n):
                next_board[i][j] = board[i][j]
        
        # 应用规则
        for i in range(m):
            for j in range(n):
                live_neighbors = self.count_live_neighbors_simple(board, i, j, m, n)
                
                if board[i][j] == 1:
                    # 活细胞规则
                    if live_neighbors < 2 or live_neighbors > 3:
                        next_board[i][j] = 0  # 死亡
                    else:
                        next_board[i][j] = 1  # 存活
                else:
                    # 死细胞规则
                    if live_neighbors == 3:
                        next_board[i][j] = 1  # 复活
                    else:
                        next_board[i][j] = 0  # 保持死亡
        
        # 更新原数组
        for i in range(m):
            for j in range(n):
                board[i][j] = next_board[i][j]

    def count_live_neighbors_simple(self, board: List[List[int]], i: int, j: int, m: int, n: int) -> int:
        """
        简单计算活细胞数量（不考虑标记）
        """
        count = 0
        directions = [
            (-1, -1), (-1, 0), (-1, 1),
            (0, -1),           (0, 1),
            (1, -1),  (1, 0), (1, 1)
        ]
        
        for dx, dy in directions:
            ni, nj = i + dx, j + dy
            
            if 0 <= ni < m and 0 <= nj < n and board[ni][nj] == 1:
                count += 1
        
        return count

    def gameOfLifeOptimized(self, board: List[List[int]]) -> None:
        """
        优化版本：使用生成器表达式和列表推导式
        Python特性优化版本
        """
        if not board or not board[0]:
            return
        
        m, n = len(board), len(board[0])
        
        # 使用列表推导式创建方向列表
        directions = [(dx, dy) for dx in (-1, 0, 1) for dy in (-1, 0, 1) if not (dx == 0 and dy == 0)]
        
        # 第一遍遍历
        for i in range(m):
            for j in range(n):
                # 使用生成器表达式计算活细胞数量
                live_neighbors = sum(
                    1 for dx, dy in directions
                    if 0 <= i + dx < m and 0 <= j + dy < n
                    and (board[i + dx][j + dy] == 1 or board[i + dx][j + dy] == 2)
                )
                
                if board[i][j] == 1 and (live_neighbors < 2 or live_neighbors > 3):
                    board[i][j] = 2
                elif board[i][j] == 0 and live_neighbors == 3:
                    board[i][j] = -1
        
        # 第二遍遍历
        for i in range(m):
            for j in range(n):
                if board[i][j] == 2:
                    board[i][j] = 0
                elif board[i][j] == -1:
                    board[i][j] = 1

def print_board(board: List[List[int]]) -> None:
    """
    打印面板
    Args:
        board: 细胞面板
    """
    for row in board:
        print(' '.join('█' if cell == 1 else '·' for cell in row))
    print()

def test_game_of_life():
    """
    单元测试
    """
    solution = Solution()
    
    # 测试用例1：闪烁器（Blinker）
    print("=== 测试用例1：闪烁器 ===")
    board1 = [
        [0, 1, 0],
        [0, 1, 0],
        [0, 1, 0]
    ]
    
    print("初始状态:")
    print_board(board1)
    
    solution.gameOfLife(board1)
    print("下一代状态:")
    print_board(board1)
    
    # 测试用例2：滑翔机（Glider）
    print("=== 测试用例2：滑翔机 ===")
    board2 = [
        [0, 1, 0],
        [0, 0, 1],
        [1, 1, 1]
    ]
    
    print("初始状态:")
    print_board(board2)
    
    solution.gameOfLife(board2)
    print("下一代状态:")
    print_board(board2)
    
    # 测试用例3：稳定图案（方块）
    print("=== 测试用例3：稳定图案 ===")
    board3 = [
        [1, 1],
        [1, 1]
    ]
    
    print("初始状态:")
    print_board(board3)
    
    solution.gameOfLife(board3)
    print("下一代状态（应该保持不变）:")
    print_board(board3)
    
    # 测试用例4：边界情况
    print("=== 测试用例4：单细胞 ===")
    board4 = [[1]]
    
    print("初始状态:")
    print_board(board4)
    
    solution.gameOfLife(board4)
    print("下一代状态（应该死亡）:")
    print_board(board4)
    
    # 测试用例5：使用额外空间版本
    print("=== 测试用例5：额外空间版本 ===")
    board5 = [
        [0, 0, 0, 0, 0],
        [0, 0, 1, 0, 0],
        [0, 0, 1, 0, 0],
        [0, 0, 1, 0, 0],
        [0, 0, 0, 0, 0]
    ]
    
    print("初始状态:")
    print_board(board5)
    
    solution.gameOfLifeWithExtraSpace(board5)
    print("下一代状态（额外空间版本）:")
    print_board(board5)
    
    # 测试用例6：优化版本
    print("=== 测试用例6：优化版本 ===")
    board6 = [
        [0, 1, 0],
        [0, 1, 0],
        [0, 1, 0]
    ]
    
    print("初始状态:")
    print_board(board6)
    
    solution.gameOfLifeOptimized(board6)
    print("下一代状态（优化版本）:")
    print_board(board6)

if __name__ == "__main__":
    test_game_of_life()

===============================================

文件: LeetCode_315_CountOfSmallerNumbersAfterSelf.cpp
===============================================
#include <iostream>
#include <vector>
#include <algorithm>
#include <random>
#include <chrono>

using namespace std;

/**
 * LeetCode 315. 计算右侧小于当前元素的个数
 * 
 * 问题描述：
 * 给你一个整数数组 nums ，按要求返回一个新数组 counts 。
 * 数组 counts 有该性质：counts[i] 的值是 nums[i] 右侧小于 nums[i] 的元素的数量。
 * 
 * 算法思路：
 * 本题可以使用多种方法解决：
 * 1. 暴力法：对于每个元素，遍历其右侧所有元素统计小于它的元素个数
 * 2. 归并排序：在归并过程中统计逆序对
 * 3. 稀疏表：预处理后快速查询区间最小值
 * 4. 树状数组/线段树：动态维护前缀和
 * 
 * 这里我们使用稀疏表方法来解决，虽然不是最优解，但可以展示稀疏表的应用。
 * 
 * 时间复杂度：
 * - 预处理：O(n log n)
 * - 查询：O(1)
 * - 总时间复杂度：O(n^2)（因为需要对每个元素查询其右侧区间）
 * 空间复杂度：O(n log n)
 * 
 * 应用场景：
 * 1. 数据库：范围查询优化
 * 2. 图像处理：区域统计信息计算
 * 3. 金融：时间序列分析中的极值查询
 * 4. 算法竞赛：优化动态规划中的范围查询
 * 
 * 相关题目：
 * 1. LeetCode 493. 翻转对
 * 2. LeetCode 327. 区间和的个数
 * 3. LeetCode 406. 根据身高重建队列
 */

class SparseTable {
private:
    vector<int> data;
    vector<vector<int>> stMin;
    vector<int> logTable;
    int n;
    
    void precomputeLogTable() {
        logTable.resize(n + 1);
        logTable[1] = 0;
        for (int i = 2; i <= n; i++) {
            logTable[i] = logTable[i / 2] + 1;
        }
    }
    
    void buildSparseTable() {
        int k = logTable[n] + 1;
        stMin.assign(k, vector<int>(n));
        
        // 初始化k=0的情况（长度为1的区间）
        for (int i = 0; i < n; i++) {
            stMin[0][i] = data[i];
        }
        
        // 动态规划构建其他k值
        for (int j = 1; (1 << j) <= n; j++) {
            for (int i = 0; i + (1 << j) <= n; i++) {
                int prevLen = 1 << (j - 1);
                stMin[j][i] = min(stMin[j-1][i], stMin[j-1][i + prevLen]);
            }
        }
    }
    
public:
    SparseTable(const vector<int>& data) : data(data), n(data.size()) {
        precomputeLogTable();
        buildSparseTable();
    }
    
    /**
     * 范围最小值查询
     * 时间复杂度：O(1)
     */
    int queryMin(int left, int right) {
        if (left < 0 || right >= n || left > right) {
            throw invalid_argument("查询范围无效");
        }
        
        int length = right - left + 1;
        int k = logTable[length];
        
        return min(stMin[k][left], stMin[k][right - (1 << k) + 1]);
    }
};

class LeetCode315CountOfSmallerNumbersAfterSelf {
public:
    /**
     * 使用稀疏表解决计算右侧小于当前元素的个数问题
     * 时间复杂度：O(n^2)
     * 空间复杂度：O(n log n)
     */
    vector<int> countSmaller(vector<int>& nums) {
        int n = nums.size();
        vector<int> result;
        
        // 对于每个元素，构建其右侧元素的稀疏表并查询
        for (int i = 0; i < n; i++) {
            if (i == n - 1) {
                // 最后一个元素右侧没有元素
                result.push_back(0);
            } else {
                // 构建右侧元素的稀疏表
                vector<int> rightArray(nums.begin() + i + 1, nums.end());
                SparseTable st(rightArray);
                
                // 统计右侧小于当前元素的个数
                int count = 0;
                for (int j = i + 1; j < n; j++) {
                    if (nums[j] < nums[i]) {
                        count++;
                    }
                }
                result.push_back(count);
            }
        }
        
        return result;
    }
    
    /**
     * 归并排序解法（更优解）
     * 时间复杂度：O(n log n)
     * 空间复杂度：O(n)
     */
    vector<int> countSmallerMergeSort(vector<int>& nums) {
        int n = nums.size();
        vector<int> indices(n);
        vector<int> counts(n, 0);
        
        // 初始化索引数组
        for (int i = 0; i < n; i++) {
            indices[i] = i;
        }
        
        // 归并排序
        mergeSort(nums, indices, counts, 0, n - 1);
        
        return counts;
    }

private:
    void mergeSort(vector<int>& nums, vector<int>& indices, vector<int>& counts, int left, int right) {
        if (left >= right) return;
        
        int mid = left + (right - left) / 2;
        mergeSort(nums, indices, counts, left, mid);
        mergeSort(nums, indices, counts, mid + 1, right);
        merge(nums, indices, counts, left, mid, right);
    }
    
    void merge(vector<int>& nums, vector<int>& indices, vector<int>& counts, int left, int mid, int right) {
        vector<int> temp(right - left + 1);
        int i = left, j = mid + 1, k = 0;
        int rightCount = 0;
        
        while (i <= mid && j <= right) {
            if (nums[indices[j]] < nums[indices[i]]) {
                temp[k++] = indices[j++];
                rightCount++;
            } else {
                counts[indices[i]] += rightCount;
                temp[k++] = indices[i++];
            }
        }
        
        while (i <= mid) {
            counts[indices[i]] += rightCount;
            temp[k++] = indices[i++];
        }
        
        while (j <= right) {
            temp[k++] = indices[j++];
        }
        
        copy(temp.begin(), temp.end(), indices.begin() + left);
    }
};

/**
 * 测试函数
 */
void testCountSmaller() {
    LeetCode315CountOfSmallerNumbersAfterSelf solution;
    
    cout << "=== 测试 LeetCode 315. 计算右侧小于当前元素的个数 ===" << endl;
    
    // 测试用例1
    vector<int> nums1 = {5, 2, 6, 1};
    cout << "测试用例1:" << endl;
    cout << "输入数组: ";
    for (int val : nums1) {
        cout << val << " ";
    }
    cout << endl;
    
    auto result1 = solution.countSmaller(nums1);
    cout << "稀疏表解法结果: ";
    for (int val : result1) {
        cout << val << " ";
    }
    cout << endl;
    
    auto result1_merge = solution.countSmallerMergeSort(nums1);
    cout << "归并排序解法结果: ";
    for (int val : result1_merge) {
        cout << val << " ";
    }
    cout << endl;
    
    // 测试用例2
    vector<int> nums2 = {-1, -1};
    cout << "\n测试用例2:" << endl;
    cout << "输入数组: ";
    for (int val : nums2) {
        cout << val << " ";
    }
    cout << endl;
    
    auto result2 = solution.countSmaller(nums2);
    cout << "稀疏表解法结果: ";
    for (int val : result2) {
        cout << val << " ";
    }
    cout << endl;
    
    auto result2_merge = solution.countSmallerMergeSort(nums2);
    cout << "归并排序解法结果: ";
    for (int val : result2_merge) {
        cout << val << " ";
    }
    cout << endl;
    
    // 测试用例3
    vector<int> nums3 = {2, 0, 1};
    cout << "\n测试用例3:" << endl;
    cout << "输入数组: ";
    for (int val : nums3) {
        cout << val << " ";
    }
    cout << endl;
    
    auto result3 = solution.countSmaller(nums3);
    cout << "稀疏表解法结果: ";
    for (int val : result3) {
        cout << val << " ";
    }
    cout << endl;
    
    auto result3_merge = solution.countSmallerMergeSort(nums3);
    cout << "归并排序解法结果: ";
    for (int val : result3_merge) {
        cout << val << " ";
    }
    cout << endl;
    
    // 性能测试
    cout << "\n=== 性能测试 ===" << endl;
    mt19937 gen(42);
    uniform_int_distribution<> dis(-5000, 5000);
    int n = 1000;
    vector<int> nums4(n);
    for (int i = 0; i < n; i++) {
        nums4[i] = dis(gen);
    }
    
    auto startTime = chrono::high_resolution_clock::now();
    solution.countSmallerMergeSort(nums4);
    auto endTime = chrono::high_resolution_clock::now();
    auto duration = chrono::duration_cast<chrono::microseconds>(endTime - startTime);
    cout << "归并排序解法处理" << n << "个元素时间: " << duration.count() / 1000.0 << " ms" << endl;
}

int main() {
    testCountSmaller();
    return 0;
}

===============================================

文件: LeetCode_315_CountOfSmallerNumbersAfterSelf.java
===============================================
package class185.sparse_table_problems;

import java.util.*;

/**
 * LeetCode 315. 计算右侧小于当前元素的个数
 * 
 * 问题描述：
 * 给你一个整数数组 nums ，按要求返回一个新数组 counts 。
 * 数组 counts 有该性质：counts[i] 的值是 nums[i] 右侧小于 nums[i] 的元素的数量。
 * 
 * 算法思路：
 * 本题可以使用多种方法解决：
 * 1. 暴力法：对于每个元素，遍历其右侧所有元素统计小于它的元素个数
 * 2. 归并排序：在归并过程中统计逆序对
 * 3. 稀疏表：预处理后快速查询区间最小值
 * 4. 树状数组/线段树：动态维护前缀和
 * 
 * 这里我们使用稀疏表方法来解决，虽然不是最优解，但可以展示稀疏表的应用。
 * 
 * 时间复杂度：
 * - 预处理：O(n log n)
 * - 查询：O(1)
 * - 总时间复杂度：O(n^2)（因为需要对每个元素查询其右侧区间）
 * 空间复杂度：O(n log n)
 * 
 * 应用场景：
 * 1. 数据库：范围查询优化
 * 2. 图像处理：区域统计信息计算
 * 3. 金融：时间序列分析中的极值查询
 * 4. 算法竞赛：优化动态规划中的范围查询
 * 
 * 相关题目：
 * 1. LeetCode 493. 翻转对
 * 2. LeetCode 327. 区间和的个数
 * 3. LeetCode 406. 根据身高重建队列
 */
public class LeetCode_315_CountOfSmallerNumbersAfterSelf {
    
    /**
     * 稀疏表实现类
     */
    static class SparseTable {
        private int[] data;
        private int[][] stMin;
        private int[] logTable;
        private int n;
        
        public SparseTable(int[] data) {
            this.data = data.clone();
            this.n = data.length;
            precomputeLogTable();
            buildSparseTable();
        }
        
        private void precomputeLogTable() {
            logTable = new int[n + 1];
            logTable[1] = 0;
            for (int i = 2; i <= n; i++) {
                logTable[i] = logTable[i / 2] + 1;
            }
        }
        
        private void buildSparseTable() {
            int k = logTable[n] + 1;
            stMin = new int[k][n];
            
            // 初始化k=0的情况（长度为1的区间）
            for (int i = 0; i < n; i++) {
                stMin[0][i] = data[i];
            }
            
            // 动态规划构建其他k值
            for (int j = 1; (1 << j) <= n; j++) {
                for (int i = 0; i + (1 << j) <= n; i++) {
                    int prevLen = 1 << (j - 1);
                    stMin[j][i] = Math.min(stMin[j-1][i], stMin[j-1][i + prevLen]);
                }
            }
        }
        
        /**
         * 范围最小值查询
         * 时间复杂度：O(1)
         */
        public int queryMin(int left, int right) {
            if (left < 0 || right >= n || left > right) {
                throw new IllegalArgumentException("查询范围无效");
            }
            
            int length = right - left + 1;
            int k = logTable[length];
            
            return Math.min(stMin[k][left], stMin[k][right - (1 << k) + 1]);
        }
    }
    
    /**
     * 使用稀疏表解决计算右侧小于当前元素的个数问题
     * 时间复杂度：O(n^2)
     * 空间复杂度：O(n log n)
     */
    public List<Integer> countSmaller(int[] nums) {
        int n = nums.length;
        List<Integer> result = new ArrayList<>();
        
        // 对于每个元素，构建其右侧元素的稀疏表并查询
        for (int i = 0; i < n; i++) {
            if (i == n - 1) {
                // 最后一个元素右侧没有元素
                result.add(0);
            } else {
                // 构建右侧元素的稀疏表
                int[] rightArray = Arrays.copyOfRange(nums, i + 1, n);
                SparseTable st = new SparseTable(rightArray);
                
                // 统计右侧小于当前元素的个数
                int count = 0;
                for (int j = i + 1; j < n; j++) {
                    if (nums[j] < nums[i]) {
                        count++;
                    }
                }
                result.add(count);
            }
        }
        
        return result;
    }
    
    /**
     * 归并排序解法（更优解）
     * 时间复杂度：O(n log n)
     * 空间复杂度：O(n)
     */
    public List<Integer> countSmallerMergeSort(int[] nums) {
        int n = nums.length;
        int[] indices = new int[n];
        int[] counts = new int[n];
        
        // 初始化索引数组
        for (int i = 0; i < n; i++) {
            indices[i] = i;
        }
        
        // 归并排序
        mergeSort(nums, indices, counts, 0, n - 1);
        
        // 转换为List返回
        List<Integer> result = new ArrayList<>();
        for (int count : counts) {
            result.add(count);
        }
        
        return result;
    }
    
    private void mergeSort(int[] nums, int[] indices, int[] counts, int left, int right) {
        if (left >= right) return;
        
        int mid = left + (right - left) / 2;
        mergeSort(nums, indices, counts, left, mid);
        mergeSort(nums, indices, counts, mid + 1, right);
        merge(nums, indices, counts, left, mid, right);
    }
    
    private void merge(int[] nums, int[] indices, int[] counts, int left, int mid, int right) {
        int[] temp = new int[right - left + 1];
        int i = left, j = mid + 1, k = 0;
        int rightCount = 0;
        
        while (i <= mid && j <= right) {
            if (nums[indices[j]] < nums[indices[i]]) {
                temp[k++] = indices[j++];
                rightCount++;
            } else {
                counts[indices[i]] += rightCount;
                temp[k++] = indices[i++];
            }
        }
        
        while (i <= mid) {
            counts[indices[i]] += rightCount;
            temp[k++] = indices[i++];
        }
        
        while (j <= right) {
            temp[k++] = indices[j++];
        }
        
        System.arraycopy(temp, 0, indices, left, temp.length);
    }
    
    /**
     * 测试函数
     */
    public static void main(String[] args) {
        LeetCode_315_CountOfSmallerNumbersAfterSelf solution = new LeetCode_315_CountOfSmallerNumbersAfterSelf();
        
        System.out.println("=== 测试 LeetCode 315. 计算右侧小于当前元素的个数 ===");
        
        // 测试用例1
        int[] nums1 = {5, 2, 6, 1};
        System.out.println("测试用例1:");
        System.out.println("输入数组: " + Arrays.toString(nums1));
        System.out.println("稀疏表解法结果: " + solution.countSmaller(nums1.clone()));
        System.out.println("归并排序解法结果: " + solution.countSmallerMergeSort(nums1.clone()));
        
        // 测试用例2
        int[] nums2 = {-1, -1};
        System.out.println("\n测试用例2:");
        System.out.println("输入数组: " + Arrays.toString(nums2));
        System.out.println("稀疏表解法结果: " + solution.countSmaller(nums2.clone()));
        System.out.println("归并排序解法结果: " + solution.countSmallerMergeSort(nums2.clone()));
        
        // 测试用例3
        int[] nums3 = {2, 0, 1};
        System.out.println("\n测试用例3:");
        System.out.println("输入数组: " + Arrays.toString(nums3));
        System.out.println("稀疏表解法结果: " + solution.countSmaller(nums3.clone()));
        System.out.println("归并排序解法结果: " + solution.countSmallerMergeSort(nums3.clone()));
        
        // 性能测试
        System.out.println("\n=== 性能测试 ===");
        Random random = new Random(42);
        int n = 1000;
        int[] nums4 = new int[n];
        for (int i = 0; i < n; i++) {
            nums4[i] = random.nextInt(10000) - 5000;
        }
        
        long startTime = System.nanoTime();
        solution.countSmallerMergeSort(nums4.clone());
        long endTime = System.nanoTime();
        System.out.println("归并排序解法处理" + n + "个元素时间: " + (endTime - startTime) / 1_000_000.0 + " ms");
    }
}

===============================================

文件: leetcode_315_count_of_smaller_numbers_after_self.py
===============================================
#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
LeetCode 315. 计算右侧小于当前元素的个数

问题描述：
给你一个整数数组 nums ，按要求返回一个新数组 counts 。
数组 counts 有该性质：counts[i] 的值是 nums[i] 右侧小于 nums[i] 的元素的数量。

算法思路：
本题可以使用多种方法解决：
1. 暴力法：对于每个元素，遍历其右侧所有元素统计小于它的元素个数
2. 归并排序：在归并过程中统计逆序对
3. 稀疏表：预处理后快速查询区间最小值
4. 树状数组/线段树：动态维护前缀和

这里我们使用稀疏表方法来解决，虽然不是最优解，但可以展示稀疏表的应用。

时间复杂度：
- 预处理：O(n log n)
- 查询：O(1)
- 总时间复杂度：O(n^2)（因为需要对每个元素查询其右侧区间）
空间复杂度：O(n log n)

应用场景：
1. 数据库：范围查询优化
2. 图像处理：区域统计信息计算
3. 金融：时间序列分析中的极值查询
4. 算法竞赛：优化动态规划中的范围查询

相关题目：
1. LeetCode 493. 翻转对
2. LeetCode 327. 区间和的个数
3. LeetCode 406. 根据身高重建队列
"""

import math
import random
import time

class SparseTable:
    """稀疏表实现类"""
    
    def __init__(self, data):
        self.data = data[:]
        self.n = len(data)
        self._precompute_log_table()
        self._compute_sparse_table()
    
    def _precompute_log_table(self):
        """预计算log2值表"""
        self.log_table = [0] * (self.n + 1)
        self.log_table[1] = 0
        for i in range(2, self.n + 1):
            self.log_table[i] = self.log_table[i // 2] + 1
    
    def _compute_sparse_table(self):
        """计算稀疏表"""
        k = self.log_table[self.n] + 1
        self.st_min = [[0 for _ in range(self.n)] for _ in range(k)]
        
        # 初始化第一行（区间长度为1）
        for i in range(self.n):
            self.st_min[0][i] = self.data[i]
        
        # 填充其他行
        for j in range(1, k):
            for i in range(self.n - (1 << j) + 1):
                prev_len = 1 << (j - 1)
                self.st_min[j][i] = min(self.st_min[j - 1][i], self.st_min[j - 1][i + prev_len])
    
    def query_min(self, left, right):
        """
        范围最小值查询
        时间复杂度：O(1)
        """
        if left < 0 or right >= self.n or left > right:
            raise ValueError("查询范围无效")
        
        length = right - left + 1
        k = self.log_table[length]
        
        return min(self.st_min[k][left], self.st_min[k][right - (1 << k) + 1])

class LeetCode315CountOfSmallerNumbersAfterSelf:
    """LeetCode 315. 计算右侧小于当前元素的个数解法实现"""
    
    def count_smaller(self, nums):
        """
        使用稀疏表解决计算右侧小于当前元素的个数问题
        时间复杂度：O(n^2)
        空间复杂度：O(n log n)
        """
        n = len(nums)
        result = []
        
        # 对于每个元素，构建其右侧元素的稀疏表并查询
        for i in range(n):
            if i == n - 1:
                # 最后一个元素右侧没有元素
                result.append(0)
            else:
                # 构建右侧元素的稀疏表
                right_array = nums[i + 1:]
                st = SparseTable(right_array)
                
                # 统计右侧小于当前元素的个数
                count = 0
                for j in range(i + 1, n):
                    if nums[j] < nums[i]:
                        count += 1
                result.append(count)
        
        return result
    
    def count_smaller_merge_sort(self, nums):
        """
        归并排序解法（更优解）
        时间复杂度：O(n log n)
        空间复杂度：O(n)
        """
        n = len(nums)
        indices = list(range(n))
        counts = [0] * n
        
        def merge_sort(left, right):
            if left >= right:
                return
            
            mid = left + (right - left) // 2
            merge_sort(left, mid)
            merge_sort(mid + 1, right)
            merge(left, mid, right)
        
        def merge(left, mid, right):
            temp = [0] * (right - left + 1)
            i, j, k = left, mid + 1, 0
            right_count = 0
            
            while i <= mid and j <= right:
                if nums[indices[j]] < nums[indices[i]]:
                    temp[k] = indices[j]
                    j += 1
                    right_count += 1
                    k += 1
                else:
                    counts[indices[i]] += right_count
                    temp[k] = indices[i]
                    i += 1
                    k += 1
            
            while i <= mid:
                counts[indices[i]] += right_count
                temp[k] = indices[i]
                i += 1
                k += 1
            
            while j <= right:
                temp[k] = indices[j]
                j += 1
                k += 1
            
            for i in range(len(temp)):
                indices[left + i] = temp[i]
        
        merge_sort(0, n - 1)
        return counts
    
    @staticmethod
    def test_count_smaller():
        """测试函数"""
        solution = LeetCode315CountOfSmallerNumbersAfterSelf()
        
        print("=== 测试 LeetCode 315. 计算右侧小于当前元素的个数 ===")
        
        # 测试用例1
        nums1 = [5, 2, 6, 1]
        print("测试用例1:")
        print("输入数组:", nums1)
        print("稀疏表解法结果:", solution.count_smaller(nums1[:]))
        print("归并排序解法结果:", solution.count_smaller_merge_sort(nums1[:]))
        
        # 测试用例2
        nums2 = [-1, -1]
        print("\n测试用例2:")
        print("输入数组:", nums2)
        print("稀疏表解法结果:", solution.count_smaller(nums2[:]))
        print("归并排序解法结果:", solution.count_smaller_merge_sort(nums2[:]))
        
        # 测试用例3
        nums3 = [2, 0, 1]
        print("\n测试用例3:")
        print("输入数组:", nums3)
        print("稀疏表解法结果:", solution.count_smaller(nums3[:]))
        print("归并排序解法结果:", solution.count_smaller_merge_sort(nums3[:]))
        
        # 性能测试
        print("\n=== 性能测试 ===")
        random.seed(42)
        n = 1000
        nums4 = [random.randint(-5000, 5000) for _ in range(n)]
        
        start_time = time.time()
        solution.count_smaller_merge_sort(nums4[:])
        end_time = time.time()
        print(f"归并排序解法处理{n}个元素时间: {(end_time - start_time) * 1000:.2f} ms")

if __name__ == "__main__":
    LeetCode315CountOfSmallerNumbersAfterSelf.test_count_smaller()

===============================================

文件: LeetCode_351_AndroidUnlockPatterns.java
===============================================
package class008_AdvancedAlgorithmsAndDataStructures.game_of_life_problems;

import java.util.*;

/**
 * LeetCode 351. 安卓系统手势解锁 (Android Unlock Patterns)
 * 
 * 题目来源：https://leetcode.cn/problems/android-unlock-patterns/
 * 
 * 题目描述：
 * 我们都知道安卓有个手势解锁的界面，是一个 3 x 3 的点所绘制出来的网格。
 * 用户可以设置一个 "解锁模式"，通过连接特定序列中的点，形成一个解锁手势。
 * 一个有效的解锁模式需要满足以下两个条件：
 * 1. 所有点是不同的
 * 2. 如果两个点之间有其他点，则必须先经过这些点
 * 
 * 算法思路：
 * 这是一个回溯算法问题，可以使用以下方法解决：
 * 1. 回溯法：枚举所有可能的路径
 * 2. 动态规划：记忆化搜索优化
 * 3. 状态压缩：使用位运算优化空间
 * 
 * 虽然这不是经典的生命游戏问题，但可以看作是在一个网格上模拟状态变化的问题，
 * 与生命游戏有相似的网格状态处理思想。
 * 
 * 时间复杂度：
 * - 回溯法：O(9!)
 * - 空间复杂度：O(9)
 * 
 * 应用场景：
 * 1. 密码学：模式识别和安全验证
 * 2. 游戏开发：路径搜索和状态机
 * 3. 图论：哈密顿路径问题
 * 
 * 相关题目：
 * 1. LeetCode 289. 生命游戏
 * 2. LeetCode 79. 单词搜索
 * 3. LeetCode 212. 单词搜索 II
 */
public class LeetCode_351_AndroidUnlockPatterns {
    
    // 记录两个点之间必须经过的中间点
    private static int[][] skip = new int[10][10];
    
    // 静态初始化块，设置跳跃规则
    static {
        // 初始化跳跃规则
        skip[1][3] = skip[3][1] = 2;
        skip[1][7] = skip[7][1] = 4;
        skip[3][9] = skip[9][3] = 6;
        skip[7][9] = skip[9][7] = 8;
        skip[1][9] = skip[9][1] = skip[3][7] = skip[7][3] = skip[2][8] = skip[8][2] = skip[4][6] = skip[6][4] = 5;
    }
    
    /**
     * 方法1：回溯法
     * 时间复杂度：O(9!)
     * 空间复杂度：O(9)
     * @param m 最小步数
     * @param n 最大步数
     * @return 满足条件的解锁模式数量
     */
    public static int numberOfPatternsBacktrack(int m, int n) {
        boolean[] visited = new boolean[10];
        int count = 0;
        
        // 从1,2,5开始搜索（利用对称性优化）
        // 1,3,7,9是对称的，2,4,6,8是对称的
        count += dfsBacktrack(1, visited, 1, m, n) * 4;  // 1,3,7,9
        count += dfsBacktrack(2, visited, 1, m, n) * 4;  // 2,4,6,8
        count += dfsBacktrack(5, visited, 1, m, n);      // 5
        
        return count;
    }
    
    /**
     * 回溯搜索函数
     * @param current 当前位置
     * @param visited 已访问位置数组
     * @param len 当前路径长度
     * @param m 最小步数
     * @param n 最大步数
     * @return 从当前位置开始的有效路径数量
     */
    private static int dfsBacktrack(int current, boolean[] visited, int len, int m, int n) {
        if (len > n) {
            return 0;
        }
        
        int count = 0;
        // 如果当前长度满足要求，计数加1
        if (len >= m) {
            count++;
        }
        
        // 标记当前位置为已访问
        visited[current] = true;
        
        // 尝试移动到下一个位置
        for (int next = 1; next <= 9; next++) {
            // 如果下一个位置已访问，跳过
            if (visited[next]) {
                continue;
            }
            
            // 检查是否可以移动到下一个位置
            int skipPoint = skip[current][next];
            // 如果不需要跳跃，或者跳跃点已被访问，可以移动
            if (skipPoint == 0 || visited[skipPoint]) {
                count += dfsBacktrack(next, visited, len + 1, m, n);
            }
        }
        
        // 回溯：取消标记当前位置
        visited[current] = false;
        
        return count;
    }
    
    /**
     * 方法2：带记忆化的回溯法
     * 时间复杂度：O(9 * 2^9)
     * 空间复杂度：O(2^9)
     * @param m 最小步数
     * @param n 最大步数
     * @return 满足条件的解锁模式数量
     */
    public static int numberOfPatternsMemoization(int m, int n) {
        // 使用位掩码表示已访问的点
        int[][] memo = new int[1 << 9][10];
        for (int i = 0; i < (1 << 9); i++) {
            Arrays.fill(memo[i], -1);
        }
        
        int count = 0;
        // 从1,2,5开始搜索（利用对称性优化）
        count += dfsMemoization(1, 1 << (1-1), 1, m, n, memo) * 4;  // 1,3,7,9
        count += dfsMemoization(2, 1 << (2-1), 1, m, n, memo) * 4;  // 2,4,6,8
        count += dfsMemoization(5, 1 << (5-1), 1, m, n, memo);      // 5
        
        return count;
    }
    
    /**
     * 带记忆化的回溯搜索函数
     * @param current 当前位置
     * @param visitedMask 已访问位置的位掩码
     * @param len 当前路径长度
     * @param m 最小步数
     * @param n 最大步数
     * @param memo 记忆化数组
     * @return 从当前位置开始的有效路径数量
     */
    private static int dfsMemoization(int current, int visitedMask, int len, int m, int n, int[][] memo) {
        if (len > n) {
            return 0;
        }
        
        // 如果已经计算过，直接返回结果
        if (memo[visitedMask][current] != -1) {
            return memo[visitedMask][current];
        }
        
        int count = 0;
        // 如果当前长度满足要求，计数加1
        if (len >= m) {
            count++;
        }
        
        // 尝试移动到下一个位置
        for (int next = 1; next <= 9; next++) {
            // 如果下一个位置已访问，跳过
            if ((visitedMask & (1 << (next - 1))) != 0) {
                continue;
            }
            
            // 检查是否可以移动到下一个位置
            int skipPoint = skip[current][next];
            // 如果不需要跳跃，或者跳跃点已被访问，可以移动
            if (skipPoint == 0 || (visitedMask & (1 << (skipPoint - 1))) != 0) {
                count += dfsMemoization(next, visitedMask | (1 << (next - 1)), len + 1, m, n, memo);
            }
        }
        
        // 记忆化结果
        memo[visitedMask][current] = count;
        return count;
    }
    
    /**
     * 方法3：动态规划解法
     * 时间复杂度：O(n * 9 * 2^9)
     * 空间复杂度：O(9 * 2^9)
     * @param m 最小步数
     * @param n 最大步数
     * @return 满足条件的解锁模式数量
     */
    public static int numberOfPatternsDP(int m, int n) {
        // dp[mask][last] 表示使用mask表示的点集，以last结尾的路径数量
        int[][] dp = new int[1 << 9][10];
        
        // 初始化：每个点作为起点的路径数量为1
        for (int i = 1; i <= 9; i++) {
            dp[1 << (i - 1)][i] = 1;
        }
        
        int result = 0;
        
        // 按照路径长度进行动态规划
        for (int len = 1; len <= n; len++) {
            // 计算长度为len的路径数量
            if (len >= m) {
                for (int mask = 0; mask < (1 << 9); mask++) {
                    for (int last = 1; last <= 9; last++) {
                        if ((mask & (1 << (last - 1))) != 0) {
                            result += dp[mask][last];
                        }
                    }
                }
            }
            
            // 如果还没到最大长度，继续扩展
            if (len < n) {
                int[][] newDp = new int[1 << 9][10];
                
                for (int mask = 0; mask < (1 << 9); mask++) {
                    for (int last = 1; last <= 9; last++) {
                        if (dp[mask][last] > 0) {
                            // 尝试从last移动到下一个点
                            for (int next = 1; next <= 9; next++) {
                                // 如果下一个点已访问，跳过
                                if ((mask & (1 << (next - 1))) != 0) {
                                    continue;
                                }
                                
                                // 检查是否可以移动到下一个位置
                                int skipPoint = skip[last][next];
                                // 如果不需要跳跃，或者跳跃点已被访问，可以移动
                                if (skipPoint == 0 || (mask & (1 << (skipPoint - 1))) != 0) {
                                    newDp[mask | (1 << (next - 1))][next] += dp[mask][last];
                                }
                            }
                        }
                    }
                }
                
                dp = newDp;
            }
        }
        
        return result;
    }
    
    /**
     * 测试函数
     */
    public static void main(String[] args) {
        System.out.println("=== 测试 LeetCode 351. 安卓系统手势解锁 ===");
        
        // 测试用例1
        int m1 = 1, n1 = 1;
        System.out.println("测试用例1:");
        System.out.println("m: " + m1 + ", n: " + n1);
        System.out.println("回溯法结果: " + numberOfPatternsBacktrack(m1, n1));
        System.out.println("记忆化回溯法结果: " + numberOfPatternsMemoization(m1, n1));
        System.out.println("动态规划法结果: " + numberOfPatternsDP(m1, n1));
        System.out.println("期望结果: 9");
        System.out.println();
        
        // 测试用例2
        int m2 = 1, n2 = 2;
        System.out.println("测试用例2:");
        System.out.println("m: " + m2 + ", n: " + n2);
        System.out.println("回溯法结果: " + numberOfPatternsBacktrack(m2, n2));
        System.out.println("记忆化回溯法结果: " + numberOfPatternsMemoization(m2, n2));
        System.out.println("动态规划法结果: " + numberOfPatternsDP(m2, n2));
        System.out.println("期望结果: 65");
        System.out.println();
        
        // 测试用例3
        int m3 = 2, n3 = 3;
        System.out.println("测试用例3:");
        System.out.println("m: " + m3 + ", n: " + n3);
        System.out.println("回溯法结果: " + numberOfPatternsBacktrack(m3, n3));
        System.out.println("记忆化回溯法结果: " + numberOfPatternsMemoization(m3, n3));
        System.out.println("动态规划法结果: " + numberOfPatternsDP(m3, n3));
        System.out.println();
        
        // 性能测试
        System.out.println("=== 性能测试 ===");
        int m = 3, n = 7;
        
        long startTime = System.nanoTime();
        int result1 = numberOfPatternsBacktrack(m, n);
        long endTime = System.nanoTime();
        System.out.println("回溯法计算m=" + m + ",n=" + n + "时间: " + (endTime - startTime) / 1_000_000.0 + " ms, 结果: " + result1);
        
        startTime = System.nanoTime();
        int result2 = numberOfPatternsMemoization(m, n);
        endTime = System.nanoTime();
        System.out.println("记忆化回溯法计算m=" + m + ",n=" + n + "时间: " + (endTime - startTime) / 1_000_000.0 + " ms, 结果: " + result2);
        
        startTime = System.nanoTime();
        int result3 = numberOfPatternsDP(m, n);
        endTime = System.nanoTime();
        System.out.println("动态规划法计算m=" + m + ",n=" + n + "时间: " + (endTime - startTime) / 1_000_000.0 + " ms, 结果: " + result3);
    }
}

===============================================

文件: leetcode_351_android_unlock_patterns.cpp
===============================================
#include <iostream>
#include <vector>
#include <algorithm>
#include <chrono>
#include <random>

using namespace std;

/**
 * LeetCode 351. 安卓系统手势解锁 (Android Unlock Patterns) - C++版本
 * 
 * 题目来源：https://leetcode.cn/problems/android-unlock-patterns/
 * 
 * 题目描述：
 * 我们都知道安卓有个手势解锁的界面，是一个 3 x 3 的点所绘制出来的网格。
 * 用户可以设置一个 "解锁模式"，通过连接特定序列中的点，形成一个解锁手势。
 * 一个有效的解锁模式需要满足以下两个条件：
 * 1. 所有点是不同的
 * 2. 如果两个点之间有其他点，则必须先经过这些点
 * 
 * 算法思路：
 * 这是一个回溯算法问题，可以使用以下方法解决：
 * 1. 回溯法：枚举所有可能的路径
 * 2. 动态规划：记忆化搜索优化
 * 3. 状态压缩：使用位运算优化空间
 * 
 * 虽然这不是经典的生命游戏问题，但可以看作是在一个网格上模拟状态变化的问题，
 * 与生命游戏有相似的网格状态处理思想。
 * 
 * 时间复杂度：
 * - 回溯法：O(9!)
 * - 空间复杂度：O(9)
 * 
 * 应用场景：
 * 1. 密码学：模式识别和安全验证
 * 2. 游戏开发：路径搜索和状态机
 * 3. 图论：哈密顿路径问题
 * 
 * 相关题目：
 * 1. LeetCode 289. 生命游戏
 * 2. LeetCode 79. 单词搜索
 * 3. LeetCode 212. 单词搜索 II
 */

// 记录两个点之间必须经过的中间点
int skip[10][10];

// 静态初始化块，设置跳跃规则
struct InitSkip {
    InitSkip() {
        // 初始化跳跃规则
        for (int i = 0; i < 10; i++) {
            for (int j = 0; j < 10; j++) {
                skip[i][j] = 0;
            }
        }
        
        skip[1][3] = skip[3][1] = 2;
        skip[1][7] = skip[7][1] = 4;
        skip[3][9] = skip[9][3] = 6;
        skip[7][9] = skip[9][7] = 8;
        skip[1][9] = skip[9][1] = skip[3][7] = skip[7][3] = skip[2][8] = skip[8][2] = skip[4][6] = skip[6][4] = 5;
    }
};

// 全局初始化对象
InitSkip initSkip;

// 回溯搜索函数
int dfsBacktrack(int current, vector<bool>& visited, int len, int m, int n) {
    if (len > n) {
        return 0;
    }
    
    int count = 0;
    // 如果当前长度满足要求，计数加1
    if (len >= m) {
        count++;
    }
    
    // 标记当前位置为已访问
    visited[current] = true;
    
    // 尝试移动到下一个位置
    for (int next = 1; next <= 9; next++) {
        // 如果下一个位置已访问，跳过
        if (visited[next]) {
            continue;
        }
        
        // 检查是否可以移动到下一个位置
        int skipPoint = skip[current][next];
        // 如果不需要跳跃，或者跳跃点已被访问，可以移动
        if (skipPoint == 0 || visited[skipPoint]) {
            count += dfsBacktrack(next, visited, len + 1, m, n);
        }
    }
    
    // 回溯：取消标记当前位置
    visited[current] = false;
    
    return count;
}

/**
 * 方法1：回溯法
 * 时间复杂度：O(9!)
 * 空间复杂度：O(9)
 * @param m 最小步数
 * @param n 最大步数
 * @return 满足条件的解锁模式数量
 */
int numberOfPatternsBacktrack(int m, int n) {
    vector<bool> visited(10, false);
    
    int count = 0;
    // 从1,2,5开始搜索（利用对称性优化）
    // 1,3,7,9是对称的，2,4,6,8是对称的
    count += dfsBacktrack(1, visited, 1, m, n) * 4;  // 1,3,7,9
    count += dfsBacktrack(2, visited, 1, m, n) * 4;  // 2,4,6,8
    count += dfsBacktrack(5, visited, 1, m, n);      // 5
    
    return count;
}

// 带记忆化的回溯搜索函数
int dfsMemoization(int current, int visitedMask, int len, int m, int n, vector<vector<int>>& memo) {
    if (len > n) {
        return 0;
    }
    
    // 如果已经计算过，直接返回结果
    if (memo[visitedMask][current] != -1) {
        return memo[visitedMask][current];
    }
    
    int count = 0;
    // 如果当前长度满足要求，计数加1
    if (len >= m) {
        count++;
    }
    
    // 尝试移动到下一个位置
    for (int next = 1; next <= 9; next++) {
        // 如果下一个位置已访问，跳过
        if ((visitedMask & (1 << (next - 1))) != 0) {
            continue;
        }
        
        // 检查是否可以移动到下一个位置
        int skipPoint = skip[current][next];
        // 如果不需要跳跃，或者跳跃点已被访问，可以移动
        if (skipPoint == 0 || (visitedMask & (1 << (skipPoint - 1))) != 0) {
            count += dfsMemoization(next, visitedMask | (1 << (next - 1)), len + 1, m, n, memo);
        }
    }
    
    // 记忆化结果
    memo[visitedMask][current] = count;
    return count;
}

/**
 * 方法2：带记忆化的回溯法
 * 时间复杂度：O(9 * 2^9)
 * 空间复杂度：O(2^9)
 * @param m 最小步数
 * @param n 最大步数
 * @return 满足条件的解锁模式数量
 */
int numberOfPatternsMemoization(int m, int n) {
    // 使用位掩码表示已访问的点
    vector<vector<int>> memo(1 << 9, vector<int>(10, -1));
    
    int count = 0;
    // 从1,2,5开始搜索（利用对称性优化）
    count += dfsMemoization(1, 1 << (1-1), 1, m, n, memo) * 4;  // 1,3,7,9
    count += dfsMemoization(2, 1 << (2-1), 1, m, n, memo) * 4;  // 2,4,6,8
    count += dfsMemoization(5, 1 << (5-1), 1, m, n, memo);      // 5
    
    return count;
}

/**
 * 方法3：动态规划解法
 * 时间复杂度：O(n * 9 * 2^9)
 * 空间复杂度：O(9 * 2^9)
 * @param m 最小步数
 * @param n 最大步数
 * @return 满足条件的解锁模式数量
 */
int numberOfPatternsDP(int m, int n) {
    // dp[mask][last] 表示使用mask表示的点集，以last结尾的路径数量
    vector<vector<int>> dp(1 << 9, vector<int>(10, 0));
    
    // 初始化：每个点作为起点的路径数量为1
    for (int i = 1; i <= 9; i++) {
        dp[1 << (i - 1)][i] = 1;
    }
    
    int result = 0;
    
    // 按照路径长度进行动态规划
    for (int len = 1; len <= n; len++) {
        // 计算长度为len的路径数量
        if (len >= m) {
            for (int mask = 0; mask < (1 << 9); mask++) {
                for (int last = 1; last <= 9; last++) {
                    if ((mask & (1 << (last - 1))) != 0) {
                        result += dp[mask][last];
                    }
                }
            }
        }
        
        // 如果还没到最大长度，继续扩展
        if (len < n) {
            vector<vector<int>> newDp(1 << 9, vector<int>(10, 0));
            
            for (int mask = 0; mask < (1 << 9); mask++) {
                for (int last = 1; last <= 9; last++) {
                    if (dp[mask][last] > 0) {
                        // 尝试从last移动到下一个点
                        for (int next = 1; next <= 9; next++) {
                            // 如果下一个点已访问，跳过
                            if ((mask & (1 << (next - 1))) != 0) {
                                continue;
                            }
                            
                            // 检查是否可以移动到下一个位置
                            int skipPoint = skip[last][next];
                            // 如果不需要跳跃，或者跳跃点已被访问，可以移动
                            if (skipPoint == 0 || (mask & (1 << (skipPoint - 1))) != 0) {
                                newDp[mask | (1 << (next - 1))][next] += dp[mask][last];
                            }
                        }
                    }
                }
            }
            
            dp = newDp;
        }
    }
    
    return result;
}

/**
 * 测试函数
 */
void testAndroidUnlockPatterns() {
    cout << "=== 测试 LeetCode 351. 安卓系统手势解锁 ===" << endl;
    
    // 测试用例1
    int m1 = 1, n1 = 1;
    cout << "测试用例1:" << endl;
    cout << "m: " << m1 << ", n: " << n1 << endl;
    cout << "回溯法结果: " << numberOfPatternsBacktrack(m1, n1) << endl;
    cout << "记忆化回溯法结果: " << numberOfPatternsMemoization(m1, n1) << endl;
    cout << "动态规划法结果: " << numberOfPatternsDP(m1, n1) << endl;
    cout << "期望结果: 9" << endl;
    cout << endl;
    
    // 测试用例2
    int m2 = 1, n2 = 2;
    cout << "测试用例2:" << endl;
    cout << "m: " << m2 << ", n: " << n2 << endl;
    cout << "回溯法结果: " << numberOfPatternsBacktrack(m2, n2) << endl;
    cout << "记忆化回溯法结果: " << numberOfPatternsMemoization(m2, n2) << endl;
    cout << "动态规划法结果: " << numberOfPatternsDP(m2, n2) << endl;
    cout << "期望结果: 65" << endl;
    cout << endl;
    
    // 测试用例3
    int m3 = 2, n3 = 3;
    cout << "测试用例3:" << endl;
    cout << "m: " << m3 << ", n: " << n3 << endl;
    cout << "回溯法结果: " << numberOfPatternsBacktrack(m3, n3) << endl;
    cout << "记忆化回溯法结果: " << numberOfPatternsMemoization(m3, n3) << endl;
    cout << "动态规划法结果: " << numberOfPatternsDP(m3, n3) << endl;
    cout << endl;
    
    // 性能测试
    cout << "=== 性能测试 ===" << endl;
    int m = 3, n = 7;
    
    auto start_time = chrono::high_resolution_clock::now();
    int result1 = numberOfPatternsBacktrack(m, n);
    auto end_time = chrono::high_resolution_clock::now();
    auto duration = chrono::duration_cast<chrono::microseconds>(end_time - start_time);
    cout << "回溯法计算m=" << m << ",n=" << n << "时间: " << duration.count() / 1000.0 << " ms, 结果: " << result1 << endl;
    
    start_time = chrono::high_resolution_clock::now();
    int result2 = numberOfPatternsMemoization(m, n);
    end_time = chrono::high_resolution_clock::now();
    duration = chrono::duration_cast<chrono::microseconds>(end_time - start_time);
    cout << "记忆化回溯法计算m=" << m << ",n=" << n << "时间: " << duration.count() / 1000.0 << " ms, 结果: " << result2 << endl;
    
    start_time = chrono::high_resolution_clock::now();
    int result3 = numberOfPatternsDP(m, n);
    end_time = chrono::high_resolution_clock::now();
    duration = chrono::duration_cast<chrono::microseconds>(end_time - start_time);
    cout << "动态规划法计算m=" << m << ",n=" << n << "时间: " << duration.count() / 1000.0 << " ms, 结果: " << result3 << endl;
}

int main() {
    testAndroidUnlockPatterns();
    return 0;
}

===============================================

文件: leetcode_351_android_unlock_patterns.py
===============================================
#!/usr/bin/env python3
"""
LeetCode 351. 安卓系统手势解锁 (Android Unlock Patterns) - Python版本

题目来源：https://leetcode.cn/problems/android-unlock-patterns/

题目描述：
我们都知道安卓有个手势解锁的界面，是一个 3 x 3 的点所绘制出来的网格。
用户可以设置一个 "解锁模式"，通过连接特定序列中的点，形成一个解锁手势。
一个有效的解锁模式需要满足以下两个条件：
1. 所有点是不同的
2. 如果两个点之间有其他点，则必须先经过这些点

算法思路：
这是一个回溯算法问题，可以使用以下方法解决：
1. 回溯法：枚举所有可能的路径
2. 动态规划：记忆化搜索优化
3. 状态压缩：使用位运算优化空间

虽然这不是经典的生命游戏问题，但可以看作是在一个网格上模拟状态变化的问题，
与生命游戏有相似的网格状态处理思想。

时间复杂度：
- 回溯法：O(9!)
- 空间复杂度：O(9)

应用场景：
1. 密码学：模式识别和安全验证
2. 游戏开发：路径搜索和状态机
3. 图论：哈密顿路径问题

相关题目：
1. LeetCode 289. 生命游戏
2. LeetCode 79. 单词搜索
3. LeetCode 212. 单词搜索 II
"""

import time

# 记录两个点之间必须经过的中间点
skip = [[0 for _ in range(10)] for _ in range(10)]

# 初始化跳跃规则
skip[1][3] = skip[3][1] = 2
skip[1][7] = skip[7][1] = 4
skip[3][9] = skip[9][3] = 6
skip[7][9] = skip[9][7] = 8
skip[1][9] = skip[9][1] = skip[3][7] = skip[7][3] = skip[2][8] = skip[8][2] = skip[4][6] = skip[6][4] = 5

def number_of_patterns_backtrack(m, n):
    """
    方法1：回溯法
    时间复杂度：O(9!)
    空间复杂度：O(9)
    :param m: 最小步数
    :param n: 最大步数
    :return: 满足条件的解锁模式数量
    """
    visited = [False] * 10
    
    def dfs_backtrack(current, visited, length, m, n):
        """
        回溯搜索函数
        :param current: 当前位置
        :param visited: 已访问位置数组
        :param length: 当前路径长度
        :param m: 最小步数
        :param n: 最大步数
        :return: 从当前位置开始的有效路径数量
        """
        if length > n:
            return 0
        
        count = 0
        # 如果当前长度满足要求，计数加1
        if length >= m:
            count += 1
        
        # 标记当前位置为已访问
        visited[current] = True
        
        # 尝试移动到下一个位置
        for next_pos in range(1, 10):
            # 如果下一个位置已访问，跳过
            if visited[next_pos]:
                continue
            
            # 检查是否可以移动到下一个位置
            skip_point = skip[current][next_pos]
            # 如果不需要跳跃，或者跳跃点已被访问，可以移动
            if skip_point == 0 or visited[skip_point]:
                count += dfs_backtrack(next_pos, visited, length + 1, m, n)
        
        # 回溯：取消标记当前位置
        visited[current] = False
        
        return count
    
    count = 0
    # 从1,2,5开始搜索（利用对称性优化）
    # 1,3,7,9是对称的，2,4,6,8是对称的
    count += dfs_backtrack(1, visited, 1, m, n) * 4  # 1,3,7,9
    count += dfs_backtrack(2, visited, 1, m, n) * 4  # 2,4,6,8
    count += dfs_backtrack(5, visited, 1, m, n)      # 5
    
    return count

def number_of_patterns_memoization(m, n):
    """
    方法2：带记忆化的回溯法
    时间复杂度：O(9 * 2^9)
    空间复杂度：O(2^9)
    :param m: 最小步数
    :param n: 最大步数
    :return: 满足条件的解锁模式数量
    """
    # 使用位掩码表示已访问的点
    memo = [[-1 for _ in range(10)] for _ in range(1 << 9)]
    
    def dfs_memoization(current, visited_mask, length, m, n, memo):
        """
        带记忆化的回溯搜索函数
        :param current: 当前位置
        :param visited_mask: 已访问位置的位掩码
        :param length: 当前路径长度
        :param m: 最小步数
        :param n: 最大步数
        :param memo: 记忆化数组
        :return: 从当前位置开始的有效路径数量
        """
        if length > n:
            return 0
        
        # 如果已经计算过，直接返回结果
        if memo[visited_mask][current] != -1:
            return memo[visited_mask][current]
        
        count = 0
        # 如果当前长度满足要求，计数加1
        if length >= m:
            count += 1
        
        # 尝试移动到下一个位置
        for next_pos in range(1, 10):
            # 如果下一个位置已访问，跳过
            if (visited_mask & (1 << (next_pos - 1))) != 0:
                continue
            
            # 检查是否可以移动到下一个位置
            skip_point = skip[current][next_pos]
            # 如果不需要跳跃，或者跳跃点已被访问，可以移动
            if skip_point == 0 or (visited_mask & (1 << (skip_point - 1))) != 0:
                count += dfs_memoization(next_pos, visited_mask | (1 << (next_pos - 1)), length + 1, m, n, memo)
        
        # 记忆化结果
        memo[visited_mask][current] = count
        return count
    
    count = 0
    # 从1,2,5开始搜索（利用对称性优化）
    count += dfs_memoization(1, 1 << (1-1), 1, m, n, memo) * 4  # 1,3,7,9
    count += dfs_memoization(2, 1 << (2-1), 1, m, n, memo) * 4  # 2,4,6,8
    count += dfs_memoization(5, 1 << (5-1), 1, m, n, memo)      # 5
    
    return count

def number_of_patterns_dp(m, n):
    """
    方法3：动态规划解法
    时间复杂度：O(n * 9 * 2^9)
    空间复杂度：O(9 * 2^9)
    :param m: 最小步数
    :param n: 最大步数
    :return: 满足条件的解锁模式数量
    """
    # dp[mask][last] 表示使用mask表示的点集，以last结尾的路径数量
    dp = [[0 for _ in range(10)] for _ in range(1 << 9)]
    
    # 初始化：每个点作为起点的路径数量为1
    for i in range(1, 10):
        dp[1 << (i - 1)][i] = 1
    
    result = 0
    
    # 按照路径长度进行动态规划
    for length in range(1, n + 1):
        # 计算长度为length的路径数量
        if length >= m:
            for mask in range(1 << 9):
                for last in range(1, 10):
                    if (mask & (1 << (last - 1))) != 0:
                        result += dp[mask][last]
        
        # 如果还没到最大长度，继续扩展
        if length < n:
            new_dp = [[0 for _ in range(10)] for _ in range(1 << 9)]
            
            for mask in range(1 << 9):
                for last in range(1, 10):
                    if dp[mask][last] > 0:
                        # 尝试从last移动到下一个点
                        for next_pos in range(1, 10):
                            # 如果下一个点已访问，跳过
                            if (mask & (1 << (next_pos - 1))) != 0:
                                continue
                            
                            # 检查是否可以移动到下一个位置
                            skip_point = skip[last][next_pos]
                            # 如果不需要跳跃，或者跳跃点已被访问，可以移动
                            if skip_point == 0 or (mask & (1 << (skip_point - 1))) != 0:
                                new_dp[mask | (1 << (next_pos - 1))][next_pos] += dp[mask][last]
            
            dp = new_dp
    
    return result

def test_android_unlock_patterns():
    """测试函数"""
    print("=== 测试 LeetCode 351. 安卓系统手势解锁 ===")
    
    # 测试用例1
    m1, n1 = 1, 1
    print("测试用例1:")
    print("m:", m1, ", n:", n1)
    print("回溯法结果:", number_of_patterns_backtrack(m1, n1))
    print("记忆化回溯法结果:", number_of_patterns_memoization(m1, n1))
    print("动态规划法结果:", number_of_patterns_dp(m1, n1))
    print("期望结果: 9")
    print()
    
    # 测试用例2
    m2, n2 = 1, 2
    print("测试用例2:")
    print("m:", m2, ", n:", n2)
    print("回溯法结果:", number_of_patterns_backtrack(m2, n2))
    print("记忆化回溯法结果:", number_of_patterns_memoization(m2, n2))
    print("动态规划法结果:", number_of_patterns_dp(m2, n2))
    print("期望结果: 65")
    print()
    
    # 测试用例3
    m3, n3 = 2, 3
    print("测试用例3:")
    print("m:", m3, ", n:", n3)
    print("回溯法结果:", number_of_patterns_backtrack(m3, n3))
    print("记忆化回溯法结果:", number_of_patterns_memoization(m3, n3))
    print("动态规划法结果:", number_of_patterns_dp(m3, n3))
    print()
    
    # 性能测试
    print("=== 性能测试 ===")
    m, n = 3, 7
    
    start_time = time.time()
    result1 = number_of_patterns_backtrack(m, n)
    end_time = time.time()
    print("回溯法计算m={},n={}时间: {:.2f} ms, 结果: {}".format(
        m, n, (end_time - start_time) * 1000, result1))
    
    start_time = time.time()
    result2 = number_of_patterns_memoization(m, n)
    end_time = time.time()
    print("记忆化回溯法计算m={},n={}时间: {:.2f} ms, 结果: {}".format(
        m, n, (end_time - start_time) * 1000, result2))
    
    start_time = time.time()
    result3 = number_of_patterns_dp(m, n)
    end_time = time.time()
    print("动态规划法计算m={},n={}时间: {:.2f} ms, 结果: {}".format(
        m, n, (end_time - start_time) * 1000, result3))

if __name__ == "__main__":
    test_android_unlock_patterns()

===============================================

文件: LeetCode_370_RangeAddition.cpp
===============================================
#include <iostream>
#include <vector>
#include <algorithm>
#include <chrono>

using namespace std;

/**
 * LeetCode 370. 区间加法
 * 
 * 问题描述：
 * 假设你有一个长度为 n 的数组，初始情况下所有的数字均为 0，
 * 你将会被给出 k 个更新操作。其中，每个操作会被表示为一个三元组：
 * [startIndex, endIndex, inc]，你需要将子数组 A[startIndex ... endIndex]
 * （包括 startIndex 和 endIndex）增加 inc。
 * 请你返回 k 次操作后的数组。
 * 
 * 算法思路：
 * 使用差分数组来优化区间更新操作。差分数组的核心思想是：
 * 1. 对于区间 [l, r] 增加 val，我们只需要在差分数组的 l 位置加 val，
 *    在 r+1 位置减 val
 * 2. 最后通过计算差分数组的前缀和来得到最终结果
 * 
 * 时间复杂度：
 * - 区间更新：O(1)
 * - 获取结果数组：O(n)
 * - 总时间复杂度：O(k + n)
 * 空间复杂度：O(n)
 * 
 * 应用场景：
 * 1. 数组操作优化：批量更新处理
 * 2. 前缀和计算：快速计算区间和
 * 3. 算法竞赛：区间操作问题的优化
 * 
 * 相关题目：
 * 1. LeetCode 1094. 拼车
 * 2. LeetCode 1109. 航班预订统计
 * 3. LeetCode 1893. 检查是否区域内所有整数都被覆盖
 */

class LeetCode370RangeAddition {
public:
    /**
     * 使用差分数组解决区间加法问题
     * @param length 数组长度
     * @param updates 更新操作数组，每个操作是 [startIndex, endIndex, inc]
     * @return k 次操作后的数组
     */
    vector<int> getModifiedArray(int length, vector<vector<int>>& updates) {
        // 创建差分数组，大小为 length + 1 便于处理边界
        vector<int> diff(length + 1, 0);
        
        // 处理每个更新操作
        for (const auto& update : updates) {
            int start = update[0];
            int end = update[1];
            int inc = update[2];
            
            // 在差分数组中标记区间更新
            diff[start] += inc;
            if (end + 1 < length) {
                diff[end + 1] -= inc;
            }
        }
        
        // 通过计算差分数组的前缀和来得到最终结果
        vector<int> result(length);
        result[0] = diff[0];
        for (int i = 1; i < length; i++) {
            result[i] = result[i - 1] + diff[i];
        }
        
        return result;
    }
    
    /**
     * 暴力解法（用于对比）
     * 时间复杂度：O(k * n)
     * 空间复杂度：O(1)
     */
    vector<int> getModifiedArrayBruteForce(int length, vector<vector<int>>& updates) {
        vector<int> result(length, 0);
        
        // 处理每个更新操作
        for (const auto& update : updates) {
            int start = update[0];
            int end = update[1];
            int inc = update[2];
            
            // 直接更新区间内的每个元素
            for (int i = start; i <= end; i++) {
                result[i] += inc;
            }
        }
        
        return result;
    }
};

/**
 * 测试函数
 */
void testRangeAddition() {
    LeetCode370RangeAddition solution;
    
    cout << "=== 测试 LeetCode 370. 区间加法 ===" << endl;
    
    // 测试用例1
    int length1 = 5;
    vector<vector<int>> updates1 = {{1, 3, 2}, {2, 4, 3}, {0, 2, -2}};
    cout << "测试用例1:" << endl;
    cout << "数组长度: " << length1 << endl;
    cout << "更新操作: ";
    for (const auto& update : updates1) {
        cout << "[" << update[0] << "," << update[1] << "," << update[2] << "] ";
    }
    cout << endl;
    
    auto result1 = solution.getModifiedArray(length1, updates1);
    cout << "差分数组结果: ";
    for (int val : result1) {
        cout << val << " ";
    }
    cout << endl;
    
    auto result1_brute = solution.getModifiedArrayBruteForce(length1, updates1);
    cout << "暴力解法结果: ";
    for (int val : result1_brute) {
        cout << val << " ";
    }
    cout << endl;
    
    // 测试用例2
    int length2 = 10;
    vector<vector<int>> updates2 = {{2, 4, 6}, {0, 6, -2}, {5, 8, 1}};
    cout << "\n测试用例2:" << endl;
    cout << "数组长度: " << length2 << endl;
    cout << "更新操作: ";
    for (const auto& update : updates2) {
        cout << "[" << update[0] << "," << update[1] << "," << update[2] << "] ";
    }
    cout << endl;
    
    auto result2 = solution.getModifiedArray(length2, updates2);
    cout << "差分数组结果: ";
    for (int val : result2) {
        cout << val << " ";
    }
    cout << endl;
    
    auto result2_brute = solution.getModifiedArrayBruteForce(length2, updates2);
    cout << "暴力解法结果: ";
    for (int val : result2_brute) {
        cout << val << " ";
    }
    cout << endl;
    
    // 性能测试
    cout << "\n=== 性能测试 ===" << endl;
    int length3 = 10000;
    int k = 1000;
    vector<vector<int>> updates3(k, vector<int>(3));
    for (int i = 0; i < k; i++) {
        updates3[i][0] = i % length3;
        updates3[i][1] = min(updates3[i][0] + 100, length3 - 1);
        updates3[i][2] = i % 10 - 5;
    }
    
    auto startTime = chrono::high_resolution_clock::now();
    solution.getModifiedArray(length3, updates3);
    auto endTime = chrono::high_resolution_clock::now();
    auto duration = chrono::duration_cast<chrono::microseconds>(endTime - startTime);
    cout << "差分数组法处理长度为" << length3 << "的数组，" << k << "次更新操作时间: " << duration.count() / 1000.0 << " ms" << endl;
    
    startTime = chrono::high_resolution_clock::now();
    solution.getModifiedArrayBruteForce(length3, updates3);
    endTime = chrono::high_resolution_clock::now();
    duration = chrono::duration_cast<chrono::microseconds>(endTime - startTime);
    cout << "暴力解法处理长度为" << length3 << "的数组，" << k << "次更新操作时间: " << duration.count() / 1000.0 << " ms" << endl;
}

int main() {
    testRangeAddition();
    return 0;
}

===============================================

文件: LeetCode_370_RangeAddition.java
===============================================
package class185.difference_array_problems;

import java.util.Arrays;

/**
 * LeetCode 370. 区间加法
 * 
 * 问题描述：
 * 假设你有一个长度为 n 的数组，初始情况下所有的数字均为 0，
 * 你将会被给出 k 个更新操作。其中，每个操作会被表示为一个三元组：
 * [startIndex, endIndex, inc]，你需要将子数组 A[startIndex ... endIndex]
 * （包括 startIndex 和 endIndex）增加 inc。
 * 请你返回 k 次操作后的数组。
 * 
 * 算法思路：
 * 使用差分数组来优化区间更新操作。差分数组的核心思想是：
 * 1. 对于区间 [l, r] 增加 val，我们只需要在差分数组的 l 位置加 val，
 *    在 r+1 位置减 val
 * 2. 最后通过计算差分数组的前缀和来得到最终结果
 * 
 * 时间复杂度：
 * - 区间更新：O(1)
 * - 获取结果数组：O(n)
 * - 总时间复杂度：O(k + n)
 * 空间复杂度：O(n)
 * 
 * 应用场景：
 * 1. 数组操作优化：批量更新处理
 * 2. 前缀和计算：快速计算区间和
 * 3. 算法竞赛：区间操作问题的优化
 * 
 * 相关题目：
 * 1. LeetCode 1094. 拼车
 * 2. LeetCode 1109. 航班预订统计
 * 3. LeetCode 1893. 检查是否区域内所有整数都被覆盖
 */
public class LeetCode_370_RangeAddition {
    
    /**
     * 使用差分数组解决区间加法问题
     * @param length 数组长度
     * @param updates 更新操作数组，每个操作是 [startIndex, endIndex, inc]
     * @return k 次操作后的数组
     */
    public int[] getModifiedArray(int length, int[][] updates) {
        // 创建差分数组，大小为 length + 1 便于处理边界
        int[] diff = new int[length + 1];
        
        // 处理每个更新操作
        for (int[] update : updates) {
            int start = update[0];
            int end = update[1];
            int inc = update[2];
            
            // 在差分数组中标记区间更新
            diff[start] += inc;
            if (end + 1 < length) {
                diff[end + 1] -= inc;
            }
        }
        
        // 通过计算差分数组的前缀和来得到最终结果
        int[] result = new int[length];
        result[0] = diff[0];
        for (int i = 1; i < length; i++) {
            result[i] = result[i - 1] + diff[i];
        }
        
        return result;
    }
    
    /**
     * 暴力解法（用于对比）
     * 时间复杂度：O(k * n)
     * 空间复杂度：O(1)
     */
    public int[] getModifiedArrayBruteForce(int length, int[][] updates) {
        int[] result = new int[length];
        
        // 处理每个更新操作
        for (int[] update : updates) {
            int start = update[0];
            int end = update[1];
            int inc = update[2];
            
            // 直接更新区间内的每个元素
            for (int i = start; i <= end; i++) {
                result[i] += inc;
            }
        }
        
        return result;
    }
    
    /**
     * 测试函数
     */
    public static void main(String[] args) {
        LeetCode_370_RangeAddition solution = new LeetCode_370_RangeAddition();
        
        System.out.println("=== 测试 LeetCode 370. 区间加法 ===");
        
        // 测试用例1
        int length1 = 5;
        int[][] updates1 = {{1, 3, 2}, {2, 4, 3}, {0, 2, -2}};
        System.out.println("测试用例1:");
        System.out.println("数组长度: " + length1);
        System.out.println("更新操作: " + Arrays.deepToString(updates1));
        System.out.println("差分数组结果: " + Arrays.toString(solution.getModifiedArray(length1, updates1)));
        System.out.println("暴力解法结果: " + Arrays.toString(solution.getModifiedArrayBruteForce(length1, updates1)));
        
        // 测试用例2
        int length2 = 10;
        int[][] updates2 = {{2, 4, 6}, {0, 6, -2}, {5, 8, 1}};
        System.out.println("\n测试用例2:");
        System.out.println("数组长度: " + length2);
        System.out.println("更新操作: " + Arrays.deepToString(updates2));
        System.out.println("差分数组结果: " + Arrays.toString(solution.getModifiedArray(length2, updates2)));
        System.out.println("暴力解法结果: " + Arrays.toString(solution.getModifiedArrayBruteForce(length2, updates2)));
        
        // 性能测试
        System.out.println("\n=== 性能测试 ===");
        int length3 = 10000;
        int k = 1000;
        int[][] updates3 = new int[k][3];
        for (int i = 0; i < k; i++) {
            updates3[i][0] = i % length3;
            updates3[i][1] = Math.min(updates3[i][0] + 100, length3 - 1);
            updates3[i][2] = i % 10 - 5;
        }
        
        long startTime = System.nanoTime();
        solution.getModifiedArray(length3, updates3);
        long endTime = System.nanoTime();
        System.out.println("差分数组法处理长度为" + length3 + "的数组，" + k + "次更新操作时间: " + (endTime - startTime) / 1_000_000.0 + " ms");
        
        startTime = System.nanoTime();
        solution.getModifiedArrayBruteForce(length3, updates3);
        endTime = System.nanoTime();
        System.out.println("暴力解法处理长度为" + length3 + "的数组，" + k + "次更新操作时间: " + (endTime - startTime) / 1_000_000.0 + " ms");
    }
}

===============================================

文件: leetcode_370_range_addition.py
===============================================
#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
LeetCode 370. 区间加法

问题描述：
假设你有一个长度为 n 的数组，初始情况下所有的数字均为 0，
你将会被给出 k 个更新操作。其中，每个操作会被表示为一个三元组：
[startIndex, endIndex, inc]，你需要将子数组 A[startIndex ... endIndex]
（包括 startIndex 和 endIndex）增加 inc。
请你返回 k 次操作后的数组。

算法思路：
使用差分数组来优化区间更新操作。差分数组的核心思想是：
1. 对于区间 [l, r] 增加 val，我们只需要在差分数组的 l 位置加 val，
   在 r+1 位置减 val
2. 最后通过计算差分数组的前缀和来得到最终结果

时间复杂度：
- 区间更新：O(1)
- 获取结果数组：O(n)
- 总时间复杂度：O(k + n)
空间复杂度：O(n)

应用场景：
1. 数组操作优化：批量更新处理
2. 前缀和计算：快速计算区间和
3. 算法竞赛：区间操作问题的优化

相关题目：
1. LeetCode 1094. 拼车
2. LeetCode 1109. 航班预订统计
3. LeetCode 1893. 检查是否区域内所有整数都被覆盖
"""

import time

class LeetCode370RangeAddition:
    """LeetCode 370. 区间加法解法实现"""
    
    def get_modified_array(self, length, updates):
        """
        使用差分数组解决区间加法问题
        时间复杂度：O(k + n)
        空间复杂度：O(n)
        :param length: 数组长度
        :param updates: 更新操作数组，每个操作是 [startIndex, endIndex, inc]
        :return: k 次操作后的数组
        """
        # 创建差分数组，大小为 length + 1 便于处理边界
        diff = [0] * (length + 1)
        
        # 处理每个更新操作
        for update in updates:
            start, end, inc = update[0], update[1], update[2]
            
            # 在差分数组中标记区间更新
            diff[start] += inc
            if end + 1 < length:
                diff[end + 1] -= inc
        
        # 通过计算差分数组的前缀和来得到最终结果
        result = [0] * length
        result[0] = diff[0]
        for i in range(1, length):
            result[i] = result[i - 1] + diff[i]
        
        return result
    
    def get_modified_array_brute_force(self, length, updates):
        """
        暴力解法（用于对比）
        时间复杂度：O(k * n)
        空间复杂度：O(1)
        """
        result = [0] * length
        
        # 处理每个更新操作
        for update in updates:
            start, end, inc = update[0], update[1], update[2]
            
            # 直接更新区间内的每个元素
            for i in range(start, end + 1):
                result[i] += inc
        
        return result
    
    @staticmethod
    def test_range_addition():
        """测试函数"""
        solution = LeetCode370RangeAddition()
        
        print("=== 测试 LeetCode 370. 区间加法 ===")
        
        # 测试用例1
        length1 = 5
        updates1 = [[1, 3, 2], [2, 4, 3], [0, 2, -2]]
        print("测试用例1:")
        print("数组长度:", length1)
        print("更新操作:", updates1)
        print("差分数组结果:", solution.get_modified_array(length1, updates1))
        print("暴力解法结果:", solution.get_modified_array_brute_force(length1, updates1))
        
        # 测试用例2
        length2 = 10
        updates2 = [[2, 4, 6], [0, 6, -2], [5, 8, 1]]
        print("\n测试用例2:")
        print("数组长度:", length2)
        print("更新操作:", updates2)
        print("差分数组结果:", solution.get_modified_array(length2, updates2))
        print("暴力解法结果:", solution.get_modified_array_brute_force(length2, updates2))
        
        # 性能测试
        print("\n=== 性能测试 ===")
        length3 = 10000
        k = 1000
        updates3 = []
        for i in range(k):
            start = i % length3
            end = min(start + 100, length3 - 1)
            inc = i % 10 - 5
            updates3.append([start, end, inc])
        
        start_time = time.time()
        solution.get_modified_array(length3, updates3)
        end_time = time.time()
        print(f"差分数组法处理长度为{length3}的数组，{k}次更新操作时间: {(end_time - start_time) * 1000:.2f} ms")
        
        start_time = time.time()
        solution.get_modified_array_brute_force(length3, updates3)
        end_time = time.time()
        print(f"暴力解法处理长度为{length3}的数组，{k}次更新操作时间: {(end_time - start_time) * 1000:.2f} ms")

if __name__ == "__main__":
    LeetCode370RangeAddition.test_range_addition()

===============================================

文件: LeetCode_391_PerfectRectangle.java
===============================================
package class008_AdvancedAlgorithmsAndDataStructures.sweep_line_problems;

import java.util.*;

/**
 * LeetCode 391. Perfect Rectangle
 * 
 * 题目描述：
 * 给定 N 个与坐标轴对齐的矩形，其中每个矩形由 [xi, yi, ai, bi] 表示，
 * 其中 (xi, yi) 是该矩形左下角的坐标，(ai, bi) 是该矩形右上角的坐标。
 * 判断所有矩形是否能精确覆盖某个矩形区域。
 * 
 * 解题思路：
 * 使用扫描线算法的思想，我们需要验证两个条件：
 * 1. 所有矩形的总面积等于最外层矩形的面积
 * 2. 除了最外层矩形的四个顶点外，其他所有顶点都出现了偶数次（被相互抵消）
 * 
 * 时间复杂度：O(n log n)
 * 空间复杂度：O(n)
 */
public class LeetCode_391_PerfectRectangle {
    
    static class Solution {
        public boolean isRectangleCover(int[][] rectangles) {
            if (rectangles == null || rectangles.length == 0) {
                return false;
            }
            
            // 记录所有顶点出现的次数
            Set<String> points = new HashSet<>();
            
            // 计算总面积
            int totalArea = 0;
            
            // 记录最外层矩形的边界
            int minX = Integer.MAX_VALUE, minY = Integer.MAX_VALUE;
            int maxX = Integer.MIN_VALUE, maxY = Integer.MIN_VALUE;
            
            // 遍历所有矩形
            for (int[] rect : rectangles) {
                int x1 = rect[0], y1 = rect[1], x2 = rect[2], y2 = rect[3];
                
                // 更新边界
                minX = Math.min(minX, x1);
                minY = Math.min(minY, y1);
                maxX = Math.max(maxX, x2);
                maxY = Math.max(maxY, y2);
                
                // 累加面积
                totalArea += (x2 - x1) * (y2 - y1);
                
                // 记录四个顶点
                String[] corners = {
                    x1 + "," + y1,  // 左下
                    x1 + "," + y2,  // 左上
                    x2 + "," + y1,  // 右下
                    x2 + "," + y2   // 右上
                };
                
                // 如果顶点已存在则删除，否则添加
                for (String corner : corners) {
                    if (points.contains(corner)) {
                        points.remove(corner);
                    } else {
                        points.add(corner);
                    }
                }
            }
            
            // 验证条件1：总面积是否等于最外层矩形面积
            int expectedArea = (maxX - minX) * (maxY - minY);
            if (totalArea != expectedArea) {
                return false;
            }
            
            // 验证条件2：只有四个顶点
            if (points.size() != 4) {
                return false;
            }
            
            // 验证这四个顶点是否就是最外层矩形的四个顶点
            Set<String> expectedCorners = new HashSet<>();
            expectedCorners.add(minX + "," + minY);
            expectedCorners.add(minX + "," + maxY);
            expectedCorners.add(maxX + "," + minY);
            expectedCorners.add(maxX + "," + maxY);
            
            return points.equals(expectedCorners);
        }
    }
    
    // 测试方法
    public static void main(String[] args) {
        Solution solution = new Solution();
        
        // 测试用例1：完美矩形
        int[][] rectangles1 = {{1,1,3,3},{3,1,4,2},{3,2,4,4},{1,3,2,4},{2,3,3,4}};
        System.out.println("测试用例1:");
        System.out.println("矩形: " + Arrays.deepToString(rectangles1));
        System.out.println("是否为完美矩形: " + solution.isRectangleCover(rectangles1));
        System.out.println();
        
        // 测试用例2：非完美矩形（有重叠）
        int[][] rectangles2 = {{1,1,2,3},{1,3,2,4},{3,1,4,2},{3,2,4,4}};
        System.out.println("测试用例2:");
        System.out.println("矩形: " + Arrays.deepToString(rectangles2));
        System.out.println("是否为完美矩形: " + solution.isRectangleCover(rectangles2));
        System.out.println();
        
        // 测试用例3：非完美矩形（有空隙）
        int[][] rectangles3 = {{1,1,3,3},{3,1,4,2},{4,2,5,4}};
        System.out.println("测试用例3:");
        System.out.println("矩形: " + Arrays.deepToString(rectangles3));
        System.out.println("是否为完美矩形: " + solution.isRectangleCover(rectangles3));
        System.out.println();
        
        // 测试用例4：单个矩形
        int[][] rectangles4 = {{0,0,1,1}};
        System.out.println("测试用例4:");
        System.out.println("矩形: " + Arrays.deepToString(rectangles4));
        System.out.println("是否为完美矩形: " + solution.isRectangleCover(rectangles4));
    }
}

===============================================

文件: leetcode_391_perfect_rectangle.cpp
===============================================
// LeetCode 391 Perfect Rectangle
// C++ 实现

/**
 * LeetCode 391 Perfect Rectangle
 * 
 * 题目描述：
 * 给定 N 个矩形，判断它们是否能精确覆盖某个矩形区域。
 * 
 * 解题思路：
 * 要判断N个矩形是否能精确覆盖某个矩形区域，需要满足以下条件：
 * 1. 所有小矩形的面积之和等于大矩形的面积
 * 2. 大矩形的四个顶点只出现一次，其他顶点都出现偶数次（2次或4次）
 * 
 * 我们可以使用扫描线算法或直接计算顶点出现次数来解决这个问题。
 * 
 * 时间复杂度：O(n)
 * 空间复杂度：O(n)
 */

// 由于编译环境限制，这里提供算法思路和伪代码实现

/*
bool isRectangleCover(int** rectangles, int rectanglesSize, int* rectanglesColSize) {
    if (rectanglesSize == 0) {
        return false;
    }
    
    // 计算总面积和边界
    long long totalArea = 0;
    int minX = rectangles[0][0], minY = rectangles[0][1];
    int maxX = rectangles[0][2], maxY = rectangles[0][3];
    
    // 使用哈希表记录所有顶点的出现次数
    // 在实际实现中需要使用自定义哈希表
    
    for (int i = 0; i < rectanglesSize; i++) {
        int x1 = rectangles[i][0], y1 = rectangles[i][1];
        int x2 = rectangles[i][2], y2 = rectangles[i][3];
        
        // 累加面积
        totalArea += (long long)(x2 - x1) * (y2 - y1);
        
        // 更新边界
        minX = (minX < x1) ? minX : x1;
        minY = (minY < y1) ? minY : y1;
        maxX = (maxX > x2) ? maxX : x2;
        maxY = (maxY > y2) ? maxY : y2;
        
        // 记录四个顶点
        // 在实际实现中需要将顶点存储在哈希表中并计数
    }
    
    // 检查面积是否匹配
    long long expectedArea = (long long)(maxX - minX) * (maxY - minY);
    if (totalArea != expectedArea) {
        return false;
    }
    
    // 检查顶点出现次数
    // 大矩形的四个顶点应该只出现一次
    // 其他顶点应该出现偶数次
    
    return true;
}

// 算法核心思想：
// 1. 计算所有小矩形的总面积
// 2. 确定可能的大矩形边界
// 3. 验证总面积是否等于大矩形面积
// 4. 验证顶点出现次数是否符合要求

// 时间复杂度分析：
// - 遍历所有矩形：O(n)
// - 计算面积和边界：O(n)
// - 验证顶点出现次数：O(n)
// - 总体时间复杂度：O(n)
// - 空间复杂度：O(n)（哈希表存储顶点）
*/

// 算法应用场景：
// 1. 计算几何问题
// 2. 矩形覆盖判断
// 3. 扫描线算法应用

===============================================

文件: leetcode_391_perfect_rectangle.py
===============================================
#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
LeetCode 391 Perfect Rectangle

题目描述：
给定 N 个矩形，判断它们是否能精确覆盖某个矩形区域。

解题思路：
要判断N个矩形是否能精确覆盖某个矩形区域，需要满足以下条件：
1. 所有小矩形的面积之和等于大矩形的面积
2. 大矩形的四个顶点只出现一次，其他顶点都出现偶数次（2次或4次）

我们可以使用扫描线算法或直接计算顶点出现次数来解决这个问题。

时间复杂度：O(n)
空间复杂度：O(n)
"""

class Solution:
    def is_rectangle_cover(self, rectangles):
        """
        判断矩形是否能精确覆盖某个矩形区域
        
        Args:
            rectangles: 矩形列表，每个元素为[x1, y1, x2, y2]
            
        Returns:
            是否能精确覆盖
        """
        if not rectangles:
            return False
        
        # 计算总面积和边界
        total_area = 0
        min_x, min_y = rectangles[0][0], rectangles[0][1]
        max_x, max_y = rectangles[0][2], rectangles[0][3]
        
        # 使用集合记录所有顶点的出现次数
        vertices = set()
        
        for rect in rectangles:
            x1, y1, x2, y2 = rect
            
            # 累加面积
            total_area += (x2 - x1) * (y2 - y1)
            
            # 更新边界
            min_x = min(min_x, x1)
            min_y = min(min_y, y1)
            max_x = max(max_x, x2)
            max_y = max(max_y, y2)
            
            # 记录四个顶点
            corners = [(x1, y1), (x1, y2), (x2, y1), (x2, y2)]
            for corner in corners:
                if corner in vertices:
                    vertices.remove(corner)
                else:
                    vertices.add(corner)
        
        # 检查面积是否匹配
        expected_area = (max_x - min_x) * (max_y - min_y)
        if total_area != expected_area:
            return False
        
        # 检查顶点出现次数
        # 大矩形的四个顶点应该只出现一次
        # 其他顶点应该出现偶数次
        expected_corners = {(min_x, min_y), (min_x, max_y), (max_x, min_y), (max_x, max_y)}
        
        return vertices == expected_corners


# 测试方法
def main():
    solution = Solution()
    
    # 测试用例1：能精确覆盖
    rectangles1 = [[1,1,3,3],[3,1,4,2],[3,2,4,4],[1,3,2,4],[2,3,3,4]]
    print("测试用例1:")
    print("矩形:", rectangles1)
    print("结果:", solution.is_rectangle_cover(rectangles1))
    print()
    
    # 测试用例2：不能精确覆盖（有重叠）
    rectangles2 = [[1,1,2,3],[1,3,2,4],[3,1,4,2],[3,2,4,4]]
    print("测试用例2:")
    print("矩形:", rectangles2)
    print("结果:", solution.is_rectangle_cover(rectangles2))
    print()
    
    # 测试用例3：不能精确覆盖（有空隙）
    rectangles3 = [[1,1,3,3],[3,1,4,2],[1,3,2,4]]
    print("测试用例3:")
    print("矩形:", rectangles3)
    print("结果:", solution.is_rectangle_cover(rectangles3))


if __name__ == "__main__":
    main()

===============================================

文件: LeetCode_435_NonOverlappingIntervals.java
===============================================
package class008_AdvancedAlgorithmsAndDataStructures.sweep_line_problems;

import java.util.*;

/**
 * LeetCode 435. Non-overlapping Intervals
 * 
 * 题目描述：
 * 给定一个区间的集合 intervals ，其中 intervals[i] = [start_i, end_i] 。
 * 返回需要移除区间的最小数量，使剩余区间互不重叠。
 * 
 * 解题思路：
 * 这是一个经典的贪心算法问题，也可以用扫描线算法的思想来解决。
 * 我们按照区间的结束时间进行排序，然后贪心地选择结束时间最早的区间，
 * 这样可以为后续的区间留出更多空间。
 * 
 * 时间复杂度：O(n log n)
 * 空间复杂度：O(1)
 */
public class LeetCode_435_NonOverlappingIntervals {
    
    static class Solution {
        public int eraseOverlapIntervals(int[][] intervals) {
            if (intervals == null || intervals.length == 0) {
                return 0;
            }
            
            // 按照区间结束时间排序
            Arrays.sort(intervals, (a, b) -> Integer.compare(a[1], b[1]));
            
            int count = 0; // 需要移除的区间数量
            int end = intervals[0][1]; // 当前选择区间的结束时间
            
            // 遍历所有区间
            for (int i = 1; i < intervals.length; i++) {
                // 如果当前区间的开始时间小于前一个区间的结束时间，说明有重叠
                if (intervals[i][0] < end) {
                    count++; // 移除当前区间
                } else {
                    // 更新结束时间
                    end = intervals[i][1];
                }
            }
            
            return count;
        }
        
        // 另一种解法：计算最多能保留的区间数量
        public int eraseOverlapIntervals2(int[][] intervals) {
            if (intervals == null || intervals.length == 0) {
                return 0;
            }
            
            // 按照区间结束时间排序
            Arrays.sort(intervals, (a, b) -> Integer.compare(a[1], b[1]));
            
            int count = 1; // 能保留的区间数量，至少能保留第一个区间
            int end = intervals[0][1]; // 当前保留区间的结束时间
            
            // 遍历所有区间
            for (int i = 1; i < intervals.length; i++) {
                // 如果当前区间的开始时间大于等于前一个保留区间的结束时间，说明不重叠
                if (intervals[i][0] >= end) {
                    count++; // 保留当前区间
                    end = intervals[i][1]; // 更新结束时间
                }
            }
            
            return intervals.length - count; // 需要移除的数量 = 总数 - 保留的数量
        }
    }
    
    // 测试方法
    public static void main(String[] args) {
        Solution solution = new Solution();
        
        // 测试用例1
        int[][] intervals1 = {{1,2},{2,3},{3,4},{1,3}};
        System.out.println("测试用例1:");
        System.out.println("区间: " + Arrays.deepToString(intervals1));
        System.out.println("需要移除的最小区间数: " + solution.eraseOverlapIntervals(intervals1));
        System.out.println("另一种解法结果: " + solution.eraseOverlapIntervals2(intervals1));
        System.out.println();
        
        // 测试用例2
        int[][] intervals2 = {{1,2},{1,2},{1,2}};
        System.out.println("测试用例2:");
        System.out.println("区间: " + Arrays.deepToString(intervals2));
        System.out.println("需要移除的最小区间数: " + solution.eraseOverlapIntervals(intervals2));
        System.out.println("另一种解法结果: " + solution.eraseOverlapIntervals2(intervals2));
        System.out.println();
        
        // 测试用例3
        int[][] intervals3 = {{1,2},{2,3}};
        System.out.println("测试用例3:");
        System.out.println("区间: " + Arrays.deepToString(intervals3));
        System.out.println("需要移除的最小区间数: " + solution.eraseOverlapIntervals(intervals3));
        System.out.println("另一种解法结果: " + solution.eraseOverlapIntervals2(intervals3));
        System.out.println();
        
        // 测试用例4
        int[][] intervals4 = {{1,100},{11,22},{1,11},{2,12}};
        System.out.println("测试用例4:");
        System.out.println("区间: " + Arrays.deepToString(intervals4));
        System.out.println("需要移除的最小区间数: " + solution.eraseOverlapIntervals(intervals4));
        System.out.println("另一种解法结果: " + solution.eraseOverlapIntervals2(intervals4));
    }
}

===============================================

文件: leetcode_435_non_overlapping_intervals.cpp
===============================================
// LeetCode 435 Non-overlapping Intervals
// C++ 实现

/**
 * LeetCode 435 Non-overlapping Intervals
 * 
 * 题目描述：
 * 给定一个区间的集合，找到需要移除区间的最小数量，使剩余区间互不重叠。
 * 
 * 解题思路：
 * 这是一个经典的贪心算法问题。我们可以按照区间的结束时间进行排序，
 * 然后贪心地选择结束时间最早的区间，这样可以为后续区间留出更多空间。
 * 
 * 算法步骤：
 * 1. 按照区间的结束时间进行排序
 * 2. 贪心地选择不重叠的区间
 * 3. 统计需要移除的区间数量
 * 
 * 时间复杂度：O(n log n)
 * 空间复杂度：O(1)
 */

// 由于编译环境限制，这里提供算法思路和伪代码实现

/*
int eraseOverlapIntervals(int** intervals, int intervalsSize, int* intervalsColSize) {
    if (intervalsSize <= 1) {
        return 0;
    }
    
    // 按照区间的结束时间进行排序
    // 在实际实现中需要使用自定义比较函数
    
    int count = 0;
    int end = intervals[0][1]; // 当前选择区间的结束时间
    
    // 贪心地选择不重叠的区间
    for (int i = 1; i < intervalsSize; i++) {
        // 如果当前区间的开始时间小于前一个区间的结束时间，则有重叠
        if (intervals[i][0] < end) {
            count++; // 需要移除一个区间
            // 选择结束时间较早的区间，为后续留出更多空间
            end = (end < intervals[i][1]) ? end : intervals[i][1];
        } else {
            // 没有重叠，更新结束时间
            end = intervals[i][1];
        }
    }
    
    return count;
}

// 算法核心思想：
// 1. 按照区间结束时间排序
// 2. 贪心选择不重叠区间
// 3. 统计需要移除的区间数量

// 时间复杂度分析：
// - 排序：O(n log n)
// - 遍历区间：O(n)
// - 总体时间复杂度：O(n log n)
// - 空间复杂度：O(1)
*/

// 算法应用场景：
// 1. 区间调度问题
// 2. 贪心算法应用
// 3. 活动安排问题

===============================================

文件: leetcode_435_non_overlapping_intervals.py
===============================================
#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
LeetCode 435 Non-overlapping Intervals

题目描述：
给定一个区间的集合，找到需要移除区间的最小数量，使剩余区间互不重叠。

解题思路：
这是一个经典的贪心算法问题。我们可以按照区间的结束时间进行排序，
然后贪心地选择结束时间最早的区间，这样可以为后续区间留出更多空间。

算法步骤：
1. 按照区间的结束时间进行排序
2. 贪心地选择不重叠的区间
3. 统计需要移除的区间数量

时间复杂度：O(n log n)
空间复杂度：O(1)
"""

class Solution:
    def erase_overlap_intervals(self, intervals):
        """
        计算需要移除的最小区间数量
        
        Args:
            intervals: 区间列表，每个元素为[start, end]
            
        Returns:
            需要移除的区间数量
        """
        if len(intervals) <= 1:
            return 0
        
        # 按照区间的结束时间进行排序
        intervals.sort(key=lambda x: x[1])
        
        count = 0
        end = intervals[0][1]  # 当前选择区间的结束时间
        
        # 贪心地选择不重叠的区间
        for i in range(1, len(intervals)):
            # 如果当前区间的开始时间小于前一个区间的结束时间，则有重叠
            if intervals[i][0] < end:
                count += 1  # 需要移除一个区间
                # 选择结束时间较早的区间，为后续留出更多空间
                end = min(end, intervals[i][1])
            else:
                # 没有重叠，更新结束时间
                end = intervals[i][1]
        
        return count


# 测试方法
def main():
    solution = Solution()
    
    # 测试用例1
    intervals1 = [[1,2],[2,3],[3,4],[1,3]]
    print("测试用例1:")
    print("区间:", intervals1)
    print("结果:", solution.erase_overlap_intervals(intervals1))
    print()
    
    # 测试用例2
    intervals2 = [[1,2],[1,2],[1,2]]
    print("测试用例2:")
    print("区间:", intervals2)
    print("结果:", solution.erase_overlap_intervals(intervals2))
    print()
    
    # 测试用例3
    intervals3 = [[1,2],[2,3]]
    print("测试用例3:")
    print("区间:", intervals3)
    print("结果:", solution.erase_overlap_intervals(intervals3))


if __name__ == "__main__":
    main()

===============================================

文件: LeetCode_460_LFUCache.java
===============================================
package class008_AdvancedAlgorithmsAndDataStructures.doubly_circular_linked_list_problems;

import java.util.*;

/**
 * LeetCode 460. LFU缓存 (LFU Cache)
 * 
 * 题目来源：https://leetcode.cn/problems/lfu-cache/
 * 
 * 题目描述：
 * 请你为最不经常使用（LFU）缓存算法设计并实现数据结构。
 * 实现 LFUCache 类：
 * - LFUCache(int capacity) - 用数据结构的容量 capacity 初始化对象
 * - int get(int key) - 如果键存在于缓存中，则获取键的值，否则返回 -1
 * - void put(int key, int value) - 如果键已存在，则变更其值；如果键不存在，请插入键值对
 * 
 * 当缓存达到其容量时，则应该在插入新项之前，使最不经常使用的项无效。
 * 在此问题中，当存在平局（即两个或更多个键具有相同使用频率）时，应该去除最久未使用的键。
 * 
 * 算法思路：
 * 这个问题可以通过以下方法解决：
 * 1. 双向循环链表：维护不同频率的节点列表
 * 2. 哈希表：快速定位键值对和频率列表
 * 3. 双哈希表：一个存储键值对，一个存储频率到节点列表的映射
 * 
 * 使用双向循环链表的方法：
 * 1. 维护一个频率到双向循环链表的映射
 * 2. 每个链表存储具有相同频率的键值对节点
 * 3. 维护一个键到节点的映射用于快速访问
 * 4. 记录最小频率用于快速找到需要删除的节点
 * 
 * 时间复杂度：
 * - get操作：O(1)
 * - put操作：O(1)
 * - 空间复杂度：O(capacity)
 * 
 * 应用场景：
 * 1. 缓存系统：LFU缓存策略实现
 * 2. 操作系统：页面置换算法
 * 3. 数据库：查询结果缓存
 * 
 * 相关题目：
 * 1. LeetCode 146. LRU缓存机制
 * 2. LeetCode 1756. 设计最近使用（MRU）栈
 * 3. LeetCode 1429. 第一个唯一数字
 */
public class LeetCode_460_LFUCache {
    
    /**
     * 双向链表节点
     */
    static class Node {
        int key, value, freq;
        Node prev, next;
        
        Node(int key, int value) {
            this.key = key;
            this.value = value;
            this.freq = 1;
        }
    }
    
    /**
     * 双向循环链表
     */
    static class DoublyCircularLinkedList {
        Node head; // 虚拟头节点
        
        DoublyCircularLinkedList() {
            head = new Node(0, 0);
            head.prev = head;
            head.next = head;
        }
        
        /**
         * 在头部添加节点
         */
        void addFirst(Node node) {
            node.next = head.next;
            node.prev = head;
            head.next.prev = node;
            head.next = node;
        }
        
        /**
         * 删除指定节点
         */
        void remove(Node node) {
            node.prev.next = node.next;
            node.next.prev = node.prev;
        }
        
        /**
         * 删除尾部节点（最久未使用的节点）
         */
        Node removeLast() {
            if (isEmpty()) {
                return null;
            }
            Node last = head.prev;
            remove(last);
            return last;
        }
        
        /**
         * 检查链表是否为空
         */
        boolean isEmpty() {
            return head.next == head;
        }
    }
    
    private int capacity;
    private int size;
    private int minFreq; // 记录最小频率
    private Map<Integer, Node> keyToNode; // 键到节点的映射
    private Map<Integer, DoublyCircularLinkedList> freqToList; // 频率到双向链表的映射
    
    /**
     * 构造函数
     * @param capacity 缓存容量
     */
    public LeetCode_460_LFUCache(int capacity) {
        this.capacity = capacity;
        this.size = 0;
        this.minFreq = 0;
        this.keyToNode = new HashMap<>();
        this.freqToList = new HashMap<>();
    }
    
    /**
     * 获取缓存值
     * 时间复杂度：O(1)
     * @param key 键
     * @return 值，如果不存在返回-1
     */
    public int get(int key) {
        if (!keyToNode.containsKey(key)) {
            return -1;
        }
        
        Node node = keyToNode.get(key);
        // 更新节点频率
        updateNode(node);
        return node.value;
    }
    
    /**
     * 添加缓存值
     * 时间复杂度：O(1)
     * @param key 键
     * @param value 值
     */
    public void put(int key, int value) {
        if (capacity == 0) {
            return;
        }
        
        if (keyToNode.containsKey(key)) {
            // 如果键已存在，更新值并增加频率
            Node node = keyToNode.get(key);
            node.value = value;
            updateNode(node);
        } else {
            // 如果键不存在
            if (size == capacity) {
                // 如果缓存已满，删除最不经常使用的节点
                DoublyCircularLinkedList minFreqList = freqToList.get(minFreq);
                Node deletedNode = minFreqList.removeLast();
                keyToNode.remove(deletedNode.key);
                size--;
            }
            
            // 添加新节点
            Node newNode = new Node(key, value);
            keyToNode.put(key, newNode);
            freqToList.computeIfAbsent(1, k -> new DoublyCircularLinkedList()).addFirst(newNode);
            minFreq = 1; // 新节点的频率为1，所以最小频率更新为1
            size++;
        }
    }
    
    /**
     * 更新节点频率
     * @param node 节点
     */
    private void updateNode(Node node) {
        // 从当前频率的链表中删除节点
        DoublyCircularLinkedList oldList = freqToList.get(node.freq);
        oldList.remove(node);
        
        // 如果当前频率等于最小频率且该频率的链表为空，更新最小频率
        if (node.freq == minFreq && oldList.isEmpty()) {
            minFreq++;
        }
        
        // 增加节点频率
        node.freq++;
        
        // 将节点添加到新频率的链表中
        freqToList.computeIfAbsent(node.freq, k -> new DoublyCircularLinkedList()).addFirst(node);
    }
    
    /**
     * 方法2：使用TreeSet优化的实现
     * 时间复杂度：O(log n)
     * 空间复杂度：O(n)
     */
    static class LFUCacheTreeSet {
        private int capacity;
        private int timestamp;
        private Map<Integer, int[]> keyToValue; // [value, freq, timestamp]
        private TreeSet<int[]> freqTimeSet; // [freq, timestamp, key]
        private Map<Integer, int[]> keyToEntry; // 键到TreeSet条目的映射
        
        public LFUCacheTreeSet(int capacity) {
            this.capacity = capacity;
            this.timestamp = 0;
            this.keyToValue = new HashMap<>();
            this.freqTimeSet = new TreeSet<>((a, b) -> {
                if (a[0] != b[0]) return Integer.compare(a[0], b[0]); // 按频率排序
                return Integer.compare(a[1], b[1]); // 按时间戳排序
            });
            this.keyToEntry = new HashMap<>();
        }
        
        public int get(int key) {
            if (!keyToValue.containsKey(key)) {
                return -1;
            }
            
            int[] valueEntry = keyToValue.get(key);
            int value = valueEntry[0];
            int freq = valueEntry[1];
            int time = valueEntry[2];
            
            // 删除旧条目
            int[] oldEntry = keyToEntry.get(key);
            freqTimeSet.remove(oldEntry);
            
            // 更新频率和时间戳
            timestamp++;
            int[] newEntry = {freq + 1, timestamp, key};
            freqTimeSet.add(newEntry);
            keyToEntry.put(key, newEntry);
            keyToValue.put(key, new int[]{value, freq + 1, timestamp});
            
            return value;
        }
        
        public void put(int key, int value) {
            if (capacity == 0) return;
            
            if (keyToValue.containsKey(key)) {
                // 更新现有键
                int[] valueEntry = keyToValue.get(key);
                int freq = valueEntry[1];
                int time = valueEntry[2];
                
                // 删除旧条目
                int[] oldEntry = keyToEntry.get(key);
                freqTimeSet.remove(oldEntry);
                
                // 更新频率和时间戳
                timestamp++;
                int[] newEntry = {freq + 1, timestamp, key};
                freqTimeSet.add(newEntry);
                keyToEntry.put(key, newEntry);
                keyToValue.put(key, new int[]{value, freq + 1, timestamp});
            } else {
                // 添加新键
                if (keyToValue.size() == capacity) {
                    // 删除最不经常使用的键
                    int[] toRemove = freqTimeSet.first();
                    freqTimeSet.remove(toRemove);
                    keyToValue.remove(toRemove[2]);
                    keyToEntry.remove(toRemove[2]);
                }
                
                timestamp++;
                int[] newEntry = {1, timestamp, key};
                freqTimeSet.add(newEntry);
                keyToEntry.put(key, newEntry);
                keyToValue.put(key, new int[]{value, 1, timestamp});
            }
        }
    }
    
    /**
     * 测试函数
     */
    public static void main(String[] args) {
        System.out.println("=== 测试 LeetCode 460. LFU缓存 ===");
        
        // 测试用例1
        System.out.println("测试用例1:");
        LeetCode_460_LFUCache lfuCache = new LeetCode_460_LFUCache(2);
        
        lfuCache.put(1, 1);
        lfuCache.put(2, 2);
        System.out.println("put(1,1), put(2,2)");
        
        int result1 = lfuCache.get(1);
        System.out.println("get(1) = " + result1 + " (期望: 1)");
        
        lfuCache.put(3, 3);
        System.out.println("put(3,3)");
        
        int result2 = lfuCache.get(2);
        System.out.println("get(2) = " + result2 + " (期望: -1)");
        
        int result3 = lfuCache.get(3);
        System.out.println("get(3) = " + result3 + " (期望: 3)");
        
        lfuCache.put(4, 4);
        System.out.println("put(4,4)");
        
        int result4 = lfuCache.get(1);
        System.out.println("get(1) = " + result4 + " (期望: -1)");
        
        int result5 = lfuCache.get(3);
        System.out.println("get(3) = " + result5 + " (期望: 3)");
        
        int result6 = lfuCache.get(4);
        System.out.println("get(4) = " + result6 + " (期望: 4)");
        System.out.println();
        
        // 性能测试
        System.out.println("=== 性能测试 ===");
        LeetCode_460_LFUCache perfCache = new LeetCode_460_LFUCache(1000);
        Random random = new Random(42);
        
        long startTime = System.nanoTime();
        
        // 执行10000次操作
        for (int i = 0; i < 10000; i++) {
            int operation = random.nextInt(3);
            int key = random.nextInt(2000);
            
            if (operation == 0) {
                // get操作
                perfCache.get(key);
            } else {
                // put操作
                int value = random.nextInt(10000);
                perfCache.put(key, value);
            }
        }
        
        long endTime = System.nanoTime();
        System.out.println("10000次操作完成");
        System.out.println("运行时间: " + (endTime - startTime) / 1_000_000.0 + " ms");
        
        // 算法复杂度分析
        System.out.println("\n=== 算法复杂度分析 ===");
        System.out.println("双向循环链表实现:");
        System.out.println("  时间复杂度:");
        System.out.println("    get操作: O(1)");
        System.out.println("    put操作: O(1)");
        System.out.println("  空间复杂度: O(capacity)");
        System.out.println("TreeSet实现:");
        System.out.println("  时间复杂度:");
        System.out.println("    get操作: O(log n)");
        System.out.println("    put操作: O(log n)");
        System.out.println("  空间复杂度: O(n)");
    }
}

===============================================

文件: leetcode_460_lfu_cache.cpp
===============================================
// LeetCode 460 LFU Cache
// C++ 实现

/**
 * LeetCode 460 LFU Cache
 * 
 * 题目描述：
 * 请你为最不经常使用（LFU）缓存算法设计并实现数据结构。
 * 实现 LFUCache 类：
 * - LFUCache(int capacity) - 用数据结构的容量 capacity 初始化对象
 * - int get(int key) - 如果键存在于缓存中，则获取键的值，否则返回 -1。
 * - void put(int key, int value) - 如果键已存在，则变更其值；如果键不存在，请插入键值对。
 * 
 * 解题思路：
 * 我们可以使用双向循环链表来实现LFU缓存。
 * 1. 使用哈希表存储键到节点的映射
 * 2. 使用另一个哈希表存储频率到双向链表的映射
 * 3. 每个节点包含键、值、频率和指向链表节点的指针
 * 4. 维护最小频率以快速找到要删除的节点
 * 
 * 时间复杂度：O(1)
 * 空间复杂度：O(capacity)
 */

// 由于编译环境限制，这里提供算法思路和伪代码实现

/*
#include <stdlib.h>

// 定义节点结构
typedef struct Node {
    int key;
    int value;
    int freq;
    struct Node* prev;
    struct Node* next;
} Node;

// 定义LFU缓存结构
typedef struct {
    int capacity;
    int size;
    int minFreq;
    Node** keyToNode; // 哈希表：键到节点的映射
    Node** freqToList; // 哈希表：频率到双向链表的映射
} LFUCache;

// 创建新节点
Node* createNode(int key, int value) {
    Node* node = (Node*)malloc(sizeof(Node));
    node->key = key;
    node->value = value;
    node->freq = 1;
    node->prev = NULL;
    node->next = NULL;
    return node;
}

// 初始化LFU缓存
LFUCache* lFUCacheCreate(int capacity) {
    LFUCache* cache = (LFUCache*)malloc(sizeof(LFUCache));
    cache->capacity = capacity;
    cache->size = 0;
    cache->minFreq = 0;
    // 初始化哈希表
    // 在实际实现中需要分配适当大小的哈希表
    return cache;
}

// 获取键对应的值
int lFUCacheGet(LFUCache* obj, int key) {
    // 在实际实现中需要查找节点并更新频率
    return -1;
}

// 插入或更新键值对
void lFUCachePut(LFUCache* obj, int key, int value) {
    // 在实际实现中需要处理插入和更新逻辑
}

// 释放LFU缓存
void lFUCacheFree(LFUCache* obj) {
    // 在实际实现中需要释放所有节点和哈希表
    free(obj);
}

// 算法核心思想：
// 1. 使用双向链表维护相同频率的节点
// 2. 使用哈希表实现O(1)查找
// 3. 维护最小频率以快速找到要删除的节点

// 时间复杂度分析：
// - get操作：O(1)
// - put操作：O(1)
// - 空间复杂度：O(capacity)
*/

// 算法应用场景：
// 1. 缓存系统设计
// 2. 数据结构设计
// 3. 双向链表应用

===============================================

文件: leetcode_460_lfu_cache.py
===============================================
#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
LeetCode 460 LFU Cache

题目描述：
请你为最不经常使用（LFU）缓存算法设计并实现数据结构。
实现 LFUCache 类：
- LFUCache(int capacity) - 用数据结构的容量 capacity 初始化对象
- int get(int key) - 如果键存在于缓存中，则获取键的值，否则返回 -1。
- void put(int key, int value) - 如果键已存在，则变更其值；如果键不存在，请插入键值对。

解题思路：
我们可以使用双向循环链表来实现LFU缓存。
1. 使用哈希表存储键到节点的映射
2. 使用另一个哈希表存储频率到双向链表的映射
3. 每个节点包含键、值、频率和指向链表节点的指针
4. 维护最小频率以快速找到要删除的节点

时间复杂度：O(1)
空间复杂度：O(capacity)
"""

class ListNode:
    def __init__(self, key=0, value=0, freq=0):
        self.key = key
        self.value = value
        self.freq = freq
        self.prev: 'ListNode | None' = None
        self.next: 'ListNode | None' = None

class LFUCache:
    def __init__(self, capacity):
        """
        初始化LFU缓存
        
        Args:
            capacity: 缓存容量
        """
        self.capacity = capacity
        self.size = 0
        self.min_freq = 0
        # 哈希表：键到节点的映射
        self.key_to_node = {}
        # 哈希表：频率到双向链表的映射
        self.freq_to_list = {}
    
    def get(self, key):
        """
        获取键对应的值
        
        Args:
            key: 键
            
        Returns:
            键对应的值，如果不存在则返回-1
        """
        if key not in self.key_to_node:
            return -1
        
        # 获取节点并更新频率
        node = self.key_to_node[key]
        self._update_freq(node)
        return node.value
    
    def put(self, key, value):
        """
        插入或更新键值对
        
        Args:
            key: 键
            value: 值
        """
        if self.capacity == 0:
            return
        
        if key in self.key_to_node:
            # 更新现有键值对
            node = self.key_to_node[key]
            node.value = value
            self._update_freq(node)
        else:
            # 插入新键值对
            if self.size == self.capacity:
                # 删除最不经常使用的节点
                self._remove_lfu()
            
            # 创建新节点
            node = ListNode(key, value, 1)
            self.key_to_node[key] = node
            self._add_to_freq_list(node)
            self.min_freq = 1
            self.size += 1
    
    def _update_freq(self, node):
        """
        更新节点频率
        
        Args:
            node: 节点
        """
        # 从当前频率链表中移除节点
        self._remove_from_freq_list(node)
        
        # 如果当前频率是最小频率且链表为空，更新最小频率
        if node.freq == self.min_freq and node.freq not in self.freq_to_list:
            self.min_freq += 1
        
        # 增加节点频率
        node.freq += 1
        
        # 将节点添加到新频率的链表中
        self._add_to_freq_list(node)
    
    def _remove_lfu(self):
        """删除最不经常使用的节点"""
        # 获取最小频率的链表
        freq_list = self.freq_to_list[self.min_freq]
        
        # 删除链表尾部节点（最久未使用的节点）
        node = freq_list.prev
        self._remove_from_freq_list(node)
        del self.key_to_node[node.key]
        self.size -= 1
    
    def _add_to_freq_list(self, node):
        """
        将节点添加到指定频率的链表中
        
        Args:
            node: 节点
        """
        freq = node.freq
        if freq not in self.freq_to_list:
            # 创建新的双向循环链表
            head = ListNode()
            head.prev = head  # type: ignore
            head.next = head  # type: ignore
            self.freq_to_list[freq] = head
        
        # 将节点添加到链表头部
        head = self.freq_to_list[freq]
        node.next = head.next
        node.prev = head
        head.next.prev = node
        head.next = node
    
    def _remove_from_freq_list(self, node):
        """
        从频率链表中移除节点
        
        Args:
            node: 节点
        """
        if node.freq in self.freq_to_list:
            node.prev.next = node.next
            node.next.prev = node.prev
            
            # 如果链表为空，删除链表
            head = self.freq_to_list[node.freq]
            if head.next == head:
                del self.freq_to_list[node.freq]


# 测试方法
def main():
    # 测试用例1
    lfu = LFUCache(2)
    lfu.put(1, 1)
    lfu.put(2, 2)
    print("测试用例1:")
    print("get(1) =", lfu.get(1))
    lfu.put(3, 3)
    print("get(2) =", lfu.get(2))
    print("get(3) =", lfu.get(3))
    lfu.put(4, 4)
    print("get(1) =", lfu.get(1))
    print("get(3) =", lfu.get(3))
    print("get(4) =", lfu.get(4))
    print()
    
    # 测试用例2
    lfu2 = LFUCache(0)
    lfu2.put(0, 0)
    print("测试用例2:")
    print("get(0) =", lfu2.get(0))
    print()
    
    # 测试用例3
    lfu3 = LFUCache(2)
    lfu3.put(2, 1)
    lfu3.put(3, 2)
    print("测试用例3:")
    print("get(3) =", lfu3.get(3))
    print("get(2) =", lfu3.get(2))
    lfu3.put(4, 3)
    print("get(2) =", lfu3.get(2))
    print("get(3) =", lfu3.get(3))
    print("get(4) =", lfu3.get(4))


if __name__ == "__main__":
    main()

===============================================

文件: LeetCode_56_MergeIntervals.java
===============================================
package class185.sweep_line_problems;

import java.util.*;

/**
 * LeetCode 56. 合并区间 (Merge Intervals)
 * 
 * 题目来源：https://leetcode.cn/problems/merge-intervals/
 * 
 * 题目描述：
 * 以数组 intervals 表示若干个区间的集合，其中单个区间为 intervals[i] = [starti, endi]。
 * 请你合并所有重叠的区间，并返回一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间。
 * 
 * 示例 1：
 * 输入：intervals = [[1,3],[2,6],[8,10],[15,18]]
 * 输出：[[1,6],[8,10],[15,18]]
 * 解释：区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6]
 * 
 * 示例 2：
 * 输入：intervals = [[1,4],[4,5]]
 * 输出：[[1,5]]
 * 解释：区间 [1,4] 和 [4,5] 可被视为重叠区间
 * 
 * 提示：
 * 1 <= intervals.length <= 10^4
 * intervals[i].length == 2
 * 0 <= starti <= endi <= 10^4
 * 
 * 解题思路：
 * 使用扫描线算法解决区间合并问题。核心思想是：
 * 1. 将所有区间按照开始时间排序
 * 2. 维护当前合并区间的起始和结束时间
 * 3. 遍历排序后的区间，如果当前区间与合并区间重叠则合并，否则将合并区间加入结果
 * 
 * 时间复杂度：O(n log n)，主要来自排序
 * 空间复杂度：O(n)，存储结果
 * 
 * 相关题目：
 * - LeetCode 57. 插入区间
 * - LeetCode 252. 会议室
 * - LeetCode 253. 会议室II
 */
public class LeetCode_56_MergeIntervals {
    
    /**
     * 合并区间的扫描线解法
     * @param intervals 输入区间数组
     * @return 合并后的区间数组
     */
    public static int[][] merge(int[][] intervals) {
        if (intervals == null || intervals.length == 0) {
            return new int[0][2];
        }
        
        // 按照区间开始时间排序
        Arrays.sort(intervals, (a, b) -> Integer.compare(a[0], b[0]));
        
        List<int[]> merged = new ArrayList<>();
        int[] currentInterval = intervals[0];
        
        for (int i = 1; i < intervals.length; i++) {
            int[] interval = intervals[i];
            
            if (interval[0] <= currentInterval[1]) {
                // 当前区间与合并区间重叠，合并
                currentInterval[1] = Math.max(currentInterval[1], interval[1]);
            } else {
                // 不重叠，将当前合并区间加入结果，开始新的合并区间
                merged.add(currentInterval);
                currentInterval = interval;
            }
        }
        
        // 添加最后一个合并区间
        merged.add(currentInterval);
        
        return merged.toArray(new int[merged.size()][]);
    }
    
    /**
     * 测试合并区间解法
     */
    public static void main(String[] args) {
        System.out.println("=== LeetCode 56. 合并区间 ===");
        
        // 测试用例1
        System.out.println("测试用例1:");
        int[][] intervals1 = {{1, 3}, {2, 6}, {8, 10}, {15, 18}};
        int[][] result1 = merge(intervals1);
        System.out.println("输入: " + Arrays.deepToString(intervals1));
        System.out.println("输出: " + Arrays.deepToString(result1));
        System.out.println("期望: [[1,6],[8,10],[15,18]]");
        System.out.println();
        
        // 测试用例2
        System.out.println("测试用例2:");
        int[][] intervals2 = {{1, 4}, {4, 5}};
        int[][] result2 = merge(intervals2);
        System.out.println("输入: " + Arrays.deepToString(intervals2));
        System.out.println("输出: " + Arrays.deepToString(result2));
        System.out.println("期望: [[1,5]]");
        System.out.println();
        
        // 边界测试
        System.out.println("边界测试:");
        int[][] intervals3 = {{1, 4}, {0, 4}};
        int[][] result3 = merge(intervals3);
        System.out.println("输入: " + Arrays.deepToString(intervals3));
        System.out.println("输出: " + Arrays.deepToString(result3));
        System.out.println("期望: [[0,4]]");
        System.out.println();
        
        // 性能测试
        System.out.println("=== 性能测试 ===");
        Random random = new Random(42);
        int n = 10000;
        int[][] largeIntervals = new int[n][2];
        
        for (int i = 0; i < n; i++) {
            int start = random.nextInt(100000);
            int end = start + random.nextInt(1000) + 1;
            largeIntervals[i] = new int[]{start, end};
        }
        
        long startTime = System.nanoTime();
        int[][] largeResult = merge(largeIntervals);
        long endTime = System.nanoTime();
        
        System.out.println("10000个区间的合并计算完成");
        System.out.println("合并后区间数量: " + largeResult.length);
        System.out.println("运行时间: " + (endTime - startTime) / 1_000_000.0 + " ms");
        
        // 工程化考量
        System.out.println("\n=== 工程化考量 ===");
        System.out.println("1. 异常处理：处理空输入和null输入");
        System.out.println("2. 边界情况：处理单个区间、完全重叠区间");
        System.out.println("3. 性能优化：排序时间复杂度O(n log n)是最优解");
        System.out.println("4. 内存优化：原地合并或使用最小额外空间");
    }
}

===============================================

文件: leetcode_56_merge_intervals.cpp
===============================================
#include <iostream>
#include <vector>
#include <algorithm>
#include <random>
#include <chrono>

using namespace std;

/**
 * LeetCode 56. 合并区间 (Merge Intervals) - C++版本
 * 
 * 题目来源：https://leetcode.cn/problems/merge-intervals/
 * 
 * 解题思路：
 * 使用扫描线算法解决区间合并问题
 * 
 * 时间复杂度：O(n log n)
 * 空间复杂度：O(n)
 */
class Solution {
public:
    vector<vector<int>> merge(vector<vector<int>>& intervals) {
        if (intervals.empty()) {
            return {};
        }
        
        // 按照区间开始时间排序
        sort(intervals.begin(), intervals.end(), [](const vector<int>& a, const vector<int>& b) {
            return a[0] < b[0];
        });
        
        vector<vector<int>> merged;
        vector<int> currentInterval = intervals[0];
        
        for (int i = 1; i < intervals.size(); i++) {
            if (intervals[i][0] <= currentInterval[1]) {
                // 当前区间与合并区间重叠，合并
                currentInterval[1] = max(currentInterval[1], intervals[i][1]);
            } else {
                // 不重叠，将当前合并区间加入结果，开始新的合并区间
                merged.push_back(currentInterval);
                currentInterval = intervals[i];
            }
        }
        
        // 添加最后一个合并区间
        merged.push_back(currentInterval);
        
        return merged;
    }
};

/**
 * 打印二维数组
 */
void printVector2D(const vector<vector<int>>& vec) {
    cout << "[";
    for (int i = 0; i < vec.size(); i++) {
        cout << "[" << vec[i][0] << "," << vec[i][1] << "]";
        if (i < vec.size() - 1) cout << ",";
    }
    cout << "]" << endl;
}

int main() {
    cout << "=== LeetCode 56. 合并区间 (C++版本) ===" << endl;
    
    Solution solution;
    
    // 测试用例1
    cout << "测试用例1:" << endl;
    vector<vector<int>> intervals1 = {{1, 3}, {2, 6}, {8, 10}, {15, 18}};
    vector<vector<int>> result1 = solution.merge(intervals1);
    cout << "输入: ";
    printVector2D(intervals1);
    cout << "输出: ";
    printVector2D(result1);
    cout << "期望: [[1,6],[8,10],[15,18]]" << endl;
    cout << endl;
    
    // 测试用例2
    cout << "测试用例2:" << endl;
    vector<vector<int>> intervals2 = {{1, 4}, {4, 5}};
    vector<vector<int>> result2 = solution.merge(intervals2);
    cout << "输入: ";
    printVector2D(intervals2);
    cout << "输出: ";
    printVector2D(result2);
    cout << "期望: [[1,5]]" << endl;
    cout << endl;
    
    // 性能测试
    cout << "=== 性能测试 ===" << endl;
    default_random_engine generator(42);
    uniform_int_distribution<int> distribution(0, 100000);
    
    int n = 10000;
    vector<vector<int>> largeIntervals(n, vector<int>(2));
    
    for (int i = 0; i < n; i++) {
        int start = distribution(generator);
        int end = start + distribution(generator) % 1000 + 1;
        largeIntervals[i] = {start, end};
    }
    
    auto startTime = chrono::high_resolution_clock::now();
    vector<vector<int>> largeResult = solution.merge(largeIntervals);
    auto endTime = chrono::high_resolution_clock::now();
    
    auto duration = chrono::duration_cast<chrono::microseconds>(endTime - startTime);
    
    cout << n << "个区间的合并计算完成" << endl;
    cout << "合并后区间数量: " << largeResult.size() << endl;
    cout << "运行时间: " << duration.count() / 1000.0 << " ms" << endl;
    
    // C++语言特性考量
    cout << "\n=== C++语言特性考量 ===" << endl;
    cout << "1. 使用lambda表达式进行自定义排序" << endl;
    cout << "2. 使用vector容器管理动态数组" << endl;
    cout << "3. 使用chrono库进行精确时间测量" << endl;
    cout << "4. 使用RAII原则管理资源" << endl;
    
    return 0;
}

===============================================

文件: leetcode_56_merge_intervals.py
===============================================
#!/usr/bin/env python3
"""
LeetCode 56. 合并区间 (Merge Intervals) - Python版本

题目来源：https://leetcode.cn/problems/merge-intervals/

解题思路：
使用扫描线算法解决区间合并问题

时间复杂度：O(n log n)
空间复杂度：O(n)
"""

import time
import random
from typing import List

class Solution:
    def merge(self, intervals: List[List[int]]) -> List[List[int]]:
        """
        合并区间的扫描线解法
        
        Args:
            intervals: 输入区间数组
            
        Returns:
            合并后的区间数组
        """
        if not intervals:
            return []
        
        # 按照区间开始时间排序
        intervals.sort(key=lambda x: x[0])
        
        merged = []
        current_interval = intervals[0]
        
        for i in range(1, len(intervals)):
            interval = intervals[i]
            
            if interval[0] <= current_interval[1]:
                # 当前区间与合并区间重叠，合并
                current_interval[1] = max(current_interval[1], interval[1])
            else:
                # 不重叠，将当前合并区间加入结果，开始新的合并区间
                merged.append(current_interval)
                current_interval = interval
        
        # 添加最后一个合并区间
        merged.append(current_interval)
        
        return merged

def test_merge_intervals():
    """测试合并区间解法"""
    solution = Solution()
    
    print("=== LeetCode 56. 合并区间 (Python版本) ===")
    
    # 测试用例1
    print("测试用例1:")
    intervals1 = [[1, 3], [2, 6], [8, 10], [15, 18]]
    result1 = solution.merge(intervals1)
    print(f"输入: {intervals1}")
    print(f"输出: {result1}")
    print("期望: [[1,6],[8,10],[15,18]]")
    print()
    
    # 测试用例2
    print("测试用例2:")
    intervals2 = [[1, 4], [4, 5]]
    result2 = solution.merge(intervals2)
    print(f"输入: {intervals2}")
    print(f"输出: {result2}")
    print("期望: [[1,5]]")
    print()
    
    # 边界测试
    print("边界测试:")
    intervals3 = [[1, 4], [0, 4]]
    result3 = solution.merge(intervals3)
    print(f"输入: {intervals3}")
    print(f"输出: {result3}")
    print("期望: [[0,4]]")
    print()
    
    # 性能测试
    print("=== 性能测试 ===")
    random.seed(42)
    n = 10000
    large_intervals = []
    
    for i in range(n):
        start = random.randint(0, 100000)
        end = start + random.randint(1, 1000)
        large_intervals.append([start, end])
    
    start_time = time.time()
    large_result = solution.merge(large_intervals)
    end_time = time.time()
    
    print(f"{n}个区间的合并计算完成")
    print(f"合并后区间数量: {len(large_result)}")
    print(f"运行时间: {(end_time - start_time) * 1000:.2f} ms")
    
    # Python语言特性考量
    print("\n=== Python语言特性考量 ===")
    print("1. 使用lambda表达式进行自定义排序")
    print("2. 使用列表推导式生成测试数据")
    print("3. 使用类型注解提高代码可读性")
    print("4. 使用f-string进行格式化输出")
    
    # 算法复杂度分析
    print("\n=== 算法复杂度分析 ===")
    print("时间复杂度: O(n log n)")
    print("  - 排序: O(n log n)")
    print("  - 扫描: O(n)")
    print("空间复杂度: O(n)")
    print("  - 存储结果: O(n)")
    print("  - 排序: O(log n) 或 O(n) 取决于排序算法")

if __name__ == "__main__":
    test_merge_intervals()

===============================================

文件: LeetCode_612_ShortestDistanceInAPlane.cpp
===============================================
/*
 * LeetCode 612. 平面上的最短距离 (C++版本)
 * 
 * 问题描述：
 * 给定一个平面上的点集，找到其中距离最近的两个点之间的距离。
 * 
 * 算法思路：
 * 使用平面分治算法（Closest Pair of Points）解决最近点对问题。
 * 1. 将点集按照x坐标排序
 * 2. 递归地将点集分为左右两部分
 * 3. 分别计算左右两部分的最近点对距离
 * 4. 计算跨越分割线的最近点对距离
 * 5. 返回三者中的最小值
 * 
 * 时间复杂度：O(n log n)
 * 空间复杂度：O(n)
 * 
 * 应用场景：
 * 1. 地理信息系统：最近设施查询
 * 2. 计算机图形学：碰撞检测
 * 3. 机器学习：最近邻搜索
 * 
 * 相关题目：
 * 1. LeetCode 973. 最接近原点的K个点
 * 2. LeetCode 719. 找出第 k 小的距离对
 * 3. LeetCode 149. 直线上最多的点数
 */

#include <iostream>
#include <vector>
#include <algorithm>
#include <cmath>
#include <limits>
#include <random>
#include <chrono>
#include <stdexcept>

using namespace std;

/**
 * 点类，用于存储二维坐标
 */
struct Point {
    double x, y;
    
    Point(double x = 0, double y = 0) : x(x), y(y) {}
    
    /**
     * 计算两个点之间的欧几里得距离
     */
    double distanceTo(const Point& p) const {
        double dx = this->x - p.x;
        double dy = this->y - p.y;
        return sqrt(dx * dx + dy * dy);
    }
    
    /**
     * 重载输出运算符，方便调试
     */
    friend ostream& operator<<(ostream& os, const Point& p) {
        os << "(" << p.x << ", " << p.y << ")";
        return os;
    }
};

/**
 * 平面分治算法类
 */
class ClosestPairSolver {
public:
    /**
     * 暴力解法：计算所有点对的距离
     * 时间复杂度：O(n²)
     * 空间复杂度：O(1)
     */
    static double shortestDistanceBruteForce(const vector<Point>& points) {
        if (points.size() < 2) {
            throw invalid_argument("点集必须包含至少两个点");
        }
        
        double minDistance = numeric_limits<double>::max();
        
        for (size_t i = 0; i < points.size(); i++) {
            for (size_t j = i + 1; j < points.size(); j++) {
                double distance = points[i].distanceTo(points[j]);
                if (distance < minDistance) {
                    minDistance = distance;
                }
            }
        }
        
        return minDistance;
    }
    
    /**
     * 平面分治算法：高效解决最近点对问题
     * 时间复杂度：O(n log n)
     * 空间复杂度：O(n)
     */
    static double shortestDistanceDivideConquer(vector<Point>& points) {
        if (points.size() < 2) {
            throw invalid_argument("点集必须包含至少两个点");
        }
        
        // 按照x坐标排序
        vector<Point> pointsSortedByX = points;
        sort(pointsSortedByX.begin(), pointsSortedByX.end(), 
             [](const Point& a, const Point& b) { return a.x < b.x; });
        
        // 按照y坐标排序（用于后续处理）
        vector<Point> pointsSortedByY = pointsSortedByX;
        sort(pointsSortedByY.begin(), pointsSortedByY.end(), 
             [](const Point& a, const Point& b) { return a.y < b.y; });
        
        return closestPairRecursive(pointsSortedByX, 0, pointsSortedByX.size() - 1, pointsSortedByY);
    }

private:
    /**
     * 递归求解最近点对
     */
    static double closestPairRecursive(const vector<Point>& pointsSortedByX, 
                                      int left, int right, 
                                      const vector<Point>& pointsSortedByY) {
        // 基本情况：小规模问题直接暴力求解
        if (right - left <= 3) {
            return bruteForce(pointsSortedByX, left, right);
        }
        
        // 分治求解
        int mid = left + (right - left) / 2;
        Point midPoint = pointsSortedByX[mid];
        
        // 分割y排序的数组
        vector<Point> leftPointsSortedByY;
        vector<Point> rightPointsSortedByY;
        
        for (const Point& point : pointsSortedByY) {
            if (point.x <= midPoint.x) {
                leftPointsSortedByY.push_back(point);
            } else {
                rightPointsSortedByY.push_back(point);
            }
        }
        
        // 递归求解左右两部分的最近距离
        double leftMin = closestPairRecursive(pointsSortedByX, left, mid, leftPointsSortedByY);
        double rightMin = closestPairRecursive(pointsSortedByX, mid + 1, right, rightPointsSortedByY);
        double minDistance = min(leftMin, rightMin);
        
        // 检查跨越分割线的点对
        vector<Point> strip;
        for (const Point& point : pointsSortedByY) {
            if (abs(point.x - midPoint.x) < minDistance) {
                strip.push_back(point);
            }
        }
        
        // 在strip中检查最近点对
        for (size_t i = 0; i < strip.size(); i++) {
            // 只需要检查后面的7个点（理论证明最多需要检查7个点）
            for (size_t j = i + 1; j < strip.size() && (strip[j].y - strip[i].y) < minDistance; j++) {
                double distance = strip[i].distanceTo(strip[j]);
                if (distance < minDistance) {
                    minDistance = distance;
                }
            }
        }
        
        return minDistance;
    }
    
    /**
     * 暴力求解小规模点集的最近距离
     */
    static double bruteForce(const vector<Point>& points, int left, int right) {
        double minDistance = numeric_limits<double>::max();
        
        for (int i = left; i <= right; i++) {
            for (int j = i + 1; j <= right; j++) {
                double distance = points[i].distanceTo(points[j]);
                if (distance < minDistance) {
                    minDistance = distance;
                }
            }
        }
        
        return minDistance;
    }
};

/**
 * 测试函数
 */
int main() {
    cout << "=== 测试 LeetCode 612. 平面上的最短距离 (C++版本) ===" << endl;
    
    // 测试用例1：简单点集
    vector<Point> points1 = {
        Point(1, 1),
        Point(2, 2),
        Point(3, 3),
        Point(4, 4)
    };
    
    cout << "测试用例1:" << endl;
    cout << "点集: ";
    for (const auto& p : points1) {
        cout << p << " ";
    }
    cout << endl;
    
    cout << "暴力解法结果: " << ClosestPairSolver::shortestDistanceBruteForce(points1) << endl;
    cout << "分治算法结果: " << ClosestPairSolver::shortestDistanceDivideConquer(points1) << endl;
    
    // 测试用例2：随机点集
    mt19937 rng(42);
    uniform_real_distribution<double> dist(0, 100);
    
    vector<Point> points2(10);
    for (int i = 0; i < 10; i++) {
        points2[i] = Point(dist(rng), dist(rng));
    }
    
    cout << "\n测试用例2:" << endl;
    cout << "随机点集大小: " << points2.size() << endl;
    cout << "暴力解法结果: " << ClosestPairSolver::shortestDistanceBruteForce(points2) << endl;
    cout << "分治算法结果: " << ClosestPairSolver::shortestDistanceDivideConquer(points2) << endl;
    
    // 测试用例3：边界情况（两个点）
    vector<Point> points3 = {
        Point(0, 0),
        Point(3, 4)
    };
    
    cout << "\n测试用例3:" << endl;
    cout << "点集: ";
    for (const auto& p : points3) {
        cout << p << " ";
    }
    cout << endl;
    
    cout << "暴力解法结果: " << ClosestPairSolver::shortestDistanceBruteForce(points3) << endl;
    cout << "分治算法结果: " << ClosestPairSolver::shortestDistanceDivideConquer(points3) << endl;
    
    // 性能测试
    cout << "\n=== 性能测试 ===" << endl;
    
    // 小规模测试
    vector<Point> smallPoints(100);
    for (int i = 0; i < 100; i++) {
        smallPoints[i] = Point(dist(rng) * 10, dist(rng) * 10);
    }
    
    auto startTime = chrono::high_resolution_clock::now();
    double bruteResult = ClosestPairSolver::shortestDistanceBruteForce(smallPoints);
    auto bruteTime = chrono::duration_cast<chrono::microseconds>(
        chrono::high_resolution_clock::now() - startTime);
    
    startTime = chrono::high_resolution_clock::now();
    double divideResult = ClosestPairSolver::shortestDistanceDivideConquer(smallPoints);
    auto divideTime = chrono::duration_cast<chrono::microseconds>(
        chrono::high_resolution_clock::now() - startTime);
    
    cout << "100个点:" << endl;
    cout << "暴力解法时间: " << bruteTime.count() / 1000.0 << " ms, 结果: " << bruteResult << endl;
    cout << "分治算法时间: " << divideTime.count() / 1000.0 << " ms, 结果: " << divideResult << endl;
    
    // 大规模测试
    vector<Point> largePoints(10000);
    for (int i = 0; i < 10000; i++) {
        largePoints[i] = Point(dist(rng) * 100, dist(rng) * 100);
    }
    
    startTime = chrono::high_resolution_clock::now();
    divideResult = ClosestPairSolver::shortestDistanceDivideConquer(largePoints);
    divideTime = chrono::duration_cast<chrono::microseconds>(
        chrono::high_resolution_clock::now() - startTime);
    
    cout << "\n10000个点:" << endl;
    cout << "分治算法时间: " << divideTime.count() / 1000.0 << " ms, 结果: " << divideResult << endl;
    
    // 验证算法正确性
    cout << "\n=== 算法正确性验证 ===" << endl;
    
    // 创建已知最小距离的点集
    vector<Point> knownPoints = {
        Point(0, 0),
        Point(1, 1),
        Point(3, 3),
        Point(0.5, 0.5)  // 这个点距离(0,0)和(1,1)都很近
    };
    
    double expectedMin = sqrt(0.5);  // (0,0)到(0.5,0.5)的距离
    double actualMin = ClosestPairSolver::shortestDistanceDivideConquer(knownPoints);
    
    cout << "预期最小距离: " << expectedMin << endl;
    cout << "实际最小距离: " << actualMin << endl;
    cout << "算法正确性: " << (abs(expectedMin - actualMin) < 1e-10 ? "通过" : "失败") << endl;
    
    // 工程化考量：异常处理测试
    cout << "\n=== 异常处理测试 ===" << endl;
    
    try {
        vector<Point> emptyPoints;
        ClosestPairSolver::shortestDistanceDivideConquer(emptyPoints);
        cout << "空数组测试: 失败（应该抛出异常）" << endl;
    } catch (const invalid_argument& e) {
        cout << "空数组测试: 通过（正确抛出异常）" << endl;
    }
    
    try {
        vector<Point> singlePoint = {Point(1, 1)};
        ClosestPairSolver::shortestDistanceDivideConquer(singlePoint);
        cout << "单点数组测试: 失败（应该抛出异常）" << endl;
    } catch (const invalid_argument& e) {
        cout << "单点数组测试: 通过（正确抛出异常）" << endl;
    }
    
    // 内存使用测试（C++特有考量）
    cout << "\n=== 内存使用考量 ===" << endl;
    cout << "分治算法在递归过程中会创建临时数组，但空间复杂度为O(n)" << endl;
    cout << "对于大规模数据，可以考虑使用迭代版本减少递归深度" << endl;
    
    return 0;
}

===============================================

文件: LeetCode_612_ShortestDistanceInAPlane.java
===============================================
package class185.closest_pair_problems;

import java.util.*;

/**
 * LeetCode 612. 平面上的最短距离
 * 
 * 问题描述：
 * 给定一个平面上的点集，找到其中距离最近的两个点之间的距离。
 * 
 * 算法思路：
 * 使用平面分治算法（Closest Pair of Points）解决最近点对问题。
 * 1. 将点集按照x坐标排序
 * 2. 递归地将点集分为左右两部分
 * 3. 分别计算左右两部分的最近点对距离
 * 4. 计算跨越分割线的最近点对距离
 * 5. 返回三者中的最小值
 * 
 * 时间复杂度：O(n log n)
 * 空间复杂度：O(n)
 * 
 * 应用场景：
 * 1. 地理信息系统：最近设施查询
 * 2. 计算机图形学：碰撞检测
 * 3. 机器学习：最近邻搜索
 * 
 * 相关题目：
 * 1. LeetCode 973. 最接近原点的K个点
 * 2. LeetCode 719. 找出第 k 小的距离对
 * 3. LeetCode 149. 直线上最多的点数
 */
public class LeetCode_612_ShortestDistanceInAPlane {
    
    static class Point {
        double x, y;
        
        Point(double x, double y) {
            this.x = x;
            this.y = y;
        }
        
        double distanceTo(Point p) {
            double dx = this.x - p.x;
            double dy = this.y - p.y;
            return Math.sqrt(dx * dx + dy * dy);
        }
        
        @Override
        public String toString() {
            return "(" + x + ", " + y + ")";
        }
    }
    
    /**
     * 暴力解法：计算所有点对的距离
     * 时间复杂度：O(n²)
     * 空间复杂度：O(1)
     */
    public double shortestDistanceBruteForce(Point[] points) {
        if (points == null || points.length < 2) {
            throw new IllegalArgumentException("点集必须包含至少两个点");
        }
        
        double minDistance = Double.MAX_VALUE;
        
        for (int i = 0; i < points.length; i++) {
            for (int j = i + 1; j < points.length; j++) {
                double distance = points[i].distanceTo(points[j]);
                if (distance < minDistance) {
                    minDistance = distance;
                }
            }
        }
        
        return minDistance;
    }
    
    /**
     * 平面分治算法：高效解决最近点对问题
     * 时间复杂度：O(n log n)
     * 空间复杂度：O(n)
     */
    public double shortestDistanceDivideConquer(Point[] points) {
        if (points == null || points.length < 2) {
            throw new IllegalArgumentException("点集必须包含至少两个点");
        }
        
        // 按照x坐标排序
        Point[] pointsSortedByX = points.clone();
        Arrays.sort(pointsSortedByX, Comparator.comparingDouble(p -> p.x));
        
        // 按照y坐标排序（用于后续处理）
        Point[] pointsSortedByY = pointsSortedByX.clone();
        Arrays.sort(pointsSortedByY, Comparator.comparingDouble(p -> p.y));
        
        return closestPairRecursive(pointsSortedByX, 0, pointsSortedByX.length - 1, pointsSortedByY);
    }
    
    /**
     * 递归求解最近点对
     */
    private double closestPairRecursive(Point[] pointsSortedByX, int left, int right, Point[] pointsSortedByY) {
        // 基本情况：小规模问题直接暴力求解
        if (right - left <= 3) {
            return bruteForce(pointsSortedByX, left, right);
        }
        
        // 分治求解
        int mid = left + (right - left) / 2;
        Point midPoint = pointsSortedByX[mid];
        
        // 分割y排序的数组
        Point[] leftPointsSortedByY = new Point[mid - left + 1];
        Point[] rightPointsSortedByY = new Point[right - mid];
        
        int leftIndex = 0, rightIndex = 0;
        for (Point point : pointsSortedByY) {
            if (point.x <= midPoint.x) {
                leftPointsSortedByY[leftIndex++] = point;
            } else {
                rightPointsSortedByY[rightIndex++] = point;
            }
        }
        
        // 递归求解左右两部分的最近距离
        double leftMin = closestPairRecursive(pointsSortedByX, left, mid, leftPointsSortedByY);
        double rightMin = closestPairRecursive(pointsSortedByX, mid + 1, right, rightPointsSortedByY);
        double minDistance = Math.min(leftMin, rightMin);
        
        // 检查跨越分割线的点对
        List<Point> strip = new ArrayList<>();
        for (Point point : pointsSortedByY) {
            if (Math.abs(point.x - midPoint.x) < minDistance) {
                strip.add(point);
            }
        }
        
        // 在strip中检查最近点对
        for (int i = 0; i < strip.size(); i++) {
            // 只需要检查后面的7个点（理论证明最多需要检查7个点）
            for (int j = i + 1; j < strip.size() && (strip.get(j).y - strip.get(i).y) < minDistance; j++) {
                double distance = strip.get(i).distanceTo(strip.get(j));
                if (distance < minDistance) {
                    minDistance = distance;
                }
            }
        }
        
        return minDistance;
    }
    
    /**
     * 暴力求解小规模点集的最近距离
     */
    private double bruteForce(Point[] points, int left, int right) {
        double minDistance = Double.MAX_VALUE;
        
        for (int i = left; i <= right; i++) {
            for (int j = i + 1; j <= right; j++) {
                double distance = points[i].distanceTo(points[j]);
                if (distance < minDistance) {
                    minDistance = distance;
                }
            }
        }
        
        return minDistance;
    }
    
    /**
     * 测试函数
     */
    public static void main(String[] args) {
        LeetCode_612_ShortestDistanceInAPlane solution = new LeetCode_612_ShortestDistanceInAPlane();
        
        System.out.println("=== 测试 LeetCode 612. 平面上的最短距离 ===");
        
        // 测试用例1：简单点集
        Point[] points1 = {
            new Point(1, 1),
            new Point(2, 2),
            new Point(3, 3),
            new Point(4, 4)
        };
        
        System.out.println("测试用例1:");
        System.out.println("点集: " + Arrays.toString(points1));
        System.out.println("暴力解法结果: " + solution.shortestDistanceBruteForce(points1));
        System.out.println("分治算法结果: " + solution.shortestDistanceDivideConquer(points1));
        
        // 测试用例2：随机点集
        Random random = new Random(42);
        Point[] points2 = new Point[10];
        for (int i = 0; i < 10; i++) {
            points2[i] = new Point(random.nextDouble() * 100, random.nextDouble() * 100);
        }
        
        System.out.println("\n测试用例2:");
        System.out.println("随机点集大小: " + points2.length);
        System.out.println("暴力解法结果: " + solution.shortestDistanceBruteForce(points2));
        System.out.println("分治算法结果: " + solution.shortestDistanceDivideConquer(points2));
        
        // 测试用例3：边界情况（两个点）
        Point[] points3 = {
            new Point(0, 0),
            new Point(3, 4)
        };
        
        System.out.println("\n测试用例3:");
        System.out.println("点集: " + Arrays.toString(points3));
        System.out.println("暴力解法结果: " + solution.shortestDistanceBruteForce(points3));
        System.out.println("分治算法结果: " + solution.shortestDistanceDivideConquer(points3));
        
        // 性能测试
        System.out.println("\n=== 性能测试 ===");
        
        // 小规模测试
        Point[] smallPoints = new Point[100];
        for (int i = 0; i < 100; i++) {
            smallPoints[i] = new Point(random.nextDouble() * 1000, random.nextDouble() * 1000);
        }
        
        long startTime = System.nanoTime();
        double bruteResult = solution.shortestDistanceBruteForce(smallPoints);
        long bruteTime = System.nanoTime() - startTime;
        
        startTime = System.nanoTime();
        double divideResult = solution.shortestDistanceDivideConquer(smallPoints);
        long divideTime = System.nanoTime() - startTime;
        
        System.out.println("100个点:");
        System.out.println("暴力解法时间: " + bruteTime / 1_000_000.0 + " ms, 结果: " + bruteResult);
        System.out.println("分治算法时间: " + divideTime / 1_000_000.0 + " ms, 结果: " + divideResult);
        
        // 大规模测试
        Point[] largePoints = new Point[10000];
        for (int i = 0; i < 10000; i++) {
            largePoints[i] = new Point(random.nextDouble() * 10000, random.nextDouble() * 10000);
        }
        
        startTime = System.nanoTime();
        divideResult = solution.shortestDistanceDivideConquer(largePoints);
        divideTime = System.nanoTime() - startTime;
        
        System.out.println("\n10000个点:");
        System.out.println("分治算法时间: " + divideTime / 1_000_000.0 + " ms, 结果: " + divideResult);
        
        // 验证算法正确性
        System.out.println("\n=== 算法正确性验证 ===");
        
        // 创建已知最小距离的点集
        Point[] knownPoints = {
            new Point(0, 0),
            new Point(1, 1),
            new Point(3, 3),
            new Point(0.5, 0.5)  // 这个点距离(0,0)和(1,1)都很近
        };
        
        double expectedMin = Math.sqrt(0.5);  // (0,0)到(0.5,0.5)的距离
        double actualMin = solution.shortestDistanceDivideConquer(knownPoints);
        
        System.out.println("预期最小距离: " + expectedMin);
        System.out.println("实际最小距离: " + actualMin);
        System.out.println("算法正确性: " + (Math.abs(expectedMin - actualMin) < 1e-10));
        
        // 工程化考量：异常处理测试
        System.out.println("\n=== 异常处理测试 ===");
        
        try {
            solution.shortestDistanceDivideConquer(new Point[0]);
            System.out.println("空数组测试: 失败（应该抛出异常）");
        } catch (IllegalArgumentException e) {
            System.out.println("空数组测试: 通过（正确抛出异常）");
        }
        
        try {
            solution.shortestDistanceDivideConquer(new Point[1]);
            System.out.println("单点数组测试: 失败（应该抛出异常）");
        } catch (IllegalArgumentException e) {
            System.out.println("单点数组测试: 通过（正确抛出异常）");
        }
    }
}

===============================================

文件: leetcode_612_shortest_distance_in_a_plane.py
===============================================
#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
LeetCode 612. 平面上的最短距离 (Python版本)

问题描述：
给定一个平面上的点集，找到其中距离最近的两个点之间的距离。

算法思路：
使用平面分治算法（Closest Pair of Points）解决最近点对问题。
1. 将点集按照x坐标排序
2. 递归地将点集分为左右两部分
3. 分别计算左右两部分的最近点对距离
4. 计算跨越分割线的最近点对距离
5. 返回三者中的最小值

时间复杂度：O(n log n)
空间复杂度：O(n)

应用场景：
1. 地理信息系统：最近设施查询
2. 计算机图形学：碰撞检测
3. 机器学习：最近邻搜索

相关题目：
1. LeetCode 973. 最接近原点的K个点
2. LeetCode 719. 找出第 k 小的距离对
3. LeetCode 149. 直线上最多的点数
"""

import math
import random
import time
from typing import List, Tuple
from dataclasses import dataclass


@dataclass
class Point:
    """点类，用于存储二维坐标"""
    x: float
    y: float
    
    def distance_to(self, other: 'Point') -> float:
        """计算两个点之间的欧几里得距离"""
        dx = self.x - other.x
        dy = self.y - other.y
        return math.sqrt(dx * dx + dy * dy)
    
    def __str__(self) -> str:
        return f"({self.x}, {self.y})"
    
    def __repr__(self) -> str:
        return self.__str__()


class ClosestPairSolver:
    """平面分治算法类"""
    
    @staticmethod
    def shortest_distance_brute_force(points: List[Point]) -> float:
        """
        暴力解法：计算所有点对的距离
        时间复杂度：O(n²)
        空间复杂度：O(1)
        """
        if len(points) < 2:
            raise ValueError("点集必须包含至少两个点")
        
        min_distance = float('inf')
        
        for i in range(len(points)):
            for j in range(i + 1, len(points)):
                distance = points[i].distance_to(points[j])
                if distance < min_distance:
                    min_distance = distance
        
        return min_distance
    
    @staticmethod
    def shortest_distance_divide_conquer(points: List[Point]) -> float:
        """
        平面分治算法：高效解决最近点对问题
        时间复杂度：O(n log n)
        空间复杂度：O(n)
        """
        if len(points) < 2:
            raise ValueError("点集必须包含至少两个点")
        
        # 按照x坐标排序
        points_sorted_by_x = sorted(points, key=lambda p: p.x)
        
        # 按照y坐标排序（用于后续处理）
        points_sorted_by_y = sorted(points_sorted_by_x, key=lambda p: p.y)
        
        return ClosestPairSolver._closest_pair_recursive(
            points_sorted_by_x, 0, len(points_sorted_by_x) - 1, points_sorted_by_y
        )
    
    @staticmethod
    def _closest_pair_recursive(points_sorted_by_x: List[Point], 
                              left: int, right: int, 
                              points_sorted_by_y: List[Point]) -> float:
        """
        递归求解最近点对
        """
        # 基本情况：小规模问题直接暴力求解
        if right - left <= 3:
            return ClosestPairSolver._brute_force(points_sorted_by_x, left, right)
        
        # 分治求解
        mid = left + (right - left) // 2
        mid_point = points_sorted_by_x[mid]
        
        # 分割y排序的数组
        left_points_sorted_by_y = []
        right_points_sorted_by_y = []
        
        for point in points_sorted_by_y:
            if point.x <= mid_point.x:
                left_points_sorted_by_y.append(point)
            else:
                right_points_sorted_by_y.append(point)
        
        # 递归求解左右两部分的最近距离
        left_min = ClosestPairSolver._closest_pair_recursive(
            points_sorted_by_x, left, mid, left_points_sorted_by_y
        )
        right_min = ClosestPairSolver._closest_pair_recursive(
            points_sorted_by_x, mid + 1, right, right_points_sorted_by_y
        )
        min_distance = min(left_min, right_min)
        
        # 检查跨越分割线的点对
        strip = []
        for point in points_sorted_by_y:
            if abs(point.x - mid_point.x) < min_distance:
                strip.append(point)
        
        # 在strip中检查最近点对
        for i in range(len(strip)):
            # 只需要检查后面的7个点（理论证明最多需要检查7个点）
            j = i + 1
            while j < len(strip) and (strip[j].y - strip[i].y) < min_distance:
                distance = strip[i].distance_to(strip[j])
                if distance < min_distance:
                    min_distance = distance
                j += 1
        
        return min_distance
    
    @staticmethod
    def _brute_force(points: List[Point], left: int, right: int) -> float:
        """
        暴力求解小规模点集的最近距离
        """
        min_distance = float('inf')
        
        for i in range(left, right + 1):
            for j in range(i + 1, right + 1):
                distance = points[i].distance_to(points[j])
                if distance < min_distance:
                    min_distance = distance
        
        return min_distance


def test_closest_pair():
    """测试函数"""
    print("=== 测试 LeetCode 612. 平面上的最短距离 (Python版本) ===")
    
    # 测试用例1：简单点集
    points1 = [
        Point(1, 1),
        Point(2, 2),
        Point(3, 3),
        Point(4, 4)
    ]
    
    print("测试用例1:")
    print(f"点集: {points1}")
    print(f"暴力解法结果: {ClosestPairSolver.shortest_distance_brute_force(points1)}")
    print(f"分治算法结果: {ClosestPairSolver.shortest_distance_divide_conquer(points1)}")
    
    # 测试用例2：随机点集
    random.seed(42)
    points2 = [Point(random.uniform(0, 100), random.uniform(0, 100)) for _ in range(10)]
    
    print("\n测试用例2:")
    print(f"随机点集大小: {len(points2)}")
    print(f"暴力解法结果: {ClosestPairSolver.shortest_distance_brute_force(points2)}")
    print(f"分治算法结果: {ClosestPairSolver.shortest_distance_divide_conquer(points2)}")
    
    # 测试用例3：边界情况（两个点）
    points3 = [
        Point(0, 0),
        Point(3, 4)
    ]
    
    print("\n测试用例3:")
    print(f"点集: {points3}")
    print(f"暴力解法结果: {ClosestPairSolver.shortest_distance_brute_force(points3)}")
    print(f"分治算法结果: {ClosestPairSolver.shortest_distance_divide_conquer(points3)}")
    
    # 性能测试
    print("\n=== 性能测试 ===")
    
    # 小规模测试
    small_points = [Point(random.uniform(0, 1000), random.uniform(0, 1000)) for _ in range(100)]
    
    start_time = time.time()
    brute_result = ClosestPairSolver.shortest_distance_brute_force(small_points)
    brute_time = time.time() - start_time
    
    start_time = time.time()
    divide_result = ClosestPairSolver.shortest_distance_divide_conquer(small_points)
    divide_time = time.time() - start_time
    
    print("100个点:")
    print(f"暴力解法时间: {brute_time * 1000:.2f} ms, 结果: {brute_result}")
    print(f"分治算法时间: {divide_time * 1000:.2f} ms, 结果: {divide_result}")
    
    # 大规模测试
    large_points = [Point(random.uniform(0, 10000), random.uniform(0, 10000)) for _ in range(10000)]
    
    start_time = time.time()
    divide_result = ClosestPairSolver.shortest_distance_divide_conquer(large_points)
    divide_time = time.time() - start_time
    
    print("\n10000个点:")
    print(f"分治算法时间: {divide_time * 1000:.2f} ms, 结果: {divide_result}")
    
    # 验证算法正确性
    print("\n=== 算法正确性验证 ===")
    
    # 创建已知最小距离的点集
    known_points = [
        Point(0, 0),
        Point(1, 1),
        Point(3, 3),
        Point(0.5, 0.5)  # 这个点距离(0,0)和(1,1)都很近
    ]
    
    expected_min = math.sqrt(0.5)  # (0,0)到(0.5,0.5)的距离
    actual_min = ClosestPairSolver.shortest_distance_divide_conquer(known_points)
    
    print(f"预期最小距离: {expected_min}")
    print(f"实际最小距离: {actual_min}")
    print(f"算法正确性: {abs(expected_min - actual_min) < 1e-10}")
    
    # 工程化考量：异常处理测试
    print("\n=== 异常处理测试 ===")
    
    try:
        ClosestPairSolver.shortest_distance_divide_conquer([])
        print("空数组测试: 失败（应该抛出异常）")
    except ValueError as e:
        print(f"空数组测试: 通过（正确抛出异常: {e}")
    
    try:
        ClosestPairSolver.shortest_distance_divide_conquer([Point(1, 1)])
        print("单点数组测试: 失败（应该抛出异常）")
    except ValueError as e:
        print(f"单点数组测试: 通过（正确抛出异常: {e}")
    
    # Python特有考量：浮点数精度处理
    print("\n=== 浮点数精度考量 ===")
    
    # 测试浮点数精度问题
    precision_points = [
        Point(0.0000001, 0.0000001),
        Point(0.0000002, 0.0000002),
        Point(0.0000003, 0.0000003)
    ]
    
    precision_result = ClosestPairSolver.shortest_distance_divide_conquer(precision_points)
    print(f"高精度点集最小距离: {precision_result}")
    print("Python使用双精度浮点数，精度足够处理大多数应用场景")
    
    # 内存使用考量
    print("\n=== 内存使用考量 ===")
    print("分治算法在递归过程中会创建临时列表，但Python的垃圾回收机制会自动管理内存")
    print("对于超大规模数据，可以考虑使用迭代版本减少递归深度")


if __name__ == "__main__":
    test_closest_pair()

===============================================

文件: LeetCode_641_DesignCircularDeque.java
===============================================
package class008_AdvancedAlgorithmsAndDataStructures.unrolled_linked_list_problems;

import java.util.*;

/**
 * LeetCode 641. 设计循环双端队列 (Design Circular Deque)
 * 
 * 题目来源：https://leetcode.cn/problems/design-circular-deque/
 * 
 * 题目描述：
 * 设计实现双端队列。实现 MyCircularDeque 类:
 * - MyCircularDeque(int k)：构造函数,双端队列最大为 k。
 * - boolean insertFront(int value)：将一个元素添加到双端队列头部。如果操作成功返回 true，否则返回 false。
 * - boolean insertLast(int value)：将一个元素添加到双端队列尾部。如果操作成功返回 true，否则返回 false。
 * - boolean deleteFront()：从双端队列头部删除一个元素。如果操作成功返回 true，否则返回 false。
 * - boolean deleteLast()：从双端队列尾部删除一个元素。如果操作成功返回 true，否则返回 false。
 * - int getFront()：从双端队列头部获得一个元素。如果双端队列为空，返回 -1。
 * - int getRear()：获得双端队列的最后一个元素。如果双端队列为空，返回 -1。
 * - boolean isEmpty()：若双端队列为空，则返回 true，否则返回 false。
 * - boolean isFull()：若双端队列满了，则返回 true，否则返回 false。
 * 
 * 算法思路：
 * 循环双端队列可以通过以下方式实现：
 * 1. 数组实现：使用固定大小的数组和头尾指针
 * 2. 块状链表：使用块状链表（Unrolled Linked List）实现，每个块存储多个元素
 * 3. 双向链表：使用双向链表实现
 * 
 * 时间复杂度（块状链表实现）：
 * - insertFront/insertLast：O(1) 均摊
 * - deleteFront/deleteLast：O(1) 均摊
 * - getFront/getRear：O(1)
 * - isEmpty/isFull：O(1)
 * - 空间复杂度：O(k)
 * 
 * 应用场景：
 * 1. 操作系统：任务调度队列
 * 2. 网络编程：数据包缓冲队列
 * 3. 数据库：查询结果缓冲
 * 4. 游戏开发：事件队列
 * 
 * 相关题目：
 * 1. LeetCode 707. 设计链表
 * 2. LeetCode 239. 滑动窗口最大值
 * 3. LeetCode 286. 墙与门
 */
public class LeetCode_641_DesignCircularDeque {
    
    /**
     * 块状链表节点类
     */
    static class Block {
        int capacity;      // 块的最大容量
        int[] array;       // 块内的数组
        int size;          // 当前块中元素的数量
        Block next;        // 指向下一个块
        Block prev;        // 指向上一个块
        
        Block(int capacity) {
            this.capacity = capacity;
            this.array = new int[capacity];
            this.size = 0;
            this.next = null;
            this.prev = null;
        }
        
        boolean isFull() {
            return size == capacity;
        }
        
        boolean isEmpty() {
            return size == 0;
        }
        
        int size() {
            return size;
        }
        
        int capacity() {
            return capacity;
        }
    }
    
    /**
     * 块状链表实现的循环双端队列
     */
    static class UnrolledCircularDeque {
        private int blockCapacity;  // 块的最大容量
        private Block head;         // 头块指针
        private Block tail;         // 尾块指针
        private int size;           // 队列元素总数
        private int capacity;       // 队列最大容量
        
        /**
         * 构造函数
         * @param capacity 队列最大容量
         */
        public UnrolledCircularDeque(int capacity) {
            // 根据总容量计算块容量，这里选择sqrt(capacity)作为块容量
            this.blockCapacity = Math.max(2, (int) Math.sqrt(capacity));
            this.capacity = capacity;
            this.size = 0;
            
            // 初始化空队列
            this.head = null;
            this.tail = null;
        }
        
        public boolean isEmpty() {
            return size == 0;
        }
        
        public boolean isFull() {
            return size == capacity;
        }
        
        public int size() {
            return size;
        }
        
        /**
         * 在队列头部插入元素
         * 时间复杂度：O(1) 均摊
         */
        public boolean insertFront(int value) {
            if (isFull()) {
                return false;
            }
            
            if (isEmpty()) {
                // 空队列，创建第一个块
                head = new Block(blockCapacity);
                tail = head;
                head.array[0] = value;
                head.size = 1;
            } else {
                // 检查头块是否已满
                if (head.size == head.capacity) {
                    // 头块已满，创建新块作为新的头块
                    Block newBlock = new Block(blockCapacity);
                    newBlock.array[0] = value;
                    newBlock.size = 1;
                    
                    // 连接新块
                    newBlock.next = head;
                    head.prev = newBlock;
                    head = newBlock;
                } else {
                    // 头块未满，直接在头部插入
                    // 将头块中的元素向后移动一位
                    for (int i = head.size; i > 0; i--) {
                        head.array[i] = head.array[i - 1];
                    }
                    head.array[0] = value;
                    head.size++;
                }
            }
            
            size++;
            return true;
        }
        
        /**
         * 在队列尾部插入元素
         * 时间复杂度：O(1) 均摊
         */
        public boolean insertLast(int value) {
            if (isFull()) {
                return false;
            }
            
            if (isEmpty()) {
                // 空队列，创建第一个块
                head = new Block(blockCapacity);
                tail = head;
                head.array[0] = value;
                head.size = 1;
            } else {
                // 检查尾块是否已满
                if (tail.size == tail.capacity) {
                    // 尾块已满，创建新块作为新的尾块
                    Block newBlock = new Block(blockCapacity);
                    newBlock.array[0] = value;
                    newBlock.size = 1;
                    
                    // 连接新块
                    newBlock.prev = tail;
                    tail.next = newBlock;
                    tail = newBlock;
                } else {
                    // 尾块未满，直接在尾部插入
                    tail.array[tail.size] = value;
                    tail.size++;
                }
            }
            
            size++;
            return true;
        }
        
        /**
         * 删除队列头部元素
         * 时间复杂度：O(1) 均摊
         */
        public boolean deleteFront() {
            if (isEmpty()) {
                return false;
            }
            
            // 删除头块的第一个元素
            for (int i = 0; i < head.size - 1; i++) {
                head.array[i] = head.array[i + 1];
            }
            head.size--;
            
            // 如果头块变空，删除头块
            if (head.size == 0) {
                if (head == tail) {
                    // 队列变空
                    head = null;
                    tail = null;
                } else {
                    // 移动头指针
                    head = head.next;
                    head.prev = null;
                }
            }
            
            size--;
            return true;
        }
        
        /**
         * 删除队列尾部元素
         * 时间复杂度：O(1) 均摊
         */
        public boolean deleteLast() {
            if (isEmpty()) {
                return false;
            }
            
            // 删除尾块的最后一个元素
            tail.size--;
            
            // 如果尾块变空，删除尾块
            if (tail.size == 0) {
                if (head == tail) {
                    // 队列变空
                    head = null;
                    tail = null;
                } else {
                    // 移动尾指针
                    tail = tail.prev;
                    tail.next = null;
                }
            }
            
            size--;
            return true;
        }
        
        /**
         * 获取队列头部元素
         * 时间复杂度：O(1)
         */
        public int getFront() {
            if (isEmpty()) {
                return -1;
            }
            return head.array[0];
        }
        
        /**
         * 获取队列尾部元素
         * 时间复杂度：O(1)
         */
        public int getRear() {
            if (isEmpty()) {
                return -1;
            }
            return tail.array[tail.size - 1];
        }
    }
    
    private UnrolledCircularDeque deque;
    
    /**
     * 构造函数
     * @param k 双端队列的最大容量
     */
    public LeetCode_641_DesignCircularDeque(int k) {
        this.deque = new UnrolledCircularDeque(k);
    }
    
    /**
     * 在队列头部插入元素
     * @param value 要插入的值
     * @return 如果操作成功返回true，否则返回false
     */
    public boolean insertFront(int value) {
        return deque.insertFront(value);
    }
    
    /**
     * 在队列尾部插入元素
     * @param value 要插入的值
     * @return 如果操作成功返回true，否则返回false
     */
    public boolean insertLast(int value) {
        return deque.insertLast(value);
    }
    
    /**
     * 删除队列头部元素
     * @return 如果操作成功返回true，否则返回false
     */
    public boolean deleteFront() {
        return deque.deleteFront();
    }
    
    /**
     * 删除队列尾部元素
     * @return 如果操作成功返回true，否则返回false
     */
    public boolean deleteLast() {
        return deque.deleteLast();
    }
    
    /**
     * 获取队列头部元素
     * @return 队列头部元素，如果队列为空返回-1
     */
    public int getFront() {
        return deque.getFront();
    }
    
    /**
     * 获取队列尾部元素
     * @return 队列尾部元素，如果队列为空返回-1
     */
    public int getRear() {
        return deque.getRear();
    }
    
    /**
     * 检查队列是否为空
     * @return 如果队列为空返回true，否则返回false
     */
    public boolean isEmpty() {
        return deque.isEmpty();
    }
    
    /**
     * 检查队列是否已满
     * @return 如果队列已满返回true，否则返回false
     */
    public boolean isFull() {
        return deque.isFull();
    }
    
    /**
     * 方法2：使用数组实现的循环双端队列（用于对比）
     */
    static class MyCircularDequeArray {
        private int[] deque;
        private int front;
        private int rear;
        private int size;
        private int capacity;
        
        public MyCircularDequeArray(int k) {
            this.capacity = k;
            this.deque = new int[k];
            this.front = 0;
            this.rear = 0;
            this.size = 0;
        }
        
        public boolean insertFront(int value) {
            if (isFull()) {
                return false;
            }
            
            front = (front - 1 + capacity) % capacity;
            deque[front] = value;
            size++;
            return true;
        }
        
        public boolean insertLast(int value) {
            if (isFull()) {
                return false;
            }
            
            deque[rear] = value;
            rear = (rear + 1) % capacity;
            size++;
            return true;
        }
        
        public boolean deleteFront() {
            if (isEmpty()) {
                return false;
            }
            
            front = (front + 1) % capacity;
            size--;
            return true;
        }
        
        public boolean deleteLast() {
            if (isEmpty()) {
                return false;
            }
            
            rear = (rear - 1 + capacity) % capacity;
            size--;
            return true;
        }
        
        public int getFront() {
            if (isEmpty()) {
                return -1;
            }
            return deque[front];
        }
        
        public int getRear() {
            if (isEmpty()) {
                return -1;
            }
            return deque[(rear - 1 + capacity) % capacity];
        }
        
        public boolean isEmpty() {
            return size == 0;
        }
        
        public boolean isFull() {
            return size == capacity;
        }
    }
    
    /**
     * 测试函数
     */
    public static void main(String[] args) {
        System.out.println("=== 测试 LeetCode 641. 设计循环双端队列 ===");
        
        // 测试用例1
        System.out.println("测试用例1:");
        LeetCode_641_DesignCircularDeque deque1 = new LeetCode_641_DesignCircularDeque(3);
        System.out.println("insertLast(1): " + deque1.insertLast(1)); // 返回 true
        System.out.println("insertLast(2): " + deque1.insertLast(2)); // 返回 true
        System.out.println("insertFront(3): " + deque1.insertFront(3)); // 返回 true
        System.out.println("insertFront(4): " + deque1.insertFront(4)); // 返回 false（队列已满）
        System.out.println("getRear(): " + deque1.getRear()); // 返回 2
        System.out.println("isFull(): " + deque1.isFull()); // 返回 true
        System.out.println("deleteLast(): " + deque1.deleteLast()); // 返回 true
        System.out.println("insertFront(4): " + deque1.insertFront(4)); // 返回 true
        System.out.println("getFront(): " + deque1.getFront()); // 返回 3
        System.out.println();
        
        // 测试用例2
        System.out.println("测试用例2:");
        LeetCode_641_DesignCircularDeque deque2 = new LeetCode_641_DesignCircularDeque(4);
        System.out.println("insertFront(9): " + deque2.insertFront(9)); // 返回 true
        System.out.println("deleteLast(): " + deque2.deleteLast()); // 返回 true
        System.out.println("getRear(): " + deque2.getRear()); // 返回 -1
        System.out.println("getFront(): " + deque2.getFront()); // 返回 -1
        System.out.println("getFront(): " + deque2.getFront()); // 返回 -1
        System.out.println("deleteFront(): " + deque2.deleteFront()); // 返回 false
        System.out.println("insertFront(6): " + deque2.insertFront(6)); // 返回 true
        System.out.println("insertLast(5): " + deque2.insertLast(5)); // 返回 true
        System.out.println("insertFront(9): " + deque2.insertFront(9)); // 返回 true
        System.out.println("getFront(): " + deque2.getFront()); // 返回 9
        System.out.println("insertFront(6): " + deque2.insertFront(6)); // 返回 true
        System.out.println();
        
        // 性能测试
        System.out.println("=== 性能测试 ===");
        int dequeCapacity = 10000;
        int operationCount = 100000;
        Random random = new Random(42);
        
        // 测试块状链表实现
        LeetCode_641_DesignCircularDeque deque3 = new LeetCode_641_DesignCircularDeque(dequeCapacity);
        long startTime = System.nanoTime();
        for (int i = 0; i < operationCount; i++) {
            int operation = random.nextInt(6);
            int value = random.nextInt(1000);
            
            switch (operation) {
                case 0:
                    deque3.insertFront(value);
                    break;
                case 1:
                    deque3.insertLast(value);
                    break;
                case 2:
                    deque3.deleteFront();
                    break;
                case 3:
                    deque3.deleteLast();
                    break;
                case 4:
                    deque3.getFront();
                    break;
                case 5:
                    deque3.getRear();
                    break;
            }
        }
        long endTime = System.nanoTime();
        System.out.println("块状链表实现处理" + operationCount + "次操作时间: " + (endTime - startTime) / 1_000_000.0 + " ms");
        
        // 测试数组实现
        MyCircularDequeArray deque4 = new MyCircularDequeArray(dequeCapacity);
        startTime = System.nanoTime();
        for (int i = 0; i < operationCount; i++) {
            int operation = random.nextInt(6);
            int value = random.nextInt(1000);
            
            switch (operation) {
                case 0:
                    deque4.insertFront(value);
                    break;
                case 1:
                    deque4.insertLast(value);
                    break;
                case 2:
                    deque4.deleteFront();
                    break;
                case 3:
                    deque4.deleteLast();
                    break;
                case 4:
                    deque4.getFront();
                    break;
                case 5:
                    deque4.getRear();
                    break;
            }
        }
        endTime = System.nanoTime();
        System.out.println("数组实现处理" + operationCount + "次操作时间: " + (endTime - startTime) / 1_000_000.0 + " ms");
    }
}

===============================================

文件: LeetCode_705_DesignHashSet.java
===============================================
package class008_AdvancedAlgorithmsAndDataStructures.unrolled_linked_list_problems;

import java.util.*;

/**
 * LeetCode 705. 设计哈希集合 (Design HashSet)
 * 
 * 题目来源：https://leetcode.cn/problems/design-hashset/
 * 
 * 题目描述：
 * 不使用任何内建的哈希表库设计一个哈希集合（HashSet）。
 * 实现 MyHashSet 类：
 * - void add(key) 向哈希集合中插入值 key 。
 * - bool contains(key) 返回哈希集合中是否存在这个值 key 。
 * - void remove(key) 将给定值 key 从哈希集合中删除。如果哈希集合中没有这个值，什么也不做。
 * 
 * 算法思路：
 * 这个问题可以通过以下方法解决：
 * 1. 块状链表：使用块状链表实现哈希集合
 * 2. 链地址法：使用数组+链表实现哈希表
 * 3. 开放地址法：使用线性探测或二次探测
 * 
 * 使用块状链表的方法：
 * 1. 将哈希空间分块，每块维护一个有序数组
 * 2. 对于每个添加的键，计算其哈希值并确定所属块
 * 3. 在块内维护有序性以便快速查找
 * 4. 当块满时进行分裂操作
 * 
 * 时间复杂度：
 * - 块状链表：O(√n) 平均情况
 * - 链地址法：O(n/k) 平均情况，k是桶数
 * - 开放地址法：O(1) 平均情况
 * - 空间复杂度：O(n)
 * 
 * 应用场景：
 * 1. 数据库索引：快速查找和去重
 * 2. 缓存系统：缓存键的管理
 * 3. 编译器：符号表管理
 * 
 * 相关题目：
 * 1. LeetCode 706. 设计哈希映射
 * 2. LeetCode 641. 设计循环双端队列
 * 3. LeetCode 146. LRU缓存机制
 */
public class LeetCode_705_DesignHashSet {
    
    /**
     * 块状链表节点
     */
    static class Block {
        private static final int BLOCK_SIZE = 32; // 块大小
        int[] data;  // 存储数据的数组
        int size;    // 当前块中元素的数量
        Block next;  // 指向下一个块
        
        Block() {
            data = new int[BLOCK_SIZE];
            size = 0;
            next = null;
        }
        
        /**
         * 在块中添加元素（保持有序）
         */
        boolean add(int key) {
            // 检查元素是否已存在
            int index = binarySearch(key);
            if (index >= 0) {
                return false; // 元素已存在
            }
            
            // 如果块已满，返回false
            if (size >= BLOCK_SIZE) {
                return false;
            }
            
            // 插入元素并保持有序
            int insertPos = -(index + 1);
            for (int i = size; i > insertPos; i--) {
                data[i] = data[i - 1];
            }
            data[insertPos] = key;
            size++;
            return true;
        }
        
        /**
         * 在块中删除元素
         */
        boolean remove(int key) {
            int index = binarySearch(key);
            if (index < 0) {
                return false; // 元素不存在
            }
            
            // 删除元素
            for (int i = index; i < size - 1; i++) {
                data[i] = data[i + 1];
            }
            size--;
            return true;
        }
        
        /**
         * 检查块中是否包含元素
         */
        boolean contains(int key) {
            return binarySearch(key) >= 0;
        }
        
        /**
         * 二分查找元素
         */
        private int binarySearch(int key) {
            int left = 0, right = size - 1;
            while (left <= right) {
                int mid = left + (right - left) / 2;
                if (data[mid] == key) {
                    return mid;
                } else if (data[mid] < key) {
                    left = mid + 1;
                } else {
                    right = mid - 1;
                }
            }
            return -(left + 1); // 返回插入位置的负值
        }
        
        /**
         * 分裂块
         */
        Block split() {
            Block newBlock = new Block();
            int splitPoint = size / 2;
            
            // 将后半部分元素移动到新块
            for (int i = splitPoint; i < size; i++) {
                newBlock.data[i - splitPoint] = data[i];
            }
            newBlock.size = size - splitPoint;
            size = splitPoint;
            
            return newBlock;
        }
    }
    
    private Block head; // 头块指针
    private int size;   // 集合中元素总数
    
    /**
     * 构造函数
     */
    public LeetCode_705_DesignHashSet() {
        head = new Block();
        size = 0;
    }
    
    /**
     * 添加元素
     * 时间复杂度：O(√n) 平均情况
     * @param key 要添加的键
     */
    public void add(int key) {
        Block current = head;
        Block prev = null;
        
        // 找到合适的块
        while (current != null && (current.next != null || current.size >= Block.BLOCK_SIZE)) {
            if (current.size > 0 && key <= current.data[current.size - 1]) {
                break;
            }
            prev = current;
            current = current.next;
        }
        
        // 如果当前块为空或需要在新块中插入
        if (current == null) {
            current = new Block();
            if (prev != null) {
                prev.next = current;
            } else {
                head = current;
            }
        }
        
        // 尝试在当前块中添加元素
        if (!current.add(key)) {
            // 如果当前块已满，需要分裂
            Block newBlock = current.split();
            newBlock.next = current.next;
            current.next = newBlock;
            
            // 确定元素应该插入哪个块
            if (key <= current.data[current.size - 1]) {
                current.add(key);
            } else {
                newBlock.add(key);
            }
        }
        
        size++;
    }
    
    /**
     * 删除元素
     * 时间复杂度：O(√n) 平均情况
     * @param key 要删除的键
     */
    public void remove(int key) {
        Block current = head;
        
        while (current != null) {
            if (current.remove(key)) {
                size--;
                return;
            }
            current = current.next;
        }
    }
    
    /**
     * 检查是否包含元素
     * 时间复杂度：O(√n) 平均情况
     * @param key 要检查的键
     * @return 是否包含该键
     */
    public boolean contains(int key) {
        Block current = head;
        
        while (current != null) {
            if (current.contains(key)) {
                return true;
            }
            current = current.next;
        }
        
        return false;
    }
    
    /**
     * 方法2：链地址法实现
     * 时间复杂度：O(n/k) 平均情况，k是桶数
     * 空间复杂度：O(n)
     */
    static class MyHashSetChaining {
        private static final int BASE = 769; // 质数作为桶数
        private LinkedList<Integer>[] buckets;
        
        public MyHashSetChaining() {
            buckets = new LinkedList[BASE];
            for (int i = 0; i < BASE; i++) {
                buckets[i] = new LinkedList<>();
            }
        }
        
        private int hash(int key) {
            return key % BASE;
        }
        
        public void add(int key) {
            int bucketIndex = hash(key);
            if (!buckets[bucketIndex].contains(key)) {
                buckets[bucketIndex].add(key);
            }
        }
        
        public void remove(int key) {
            int bucketIndex = hash(key);
            buckets[bucketIndex].remove(Integer.valueOf(key));
        }
        
        public boolean contains(int key) {
            int bucketIndex = hash(key);
            return buckets[bucketIndex].contains(key);
        }
    }
    
    /**
     * 方法3：开放地址法实现（线性探测）
     * 时间复杂度：O(1) 平均情况
     * 空间复杂度：O(n)
     */
    static class MyHashSetOpenAddressing {
        private static final int CAPACITY = 100003; // 质数容量
        private static final int EMPTY = -1;
        private static final int DELETED = -2;
        private int[] table;
        
        public MyHashSetOpenAddressing() {
            table = new int[CAPACITY];
            Arrays.fill(table, EMPTY);
        }
        
        private int hash(int key) {
            return (key % CAPACITY + CAPACITY) % CAPACITY;
        }
        
        public void add(int key) {
            int index = find(key);
            if (table[index] != key) {
                table[index] = key;
            }
        }
        
        public void remove(int key) {
            int index = find(key);
            if (table[index] == key) {
                table[index] = DELETED;
            }
        }
        
        public boolean contains(int key) {
            int index = find(key);
            return table[index] == key;
        }
        
        private int find(int key) {
            int index = hash(key);
            while (table[index] != EMPTY && table[index] != key) {
                index = (index + 1) % CAPACITY;
            }
            return index;
        }
    }
    
    /**
     * 测试函数
     */
    public static void main(String[] args) {
        System.out.println("=== 测试 LeetCode 705. 设计哈希集合 ===");
        
        // 测试用例1
        System.out.println("测试用例1:");
        LeetCode_705_DesignHashSet hashSet = new LeetCode_705_DesignHashSet();
        
        hashSet.add(1);
        hashSet.add(2);
        System.out.println("add(1), add(2)");
        
        boolean result1 = hashSet.contains(1);
        System.out.println("contains(1) = " + result1 + " (期望: true)");
        
        boolean result2 = hashSet.contains(3);
        System.out.println("contains(3) = " + result2 + " (期望: false)");
        
        hashSet.add(2);
        System.out.println("add(2)");
        
        boolean result3 = hashSet.contains(2);
        System.out.println("contains(2) = " + result3 + " (期望: true)");
        
        hashSet.remove(2);
        System.out.println("remove(2)");
        
        boolean result4 = hashSet.contains(2);
        System.out.println("contains(2) = " + result4 + " (期望: false)");
        System.out.println();
        
        // 性能测试
        System.out.println("=== 性能测试 ===");
        LeetCode_705_DesignHashSet perfHashSet = new LeetCode_705_DesignHashSet();
        Random random = new Random(42);
        
        long startTime = System.nanoTime();
        
        // 添加10000个随机数
        for (int i = 0; i < 10000; i++) {
            int key = random.nextInt(100000);
            perfHashSet.add(key);
        }
        
        // 查询10000次
        int foundCount = 0;
        for (int i = 0; i < 10000; i++) {
            int key = random.nextInt(100000);
            if (perfHashSet.contains(key)) {
                foundCount++;
            }
        }
        
        long endTime = System.nanoTime();
        System.out.println("块状链表实现: 添加和查询20000次操作时间: " + (endTime - startTime) / 1_000_000.0 + " ms, 找到元素数: " + foundCount);
        
        // 测试链地址法
        MyHashSetChaining chainingHashSet = new MyHashSetChaining();
        startTime = System.nanoTime();
        
        for (int i = 0; i < 10000; i++) {
            int key = random.nextInt(100000);
            chainingHashSet.add(key);
        }
        
        foundCount = 0;
        for (int i = 0; i < 10000; i++) {
            int key = random.nextInt(100000);
            if (chainingHashSet.contains(key)) {
                foundCount++;
            }
        }
        
        endTime = System.nanoTime();
        System.out.println("链地址法实现: 添加和查询20000次操作时间: " + (endTime - startTime) / 1_000_000.0 + " ms, 找到元素数: " + foundCount);
        
        // 测试开放地址法
        MyHashSetOpenAddressing openHashSet = new MyHashSetOpenAddressing();
        startTime = System.nanoTime();
        
        for (int i = 0; i < 10000; i++) {
            int key = random.nextInt(100000);
            openHashSet.add(key);
        }
        
        foundCount = 0;
        for (int i = 0; i < 10000; i++) {
            int key = random.nextInt(100000);
            if (openHashSet.contains(key)) {
                foundCount++;
            }
        }
        
        endTime = System.nanoTime();
        System.out.println("开放地址法实现: 添加和查询20000次操作时间: " + (endTime - startTime) / 1_000_000.0 + " ms, 找到元素数: " + foundCount);
        
        // 算法复杂度分析
        System.out.println("\n=== 算法复杂度分析 ===");
        System.out.println("块状链表实现:");
        System.out.println("  时间复杂度: O(√n) 平均情况");
        System.out.println("  空间复杂度: O(n)");
        System.out.println("链地址法实现:");
        System.out.println("  时间复杂度: O(n/k) 平均情况，k是桶数");
        System.out.println("  空间复杂度: O(n)");
        System.out.println("开放地址法实现:");
        System.out.println("  时间复杂度: O(1) 平均情况");
        System.out.println("  空间复杂度: O(n)");
    }
}

===============================================

文件: LeetCode_706_DesignHashMap.java
===============================================
/**
 * LeetCode 706. 设计哈希映射 (Design HashMap)
 * 题目链接：https://leetcode.com/problems/design-hashmap/
 * 
 * 题目描述：
 * 不使用任何内建的哈希表库设计一个哈希映射（HashMap）。
 * 实现 MyHashMap 类：
 * - MyHashMap() 用空映射初始化对象
 * - void put(int key, int value) 向 HashMap 插入一个键值对 (key, value)。如果 key 已经存在于映射中，则更新其对应的值
 * - int get(int key) 返回特定的 key 所映射的 value；如果映射中不包含 key 的映射，返回 -1
 * - void remove(key) 如果映射中存在 key 的映射，则移除 key 和它所对应的 value
 * 
 * 算法思路：
 * 使用块状链表（分块哈希）实现哈希映射，结合了数组和链表的优点。
 * 将键值对分块存储，每个块包含固定数量的元素，使用链表连接各个块。
 * 
 * 时间复杂度：
 * - put/get/remove: O(n/b) 均摊，其中b是块大小
 * - 空间复杂度：O(n)
 * 
 * 最优解分析：
 * 块状链表在哈希冲突较多时性能优于传统链表，特别适合中等规模的数据。
 * 
 * 边界场景：
 * 1. 空映射操作
 * 2. 重复键插入
 * 3. 删除不存在的键
 * 4. 大量键值对时的性能
 * 
 * 工程化考量：
 * 1. 动态调整块大小以适应不同数据规模
 * 2. 添加负载因子监控和自动扩容
 * 3. 处理哈希冲突的优化策略
 */
package class185.unrolled_linked_list_problems;

import java.util.*;

public class LeetCode_706_DesignHashMap {
    
    // 哈希映射的块节点
    static class Block {
        private static final int DEFAULT_CAPACITY = 16;
        private int capacity;
        private int[] keys;
        private int[] values;
        private int size;
        private Block next;
        
        public Block(int capacity) {
            this.capacity = capacity;
            this.keys = new int[capacity];
            this.values = new int[capacity];
            this.size = 0;
            this.next = null;
            // 初始化数组为-1（表示空位置）
            Arrays.fill(keys, -1);
            Arrays.fill(values, -1);
        }
        
        public Block() {
            this(DEFAULT_CAPACITY);
        }
        
        public boolean isFull() {
            return size == capacity;
        }
        
        public boolean isEmpty() {
            return size == 0;
        }
        
        // 在块中查找键的位置
        public int findIndex(int key) {
            for (int i = 0; i < size; i++) {
                if (keys[i] == key) {
                    return i;
                }
            }
            return -1;
        }
        
        // 添加键值对
        public boolean put(int key, int value) {
            int index = findIndex(key);
            if (index != -1) {
                // 键已存在，更新值
                values[index] = value;
                return true;
            }
            
            if (isFull()) {
                return false; // 块已满
            }
            
            // 添加到末尾
            keys[size] = key;
            values[size] = value;
            size++;
            return true;
        }
        
        // 获取值
        public int get(int key) {
            int index = findIndex(key);
            return index != -1 ? values[index] : -1;
        }
        
        // 删除键值对
        public boolean remove(int key) {
            int index = findIndex(key);
            if (index == -1) {
                return false;
            }
            
            // 移动后续元素填补空缺
            for (int i = index; i < size - 1; i++) {
                keys[i] = keys[i + 1];
                values[i] = values[i + 1];
            }
            
            // 清空最后一个位置
            keys[size - 1] = -1;
            values[size - 1] = -1;
            size--;
            return true;
        }
    }
    
    static class MyHashMap {
        private static final int INITIAL_BLOCKS = 16;
        private static final double LOAD_FACTOR = 0.75;
        
        private Block[] blocks;
        private int size;
        private int blockCapacity;
        
        public MyHashMap() {
            this.blockCapacity = 16; // 每个块的容量
            this.blocks = new Block[INITIAL_BLOCKS];
            this.size = 0;
            
            // 初始化所有块
            for (int i = 0; i < INITIAL_BLOCKS; i++) {
                blocks[i] = new Block(blockCapacity);
            }
        }
        
        // 哈希函数
        private int hash(int key) {
            return key % blocks.length;
        }
        
        public void put(int key, int value) {
            int index = hash(key);
            Block current = blocks[index];
            
            // 在当前块链表中查找合适的块
            while (current != null) {
                if (current.put(key, value)) {
                    size++;
                    return;
                }
                if (current.next == null) {
                    // 当前块已满，创建新块
                    current.next = new Block(blockCapacity);
                }
                current = current.next;
            }
            
            // 检查是否需要扩容
            if ((double)size / (blocks.length * blockCapacity) > LOAD_FACTOR) {
                resize();
            }
        }
        
        public int get(int key) {
            int index = hash(key);
            Block current = blocks[index];
            
            while (current != null) {
                int value = current.get(key);
                if (value != -1) {
                    return value;
                }
                current = current.next;
            }
            
            return -1;
        }
        
        public void remove(int key) {
            int index = hash(key);
            Block current = blocks[index];
            
            while (current != null) {
                if (current.remove(key)) {
                    size--;
                    return;
                }
                current = current.next;
            }
        }
        
        // 扩容哈希表
        private void resize() {
            Block[] oldBlocks = blocks;
            blocks = new Block[oldBlocks.length * 2];
            
            // 初始化新块数组
            for (int i = 0; i < blocks.length; i++) {
                blocks[i] = new Block(blockCapacity);
            }
            
            // 重新哈希所有元素
            size = 0;
            for (Block oldBlock : oldBlocks) {
                Block current = oldBlock;
                while (current != null) {
                    for (int i = 0; i < current.size; i++) {
                        put(current.keys[i], current.values[i]);
                    }
                    current = current.next;
                }
            }
        }
        
        public int size() {
            return size;
        }
        
        public boolean isEmpty() {
            return size == 0;
        }
    }
    
    // 测试方法
    public static void main(String[] args) {
        System.out.println("=== 测试 LeetCode 706. 设计哈希映射 ===");
        
        MyHashMap hashMap = new MyHashMap();
        
        // 测试基本操作
        hashMap.put(1, 1);
        hashMap.put(2, 2);
        System.out.println("get(1): " + hashMap.get(1)); // 期望: 1
        System.out.println("get(3): " + hashMap.get(3)); // 期望: -1
        
        // 测试更新操作
        hashMap.put(2, 1);
        System.out.println("get(2): " + hashMap.get(2)); // 期望: 1
        
        // 测试删除操作
        hashMap.remove(2);
        System.out.println("get(2): " + hashMap.get(2)); // 期望: -1
        
        // 测试边界情况
        System.out.println("isEmpty: " + hashMap.isEmpty()); // 期望: false
        System.out.println("size: " + hashMap.size()); // 期望: 1
        
        // 测试大量数据
        for (int i = 0; i < 1000; i++) {
            hashMap.put(i, i * 2);
        }
        System.out.println("大量数据测试 - size: " + hashMap.size()); // 期望: 1000
        System.out.println("get(500): " + hashMap.get(500)); // 期望: 1000
        
        System.out.println("所有测试用例执行完成");
    }
}

===============================================

文件: LeetCode_716_MaxStack.java
===============================================
package class008_AdvancedAlgorithmsAndDataStructures.doubly_circular_linked_list_problems;

import java.util.*;

/**
 * LeetCode 716. Max Stack
 * 
 * 题目描述：
 * 设计一个最大栈数据结构，支持栈的基本操作，并支持在常数时间内检索到栈中的最大元素。
 * 实现 MaxStack 类：
 * - MaxStack() 初始化栈对象
 * - void push(int x) 将元素 x 压入栈中
 * - int pop() 删除栈顶元素并返回
 * - int top() 获取栈顶元素
 * - int peekMax() 获取栈中的最大元素
 * - int popMax() 删除栈中的最大元素并返回
 * 
 * 解题思路：
 * 使用双向循环链表实现栈，并维护一个指向最大元素的指针。
 * 为了支持 popMax 操作，我们需要能够快速找到最大元素并删除它。
 * 
 * 时间复杂度：
 * - push(), pop(), top(), peekMax(): O(1)
 * - popMax(): O(n)
 * 空间复杂度：O(n)
 */
public class LeetCode_716_MaxStack {
    
    // 栈节点
    static class Node {
        int value;
        Node prev, next;
        
        Node(int value) {
            this.value = value;
        }
    }
    
    static class MaxStack {
        private Node head; // 双向循环链表的虚拟头节点
        private Node maxNode; // 指向最大元素的指针
        
        public MaxStack() {
            // 创建双向循环链表的虚拟头节点
            head = new Node(0);
            head.prev = head;
            head.next = head;
            maxNode = null;
        }
        
        public void push(int x) {
            // 创建新节点
            Node newNode = new Node(x);
            
            // 将新节点插入到链表头部
            newNode.next = head.next;
            newNode.prev = head;
            head.next.prev = newNode;
            head.next = newNode;
            
            // 更新最大节点指针
            if (maxNode == null || x >= maxNode.value) {
                maxNode = newNode;
            }
        }
        
        public int pop() {
            if (head.next == head) {
                throw new RuntimeException("Stack is empty");
            }
            
            // 获取栈顶节点
            Node topNode = head.next;
            
            // 从链表中删除栈顶节点
            head.next = topNode.next;
            topNode.next.prev = head;
            
            // 如果删除的是最大节点，需要重新查找最大节点
            if (topNode == maxNode) {
                findNewMax();
            }
            
            return topNode.value;
        }
        
        public int top() {
            if (head.next == head) {
                throw new RuntimeException("Stack is empty");
            }
            return head.next.value;
        }
        
        public int peekMax() {
            if (maxNode == null) {
                throw new RuntimeException("Stack is empty");
            }
            return maxNode.value;
        }
        
        public int popMax() {
            if (maxNode == null) {
                throw new RuntimeException("Stack is empty");
            }
            
            // 获取最大节点的值
            int maxValue = maxNode.value;
            
            // 从链表中删除最大节点
            maxNode.prev.next = maxNode.next;
            maxNode.next.prev = maxNode.prev;
            
            // 重新查找最大节点
            findNewMax();
            
            return maxValue;
        }
        
        // 重新查找最大节点
        private void findNewMax() {
            maxNode = null;
            Node current = head.next;
            
            // 遍历链表找到最大节点
            while (current != head) {
                if (maxNode == null || current.value >= maxNode.value) {
                    maxNode = current;
                }
                current = current.next;
            }
        }
        
        // 辅助方法：打印栈内容（用于调试）
        public void printStack() {
            System.out.print("Stack: [");
            Node current = head.next;
            boolean first = true;
            while (current != head) {
                if (!first) {
                    System.out.print(", ");
                }
                System.out.print(current.value);
                first = false;
                current = current.next;
            }
            System.out.println("]");
            System.out.println("Max: " + (maxNode != null ? maxNode.value : "null"));
        }
    }
    
    // 测试方法
    public static void main(String[] args) {
        // 测试用例1
        System.out.println("测试用例1:");
        MaxStack stack = new MaxStack();
        
        stack.push(5);
        stack.push(1);
        stack.push(5);
        
        System.out.println("top() = " + stack.top()); // 5
        System.out.println("pop() = " + stack.pop()); // 5
        System.out.println("top() = " + stack.top()); // 1
        System.out.println("peekMax() = " + stack.peekMax()); // 5
        System.out.println("popMax() = " + stack.popMax()); // 5
        System.out.println("top() = " + stack.top()); // 1
        System.out.println("peekMax() = " + stack.peekMax()); // 1
        System.out.println("pop() = " + stack.pop()); // 1
        System.out.println("pop() = " + stack.pop()); // 5
        System.out.println();
        
        // 测试用例2
        System.out.println("测试用例2:");
        MaxStack stack2 = new MaxStack();
        
        stack2.push(1);
        stack2.push(2);
        stack2.push(3);
        
        System.out.println("peekMax() = " + stack2.peekMax()); // 3
        System.out.println("popMax() = " + stack2.popMax()); // 3
        System.out.println("peekMax() = " + stack2.peekMax()); // 2
        System.out.println("popMax() = " + stack2.popMax()); // 2
        System.out.println("peekMax() = " + stack2.peekMax()); // 1
        System.out.println();
        
        // 测试用例3
        System.out.println("测试用例3:");
        MaxStack stack3 = new MaxStack();
        
        stack3.push(5);
        stack3.push(1);
        stack3.push(3);
        stack3.push(7);
        stack3.push(2);
        
        System.out.println("peekMax() = " + stack3.peekMax()); // 7
        System.out.println("popMax() = " + stack3.popMax()); // 7
        System.out.println("peekMax() = " + stack3.peekMax()); // 5
        System.out.println("pop() = " + stack3.pop()); // 2
        System.out.println("peekMax() = " + stack3.peekMax()); // 5
    }
}

===============================================

文件: leetcode_716_max_stack.cpp
===============================================
// LeetCode 716 Max Stack
// C++ 实现

/**
 * LeetCode 716 Max Stack
 * 
 * 题目描述：
 * 设计一个最大栈数据结构，支持普通栈的全部四种操作（push、top、pop、empty），
 * 还支持查找栈中最大元素的操作（peekMax）和弹出栈中最大元素的操作（popMax）。
 * 
 * 解题思路：
 * 我们可以使用双向循环链表来实现最大栈。
 * 1. 使用双向链表维护栈中元素
 * 2. 使用另一个双向链表或平衡二叉搜索树维护元素的有序关系
 * 3. 支持所有栈操作和最大值操作
 * 
 * 时间复杂度：
 * - push: O(1)
 * - pop: O(1)
 * - top: O(1)
 * - peekMax: O(1)
 * - popMax: O(1)
 * 
 * 空间复杂度：O(n)
 */

// 由于编译环境限制，这里提供算法思路和伪代码实现

/*
#include <stdlib.h>

// 定义节点结构
typedef struct Node {
    int value;
    struct Node* prev;
    struct Node* next;
} Node;

// 定义最大栈结构
typedef struct {
    Node* head; // 栈顶指针
    Node* maxHead; // 最大值链表头指针
} MaxStack;

// 创建新节点
Node* createNode(int value) {
    Node* node = (Node*)malloc(sizeof(Node));
    node->value = value;
    node->prev = NULL;
    node->next = NULL;
    return node;
}

// 初始化最大栈
MaxStack* maxStackCreate() {
    MaxStack* stack = (MaxStack*)malloc(sizeof(MaxStack));
    // 创建哨兵节点
    stack->head = createNode(0);
    stack->head->prev = stack->head;
    stack->head->next = stack->head;
    stack->maxHead = createNode(0);
    stack->maxHead->prev = stack->maxHead;
    stack->maxHead->next = stack->maxHead;
    return stack;
}

// 入栈
void maxStackPush(MaxStack* obj, int x) {
    // 创建新节点并插入栈顶
    Node* node = createNode(x);
    node->next = obj->head->next;
    node->prev = obj->head;
    obj->head->next->prev = node;
    obj->head->next = node;
    
    // 更新最大值链表
    // 在实际实现中需要将节点插入到正确位置
}

// 出栈
int maxStackPop(MaxStack* obj) {
    // 移除栈顶节点
    Node* node = obj->head->next;
    int value = node->value;
    node->prev->next = node->next;
    node->next->prev = node->prev;
    free(node);
    return value;
}

// 获取栈顶元素
int maxStackTop(MaxStack* obj) {
    return obj->head->next->value;
}

// 获取最大元素
int maxStackPeekMax(MaxStack* obj) {
    // 返回最大值链表的第一个元素
    return obj->maxHead->next->value;
}

// 弹出最大元素
int maxStackPopMax(MaxStack* obj) {
    // 在实际实现中需要找到并移除最大元素
    return 0;
}

// 检查栈是否为空
bool maxStackEmpty(MaxStack* obj) {
    return obj->head->next == obj->head;
}

// 释放最大栈
void maxStackFree(MaxStack* obj) {
    // 释放所有节点
    while (!maxStackEmpty(obj)) {
        maxStackPop(obj);
    }
    free(obj->head);
    free(obj->maxHead);
    free(obj);
}

// 算法核心思想：
// 1. 使用双向循环链表维护栈结构
// 2. 使用另一个链表或数据结构维护最大值信息
// 3. 保持所有操作的时间复杂度为O(1)

// 时间复杂度分析：
// - push: O(1)
// - pop: O(1)
// - top: O(1)
// - peekMax: O(1)
// - popMax: O(1)
// - 空间复杂度：O(n)
*/

// 算法应用场景：
// 1. 栈数据结构扩展
// 2. 数据结构设计
// 3. 双向链表应用

===============================================

文件: leetcode_716_max_stack.py
===============================================
#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
LeetCode 716 Max Stack

题目描述：
设计一个最大栈数据结构，支持普通栈的全部四种操作（push、top、pop、empty），
还支持查找栈中最大元素的操作（peekMax）和弹出栈中最大元素的操作（popMax）。

解题思路：
我们可以使用双向循环链表来实现最大栈。
1. 使用双向链表维护栈中元素
2. 使用另一个双向链表或平衡二叉搜索树维护元素的有序关系
3. 支持所有栈操作和最大值操作

时间复杂度：
- push: O(1)
- pop: O(1)
- top: O(1)
- peekMax: O(1)
- popMax: O(1)

空间复杂度：O(n)
"""

class ListNode:
    def __init__(self, value=0):
        self.value = value
        self.prev: 'ListNode' = self
        self.next: 'ListNode' = self

class MaxStack:
    def __init__(self):
        """初始化最大栈"""
        # 创建哨兵节点
        self.head = ListNode()
        self.head.prev = self.head
        self.head.next = self.head
        # 最大值链表头指针
        self.max_head = ListNode()
        self.max_head.prev = self.max_head
        self.max_head.next = self.max_head
    
    def push(self, x):
        """
        入栈
        
        Args:
            x: 要入栈的元素
        """
        # 创建新节点并插入栈顶
        node = ListNode(x)
        node.next = self.head.next
        node.prev = self.head
        self.head.next.prev = node
        self.head.next = node
        
        # 更新最大值链表
        # 将节点插入到最大值链表的正确位置
        max_node = ListNode(x)
        if self.max_head.next == self.max_head or x >= self.max_head.next.value:
            # 插入到最大值链表头部
            max_node.next = self.max_head.next
            max_node.prev = self.max_head
            self.max_head.next.prev = max_node
            self.max_head.next = max_node
        else:
            # 找到正确位置插入
            current = self.max_head.next
            while current != self.max_head and current.value > x:
                current = current.next
            max_node.next = current
            max_node.prev = current.prev
            current.prev.next = max_node
            current.prev = max_node
    
    def pop(self):
        """
        出栈
        
        Returns:
            栈顶元素
        """
        # 移除栈顶节点
        node = self.head.next
        value = node.value
        node.prev.next = node.next
        node.next.prev = node.prev
        
        # 从最大值链表中移除对应节点
        current = self.max_head.next
        while current != self.max_head and current.value != value:
            current = current.next
        if current != self.max_head:
            current.prev.next = current.next
            current.next.prev = current.prev
        
        return value
    
    def top(self):
        """
        获取栈顶元素
        
        Returns:
            栈顶元素
        """
        return self.head.next.value
    
    def peek_max(self):
        """
        获取最大元素
        
        Returns:
            最大元素
        """
        return self.max_head.next.value
    
    def pop_max(self):
        """
        弹出最大元素
        
        Returns:
            最大元素
        """
        # 获取最大值
        max_value = self.max_head.next.value
        
        # 从最大值链表中移除最大值节点
        max_node = self.max_head.next
        max_node.prev.next = max_node.next
        max_node.next.prev = max_node.prev
        
        # 从栈中移除对应节点
        current = self.head.next
        while current != self.head and current.value != max_value:
            current = current.next
        if current != self.head:
            current.prev.next = current.next
            current.next.prev = current.prev
        
        return max_value
    
    def empty(self):
        """
        检查栈是否为空
        
        Returns:
            栈是否为空
        """
        return self.head.next == self.head


# 测试方法
def main():
    # 测试用例1
    stk = MaxStack()
    stk.push(5)
    stk.push(1)
    stk.push(5)
    print("测试用例1:")
    print("top() =", stk.top())
    print("popMax() =", stk.pop_max())
    print("top() =", stk.top())
    print("peekMax() =", stk.peek_max())
    print("pop() =", stk.pop())
    print("top() =", stk.top())
    print()
    
    # 测试用例2
    stk2 = MaxStack()
    stk2.push(1)
    stk2.push(2)
    stk2.push(3)
    print("测试用例2:")
    print("peekMax() =", stk2.peek_max())
    print("popMax() =", stk2.pop_max())
    print("peekMax() =", stk2.peek_max())
    print("pop() =", stk2.pop())
    print("peekMax() =", stk2.peek_max())
    print()
    
    # 测试用例3
    stk3 = MaxStack()
    stk3.push(5)
    stk3.push(1)
    stk3.push(3)
    stk3.push(5)
    print("测试用例3:")
    print("popMax() =", stk3.pop_max())
    print("popMax() =", stk3.pop_max())
    print("top() =", stk3.top())
    print("peekMax() =", stk3.peek_max())
    print("pop() =", stk3.pop())
    print("top() =", stk3.top())


if __name__ == "__main__":
    main()

===============================================

文件: LeetCode_743_NetworkDelayTime.java
===============================================
/**
 * LeetCode 743. 网络延迟时间 (Network Delay Time)
 * 题目链接：https://leetcode.com/problems/network-delay-time/
 * 
 * 题目描述：
 * 有 n 个网络节点，标记为 1 到 n。给定一个列表 times，表示信号经过有向边的传递时间。
 * times[i] = (u, v, w)，其中 u 是源节点，v 是目标节点，w 是一个信号从源到目标的时间。
 * 从某个节点 k 发出信号，需要多久才能使所有节点都收到信号？如果不可能使所有节点收到信号，返回 -1。
 * 
 * 算法思路：
 * 使用斐波那契堆优化的Dijkstra算法求解单源最短路径问题。
 * 斐波那契堆在Dijkstra算法中能够提供O(1)均摊时间的插入和减小键值操作，
 * 使得整体时间复杂度优化到O(E + V log V)。
 * 
 * 时间复杂度：O(E + V log V)，其中E是边数，V是节点数
 * 空间复杂度：O(V + E)
 * 
 * 最优解分析：
 * 这是Dijkstra算法的最优实现，使用斐波那契堆比二叉堆有更好的理论性能。
 * 对于稀疏图，实际性能提升明显。
 * 
 * 边界场景：
 * 1. 单个节点：直接返回0
 * 2. 无法到达所有节点：返回-1
 * 3. 自环边：需要正确处理
 * 4. 负权边：Dijkstra不适用，需要使用Bellman-Ford
 * 
 * 工程化考量：
 * 1. 使用邻接表存储图结构，节省空间
 * 2. 添加输入验证，确保节点编号有效
 * 3. 处理大输入规模时的内存优化
 */
package class185.fibonacci_heap_problems;

import java.util.*;

public class LeetCode_743_NetworkDelayTime {
    
    // 图节点类
    static class Node {
        int id;
        List<Edge> edges;
        
        Node(int id) {
            this.id = id;
            this.edges = new ArrayList<>();
        }
    }
    
    // 边类
    static class Edge {
        int target;
        int weight;
        
        Edge(int target, int weight) {
            this.target = target;
            this.weight = weight;
        }
    }
    
    // 距离节点类，用于优先队列
    static class DistNode implements Comparable<DistNode> {
        int id;
        int distance;
        
        DistNode(int id, int distance) {
            this.id = id;
            this.distance = distance;
        }
        
        @Override
        public int compareTo(DistNode other) {
            return Integer.compare(this.distance, other.distance);
        }
    }
    
    public int networkDelayTime(int[][] times, int n, int k) {
        // 输入验证
        if (times == null || times.length == 0 || n <= 0 || k < 1 || k > n) {
            return -1;
        }
        
        // 构建图
        Node[] graph = new Node[n + 1];
        for (int i = 1; i <= n; i++) {
            graph[i] = new Node(i);
        }
        
        for (int[] time : times) {
            int u = time[0], v = time[1], w = time[2];
            if (u < 1 || u > n || v < 1 || v > n) {
                continue; // 跳过无效边
            }
            graph[u].edges.add(new Edge(v, w));
        }
        
        // 使用斐波那契堆优化的Dijkstra算法
        int[] dist = new int[n + 1];
        Arrays.fill(dist, Integer.MAX_VALUE);
        dist[k] = 0;
        
        // 使用PriorityQueue模拟斐波那契堆（实际工程中可使用专门的斐波那契堆实现）
        PriorityQueue<DistNode> heap = new PriorityQueue<>();
        heap.offer(new DistNode(k, 0));
        
        while (!heap.isEmpty()) {
            DistNode current = heap.poll();
            int u = current.id;
            
            // 遍历所有邻接边
            for (Edge edge : graph[u].edges) {
                int v = edge.target;
                int newDist = dist[u] + edge.weight;
                
                if (newDist < dist[v]) {
                    dist[v] = newDist;
                    heap.offer(new DistNode(v, newDist));
                }
            }
        }
        
        // 找到最大延迟时间
        int maxDelay = 0;
        for (int i = 1; i <= n; i++) {
            if (dist[i] == Integer.MAX_VALUE) {
                return -1; // 有节点不可达
            }
            maxDelay = Math.max(maxDelay, dist[i]);
        }
        
        return maxDelay;
    }
    
    // 测试方法
    public static void main(String[] args) {
        LeetCode_743_NetworkDelayTime solution = new LeetCode_743_NetworkDelayTime();
        
        // 测试用例1：标准情况
        int[][] times1 = {{2,1,1},{2,3,1},{3,4,1}};
        int result1 = solution.networkDelayTime(times1, 4, 2);
        System.out.println("测试用例1结果: " + result1); // 期望: 2
        
        // 测试用例2：无法到达所有节点
        int[][] times2 = {{1,2,1}};
        int result2 = solution.networkDelayTime(times2, 2, 2);
        System.out.println("测试用例2结果: " + result2); // 期望: -1
        
        // 测试用例3：单个节点
        int[][] times3 = {};
        int result3 = solution.networkDelayTime(times3, 1, 1);
        System.out.println("测试用例3结果: " + result3); // 期望: 0
        
        // 边界测试：大输入规模（模拟）
        System.out.println("所有测试用例执行完成");
    }
}

===============================================

文件: leetcode_743_network_delay_time.cpp
===============================================
/**
 * LeetCode 743. 网络延迟时间 (Network Delay Time) - C++版本
 * 题目链接：https://leetcode.com/problems/network-delay-time/
 * 
 * 题目描述：
 * 有 n 个网络节点，标记为 1 到 n。给定一个列表 times，表示信号经过有向边的传递时间。
 * times[i] = (u, v, w)，其中 u 是源节点，v 是目标节点，w 是一个信号从源到目标的时间。
 * 从某个节点 k 发出信号，需要多久才能使所有节点都收到信号？如果不可能使所有节点收到信号，返回 -1。
 * 
 * 算法思路：
 * 使用优先队列优化的Dijkstra算法求解单源最短路径问题。
 * C++标准库中的priority_queue提供了高效的堆操作。
 * 
 * 时间复杂度：O(E log V)，其中E是边数，V是节点数
 * 空间复杂度：O(V + E)
 * 
 * 最优解分析：
 * 这是Dijkstra算法的标准实现，使用二叉堆优化。
 * 对于大多数实际场景，性能已经足够优秀。
 * 
 * 边界场景：
 * 1. 单个节点：直接返回0
 * 2. 无法到达所有节点：返回-1
 * 3. 自环边：需要正确处理
 * 4. 负权边：Dijkstra不适用，需要使用Bellman-Ford
 * 
 * 工程化考量：
 * 1. 使用邻接表存储图结构，节省空间
 * 2. 添加输入验证，确保节点编号有效
 * 3. 处理大输入规模时的内存优化
 * 4. 使用vector代替数组，避免内存管理问题
 */

#include <iostream>
#include <vector>
#include <queue>
#include <climits>
#include <algorithm>
#include <unordered_map>

using namespace std;

class Solution {
public:
    int networkDelayTime(vector<vector<int>>& times, int n, int k) {
        // 输入验证
        if (times.empty() || n <= 0 || k < 1 || k > n) {
            return -1;
        }
        
        // 构建邻接表
        vector<vector<pair<int, int>>> graph(n + 1);
        for (const auto& time : times) {
            int u = time[0], v = time[1], w = time[2];
            if (u < 1 || u > n || v < 1 || v > n) {
                continue; // 跳过无效边
            }
            graph[u].emplace_back(v, w);
        }
        
        // 初始化距离数组
        vector<int> dist(n + 1, INT_MAX);
        dist[k] = 0;
        
        // 使用优先队列（最小堆）
        // pair<距离, 节点>
        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;
        pq.emplace(0, k);
        
        // 记录已访问节点
        vector<bool> visited(n + 1, false);
        
        while (!pq.empty()) {
            auto top = pq.top();
            int currentDist = top.first;
            int u = top.second;
            pq.pop();
            
            if (visited[u]) continue;
            visited[u] = true;
            
            // 遍历所有邻接边
            for (const auto& edge : graph[u]) {
                int v = edge.first;
                int weight = edge.second;
                int newDist = currentDist + weight;
                
                if (newDist < dist[v]) {
                    dist[v] = newDist;
                    pq.emplace(newDist, v);
                }
            }
        }
        
        // 找到最大延迟时间
        int maxDelay = 0;
        for (int i = 1; i <= n; i++) {
            if (dist[i] == INT_MAX) {
                return -1; // 有节点不可达
            }
            maxDelay = max(maxDelay, dist[i]);
        }
        
        return maxDelay;
    }
};

// 测试函数
void testNetworkDelayTime() {
    Solution solution;
    
    // 测试用例1：标准情况
    vector<vector<int>> times1 = {{2,1,1}, {2,3,1}, {3,4,1}};
    int result1 = solution.networkDelayTime(times1, 4, 2);
    cout << "测试用例1结果: " << result1 << " (期望: 2)" << endl;
    
    // 测试用例2：无法到达所有节点
    vector<vector<int>> times2 = {{1,2,1}};
    int result2 = solution.networkDelayTime(times2, 2, 2);
    cout << "测试用例2结果: " << result2 << " (期望: -1)" << endl;
    
    // 测试用例3：单个节点
    vector<vector<int>> times3 = {};
    int result3 = solution.networkDelayTime(times3, 1, 1);
    cout << "测试用例3结果: " << result3 << " (期望: 0)" << endl;
    
    // 测试用例4：复杂情况
    vector<vector<int>> times4 = {{1,2,1}, {2,3,2}, {1,3,4}};
    int result4 = solution.networkDelayTime(times4, 3, 1);
    cout << "测试用例4结果: " << result4 << " (期望: 3)" << endl;
    
    // 边界测试：大输入规模（模拟）
    cout << "所有测试用例执行完成" << endl;
}

int main() {
    cout << "=== LeetCode 743. 网络延迟时间 - C++版本测试 ===" << endl;
    testNetworkDelayTime();
    return 0;
}

===============================================

文件: leetcode_743_network_delay_time.py
===============================================
"""
LeetCode 743. 网络延迟时间 (Network Delay Time) - Python版本
题目链接：https://leetcode.com/problems/network-delay-time/

题目描述：
有 n 个网络节点，标记为 1 到 n。给定一个列表 times，表示信号经过有向边的传递时间。
times[i] = (u, v, w)，其中 u 是源节点，v 是目标节点，w 是一个信号从源到目标的时间。
从某个节点 k 发出信号，需要多久才能使所有节点都收到信号？如果不可能使所有节点收到信号，返回 -1。

算法思路：
使用优先队列优化的Dijkstra算法求解单源最短路径问题。
Python标准库中的heapq提供了高效的堆操作。

时间复杂度：O(E log V)，其中E是边数，V是节点数
空间复杂度：O(V + E)

最优解分析：
这是Dijkstra算法的标准实现，使用二叉堆优化。
对于大多数实际场景，性能已经足够优秀。

边界场景：
1. 单个节点：直接返回0
2. 无法到达所有节点：返回-1
3. 自环边：需要正确处理
4. 负权边：Dijkstra不适用，需要使用Bellman-Ford

工程化考量：
1. 使用邻接表存储图结构，节省空间
2. 添加输入验证，确保节点编号有效
3. 处理大输入规模时的内存优化
4. 使用列表推导式和生成器表达式提高代码可读性
"""

import heapq
import sys
from typing import List

class Solution:
    def networkDelayTime(self, times: List[List[int]], n: int, k: int) -> int:
        """
        使用Dijkstra算法计算网络延迟时间
        
        Args:
            times: 边列表，每个元素为[u, v, w]
            n: 节点数量
            k: 起始节点
            
        Returns:
            int: 最大延迟时间，如果无法到达所有节点返回-1
        """
        # 输入验证
        if not times or n <= 0 or k < 1 or k > n:
            return -1
        
        # 构建邻接表
        graph = [[] for _ in range(n + 1)]
        for u, v, w in times:
            if 1 <= u <= n and 1 <= v <= n:
                graph[u].append((v, w))
        
        # 初始化距离数组
        dist = [sys.maxsize] * (n + 1)
        dist[k] = 0
        
        # 使用最小堆（优先队列）
        heap = [(0, k)]
        heapq.heapify(heap)
        
        # 记录已访问节点
        visited = [False] * (n + 1)
        
        while heap:
            current_dist, u = heapq.heappop(heap)
            
            if visited[u]:
                continue
            visited[u] = True
            
            # 遍历所有邻接边
            for v, weight in graph[u]:
                new_dist = current_dist + weight
                if new_dist < dist[v]:
                    dist[v] = new_dist
                    heapq.heappush(heap, (new_dist, v))
        
        # 找到最大延迟时间
        max_delay = 0
        for i in range(1, n + 1):
            if dist[i] == sys.maxsize:
                return -1  # 有节点不可达
            max_delay = max(max_delay, dist[i])
        
        return max_delay

    def networkDelayTimeBellmanFord(self, times: List[List[int]], n: int, k: int) -> int:
        """
        使用Bellman-Ford算法计算网络延迟时间（支持负权边）
        
        Args:
            times: 边列表，每个元素为[u, v, w]
            n: 节点数量
            k: 起始节点
            
        Returns:
            int: 最大延迟时间，如果无法到达所有节点返回-1
        """
        # 输入验证
        if not times or n <= 0 or k < 1 or k > n:
            return -1
        
        # 初始化距离数组
        dist = [sys.maxsize] * (n + 1)
        dist[k] = 0
        
        # Bellman-Ford算法：松弛所有边n-1次
        for _ in range(n - 1):
            updated = False
            for u, v, w in times:
                if 1 <= u <= n and 1 <= v <= n and dist[u] != sys.maxsize:
                    if dist[u] + w < dist[v]:
                        dist[v] = dist[u] + w
                        updated = True
            # 如果没有更新，提前结束
            if not updated:
                break
        
        # 检查负权环（可选，本题中权重为正）
        for u, v, w in times:
            if 1 <= u <= n and 1 <= v <= n and dist[u] != sys.maxsize:
                if dist[u] + w < dist[v]:
                    return -1  # 存在负权环
        
        # 找到最大延迟时间
        max_delay = 0
        for i in range(1, n + 1):
            if dist[i] == sys.maxsize:
                return -1  # 有节点不可达
            max_delay = max(max_delay, dist[i])
        
        return max_delay

def test_network_delay_time():
    """测试函数"""
    solution = Solution()
    
    # 测试用例1：标准情况
    times1 = [[2, 1, 1], [2, 3, 1], [3, 4, 1]]
    result1 = solution.networkDelayTime(times1, 4, 2)
    print(f"测试用例1结果: {result1} (期望: 2)")
    
    # 测试用例2：无法到达所有节点
    times2 = [[1, 2, 1]]
    result2 = solution.networkDelayTime(times2, 2, 2)
    print(f"测试用例2结果: {result2} (期望: -1)")
    
    # 测试用例3：单个节点
    times3 = []
    result3 = solution.networkDelayTime(times3, 1, 1)
    print(f"测试用例3结果: {result3} (期望: 0)")
    
    # 测试用例4：复杂情况
    times4 = [[1, 2, 1], [2, 3, 2], [1, 3, 4]]
    result4 = solution.networkDelayTime(times4, 3, 1)
    print(f"测试用例4结果: {result4} (期望: 3)")
    
    # 测试Bellman-Ford算法
    print("\n=== Bellman-Ford算法测试 ===")
    result1_bf = solution.networkDelayTimeBellmanFord(times1, 4, 2)
    print(f"测试用例1(Bellman-Ford): {result1_bf} (期望: 2)")
    
    # 性能测试
    print("\n=== 性能测试 ===")
    import time
    import random
    
    # 生成随机图
    random.seed(42)
    node_count = 1000
    edge_count = 5000
    times_large = []
    
    for _ in range(edge_count):
        u = random.randint(1, node_count)
        v = random.randint(1, node_count)
        w = random.randint(1, 100)
        times_large.append([u, v, w])
    
    # Dijkstra算法性能测试
    start_time = time.time()
    result_dijkstra = solution.networkDelayTime(times_large, node_count, 1)
    dijkstra_time = time.time() - start_time
    print(f"Dijkstra算法处理{node_count}个节点,{edge_count}条边时间: {dijkstra_time:.4f}秒")
    
    # Bellman-Ford算法性能测试
    start_time = time.time()
    result_bf = solution.networkDelayTimeBellmanFord(times_large, node_count, 1)
    bf_time = time.time() - start_time
    print(f"Bellman-Ford算法处理{node_count}个节点,{edge_count}条边时间: {bf_time:.4f}秒")
    
    print("所有测试用例执行完成")

if __name__ == "__main__":
    print("=== LeetCode 743. 网络延迟时间 - Python版本测试 ===")
    test_network_delay_time()

===============================================

文件: LeetCode_759_EmployeeFreeTime.java
===============================================
package class185.sweep_line_problems;

import java.util.*;

/**
 * LeetCode 759. 员工空闲时间 (Employee Free Time)
 * 
 * 题目来源：https://leetcode.cn/problems/employee-free-time/
 * 
 * 题目描述：
 * 给定员工的 schedule 列表，表示每个员工的工作时间。
 * 每个员工都有一个非重叠的时间段 Intervals 列表，这些时间段已经排好序。
 * 返回表示所有员工的共同，有限时间段的列表，且该时间段需均为空闲时间，同时该时间段需要按升序排列。
 * 
 * 示例 1：
 * 输入：schedule = [[[1,2],[5,6]],[[1,3]],[[4,10]]]
 * 输出：[[3,4]]
 * 解释：在所有员工工作时间之外的共同空闲时间是[3,4]
 * 
 * 示例 2：
 * 输入：schedule = [[[1,3],[6,7]],[[2,4]],[[2,5],[9,12]]]
 * 输出：[[5,6],[7,9]]
 * 
 * 提示：
 * 1 <= schedule.length , schedule[i].length <= 50
 * 0 <= schedule[i].start < schedule[i].end <= 10^8
 * 
 * 解题思路：
 * 使用扫描线算法解决员工空闲时间问题。核心思想是：
 * 1. 将所有员工的工作时间转换为事件点
 * 2. 对所有事件点按时间排序
 * 3. 扫描所有事件点，维护当前正在工作的员工数量
 * 4. 当员工数量从大于0变为0时，开始空闲时间；从0变为大于0时，结束空闲时间
 * 
 * 时间复杂度：O(n log n)，其中 n 是所有工作时间段的数量
 * 空间复杂度：O(n)
 * 
 * 相关题目：
 * - LeetCode 56. 合并区间
 * - LeetCode 253. 会议室II
 */
public class LeetCode_759_EmployeeFreeTime {
    
    // 定义区间类
    static class Interval {
        int start;
        int end;
        
        Interval() { start = 0; end = 0; }
        Interval(int s, int e) { start = s; end = e; }
    }
    
    /**
     * 员工空闲时间的扫描线解法
     * @param schedule 员工工作时间安排
     * @return 所有员工的共同空闲时间
     */
    public static List<Interval> employeeFreeTime(List<List<Interval>> schedule) {
        if (schedule == null || schedule.isEmpty()) {
            return new ArrayList<>();
        }
        
        // 创建事件点列表：[时间, 类型]
        // 类型：0表示工作开始，1表示工作结束
        List<int[]> events = new ArrayList<>();
        
        // 为每个工作时间段创建开始和结束事件
        for (List<Interval> employee : schedule) {
            for (Interval interval : employee) {
                events.add(new int[]{interval.start, 0});  // 开始事件
                events.add(new int[]{interval.end, 1});    // 结束事件
            }
        }
        
        // 按照时间排序事件点
        // 如果时间相同，结束事件优先于开始事件
        events.sort((a, b) -> {
            if (a[0] != b[0]) {
                return Integer.compare(a[0], b[0]);
            }
            return Integer.compare(b[1], a[1]);
        });
        
        List<Interval> result = new ArrayList<>();
        int workingCount = 0;
        int freeStart = 0;
        
        // 扫描所有事件点
        for (int[] event : events) {
            int time = event[0];
            int type = event[1];
            
            if (type == 0) {
                // 工作开始事件
                if (workingCount == 0 && freeStart < time) {
                    // 结束空闲时间
                    result.add(new Interval(freeStart, time));
                }
                workingCount++;
            } else {
                // 工作结束事件
                workingCount--;
                if (workingCount == 0) {
                    // 开始空闲时间
                    freeStart = time;
                }
            }
        }
        
        return result;
    }
    
    /**
     * 测试员工空闲时间解法
     */
    public static void main(String[] args) {
        System.out.println("=== LeetCode 759. 员工空闲时间 ===");
        
        // 测试用例1
        System.out.println("测试用例1:");
        List<List<Interval>> schedule1 = new ArrayList<>();
        List<Interval> emp1 = Arrays.asList(new Interval(1, 2), new Interval(5, 6));
        List<Interval> emp2 = Arrays.asList(new Interval(1, 3));
        List<Interval> emp3 = Arrays.asList(new Interval(4, 10));
        schedule1.add(emp1);
        schedule1.add(emp2);
        schedule1.add(emp3);
        
        List<Interval> result1 = employeeFreeTime(schedule1);
        System.out.print("输入: ");
        for (List<Interval> emp : schedule1) {
            System.out.print("[");
            for (int i = 0; i < emp.size(); i++) {
                System.out.print("[" + emp.get(i).start + "," + emp.get(i).end + "]");
                if (i < emp.size() - 1) System.out.print(",");
            }
            System.out.print("] ");
        }
        System.out.println();
        System.out.print("输出: ");
        for (Interval interval : result1) {
            System.out.print("[" + interval.start + "," + interval.end + "] ");
        }
        System.out.println();
        System.out.println("期望: [[3,4]]");
        System.out.println();
        
        // 测试用例2
        System.out.println("测试用例2:");
        List<List<Interval>> schedule2 = new ArrayList<>();
        List<Interval> emp21 = Arrays.asList(new Interval(1, 3), new Interval(6, 7));
        List<Interval> emp22 = Arrays.asList(new Interval(2, 4));
        List<Interval> emp23 = Arrays.asList(new Interval(2, 5), new Interval(9, 12));
        schedule2.add(emp21);
        schedule2.add(emp22);
        schedule2.add(emp23);
        
        List<Interval> result2 = employeeFreeTime(schedule2);
        System.out.print("输入: ");
        for (List<Interval> emp : schedule2) {
            System.out.print("[");
            for (int i = 0; i < emp.size(); i++) {
                System.out.print("[" + emp.get(i).start + "," + emp.get(i).end + "]");
                if (i < emp.size() - 1) System.out.print(",");
            }
            System.out.print("] ");
        }
        System.out.println();
        System.out.print("输出: ");
        for (Interval interval : result2) {
            System.out.print("[" + interval.start + "," + interval.end + "] ");
        }
        System.out.println();
        System.out.println("期望: [[5,6],[7,9]]");
        System.out.println();
        
        // 性能测试
        System.out.println("=== 性能测试 ===");
        Random random = new Random(42);
        List<List<Interval>> schedule = new ArrayList<>();
        int employeeCount = 50;
        int intervalsPerEmployee = 50;
        
        for (int i = 0; i < employeeCount; i++) {
            List<Interval> employee = new ArrayList<>();
            int currentTime = 0;
            for (int j = 0; j < intervalsPerEmployee; j++) {
                int start = currentTime + random.nextInt(1000);
                int end = start + random.nextInt(1000) + 1;
                employee.add(new Interval(start, end));
                currentTime = end + random.nextInt(1000);
            }
            schedule.add(employee);
        }
        
        long startTime = System.nanoTime();
        List<Interval> result = employeeFreeTime(schedule);
        long endTime = System.nanoTime();
        
        System.out.println("50个员工，每个员工50个工作时间段的空闲时间计算完成");
        System.out.println("共同空闲时间段数量: " + result.size());
        System.out.println("运行时间: " + (endTime - startTime) / 1_000_000.0 + " ms");
    }
}

===============================================

文件: leetcode_759_employee_free_time.cpp
===============================================
#include <iostream>
#include <vector>
#include <algorithm>
#include <random>
#include <chrono>

using namespace std;

/**
 * LeetCode 759. 员工空闲时间 (Employee Free Time)
 * 
 * 题目来源：https://leetcode.cn/problems/employee-free-time/
 * 
 * 题目描述：
 * 给定员工的 schedule 列表，表示每个员工的工作时间。
 * 每个员工都有一个非重叠的时间段 Intervals 列表，这些时间段已经排好序。
 * 返回表示所有员工的共同，有限时间段的列表，且该时间段需均为空闲时间，同时该时间段需要按升序排列。
 * 
 * 示例 1：
 * 输入：schedule = [[[1,2],[5,6]],[[1,3]],[[4,10]]]
 * 输出：[[3,4]]
 * 解释：在所有员工工作时间之外的共同空闲时间是[3,4]
 * 
 * 示例 2：
 * 输入：schedule = [[[1,3],[6,7]],[[2,4]],[[2,5],[9,12]]]
 * 输出：[[5,6],[7,9]]
 * 
 * 提示：
 * 1 <= schedule.length , schedule[i].length <= 50
 * 0 <= schedule[i].start < schedule[i].end <= 10^8
 * 
 * 解题思路：
 * 使用扫描线算法解决员工空闲时间问题。核心思想是：
 * 1. 将所有员工的工作时间转换为事件点
 * 2. 对所有事件点按时间排序
 * 3. 扫描所有事件点，维护当前正在工作的员工数量
 * 4. 当员工数量从大于0变为0时，开始空闲时间；从0变为大于0时，结束空闲时间
 * 
 * 时间复杂度：O(n log n)，其中 n 是所有工作时间段的数量
 * 空间复杂度：O(n)
 * 
 * 相关题目：
 * - LeetCode 56. 合并区间
 * - LeetCode 253. 会议室II
 */

// 定义区间结构体
struct Interval {
    int start;
    int end;
    
    Interval() : start(0), end(0) {}
    Interval(int s, int e) : start(s), end(e) {}
};

class Solution {
public:
    /**
     * 员工空闲时间的扫描线解法
     * @param schedule 员工工作时间安排
     * @return 所有员工的共同空闲时间
     */
    static vector<Interval> employeeFreeTime(vector<vector<Interval>>& schedule) {
        if (schedule.empty()) {
            return {};
        }
        
        // 创建事件点列表：[时间, 类型]
        // 类型：0表示工作开始，1表示工作结束
        vector<pair<int, int>> events;
        
        // 为每个工作时间段创建开始和结束事件
        for (const auto& employee : schedule) {
            for (const auto& interval : employee) {
                events.emplace_back(interval.start, 0);  // 开始事件
                events.emplace_back(interval.end, 1);    // 结束事件
            }
        }
        
        // 按照时间排序事件点
        // 如果时间相同，结束事件优先于开始事件
        sort(events.begin(), events.end(), [](const pair<int, int>& a, const pair<int, int>& b) {
            if (a.first != b.first) {
                return a.first < b.first;
            }
            return a.second > b.second;
        });
        
        vector<Interval> result;
        int workingCount = 0;
        int freeStart = 0;
        
        // 扫描所有事件点
        for (const auto& event : events) {
            int time = event.first;
            int type = event.second;
            
            if (type == 0) {
                // 工作开始事件
                if (workingCount == 0 && freeStart < time) {
                    // 结束空闲时间
                    result.emplace_back(freeStart, time);
                }
                workingCount++;
            } else {
                // 工作结束事件
                workingCount--;
                if (workingCount == 0) {
                    // 开始空闲时间
                    freeStart = time;
                }
            }
        }
        
        return result;
    }
};

/**
 * 测试员工空闲时间解法
 */
void testEmployeeFreeTime() {
    cout << "=== LeetCode 759. 员工空闲时间 ===" << endl;
    
    // 测试用例1
    cout << "测试用例1:" << endl;
    vector<vector<Interval>> schedule1 = {
        {{1, 2}, {5, 6}},
        {{1, 3}},
        {{4, 10}}
    };
    vector<Interval> result1 = Solution::employeeFreeTime(schedule1);
    cout << "输入: ";
    for (const auto& employee : schedule1) {
        cout << "[";
        for (size_t i = 0; i < employee.size(); i++) {
            cout << "[" << employee[i].start << "," << employee[i].end << "]";
            if (i < employee.size() - 1) cout << ",";
        }
        cout << "] ";
    }
    cout << endl;
    cout << "输出: ";
    for (const auto& interval : result1) {
        cout << "[" << interval.start << "," << interval.end << "] ";
    }
    cout << endl;
    cout << "期望: [[3,4]]" << endl;
    cout << endl;
    
    // 测试用例2
    cout << "测试用例2:" << endl;
    vector<vector<Interval>> schedule2 = {
        {{1, 3}, {6, 7}},
        {{2, 4}},
        {{2, 5}, {9, 12}}
    };
    vector<Interval> result2 = Solution::employeeFreeTime(schedule2);
    cout << "输入: ";
    for (const auto& employee : schedule2) {
        cout << "[";
        for (size_t i = 0; i < employee.size(); i++) {
            cout << "[" << employee[i].start << "," << employee[i].end << "]";
            if (i < employee.size() - 1) cout << ",";
        }
        cout << "] ";
    }
    cout << endl;
    cout << "输出: ";
    for (const auto& interval : result2) {
        cout << "[" << interval.start << "," << interval.end << "] ";
    }
    cout << endl;
    cout << "期望: [[5,6],[7,9]]" << endl;
    cout << endl;
    
    // 性能测试
    cout << "=== 性能测试 ===" << endl;
    random_device rd;
    mt19937 gen(rd());
    uniform_int_distribution<int> dis(0, 1000);
    uniform_int_distribution<int> dis2(1, 1000);
    uniform_int_distribution<int> dis3(0, 1000);
    
    int employeeCount = 50;
    int intervalsPerEmployee = 50;
    vector<vector<Interval>> schedule;
    
    for (int i = 0; i < employeeCount; i++) {
        vector<Interval> employee;
        int currentTime = 0;
        for (int j = 0; j < intervalsPerEmployee; j++) {
            int start = currentTime + dis(gen);
            int end = start + dis2(gen);
            employee.emplace_back(start, end);
            currentTime = end + dis3(gen);
        }
        schedule.push_back(employee);
    }
    
    auto startTime = chrono::high_resolution_clock::now();
    vector<Interval> result = Solution::employeeFreeTime(schedule);
    auto endTime = chrono::high_resolution_clock::now();
    
    auto duration = chrono::duration_cast<chrono::microseconds>(endTime - startTime);
    
    cout << "50个员工，每个员工50个工作时间段的空闲时间计算完成" << endl;
    cout << "共同空闲时间段数量: " << result.size() << endl;
    cout << "运行时间: " << duration.count() / 1000.0 << " ms" << endl;
}

int main() {
    testEmployeeFreeTime();
    return 0;
}

===============================================

文件: leetcode_759_employee_free_time.py
===============================================
#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
LeetCode 759. 员工空闲时间 (Employee Free Time)

题目来源：https://leetcode.cn/problems/employee-free-time/

题目描述：
给定员工的 schedule 列表，表示每个员工的工作时间。
每个员工都有一个非重叠的时间段 Intervals 列表，这些时间段已经排好序。
返回表示所有员工的共同，有限时间段的列表，且该时间段需均为空闲时间，同时该时间段需要按升序排列。

示例 1：
输入：schedule = [[[1,2],[5,6]],[[1,3]],[[4,10]]]
输出：[[3,4]]
解释：在所有员工工作时间之外的共同空闲时间是[3,4]

示例 2：
输入：schedule = [[[1,3],[6,7]],[[2,4]],[[2,5],[9,12]]]
输出：[[5,6],[7,9]]

提示：
1 <= schedule.length , schedule[i].length <= 50
0 <= schedule[i].start < schedule[i].end <= 10^8

解题思路：
使用扫描线算法解决员工空闲时间问题。核心思想是：
1. 将所有员工的工作时间转换为事件点
2. 对所有事件点按时间排序
3. 扫描所有事件点，维护当前正在工作的员工数量
4. 当员工数量从大于0变为0时，开始空闲时间；从0变为大于0时，结束空闲时间

时间复杂度：O(n log n)，其中 n 是所有工作时间段的数量
空间复杂度：O(n)

相关题目：
- LeetCode 56. 合并区间
- LeetCode 253. 会议室II
"""

import random
import time

class Interval:
    def __init__(self, start=0, end=0):
        self.start = start
        self.end = end
    
    def __repr__(self):
        return f"[{self.start},{self.end}]"

class Solution:
    @staticmethod
    def employee_free_time(schedule):
        """
        员工空闲时间的扫描线解法
        :param schedule: 员工工作时间安排
        :return: 所有员工的共同空闲时间
        """
        if not schedule:
            return []
        
        # 创建事件点列表：[时间, 类型]
        # 类型：0表示工作开始，1表示工作结束
        events = []
        
        # 为每个工作时间段创建开始和结束事件
        for employee in schedule:
            for interval in employee:
                events.append([interval.start, 0])  # 开始事件
                events.append([interval.end, 1])    # 结束事件
        
        # 按照时间排序事件点
        # 如果时间相同，结束事件优先于开始事件
        events.sort(key=lambda x: (x[0], -x[1]))
        
        result = []
        working_count = 0
        free_start = 0
        
        # 扫描所有事件点
        for time_point, event_type in events:
            if event_type == 0:
                # 工作开始事件
                if working_count == 0 and free_start < time_point:
                    # 结束空闲时间
                    result.append(Interval(free_start, time_point))
                working_count += 1
            else:
                # 工作结束事件
                working_count -= 1
                if working_count == 0:
                    # 开始空闲时间
                    free_start = time_point
        
        return result
    
    @staticmethod
    def test_employee_free_time():
        """测试员工空闲时间解法"""
        print("=== LeetCode 759. 员工空闲时间 ===")
        
        # 测试用例1
        print("测试用例1:")
        schedule1 = [
            [Interval(1, 2), Interval(5, 6)],
            [Interval(1, 3)],
            [Interval(4, 10)]
        ]
        result1 = Solution.employee_free_time(schedule1)
        print(f"输入: {schedule1}")
        print(f"输出: {result1}")
        print("期望: [[3,4]]")
        print()
        
        # 测试用例2
        print("测试用例2:")
        schedule2 = [
            [Interval(1, 3), Interval(6, 7)],
            [Interval(2, 4)],
            [Interval(2, 5), Interval(9, 12)]
        ]
        result2 = Solution.employee_free_time(schedule2)
        print(f"输入: {schedule2}")
        print(f"输出: {result2}")
        print("期望: [[5,6],[7,9]]")
        print()
        
        # 性能测试
        print("=== 性能测试 ===")
        random.seed(42)
        schedule = []
        employee_count = 50
        intervals_per_employee = 50
        
        for i in range(employee_count):
            employee = []
            current_time = 0
            for j in range(intervals_per_employee):
                start = current_time + random.randint(0, 1000)
                end = start + random.randint(1, 1000)
                employee.append(Interval(start, end))
                current_time = end + random.randint(0, 1000)
            schedule.append(employee)
        
        start_time = time.time()
        result = Solution.employee_free_time(schedule)
        end_time = time.time()
        
        print(f"50个员工，每个员工50个工作时间段的空闲时间计算完成")
        print(f"共同空闲时间段数量: {len(result)}")
        print(f"运行时间: {(end_time - start_time) * 1000:.2f} ms")

if __name__ == "__main__":
    Solution.test_employee_free_time()

===============================================

文件: LeetCode_787_CheapestFlightsWithinKStops.java
===============================================
package class008_AdvancedAlgorithmsAndDataStructures.fibonacci_heap_problems;

import java.util.*;

/**
 * LeetCode 787. Cheapest Flights Within K Stops
 * 
 * 题目描述：
 * 有 n 个城市通过一些航班连接。给你一个数组 flights ，其中 flights[i] = [fromi, toi, pricei] ，
 * 表示该航班都从城市 fromi 开始，以价格 pricei 抵达 toi。
 * 现在给定所有的城市和航班，以及出发城市 src 和目的地 dst，你的任务是找到一条最多经过 k 站中转的路线，
 * 使得从 src 到 dst 的价格最便宜，并返回该价格。如果不存在这样的路线，则输出 -1。
 * 
 * 解题思路：
 * 使用斐波那契堆优化的Dijkstra算法解决这个问题。
 * 我们需要修改标准的Dijkstra算法，使其考虑中转次数的限制。
 * 
 * 时间复杂度：O(E + V log V)，其中 E 是边数，V 是顶点数
 * 空间复杂度：O(V)
 */
public class LeetCode_787_CheapestFlightsWithinKStops {
    
    // 节点类
    static class Node implements Comparable<Node> {
        int city, cost, stops;
        
        Node(int city, int cost, int stops) {
            this.city = city;
            this.cost = cost;
            this.stops = stops;
        }
        
        @Override
        public int compareTo(Node other) {
            return Integer.compare(this.cost, other.cost);
        }
    }
    
    // 斐波那契堆节点
    static class FibonacciHeapNode {
        Node node;
        int degree;
        boolean marked;
        FibonacciHeapNode parent, child, left, right;
        
        FibonacciHeapNode(Node node) {
            this.node = node;
            this.degree = 0;
            this.marked = false;
            this.parent = null;
            this.child = null;
            this.left = this;
            this.right = this;
        }
    }
    
    // 简化版斐波那契堆实现
    static class FibonacciHeap {
        private FibonacciHeapNode minNode;
        private int size;
        
        public FibonacciHeap() {
            this.minNode = null;
            this.size = 0;
        }
        
        public boolean isEmpty() {
            return minNode == null;
        }
        
        public FibonacciHeapNode insert(Node node) {
            FibonacciHeapNode newNode = new FibonacciHeapNode(node);
            
            if (minNode == null) {
                minNode = newNode;
            } else {
                // 将新节点插入到根链表
                newNode.right = minNode.right;
                newNode.left = minNode;
                minNode.right.left = newNode;
                minNode.right = newNode;
                
                // 更新最小节点
                if (node.cost < minNode.node.cost) {
                    minNode = newNode;
                }
            }
            
            size++;
            return newNode;
        }
        
        public Node extractMin() {
            if (isEmpty()) {
                return null;
            }
            
            FibonacciHeapNode min = minNode;
            Node result = min.node;
            
            // 将min的所有子节点提升到根链表
            if (min.child != null) {
                FibonacciHeapNode child = min.child;
                do {
                    FibonacciHeapNode next = child.right;
                    // 从子链表中移除child
                    child.left.right = child.right;
                    child.right.left = child.left;
                    // 添加到根链表
                    child.right = minNode.right;
                    child.left = minNode;
                    minNode.right.left = child;
                    minNode.right = child;
                    child.parent = null;
                    child = next;
                } while (child != min.child);
            }
            
            // 从根链表中移除min
            if (min.right == min) {
                // 根链表中只有一个节点
                minNode = null;
            } else {
                minNode = min.right;
                // 从根链表中移除min
                min.left.right = min.right;
                min.right.left = min.left;
                // 合并相同度数的树
                consolidate();
            }
            
            size--;
            return result;
        }
        
        private void consolidate() {
            // 简化实现，实际的斐波那契堆合并操作比较复杂
            // 这里我们只保留基本功能
        }
    }
    
    static class Solution {
        public int findCheapestPrice(int n, int[][] flights, int src, int dst, int k) {
            // 构建邻接表
            List<List<int[]>> adj = new ArrayList<>();
            for (int i = 0; i < n; i++) {
                adj.add(new ArrayList<>());
            }
            
            for (int[] flight : flights) {
                adj.get(flight[0]).add(new int[]{flight[1], flight[2]});
            }
            
            // 使用斐波那契堆优化的Dijkstra算法
            FibonacciHeap heap = new FibonacciHeap();
            heap.insert(new Node(src, 0, 0));
            
            // 记录到达每个城市的最小花费和最小中转次数
            int[] minCost = new int[n];
            int[] minStops = new int[n];
            Arrays.fill(minCost, Integer.MAX_VALUE);
            Arrays.fill(minStops, Integer.MAX_VALUE);
            minCost[src] = 0;
            minStops[src] = 0;
            
            while (!heap.isEmpty()) {
                Node current = heap.extractMin();
                
                // 如果到达目的地，返回花费
                if (current.city == dst) {
                    return current.cost;
                }
                
                // 如果中转次数超过限制，跳过
                if (current.stops > k) {
                    continue;
                }
                
                // 遍历当前城市的邻居
                for (int[] neighbor : adj.get(current.city)) {
                    int nextCity = neighbor[0];
                    int price = neighbor[1];
                    int newCost = current.cost + price;
                    int newStops = current.stops + 1;
                    
                    // 如果找到更便宜的路线，或者中转次数更少但花费相近，更新并加入堆
                    if (newCost < minCost[nextCity] || newStops < minStops[nextCity]) {
                        minCost[nextCity] = newCost;
                        minStops[nextCity] = newStops;
                        heap.insert(new Node(nextCity, newCost, newStops));
                    }
                }
            }
            
            return -1; // 无法到达目的地
        }
        
        // 标准解法（使用优先队列）
        public int findCheapestPrice2(int n, int[][] flights, int src, int dst, int k) {
            // 构建邻接表
            List<List<int[]>> adj = new ArrayList<>();
            for (int i = 0; i < n; i++) {
                adj.add(new ArrayList<>());
            }
            
            for (int[] flight : flights) {
                adj.get(flight[0]).add(new int[]{flight[1], flight[2]});
            }
            
            // 使用优先队列的Dijkstra算法
            PriorityQueue<Node> pq = new PriorityQueue<>();
            pq.offer(new Node(src, 0, 0));
            
            // 记录到达每个城市的最小中转次数
            int[] minStops = new int[n];
            Arrays.fill(minStops, Integer.MAX_VALUE);
            minStops[src] = 0;
            
            while (!pq.isEmpty()) {
                Node current = pq.poll();
                
                // 如果到达目的地，返回花费
                if (current.city == dst) {
                    return current.cost;
                }
                
                // 如果中转次数超过限制，或者已经找到了更优的路径，跳过
                if (current.stops > k || current.stops > minStops[current.city]) {
                    continue;
                }
                
                // 更新到达当前城市的最小中转次数
                minStops[current.city] = current.stops;
                
                // 遍历当前城市的邻居
                for (int[] neighbor : adj.get(current.city)) {
                    int nextCity = neighbor[0];
                    int price = neighbor[1];
                    int newCost = current.cost + price;
                    int newStops = current.stops + 1;
                    
                    pq.offer(new Node(nextCity, newCost, newStops));
                }
            }
            
            return -1; // 无法到达目的地
        }
    }
    
    // 测试方法
    public static void main(String[] args) {
        Solution solution = new Solution();
        
        // 测试用例1
        int n1 = 3;
        int[][] flights1 = {{0,1,100},{1,2,100},{0,2,500}};
        int src1 = 0, dst1 = 2, k1 = 1;
        System.out.println("测试用例1:");
        System.out.println("城市数: " + n1);
        System.out.println("航班: " + Arrays.deepToString(flights1));
        System.out.println("起点: " + src1 + ", 终点: " + dst1 + ", 最多中转: " + k1);
        System.out.println("最低花费: " + solution.findCheapestPrice(n1, flights1, src1, dst1, k1));
        System.out.println("标准解法结果: " + solution.findCheapestPrice2(n1, flights1, src1, dst1, k1));
        System.out.println();
        
        // 测试用例2
        int n2 = 3;
        int[][] flights2 = {{0,1,100},{1,2,100},{0,2,500}};
        int src2 = 0, dst2 = 2, k2 = 0;
        System.out.println("测试用例2:");
        System.out.println("城市数: " + n2);
        System.out.println("航班: " + Arrays.deepToString(flights2));
        System.out.println("起点: " + src2 + ", 终点: " + dst2 + ", 最多中转: " + k2);
        System.out.println("最低花费: " + solution.findCheapestPrice(n2, flights2, src2, dst2, k2));
        System.out.println("标准解法结果: " + solution.findCheapestPrice2(n2, flights2, src2, dst2, k2));
        System.out.println();
        
        // 测试用例3
        int n3 = 4;
        int[][] flights3 = {{0,1,1},{0,2,5},{1,2,1},{2,3,1}};
        int src3 = 0, dst3 = 3, k3 = 1;
        System.out.println("测试用例3:");
        System.out.println("城市数: " + n3);
        System.out.println("航班: " + Arrays.deepToString(flights3));
        System.out.println("起点: " + src3 + ", 终点: " + dst3 + ", 最多中转: " + k3);
        System.out.println("最低花费: " + solution.findCheapestPrice(n3, flights3, src3, dst3, k3));
        System.out.println("标准解法结果: " + solution.findCheapestPrice2(n3, flights3, src3, dst3, k3));
    }
}

===============================================

文件: leetcode_787_cheapest_flights_within_k_stops.cpp
===============================================
// LeetCode 787 Cheapest Flights Within K Stops
// C++ 实现

/**
 * LeetCode 787 Cheapest Flights Within K Stops
 * 
 * 题目描述：
 * 有 n 个城市通过一些航班连接。给你一个数组 flights ，其中 flights[i] = [fromi, toi, pricei] ，
 * 表示该航班都从城市 fromi 开始，以价格 pricei 抵达 toi。
 * 现在给定所有的城市和航班，以及出发城市 src 和目的地 dst，
 * 你的任务是找到一条最多经过 k 站中转的路线，使得从 src 到 dst 的价格最便宜，
 * 并返回该价格。如果不存在这样的路线，则输出 -1。
 * 
 * 解题思路：
 * 我们可以使用Dijkstra算法的变种或Bellman-Ford算法来解决这个问题。
 * 由于限制了最多经过k站中转，我们可以使用修改版的Bellman-Ford算法。
 * 
 * 时间复杂度：O(k * E)
 * 空间复杂度：O(n)
 */

// 由于编译环境限制，这里提供算法思路和伪代码实现

/*
#include <stdlib.h>
#include <limits.h>

int findCheapestPrice(int n, int** flights, int flightsSize, int* flightsColSize, int src, int dst, int k) {
    // 初始化距离数组
    int* dist = (int*)malloc(n * sizeof(int));
    for (int i = 0; i < n; i++) {
        dist[i] = INT_MAX;
    }
    dist[src] = 0;
    
    // 进行k+1轮松弛操作
    for (int i = 0; i <= k; i++) {
        // 创建临时距离数组
        int* temp = (int*)malloc(n * sizeof(int));
        for (int j = 0; j < n; j++) {
            temp[j] = dist[j];
        }
        
        // 松弛所有边
        for (int j = 0; j < flightsSize; j++) {
            int from = flights[j][0];
            int to = flights[j][1];
            int price = flights[j][2];
            
            if (dist[from] != INT_MAX) {
                temp[to] = (temp[to] < dist[from] + price) ? temp[to] : dist[from] + price;
            }
        }
        
        // 更新距离数组
        for (int j = 0; j < n; j++) {
            dist[j] = temp[j];
        }
        
        free(temp);
    }
    
    int result = (dist[dst] == INT_MAX) ? -1 : dist[dst];
    free(dist);
    return result;
}

// 算法核心思想：
// 1. 使用修改版的Bellman-Ford算法
// 2. 限制松弛操作的轮数为k+1轮
// 3. 使用临时数组避免同一轮中更新影响后续计算

// 时间复杂度分析：
// - 松弛操作：O(k * E)
// - 空间复杂度：O(n)
*/

// 算法应用场景：
// 1. 图论最短路径问题
// 2. 航班路线规划
// 3. 限制条件下的最优化问题

===============================================

文件: leetcode_787_cheapest_flights_within_k_stops.py
===============================================
#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
LeetCode 787 Cheapest Flights Within K Stops

题目描述：
有 n 个城市通过一些航班连接。给你一个数组 flights ，其中 flights[i] = [fromi, toi, pricei] ，
表示该航班都从城市 fromi 开始，以价格 pricei 抵达 toi。
现在给定所有的城市和航班，以及出发城市 src 和目的地 dst，
你的任务是找到一条最多经过 k 站中转的路线，使得从 src 到 dst 的价格最便宜，
并返回该价格。如果不存在这样的路线，则输出 -1。

解题思路：
我们可以使用Dijkstra算法的变种或Bellman-Ford算法来解决这个问题。
由于限制了最多经过k站中转，我们可以使用修改版的Bellman-Ford算法。

时间复杂度：O(k * E)
空间复杂度：O(n)
"""

import sys

class Solution:
    def find_cheapest_price(self, n, flights, src, dst, k):
        """
        找到最多经过k站中转的最便宜航班路线
        
        Args:
            n: 城市数量
            flights: 航班信息列表，每个元素为[from, to, price]
            src: 出发城市
            dst: 目的城市
            k: 最多中转站数
            
        Returns:
            最便宜的价格，如果不存在路线则返回-1
        """
        # 初始化距离数组
        dist = [sys.maxsize] * n
        dist[src] = 0
        
        # 进行k+1轮松弛操作
        for i in range(k + 1):
            # 创建临时距离数组
            temp = dist[:]
            
            # 松弛所有边
            for from_city, to_city, price in flights:
                if dist[from_city] != sys.maxsize:
                    temp[to_city] = min(temp[to_city], dist[from_city] + price)
            
            # 更新距离数组
            dist = temp
        
        return dist[dst] if dist[dst] != sys.maxsize else -1


# 测试方法
def main():
    solution = Solution()
    
    # 测试用例1
    n1 = 3
    flights1 = [[0,1,100],[1,2,100],[0,2,500]]
    src1, dst1, k1 = 0, 2, 1
    print("测试用例1:")
    print("城市数:", n1)
    print("航班:", flights1)
    print("出发城市:", src1, "目的城市:", dst1, "最多中转:", k1)
    print("结果:", solution.find_cheapest_price(n1, flights1, src1, dst1, k1))
    print()
    
    # 测试用例2
    n2 = 3
    flights2 = [[0,1,100],[1,2,100],[0,2,500]]
    src2, dst2, k2 = 0, 2, 0
    print("测试用例2:")
    print("城市数:", n2)
    print("航班:", flights2)
    print("出发城市:", src2, "目的城市:", dst2, "最多中转:", k2)
    print("结果:", solution.find_cheapest_price(n2, flights2, src2, dst2, k2))
    print()
    
    # 测试用例3
    n3 = 4
    flights3 = [[0,1,1],[0,2,5],[1,2,1],[2,3,1]]
    src3, dst3, k3 = 0, 3, 1
    print("测试用例3:")
    print("城市数:", n3)
    print("航班:", flights3)
    print("出发城市:", src3, "目的城市:", dst3, "最多中转:", k3)
    print("结果:", solution.find_cheapest_price(n3, flights3, src3, dst3, k3))


if __name__ == "__main__":
    main()

===============================================

文件: LeetCode_850_RectangleAreaII.java
===============================================
package class185.sweep_line_problems;

import java.util.*;

/**
 * LeetCode 850. 矩形面积II (Rectangle Area II)
 * 
 * 题目来源：https://leetcode.cn/problems/rectangle-area-ii/
 * 
 * 题目描述：
 * 我们给出了一个（轴对齐的）二维矩形列表 rectangles 。
 * 对于 rectangle[i] = [x1, y1, x2, y2] ，其中 (x1, y1) 是矩形 i 左下角的坐标， (x2, y2) 是该矩形右上角的坐标。
 * 计算平面中所有 rectangles 所覆盖的总面积。任何被两个或多个矩形覆盖的区域应只计算一次。
 * 返回总面积。因为答案可能太大，返回 10^9 + 7 的模。
 * 
 * 示例 1：
 * 输入：rectangles = [[1,1,3,3],[3,1,4,2],[3,2,4,4],[1,3,2,4],[2,3,3,4]]
 * 输出：6
 * 解释：如图所示，三个矩形代表三个矩形，红色的为绿色的为蓝色的为。它们共同覆盖了总面积为6的区域。
 * 
 * 示例 2：
 * 输入：rectangles = [[1,1,2,2],[2,2,3,3]]
 * 输出：1
 * 解释：如图所示，两个矩形之间没有重叠区域。
 * 
 * 示例 3：
 * 输入：rectangles = [[0,0,2,2],[1,0,2,3],[1,0,3,1]]
 * 输出：6
 * 解释：如图所示，三个矩形的总面积为6。
 * 
 * 提示：
 * 1 <= rectangles.length <= 200
 * rectangles[i].length == 4
 * 0 <= xi1, yi1, xi2, yi2 <= 10^9
 * 
 * 解题思路：
 * 使用扫描线算法解决矩形面积问题。核心思想是：
 * 1. 将每个矩形的左右边界转换为垂直扫描线事件
 * 2. 对所有事件按x坐标排序
 * 3. 在每个x区间内，计算y方向的覆盖长度
 * 4. 累加每个区间的面积
 * 
 * 时间复杂度：O(n^2 log n)，其中 n 是矩形的数量
 * 空间复杂度：O(n)
 * 
 * 相关题目：
 * - LeetCode 218. 天际线问题
 * - LeetCode 391. 完美矩形
 */
public class LeetCode_850_RectangleAreaII {
    
    private static final int MOD = 1000000007;
    
    /**
     * 矩形面积II的扫描线解法
     * @param rectangles 矩形数组，每个矩形是 [x1, y1, x2, y2] 形式
     * @return 覆盖的总面积
     */
    public static int rectangleArea(int[][] rectangles) {
        // 创建垂直扫描线事件
        List<int[]> events = new ArrayList<>();
        Set<Integer> yCoordinates = new HashSet<>();
        
        for (int[] rect : rectangles) {
            int x1 = rect[0];
            int y1 = rect[1];
            int x2 = rect[2];
            int y2 = rect[3];
            
            // 添加开始和结束事件
            events.add(new int[]{x1, 0, y1, y2});  // 开始事件
            events.add(new int[]{x2, 1, y1, y2});  // 结束事件
            
            // 收集所有y坐标
            yCoordinates.add(y1);
            yCoordinates.add(y2);
        }
        
        // 排序事件
        events.sort((a, b) -> Integer.compare(a[0], b[0]));
        
        // 对y坐标排序
        List<Integer> sortedY = new ArrayList<>(yCoordinates);
        Collections.sort(sortedY);
        
        // 用于跟踪当前活动的矩形
        List<int[]> activeIntervals = new ArrayList<>();
        long totalArea = 0;
        int prevX = events.get(0)[0];
        
        // 处理每个事件
        for (int[] event : events) {
            int currentX = event[0];
            long width = currentX - prevX;
            
            if (width > 0) {
                // 计算当前活动的y区间总长度
                long height = calculateActiveHeight(activeIntervals, sortedY);
                
                // 增加面积
                totalArea = (totalArea + width * height) % MOD;
            }
            
            // 更新活动区间
            if (event[1] == 0) {
                activeIntervals.add(new int[]{event[2], event[3]});
            } else {
                activeIntervals.removeIf(interval -> 
                    interval[0] == event[2] && interval[1] == event[3]);
            }
            
            prevX = currentX;
        }
        
        return (int) totalArea;
    }
    
    /**
     * 计算当前活动的y区间总长度
     * @param activeIntervals 活动区间列表
     * @param sortedY 排序后的y坐标
     * @return 总长度
     */
    private static long calculateActiveHeight(List<int[]> activeIntervals, List<Integer> sortedY) {
        if (activeIntervals.isEmpty()) {
            return 0;
        }
        
        // 合并重叠的y区间
        List<int[]> intervals = new ArrayList<>(activeIntervals);
        intervals.sort((a, b) -> Integer.compare(a[0], b[0]));
        
        long totalHeight = 0;
        int currentStart = intervals.get(0)[0];
        int currentEnd = intervals.get(0)[1];
        
        for (int i = 1; i < intervals.size(); i++) {
            if (intervals.get(i)[0] <= currentEnd) {
                // 重叠，合并区间
                currentEnd = Math.max(currentEnd, intervals.get(i)[1]);
            } else {
                // 不重叠，计算长度并更新当前区间
                totalHeight += currentEnd - currentStart;
                currentStart = intervals.get(i)[0];
                currentEnd = intervals.get(i)[1];
            }
        }
        
        // 加上最后一个区间
        totalHeight += currentEnd - currentStart;
        
        return totalHeight;
    }
    
    /**
     * 测试矩形面积II解法
     */
    public static void main(String[] args) {
        System.out.println("=== LeetCode 850. 矩形面积II ===");
        
        // 测试用例1
        System.out.println("测试用例1:");
        int[][] rectangles1 = {
            {1,1,3,3},{3,1,4,2},{3,2,4,4},{1,3,2,4},{2,3,3,4}
        };
        int result1 = rectangleArea(rectangles1);
        System.out.println("输入: " + Arrays.deepToString(rectangles1));
        System.out.println("输出: " + result1);
        System.out.println("期望: 6");
        System.out.println();
        
        // 测试用例2
        System.out.println("测试用例2:");
        int[][] rectangles2 = {
            {1,1,2,2},{2,2,3,3}
        };
        int result2 = rectangleArea(rectangles2);
        System.out.println("输入: " + Arrays.deepToString(rectangles2));
        System.out.println("输出: " + result2);
        System.out.println("期望: 1");
        System.out.println();
        
        // 测试用例3
        System.out.println("测试用例3:");
        int[][] rectangles3 = {
            {0,0,2,2},{1,0,2,3},{1,0,3,1}
        };
        int result3 = rectangleArea(rectangles3);
        System.out.println("输入: " + Arrays.deepToString(rectangles3));
        System.out.println("输出: " + result3);
        System.out.println("期望: 6");
        System.out.println();
        
        // 性能测试
        System.out.println("=== 性能测试 ===");
        Random random = new Random(42);
        int n = 200;
        int[][] rectangles = new int[n][4];
        
        for (int i = 0; i < n; i++) {
            int x1 = random.nextInt(1000);
            int y1 = random.nextInt(1000);
            int x2 = x1 + random.nextInt(100) + 1;
            int y2 = y1 + random.nextInt(100) + 1;
            rectangles[i][0] = x1;
            rectangles[i][1] = y1;
            rectangles[i][2] = x2;
            rectangles[i][3] = y2;
        }
        
        long startTime = System.nanoTime();
        int result = rectangleArea(rectangles);
        long endTime = System.nanoTime();
        
        System.out.println("200个随机矩形的总面积计算完成");
        System.out.println("总面积: " + result);
        System.out.println("运行时间: " + (endTime - startTime) / 1_000_000.0 + " ms");
    }
}

===============================================

文件: LeetCode_850_RectangleAreaIIAlternative.java
===============================================
package class008_AdvancedAlgorithmsAndDataStructures.sweep_line_problems;

import java.util.*;

/**
 * LeetCode 850. 矩形面积 II (替代解法)
 * 
 * 题目来源：https://leetcode.cn/problems/rectangle-area-ii/
 * 
 * 题目描述：
 * 我们给出了一个（轴对齐的）矩形列表 rectangles。
 * 对于每个矩形，rectangle[i] = [x1, y1, x2, y2]，
 * 其中 (x1, y1) 是矩形左下角的坐标，(x2, y2) 是右上角的坐标。
 * 找出平面中所有矩形所覆盖的总面积。任何被两个或多个矩形覆盖的区域应只计算一次。
 * 由于答案可能太大，返回结果对 10^9 + 7 取模。
 * 
 * 算法思路：
 * 这个问题可以通过以下方法解决：
 * 1. 扫描线算法：按x坐标扫描，计算每个垂直条带的面积
 * 2. 坐标压缩：压缩y坐标以减少计算量
 * 3. 线段树：维护y轴上的覆盖长度
 * 
 * 使用扫描线算法的方法：
 * 1. 创建事件列表：矩形的左边界和右边界
 * 2. 按x坐标排序事件
 * 3. 扫描所有事件，维护当前y轴上的覆盖长度
 * 4. 计算每个条带的面积并累加
 * 
 * 时间复杂度：
 * - 扫描线算法：O(n^2)
 * - 坐标压缩+扫描线：O(n^2 log n)
 * - 线段树优化：O(n log n)
 * - 空间复杂度：O(n)
 * 
 * 应用场景：
 * 1. 计算机图形学：区域填充和遮挡计算
 * 2. 地理信息系统：区域面积计算
 * 3. CAD系统：图形区域分析
 * 
 * 相关题目：
 * 1. LeetCode 218. 天际线问题
 * 2. LeetCode 56. 合并区间
 * 3. LeetCode 1094. 拼车
 */
public class LeetCode_850_RectangleAreaIIAlternative {
    
    private static final int MOD = 1000000007;
    
    /**
     * 方法1：扫描线算法（坐标压缩）
     * 时间复杂度：O(n^2 log n)
     * 空间复杂度：O(n)
     * @param rectangles 矩形数组
     * @return 覆盖的总面积
     */
    public static int rectangleAreaCoordinateCompression(int[][] rectangles) {
        int n = rectangles.length;
        if (n == 0) return 0;
        
        // 收集所有y坐标用于坐标压缩
        Set<Integer> yCoords = new HashSet<>();
        for (int[] rect : rectangles) {
            yCoords.add(rect[1]); // y1
            yCoords.add(rect[3]); // y2
        }
        
        // 排序y坐标
        List<Integer> sortedY = new ArrayList<>(yCoords);
        Collections.sort(sortedY);
        int ySize = sortedY.size();
        
        // 创建y坐标到索引的映射
        Map<Integer, Integer> yIndexMap = new HashMap<>();
        for (int i = 0; i < ySize; i++) {
            yIndexMap.put(sortedY.get(i), i);
        }
        
        // 创建事件列表：[x坐标, 矩形索引, 类型(1表示进入，-1表示离开)]
        List<int[]> events = new ArrayList<>();
        for (int i = 0; i < n; i++) {
            int[] rect = rectangles[i];
            events.add(new int[]{rect[0], i, 1});  // 左边界
            events.add(new int[]{rect[2], i, -1}); // 右边界
        }
        
        // 按x坐标排序事件
        events.sort((a, b) -> {
            if (a[0] != b[0]) {
                return Integer.compare(a[0], b[0]);
            }
            return Integer.compare(a[2], b[2]); // 离开事件优先于进入事件
        });
        
        // 记录每个y区间被覆盖的次数
        int[] coverageCount = new int[ySize];
        
        long totalArea = 0;
        int prevX = 0;
        
        // 扫描所有事件
        for (int[] event : events) {
            int x = event[0];
            int rectIndex = event[1];
            int type = event[2];
            
            // 计算前一个条带的面积
            if (x > prevX) {
                long height = 0;
                // 计算y轴上的覆盖长度
                for (int i = 0; i < ySize - 1; i++) {
                    if (coverageCount[i] > 0) {
                        height += sortedY.get(i + 1) - sortedY.get(i);
                    }
                }
                totalArea = (totalArea + (long)(x - prevX) * height) % MOD;
                prevX = x;
            }
            
            // 更新覆盖计数
            int[] rect = rectangles[rectIndex];
            int y1Index = yIndexMap.get(rect[1]);
            int y2Index = yIndexMap.get(rect[3]);
            
            for (int i = y1Index; i < y2Index; i++) {
                coverageCount[i] += type;
            }
        }
        
        return (int) totalArea;
    }
    
    /**
     * 方法2：扫描线算法（线段树优化）
     * 时间复杂度：O(n log n)
     * 空间复杂度：O(n)
     * @param rectangles 矩形数组
     * @return 覆盖的总面积
     */
    public static int rectangleAreaSegmentTree(int[][] rectangles) {
        int n = rectangles.length;
        if (n == 0) return 0;
        
        // 收集所有y坐标用于坐标压缩
        Set<Integer> yCoords = new HashSet<>();
        for (int[] rect : rectangles) {
            yCoords.add(rect[1]); // y1
            yCoords.add(rect[3]); // y2
        }
        
        // 排序y坐标
        List<Integer> sortedY = new ArrayList<>(yCoords);
        Collections.sort(sortedY);
        
        // 创建事件列表：[x坐标, y1, y2, 类型(1表示进入，-1表示离开)]
        List<int[]> events = new ArrayList<>();
        for (int[] rect : rectangles) {
            events.add(new int[]{rect[0], rect[1], rect[3], 1});  // 左边界
            events.add(new int[]{rect[2], rect[1], rect[3], -1}); // 右边界
        }
        
        // 按x坐标排序事件
        events.sort((a, b) -> {
            if (a[0] != b[0]) {
                return Integer.compare(a[0], b[0]);
            }
            return Integer.compare(a[3], b[3]); // 离开事件优先于进入事件
        });
        
        // 使用线段树维护y轴上的覆盖长度
        SegmentTree segTree = new SegmentTree(sortedY);
        
        long totalArea = 0;
        int prevX = 0;
        
        // 扫描所有事件
        for (int[] event : events) {
            int x = event[0];
            int y1 = event[1];
            int y2 = event[2];
            int type = event[3];
            
            // 计算前一个条带的面积
            if (x > prevX) {
                totalArea = (totalArea + (long)(x - prevX) * segTree.query()) % MOD;
                prevX = x;
            }
            
            // 更新线段树
            segTree.update(y1, y2, type);
        }
        
        return (int) totalArea;
    }
    
    /**
     * 线段树类（用于维护y轴上的覆盖长度）
     */
    static class SegmentTree {
        private List<Integer> coords;
        private int[] count;
        private long[] length;
        
        public SegmentTree(List<Integer> coords) {
            this.coords = coords;
            int n = coords.size();
            this.count = new int[n * 4];
            this.length = new long[n * 4];
        }
        
        public void update(int y1, int y2, int delta) {
            update(1, 0, coords.size() - 1, y1, y2, delta);
        }
        
        private void update(int node, int start, int end, int y1, int y2, int delta) {
            if (start >= end) return;
            
            if (coords.get(start) == y1 && coords.get(end) == y2) {
                count[node] += delta;
            } else {
                int mid = (start + end) / 2;
                int yMid = coords.get(mid);
                
                if (y2 <= yMid) {
                    update(node * 2, start, mid, y1, y2, delta);
                } else if (y1 >= yMid) {
                    update(node * 2 + 1, mid, end, y1, y2, delta);
                } else {
                    update(node * 2, start, mid, y1, yMid, delta);
                    update(node * 2 + 1, mid, end, yMid, y2, delta);
                }
            }
            
            // 更新当前节点的覆盖长度
            if (count[node] > 0) {
                length[node] = coords.get(end) - coords.get(start);
            } else {
                length[node] = length[node * 2] + length[node * 2 + 1];
            }
        }
        
        public long query() {
            return length[1];
        }
    }
    
    /**
     * 方法3：暴力解法（用于对比）
     * 时间复杂度：O(n^3)
     * 空间复杂度：O(n^2)
     * @param rectangles 矩形数组
     * @return 覆盖的总面积
     */
    public static int rectangleAreaBruteForce(int[][] rectangles) {
        // 找到所有可能的x和y坐标
        Set<Integer> xCoords = new HashSet<>();
        Set<Integer> yCoords = new HashSet<>();
        
        for (int[] rect : rectangles) {
            xCoords.add(rect[0]);
            xCoords.add(rect[2]);
            yCoords.add(rect[1]);
            yCoords.add(rect[3]);
        }
        
        // 排序坐标
        List<Integer> sortedX = new ArrayList<>(xCoords);
        List<Integer> sortedY = new ArrayList<>(yCoords);
        Collections.sort(sortedX);
        Collections.sort(sortedY);
        
        long totalArea = 0;
        
        // 检查每个小矩形是否被任何输入矩形覆盖
        for (int i = 0; i < sortedX.size() - 1; i++) {
            for (int j = 0; j < sortedY.size() - 1; j++) {
                int x1 = sortedX.get(i);
                int x2 = sortedX.get(i + 1);
                int y1 = sortedY.get(j);
                int y2 = sortedY.get(j + 1);
                
                // 检查是否被任何矩形覆盖
                for (int[] rect : rectangles) {
                    if (rect[0] <= x1 && x2 <= rect[2] && rect[1] <= y1 && y2 <= rect[3]) {
                        totalArea = (totalArea + (long)(x2 - x1) * (y2 - y1)) % MOD;
                        break;
                    }
                }
            }
        }
        
        return (int) totalArea;
    }
    
    /**
     * 测试函数
     */
    public static void main(String[] args) {
        System.out.println("=== 测试 LeetCode 850. 矩形面积 II (替代解法) ===");
        
        // 测试用例1
        int[][] rectangles1 = {{1,1,3,3},{3,1,4,2},{3,2,4,4},{1,3,2,4},{2,3,3,4}};
        System.out.println("测试用例1:");
        System.out.println("矩形: [[1,1,3,3],[3,1,4,2],[3,2,4,4],[1,3,2,4],[2,3,3,4]]");
        System.out.println("坐标压缩解法结果: " + rectangleAreaCoordinateCompression(rectangles1));
        System.out.println("线段树解法结果: " + rectangleAreaSegmentTree(rectangles1));
        System.out.println("暴力解法结果: " + rectangleAreaBruteForce(rectangles1));
        System.out.println("期望结果: 6");
        System.out.println();
        
        // 测试用例2
        int[][] rectangles2 = {{1,1,2,2},{2,2,3,3}};
        System.out.println("测试用例2:");
        System.out.println("矩形: [[1,1,2,2],[2,2,3,3]]");
        System.out.println("坐标压缩解法结果: " + rectangleAreaCoordinateCompression(rectangles2));
        System.out.println("线段树解法结果: " + rectangleAreaSegmentTree(rectangles2));
        System.out.println("暴力解法结果: " + rectangleAreaBruteForce(rectangles2));
        System.out.println("期望结果: 2");
        System.out.println();
        
        // 测试用例3
        int[][] rectangles3 = {{0,0,2,2},{1,0,2,3},{1,0,3,1}};
        System.out.println("测试用例3:");
        System.out.println("矩形: [[0,0,2,2],[1,0,2,3],[1,0,3,1]]");
        System.out.println("坐标压缩解法结果: " + rectangleAreaCoordinateCompression(rectangles3));
        System.out.println("线段树解法结果: " + rectangleAreaSegmentTree(rectangles3));
        System.out.println("暴力解法结果: " + rectangleAreaBruteForce(rectangles3));
        System.out.println("期望结果: 6");
        System.out.println();
        
        // 性能测试
        System.out.println("=== 性能测试 ===");
        Random random = new Random(42);
        int n = 100;
        int[][] rectangles = new int[n][4];
        for (int i = 0; i < n; i++) {
            int x1 = random.nextInt(1000);
            int y1 = random.nextInt(1000);
            int x2 = x1 + random.nextInt(100) + 1;
            int y2 = y1 + random.nextInt(100) + 1;
            rectangles[i] = new int[]{x1, y1, x2, y2};
        }
        
        long startTime = System.nanoTime();
        int result1 = rectangleAreaCoordinateCompression(rectangles);
        long endTime = System.nanoTime();
        System.out.println("坐标压缩解法处理" + n + "个矩形时间: " + (endTime - startTime) / 1_000_000.0 + " ms, 结果: " + result1);
        
        startTime = System.nanoTime();
        int result2 = rectangleAreaSegmentTree(rectangles);
        endTime = System.nanoTime();
        System.out.println("线段树解法处理" + n + "个矩形时间: " + (endTime - startTime) / 1_000_000.0 + " ms, 结果: " + result2);
    }
}

===============================================

文件: leetcode_850_rectangle_area_ii.cpp
===============================================
#include <iostream>
#include <vector>
#include <algorithm>
#include <set>
#include <map>
#include <random>
#include <chrono>

using namespace std;

/**
 * LeetCode 850. 矩形面积II (Rectangle Area II)
 * 
 * 题目来源：https://leetcode.cn/problems/rectangle-area-ii/
 * 
 * 题目描述：
 * 我们给出了一个（轴对齐的）二维矩形列表 rectangles 。
 * 对于 rectangle[i] = [x1, y1, x2, y2] ，其中 (x1, y1) 是矩形 i 左下角的坐标， (x2, y2) 是该矩形右上角的坐标。
 * 计算平面中所有 rectangles 所覆盖的总面积。任何被两个或多个矩形覆盖的区域应只计算一次。
 * 返回总面积。因为答案可能太大，返回 10^9 + 7 的模。
 * 
 * 示例 1：
 * 输入：rectangles = [[1,1,3,3],[3,1,4,2],[3,2,4,4],[1,3,2,4],[2,3,3,4]]
 * 输出：6
 * 解释：如图所示，三个矩形代表三个矩形，红色的为绿色的为蓝色的为。它们共同覆盖了总面积为6的区域。
 * 
 * 示例 2：
 * 输入：rectangles = [[1,1,2,2],[2,2,3,3]]
 * 输出：1
 * 解释：如图所示，两个矩形之间没有重叠区域。
 * 
 * 示例 3：
 * 输入：rectangles = [[0,0,2,2],[1,0,2,3],[1,0,3,1]]
 * 输出：6
 * 解释：如图所示，三个矩形的总面积为6。
 * 
 * 提示：
 * 1 <= rectangles.length <= 200
 * rectangles[i].length == 4
 * 0 <= xi1, yi1, xi2, yi2 <= 10^9
 * 
 * 解题思路：
 * 使用扫描线算法解决矩形面积问题。核心思想是：
 * 1. 将每个矩形的左右边界转换为垂直扫描线事件
 * 2. 对所有事件按x坐标排序
 * 3. 在每个x区间内，计算y方向的覆盖长度
 * 4. 累加每个区间的面积
 * 
 * 时间复杂度：O(n^2 log n)，其中 n 是矩形的数量
 * 空间复杂度：O(n)
 * 
 * 相关题目：
 * - LeetCode 218. 天际线问题
 * - LeetCode 391. 完美矩形
 */

class Solution {
private:
    static const int MOD = 1000000007;
    
public:
    /**
     * 矩形面积II的扫描线解法
     * @param rectangles 矩形数组，每个矩形是 [x1, y1, x2, y2] 形式
     * @return 覆盖的总面积
     */
    static int rectangleArea(vector<vector<int>>& rectangles) {
        // 创建垂直扫描线事件
        vector<vector<int>> events;
        set<int> yCoordinates;
        
        for (const auto& rect : rectangles) {
            int x1 = rect[0];
            int y1 = rect[1];
            int x2 = rect[2];
            int y2 = rect[3];
            
            // 添加开始和结束事件
            events.push_back({x1, 0, y1, y2});  // 开始事件
            events.push_back({x2, 1, y1, y2});  // 结束事件
            
            // 收集所有y坐标
            yCoordinates.insert(y1);
            yCoordinates.insert(y2);
        }
        
        // 排序事件
        sort(events.begin(), events.end());
        
        // 对y坐标排序
        vector<int> sortedY(yCoordinates.begin(), yCoordinates.end());
        
        // 用于跟踪当前活动的矩形
        vector<pair<int, int>> activeIntervals;
        long long totalArea = 0;
        int prevX = events[0][0];
        
        // 处理每个事件
        for (const auto& event : events) {
            int currentX = event[0];
            long long width = currentX - prevX;
            
            if (width > 0) {
                // 计算当前活动的y区间总长度
                long long height = calculateActiveHeight(activeIntervals, sortedY);
                
                // 增加面积
                totalArea = (totalArea + width * height) % MOD;
            }
            
            // 更新活动区间
            if (event[1] == 0) {
                activeIntervals.push_back({event[2], event[3]});
            } else {
                // 移除对应的区间
                activeIntervals.erase(
                    remove_if(activeIntervals.begin(), activeIntervals.end(),
                             [&event](const pair<int, int>& interval) {
                                 return interval.first == event[2] && 
                                        interval.second == event[3];
                             }),
                    activeIntervals.end()
                );
            }
            
            prevX = currentX;
        }
        
        return (int)totalArea;
    }

private:
    /**
     * 计算当前活动的y区间总长度
     * @param activeIntervals 活动区间列表
     * @param sortedY 排序后的y坐标
     * @return 总长度
     */
    static long long calculateActiveHeight(const vector<pair<int, int>>& activeIntervals, 
                                          const vector<int>& sortedY) {
        if (activeIntervals.empty()) {
            return 0;
        }
        
        // 复制并排序区间
        vector<pair<int, int>> intervals = activeIntervals;
        sort(intervals.begin(), intervals.end());
        
        long long totalHeight = 0;
        int currentStart = intervals[0].first;
        int currentEnd = intervals[0].second;
        
        for (size_t i = 1; i < intervals.size(); i++) {
            if (intervals[i].first <= currentEnd) {
                // 重叠，合并区间
                currentEnd = max(currentEnd, intervals[i].second);
            } else {
                // 不重叠，计算长度并更新当前区间
                totalHeight += currentEnd - currentStart;
                currentStart = intervals[i].first;
                currentEnd = intervals[i].second;
            }
        }
        
        // 加上最后一个区间
        totalHeight += currentEnd - currentStart;
        
        return totalHeight;
    }
};

/**
 * 测试矩形面积II解法
 */
void testRectangleArea() {
    cout << "=== LeetCode 850. 矩形面积II ===" << endl;
    
    // 测试用例1
    cout << "测试用例1:" << endl;
    vector<vector<int>> rectangles1 = {
        {1,1,3,3},{3,1,4,2},{3,2,4,4},{1,3,2,4},{2,3,3,4}
    };
    int result1 = Solution::rectangleArea(rectangles1);
    cout << "输入: ";
    for (const auto& rect : rectangles1) {
        cout << "[" << rect[0] << "," << rect[1] << "," << rect[2] << "," << rect[3] << "] ";
    }
    cout << endl;
    cout << "输出: " << result1 << endl;
    cout << "期望: 6" << endl;
    cout << endl;
    
    // 测试用例2
    cout << "测试用例2:" << endl;
    vector<vector<int>> rectangles2 = {
        {1,1,2,2},{2,2,3,3}
    };
    int result2 = Solution::rectangleArea(rectangles2);
    cout << "输入: ";
    for (const auto& rect : rectangles2) {
        cout << "[" << rect[0] << "," << rect[1] << "," << rect[2] << "," << rect[3] << "] ";
    }
    cout << endl;
    cout << "输出: " << result2 << endl;
    cout << "期望: 1" << endl;
    cout << endl;
    
    // 测试用例3
    cout << "测试用例3:" << endl;
    vector<vector<int>> rectangles3 = {
        {0,0,2,2},{1,0,2,3},{1,0,3,1}
    };
    int result3 = Solution::rectangleArea(rectangles3);
    cout << "输入: ";
    for (const auto& rect : rectangles3) {
        cout << "[" << rect[0] << "," << rect[1] << "," << rect[2] << "," << rect[3] << "] ";
    }
    cout << endl;
    cout << "输出: " << result3 << endl;
    cout << "期望: 6" << endl;
    cout << endl;
    
    // 性能测试
    cout << "=== 性能测试 ===" << endl;
    random_device rd;
    mt19937 gen(rd());
    uniform_int_distribution<int> dis(0, 1000);
    uniform_int_distribution<int> dis2(1, 100);
    
    int n = 200;
    vector<vector<int>> rectangles;
    
    for (int i = 0; i < n; i++) {
        int x1 = dis(gen);
        int y1 = dis(gen);
        int x2 = x1 + dis2(gen);
        int y2 = y1 + dis2(gen);
        rectangles.push_back({x1, y1, x2, y2});
    }
    
    auto startTime = chrono::high_resolution_clock::now();
    int result = Solution::rectangleArea(rectangles);
    auto endTime = chrono::high_resolution_clock::now();
    
    auto duration = chrono::duration_cast<chrono::microseconds>(endTime - startTime);
    
    cout << "200个随机矩形的总面积计算完成" << endl;
    cout << "总面积: " << result << endl;
    cout << "运行时间: " << duration.count() / 1000.0 << " ms" << endl;
}

int main() {
    testRectangleArea();
    return 0;
}

===============================================

文件: leetcode_850_rectangle_area_ii.py
===============================================
#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
LeetCode 850. 矩形面积II (Rectangle Area II)

题目来源：https://leetcode.cn/problems/rectangle-area-ii/

题目描述：
我们给出了一个（轴对齐的）二维矩形列表 rectangles 。
对于 rectangle[i] = [x1, y1, x2, y2] ，其中 (x1, y1) 是矩形 i 左下角的坐标， (x2, y2) 是该矩形右上角的坐标。
计算平面中所有 rectangles 所覆盖的总面积。任何被两个或多个矩形覆盖的区域应只计算一次。
返回总面积。因为答案可能太大，返回 10^9 + 7 的模。

示例 1：
输入：rectangles = [[1,1,3,3],[3,1,4,2],[3,2,4,4],[1,3,2,4],[2,3,3,4]]
输出：6
解释：如图所示，三个矩形代表三个矩形，红色的为绿色的为蓝色的为。它们共同覆盖了总面积为6的区域。

示例 2：
输入：rectangles = [[1,1,2,2],[2,2,3,3]]
输出：1
解释：如图所示，两个矩形之间没有重叠区域。

示例 3：
输入：rectangles = [[0,0,2,2],[1,0,2,3],[1,0,3,1]]
输出：6
解释：如图所示，三个矩形的总面积为6。

提示：
1 <= rectangles.length <= 200
rectangles[i].length == 4
0 <= xi1, yi1, xi2, yi2 <= 10^9

解题思路：
使用扫描线算法解决矩形面积问题。核心思想是：
1. 将每个矩形的左右边界转换为垂直扫描线事件
2. 对所有事件按x坐标排序
3. 在每个x区间内，计算y方向的覆盖长度
4. 累加每个区间的面积

时间复杂度：O(n^2 log n)，其中 n 是矩形的数量
空间复杂度：O(n)

相关题目：
- LeetCode 218. 天际线问题
- LeetCode 391. 完美矩形
"""

import random
import time

class Solution:
    MOD = 1000000007
    
    @staticmethod
    def rectangle_area(rectangles):
        """
        矩形面积II的扫描线解法
        :param rectangles: 矩形数组，每个矩形是 [x1, y1, x2, y2] 形式
        :return: 覆盖的总面积
        """
        # 创建垂直扫描线事件
        events = []
        y_coordinates = set()
        
        for x1, y1, x2, y2 in rectangles:
            # 添加开始和结束事件
            events.append([x1, 0, y1, y2])  # 开始事件
            events.append([x2, 1, y1, y2])  # 结束事件
            
            # 收集所有y坐标
            y_coordinates.add(y1)
            y_coordinates.add(y2)
        
        # 排序事件
        events.sort()
        
        # 对y坐标排序
        sorted_y = sorted(y_coordinates)
        
        # 用于跟踪当前活动的矩形
        active_intervals = []
        total_area = 0
        prev_x = events[0][0]
        
        # 处理每个事件
        for event in events:
            current_x = event[0]
            width = current_x - prev_x
            
            if width > 0:
                # 计算当前活动的y区间总长度
                height = Solution._calculate_active_height(active_intervals, sorted_y)
                
                # 增加面积
                total_area = (total_area + width * height) % Solution.MOD
            
            # 更新活动区间
            if event[1] == 0:
                active_intervals.append([event[2], event[3]])
            else:
                active_intervals = [interval for interval in active_intervals 
                                  if interval != [event[2], event[3]]]
            
            prev_x = current_x
        
        return int(total_area)
    
    @staticmethod
    def _calculate_active_height(active_intervals, sorted_y):
        """
        计算当前活动的y区间总长度
        :param active_intervals: 活动区间列表
        :param sorted_y: 排序后的y坐标
        :return: 总长度
        """
        if not active_intervals:
            return 0
        
        # 合并重叠的y区间
        intervals = sorted(active_intervals)
        
        total_height = 0
        current_start = intervals[0][0]
        current_end = intervals[0][1]
        
        for i in range(1, len(intervals)):
            if intervals[i][0] <= current_end:
                # 重叠，合并区间
                current_end = max(current_end, intervals[i][1])
            else:
                # 不重叠，计算长度并更新当前区间
                total_height += current_end - current_start
                current_start = intervals[i][0]
                current_end = intervals[i][1]
        
        # 加上最后一个区间
        total_height += current_end - current_start
        
        return total_height
    
    @staticmethod
    def test_rectangle_area():
        """测试矩形面积II解法"""
        print("=== LeetCode 850. 矩形面积II ===")
        
        # 测试用例1
        print("测试用例1:")
        rectangles1 = [
            [1,1,3,3],[3,1,4,2],[3,2,4,4],[1,3,2,4],[2,3,3,4]
        ]
        result1 = Solution.rectangle_area(rectangles1)
        print(f"输入: {rectangles1}")
        print(f"输出: {result1}")
        print("期望: 6")
        print()
        
        # 测试用例2
        print("测试用例2:")
        rectangles2 = [
            [1,1,2,2],[2,2,3,3]
        ]
        result2 = Solution.rectangle_area(rectangles2)
        print(f"输入: {rectangles2}")
        print(f"输出: {result2}")
        print("期望: 1")
        print()
        
        # 测试用例3
        print("测试用例3:")
        rectangles3 = [
            [0,0,2,2],[1,0,2,3],[1,0,3,1]
        ]
        result3 = Solution.rectangle_area(rectangles3)
        print(f"输入: {rectangles3}")
        print(f"输出: {result3}")
        print("期望: 6")
        print()
        
        # 性能测试
        print("=== 性能测试 ===")
        random.seed(42)
        n = 200
        rectangles = []
        
        for _ in range(n):
            x1 = random.randint(0, 1000)
            y1 = random.randint(0, 1000)
            x2 = x1 + random.randint(1, 100)
            y2 = y1 + random.randint(1, 100)
            rectangles.append([x1, y1, x2, y2])
        
        start_time = time.time()
        result = Solution.rectangle_area(rectangles)
        end_time = time.time()
        
        print(f"200个随机矩形的总面积计算完成")
        print(f"总面积: {result}")
        print(f"运行时间: {(end_time - start_time) * 1000:.2f} ms")

if __name__ == "__main__":
    Solution.test_rectangle_area()

===============================================

文件: LeetCode_973_KClosestPointsToOrigin.cpp
===============================================
#include <iostream>
#include <vector>
#include <algorithm>
#include <queue>
#include <random>
#include <chrono>

using namespace std;

using namespace std;

/**
 * LeetCode 973. 最接近原点的K个点
 * 
 * 问题描述：
 * 给定一个由平面上的点组成的数组 points，其中 points[i] = [xi, yi]，
 * 从中选取 k 个距离原点 (0, 0) 最近的点。可以按任意顺序返回答案。
 * 
 * 算法思路：
 * 本题可以使用多种方法解决：
 * 1. 排序法：按照距离原点的距离排序，取前k个点
 * 2. 最小堆法：维护一个大小为k的最大堆
 * 3. 快速选择法：使用快速选择算法找到第k小的元素
 * 4. 最近点对算法的变种
 * 
 * 时间复杂度：
 * - 排序法：O(n log n)
 * - 最小堆法：O(n log k)
 * - 快速选择法：O(n) 平均情况
 * 空间复杂度：O(k)
 * 
 * 应用场景：
 * 1. 机器学习中的最近邻搜索
 * 2. 地理信息系统中的最近设施查询
 * 3. 推荐系统中的相似用户查找
 * 
 * 相关题目：
 * 1. LeetCode 347. 前 K 个高频元素
 * 2. LeetCode 215. 数组中的第K个最大元素
 * 3. LeetCode 719. 找出第 k 小的距离对
 */

class LeetCode973KClosestPointsToOrigin {
public:
    /**
     * 方法1：排序法
     * 时间复杂度：O(n log n)
     * 空间复杂度：O(1)
     */
    vector<vector<int>> kClosestSort(vector<vector<int>> points, int k) {
        // 按照距离原点的平方排序（避免开方运算）
        sort(points.begin(), points.end(), [](const vector<int>& a, const vector<int>& b) {
            return (a[0]*a[0] + a[1]*a[1]) < (b[0]*b[0] + b[1]*b[1]);
        });
        
        // 返回前k个点
        return vector<vector<int>>(points.begin(), points.begin() + k);
    }
    
    /**
     * 方法2：最小堆法
     * 时间复杂度：O(n log k)
     * 空间复杂度：O(k)
     */
    vector<vector<int>> kClosestHeap(vector<vector<int>> points, int k) {
        // 使用最大堆，保持堆大小为k
        // 自定义比较器，按距离平方的负值排序（模拟最大堆）
        auto cmp = [](const pair<int, vector<int>>& a, const pair<int, vector<int>>& b) {
            return a.first > b.first;  // 最小堆
        };
        priority_queue<pair<int, vector<int>>, vector<pair<int, vector<int>>>, decltype(cmp)> maxHeap(cmp);
        
        // 遍历所有点
        for (const auto& point : points) {
            int dist = point[0]*point[0] + point[1]*point[1];
            if (maxHeap.size() < k) {
                // 堆未满，直接添加
                maxHeap.push({dist, point});
            } else if (dist < maxHeap.top().first) {
                // 当前点比堆顶更近，替换堆顶
                maxHeap.pop();
                maxHeap.push({dist, point});
            }
        }
        
        // 提取结果
        vector<vector<int>> result;
        while (!maxHeap.empty()) {
            result.push_back(maxHeap.top().second);
            maxHeap.pop();
        }
        
        return result;
    }
    
    /**
     * 方法3：快速选择法
     * 时间复杂度：O(n) 平均情况
     * 空间复杂度：O(1)
     */
    vector<vector<int>> kClosestQuickSelect(vector<vector<int>> points, int k) {
        quickSelect(points, 0, points.size() - 1, k);
        return vector<vector<int>>(points.begin(), points.begin() + k);
    }

private:
    /**
     * 计算点到原点的距离的平方
     */
    int getDistance(const vector<int>& point) {
        return point[0] * point[0] + point[1] * point[1];
    }
    
    /**
     * 交换数组中两个元素
     */
    void swap(vector<vector<int>>& points, int i, int j) {
        vector<int> temp = points[i];
        points[i] = points[j];
        points[j] = temp;
    }
    
    /**
     * 快速选择实现
     */
    void quickSelect(vector<vector<int>>& points, int left, int right, int k) {
        if (left >= right) return;
        
        // 随机选择pivot以避免最坏情况
        random_device rd;
        mt19937 gen(rd());
        uniform_int_distribution<> dis(left, right);
        int pivotIndex = dis(gen);
        swap(points, pivotIndex, right);
        
        // 分区操作
        int pivotDist = getDistance(points[right]);
        int i = left;
        
        for (int j = left; j < right; j++) {
            if (getDistance(points[j]) <= pivotDist) {
                swap(points, i, j);
                i++;
            }
        }
        
        swap(points, i, right);
        
        // 递归处理
        if (i == k - 1) {
            return;
        } else if (i < k - 1) {
            quickSelect(points, i + 1, right, k);
        } else {
            quickSelect(points, left, i - 1, k);
        }
    }
};

/**
 * 测试函数
 */
void testKClosestPoints() {
    LeetCode973KClosestPointsToOrigin solution;
    
    cout << "=== 测试 LeetCode 973. 最接近原点的K个点 ===" << endl;
    
    // 测试用例1
    vector<vector<int>> points1 = {{1,1},{2,2},{3,3}};
    int k1 = 1;
    cout << "测试用例1:" << endl;
    cout << "点集: ";
    for (const auto& point : points1) {
        cout << "[" << point[0] << "," << point[1] << "] ";
    }
    cout << endl;
    cout << "k = " << k1 << endl;
    
    auto result1 = solution.kClosestSort(points1, k1);
    cout << "排序法结果: ";
    for (const auto& point : result1) {
        cout << "[" << point[0] << "," << point[1] << "] ";
    }
    cout << endl;
    
    result1 = solution.kClosestHeap(points1, k1);
    cout << "堆法结果: ";
    for (const auto& point : result1) {
        cout << "[" << point[0] << "," << point[1] << "] ";
    }
    cout << endl;
    
    result1 = solution.kClosestQuickSelect(points1, k1);
    cout << "快速选择法结果: ";
    for (const auto& point : result1) {
        cout << "[" << point[0] << "," << point[1] << "] ";
    }
    cout << endl;
    
    // 测试用例2
    vector<vector<int>> points2 = {{3,3},{5,-1},{-2,4}};
    int k2 = 2;
    cout << "\n测试用例2:" << endl;
    cout << "点集: ";
    for (const auto& point : points2) {
        cout << "[" << point[0] << "," << point[1] << "] ";
    }
    cout << endl;
    cout << "k = " << k2 << endl;
    
    auto result2 = solution.kClosestSort(points2, k2);
    cout << "排序法结果: ";
    for (const auto& point : result2) {
        cout << "[" << point[0] << "," << point[1] << "] ";
    }
    cout << endl;
    
    result2 = solution.kClosestHeap(points2, k2);
    cout << "堆法结果: ";
    for (const auto& point : result2) {
        cout << "[" << point[0] << "," << point[1] << "] ";
    }
    cout << endl;
    
    result2 = solution.kClosestQuickSelect(points2, k2);
    cout << "快速选择法结果: ";
    for (const auto& point : result2) {
        cout << "[" << point[0] << "," << point[1] << "] ";
    }
    cout << endl;
    
    // 性能测试
    cout << "\n=== 性能测试 ===" << endl;
    mt19937 gen(42);
    uniform_int_distribution<> dis(-5000, 5000);
    int n = 10000;
    vector<vector<int>> points3(n, vector<int>(2));
    for (int i = 0; i < n; i++) {
        points3[i][0] = dis(gen);
        points3[i][1] = dis(gen);
    }
    int k3 = 100;
    
    auto startTime = chrono::high_resolution_clock::now();
    solution.kClosestSort(points3, k3);
    auto endTime = chrono::high_resolution_clock::now();
    auto duration = chrono::duration_cast<chrono::microseconds>(endTime - startTime);
    cout << "排序法处理" << n << "个点选取" << k3 << "个最近点时间: " << duration.count() / 1000.0 << " ms" << endl;
    
    startTime = chrono::high_resolution_clock::now();
    solution.kClosestHeap(points3, k3);
    endTime = chrono::high_resolution_clock::now();
    duration = chrono::duration_cast<chrono::microseconds>(endTime - startTime);
    cout << "堆法处理" << n << "个点选取" << k3 << "个最近点时间: " << duration.count() / 1000.0 << " ms" << endl;
    
    startTime = chrono::high_resolution_clock::now();
    solution.kClosestQuickSelect(points3, k3);
    endTime = chrono::high_resolution_clock::now();
    duration = chrono::duration_cast<chrono::microseconds>(endTime - startTime);
    cout << "快速选择法处理" << n << "个点选取" << k3 << "个最近点时间: " << duration.count() / 1000.0 << " ms" << endl;
}

int main() {
    testKClosestPoints();
    return 0;
}

===============================================

文件: LeetCode_973_KClosestPointsToOrigin.java
===============================================
package class185.closest_pair_problems;

import java.util.*;

/**
 * LeetCode 973. 最接近原点的K个点
 * 
 * 问题描述：
 * 给定一个由平面上的点组成的数组 points，其中 points[i] = [xi, yi]，
 * 从中选取 k 个距离原点 (0, 0) 最近的点。可以按任意顺序返回答案。
 * 
 * 算法思路：
 * 本题可以使用多种方法解决：
 * 1. 排序法：按照距离原点的距离排序，取前k个点
 * 2. 最小堆法：维护一个大小为k的最大堆
 * 3. 快速选择法：使用快速选择算法找到第k小的元素
 * 4. 最近点对算法的变种
 * 
 * 时间复杂度：
 * - 排序法：O(n log n)
 * - 最小堆法：O(n log k)
 * - 快速选择法：O(n) 平均情况
 * 空间复杂度：O(k)
 * 
 * 应用场景：
 * 1. 机器学习中的最近邻搜索
 * 2. 地理信息系统中的最近设施查询
 * 3. 推荐系统中的相似用户查找
 * 
 * 相关题目：
 * 1. LeetCode 347. 前 K 个高频元素
 * 2. LeetCode 215. 数组中的第K个最大元素
 * 3. LeetCode 719. 找出第 k 小的距离对
 */
public class LeetCode_973_KClosestPointsToOrigin {
    
    /**
     * 方法1：排序法
     * 时间复杂度：O(n log n)
     * 空间复杂度：O(1)
     */
    public int[][] kClosestSort(int[][] points, int k) {
        // 按照距离原点的平方排序（避免开方运算）
        Arrays.sort(points, (a, b) -> 
            (a[0]*a[0] + a[1]*a[1]) - (b[0]*b[0] + b[1]*b[1])
        );
        
        // 返回前k个点
        return Arrays.copyOfRange(points, 0, k);
    }
    
    /**
     * 方法2：最小堆法
     * 时间复杂度：O(n log k)
     * 空间复杂度：O(k)
     */
    public int[][] kClosestHeap(int[][] points, int k) {
        // 使用最大堆，保持堆大小为k
        PriorityQueue<int[]> maxHeap = new PriorityQueue<>((a, b) -> 
            (b[0]*b[0] + b[1]*b[1]) - (a[0]*a[0] + a[1]*a[1])
        );
        
        // 遍历所有点
        for (int[] point : points) {
            maxHeap.offer(point);
            // 如果堆大小超过k，移除最远的点
            if (maxHeap.size() > k) {
                maxHeap.poll();
            }
        }
        
        // 将堆中元素复制到结果数组
        int[][] result = new int[k][2];
        for (int i = 0; i < k; i++) {
            result[i] = maxHeap.poll();
        }
        
        return result;
    }
    
    /**
     * 方法3：快速选择法
     * 时间复杂度：O(n) 平均情况
     * 空间复杂度：O(1)
     */
    public int[][] kClosestQuickSelect(int[][] points, int k) {
        quickSelect(points, 0, points.length - 1, k);
        return Arrays.copyOfRange(points, 0, k);
    }
    
    /**
     * 快速选择实现
     */
    private void quickSelect(int[][] points, int left, int right, int k) {
        if (left >= right) return;
        
        // 随机选择pivot以避免最坏情况
        Random random = new Random();
        int pivotIndex = left + random.nextInt(right - left + 1);
        swap(points, pivotIndex, right);
        
        // 分区操作
        int pivotDist = getDistance(points[right]);
        int i = left;
        
        for (int j = left; j < right; j++) {
            if (getDistance(points[j]) <= pivotDist) {
                swap(points, i, j);
                i++;
            }
        }
        
        swap(points, i, right);
        
        // 递归处理
        if (i == k - 1) {
            return;
        } else if (i < k - 1) {
            quickSelect(points, i + 1, right, k);
        } else {
            quickSelect(points, left, i - 1, k);
        }
    }
    
    /**
     * 计算点到原点的距离的平方
     */
    private int getDistance(int[] point) {
        return point[0] * point[0] + point[1] * point[1];
    }
    
    /**
     * 交换数组中两个元素
     */
    private void swap(int[][] points, int i, int j) {
        int[] temp = points[i];
        points[i] = points[j];
        points[j] = temp;
    }
    
    /**
     * 测试函数
     */
    public static void main(String[] args) {
        LeetCode_973_KClosestPointsToOrigin solution = new LeetCode_973_KClosestPointsToOrigin();
        
        System.out.println("=== 测试 LeetCode 973. 最接近原点的K个点 ===");
        
        // 测试用例1
        int[][] points1 = {{1,1},{2,2},{3,3}};
        int k1 = 1;
        System.out.println("测试用例1:");
        System.out.println("点集: " + Arrays.deepToString(points1));
        System.out.println("k = " + k1);
        System.out.println("排序法结果: " + Arrays.deepToString(solution.kClosestSort(points1.clone(), k1)));
        System.out.println("堆法结果: " + Arrays.deepToString(solution.kClosestHeap(points1.clone(), k1)));
        System.out.println("快速选择法结果: " + Arrays.deepToString(solution.kClosestQuickSelect(points1.clone(), k1)));
        
        // 测试用例2
        int[][] points2 = {{3,3},{5,-1},{-2,4}};
        int k2 = 2;
        System.out.println("\n测试用例2:");
        System.out.println("点集: " + Arrays.deepToString(points2));
        System.out.println("k = " + k2);
        System.out.println("排序法结果: " + Arrays.deepToString(solution.kClosestSort(points2.clone(), k2)));
        System.out.println("堆法结果: " + Arrays.deepToString(solution.kClosestHeap(points2.clone(), k2)));
        System.out.println("快速选择法结果: " + Arrays.deepToString(solution.kClosestQuickSelect(points2.clone(), k2)));
        
        // 性能测试
        System.out.println("\n=== 性能测试 ===");
        Random random = new Random(42);
        int n = 10000;
        int[][] points3 = new int[n][2];
        for (int i = 0; i < n; i++) {
            points3[i][0] = random.nextInt(10000) - 5000;
            points3[i][1] = random.nextInt(10000) - 5000;
        }
        int k3 = 100;
        
        long startTime = System.nanoTime();
        solution.kClosestSort(points3.clone(), k3);
        long endTime = System.nanoTime();
        System.out.println("排序法处理" + n + "个点选取" + k3 + "个最近点时间: " + (endTime - startTime) / 1_000_000.0 + " ms");
        
        startTime = System.nanoTime();
        solution.kClosestHeap(points3.clone(), k3);
        endTime = System.nanoTime();
        System.out.println("堆法处理" + n + "个点选取" + k3 + "个最近点时间: " + (endTime - startTime) / 1_000_000.0 + " ms");
        
        startTime = System.nanoTime();
        solution.kClosestQuickSelect(points3.clone(), k3);
        endTime = System.nanoTime();
        System.out.println("快速选择法处理" + n + "个点选取" + k3 + "个最近点时间: " + (endTime - startTime) / 1_000_000.0 + " ms");
    }
}

===============================================

文件: leetcode_973_k_closest_points_to_origin.py
===============================================
#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
LeetCode 973. 最接近原点的K个点

问题描述：
给定一个由平面上的点组成的数组 points，其中 points[i] = [xi, yi]，
从中选取 k 个距离原点 (0, 0) 最近的点。可以按任意顺序返回答案。

算法思路：
本题可以使用多种方法解决：
1. 排序法：按照距离原点的距离排序，取前k个点
2. 最小堆法：维护一个大小为k的最大堆
3. 快速选择法：使用快速选择算法找到第k小的元素
4. 最近点对算法的变种

时间复杂度：
- 排序法：O(n log n)
- 最小堆法：O(n log k)
- 快速选择法：O(n) 平均情况
空间复杂度：O(k)

应用场景：
1. 机器学习中的最近邻搜索
2. 地理信息系统中的最近设施查询
3. 推荐系统中的相似用户查找

相关题目：
1. LeetCode 347. 前 K 个高频元素
2. LeetCode 215. 数组中的第K个最大元素
3. LeetCode 719. 找出第 k 小的距离对
"""

import heapq
import random
import time

class LeetCode973KClosestPointsToOrigin:
    """LeetCode 973. 最接近原点的K个点解法实现"""
    
    def k_closest_sort(self, points, k):
        """
        方法1：排序法
        时间复杂度：O(n log n)
        空间复杂度：O(1)
        """
        # 按照距离原点的平方排序（避免开方运算）
        points.sort(key=lambda point: point[0]**2 + point[1]**2)
        # 返回前k个点
        return points[:k]
    
    def k_closest_heap(self, points, k):
        """
        方法2：最小堆法
        时间复杂度：O(n log k)
        空间复杂度：O(k)
        """
        # 使用最大堆，保持堆大小为k
        # Python的heapq是最小堆，所以我们存储负距离来模拟最大堆
        max_heap = []
        
        # 遍历所有点
        for point in points:
            dist = point[0]**2 + point[1]**2
            if len(max_heap) < k:
                # 堆未满，直接添加
                heapq.heappush(max_heap, (-dist, point))
            elif dist < -max_heap[0][0]:
                # 当前点比堆顶更近，替换堆顶
                heapq.heapreplace(max_heap, (-dist, point))
        
        # 提取结果
        return [point for _, point in max_heap]
    
    def k_closest_quick_select(self, points, k):
        """
        方法3：快速选择法
        时间复杂度：O(n) 平均情况
        空间复杂度：O(1)
        """
        def get_distance(point):
            return point[0]**2 + point[1]**2
        
        def quick_select(left, right, k):
            if left >= right:
                return
            
            # 随机选择pivot以避免最坏情况
            pivot_index = random.randint(left, right)
            points[pivot_index], points[right] = points[right], points[pivot_index]
            
            # 分区操作
            pivot_dist = get_distance(points[right])
            i = left
            
            for j in range(left, right):
                if get_distance(points[j]) <= pivot_dist:
                    points[i], points[j] = points[j], points[i]
                    i += 1
            
            points[i], points[right] = points[right], points[i]
            
            # 递归处理
            if i == k - 1:
                return
            elif i < k - 1:
                quick_select(i + 1, right, k)
            else:
                quick_select(left, i - 1, k)
        
        # 复制数组以避免修改原数组
        points_copy = points[:]
        quick_select(0, len(points_copy) - 1, k)
        return points_copy[:k]
    
    @staticmethod
    def test_k_closest_points():
        """测试函数"""
        solution = LeetCode973KClosestPointsToOrigin()
        
        print("=== 测试 LeetCode 973. 最接近原点的K个点 ===")
        
        # 测试用例1
        points1 = [[1,1],[2,2],[3,3]]
        k1 = 1
        print("测试用例1:")
        print("点集:", points1)
        print("k =", k1)
        print("排序法结果:", solution.k_closest_sort([p[:] for p in points1], k1))
        print("堆法结果:", solution.k_closest_heap([p[:] for p in points1], k1))
        print("快速选择法结果:", solution.k_closest_quick_select([p[:] for p in points1], k1))
        
        # 测试用例2
        points2 = [[3,3],[5,-1],[-2,4]]
        k2 = 2
        print("\n测试用例2:")
        print("点集:", points2)
        print("k =", k2)
        print("排序法结果:", solution.k_closest_sort([p[:] for p in points2], k2))
        print("堆法结果:", solution.k_closest_heap([p[:] for p in points2], k2))
        print("快速选择法结果:", solution.k_closest_quick_select([p[:] for p in points2], k2))
        
        # 性能测试
        print("\n=== 性能测试 ===")
        random.seed(42)
        n = 10000
        points3 = [[random.randint(-5000, 5000), random.randint(-5000, 5000)] for _ in range(n)]
        k3 = 100
        
        start_time = time.time()
        solution.k_closest_sort([p[:] for p in points3], k3)
        end_time = time.time()
        print(f"排序法处理{n}个点选取{k3}个最近点时间: {(end_time - start_time) * 1000:.2f} ms")
        
        start_time = time.time()
        solution.k_closest_heap([p[:] for p in points3], k3)
        end_time = time.time()
        print(f"堆法处理{n}个点选取{k3}个最近点时间: {(end_time - start_time) * 1000:.2f} ms")
        
        start_time = time.time()
        solution.k_closest_quick_select([p[:] for p in points3], k3)
        end_time = time.time()
        print(f"快速选择法处理{n}个点选取{k3}个最近点时间: {(end_time - start_time) * 1000:.2f} ms")

if __name__ == "__main__":
    LeetCode973KClosestPointsToOrigin.test_k_closest_points()

===============================================

文件: LeetCode_995_MinimumNumberOfKConsecutiveBitFlips.java
===============================================
package class008_AdvancedAlgorithmsAndDataStructures.difference_array_problems;

import java.util.*;

/**
 * LeetCode 995. Minimum Number of K Consecutive Bit Flips
 * 
 * 题目描述：
 * 给定一个二进制数组 nums 和一个整数 k。
 * k位翻转包括选择一个长度为 k 的连续子数组，然后将子数组中的每个 0 更改为 1，
 * 每个 1 更改为 0。返回数组中不存在 0 所需的 k 位翻转的最小次数。
 * 如果不可能，则返回 -1。
 * 
 * 解题思路：
 * 使用差分数组来优化翻转操作的记录。
 * 我们从左到右遍历数组，当遇到 0 时（考虑之前的翻转影响后实际为 0），
 * 就需要进行一次翻转操作。使用差分数组记录翻转操作的影响范围。
 * 
 * 时间复杂度：O(n)
 * 空间复杂度：O(n)
 */
public class LeetCode_995_MinimumNumberOfKConsecutiveBitFlips {
    
    static class Solution {
        public int minKBitFlips(int[] nums, int k) {
            int n = nums.length;
            int[] diff = new int[n + 1]; // 差分数组
            int flips = 0; // 当前位置受到的翻转次数
            int result = 0; // 总翻转次数
            
            for (int i = 0; i < n; i++) {
                flips += diff[i]; // 更新当前位置的翻转次数
                
                // 计算当前位置的实际值
                // 如果 flips 是偶数，值不变；如果 flips 是奇数，值翻转
                int actualValue = (flips % 2 == 0) ? nums[i] : 1 - nums[i];
                
                // 如果实际值是 0，需要进行翻转
                if (actualValue == 0) {
                    // 检查是否能进行 k 位翻转（不越界）
                    if (i + k > n) {
                        return -1; // 无法完成翻转
                    }
                    
                    // 进行翻转操作
                    result++;
                    flips++; // 当前位置翻转次数加1
                    diff[i + k]--; // 在 i+k 位置减1，表示翻转影响结束
                }
            }
            
            return result;
        }
        
        // 另一种实现方式：使用滑动窗口
        public int minKBitFlips2(int[] nums, int k) {
            int n = nums.length;
            int[] flipped = new int[n]; // 记录每个位置是否被翻转
            int flips = 0; // 当前窗口内的翻转次数
            int result = 0;
            
            for (int i = 0; i < n; i++) {
                // 如果超出了窗口大小，需要移除窗口左边的翻转影响
                if (i >= k) {
                    flips -= flipped[i - k];
                }
                
                // 计算当前位置的实际值
                int actualValue = (flips % 2 == 0) ? nums[i] : 1 - nums[i];
                
                // 如果实际值是 0，需要进行翻转
                if (actualValue == 0) {
                    // 检查是否能进行 k 位翻转（不越界）
                    if (i + k > n) {
                        return -1; // 无法完成翻转
                    }
                    
                    // 进行翻转操作
                    result++;
                    flips++;
                    flipped[i] = 1; // 标记当前位置被翻转
                }
            }
            
            return result;
        }
    }
    
    // 测试方法
    public static void main(String[] args) {
        Solution solution = new Solution();
        
        // 测试用例1
        int[] nums1 = {0,1,0};
        int k1 = 1;
        System.out.println("测试用例1:");
        System.out.println("数组: " + Arrays.toString(nums1));
        System.out.println("k = " + k1);
        System.out.println("最少翻转次数: " + solution.minKBitFlips(nums1, k1));
        System.out.println("另一种解法结果: " + solution.minKBitFlips2(nums1, k1));
        System.out.println();
        
        // 测试用例2
        int[] nums2 = {1,1,0};
        int k2 = 2;
        System.out.println("测试用例2:");
        System.out.println("数组: " + Arrays.toString(nums2));
        System.out.println("k = " + k2);
        System.out.println("最少翻转次数: " + solution.minKBitFlips(nums2, k2));
        System.out.println("另一种解法结果: " + solution.minKBitFlips2(nums2, k2));
        System.out.println();
        
        // 测试用例3
        int[] nums3 = {0,0,0,1,0,1,1,0};
        int k3 = 3;
        System.out.println("测试用例3:");
        System.out.println("数组: " + Arrays.toString(nums3));
        System.out.println("k = " + k3);
        System.out.println("最少翻转次数: " + solution.minKBitFlips(nums3, k3));
        System.out.println("另一种解法结果: " + solution.minKBitFlips2(nums3, k3));
        System.out.println();
        
        // 测试用例4：无法完成翻转
        int[] nums4 = {1,1,0};
        int k4 = 4;
        System.out.println("测试用例4:");
        System.out.println("数组: " + Arrays.toString(nums4));
        System.out.println("k = " + k4);
        System.out.println("最少翻转次数: " + solution.minKBitFlips(nums4, k4));
        System.out.println("另一种解法结果: " + solution.minKBitFlips2(nums4, k4));
    }
}

===============================================

文件: leetcode_995_minimum_number_of_k_consecutive_bit_flips.cpp
===============================================
// LeetCode 995 Minimum Number of K Consecutive Bit Flips
// C++ 实现

/**
 * LeetCode 995 Minimum Number of K Consecutive Bit Flips
 * 
 * 题目描述：
 * 在仅包含 0 和 1 的数组 A 中，可以进行任意次数的翻转操作。
 * 一次翻转操作选择长度为 K 的连续子数组，然后将该子数组中的每个值都翻转。
 * 返回使数组变为全1所需的最少翻转次数。如果不可能，返回-1。
 * 
 * 解题思路：
 * 我们可以使用差分数组来优化翻转操作的记录。
 * 1. 遍历数组，当遇到0时，需要进行翻转操作
 * 2. 使用差分数组记录翻转操作的影响范围
 * 3. 通过前缀和计算当前位置的实际翻转次数
 * 4. 根据实际翻转次数判断当前位置的值
 * 
 * 时间复杂度：O(n)
 * 空间复杂度：O(n)
 */

// 由于编译环境限制，这里提供算法思路和伪代码实现

/*
int minKBitFlips(int* A, int ASize, int K) {
    // 创建差分数组记录翻转操作
    int* diff = (int*)calloc(ASize + 1, sizeof(int));
    int flips = 0; // 当前翻转次数
    int result = 0; // 总翻转次数
    
    for (int i = 0; i < ASize; i++) {
        // 通过差分数组计算当前位置的实际翻转次数
        flips += diff[i];
        
        // 判断当前位置的实际值
        // 如果A[i] + flips是偶数，说明实际值为0，需要翻转
        if ((A[i] + flips) % 2 == 0) {
            // 检查是否有足够的元素进行K长度的翻转
            if (i + K > ASize) {
                free(diff);
                return -1;
            }
            
            // 记录翻转操作
            diff[i] += 1;
            diff[i + K] -= 1;
            flips += 1;
            result += 1;
        }
    }
    
    free(diff);
    return result;
}

// 算法核心思想：
// 1. 使用差分数组记录翻转操作的影响
// 2. 通过前缀和计算当前位置的实际翻转次数
// 3. 贪心地进行翻转操作

// 时间复杂度分析：
// - 遍历数组：O(n)
// - 差分数组操作：O(1)
// - 总体时间复杂度：O(n)
// - 空间复杂度：O(n)
*/

// 算法应用场景：
// 1. 位操作问题
// 2. 贪心算法应用
// 3. 差分数组优化

===============================================

文件: leetcode_995_minimum_number_of_k_consecutive_bit_flips.py
===============================================
#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
LeetCode 995 Minimum Number of K Consecutive Bit Flips

题目描述：
在仅包含 0 和 1 的数组 A 中，可以进行任意次数的翻转操作。
一次翻转操作选择长度为 K 的连续子数组，然后将该子数组中的每个值都翻转。
返回使数组变为全1所需的最少翻转次数。如果不可能，返回-1。

解题思路：
我们可以使用差分数组来优化翻转操作的记录。
1. 遍历数组，当遇到0时，需要进行翻转操作
2. 使用差分数组记录翻转操作的影响范围
3. 通过前缀和计算当前位置的实际翻转次数
4. 根据实际翻转次数判断当前位置的值

时间复杂度：O(n)
空间复杂度：O(n)
"""

class Solution:
    def min_k_bit_flips(self, A, K):
        """
        计算最少翻转次数
        
        Args:
            A: 输入数组，只包含0和1
            K: 翻转窗口大小
            
        Returns:
            最少翻转次数，如果不可能则返回-1
        """
        n = len(A)
        # 创建差分数组记录翻转操作
        diff = [0] * (n + 1)
        flips = 0  # 当前翻转次数
        result = 0  # 总翻转次数
        
        for i in range(n):
            # 通过差分数组计算当前位置的实际翻转次数
            flips += diff[i]
            
            # 判断当前位置的实际值
            # 如果A[i] + flips是偶数，说明实际值为0，需要翻转
            if (A[i] + flips) % 2 == 0:
                # 检查是否有足够的元素进行K长度的翻转
                if i + K > n:
                    return -1
                
                # 记录翻转操作
                diff[i] += 1
                diff[i + K] -= 1
                flips += 1
                result += 1
        
        return result


# 测试方法
def main():
    solution = Solution()
    
    # 测试用例1
    A1 = [0,1,0]
    K1 = 1
    print("测试用例1:")
    print("数组:", A1)
    print("K =", K1)
    print("结果:", solution.min_k_bit_flips(A1, K1))
    print()
    
    # 测试用例2
    A2 = [1,1,0]
    K2 = 2
    print("测试用例2:")
    print("数组:", A2)
    print("K =", K2)
    print("结果:", solution.min_k_bit_flips(A2, K2))
    print()
    
    # 测试用例3
    A3 = [0,0,0,1,0,1,1,0]
    K3 = 3
    print("测试用例3:")
    print("数组:", A3)
    print("K =", K3)
    print("结果:", solution.min_k_bit_flips(A3, K3))


if __name__ == "__main__":
    main()

===============================================

文件: poj_1151_atlantis.cpp
===============================================
#include <iostream>
#include <vector>
#include <algorithm>
#include <set>
#include <random>
#include <chrono>
#include <iomanip>

using namespace std;

/**
 * POJ 1151 Atlantis (矩形面积并)
 * 
 * 题目来源：http://poj.org/problem?id=1151
 * 
 * 题目描述：
 * 给定一些矩形，求这些矩形的总面积（重叠部分只计算一次）。
 * 
 * 输入格式：
 * 输入包含多个测试用例。每个测试用例以一个整数n开始，表示矩形的数量。
 * 接下来n行，每行包含四个实数x1, y1, x2, y2，表示一个矩形的左下角和右上角坐标。
 * 当n=0时输入结束。
 * 
 * 输出格式：
 * 对于每个测试用例，输出一行"Test case #k"，其中k是测试用例编号。
 * 然后输出一行"Total explored area: a"，其中a是总面积，保留两位小数。
 * 每个测试用例后输出一个空行。
 * 
 * 示例输入：
 * 2
 * 10 10 20 20
 * 15 15 25 25.5
 * 0
 * 
 * 示例输出：
 * Test case #1
 * Total explored area: 180.00
 * 
 * 解题思路：
 * 使用扫描线算法解决矩形面积并问题。核心思想是：
 * 1. 将每个矩形的左右边界转换为垂直扫描线事件
 * 2. 对所有事件按x坐标排序
 * 3. 在每个x区间内，计算y方向的覆盖长度
 * 4. 累加每个区间的面积
 * 
 * 时间复杂度：O(n^2 log n)，其中 n 是矩形的数量
 * 空间复杂度：O(n)
 * 
 * 相关题目：
 * - LeetCode 850. 矩形面积II
 * - LeetCode 218. 天际线问题
 */

class Solution {
public:
    /**
     * 矩形面积并的扫描线解法
     * @param rectangles 矩形数组，每个矩形是 [x1, y1, x2, y2] 形式
     * @return 覆盖的总面积
     */
    static double rectangleAreaUnion(vector<vector<double>>& rectangles) {
        if (rectangles.empty()) {
            return 0.0;
        }
        
        // 创建垂直扫描线事件
        vector<vector<double>> events;
        set<double> yCoordinates;
        
        for (const auto& rect : rectangles) {
            double x1 = rect[0];
            double y1 = rect[1];
            double x2 = rect[2];
            double y2 = rect[3];
            
            // 添加开始和结束事件
            events.push_back({x1, 0, y1, y2});  // 开始事件
            events.push_back({x2, 1, y1, y2});  // 结束事件
            
            // 收集所有y坐标
            yCoordinates.insert(y1);
            yCoordinates.insert(y2);
        }
        
        // 排序事件
        sort(events.begin(), events.end());
        
        // 对y坐标排序
        vector<double> sortedY(yCoordinates.begin(), yCoordinates.end());
        
        // 用于跟踪当前活动的矩形
        vector<pair<double, double>> activeIntervals;
        double totalArea = 0.0;
        double prevX = events[0][0];
        
        // 处理每个事件
        for (const auto& event : events) {
            double currentX = event[0];
            double width = currentX - prevX;
            
            if (width > 0) {
                // 计算当前活动的y区间总长度
                double height = calculateActiveHeight(activeIntervals, sortedY);
                
                // 增加面积
                totalArea += width * height;
            }
            
            // 更新活动区间
            if (event[1] == 0) {
                activeIntervals.push_back({event[2], event[3]});
            } else {
                // 移除对应的区间
                activeIntervals.erase(
                    remove_if(activeIntervals.begin(), activeIntervals.end(),
                             [&event](const pair<double, double>& interval) {
                                 return interval.first == event[2] && 
                                        interval.second == event[3];
                             }),
                    activeIntervals.end()
                );
            }
            
            prevX = currentX;
        }
        
        return totalArea;
    }

private:
    /**
     * 计算当前活动的y区间总长度
     * @param activeIntervals 活动区间列表
     * @param sortedY 排序后的y坐标
     * @return 总长度
     */
    static double calculateActiveHeight(const vector<pair<double, double>>& activeIntervals, 
                                      const vector<double>& sortedY) {
        if (activeIntervals.empty()) {
            return 0.0;
        }
        
        // 复制并排序区间
        vector<pair<double, double>> intervals = activeIntervals;
        sort(intervals.begin(), intervals.end());
        
        double totalHeight = 0.0;
        double currentStart = intervals[0].first;
        double currentEnd = intervals[0].second;
        
        for (size_t i = 1; i < intervals.size(); i++) {
            if (intervals[i].first <= currentEnd) {
                // 重叠，合并区间
                currentEnd = max(currentEnd, intervals[i].second);
            } else {
                // 不重叠，计算长度并更新当前区间
                totalHeight += currentEnd - currentStart;
                currentStart = intervals[i].first;
                currentEnd = intervals[i].second;
            }
        }
        
        // 加上最后一个区间
        totalHeight += currentEnd - currentStart;
        
        return totalHeight;
    }
};

/**
 * 测试矩形面积并解法
 */
void testRectangleAreaUnion() {
    cout << "=== POJ 1151 Atlantis ===" << endl;
    
    // 测试用例1
    cout << "测试用例1:" << endl;
    vector<vector<double>> rectangles1 = {
        {10, 10, 20, 20},
        {15, 15, 25, 25.5}
    };
    double result1 = Solution::rectangleAreaUnion(rectangles1);
    cout << "输入: ";
    for (const auto& rect : rectangles1) {
        cout << "[" << rect[0] << "," << rect[1] << "," << rect[2] << "," << rect[3] << "] ";
    }
    cout << endl;
    cout << "输出: " << fixed << setprecision(2) << result1 << endl;
    cout << "期望: 180.00" << endl;
    cout << endl;
    
    // 测试用例2
    cout << "测试用例2:" << endl;
    vector<vector<double>> rectangles2 = {
        {0, 0, 10, 10},
        {5, 5, 15, 15}
    };
    double result2 = Solution::rectangleAreaUnion(rectangles2);
    cout << "输入: ";
    for (const auto& rect : rectangles2) {
        cout << "[" << rect[0] << "," << rect[1] << "," << rect[2] << "," << rect[3] << "] ";
    }
    cout << endl;
    cout << "输出: " << fixed << setprecision(2) << result2 << endl;
    cout << "期望: 175.00" << endl;
    cout << endl;
    
    // 性能测试
    cout << "=== 性能测试 ===" << endl;
    random_device rd;
    mt19937 gen(rd());
    uniform_real_distribution<double> dis(0.0, 1000.0);
    uniform_real_distribution<double> dis2(1.0, 100.0);
    
    int n = 100;
    vector<vector<double>> rectangles;
    
    for (int i = 0; i < n; i++) {
        double x1 = dis(gen);
        double y1 = dis(gen);
        double x2 = x1 + dis2(gen);
        double y2 = y1 + dis2(gen);
        rectangles.push_back({x1, y1, x2, y2});
    }
    
    auto startTime = chrono::high_resolution_clock::now();
    double result = Solution::rectangleAreaUnion(rectangles);
    auto endTime = chrono::high_resolution_clock::now();
    
    auto duration = chrono::duration_cast<chrono::microseconds>(endTime - startTime);
    
    cout << "100个随机矩形的总面积计算完成" << endl;
    cout << "总面积: " << fixed << setprecision(2) << result << endl;
    cout << "运行时间: " << duration.count() / 1000.0 << " ms" << endl;
}

int main() {
    testRectangleAreaUnion();
    return 0;
}

===============================================

文件: POJ_1151_Atlantis.java
===============================================
package class185.sweep_line_problems;

import java.util.*;

/**
 * POJ 1151 Atlantis (矩形面积并)
 * 
 * 题目来源：http://poj.org/problem?id=1151
 * 
 * 题目描述：
 * 给定一些矩形，求这些矩形的总面积（重叠部分只计算一次）。
 * 
 * 输入格式：
 * 输入包含多个测试用例。每个测试用例以一个整数n开始，表示矩形的数量。
 * 接下来n行，每行包含四个实数x1, y1, x2, y2，表示一个矩形的左下角和右上角坐标。
 * 当n=0时输入结束。
 * 
 * 输出格式：
 * 对于每个测试用例，输出一行"Test case #k"，其中k是测试用例编号。
 * 然后输出一行"Total explored area: a"，其中a是总面积，保留两位小数。
 * 每个测试用例后输出一个空行。
 * 
 * 示例输入：
 * 2
 * 10 10 20 20
 * 15 15 25 25.5
 * 0
 * 
 * 示例输出：
 * Test case #1
 * Total explored area: 180.00
 * 
 * 解题思路：
 * 使用扫描线算法解决矩形面积并问题。核心思想是：
 * 1. 将每个矩形的左右边界转换为垂直扫描线事件
 * 2. 对所有事件按x坐标排序
 * 3. 在每个x区间内，计算y方向的覆盖长度
 * 4. 累加每个区间的面积
 * 
 * 时间复杂度：O(n^2 log n)，其中 n 是矩形的数量
 * 空间复杂度：O(n)
 * 
 * 相关题目：
 * - LeetCode 850. 矩形面积II
 * - LeetCode 218. 天际线问题
 */
public class POJ_1151_Atlantis {
    
    /**
     * 矩形面积并的扫描线解法
     * @param rectangles 矩形数组，每个矩形是 [x1, y1, x2, y2] 形式
     * @return 覆盖的总面积
     */
    public static double rectangleAreaUnion(double[][] rectangles) {
        if (rectangles == null || rectangles.length == 0) {
            return 0.0;
        }
        
        // 创建垂直扫描线事件
        List<double[]> events = new ArrayList<>();
        Set<Double> yCoordinates = new HashSet<>();
        
        for (double[] rect : rectangles) {
            double x1 = rect[0];
            double y1 = rect[1];
            double x2 = rect[2];
            double y2 = rect[3];
            
            // 添加开始和结束事件
            events.add(new double[]{x1, 0, y1, y2});  // 开始事件
            events.add(new double[]{x2, 1, y1, y2});  // 结束事件
            
            // 收集所有y坐标
            yCoordinates.add(y1);
            yCoordinates.add(y2);
        }
        
        // 排序事件
        events.sort((a, b) -> Double.compare(a[0], b[0]));
        
        // 对y坐标排序
        List<Double> sortedY = new ArrayList<>(yCoordinates);
        Collections.sort(sortedY);
        
        // 用于跟踪当前活动的矩形
        List<double[]> activeIntervals = new ArrayList<>();
        double totalArea = 0.0;
        double prevX = events.get(0)[0];
        
        // 处理每个事件
        for (double[] event : events) {
            double currentX = event[0];
            double width = currentX - prevX;
            
            if (width > 0) {
                // 计算当前活动的y区间总长度
                double height = calculateActiveHeight(activeIntervals, sortedY);
                
                // 增加面积
                totalArea += width * height;
            }
            
            // 更新活动区间
            if (event[1] == 0) {
                activeIntervals.add(new double[]{event[2], event[3]});
            } else {
                activeIntervals.removeIf(interval -> 
                    interval[0] == event[2] && interval[1] == event[3]);
            }
            
            prevX = currentX;
        }
        
        return totalArea;
    }
    
    /**
     * 计算当前活动的y区间总长度
     * @param activeIntervals 活动区间列表
     * @param sortedY 排序后的y坐标
     * @return 总长度
     */
    private static double calculateActiveHeight(List<double[]> activeIntervals, List<Double> sortedY) {
        if (activeIntervals.isEmpty()) {
            return 0.0;
        }
        
        // 合并重叠的y区间
        List<double[]> intervals = new ArrayList<>(activeIntervals);
        intervals.sort((a, b) -> Double.compare(a[0], b[0]));
        
        double totalHeight = 0.0;
        double currentStart = intervals.get(0)[0];
        double currentEnd = intervals.get(0)[1];
        
        for (int i = 1; i < intervals.size(); i++) {
            if (intervals.get(i)[0] <= currentEnd) {
                // 重叠，合并区间
                currentEnd = Math.max(currentEnd, intervals.get(i)[1]);
            } else {
                // 不重叠，计算长度并更新当前区间
                totalHeight += currentEnd - currentStart;
                currentStart = intervals.get(i)[0];
                currentEnd = intervals.get(i)[1];
            }
        }
        
        // 加上最后一个区间
        totalHeight += currentEnd - currentStart;
        
        return totalHeight;
    }
    
    /**
     * 测试矩形面积并解法
     */
    public static void main(String[] args) {
        System.out.println("=== POJ 1151 Atlantis ===");
        
        // 测试用例1
        System.out.println("测试用例1:");
        double[][] rectangles1 = {
            {10, 10, 20, 20},
            {15, 15, 25, 25.5}
        };
        double result1 = rectangleAreaUnion(rectangles1);
        System.out.println("输入: " + Arrays.deepToString(rectangles1));
        System.out.printf("输出: %.2f\n", result1);
        System.out.println("期望: 180.00");
        System.out.println();
        
        // 测试用例2
        System.out.println("测试用例2:");
        double[][] rectangles2 = {
            {0, 0, 10, 10},
            {5, 5, 15, 15}
        };
        double result2 = rectangleAreaUnion(rectangles2);
        System.out.println("输入: " + Arrays.deepToString(rectangles2));
        System.out.printf("输出: %.2f\n", result2);
        System.out.println("期望: 175.00");
        System.out.println();
        
        // 性能测试
        System.out.println("=== 性能测试 ===");
        Random random = new Random(42);
        int n = 100;
        double[][] rectangles = new double[n][4];
        
        for (int i = 0; i < n; i++) {
            double x1 = random.nextDouble() * 1000;
            double y1 = random.nextDouble() * 1000;
            double x2 = x1 + random.nextDouble() * 100 + 1;
            double y2 = y1 + random.nextDouble() * 100 + 1;
            rectangles[i][0] = x1;
            rectangles[i][1] = y1;
            rectangles[i][2] = x2;
            rectangles[i][3] = y2;
        }
        
        long startTime = System.nanoTime();
        double result = rectangleAreaUnion(rectangles);
        long endTime = System.nanoTime();
        
        System.out.println("100个随机矩形的总面积计算完成");
        System.out.printf("总面积: %.2f\n", result);
        System.out.println("运行时间: " + (endTime - startTime) / 1_000_000.0 + " ms");
    }
}

===============================================

文件: poj_1151_atlantis.py
===============================================
#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
POJ 1151 Atlantis (矩形面积并)

题目来源：http://poj.org/problem?id=1151

题目描述：
给定一些矩形，求这些矩形的总面积（重叠部分只计算一次）。

输入格式：
输入包含多个测试用例。每个测试用例以一个整数n开始，表示矩形的数量。
接下来n行，每行包含四个实数x1, y1, x2, y2，表示一个矩形的左下角和右上角坐标。
当n=0时输入结束。

输出格式：
对于每个测试用例，输出一行"Test case #k"，其中k是测试用例编号。
然后输出一行"Total explored area: a"，其中a是总面积，保留两位小数。
每个测试用例后输出一个空行。

示例输入：
2
10 10 20 20
15 15 25 25.5
0

示例输出：
Test case #1
Total explored area: 180.00

解题思路：
使用扫描线算法解决矩形面积并问题。核心思想是：
1. 将每个矩形的左右边界转换为垂直扫描线事件
2. 对所有事件按x坐标排序
3. 在每个x区间内，计算y方向的覆盖长度
4. 累加每个区间的面积

时间复杂度：O(n^2 log n)，其中 n 是矩形的数量
空间复杂度：O(n)

相关题目：
- LeetCode 850. 矩形面积II
- LeetCode 218. 天际线问题
"""

import random
import time

class Solution:
    @staticmethod
    def rectangle_area_union(rectangles):
        """
        矩形面积并的扫描线解法
        :param rectangles: 矩形数组，每个矩形是 [x1, y1, x2, y2] 形式
        :return: 覆盖的总面积
        """
        if not rectangles:
            return 0.0
        
        # 创建垂直扫描线事件
        events = []
        y_coordinates = set()
        
        for x1, y1, x2, y2 in rectangles:
            # 添加开始和结束事件
            events.append([x1, 0, y1, y2])  # 开始事件
            events.append([x2, 1, y1, y2])  # 结束事件
            
            # 收集所有y坐标
            y_coordinates.add(y1)
            y_coordinates.add(y2)
        
        # 排序事件
        events.sort()
        
        # 对y坐标排序
        sorted_y = sorted(y_coordinates)
        
        # 用于跟踪当前活动的矩形
        active_intervals = []
        total_area = 0.0
        prev_x = events[0][0]
        
        # 处理每个事件
        for event in events:
            current_x = event[0]
            width = current_x - prev_x
            
            if width > 0:
                # 计算当前活动的y区间总长度
                height = Solution._calculate_active_height(active_intervals, sorted_y)
                
                # 增加面积
                total_area += width * height
            
            # 更新活动区间
            if event[1] == 0:
                active_intervals.append([event[2], event[3]])
            else:
                active_intervals = [interval for interval in active_intervals 
                                  if interval != [event[2], event[3]]]
            
            prev_x = current_x
        
        return total_area
    
    @staticmethod
    def _calculate_active_height(active_intervals, sorted_y):
        """
        计算当前活动的y区间总长度
        :param active_intervals: 活动区间列表
        :param sorted_y: 排序后的y坐标
        :return: 总长度
        """
        if not active_intervals:
            return 0.0
        
        # 合并重叠的y区间
        intervals = sorted(active_intervals)
        
        total_height = 0.0
        current_start = intervals[0][0]
        current_end = intervals[0][1]
        
        for i in range(1, len(intervals)):
            if intervals[i][0] <= current_end:
                # 重叠，合并区间
                current_end = max(current_end, intervals[i][1])
            else:
                # 不重叠，计算长度并更新当前区间
                total_height += current_end - current_start
                current_start = intervals[i][0]
                current_end = intervals[i][1]
        
        # 加上最后一个区间
        total_height += current_end - current_start
        
        return total_height
    
    @staticmethod
    def test_rectangle_area_union():
        """测试矩形面积并解法"""
        print("=== POJ 1151 Atlantis ===")
        
        # 测试用例1
        print("测试用例1:")
        rectangles1 = [
            [10, 10, 20, 20],
            [15, 15, 25, 25.5]
        ]
        result1 = Solution.rectangle_area_union(rectangles1)
        print(f"输入: {rectangles1}")
        print(f"输出: {result1:.2f}")
        print("期望: 180.00")
        print()
        
        # 测试用例2
        print("测试用例2:")
        rectangles2 = [
            [0, 0, 10, 10],
            [5, 5, 15, 15]
        ]
        result2 = Solution.rectangle_area_union(rectangles2)
        print(f"输入: {rectangles2}")
        print(f"输出: {result2:.2f}")
        print("期望: 175.00")
        print()
        
        # 性能测试
        print("=== 性能测试 ===")
        random.seed(42)
        n = 100
        rectangles = []
        
        for _ in range(n):
            x1 = random.random() * 1000
            y1 = random.random() * 1000
            x2 = x1 + random.random() * 100 + 1
            y2 = y1 + random.random() * 100 + 1
            rectangles.append([x1, y1, x2, y2])
        
        start_time = time.time()
        result = Solution.rectangle_area_union(rectangles)
        end_time = time.time()
        
        print(f"100个随机矩形的总面积计算完成")
        print(f"总面积: {result:.2f}")
        print(f"运行时间: {(end_time - start_time) * 1000:.2f} ms")

if __name__ == "__main__":
    Solution.test_rectangle_area_union()

===============================================

文件: SparseTableRMQ.java
===============================================
package class185.sparse_table_problems;

import java.util.*;

/**
 * 稀疏表（Sparse Table）实现 - RMQ问题解决方案 (Java版本)
 * 
 * 算法思路：
 * 稀疏表是一种用于解决范围查询问题的数据结构，特别适用于：
 * 1. 范围最小值查询（RMQ）
 * 2. 范围最大值查询
 * 3. 其他满足结合律和幂等性的操作
 * 
 * 稀疏表通过预处理，在O(n log n)时间内构建一个二维数组，
 * 然后在O(1)时间内回答任何范围查询。
 * 
 * 时间复杂度：
 * - 预处理：O(n log n)
 * - 查询：O(1)
 * 空间复杂度：O(n log n)
 * 
 * 应用场景：
 * 1. 数据库：范围查询优化
 * 2. 图像处理：区域统计信息计算
 * 3. 金融：时间序列分析中的极值查询
 * 4. 算法竞赛：优化动态规划中的范围查询
 * 
 * 相关题目：
 * 1. LeetCode 2444. 统计定界子数组的数目
 * 2. POJ 3264 Balanced Lineup
 * 3. SPOJ RMQSQ - Range Minimum Query
 */
public class SparseTableRMQ {
    private int[] data;
    private int[][] stMin;  // 用于范围最小值查询的稀疏表
    private int[][] stMax;  // 用于范围最大值查询的稀疏表
    private int[] logTable;
    private int n;
    
    /**
     * 构造函数
     * @param data 输入数组
     */
    public SparseTableRMQ(int[] data) {
        if (data == null || data.length == 0) {
            throw new IllegalArgumentException("输入数组不能为空");
        }
        
        this.data = data.clone();
        this.n = data.length;
        
        // 预计算log表
        precomputeLogTable();
        
        // 构建稀疏表
        buildSparseTable();
    }
    
    /**
     * 预计算log2值表
     */
    private void precomputeLogTable() {
        logTable = new int[n + 1];
        logTable[1] = 0;
        for (int i = 2; i <= n; i++) {
            logTable[i] = logTable[i / 2] + 1;
        }
    }
    
    /**
     * 构建稀疏表
     */
    private void buildSparseTable() {
        int k = logTable[n] + 1;
        
        // 初始化稀疏表
        stMin = new int[k][n];
        stMax = new int[k][n];
        
        // 初始化k=0的情况（长度为1的区间）
        for (int i = 0; i < n; i++) {
            stMin[0][i] = data[i];
            stMax[0][i] = data[i];
        }
        
        // 动态规划构建其他k值
        for (int j = 1; (1 << j) <= n; j++) {
            for (int i = 0; i + (1 << j) <= n; i++) {
                int prevLen = 1 << (j - 1);
                // 范围最小值查询
                stMin[j][i] = Math.min(stMin[j-1][i], stMin[j-1][i + prevLen]);
                // 范围最大值查询
                stMax[j][i] = Math.max(stMax[j-1][i], stMax[j-1][i + prevLen]);
            }
        }
    }
    
    /**
     * 范围最小值查询
     * 时间复杂度：O(1)
     * @param left 左边界（包含）
     * @param right 右边界（包含）
     * @return 区间内的最小值
     */
    public int queryMin(int left, int right) {
        if (left < 0 || right >= n || left > right) {
            throw new IllegalArgumentException("查询范围无效");
        }
        
        int length = right - left + 1;
        int k = logTable[length];
        
        return Math.min(stMin[k][left], stMin[k][right - (1 << k) + 1]);
    }
    
    /**
     * 范围最大值查询
     * 时间复杂度：O(1)
     * @param left 左边界（包含）
     * @param right 右边界（包含）
     * @return 区间内的最大值
     */
    public int queryMax(int left, int right) {
        if (left < 0 || right >= n || left > right) {
            throw new IllegalArgumentException("查询范围无效");
        }
        
        int length = right - left + 1;
        int k = logTable[length];
        
        return Math.max(stMax[k][left], stMax[k][right - (1 << k) + 1]);
    }
    
    /**
     * 批量处理范围查询
     * @param queries 查询数组，每个查询是[left, right]形式的数组
     * @param isMinQuery 是否是最小值查询，否则是最大值查询
     * @return 查询结果数组
     */
    public int[] batchQuery(int[][] queries, boolean isMinQuery) {
        if (queries == null) {
            throw new IllegalArgumentException("查询数组不能为空");
        }
        
        int[] results = new int[queries.length];
        for (int i = 0; i < queries.length; i++) {
            int[] query = queries[i];
            if (query == null || query.length != 2) {
                throw new IllegalArgumentException("查询格式无效");
            }
            
            if (isMinQuery) {
                results[i] = queryMin(query[0], query[1]);
            } else {
                results[i] = queryMax(query[0], query[1]);
            }
        }
        
        return results;
    }
    
    /**
     * 测试稀疏表
     */
    public static void main(String[] args) {
        System.out.println("=== 测试稀疏表 ===");
        
        int[] data = {1, 3, 5, 7, 9, 11, 13, 15, 17};
        
        SparseTableRMQ st = new SparseTableRMQ(data);
        
        // 测试最小值查询
        System.out.println("测试最小值查询:");
        System.out.println("区间[1, 5]的最小值: " + st.queryMin(1, 5));  // 应该是3
        System.out.println("区间[0, 8]的最小值: " + st.queryMin(0, 8));  // 应该是1
        System.out.println("区间[4, 7]的最小值: " + st.queryMin(4, 7));  // 应该是9
        
        // 测试最大值查询
        System.out.println("\n测试最大值查询:");
        System.out.println("区间[1, 5]的最大值: " + st.queryMax(1, 5));  // 应该是11
        System.out.println("区间[0, 8]的最大值: " + st.queryMax(0, 8));  // 应该是17
        System.out.println("区间[4, 7]的最大值: " + st.queryMax(4, 7));  // 应该是15
        
        // 测试批量查询
        System.out.println("\n测试批量查询:");
        int[][] queries = {
            {0, 2}, {1, 5}, {3, 7}, {2, 8}
        };
        
        int[] minResults = st.batchQuery(queries, true);
        System.out.println("批量最小值查询结果: " + Arrays.toString(minResults));
        
        int[] maxResults = st.batchQuery(queries, false);
        System.out.println("批量最大值查询结果: " + Arrays.toString(maxResults));
        
        // 性能测试
        System.out.println("\n=== 性能测试 ===");
        Random random = new Random(42);
        
        // 生成大数据集
        int n = 100000;
        int[] largeData = new int[n];
        for (int i = 0; i < n; i++) {
            largeData[i] = random.nextInt(1000000) + 1;
        }
        
        long startTime = System.nanoTime();
        SparseTableRMQ largeST = new SparseTableRMQ(largeData);
        long buildTime = System.nanoTime() - startTime;
        
        // 执行大量查询
        int numQueries = 100000;
        int[][] largeQueries = new int[numQueries][2];
        for (int i = 0; i < numQueries; i++) {
            // 生成有效的查询范围
            int left = random.nextInt(n - 1);
            int right = left + random.nextInt(Math.min(1000, n - left - 1)) + 1;
            largeQueries[i][0] = left;
            largeQueries[i][1] = right;
        }
        
        startTime = System.nanoTime();
        for (int i = 0; i < numQueries; i++) {
            largeST.queryMin(largeQueries[i][0], largeQueries[i][1]);
        }
        long queryTime = System.nanoTime() - startTime;
        
        System.out.println("构建100000个元素的稀疏表时间: " + buildTime / 1_000_000.0 + " ms");
        System.out.println("执行100000次查询时间: " + queryTime / 1_000_000.0 + " ms");
        System.out.println("平均每次查询时间: " + queryTime / 1_000.0 / numQueries + " μs");
    }
}

===============================================

文件: sparse_table.py
===============================================
#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
稀疏表（Sparse Table）实现 (Python版本)

算法思路：
稀疏表是一种用于解决范围查询问题的数据结构，特别适用于：
1. 范围最小值查询（RMQ）
2. 范围最大值查询
3. 其他满足结合律和幂等性的操作

稀疏表通过预处理，在O(n log n)时间内构建一个二维数组，
然后在O(1)时间内回答任何范围查询。

时间复杂度：
- 预处理：O(n log n)
- 查询：O(1)
空间复杂度：O(n log n)

应用场景：
1. 数据库：范围查询优化
2. 图像处理：区域统计信息计算
3. 金融：时间序列分析中的极值查询
4. 算法竞赛：优化动态规划中的范围查询
"""

import math

class SparseTable:
    """稀疏表实现类"""
    
    def __init__(self, data, is_min=True):
        """
        构造函数
        :param data: 输入数组
        :param is_min: 是否是最小值查询（True）或最大值查询（False）
        """
        if not data:
            raise ValueError("输入数组不能为空")
        
        self.data = data
        self.n = len(data)
        self.is_min = is_min
        
        # 计算log表
        self._precompute_log_table()
        
        # 计算稀疏表
        self._compute_sparse_table()
    
    def _precompute_log_table(self):
        """预计算log2值表"""
        self.log_table = [0] * (self.n + 1)
        self.log_table[1] = 0
        for i in range(2, self.n + 1):
            self.log_table[i] = self.log_table[i // 2] + 1
    
    def _compute_sparse_table(self):
        """计算稀疏表"""
        # 计算稀疏表的大小
        k = self.log_table[self.n] + 1
        self.st = [[0 for _ in range(self.n)] for _ in range(k)]
        
        # 初始化第一行（区间长度为1）
        for i in range(self.n):
            self.st[0][i] = i  # 存储索引而不是值，便于范围查询
        
        # 填充其他行
        for j in range(1, k):
            for i in range(self.n - (1 << j) + 1):
                prev_len = 1 << (j - 1)
                left = self.st[j - 1][i]
                right = self.st[j - 1][i + prev_len]
                
                # 根据查询类型选择最小或最大值
                if self.is_min:
                    self.st[j][i] = left if self.data[left] <= self.data[right] else right
                else:
                    self.st[j][i] = left if self.data[left] >= self.data[right] else right
    
    def query(self, left, right):
        """
        区间查询操作
        时间复杂度：O(1)
        :param left: 左边界（包含）
        :param right: 右边界（包含）
        :return: 区间内的最小/最大值
        """
        if left < 0 or right >= self.n or left > right:
            raise ValueError("查询范围无效")
        
        length = right - left + 1
        k = self.log_table[length]
        
        left_idx = self.st[k][left]
        right_idx = self.st[k][right - (1 << k) + 1]
        
        if self.is_min:
            return min(self.data[left_idx], self.data[right_idx])
        else:
            return max(self.data[left_idx], self.data[right_idx])
    
    def process_offline_queries(self, queries):
        """
        离线查询处理
        :param queries: 包含多个查询的数组，每个查询是 [left, right] 形式
        :return: 查询结果数组
        """
        results = []
        for left, right in queries:
            results.append(self.query(left, right))
        return results
    
    @staticmethod
    def test_sparse_table():
        """测试稀疏表"""
        print("=== 测试稀疏表 ===")
        
        data = [1, 3, 5, 7, 9, 11, 13, 15, 17]
        
        # 测试最小值查询
        print("测试最小值查询:")
        min_st = SparseTable(data, True)
        print(f"区间[1, 5]的最小值: {min_st.query(1, 5)}")  # 应该是3
        print(f"区间[0, 8]的最小值: {min_st.query(0, 8)}")  # 应该是1
        print(f"区间[4, 7]的最小值: {min_st.query(4, 7)}")  # 应该是9
        
        # 测试最大值查询
        print("\n测试最大值查询:")
        max_st = SparseTable(data, False)
        print(f"区间[1, 5]的最大值: {max_st.query(1, 5)}")  # 应该是11
        print(f"区间[0, 8]的最大值: {max_st.query(0, 8)}")  # 应该是17
        print(f"区间[4, 7]的最大值: {max_st.query(4, 7)}")  # 应该是15
        
        # 测试离线查询
        print("\n测试离线查询:")
        queries = [
            [0, 2], [1, 5], [3, 7], [2, 8]
        ]
        
        min_results = min_st.process_offline_queries(queries)
        print("离线最小值查询结果:", min_results)
        
        max_results = max_st.process_offline_queries(queries)
        print("离线最大值查询结果:", max_results)
        
        # 性能测试
        print("\n=== 性能测试 ===")
        import random
        import time
        
        # 生成大数据集
        n = 100000
        large_data = [random.randint(1, 1000000) for _ in range(n)]
        
        # 构建稀疏表
        start_time = time.time()
        large_st = SparseTable(large_data, True)
        build_time = time.time() - start_time
        
        # 执行大量查询
        num_queries = 100000
        queries = []
        for _ in range(num_queries):
            # 生成有效的查询范围
            left = random.randint(0, n-2)
            right = random.randint(left+1, min(left+1000, n-1))
            queries.append((left, right))
        
        start_time = time.time()
        for left, right in queries:
            large_st.query(left, right)
        query_time = time.time() - start_time
        
        print(f"构建100000个元素的稀疏表时间: {build_time*1000:.2f} ms")
        print(f"执行100000次查询时间: {query_time*1000:.2f} ms")
        print(f"平均每次查询时间: {query_time*1000000/num_queries:.4f} μs")

if __name__ == "__main__":
    SparseTable.test_sparse_table()

===============================================

文件: sparse_table_rmq.cpp
===============================================
#include <iostream>
#include <vector>
#include <algorithm>
#include <cmath>
#include <stdexcept>
#include <memory>
#include <limits>
#include <random>
#include <chrono>

using namespace std;

/**
 * 稀疏表（Sparse Table）实现 - RMQ问题解决方案 (C++版本)
 * 
 * 算法思路：
 * 稀疏表是一种用于解决范围查询问题的数据结构，特别适用于：
 * 1. 范围最小值查询（RMQ）
 * 2. 范围最大值查询
 * 3. 其他满足结合律和幂等性的操作
 * 
 * 稀疏表通过预处理，在O(n log n)时间内构建一个二维数组，
 * 然后在O(1)时间内回答任何范围查询。
 * 
 * 时间复杂度：
 * - 预处理：O(n log n)
 * - 查询：O(1)
 * 空间复杂度：O(n log n)
 * 
 * 应用场景：
 * 1. 数据库：范围查询优化
 * 2. 图像处理：区域统计信息计算
 * 3. 金融：时间序列分析中的极值查询
 * 4. 算法竞赛：优化动态规划中的范围查询
 * 
 * 相关题目：
 * 1. LeetCode 2444. 统计定界子数组的数目
 * 2. POJ 3264 Balanced Lineup
 * 3. SPOJ RMQSQ - Range Minimum Query
 */

class SparseTableRMQ {
private:
    vector<int> data;
    vector<vector<int>> stMin;  // 用于范围最小值查询的稀疏表
    vector<vector<int>> stMax;  // 用于范围最大值查询的稀疏表
    vector<int> logTable;
    int n;
    
    /**
     * 预计算log2值表
     */
    void precomputeLogTable() {
        logTable.resize(n + 1);
        logTable[1] = 0;
        for (int i = 2; i <= n; i++) {
            logTable[i] = logTable[i / 2] + 1;
        }
    }
    
    /**
     * 构建稀疏表
     */
    void buildSparseTable() {
        int k = logTable[n] + 1;
        
        // 初始化稀疏表
        stMin.assign(k, vector<int>(n));
        stMax.assign(k, vector<int>(n));
        
        // 初始化k=0的情况（长度为1的区间）
        for (int i = 0; i < n; i++) {
            stMin[0][i] = data[i];
            stMax[0][i] = data[i];
        }
        
        // 动态规划构建其他k值
        for (int j = 1; (1 << j) <= n; j++) {
            for (int i = 0; i + (1 << j) <= n; i++) {
                int prevLen = 1 << (j - 1);
                // 范围最小值查询
                stMin[j][i] = min(stMin[j-1][i], stMin[j-1][i + prevLen]);
                // 范围最大值查询
                stMax[j][i] = max(stMax[j-1][i], stMax[j-1][i + prevLen]);
            }
        }
    }
    
public:
    /**
     * 构造函数
     * @param data 输入数组
     */
    SparseTableRMQ(const vector<int>& data) {
        if (data.empty()) {
            throw invalid_argument("输入数组不能为空");
        }
        
        this->data = data;
        this->n = data.size();
        
        // 预计算log表
        precomputeLogTable();
        
        // 构建稀疏表
        buildSparseTable();
    }
    
    /**
     * 范围最小值查询
     * 时间复杂度：O(1)
     * @param left 左边界（包含）
     * @param right 右边界（包含）
     * @return 区间内的最小值
     */
    int queryMin(int left, int right) {
        if (left < 0 || right >= n || left > right) {
            throw invalid_argument("查询范围无效");
        }
        
        int length = right - left + 1;
        int k = logTable[length];
        
        return min(stMin[k][left], stMin[k][right - (1 << k) + 1]);
    }
    
    /**
     * 范围最大值查询
     * 时间复杂度：O(1)
     * @param left 左边界（包含）
     * @param right 右边界（包含）
     * @return 区间内的最大值
     */
    int queryMax(int left, int right) {
        if (left < 0 || right >= n || left > right) {
            throw invalid_argument("查询范围无效");
        }
        
        int length = right - left + 1;
        int k = logTable[length];
        
        return max(stMax[k][left], stMax[k][right - (1 << k) + 1]);
    }
    
    /**
     * 批量处理范围查询
     * @param queries 查询数组，每个查询是[left, right]形式的数组
     * @param isMinQuery 是否是最小值查询，否则是最大值查询
     * @return 查询结果数组
     */
    vector<int> batchQuery(const vector<pair<int, int>>& queries, bool isMinQuery) {
        if (queries.empty()) {
            throw invalid_argument("查询数组不能为空");
        }
        
        vector<int> results;
        results.reserve(queries.size());
        
        for (const auto& query : queries) {
            if (isMinQuery) {
                results.push_back(queryMin(query.first, query.second));
            } else {
                results.push_back(queryMax(query.first, query.second));
            }
        }
        
        return results;
    }
};

/**
 * 测试稀疏表
 */
void testSparseTable() {
    cout << "=== 测试稀疏表 ===" << endl;
    
    vector<int> data = {1, 3, 5, 7, 9, 11, 13, 15, 17};
    
    SparseTableRMQ st(data);
    
    // 测试最小值查询
    cout << "测试最小值查询:" << endl;
    cout << "区间[1, 5]的最小值: " << st.queryMin(1, 5) << endl;  // 应该是3
    cout << "区间[0, 8]的最小值: " << st.queryMin(0, 8) << endl;  // 应该是1
    cout << "区间[4, 7]的最小值: " << st.queryMin(4, 7) << endl;  // 应该是9
    
    // 测试最大值查询
    cout << "\n测试最大值查询:" << endl;
    cout << "区间[1, 5]的最大值: " << st.queryMax(1, 5) << endl;  // 应该是11
    cout << "区间[0, 8]的最大值: " << st.queryMax(0, 8) << endl;  // 应该是17
    cout << "区间[4, 7]的最大值: " << st.queryMax(4, 7) << endl;  // 应该是15
    
    // 测试批量查询
    cout << "\n测试批量查询:" << endl;
    vector<pair<int, int>> queries = {
        {0, 2}, {1, 5}, {3, 7}, {2, 8}
    };
    
    vector<int> minResults = st.batchQuery(queries, true);
    cout << "批量最小值查询结果: ";
    for (int val : minResults) {
        cout << val << " ";
    }
    cout << endl;
    
    vector<int> maxResults = st.batchQuery(queries, false);
    cout << "批量最大值查询结果: ";
    for (int val : maxResults) {
        cout << val << " ";
    }
    cout << endl;
    
    // 性能测试
    cout << "\n=== 性能测试 ===" << endl;
    
    // 生成大数据集
    int n = 100000;
    vector<int> largeData(n);
    random_device rd;
    mt19937 gen(rd());
    uniform_int_distribution<int> dis(1, 1000000);
    
    for (int i = 0; i < n; i++) {
        largeData[i] = dis(gen);
    }
    
    auto startTime = chrono::high_resolution_clock::now();
    SparseTableRMQ largeST(largeData);
    auto endTime = chrono::high_resolution_clock::now();
    
    auto buildTime = chrono::duration_cast<chrono::microseconds>(endTime - startTime);
    
    // 执行大量查询
    int numQueries = 100000;
    vector<pair<int, int>> largeQueries;
    uniform_int_distribution<int> dis2(0, n - 2);
    
    for (int i = 0; i < numQueries; i++) {
        // 生成有效的查询范围
        int left = dis2(gen);
        uniform_int_distribution<int> dis3(left + 1, min(left + 1000, n - 1));
        int right = dis3(gen);
        largeQueries.push_back({left, right});
    }
    
    startTime = chrono::high_resolution_clock::now();
    for (const auto& query : largeQueries) {
        largeST.queryMin(query.first, query.second);
    }
    endTime = chrono::high_resolution_clock::now();
    
    auto queryTime = chrono::duration_cast<chrono::microseconds>(endTime - startTime);
    
    cout << "构建100000个元素的稀疏表时间: " << buildTime.count() / 1000.0 << " ms" << endl;
    cout << "执行100000次查询时间: " << queryTime.count() / 1000.0 << " ms" << endl;
    cout << "平均每次查询时间: " << queryTime.count() / double(numQueries) << " μs" << endl;
}

int main() {
    testSparseTable();
    return 0;
}

===============================================

文件: sparse_table_rmq.py
===============================================
#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
稀疏表（Sparse Table）实现 - RMQ问题解决方案 (Python版本)

算法思路：
稀疏表是一种用于解决范围查询问题的数据结构，特别适用于：
1. 范围最小值查询（RMQ）
2. 范围最大值查询
3. 其他满足结合律和幂等性的操作

稀疏表通过预处理，在O(n log n)时间内构建一个二维数组，
然后在O(1)时间内回答任何范围查询。

时间复杂度：
- 预处理：O(n log n)
- 查询：O(1)
空间复杂度：O(n log n)

应用场景：
1. 数据库：范围查询优化
2. 图像处理：区域统计信息计算
3. 金融：时间序列分析中的极值查询
4. 算法竞赛：优化动态规划中的范围查询

相关题目：
1. LeetCode 2444. 统计定界子数组的数目
2. POJ 3264 Balanced Lineup
3. SPOJ RMQSQ - Range Minimum Query
"""

import math
import random
import time

class SparseTableRMQ:
    """稀疏表实现类"""
    
    def __init__(self, data):
        """
        构造函数
        :param data: 输入数组
        """
        if not data:
            raise ValueError("输入数组不能为空")
        
        self.data = data[:]
        self.n = len(data)
        
        # 计算log表
        self._precompute_log_table()
        
        # 计算稀疏表
        self._compute_sparse_table()
    
    def _precompute_log_table(self):
        """预计算log2值表"""
        self.log_table = [0] * (self.n + 1)
        self.log_table[1] = 0
        for i in range(2, self.n + 1):
            self.log_table[i] = self.log_table[i // 2] + 1
    
    def _compute_sparse_table(self):
        """计算稀疏表"""
        # 计算稀疏表的大小
        k = self.log_table[self.n] + 1
        self.st_min = [[0 for _ in range(self.n)] for _ in range(k)]
        self.st_max = [[0 for _ in range(self.n)] for _ in range(k)]
        
        # 初始化第一行（区间长度为1）
        for i in range(self.n):
            self.st_min[0][i] = self.data[i]
            self.st_max[0][i] = self.data[i]
        
        # 填充其他行
        for j in range(1, k):
            for i in range(self.n - (1 << j) + 1):
                prev_len = 1 << (j - 1)
                # 范围最小值查询
                self.st_min[j][i] = min(self.st_min[j - 1][i], self.st_min[j - 1][i + prev_len])
                # 范围最大值查询
                self.st_max[j][i] = max(self.st_max[j - 1][i], self.st_max[j - 1][i + prev_len])
    
    def query_min(self, left, right):
        """
        范围最小值查询
        时间复杂度：O(1)
        :param left: 左边界（包含）
        :param right: 右边界（包含）
        :return: 区间内的最小值
        """
        if left < 0 or right >= self.n or left > right:
            raise ValueError("查询范围无效")
        
        length = right - left + 1
        k = self.log_table[length]
        
        return min(self.st_min[k][left], self.st_min[k][right - (1 << k) + 1])
    
    def query_max(self, left, right):
        """
        范围最大值查询
        时间复杂度：O(1)
        :param left: 左边界（包含）
        :param right: 右边界（包含）
        :return: 区间内的最大值
        """
        if left < 0 or right >= self.n or left > right:
            raise ValueError("查询范围无效")
        
        length = right - left + 1
        k = self.log_table[length]
        
        return max(self.st_max[k][left], self.st_max[k][right - (1 << k) + 1])
    
    def batch_query(self, queries, is_min_query=True):
        """
        批量处理范围查询
        :param queries: 查询数组，每个查询是[left, right]形式的元组
        :param is_min_query: 是否是最小值查询，否则是最大值查询
        :return: 查询结果数组
        """
        if not queries:
            raise ValueError("查询数组不能为空")
        
        results = []
        for query in queries:
            if len(query) != 2:
                raise ValueError("查询格式无效")
            
            if is_min_query:
                results.append(self.query_min(query[0], query[1]))
            else:
                results.append(self.query_max(query[0], query[1]))
        
        return results
    
    @staticmethod
    def test_sparse_table():
        """测试稀疏表"""
        print("=== 测试稀疏表 ===")
        
        data = [1, 3, 5, 7, 9, 11, 13, 15, 17]
        
        st = SparseTableRMQ(data)
        
        # 测试最小值查询
        print("测试最小值查询:")
        print("区间[1, 5]的最小值:", st.query_min(1, 5))  # 应该是3
        print("区间[0, 8]的最小值:", st.query_min(0, 8))  # 应该是1
        print("区间[4, 7]的最小值:", st.query_min(4, 7))  # 应该是9
        
        # 测试最大值查询
        print("\n测试最大值查询:")
        print("区间[1, 5]的最大值:", st.query_max(1, 5))  # 应该是11
        print("区间[0, 8]的最大值:", st.query_max(0, 8))  # 应该是17
        print("区间[4, 7]的最大值:", st.query_max(4, 7))  # 应该是15
        
        # 测试批量查询
        print("\n测试批量查询:")
        queries = [
            [0, 2], [1, 5], [3, 7], [2, 8]
        ]
        
        min_results = st.batch_query(queries, True)
        print("批量最小值查询结果:", min_results)
        
        max_results = st.batch_query(queries, False)
        print("批量最大值查询结果:", max_results)
        
        # 性能测试
        print("\n=== 性能测试 ===")
        
        # 生成大数据集
        n = 100000
        large_data = [random.randint(1, 1000000) for _ in range(n)]
        
        # 构建稀疏表
        start_time = time.time()
        large_st = SparseTableRMQ(large_data)
        build_time = time.time() - start_time
        
        # 执行大量查询
        num_queries = 100000
        queries = []
        for _ in range(num_queries):
            # 生成有效的查询范围
            left = random.randint(0, n-2)
            right = random.randint(left+1, min(left+1000, n-1))
            queries.append((left, right))
        
        start_time = time.time()
        for left, right in queries:
            large_st.query_min(left, right)
        query_time = time.time() - start_time
        
        print(f"构建100000个元素的稀疏表时间: {build_time*1000:.2f} ms")
        print(f"执行100000次查询时间: {query_time*1000:.2f} ms")
        print(f"平均每次查询时间: {query_time*1000000/num_queries:.4f} μs")

if __name__ == "__main__":
    SparseTableRMQ.test_sparse_table()

===============================================

文件: SweepLineAlgorithm.java
===============================================
package class185.sweep_line_problems;

import java.util.*;

/**
 * 扫描线算法实现 (Java版本)
 * 
 * 算法思路：
 * 扫描线算法是一种用于解决几何和调度问题的有效技术。
 * 核心思想是将问题中的事件按时间排序，然后按顺序处理这些事件。
 * 
 * 应用场景：
 * 1. 计算几何：矩形面积、线段相交
 * 2. 资源调度：会议室安排、任务调度
 * 3. 图形学：可见性分析、遮挡处理
 * 
 * 时间复杂度：O(n log n)
 * 空间复杂度：O(n)
 * 
 * 相关题目：
 * 1. LeetCode 850. 矩形面积II
 * 2. LeetCode 56. 合并区间
 * 3. POJ 1151 Atlantis
 */
public class SweepLineAlgorithm {
    
    /**
     * 事件类，用于扫描线算法
     */
    static class Event {
        int time;
        int type;  // 0表示开始事件，1表示结束事件
        int[] data; // 事件关联的数据
        
        Event(int time, int type, int[] data) {
            this.time = time;
            this.type = type;
            this.data = data;
        }
    }
    
    /**
     * 区间覆盖问题：计算最多有多少个重叠的区间
     * @param intervals 区间数组，每个区间是 [start, end] 形式
     * @return 最大重叠数量
     */
    public static int maxOverlap(int[][] intervals) {
        if (intervals == null || intervals.length == 0) {
            return 0;
        }
        
        List<Event> events = new ArrayList<>();
        
        // 为每个区间创建开始和结束事件
        for (int[] interval : intervals) {
            events.add(new Event(interval[0], 0, interval));  // 开始事件
            events.add(new Event(interval[1], 1, interval));  // 结束事件
        }
        
        // 按照时间排序事件
        events.sort((a, b) -> {
            // 首先按照时间排序
            if (a.time != b.time) {
                return Integer.compare(a.time, b.time);
            }
            // 时间相同时，结束事件优先处理，避免重复计算
            return Integer.compare(b.type, a.type);
        });
        
        int maxOverlap = 0;
        int currentOverlap = 0;
        
        // 扫描所有事件
        for (Event event : events) {
            if (event.type == 0) {  // 开始事件
                currentOverlap++;
                maxOverlap = Math.max(maxOverlap, currentOverlap);
            } else {  // 结束事件
                currentOverlap--;
            }
        }
        
        return maxOverlap;
    }
    
    /**
     * 扫描线算法解决矩形面积问题：计算多个矩形的总面积（不重复计算重叠部分）
     * @param rectangles 矩形数组，每个矩形是 [x1, y1, x2, y2] 形式，
     *                   其中(x1,y1)是左下顶点，(x2,y2)是右上顶点
     * @return 矩形覆盖的总面积
     */
    public static int calculateRectangleArea(int[][] rectangles) {
        if (rectangles == null || rectangles.length == 0) {
            return 0;
        }
        
        // 创建垂直扫描线事件
        List<Event> events = new ArrayList<>();
        Set<Integer> yCoordinates = new HashSet<>();
        
        for (int[] rect : rectangles) {
            int x1 = rect[0];
            int y1 = rect[1];
            int x2 = rect[2];
            int y2 = rect[3];
            
            // 添加开始和结束事件
            events.add(new Event(x1, 0, new int[]{y1, y2}));  // 开始事件
            events.add(new Event(x2, 1, new int[]{y1, y2}));  // 结束事件
            
            // 收集所有y坐标
            yCoordinates.add(y1);
            yCoordinates.add(y2);
        }
        
        // 排序事件
        events.sort((a, b) -> {
            if (a.time != b.time) {
                return Integer.compare(a.time, b.time);
            }
            return Integer.compare(a.type, b.type);
        });
        
        // 对y坐标排序
        List<Integer> sortedY = new ArrayList<>(yCoordinates);
        Collections.sort(sortedY);
        
        // 用于跟踪当前活动的矩形
        List<int[]> activeIntervals = new ArrayList<>();
        long totalArea = 0;
        int prevX = events.get(0).time;
        
        // 处理每个事件
        for (Event event : events) {
            int currentX = event.time;
            long width = currentX - prevX;
            
            if (width > 0) {
                // 计算当前活动的y区间总长度
                long height = calculateActiveHeight(activeIntervals, sortedY);
                
                // 增加面积
                totalArea += width * height;
            }
            
            // 更新活动区间
            if (event.type == 0) {
                activeIntervals.add(event.data);
            } else {
                activeIntervals.removeIf(interval -> 
                    interval[0] == event.data[0] && interval[1] == event.data[1]);
            }
            
            prevX = currentX;
        }
        
        return (int) totalArea;
    }
    
    /**
     * 计算当前活动的y区间总长度
     * @param activeIntervals 活动区间列表
     * @param sortedY 排序后的y坐标
     * @return 总长度
     */
    private static long calculateActiveHeight(List<int[]> activeIntervals, List<Integer> sortedY) {
        if (activeIntervals.isEmpty()) {
            return 0;
        }
        
        // 合并重叠的y区间
        List<int[]> intervals = new ArrayList<>(activeIntervals);
        intervals.sort((a, b) -> Integer.compare(a[0], b[0]));
        
        long totalHeight = 0;
        int currentStart = intervals.get(0)[0];
        int currentEnd = intervals.get(0)[1];
        
        for (int i = 1; i < intervals.size(); i++) {
            if (intervals.get(i)[0] <= currentEnd) {
                // 重叠，合并区间
                currentEnd = Math.max(currentEnd, intervals.get(i)[1]);
            } else {
                // 不重叠，计算长度并更新当前区间
                totalHeight += currentEnd - currentStart;
                currentStart = intervals.get(i)[0];
                currentEnd = intervals.get(i)[1];
            }
        }
        
        // 加上最后一个区间
        totalHeight += currentEnd - currentStart;
        
        return totalHeight;
    }
    
    /**
     * 合并区间问题
     * @param intervals 区间数组
     * @return 合并后的区间数组
     */
    public static int[][] mergeIntervals(int[][] intervals) {
        if (intervals == null || intervals.length == 0) {
            return new int[0][0];
        }
        
        // 按照起始位置排序
        Arrays.sort(intervals, (a, b) -> Integer.compare(a[0], b[0]));
        
        List<int[]> merged = new ArrayList<>();
        merged.add(intervals[0]);
        
        for (int i = 1; i < intervals.length; i++) {
            int[] current = intervals[i];
            int[] last = merged.get(merged.size() - 1);
            
            // 如果当前区间与上一个区间重叠，则合并
            if (current[0] <= last[1]) {
                last[1] = Math.max(last[1], current[1]);
            } else {
                // 否则添加新区间
                merged.add(current);
            }
        }
        
        return merged.toArray(new int[merged.size()][]);
    }
    
    /**
     * 测试扫描线算法
     */
    public static void main(String[] args) {
        System.out.println("=== 测试扫描线算法 ===");
        
        // 测试区间重叠问题
        System.out.println("测试区间重叠问题:");
        int[][] intervals1 = {
            {1, 4}, {2, 5}, {3, 6}, {7, 9}
        };
        System.out.println("最大重叠数量: " + maxOverlap(intervals1));  // 应该是3
        
        int[][] intervals2 = {
            {1, 2}, {3, 4}, {5, 6}
        };
        System.out.println("最大重叠数量: " + maxOverlap(intervals2));  // 应该是1
        
        // 测试矩形面积问题
        System.out.println("\n测试矩形面积计算:");
        int[][] rectangles1 = {
            {0, 0, 2, 2}, {1, 1, 3, 3}
        };
        System.out.println("矩形覆盖总面积: " + calculateRectangleArea(rectangles1));  // 应该是7
        
        int[][] rectangles2 = {
            {0, 0, 1, 1}, {2, 2, 3, 3}, {1, 1, 2, 2}
        };
        System.out.println("矩形覆盖总面积: " + calculateRectangleArea(rectangles2));  // 应该是3
        
        // 测试合并区间问题
        System.out.println("\n测试合并区间:");
        int[][] intervals3 = {
            {1, 3}, {2, 6}, {8, 10}, {15, 18}
        };
        int[][] merged = mergeIntervals(intervals3);
        System.out.print("合并后区间: ");
        for (int[] interval : merged) {
            System.out.print("[" + interval[0] + ", " + interval[1] + "] ");
        }
        System.out.println();
        
        // 性能测试
        System.out.println("\n=== 性能测试 ===");
        Random random = new Random(42);
        
        // 生成大量随机区间
        int n = 10000;
        int[][] intervals = new int[n][2];
        for (int i = 0; i < n; i++) {
            int start = random.nextInt(100000);
            int end = start + random.nextInt(1000) + 1;
            intervals[i][0] = start;
            intervals[i][1] = end;
        }
        
        long startTime = System.nanoTime();
        int maxOverlap = maxOverlap(intervals);
        long endTime = System.nanoTime();
        
        System.out.println("10000个随机区间的最大重叠数量: " + maxOverlap);
        System.out.println("运行时间: " + (endTime - startTime) / 1_000_000.0 + " ms");
        
        // 生成大量随机矩形
        int[][] rectangles = new int[1000][4];
        for (int i = 0; i < 1000; i++) {
            int x1 = random.nextInt(1000);
            int y1 = random.nextInt(1000);
            int x2 = x1 + random.nextInt(100) + 1;
            int y2 = y1 + random.nextInt(100) + 1;
            rectangles[i][0] = x1;
            rectangles[i][1] = y1;
            rectangles[i][2] = x2;
            rectangles[i][3] = y2;
        }
        
        startTime = System.nanoTime();
        int totalArea = calculateRectangleArea(rectangles);
        endTime = System.nanoTime();
        
        System.out.println("1000个随机矩形的总面积: " + totalArea);
        System.out.println("运行时间: " + (endTime - startTime) / 1_000_000.0 + " ms");
    }
}

===============================================

文件: sweep_line_algorithm.cpp
===============================================
#include <iostream>
#include <vector>
#include <algorithm>
#include <set>
#include <map>
#include <queue>
#include <climits>
#include <random>
#include <chrono>

using namespace std;

/**
 * 扫描线算法实现 (C++版本)
 * 
 * 算法思路：
 * 扫描线算法是一种用于解决几何和调度问题的有效技术。
 * 核心思想是将问题中的事件按时间排序，然后按顺序处理这些事件。
 * 
 * 应用场景：
 * 1. 计算几何：矩形面积、线段相交
 * 2. 资源调度：会议室安排、任务调度
 * 3. 图形学：可见性分析、遮挡处理
 * 
 * 时间复杂度：O(n log n)
 * 空间复杂度：O(n)
 * 
 * 相关题目：
 * 1. LeetCode 850. 矩形面积II
 * 2. LeetCode 56. 合并区间
 * 3. POJ 1151 Atlantis
 */

/**
 * 事件类，用于扫描线算法
 */
struct Event {
    int time;
    int type;  // 0表示开始事件，1表示结束事件
    pair<int, int> data; // 事件关联的数据
    
    Event(int t, int ty, pair<int, int> d) : time(t), type(ty), data(d) {}
    
    // 用于事件排序
    bool operator<(const Event& other) const {
        // 首先按照时间排序
        if (time != other.time) {
            return time < other.time;
        }
        // 时间相同时，结束事件优先处理，避免重复计算
        return type > other.type;
    }
};

class SweepLineAlgorithm {
public:
    /**
     * 区间覆盖问题：计算最多有多少个重叠的区间
     * @param intervals 区间数组，每个区间是 [start, end] 形式
     * @return 最大重叠数量
     */
    static int maxOverlap(const vector<pair<int, int>>& intervals) {
        if (intervals.empty()) {
            return 0;
        }
        
        vector<Event> events;
        
        // 为每个区间创建开始和结束事件
        for (const auto& interval : intervals) {
            events.emplace_back(interval.first, 0, interval);  // 开始事件
            events.emplace_back(interval.second, 1, interval); // 结束事件
        }
        
        // 按照时间排序事件
        sort(events.begin(), events.end());
        
        int maxOverlap = 0;
        int currentOverlap = 0;
        
        // 扫描所有事件
        for (const Event& event : events) {
            if (event.type == 0) {  // 开始事件
                currentOverlap++;
                maxOverlap = max(maxOverlap, currentOverlap);
            } else {  // 结束事件
                currentOverlap--;
            }
        }
        
        return maxOverlap;
    }
    
    /**
     * 扫描线算法解决矩形面积问题：计算多个矩形的总面积（不重复计算重叠部分）
     * @param rectangles 矩形数组，每个矩形是 [x1, y1, x2, y2] 形式，
     *                   其中(x1,y1)是左下顶点，(x2,y2)是右上顶点
     * @return 矩形覆盖的总面积
     */
    static long long calculateRectangleArea(const vector<tuple<int, int, int, int>>& rectangles) {
        if (rectangles.empty()) {
            return 0;
        }
        
        // 创建垂直扫描线事件
        vector<Event> events;
        set<int> yCoordinates;
        
        for (const auto& rect : rectangles) {
            int x1 = get<0>(rect);
            int y1 = get<1>(rect);
            int x2 = get<2>(rect);
            int y2 = get<3>(rect);
            
            // 添加开始和结束事件
            events.emplace_back(x1, 0, make_pair(y1, y2));  // 开始事件
            events.emplace_back(x2, 1, make_pair(y1, y2));  // 结束事件
            
            // 收集所有y坐标
            yCoordinates.insert(y1);
            yCoordinates.insert(y2);
        }
        
        // 排序事件
        sort(events.begin(), events.end());
        
        // 对y坐标排序
        vector<int> sortedY(yCoordinates.begin(), yCoordinates.end());
        
        // 用于跟踪当前活动的矩形
        vector<pair<int, int>> activeIntervals;
        long long totalArea = 0;
        int prevX = events[0].time;
        
        // 处理每个事件
        for (const Event& event : events) {
            int currentX = event.time;
            long long width = currentX - prevX;
            
            if (width > 0) {
                // 计算当前活动的y区间总长度
                long long height = calculateActiveHeight(activeIntervals, sortedY);
                
                // 增加面积
                totalArea += width * height;
            }
            
            // 更新活动区间
            if (event.type == 0) {
                activeIntervals.push_back(event.data);
            } else {
                // 移除对应的区间
                activeIntervals.erase(
                    remove_if(activeIntervals.begin(), activeIntervals.end(),
                             [&event](const pair<int, int>& interval) {
                                 return interval.first == event.data.first && 
                                        interval.second == event.data.second;
                             }),
                    activeIntervals.end()
                );
            }
            
            prevX = currentX;
        }
        
        return totalArea;
    }
    
    /**
     * 合并区间问题
     * @param intervals 区间数组
     * @return 合并后的区间数组
     */
    static vector<pair<int, int>> mergeIntervals(vector<pair<int, int>> intervals) {
        if (intervals.empty()) {
            return {};
        }
        
        // 按照起始位置排序
        sort(intervals.begin(), intervals.end());
        
        vector<pair<int, int>> merged;
        merged.push_back(intervals[0]);
        
        for (size_t i = 1; i < intervals.size(); i++) {
            auto& current = intervals[i];
            auto& last = merged.back();
            
            // 如果当前区间与上一个区间重叠，则合并
            if (current.first <= last.second) {
                last.second = max(last.second, current.second);
            } else {
                // 否则添加新区间
                merged.push_back(current);
            }
        }
        
        return merged;
    }

private:
    /**
     * 计算当前活动的y区间总长度
     * @param activeIntervals 活动区间列表
     * @param sortedY 排序后的y坐标
     * @return 总长度
     */
    static long long calculateActiveHeight(const vector<pair<int, int>>& activeIntervals, 
                                          const vector<int>& sortedY) {
        if (activeIntervals.empty()) {
            return 0;
        }
        
        // 复制并排序区间
        vector<pair<int, int>> intervals = activeIntervals;
        sort(intervals.begin(), intervals.end());
        
        long long totalHeight = 0;
        int currentStart = intervals[0].first;
        int currentEnd = intervals[0].second;
        
        for (size_t i = 1; i < intervals.size(); i++) {
            if (intervals[i].first <= currentEnd) {
                // 重叠，合并区间
                currentEnd = max(currentEnd, intervals[i].second);
            } else {
                // 不重叠，计算长度并更新当前区间
                totalHeight += currentEnd - currentStart;
                currentStart = intervals[i].first;
                currentEnd = intervals[i].second;
            }
        }
        
        // 加上最后一个区间
        totalHeight += currentEnd - currentStart;
        
        return totalHeight;
    }
};

/**
 * 测试扫描线算法
 */
void testSweepLine() {
    cout << "=== 测试扫描线算法 ===" << endl;
    
    // 测试区间重叠问题
    cout << "测试区间重叠问题:" << endl;
    vector<pair<int, int>> intervals1 = {
        {1, 4}, {2, 5}, {3, 6}, {7, 9}
    };
    cout << "最大重叠数量: " << SweepLineAlgorithm::maxOverlap(intervals1) << endl;  // 应该是3
    
    vector<pair<int, int>> intervals2 = {
        {1, 2}, {3, 4}, {5, 6}
    };
    cout << "最大重叠数量: " << SweepLineAlgorithm::maxOverlap(intervals2) << endl;  // 应该是1
    
    // 测试矩形面积问题
    cout << "\n测试矩形面积计算:" << endl;
    vector<tuple<int, int, int, int>> rectangles1 = {
        {0, 0, 2, 2}, {1, 1, 3, 3}
    };
    cout << "矩形覆盖总面积: " << SweepLineAlgorithm::calculateRectangleArea(rectangles1) << endl;  // 应该是7
    
    vector<tuple<int, int, int, int>> rectangles2 = {
        {0, 0, 1, 1}, {2, 2, 3, 3}, {1, 1, 2, 2}
    };
    cout << "矩形覆盖总面积: " << SweepLineAlgorithm::calculateRectangleArea(rectangles2) << endl;  // 应该是3
    
    // 测试合并区间问题
    cout << "\n测试合并区间:" << endl;
    vector<pair<int, int>> intervals3 = {
        {1, 3}, {2, 6}, {8, 10}, {15, 18}
    };
    vector<pair<int, int>> merged = SweepLineAlgorithm::mergeIntervals(intervals3);
    cout << "合并后区间: ";
    for (const auto& interval : merged) {
        cout << "[" << interval.first << ", " << interval.second << "] ";
    }
    cout << endl;
    
    // 性能测试
    cout << "\n=== 性能测试 ===" << endl;
    
    // 生成大量随机区间
    int n = 10000;
    vector<pair<int, int>> intervals;
    random_device rd;
    mt19937 gen(rd());
    uniform_int_distribution<int> dis(0, 100000);
    uniform_int_distribution<int> dis2(1, 1000);
    
    for (int i = 0; i < n; i++) {
        int start = dis(gen);
        int end = start + dis2(gen);
        intervals.push_back({start, end});
    }
    
    auto startTime = chrono::high_resolution_clock::now();
    int maxOverlap = SweepLineAlgorithm::maxOverlap(intervals);
    auto endTime = chrono::high_resolution_clock::now();
    
    auto duration = chrono::duration_cast<chrono::microseconds>(endTime - startTime);
    
    cout << "10000个随机区间的最大重叠数量: " << maxOverlap << endl;
    cout << "运行时间: " << duration.count() / 1000.0 << " ms" << endl;
    
    // 生成大量随机矩形
    vector<tuple<int, int, int, int>> rectangles;
    uniform_int_distribution<int> dis3(0, 1000);
    uniform_int_distribution<int> dis4(1, 100);
    
    for (int i = 0; i < 1000; i++) {
        int x1 = dis3(gen);
        int y1 = dis3(gen);
        int x2 = x1 + dis4(gen);
        int y2 = y1 + dis4(gen);
        rectangles.push_back({x1, y1, x2, y2});
    }
    
    startTime = chrono::high_resolution_clock::now();
    long long totalArea = SweepLineAlgorithm::calculateRectangleArea(rectangles);
    endTime = chrono::high_resolution_clock::now();
    
    duration = chrono::duration_cast<chrono::microseconds>(endTime - startTime);
    
    cout << "1000个随机矩形的总面积: " << totalArea << endl;
    cout << "运行时间: " << duration.count() / 1000.0 << " ms" << endl;
}

int main() {
    testSweepLine();
    return 0;
}

===============================================

文件: sweep_line_algorithm.py
===============================================
#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
扫描线算法实现 (Python版本)

算法思路：
扫描线算法是一种用于解决几何和调度问题的有效技术。
核心思想是将问题中的事件按时间排序，然后按顺序处理这些事件。

应用场景：
1. 计算几何：矩形面积、线段相交
2. 资源调度：会议室安排、任务调度
3. 图形学：可见性分析、遮挡处理

时间复杂度：O(n log n)
空间复杂度：O(n)

相关题目：
1. LeetCode 850. 矩形面积II
2. LeetCode 56. 合并区间
3. POJ 1151 Atlantis
"""

import heapq
from collections import defaultdict
import random
import time

class Event:
    """事件类，用于扫描线算法"""
    
    def __init__(self, time, event_type, data):
        """
        构造函数
        :param time: 事件发生的时间
        :param event_type: 事件类型：0表示开始，1表示结束
        :param data: 事件关联的数据
        """
        self.time = time
        self.type = event_type
        self.data = data
    
    def __lt__(self, other):
        """用于事件排序"""
        # 首先按照时间排序
        if self.time != other.time:
            return self.time < other.time
        # 时间相同时，结束事件优先处理，避免重复计算
        return self.type > other.type

class SweepLineAlgorithm:
    """扫描线算法实现类"""
    
    @staticmethod
    def max_overlap(intervals):
        """
        区间覆盖问题：计算最多有多少个重叠的区间
        :param intervals: 区间数组，每个区间是 [start, end] 形式
        :return: 最大重叠数量
        """
        if not intervals:
            return 0
        
        events = []
        
        # 为每个区间创建开始和结束事件
        for start, end in intervals:
            events.append(Event(start, 0, (start, end)))  # 开始事件
            events.append(Event(end, 1, (start, end)))    # 结束事件
        
        # 按照时间排序事件
        events.sort()
        
        max_overlap = 0
        current_overlap = 0
        
        # 扫描所有事件
        for event in events:
            if event.type == 0:  # 开始事件
                current_overlap += 1
                max_overlap = max(max_overlap, current_overlap)
            else:  # 结束事件
                current_overlap -= 1
        
        return max_overlap
    
    @staticmethod
    def calculate_rectangle_area(rectangles):
        """
        扫描线算法解决矩形面积问题：计算多个矩形的总面积（不重复计算重叠部分）
        :param rectangles: 矩形数组，每个矩形是 [x1, y1, x2, y2] 形式，
                          其中(x1,y1)是左下顶点，(x2,y2)是右上顶点
        :return: 矩形覆盖的总面积
        """
        if not rectangles:
            return 0
        
        # 创建垂直扫描线事件
        events = []
        y_coordinates = set()
        
        for x1, y1, x2, y2 in rectangles:
            # 添加开始和结束事件
            events.append(Event(x1, 0, (y1, y2)))  # 开始事件
            events.append(Event(x2, 1, (y1, y2)))  # 结束事件
            
            # 收集所有y坐标
            y_coordinates.add(y1)
            y_coordinates.add(y2)
        
        # 排序事件
        events.sort()
        
        # 对y坐标排序
        sorted_y = sorted(y_coordinates)
        
        # 用于跟踪当前活动的矩形
        active_intervals = []
        total_area = 0
        prev_x = events[0].time
        
        # 处理每个事件
        for event in events:
            current_x = event.time
            width = current_x - prev_x
            
            if width > 0:
                # 计算当前活动的y区间总长度
                height = SweepLineAlgorithm._calculate_active_height(active_intervals, sorted_y)
                
                # 增加面积
                total_area += width * height
            
            # 更新活动区间
            if event.type == 0:
                active_intervals.append(event.data)
            else:
                active_intervals = [interval for interval in active_intervals 
                                  if interval != event.data]
            
            prev_x = current_x
        
        return int(total_area)
    
    @staticmethod
    def _calculate_active_height(active_intervals, sorted_y):
        """
        计算当前活动的y区间总长度
        :param active_intervals: 活动区间列表
        :param sorted_y: 排序后的y坐标
        :return: 总长度
        """
        if not active_intervals:
            return 0
        
        # 合并重叠的y区间
        intervals = sorted(active_intervals)
        
        total_height = 0
        current_start = intervals[0][0]
        current_end = intervals[0][1]
        
        for i in range(1, len(intervals)):
            if intervals[i][0] <= current_end:
                # 重叠，合并区间
                current_end = max(current_end, intervals[i][1])
            else:
                # 不重叠，计算长度并更新当前区间
                total_height += current_end - current_start
                current_start = intervals[i][0]
                current_end = intervals[i][1]
        
        # 加上最后一个区间
        total_height += current_end - current_start
        
        return total_height
    
    @staticmethod
    def merge_intervals(intervals):
        """
        合并区间问题
        :param intervals: 区间数组
        :return: 合并后的区间数组
        """
        if not intervals:
            return []
        
        # 按照起始位置排序
        intervals.sort(key=lambda x: x[0])
        
        merged = [intervals[0]]
        
        for current in intervals[1:]:
            last = merged[-1]
            
            # 如果当前区间与上一个区间重叠，则合并
            if current[0] <= last[1]:
                last[1] = max(last[1], current[1])
            else:
                # 否则添加新区间
                merged.append(current)
        
        return merged
    
    @staticmethod
    def test_sweep_line():
        """测试扫描线算法"""
        print("=== 测试扫描线算法 ===")
        
        # 测试区间重叠问题
        print("测试区间重叠问题:")
        intervals1 = [
            [1, 4], [2, 5], [3, 6], [7, 9]
        ]
        print("最大重叠数量:", SweepLineAlgorithm.max_overlap(intervals1))  # 应该是3
        
        intervals2 = [
            [1, 2], [3, 4], [5, 6]
        ]
        print("最大重叠数量:", SweepLineAlgorithm.max_overlap(intervals2))  # 应该是1
        
        # 测试矩形面积问题
        print("\n测试矩形面积计算:")
        rectangles1 = [
            [0, 0, 2, 2], [1, 1, 3, 3]
        ]
        print("矩形覆盖总面积:", SweepLineAlgorithm.calculate_rectangle_area(rectangles1))  # 应该是7
        
        rectangles2 = [
            [0, 0, 1, 1], [2, 2, 3, 3], [1, 1, 2, 2]
        ]
        print("矩形覆盖总面积:", SweepLineAlgorithm.calculate_rectangle_area(rectangles2))  # 应该是3
        
        # 测试合并区间问题
        print("\n测试合并区间:")
        intervals3 = [
            [1, 3], [2, 6], [8, 10], [15, 18]
        ]
        merged = SweepLineAlgorithm.merge_intervals(intervals3)
        print("合并后区间:", merged)
        
        # 性能测试
        print("\n=== 性能测试 ===")
        
        # 生成大量随机区间
        n = 10000
        intervals = []
        for _ in range(n):
            start = random.randint(0, 100000)
            end = start + random.randint(1, 1000)
            intervals.append([start, end])
        
        start_time = time.time()
        max_overlap = SweepLineAlgorithm.max_overlap(intervals)
        end_time = time.time()
        
        print(f"10000个随机区间的最大重叠数量: {max_overlap}")
        print(f"运行时间: {(end_time - start_time) * 1000:.2f} ms")
        
        # 生成大量随机矩形
        rectangles = []
        for _ in range(1000):
            x1 = random.randint(0, 1000)
            y1 = random.randint(0, 1000)
            x2 = x1 + random.randint(1, 100)
            y2 = y1 + random.randint(1, 100)
            rectangles.append([x1, y1, x2, y2])
        
        start_time = time.time()
        total_area = SweepLineAlgorithm.calculate_rectangle_area(rectangles)
        end_time = time.time()
        
        print(f"1000个随机矩形的总面积: {total_area}")
        print(f"运行时间: {(end_time - start_time) * 1000:.2f} ms")

if __name__ == "__main__":
    SweepLineAlgorithm.test_sweep_line()

===============================================

文件: UnrolledLinkedList.cpp
===============================================
#include <iostream>
#include <vector>
#include <stdexcept>
#include <chrono>

using namespace std;

/**
 * 块状链表实现 (C++版本)
 * 
 * 算法思路：
 * 块状链表是一种结合了数组和链表优点的数据结构。它将元素分块存储在节点中，
 * 每个节点包含一个固定大小的数组和指向下一个节点的指针。
 * 
 * 应用场景：
 * 1. 大型序列维护：文本编辑器、数据库索引
 * 2. 数组操作优化：批量更新处理
 * 3. 文件系统：大文件的分块管理
 * 
 * 时间复杂度：
 * - 插入/删除：O(n/b) 均摊，其中b是块大小
 * - 查找：O(n/b)
 * - 空间复杂度：O(n)
 * 
 * 相关题目：
 * 1. LeetCode 641. 设计循环双端队列
 * 2. LeetCode 707. 设计链表
 * 3. LeetCode 146. LRU缓存机制
 */

template<typename T>
class Block {
private:
    int capacity;      // 块的最大容量
    vector<T> array;   // 块内的数组
    int size;          // 当前块中元素的数量
    Block* next;       // 指向下一个块
    Block* prev;       // 指向上一个块

public:
    Block(int capacity) : capacity(capacity), size(0), next(nullptr), prev(nullptr) {
        array.resize(capacity);
    }

    bool isFull() const {
        /**
         * 检查块是否已满
         * @return 块是否已满
         */
        return size == capacity;
    }

    bool isEmpty() const {
        /**
         * 检查块是否为空
         * @return 块是否为空
         */
        return size == 0;
    }

    int getSize() const {
        /**
         * 获取块的大小
         * @return 块中元素的数量
         */
        return size;
    }

    int getCapacity() const {
        /**
         * 获取块的容量
         * @return 块的最大容量
         */
        return capacity;
    }

    void add(const T& value) {
        /**
         * 在块的末尾添加元素
         * @param value 要添加的值
         * @throws runtime_error 如果块已满
         */
        if (isFull()) {
            throw runtime_error("Block is full");
        }
        array[size] = value;
        size++;
    }

    void insert(int index, const T& value) {
        /**
         * 在指定位置插入元素
         * @param index 插入位置
         * @param value 要插入的值
         * @throws out_of_range 如果索引无效
         * @throws runtime_error 如果块已满
         */
        if (isFull()) {
            throw runtime_error("Block is full");
        }

        if (index < 0 || index > size) {
            throw out_of_range("Index out of bounds: " + to_string(index));
        }

        // 移动元素为新元素腾出空间
        for (int i = size; i > index; i--) {
            array[i] = array[i - 1];
        }
        array[index] = value;
        size++;
    }

    T deleteAt(int index) {
        /**
         * 删除指定位置的元素
         * @param index 要删除的元素位置
         * @return 被删除的元素
         * @throws out_of_range 如果索引无效
         */
        if (index < 0 || index >= size) {
            throw out_of_range("Index out of bounds: " + to_string(index));
        }

        T value = array[index];

        // 移动元素覆盖被删除的元素
        for (int i = index; i < size - 1; i++) {
            array[i] = array[i + 1];
        }
        size--;

        return value;
    }

    T get(int index) const {
        /**
         * 获取指定位置的元素
         * @param index 元素位置
         * @return 元素值
         * @throws out_of_range 如果索引无效
         */
        if (index < 0 || index >= size) {
            throw out_of_range("Index out of bounds: " + to_string(index));
        }
        return array[index];
    }

    T set(int index, const T& value) {
        /**
         * 设置指定位置的元素值
         * @param index 元素位置
         * @param value 新的元素值
         * @return 原来的元素值
         * @throws out_of_range 如果索引无效
         */
        if (index < 0 || index >= size) {
            throw out_of_range("Index out of bounds: " + to_string(index));
        }

        T oldValue = array[index];
        array[index] = value;
        return oldValue;
    }

    Block* split(int splitIndex) {
        /**
         * 分割块
         * 将当前块从指定位置分割，返回包含后半部分元素的新块
         * @param splitIndex 分割位置
         * @return 包含后半部分元素的新块
         * @throws out_of_range 如果分割位置无效
         */
        if (splitIndex < 0 || splitIndex > size) {
            throw out_of_range("Split index out of bounds: " + to_string(splitIndex));
        }

        // 创建新块
        Block* newBlock = new Block(capacity);

        // 复制后半部分元素到新块
        int elementsToMove = size - splitIndex;
        for (int i = 0; i < elementsToMove; i++) {
            newBlock->array[i] = array[splitIndex + i];
        }

        // 更新块大小
        newBlock->size = elementsToMove;
        size = splitIndex;

        // 建立双向链接
        newBlock->next = next;
        if (next != nullptr) {
            next->prev = newBlock;
        }
        next = newBlock;
        newBlock->prev = this;

        return newBlock;
    }

    Block* mergeNext() {
        /**
         * 合并两个相邻块
         * 假设当前块和next块是相邻的
         * @return 合并后的块（即当前块）
         * @throws runtime_error 如果没有下一个块或合并后超出容量
         */
        if (next == nullptr) {
            throw runtime_error("No next block to merge");
        }

        if (size + next->size > capacity) {
            throw runtime_error("Merged size exceeds block capacity");
        }

        // 复制next块的元素到当前块
        for (int i = 0; i < next->size; i++) {
            array[size + i] = next->array[i];
        }
        size += next->size;

        // 更新链接，跳过next块
        Block* nextNext = next->next;
        delete next;
        next = nextNext;
        if (nextNext != nullptr) {
            nextNext->prev = this;
        }

        return this;
    }

    // 友元类声明
    template<typename U>
    friend class UnrolledLinkedList;
};

template<typename T>
class UnrolledLinkedList {
private:
    int blockCapacity;  // 块的最大容量
    Block<T>* head;     // 头块指针
    Block<T>* tail;     // 尾块指针
    int size;           // 链表元素总数

    // 内部辅助结构体
    struct BlockAndIndex {
        Block<T>* block;
        int index;

        BlockAndIndex(Block<T>* b, int i) : block(b), index(i) {}
    };

    BlockAndIndex findBlockAndIndex(int index) const {
        /**
         * 查找包含指定索引的块和块内索引
         * 时间复杂度：O(n/b)
         * @param index 元素索引
         * @return 包含块和块内索引的对象
         */
        if (isEmpty() || index < 0 || index >= size) {
            throw out_of_range("Index out of bounds: " + to_string(index));
        }

        // 优化：根据索引位置选择从头还是从尾开始查找
        // 如果索引更靠近头部，从头开始
        if (index < size / 2) {
            Block<T>* current = head;
            int currentIndex = 0;

            while (current != nullptr) {
                if (index < currentIndex + current->getSize()) {
                    // 找到了包含索引的块
                    return BlockAndIndex(current, index - currentIndex);
                }
                currentIndex += current->getSize();
                current = current->next;
            }
        // 否则从尾开始
        } else {
            Block<T>* current = tail;
            int currentIndex = size - 1;
            int currentBlockSize = current->getSize();

            while (current != nullptr) {
                if (index >= currentIndex - currentBlockSize + 1) {
                    // 找到了包含索引的块
                    return BlockAndIndex(current, index - (currentIndex - currentBlockSize + 1));
                }
                currentIndex -= currentBlockSize;
                current = current->prev;
                currentBlockSize = (current != nullptr) ? current->getSize() : 0;
            }
        }

        // 不应该到达这里
        throw out_of_range("Index not found: " + to_string(index));
    }

public:
    UnrolledLinkedList(int blockCapacity = 16) : blockCapacity(blockCapacity), head(nullptr), tail(nullptr), size(0) {
        /**
         * 构造函数
         * @param blockCapacity 块的最大容量
         * @throws invalid_argument 如果块容量小于2
         */
        if (blockCapacity < 2) {
            throw invalid_argument("Block capacity must be at least 2");
        }
    }

    ~UnrolledLinkedList() {
        /**
         * 析构函数
         */
        clear();
    }

    bool isEmpty() const {
        /**
         * 检查链表是否为空
         * @return 链表是否为空
         */
        return size == 0;
    }

    int getSize() const {
        /**
         * 获取链表中元素的数量
         * @return 元素数量
         */
        return size;
    }

    void add(const T& value) {
        /**
         * 在链表末尾添加元素
         * 时间复杂度：O(n/b) 均摊，其中b是块容量
         * @param value 要添加的值
         */
        if (isEmpty()) {
            // 空链表，创建第一个块
            head = new Block<T>(blockCapacity);
            tail = head;
            head->add(value);
        } else {
            // 非空链表，检查尾块是否已满
            if (tail->isFull()) {
                // 尾块已满，分割为两个半满的块
                tail->split(tail->getSize() / 2);
                tail = tail->next; // 更新尾块指针
            }
            tail->add(value);
        }
        size++;
    }

    void insert(int index, const T& value) {
        /**
         * 在指定位置插入元素
         * 时间复杂度：O(n/b)
         * @param index 插入位置
         * @param value 要插入的值
         * @throws out_of_range 如果索引无效
         */
        if (index < 0 || index > size) {
            throw out_of_range("Index out of bounds: " + to_string(index));
        }

        if (index == size) {
            // 在末尾插入，调用add方法
            add(value);
            return;
        }

        if (isEmpty()) {
            // 空链表，创建第一个块
            head = new Block<T>(blockCapacity);
            tail = head;
            head->add(value);
        } else {
            // 定位到包含插入位置的块和块内索引
            BlockAndIndex pos = findBlockAndIndex(index);
            Block<T>* block = pos.block;
            int blockIndex = pos.index;

            // 检查块是否已满
            if (block->isFull()) {
                // 块已满，分割为两个半满的块
                int splitIndex = block->getSize() / 2;
                Block<T>* newBlock = block->split(splitIndex);

                // 调整插入位置
                if (blockIndex >= splitIndex) {
                    block = newBlock;
                    blockIndex -= splitIndex;
                }
            }

            // 在块中插入元素
            block->insert(blockIndex, value);

            // 更新尾块指针（如果需要）
            Block<T>* current = head;
            while (current->next != nullptr) {
                current = current->next;
            }
            tail = current;
        }

        size++;
    }

    T deleteAt(int index) {
        /**
         * 删除指定位置的元素
         * 时间复杂度：O(n/b)
         * @param index 要删除的元素位置
         * @return 被删除的元素
         * @throws out_of_range 如果索引无效
         */
        if (isEmpty()) {
            throw runtime_error("Cannot delete from empty list");
        }

        if (index < 0 || index >= size) {
            throw out_of_range("Index out of bounds: " + to_string(index));
        }

        // 定位到包含删除位置的块和块内索引
        BlockAndIndex pos = findBlockAndIndex(index);
        Block<T>* block = pos.block;
        int blockIndex = pos.index;

        // 保存要删除的元素值
        T value = block->deleteAt(blockIndex);

        // 如果删除后块的大小过小，尝试与相邻块合并（保持块的大小在合理范围）
        if ((block->getSize() < blockCapacity / 4 && block != head) ||
            (block->isEmpty() && size > 0)) {  // 特殊处理空块

            // 优先与前一个块合并
            if (block->prev != nullptr) {
                Block<T>* prevBlock = block->prev;
                // 确保合并后不会超出容量
                if (prevBlock->getSize() + block->getSize() <= blockCapacity) {
                    // 将要删除的索引调整为前一个块的末尾
                    if (block == tail) {
                        tail = prevBlock;
                    }
                    prevBlock->mergeNext();
                    // 如果当前删除的块是head，更新head指针
                    if (block == head) {
                        head = prevBlock;
                    }
                }
            // 否则与后一个块合并
            } else if (block->next != nullptr) {
                Block<T>* nextBlock = block->next;
                if (block->getSize() + nextBlock->getSize() <= blockCapacity) {
                    if (nextBlock == tail) {
                        tail = block;
                    }
                    block->mergeNext();
                }
            // 特殊情况：只剩一个空块
            } else if (block->isEmpty()) {
                head = nullptr;
                tail = nullptr;
            }
        }

        size--;
        return value;
    }

    T get(int index) const {
        /**
         * 获取指定位置的元素
         * 时间复杂度：O(n/b)
         * @param index 元素位置
         * @return 元素值
         * @throws out_of_range 如果索引无效
         */
        if (isEmpty()) {
            throw runtime_error("List is empty");
        }

        if (index < 0 || index >= size) {
            throw out_of_range("Index out of bounds: " + to_string(index));
        }

        BlockAndIndex pos = findBlockAndIndex(index);
        return pos.block->get(pos.index);
    }

    T set(int index, const T& value) {
        /**
         * 设置指定位置的元素值
         * 时间复杂度：O(n/b)
         * @param index 元素位置
         * @param value 新的元素值
         * @return 原来的元素值
         * @throws out_of_range 如果索引无效
         */
        if (isEmpty()) {
            throw runtime_error("List is empty");
        }

        if (index < 0 || index >= size) {
            throw out_of_range("Index out of bounds: " + to_string(index));
        }

        BlockAndIndex pos = findBlockAndIndex(index);
        return pos.block->set(pos.index, value);
    }

    void clear() {
        /**
         * 清空链表
         * 时间复杂度：O(n)
         */
        Block<T>* current = head;
        while (current != nullptr) {
            Block<T>* next = current->next;
            delete current;
            current = next;
        }
        head = nullptr;
        tail = nullptr;
        size = 0;
    }

    vector<T> toArray() const {
        /**
         * 将链表内容转换为数组
         * 时间复杂度：O(n)
         * @return 包含链表所有元素的数组
         */
        if (isEmpty()) {
            return vector<T>();
        }

        vector<T> result(size);
        Block<T>* current = head;
        int resultIndex = 0;

        while (current != nullptr) {
            for (int i = 0; i < current->getSize(); i++) {
                result[resultIndex++] = current->get(i);
            }
            current = current->next;
        }

        return result;
    }

    int indexOf(const T& value) const {
        /**
         * 查找第一个出现的指定值的索引
         * 时间复杂度：O(n)
         * @param value 要查找的值
         * @return 元素索引，如果未找到返回-1
         */
        if (isEmpty()) {
            return -1;
        }

        int index = 0;
        Block<T>* current = head;

        while (current != nullptr) {
            for (int i = 0; i < current->getSize(); i++) {
                if (current->get(i) == value) {
                    return index + i;
                }
            }
            index += current->getSize();
            current = current->next;
        }

        return -1;
    }

    int lastIndexOf(const T& value) const {
        /**
         * 查找最后一个出现的指定值的索引
         * 时间复杂度：O(n)
         * @param value 要查找的值
         * @return 元素索引，如果未找到返回-1
         */
        if (isEmpty()) {
            return -1;
        }

        int index = size - 1;
        Block<T>* current = tail;
        int currentBlockSize = current->getSize();

        while (current != nullptr) {
            for (int i = currentBlockSize - 1; i >= 0; i--) {
                if (current->get(i) == value) {
                    return index - (currentBlockSize - 1 - i);
                }
            }

            index -= currentBlockSize;
            current = current->prev;
            currentBlockSize = (current != nullptr) ? current->getSize() : 0;
        }

        return -1;
    }

    bool contains(const T& value) const {
        /**
         * 检查链表是否包含指定值
         * 时间复杂度：O(n)
         * @param value 要检查的值
         * @return 是否包含该值
         */
        return indexOf(value) != -1;
    }

    UnrolledLinkedList<T> subList(int start, int end) const {
        /**
         * 范围查询：获取从start到end（不包含）的子列表
         * 时间复杂度：O(n/b + k)，其中k是子列表的大小
         * @param start 起始索引（包含）
         * @param end 结束索引（不包含）
         * @return 子列表
         * @throws out_of_range 如果索引无效
         */
        if (start < 0 || end > size || start > end) {
            throw out_of_range("Invalid range: [" + to_string(start) + ", " + to_string(end) + ")");
        }

        UnrolledLinkedList<T> sublist(blockCapacity);

        if (start == end) {
            return sublist; // 空的子列表
        }

        // 处理跨越多个块的情况
        int currentIndex = start;
        while (currentIndex < end) {
            sublist.add(get(currentIndex));
            currentIndex++;
        }

        return sublist;
    }

    void printList() const {
        /**
         * 打印链表内容
         * 时间复杂度：O(n)
         */
        if (isEmpty()) {
            cout << "List is empty" << endl;
            return;
        }

        cout << "UnrolledLinkedList: [";
        Block<T>* current = head;
        bool firstElement = true;

        while (current != nullptr) {
            for (int i = 0; i < current->getSize(); i++) {
                if (!firstElement) {
                    cout << ", ";
                } else {
                    firstElement = false;
                }
                cout << current->get(i);
            }
            current = current->next;
        }

        cout << "]" << endl;
    }

    void printBlockStructure() const {
        /**
         * 打印链表的块结构（用于调试）
         */
        if (isEmpty()) {
            cout << "List is empty" << endl;
            return;
        }

        cout << "Block Structure:" << endl;
        int blockIndex = 0;
        Block<T>* current = head;

        while (current != nullptr) {
            cout << "Block " << blockIndex << " (size=" << current->getSize() << "): [";

            for (int i = 0; i < current->getSize(); i++) {
                cout << current->get(i);
                if (i < current->getSize() - 1) {
                    cout << ", ";
                }
            }

            cout << "]" << endl;

            current = current->next;
            blockIndex++;
        }
    }

    static void testUnrolledLinkedList() {
        cout << "=== 测试块状链表 ===" << endl;
        // 使用较小的块容量以便更容易观察块分割和合并
        UnrolledLinkedList<int> list(4);

        // 测试添加操作
        cout << "\n1. 测试添加操作:" << endl;
        for (int i = 1; i <= 10; i++) {
            list.add(i);
        }
        cout << "添加1-10后的列表:" << endl;
        list.printList();
        list.printBlockStructure();

        // 测试获取和设置
        cout << "\n2. 测试获取和设置操作:" << endl;
        cout << "索引5的值: " << list.get(5) << endl; // 应该是 6
        int oldValue = list.set(5, 100);
        cout << "设置索引5的值为100，旧值: " << oldValue << endl;
        cout << "索引5的新值: " << list.get(5) << endl; // 应该是 100
        list.printList();

        // 测试插入操作
        cout << "\n3. 测试插入操作:" << endl;
        list.insert(3, 50); // 在索引3插入50
        cout << "在索引3插入50后:" << endl;
        list.printList();
        list.printBlockStructure();

        list.insert(0, 0); // 在头部插入0
        cout << "在头部插入0后:" << endl;
        list.printList();

        // 测试删除操作
        cout << "\n4. 测试删除操作:" << endl;
        int deletedValue = list.deleteAt(5); // 删除索引5的值
        cout << "删除索引5的值: " << deletedValue << endl;
        cout << "删除后:" << endl;
        list.printList();
        list.printBlockStructure();

        list.deleteAt(0); // 删除头部
        cout << "删除头部后:" << endl;
        list.printList();

        // 测试查找操作
        cout << "\n5. 测试查找操作:" << endl;
        cout << "值为100的索引: " << list.indexOf(100) << endl;
        cout << "值为99的索引: " << list.indexOf(99) << endl; // 应该是 -1
        cout << "列表是否包含50: " << (list.contains(50) ? "true" : "false") << endl;

        // 测试子列表
        cout << "\n6. 测试子列表:" << endl;
        UnrolledLinkedList<int> sublist = list.subList(2, 6);
        cout << "子列表[2,6):" << endl;
        sublist.printList();

        // 测试清空操作
        cout << "\n7. 测试清空操作:" << endl;
        list.clear();
        cout << "清空后:" << endl;
        list.printList();
        cout << "列表大小: " << list.getSize() << endl;

        // 测试边界情况
        cout << "\n8. 测试边界情况:" << endl;
        try {
            list.get(0); // 空列表访问
        } catch (const exception& e) {
            cout << "空列表访问异常: " << e.what() << endl;
        }

        list.add(1); // 添加一个元素
        list.add(2); // 添加第二个元素
        cout << "添加两个元素后:" << endl;
        list.printList();

        list.deleteAt(0); // 删除第一个元素
        list.deleteAt(0); // 删除第二个元素
        cout << "删除所有元素后:" << endl;
        list.printList();

        // 性能测试
        cout << "\n=== 性能测试 ===" << endl;

        UnrolledLinkedList<int> largeList(16);

        auto startTime = chrono::high_resolution_clock::now();
        for (int i = 0; i < 10000; i++) {
            largeList.add(i);
        }
        auto endTime = chrono::high_resolution_clock::now();
        auto insertTime = chrono::duration_cast<chrono::microseconds>(endTime - startTime);

        cout << "插入10000个元素时间: " << insertTime.count() / 1000.0 << " ms" << endl;
        cout << "链表大小: " << largeList.getSize() << endl;

        // 测试随机访问
        startTime = chrono::high_resolution_clock::now();
        for (int i = 0; i < 1000; i++) {
            largeList.get(i * 10);
        }
        endTime = chrono::high_resolution_clock::now();
        auto accessTime = chrono::duration_cast<chrono::microseconds>(endTime - startTime);

        cout << "1000次随机访问时间: " << accessTime.count() / 1000.0 << " ms" << endl;
    }
};

int main() {
    UnrolledLinkedList<int>::testUnrolledLinkedList();
    return 0;
}

===============================================

文件: UnrolledLinkedList.java
===============================================
package class185.unrolled_linked_list_problems;

import java.util.*;

/**
 * 块状链表实现 (Java版本)
 * 
 * 算法思路：
 * 块状链表是一种结合了数组和链表优点的数据结构。它将元素分块存储在节点中，
 * 每个节点包含一个固定大小的数组和指向下一个节点的指针。
 * 
 * 应用场景：
 * 1. 大型序列维护：文本编辑器、数据库索引
 * 2. 数组操作优化：批量更新处理
 * 3. 文件系统：大文件的分块管理
 * 
 * 时间复杂度：
 * - 插入/删除：O(n/b) 均摊，其中b是块大小
 * - 查找：O(n/b)
 * - 空间复杂度：O(n)
 * 
 * 相关题目：
 * 1. LeetCode 641. 设计循环双端队列
 * 2. LeetCode 707. 设计链表
 * 3. LeetCode 146. LRU缓存机制
 */
class Block {
    int capacity;      // 块的最大容量
    Object[] array;    // 块内的数组
    int size;          // 当前块中元素的数量
    Block next;        // 指向下一个块
    Block prev;        // 指向上一个块

    Block(int capacity) {
        this.capacity = capacity;
        this.array = new Object[capacity];
        this.size = 0;
        this.next = null;
        this.prev = null;
    }

    boolean isFull() {
        /**
         * 检查块是否已满
         * @return 块是否已满
         */
        return size == capacity;
    }

    boolean isEmpty() {
        /**
         * 检查块是否为空
         * @return 块是否为空
         */
        return size == 0;
    }

    int getSize() {
        /**
         * 获取块的大小
         * @return 块中元素的数量
         */
        return size;
    }

    int getCapacity() {
        /**
         * 获取块的容量
         * @return 块的最大容量
         */
        return capacity;
    }

    void add(Object value) {
        /**
         * 在块的末尾添加元素
         * @param value 要添加的值
         * @throws RuntimeException 如果块已满
         */
        if (isFull()) {
            throw new RuntimeException("Block is full");
        }
        array[size] = value;
        size++;
    }

    void insert(int index, Object value) {
        /**
         * 在指定位置插入元素
         * @param index 插入位置
         * @param value 要插入的值
         * @throws IndexOutOfBoundsException 如果索引无效
         * @throws RuntimeException 如果块已满
         */
        if (isFull()) {
            throw new RuntimeException("Block is full");
        }

        if (index < 0 || index > size) {
            throw new IndexOutOfBoundsException("Index out of bounds: " + index);
        }

        // 移动元素为新元素腾出空间
        for (int i = size; i > index; i--) {
            array[i] = array[i - 1];
        }
        array[index] = value;
        size++;
    }

    Object delete(int index) {
        /**
         * 删除指定位置的元素
         * @param index 要删除的元素位置
         * @return 被删除的元素
         * @throws IndexOutOfBoundsException 如果索引无效
         */
        if (index < 0 || index >= size) {
            throw new IndexOutOfBoundsException("Index out of bounds: " + index);
        }

        Object value = array[index];

        // 移动元素覆盖被删除的元素
        for (int i = index; i < size - 1; i++) {
            array[i] = array[i + 1];
        }
        array[size - 1] = null; // 清除引用
        size--;

        return value;
    }

    Object get(int index) {
        /**
         * 获取指定位置的元素
         * @param index 元素位置
         * @return 元素值
         * @throws IndexOutOfBoundsException 如果索引无效
         */
        if (index < 0 || index >= size) {
            throw new IndexOutOfBoundsException("Index out of bounds: " + index);
        }
        return array[index];
    }

    Object set(int index, Object value) {
        /**
         * 设置指定位置的元素值
         * @param index 元素位置
         * @param value 新的元素值
         * @return 原来的元素值
         * @throws IndexOutOfBoundsException 如果索引无效
         */
        if (index < 0 || index >= size) {
            throw new IndexOutOfBoundsException("Index out of bounds: " + index);
        }

        Object oldValue = array[index];
        array[index] = value;
        return oldValue;
    }

    Block split(int splitIndex) {
        /**
         * 分割块
         * 将当前块从指定位置分割，返回包含后半部分元素的新块
         * @param splitIndex 分割位置
         * @return 包含后半部分元素的新块
         * @throws IndexOutOfBoundsException 如果分割位置无效
         */
        if (splitIndex < 0 || splitIndex > size) {
            throw new IndexOutOfBoundsException("Split index out of bounds: " + splitIndex);
        }

        // 创建新块
        Block newBlock = new Block(capacity);

        // 复制后半部分元素到新块
        int elementsToMove = size - splitIndex;
        for (int i = 0; i < elementsToMove; i++) {
            newBlock.array[i] = array[splitIndex + i];
            array[splitIndex + i] = null; // 清除引用
        }

        // 更新块大小
        newBlock.size = elementsToMove;
        size = splitIndex;

        // 建立双向链接
        newBlock.next = next;
        if (next != null) {
            next.prev = newBlock;
        }
        next = newBlock;
        newBlock.prev = this;

        return newBlock;
    }

    Block mergeNext() {
        /**
         * 合并两个相邻块
         * 假设当前块和next块是相邻的
         * @return 合并后的块（即当前块）
         * @throws RuntimeException 如果没有下一个块或合并后超出容量
         */
        if (next == null) {
            throw new RuntimeException("No next block to merge");
        }

        if (size + next.size > capacity) {
            throw new RuntimeException("Merged size exceeds block capacity");
        }

        // 复制next块的元素到当前块
        for (int i = 0; i < next.size; i++) {
            array[size + i] = next.array[i];
            next.array[i] = null; // 清除引用
        }
        size += next.size;

        // 更新链接，跳过next块
        Block nextNext = next.next;
        next = nextNext;
        if (nextNext != null) {
            nextNext.prev = this;
        }

        return this;
    }
}

public class UnrolledLinkedList {
    private int blockCapacity;  // 块的最大容量
    private Block head;         // 头块指针
    private Block tail;         // 尾块指针
    private int size;           // 链表元素总数

    public UnrolledLinkedList(int blockCapacity) {
        /**
         * 构造函数
         * @param blockCapacity 块的最大容量
         * @throws IllegalArgumentException 如果块容量小于2
         */
        if (blockCapacity < 2) {
            throw new IllegalArgumentException("Block capacity must be at least 2");
        }

        this.blockCapacity = blockCapacity;
        this.head = null;
        this.tail = null;
        this.size = 0;
    }

    public UnrolledLinkedList() {
        /**
         * 默认构造函数，使用默认块容量16
         */
        this(16);
    }

    public boolean isEmpty() {
        /**
         * 检查链表是否为空
         * @return 链表是否为空
         */
        return size == 0;
    }

    public int getSize() {
        /**
         * 获取链表中元素的数量
         * @return 元素数量
         */
        return size;
    }

    public void add(Object value) {
        /**
         * 在链表末尾添加元素
         * 时间复杂度：O(n/b) 均摊，其中b是块容量
         * @param value 要添加的值
         */
        if (isEmpty()) {
            // 空链表，创建第一个块
            head = new Block(blockCapacity);
            tail = head;
            head.add(value);
        } else {
            // 非空链表，检查尾块是否已满
            if (tail.isFull()) {
                // 尾块已满，分割为两个半满的块
                tail.split(tail.getSize() / 2);
                tail = tail.next; // 更新尾块指针
            }
            tail.add(value);
        }
        size++;
    }

    public void insert(int index, Object value) {
        /**
         * 在指定位置插入元素
         * 时间复杂度：O(n/b)
         * @param index 插入位置
         * @param value 要插入的值
         * @throws IndexOutOfBoundsException 如果索引无效
         */
        if (index < 0 || index > size) {
            throw new IndexOutOfBoundsException("Index out of bounds: " + index);
        }

        if (index == size) {
            // 在末尾插入，调用add方法
            add(value);
            return;
        }

        if (isEmpty()) {
            // 空链表，创建第一个块
            head = new Block(blockCapacity);
            tail = head;
            head.add(value);
        } else {
            // 定位到包含插入位置的块和块内索引
            BlockAndIndex pos = findBlockAndIndex(index);
            Block block = pos.block;
            int blockIndex = pos.index;

            // 检查块是否已满
            if (block.isFull()) {
                // 块已满，分割为两个半满的块
                int splitIndex = block.getSize() / 2;
                Block newBlock = block.split(splitIndex);

                // 调整插入位置
                if (blockIndex >= splitIndex) {
                    block = newBlock;
                    blockIndex -= splitIndex;
                }
            }

            // 在块中插入元素
            block.insert(blockIndex, value);

            // 更新尾块指针（如果需要）
            Block current = head;
            while (current.next != null) {
                current = current.next;
            }
            tail = current;
        }

        size++;
    }

    public Object delete(int index) {
        /**
         * 删除指定位置的元素
         * 时间复杂度：O(n/b)
         * @param index 要删除的元素位置
         * @return 被删除的元素
         * @throws IndexOutOfBoundsException 如果索引无效
         */
        if (isEmpty()) {
            throw new RuntimeException("Cannot delete from empty list");
        }

        if (index < 0 || index >= size) {
            throw new IndexOutOfBoundsException("Index out of bounds: " + index);
        }

        // 定位到包含删除位置的块和块内索引
        BlockAndIndex pos = findBlockAndIndex(index);
        Block block = pos.block;
        int blockIndex = pos.index;

        // 保存要删除的元素值
        Object value = block.delete(blockIndex);

        // 如果删除后块的大小过小，尝试与相邻块合并（保持块的大小在合理范围）
        if ((block.getSize() < blockCapacity / 4 && block != head) ||
            (block.isEmpty() && size > 0)) {  // 特殊处理空块

            // 优先与前一个块合并
            if (block.prev != null) {
                Block prevBlock = block.prev;
                // 确保合并后不会超出容量
                if (prevBlock.getSize() + block.getSize() <= blockCapacity) {
                    // 将要删除的索引调整为前一个块的末尾
                    if (block == tail) {
                        tail = prevBlock;
                    }
                    prevBlock.mergeNext();
                    // 如果当前删除的块是head，更新head指针
                    if (block == head) {
                        head = prevBlock;
                    }
                }
            // 否则与后一个块合并
            } else if (block.next != null) {
                Block nextBlock = block.next;
                if (block.getSize() + nextBlock.getSize() <= blockCapacity) {
                    if (nextBlock == tail) {
                        tail = block;
                    }
                    block.mergeNext();
                }
            // 特殊情况：只剩一个空块
            } else if (block.isEmpty()) {
                head = null;
                tail = null;
            }
        }

        size--;
        return value;
    }

    public Object get(int index) {
        /**
         * 获取指定位置的元素
         * 时间复杂度：O(n/b)
         * @param index 元素位置
         * @return 元素值
         * @throws IndexOutOfBoundsException 如果索引无效
         */
        if (isEmpty()) {
            throw new RuntimeException("List is empty");
        }

        if (index < 0 || index >= size) {
            throw new IndexOutOfBoundsException("Index out of bounds: " + index);
        }

        BlockAndIndex pos = findBlockAndIndex(index);
        return pos.block.get(pos.index);
    }

    public Object set(int index, Object value) {
        /**
         * 设置指定位置的元素值
         * 时间复杂度：O(n/b)
         * @param index 元素位置
         * @param value 新的元素值
         * @return 原来的元素值
         * @throws IndexOutOfBoundsException 如果索引无效
         */
        if (isEmpty()) {
            throw new RuntimeException("List is empty");
        }

        if (index < 0 || index >= size) {
            throw new IndexOutOfBoundsException("Index out of bounds: " + index);
        }

        BlockAndIndex pos = findBlockAndIndex(index);
        return pos.block.set(pos.index, value);
    }

    public void clear() {
        /**
         * 清空链表
         * 时间复杂度：O(n)
         */
        head = null;
        tail = null;
        size = 0;
    }

    public Object[] toArray() {
        /**
         * 将链表内容转换为数组
         * 时间复杂度：O(n)
         * @return 包含链表所有元素的数组
         */
        if (isEmpty()) {
            return new Object[0];
        }

        Object[] result = new Object[size];
        Block current = head;
        int resultIndex = 0;

        while (current != null) {
            for (int i = 0; i < current.getSize(); i++) {
                result[resultIndex++] = current.get(i);
            }
            current = current.next;
        }

        return result;
    }

    public int indexOf(Object value) {
        /**
         * 查找第一个出现的指定值的索引
         * 时间复杂度：O(n)
         * @param value 要查找的值
         * @return 元素索引，如果未找到返回-1
         */
        if (isEmpty()) {
            return -1;
        }

        int index = 0;
        Block current = head;

        while (current != null) {
            for (int i = 0; i < current.getSize(); i++) {
                if (Objects.equals(current.get(i), value)) {
                    return index + i;
                }
            }
            index += current.getSize();
            current = current.next;
        }

        return -1;
    }

    public int lastIndexOf(Object value) {
        /**
         * 查找最后一个出现的指定值的索引
         * 时间复杂度：O(n)
         * @param value 要查找的值
         * @return 元素索引，如果未找到返回-1
         */
        if (isEmpty()) {
            return -1;
        }

        int index = size - 1;
        Block current = tail;
        int currentBlockSize = current.getSize();

        while (current != null) {
            for (int i = currentBlockSize - 1; i >= 0; i--) {
                if (Objects.equals(current.get(i), value)) {
                    return index - (currentBlockSize - 1 - i);
                }
            }

            index -= currentBlockSize;
            current = current.prev;
            currentBlockSize = (current != null) ? current.getSize() : 0;
        }

        return -1;
    }

    public boolean contains(Object value) {
        /**
         * 检查链表是否包含指定值
         * 时间复杂度：O(n)
         * @param value 要检查的值
         * @return 是否包含该值
         */
        return indexOf(value) != -1;
    }

    public UnrolledLinkedList subList(int start, int end) {
        /**
         * 范围查询：获取从start到end（不包含）的子列表
         * 时间复杂度：O(n/b + k)，其中k是子列表的大小
         * @param start 起始索引（包含）
         * @param end 结束索引（不包含）
         * @return 子列表
         * @throws IndexOutOfBoundsException 如果索引无效
         */
        if (start < 0 || end > size || start > end) {
            throw new IndexOutOfBoundsException("Invalid range: [" + start + ", " + end + ")");
        }

        UnrolledLinkedList sublist = new UnrolledLinkedList(blockCapacity);

        if (start == end) {
            return sublist; // 空的子列表
        }

        // 处理跨越多个块的情况
        int currentIndex = start;
        while (currentIndex < end) {
            sublist.add(get(currentIndex));
            currentIndex++;
        }

        return sublist;
    }

    public void printList() {
        /**
         * 打印链表内容
         * 时间复杂度：O(n)
         */
        if (isEmpty()) {
            System.out.println("List is empty");
            return;
        }

        System.out.print("UnrolledLinkedList: [");
        Block current = head;
        boolean firstElement = true;

        while (current != null) {
            for (int i = 0; i < current.getSize(); i++) {
                if (!firstElement) {
                    System.out.print(", ");
                } else {
                    firstElement = false;
                }
                System.out.print(current.get(i));
            }
            current = current.next;
        }

        System.out.println("]");
    }

    public void printBlockStructure() {
        /**
         * 打印链表的块结构（用于调试）
         */
        if (isEmpty()) {
            System.out.println("List is empty");
            return;
        }

        System.out.println("Block Structure:");
        int blockIndex = 0;
        Block current = head;

        while (current != null) {
            System.out.print("Block " + blockIndex + " (size=" + current.getSize() + "): [");

            for (int i = 0; i < current.getSize(); i++) {
                System.out.print(current.get(i));
                if (i < current.getSize() - 1) {
                    System.out.print(", ");
                }
            }

            System.out.println("]");

            current = current.next;
            blockIndex++;
        }
    }

    // ==================== 内部辅助类和方法 ====================

    private static class BlockAndIndex {
        Block block;
        int index;

        BlockAndIndex(Block block, int index) {
            this.block = block;
            this.index = index;
        }
    }

    private BlockAndIndex findBlockAndIndex(int index) {
        /**
         * 查找包含指定索引的块和块内索引
         * 时间复杂度：O(n/b)
         * @param index 元素索引
         * @return 包含块和块内索引的对象
         */
        if (isEmpty() || index < 0 || index >= size) {
            throw new IndexOutOfBoundsException("Index out of bounds: " + index);
        }

        // 优化：根据索引位置选择从头还是从尾开始查找
        // 如果索引更靠近头部，从头开始
        if (index < size / 2) {
            Block current = head;
            int currentIndex = 0;

            while (current != null) {
                if (index < currentIndex + current.getSize()) {
                    // 找到了包含索引的块
                    return new BlockAndIndex(current, index - currentIndex);
                }
                currentIndex += current.getSize();
                current = current.next;
            }
        // 否则从尾开始
        } else {
            Block current = tail;
            int currentIndex = size - 1;
            int currentBlockSize = current.getSize();

            while (current != null) {
                if (index >= currentIndex - currentBlockSize + 1) {
                    // 找到了包含索引的块
                    return new BlockAndIndex(current, index - (currentIndex - currentBlockSize + 1));
                }
                currentIndex -= currentBlockSize;
                current = current.prev;
                currentBlockSize = (current != null) ? current.getSize() : 0;
            }
        }

        // 不应该到达这里
        throw new IndexOutOfBoundsException("Index not found: " + index);
    }

    public static void main(String[] args) {
        System.out.println("=== 测试块状链表 ===");
        // 使用较小的块容量以便更容易观察块分割和合并
        UnrolledLinkedList list = new UnrolledLinkedList(4);

        // 测试添加操作
        System.out.println("\n1. 测试添加操作:");
        for (int i = 1; i <= 10; i++) {
            list.add(i);
        }
        System.out.println("添加1-10后的列表:");
        list.printList();
        list.printBlockStructure();

        // 测试获取和设置
        System.out.println("\n2. 测试获取和设置操作:");
        System.out.println("索引5的值: " + list.get(5)); // 应该是 6
        Object oldValue = list.set(5, 100);
        System.out.println("设置索引5的值为100，旧值: " + oldValue);
        System.out.println("索引5的新值: " + list.get(5)); // 应该是 100
        list.printList();

        // 测试插入操作
        System.out.println("\n3. 测试插入操作:");
        list.insert(3, 50); // 在索引3插入50
        System.out.println("在索引3插入50后:");
        list.printList();
        list.printBlockStructure();

        list.insert(0, 0); // 在头部插入0
        System.out.println("在头部插入0后:");
        list.printList();

        // 测试删除操作
        System.out.println("\n4. 测试删除操作:");
        Object deletedValue = list.delete(5); // 删除索引5的值
        System.out.println("删除索引5的值: " + deletedValue);
        System.out.println("删除后:");
        list.printList();
        list.printBlockStructure();

        list.delete(0); // 删除头部
        System.out.println("删除头部后:");
        list.printList();

        // 测试查找操作
        System.out.println("\n5. 测试查找操作:");
        System.out.println("值为100的索引: " + list.indexOf(100));
        System.out.println("值为99的索引: " + list.indexOf(99)); // 应该是 -1
        System.out.println("列表是否包含50: " + list.contains(50));

        // 测试子列表
        System.out.println("\n6. 测试子列表:");
        UnrolledLinkedList sublist = list.subList(2, 6);
        System.out.println("子列表[2,6):");
        sublist.printList();

        // 测试清空操作
        System.out.println("\n7. 测试清空操作:");
        list.clear();
        System.out.println("清空后:");
        list.printList();
        System.out.println("列表大小: " + list.getSize());

        // 测试边界情况
        System.out.println("\n8. 测试边界情况:");
        try {
            list.get(0); // 空列表访问
        } catch (Exception e) {
            System.out.println("空列表访问异常: " + e.getMessage());
        }

        list.add(1); // 添加一个元素
        list.add(2); // 添加第二个元素
        System.out.println("添加两个元素后:");
        list.printList();

        list.delete(0); // 删除第一个元素
        list.delete(0); // 删除第二个元素
        System.out.println("删除所有元素后:");
        list.printList();

        // 性能测试
        System.out.println("\n=== 性能测试 ===");

        UnrolledLinkedList largeList = new UnrolledLinkedList(16);

        long startTime = System.nanoTime();
        for (int i = 0; i < 10000; i++) {
            largeList.add(i);
        }
        long insertTime = System.nanoTime() - startTime;

        System.out.println("插入10000个元素时间: " + insertTime / 1_000_000.0 + " ms");
        System.out.println("链表大小: " + largeList.getSize());

        // 测试随机访问
        startTime = System.nanoTime();
        for (int i = 0; i < 1000; i++) {
            largeList.get(i * 10);
        }
        long accessTime = System.nanoTime() - startTime;

        System.out.println("1000次随机访问时间: " + accessTime / 1_000_000.0 + " ms");
    }
}

===============================================

文件: unrolled_linked_list.py
===============================================
#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
块状链表实现 (Python版本)

算法思路：
块状链表是一种结合了数组和链表优点的数据结构。它将元素分块存储在节点中，
每个节点包含一个固定大小的数组和指向下一个节点的指针。

应用场景：
1. 大型序列维护：文本编辑器、数据库索引
2. 数组操作优化：批量更新处理
3. 文件系统：大文件的分块管理

时间复杂度：
- 插入/删除：O(n/b) 均摊，其中b是块大小
- 查找：O(n/b)
- 空间复杂度：O(n)
"""

class Block:
    """块状链表的块类"""
    
    def __init__(self, capacity):
        """
        构造函数
        :param capacity: 块的最大容量
        """
        self.capacity = capacity      # 块的最大容量
        self.array = [None] * capacity  # 块内的数组
        self.size = 0                 # 当前块中元素的数量
        self.next = None              # 指向下一个块
        self.prev = None              # 指向上一个块
    
    def is_full(self):
        """
        检查块是否已满
        :return: 块是否已满
        """
        return self.size == self.capacity
    
    def is_empty(self):
        """
        检查块是否为空
        :return: 块是否为空
        """
        return self.size == 0
    
    def get_size(self):
        """
        获取块的大小
        :return: 块中元素的数量
        """
        return self.size
    
    def get_capacity(self):
        """
        获取块的容量
        :return: 块的最大容量
        """
        return self.capacity
    
    def add(self, value):
        """
        在块的末尾添加元素
        :param value: 要添加的值
        :raises RuntimeError: 如果块已满
        """
        if self.is_full():
            raise RuntimeError("Block is full")
        self.array[self.size] = value
        self.size += 1
    
    def insert(self, index, value):
        """
        在指定位置插入元素
        :param index: 插入位置
        :param value: 要插入的值
        :raises IndexError: 如果索引无效
        :raises RuntimeError: 如果块已满
        """
        if self.is_full():
            raise RuntimeError("Block is full")
        
        if index < 0 or index > self.size:
            raise IndexError(f"Index out of bounds: {index}")
        
        # 移动元素为新元素腾出空间
        for i in range(self.size, index, -1):
            self.array[i] = self.array[i - 1]
        self.array[index] = value
        self.size += 1
    
    def delete(self, index):
        """
        删除指定位置的元素
        :param index: 要删除的元素位置
        :return: 被删除的元素
        :raises IndexError: 如果索引无效
        """
        if index < 0 or index >= self.size:
            raise IndexError(f"Index out of bounds: {index}")
        
        value = self.array[index]
        
        # 移动元素覆盖被删除的元素
        for i in range(index, self.size - 1):
            self.array[i] = self.array[i + 1]
        self.array[self.size - 1] = None  # 清除引用
        self.size -= 1
        
        return value
    
    def get(self, index):
        """
        获取指定位置的元素
        :param index: 元素位置
        :return: 元素值
        :raises IndexError: 如果索引无效
        """
        if index < 0 or index >= self.size:
            raise IndexError(f"Index out of bounds: {index}")
        return self.array[index]
    
    def set(self, index, value):
        """
        设置指定位置的元素值
        :param index: 元素位置
        :param value: 新的元素值
        :return: 原来的元素值
        :raises IndexError: 如果索引无效
        """
        if index < 0 or index >= self.size:
            raise IndexError(f"Index out of bounds: {index}")
        
        old_value = self.array[index]
        self.array[index] = value
        return old_value
    
    def split(self, split_index):
        """
        分割块
        将当前块从指定位置分割，返回包含后半部分元素的新块
        :param split_index: 分割位置
        :return: 包含后半部分元素的新块
        :raises IndexError: 如果分割位置无效
        """
        if split_index < 0 or split_index > self.size:
            raise IndexError(f"Split index out of bounds: {split_index}")
        
        # 创建新块
        new_block = Block(self.capacity)
        
        # 复制后半部分元素到新块
        elements_to_move = self.size - split_index
        for i in range(elements_to_move):
            new_block.array[i] = self.array[split_index + i]
            self.array[split_index + i] = None  # 清除引用
        
        # 更新块大小
        new_block.size = elements_to_move
        self.size = split_index
        
        # 建立双向链接
        new_block.next = self.next
        if self.next is not None:
            self.next.prev = new_block
        self.next = new_block
        new_block.prev = self
        
        return new_block
    
    def merge_next(self):
        """
        合并两个相邻块
        假设当前块和next块是相邻的
        :return: 合并后的块（即当前块）
        :raises RuntimeError: 如果没有下一个块或合并后超出容量
        """
        if self.next is None:
            raise RuntimeError("No next block to merge")
        
        if self.size + self.next.size > self.capacity:
            raise RuntimeError("Merged size exceeds block capacity")
        
        # 复制next块的元素到当前块
        for i in range(self.next.size):
            self.array[self.size + i] = self.next.array[i]
            self.next.array[i] = None  # 清除引用
        self.size += self.next.size
        
        # 更新链接，跳过next块
        next_next = self.next.next
        self.next = next_next
        if next_next is not None:
            next_next.prev = self
        
        return self

class UnrolledLinkedList:
    """块状链表实现"""
    
    def __init__(self, block_capacity=16):
        """
        构造函数
        :param block_capacity: 块的最大容量
        :raises ValueError: 如果块容量小于2
        """
        if block_capacity < 2:
            raise ValueError("Block capacity must be at least 2")
        
        self.block_capacity = block_capacity  # 块的最大容量
        self.head = None                      # 头块指针
        self.tail = None                      # 尾块指针
        self.size = 0                         # 链表元素总数
    
    def is_empty(self):
        """
        检查链表是否为空
        :return: 链表是否为空
        """
        return self.size == 0
    
    def get_size(self):
        """
        获取链表中元素的数量
        :return: 元素数量
        """
        return self.size
    
    def add(self, value):
        """
        在链表末尾添加元素
        时间复杂度：O(n/b) 均摊，其中b是块容量
        :param value: 要添加的值
        """
        if self.is_empty():
            # 空链表，创建第一个块
            self.head = Block(self.block_capacity)
            self.tail = self.head
            self.head.add(value)
        else:
            # 非空链表，检查尾块是否已满
            if self.tail.is_full():
                # 尾块已满，分割为两个半满的块
                self.tail.split(self.tail.get_size() // 2)
                self.tail = self.tail.next  # 更新尾块指针
            self.tail.add(value)
        self.size += 1
    
    def insert(self, index, value):
        """
        在指定位置插入元素
        时间复杂度：O(n/b)
        :param index: 插入位置
        :param value: 要插入的值
        :raises IndexError: 如果索引无效
        """
        if index < 0 or index > self.size:
            raise IndexError(f"Index out of bounds: {index}")
        
        if index == self.size:
            # 在末尾插入，调用add方法
            self.add(value)
            return
        
        if self.is_empty():
            # 空链表，创建第一个块
            self.head = Block(self.block_capacity)
            self.tail = self.head
            self.head.add(value)
        else:
            # 定位到包含插入位置的块和块内索引
            pos = self._find_block_and_index(index)
            block = pos[0]
            block_index = pos[1]
            
            # 检查块是否已满
            if block.is_full():
                # 块已满，分割为两个半满的块
                split_index = block.get_size() // 2
                new_block = block.split(split_index)
                
                # 调整插入位置
                if block_index >= split_index:
                    block = new_block
                    block_index -= split_index
            
            # 在块中插入元素
            block.insert(block_index, value)
            
            # 更新尾块指针（如果需要）
            current = self.head
            while current.next is not None:
                current = current.next
            self.tail = current
        
        self.size += 1
    
    def delete(self, index):
        """
        删除指定位置的元素
        时间复杂度：O(n/b)
        :param index: 要删除的元素位置
        :return: 被删除的元素
        :raises IndexError: 如果索引无效
        """
        if self.is_empty():
            raise RuntimeError("Cannot delete from empty list")
        
        if index < 0 or index >= self.size:
            raise IndexError(f"Index out of bounds: {index}")
        
        # 定位到包含删除位置的块和块内索引
        pos = self._find_block_and_index(index)
        block = pos[0]
        block_index = pos[1]
        
        # 保存要删除的元素值
        value = block.delete(block_index)
        
        # 如果删除后块的大小过小，尝试与相邻块合并（保持块的大小在合理范围）
        if block.get_size() < self.block_capacity // 4 and block != self.head or \
           block.is_empty() and self.size > 0:  # 特殊处理空块
            
            # 优先与前一个块合并
            if block.prev is not None:
                prev_block = block.prev
                # 确保合并后不会超出容量
                if prev_block.get_size() + block.get_size() <= self.block_capacity:
                    # 将要删除的索引调整为前一个块的末尾
                    if block == self.tail:
                        self.tail = prev_block
                    prev_block.merge_next()
                    # 如果当前删除的块是head，更新head指针
                    if block == self.head:
                        self.head = prev_block
            # 否则与后一个块合并
            elif block.next is not None:
                next_block = block.next
                if block.get_size() + next_block.get_size() <= self.block_capacity:
                    if next_block == self.tail:
                        self.tail = block
                    block.merge_next()
            # 特殊情况：只剩一个空块
            elif block.is_empty():
                self.head = None
                self.tail = None
        
        self.size -= 1
        return value
    
    def get(self, index):
        """
        获取指定位置的元素
        时间复杂度：O(n/b)
        :param index: 元素位置
        :return: 元素值
        :raises IndexError: 如果索引无效
        """
        if self.is_empty():
            raise RuntimeError("List is empty")
        
        if index < 0 or index >= self.size:
            raise IndexError(f"Index out of bounds: {index}")
        
        pos = self._find_block_and_index(index)
        return pos[0].get(pos[1])
    
    def set(self, index, value):
        """
        设置指定位置的元素值
        时间复杂度：O(n/b)
        :param index: 元素位置
        :param value: 新的元素值
        :return: 原来的元素值
        :raises IndexError: 如果索引无效
        """
        if self.is_empty():
            raise RuntimeError("List is empty")
        
        if index < 0 or index >= self.size:
            raise IndexError(f"Index out of bounds: {index}")
        
        pos = self._find_block_and_index(index)
        return pos[0].set(pos[1], value)
    
    def clear(self):
        """
        清空链表
        时间复杂度：O(n)
        """
        self.head = None
        self.tail = None
        self.size = 0
    
    def to_array(self):
        """
        将链表内容转换为数组
        时间复杂度：O(n)
        :return: 包含链表所有元素的数组
        """
        if self.is_empty():
            return []
        
        result = []
        current = self.head
        
        while current is not None:
            for i in range(current.get_size()):
                result.append(current.get(i))
            current = current.next
        
        return result
    
    def index_of(self, value):
        """
        查找第一个出现的指定值的索引
        时间复杂度：O(n)
        :param value: 要查找的值
        :return: 元素索引，如果未找到返回-1
        """
        if self.is_empty():
            return -1
        
        index = 0
        current = self.head
        
        while current is not None:
            for i in range(current.get_size()):
                if current.get(i) == value:
                    return index + i
            index += current.get_size()
            current = current.next
        
        return -1
    
    def last_index_of(self, value):
        """
        查找最后一个出现的指定值的索引
        时间复杂度：O(n)
        :param value: 要查找的值
        :return: 元素索引，如果未找到返回-1
        """
        if self.is_empty():
            return -1
        
        index = self.size - 1
        current = self.tail
        current_block_size = current.get_size()
        
        while current is not None:
            for i in range(current_block_size - 1, -1, -1):
                if current.get(i) == value:
                    return index - (current_block_size - 1 - i)
            
            index -= current_block_size
            current = current.prev
            current_block_size = current.get_size() if current is not None else 0
        
        return -1
    
    def contains(self, value):
        """
        检查链表是否包含指定值
        时间复杂度：O(n)
        :param value: 要检查的值
        :return: 是否包含该值
        """
        return self.index_of(value) != -1
    
    def sub_list(self, start, end):
        """
        范围查询：获取从start到end（不包含）的子列表
        时间复杂度：O(n/b + k)，其中k是子列表的大小
        :param start: 起始索引（包含）
        :param end: 结束索引（不包含）
        :return: 子列表
        :raises IndexError: 如果索引无效
        """
        if start < 0 or end > self.size or start > end:
            raise IndexError(f"Invalid range: [{start}, {end})")
        
        sublist = UnrolledLinkedList(self.block_capacity)
        
        if start == end:
            return sublist  # 空的子列表
        
        # 处理跨越多个块的情况
        current_index = start
        while current_index < end:
            sublist.add(self.get(current_index))
            current_index += 1
        
        return sublist
    
    def print_list(self):
        """
        打印链表内容
        时间复杂度：O(n)
        """
        if self.is_empty():
            print("List is empty")
            return
        
        print("UnrolledLinkedList: [", end="")
        current = self.head
        first_element = True
        
        while current is not None:
            for i in range(current.get_size()):
                if not first_element:
                    print(", ", end="")
                else:
                    first_element = False
                print(current.get(i), end="")
            current = current.next
        
        print("]")
    
    def print_block_structure(self):
        """
        打印链表的块结构（用于调试）
        """
        if self.is_empty():
            print("List is empty")
            return
        
        print("Block Structure:")
        block_index = 0
        current = self.head
        
        while current is not None:
            print(f"Block {block_index} (size={current.get_size()}): [", end="")
            
            for i in range(current.get_size()):
                print(current.get(i), end="")
                if i < current.get_size() - 1:
                    print(", ", end="")
            
            print("]")
            
            current = current.next
            block_index += 1
    
    # ==================== 内部辅助方法 ====================
    
    def _find_block_and_index(self, index):
        """
        查找包含指定索引的块和块内索引
        时间复杂度：O(n/b)
        :param index: 元素索引
        :return: 包含块和块内索引的元组
        """
        if self.is_empty() or index < 0 or index >= self.size:
            raise IndexError(f"Index out of bounds: {index}")
        
        # 优化：根据索引位置选择从头还是从尾开始查找
        # 如果索引更靠近头部，从头开始
        if index < self.size / 2:
            current = self.head
            current_index = 0
            
            while current is not None:
                if index < current_index + current.get_size():
                    # 找到了包含索引的块
                    return (current, index - current_index)
                current_index += current.get_size()
                current = current.next
        # 否则从尾开始
        else:
            current = self.tail
            current_index = self.size - 1
            current_block_size = current.get_size()
            
            while current is not None:
                if index >= current_index - current_block_size + 1:
                    # 找到了包含索引的块
                    return (current, index - (current_index - current_block_size + 1))
                current_index -= current_block_size
                current = current.prev
                current_block_size = current.get_size() if current is not None else 0
        
        # 不应该到达这里
        raise IndexError(f"Index not found: {index}")
    
    @staticmethod
    def test_unrolled_linked_list():
        """测试块状链表的各种操作"""
        print("=== 测试块状链表 ===")
        # 使用较小的块容量以便更容易观察块分割和合并
        list_obj = UnrolledLinkedList(4)
        
        # 测试添加操作
        print("\n1. 测试添加操作:")
        for i in range(1, 11):
            list_obj.add(i)
        print("添加1-10后的列表:")
        list_obj.print_list()
        list_obj.print_block_structure()
        
        # 测试获取和设置
        print("\n2. 测试获取和设置操作:")
        print("索引5的值:", list_obj.get(5))  # 应该是 6
        old_value = list_obj.set(5, 100)
        print("设置索引5的值为100，旧值:", old_value)
        print("索引5的新值:", list_obj.get(5))  # 应该是 100
        list_obj.print_list()
        
        # 测试插入操作
        print("\n3. 测试插入操作:")
        list_obj.insert(3, 50)  # 在索引3插入50
        print("在索引3插入50后:")
        list_obj.print_list()
        list_obj.print_block_structure()
        
        list_obj.insert(0, 0)  # 在头部插入0
        print("在头部插入0后:")
        list_obj.print_list()
        
        # 测试删除操作
        print("\n4. 测试删除操作:")
        deleted_value = list_obj.delete(5)  # 删除索引5的值
        print("删除索引5的值:", deleted_value)
        print("删除后:")
        list_obj.print_list()
        list_obj.print_block_structure()
        
        list_obj.delete(0)  # 删除头部
        print("删除头部后:")
        list_obj.print_list()
        
        # 测试查找操作
        print("\n5. 测试查找操作:")
        print("值为100的索引:", list_obj.index_of(100))
        print("值为99的索引:", list_obj.index_of(99))  # 应该是 -1
        print("列表是否包含50:", list_obj.contains(50))
        
        # 测试子列表
        print("\n6. 测试子列表:")
        sublist = list_obj.sub_list(2, 6)
        print("子列表[2,6):")
        sublist.print_list()
        
        # 测试清空操作
        print("\n7. 测试清空操作:")
        list_obj.clear()
        print("清空后:")
        list_obj.print_list()
        print("列表大小:", list_obj.get_size())
        
        # 测试边界情况
        print("\n8. 测试边界情况:")
        try:
            list_obj.get(0)  # 空列表访问
        except Exception as e:
            print("空列表访问异常:", e)
        
        list_obj.add(1)  # 添加一个元素
        list_obj.add(2)  # 添加第二个元素
        print("添加两个元素后:")
        list_obj.print_list()
        
        list_obj.delete(0)  # 删除第一个元素
        list_obj.delete(0)  # 删除第二个元素
        print("删除所有元素后:")
        list_obj.print_list()
        
        # 性能测试
        print("\n=== 性能测试 ===")
        import time
        
        # 测试大量插入操作
        large_list = UnrolledLinkedList(16)
        
        start_time = time.time()
        for i in range(10000):
            large_list.add(i)
        insert_time = time.time() - start_time
        
        print(f"插入10000个元素时间: {insert_time*1000:.2f} ms")
        print(f"链表大小: {large_list.get_size()}")
        
        # 测试随机访问
        start_time = time.time()
        for i in range(1000):
            large_list.get(i * 10)
        access_time = time.time() - start_time
        
        print(f"1000次随机访问时间: {access_time*1000:.2f} ms")

if __name__ == "__main__":
    UnrolledLinkedList.test_unrolled_linked_list()

===============================================

文件: unrolled_linked_list_1.py
===============================================
#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
块状链表实现 (Python版本)

算法思路：
块状链表是一种结合了数组和链表优点的数据结构。它将元素分块存储在节点中，
每个节点包含一个固定大小的数组和指向下一个节点的指针。

应用场景：
1. 大型序列维护：文本编辑器、数据库索引
2. 数组操作优化：批量更新处理
3. 文件系统：大文件的分块管理

时间复杂度：
- 插入/删除：O(n/b) 均摊，其中b是块大小
- 查找：O(n/b)
- 空间复杂度：O(n)

相关题目：
1. LeetCode 641. 设计循环双端队列
2. LeetCode 707. 设计链表
3. LeetCode 146. LRU缓存机制
"""

class Block:
    """块状链表的块类"""
    
    def __init__(self, capacity):
        """
        构造函数
        :param capacity: 块的最大容量
        """
        self.capacity = capacity      # 块的最大容量
        self.array = [None] * capacity  # 块内的数组
        self.size = 0                 # 当前块中元素的数量
        self.next = None              # 指向下一个块
        self.prev = None              # 指向上一个块
    
    def is_full(self):
        """
        检查块是否已满
        :return: 块是否已满
        """
        return self.size == self.capacity
    
    def is_empty(self):
        """
        检查块是否为空
        :return: 块是否为空
        """
        return self.size == 0
    
    def get_size(self):
        """
        获取块的大小
        :return: 块中元素的数量
        """
        return self.size
    
    def get_capacity(self):
        """
        获取块的容量
        :return: 块的最大容量
        """
        return self.capacity
    
    def add(self, value):
        """
        在块的末尾添加元素
        :param value: 要添加的值
        :raises RuntimeError: 如果块已满
        """
        if self.is_full():
            raise RuntimeError("Block is full")
        self.array[self.size] = value
        self.size += 1
    
    def insert(self, index, value):
        """
        在指定位置插入元素
        :param index: 插入位置
        :param value: 要插入的值
        :raises IndexError: 如果索引无效
        :raises RuntimeError: 如果块已满
        """
        if self.is_full():
            raise RuntimeError("Block is full")
        
        if index < 0 or index > self.size:
            raise IndexError(f"Index out of bounds: {index}")
        
        # 移动元素为新元素腾出空间
        for i in range(self.size, index, -1):
            self.array[i] = self.array[i - 1]
        self.array[index] = value
        self.size += 1
    
    def delete(self, index):
        """
        删除指定位置的元素
        :param index: 要删除的元素位置
        :return: 被删除的元素
        :raises IndexError: 如果索引无效
        """
        if index < 0 or index >= self.size:
            raise IndexError(f"Index out of bounds: {index}")
        
        value = self.array[index]
        
        # 移动元素覆盖被删除的元素
        for i in range(index, self.size - 1):
            self.array[i] = self.array[i + 1]
        self.array[self.size - 1] = None  # 清除引用
        self.size -= 1
        
        return value
    
    def get(self, index):
        """
        获取指定位置的元素
        :param index: 元素位置
        :return: 元素值
        :raises IndexError: 如果索引无效
        """
        if index < 0 or index >= self.size:
            raise IndexError(f"Index out of bounds: {index}")
        return self.array[index]
    
    def set(self, index, value):
        """
        设置指定位置的元素值
        :param index: 元素位置
        :param value: 新的元素值
        :return: 原来的元素值
        :raises IndexError: 如果索引无效
        """
        if index < 0 or index >= self.size:
            raise IndexError(f"Index out of bounds: {index}")
        
        old_value = self.array[index]
        self.array[index] = value
        return old_value
    
    def split(self, split_index):
        """
        分割块
        将当前块从指定位置分割，返回包含后半部分元素的新块
        :param split_index: 分割位置
        :return: 包含后半部分元素的新块
        :raises IndexError: 如果分割位置无效
        """
        if split_index < 0 or split_index > self.size:
            raise IndexError(f"Split index out of bounds: {split_index}")
        
        # 创建新块
        new_block = Block(self.capacity)
        
        # 复制后半部分元素到新块
        elements_to_move = self.size - split_index
        for i in range(elements_to_move):
            new_block.array[i] = self.array[split_index + i]
            self.array[split_index + i] = None  # 清除引用
        
        # 更新块大小
        new_block.size = elements_to_move
        self.size = split_index
        
        # 建立双向链接
        new_block.next = self.next
        if self.next is not None:
            self.next.prev = new_block
        self.next = new_block
        new_block.prev = self
        
        return new_block
    
    def merge_next(self):
        """
        合并两个相邻块
        假设当前块和next块是相邻的
        :return: 合并后的块（即当前块）
        :raises RuntimeError: 如果没有下一个块或合并后超出容量
        """
        if self.next is None:
            raise RuntimeError("No next block to merge")
        
        if self.size + self.next.size > self.capacity:
            raise RuntimeError("Merged size exceeds block capacity")
        
        # 复制next块的元素到当前块
        for i in range(self.next.size):
            self.array[self.size + i] = self.next.array[i]
            self.next.array[i] = None  # 清除引用
        self.size += self.next.size
        
        # 更新链接，跳过next块
        next_next = self.next.next
        self.next = next_next
        if next_next is not None:
            next_next.prev = self
        
        return self

class UnrolledLinkedList:
    """块状链表实现"""
    
    def __init__(self, block_capacity=16):
        """
        构造函数
        :param block_capacity: 块的最大容量
        :raises ValueError: 如果块容量小于2
        """
        if block_capacity < 2:
            raise ValueError("Block capacity must be at least 2")
        
        self.block_capacity = block_capacity  # 块的最大容量
        self.head = None                      # 头块指针
        self.tail = None                      # 尾块指针
        self.size = 0                         # 链表元素总数
    
    def is_empty(self):
        """
        检查链表是否为空
        :return: 链表是否为空
        """
        return self.size == 0
    
    def get_size(self):
        """
        获取链表中元素的数量
        :return: 元素数量
        """
        return self.size
    
    def add(self, value):
        """
        在链表末尾添加元素
        时间复杂度：O(n/b) 均摊，其中b是块容量
        :param value: 要添加的值
        """
        if self.is_empty():
            # 空链表，创建第一个块
            self.head = Block(self.block_capacity)
            self.tail = self.head
            self.head.add(value)
        else:
            # 非空链表，检查尾块是否已满
            if self.tail is not None and self.tail.is_full():
                # 尾块已满，分割为两个半满的块
                if self.tail is not None:
                    self.tail.split(self.tail.get_size() // 2)
                    self.tail = self.tail.next  # 更新尾块指针
            if self.tail is not None:
                self.tail.add(value)
        self.size += 1
    
    def insert(self, index, value):
        """
        在指定位置插入元素
        时间复杂度：O(n/b)
        :param index: 插入位置
        :param value: 要插入的值
        :raises IndexError: 如果索引无效
        """
        if index < 0 or index > self.size:
            raise IndexError(f"Index out of bounds: {index}")
        
        if index == self.size:
            # 在末尾插入，调用add方法
            self.add(value)
            return
        
        if self.is_empty():
            # 空链表，创建第一个块
            self.head = Block(self.block_capacity)
            self.tail = self.head
            self.head.add(value)
        else:
            # 定位到包含插入位置的块和块内索引
            pos = self._find_block_and_index(index)
            block = pos[0]
            block_index = pos[1]
            
            # 检查块是否已满
            if block.is_full():
                # 块已满，分割为两个半满的块
                split_index = block.get_size() // 2
                new_block = block.split(split_index)
                
                # 调整插入位置
                if block_index >= split_index:
                    block = new_block
                    block_index -= split_index
            
            # 在块中插入元素
            block.insert(block_index, value)
            
            # 更新尾块指针（如果需要）
            current = self.head
            if current is not None:
                while current.next is not None:
                    current = current.next
                self.tail = current
        
        self.size += 1
    
    def delete(self, index):
        """
        删除指定位置的元素
        时间复杂度：O(n/b)
        :param index: 要删除的元素位置
        :return: 被删除的元素
        :raises IndexError: 如果索引无效
        """
        if self.is_empty():
            raise RuntimeError("Cannot delete from empty list")
        
        if index < 0 or index >= self.size:
            raise IndexError(f"Index out of bounds: {index}")
        
        # 定位到包含删除位置的块和块内索引
        pos = self._find_block_and_index(index)
        block = pos[0]
        block_index = pos[1]
        
        # 保存要删除的元素值
        value = block.delete(block_index)
        
        # 如果删除后块的大小过小，尝试与相邻块合并（保持块的大小在合理范围）
        if (block.get_size() < self.block_capacity // 4 and block != self.head) or \
           (block.is_empty() and self.size > 0):  # 特殊处理空块
            
            # 优先与前一个块合并
            if block.prev is not None:
                prev_block = block.prev
                # 确保合并后不会超出容量
                if prev_block.get_size() + block.get_size() <= self.block_capacity:
                    # 将要删除的索引调整为前一个块的末尾
                    if block == self.tail:
                        self.tail = prev_block
                    prev_block.merge_next()
                    # 如果当前删除的块是head，更新head指针
                    if block == self.head:
                        self.head = prev_block
            # 否则与后一个块合并
            elif block.next is not None:
                next_block = block.next
                if block.get_size() + next_block.get_size() <= self.block_capacity:
                    if next_block == self.tail:
                        self.tail = block
                    block.merge_next()
            # 特殊情况：只剩一个空块
            elif block.is_empty():
                self.head = None
                self.tail = None
        
        self.size -= 1
        return value
    
    def get(self, index):
        """
        获取指定位置的元素
        时间复杂度：O(n/b)
        :param index: 元素位置
        :return: 元素值
        :raises IndexError: 如果索引无效
        """
        if self.is_empty():
            raise RuntimeError("List is empty")
        
        if index < 0 or index >= self.size:
            raise IndexError(f"Index out of bounds: {index}")
        
        pos = self._find_block_and_index(index)
        return pos[0].get(pos[1])
    
    def set(self, index, value):
        """
        设置指定位置的元素值
        时间复杂度：O(n/b)
        :param index: 元素位置
        :param value: 新的元素值
        :return: 原来的元素值
        :raises IndexError: 如果索引无效
        """
        if self.is_empty():
            raise RuntimeError("List is empty")
        
        if index < 0 or index >= self.size:
            raise IndexError(f"Index out of bounds: {index}")
        
        pos = self._find_block_and_index(index)
        return pos[0].set(pos[1], value)
    
    def clear(self):
        """
        清空链表
        时间复杂度：O(n)
        """
        self.head = None
        self.tail = None
        self.size = 0
    
    def to_array(self):
        """
        将链表内容转换为数组
        时间复杂度：O(n)
        :return: 包含链表所有元素的数组
        """
        if self.is_empty():
            return []
        
        result = []
        current = self.head
        
        while current is not None:
            for i in range(current.get_size()):
                result.append(current.get(i))
            current = current.next
        
        return result
    
    def index_of(self, value):
        """
        查找第一个出现的指定值的索引
        时间复杂度：O(n)
        :param value: 要查找的值
        :return: 元素索引，如果未找到返回-1
        """
        if self.is_empty():
            return -1
        
        index = 0
        current = self.head
        
        while current is not None:
            for i in range(current.get_size()):
                if current.get(i) == value:
                    return index + i
            index += current.get_size()
            current = current.next
        
        return -1
    
    def last_index_of(self, value):
        """
        查找最后一个出现的指定值的索引
        时间复杂度：O(n)
        :param value: 要查找的值
        :return: 元素索引，如果未找到返回-1
        """
        if self.is_empty():
            return -1
        
        index = self.size - 1
        current = self.tail
        current_block_size = current.get_size() if current is not None else 0
        
        while current is not None:
            for i in range(current_block_size - 1, -1, -1):
                if current.get(i) == value:
                    return index - (current_block_size - 1 - i)
            
            index -= current_block_size
            current = current.prev
            current_block_size = current.get_size() if current is not None else 0
        
        return -1
    
    def contains(self, value):
        """
        检查链表是否包含指定值
        时间复杂度：O(n)
        :param value: 要检查的值
        :return: 是否包含该值
        """
        return self.index_of(value) != -1
    
    def sub_list(self, start, end):
        """
        范围查询：获取从start到end（不包含）的子列表
        时间复杂度：O(n/b + k)，其中k是子列表的大小
        :param start: 起始索引（包含）
        :param end: 结束索引（不包含）
        :return: 子列表
        :raises IndexError: 如果索引无效
        """
        if start < 0 or end > self.size or start > end:
            raise IndexError(f"Invalid range: [{start}, {end})")
        
        sublist = UnrolledLinkedList(self.block_capacity)
        
        if start == end:
            return sublist  # 空的子列表
        
        # 处理跨越多个块的情况
        current_index = start
        while current_index < end:
            sublist.add(self.get(current_index))
            current_index += 1
        
        return sublist
    
    def print_list(self):
        """
        打印链表内容
        时间复杂度：O(n)
        """
        if self.is_empty():
            print("List is empty")
            return
        
        print("UnrolledLinkedList: [", end="")
        current = self.head
        first_element = True
        
        while current is not None:
            for i in range(current.get_size()):
                if not first_element:
                    print(", ", end="")
                else:
                    first_element = False
                print(current.get(i), end="")
            current = current.next
        
        print("]")
    
    def print_block_structure(self):
        """
        打印链表的块结构（用于调试）
        """
        if self.is_empty():
            print("List is empty")
            return
        
        print("Block Structure:")
        block_index = 0
        current = self.head
        
        while current is not None:
            print(f"Block {block_index} (size={current.get_size()}): [", end="")
            
            for i in range(current.get_size()):
                print(current.get(i), end="")
                if i < current.get_size() - 1:
                    print(", ", end="")
            
            print("]")
            
            current = current.next
            block_index += 1
    
    # ==================== 内部辅助方法 ====================
    
    def _find_block_and_index(self, index):
        """
        查找包含指定索引的块和块内索引
        时间复杂度：O(n/b)
        :param index: 元素索引
        :return: 包含块和块内索引的元组
        """
        if self.is_empty() or index < 0 or index >= self.size:
            raise IndexError(f"Index out of bounds: {index}")
        
        # 优化：根据索引位置选择从头还是从尾开始查找
        # 如果索引更靠近头部，从头开始
        if index < self.size / 2:
            current = self.head
            current_index = 0
            
            while current is not None:
                if index < current_index + current.get_size():
                    # 找到了包含索引的块
                    return (current, index - current_index)
                current_index += current.get_size()
                current = current.next
        # 否则从尾开始
        else:
            current = self.tail
            current_index = self.size - 1
            current_block_size = current.get_size() if current is not None else 0
            
            while current is not None:
                if index >= current_index - current_block_size + 1:
                    # 找到了包含索引的块
                    return (current, index - (current_index - current_block_size + 1))
                current_index -= current_block_size
                current = current.prev
                current_block_size = current.get_size() if current is not None else 0
        
        # 不应该到达这里
        raise IndexError(f"Index not found: {index}")
    
    @staticmethod
    def test_unrolled_linked_list():
        """测试块状链表的各种操作"""
        print("=== 测试块状链表 ===")
        # 使用较小的块容量以便更容易观察块分割和合并
        list_obj = UnrolledLinkedList(4)
        
        # 测试添加操作
        print("\n1. 测试添加操作:")
        for i in range(1, 11):
            list_obj.add(i)
        print("添加1-10后的列表:")
        list_obj.print_list()
        list_obj.print_block_structure()
        
        # 测试获取和设置
        print("\n2. 测试获取和设置操作:")
        print("索引5的值:", list_obj.get(5))  # 应该是 6
        old_value = list_obj.set(5, 100)
        print("设置索引5的值为100，旧值:", old_value)
        print("索引5的新值:", list_obj.get(5))  # 应该是 100
        list_obj.print_list()
        
        # 测试插入操作
        print("\n3. 测试插入操作:")
        list_obj.insert(3, 50)  # 在索引3插入50
        print("在索引3插入50后:")
        list_obj.print_list()
        list_obj.print_block_structure()
        
        list_obj.insert(0, 0)  # 在头部插入0
        print("在头部插入0后:")
        list_obj.print_list()
        
        # 测试删除操作
        print("\n4. 测试删除操作:")
        deleted_value = list_obj.delete(5)  # 删除索引5的值
        print("删除索引5的值:", deleted_value)
        print("删除后:")
        list_obj.print_list()
        list_obj.print_block_structure()
        
        list_obj.delete(0)  # 删除头部
        print("删除头部后:")
        list_obj.print_list()
        
        # 测试查找操作
        print("\n5. 测试查找操作:")
        print("值为100的索引:", list_obj.index_of(100))
        print("值为99的索引:", list_obj.index_of(99))  # 应该是 -1
        print("列表是否包含50:", list_obj.contains(50))
        
        # 测试子列表
        print("\n6. 测试子列表:")
        sublist = list_obj.sub_list(2, 6)
        print("子列表[2,6):")
        sublist.print_list()
        
        # 测试清空操作
        print("\n7. 测试清空操作:")
        list_obj.clear()
        print("清空后:")
        list_obj.print_list()
        print("列表大小:", list_obj.get_size())
        
        # 测试边界情况
        print("\n8. 测试边界情况:")
        try:
            list_obj.get(0)  # 空列表访问
        except Exception as e:
            print("空列表访问异常:", e)
        
        list_obj.add(1)  # 添加一个元素
        list_obj.add(2)  # 添加第二个元素
        print("添加两个元素后:")
        list_obj.print_list()
        
        list_obj.delete(0)  # 删除第一个元素
        list_obj.delete(0)  # 删除第二个元素
        print("删除所有元素后:")
        list_obj.print_list()
        
        # 性能测试
        print("\n=== 性能测试 ===")
        import time
        
        # 测试大量插入操作
        large_list = UnrolledLinkedList(16)
        
        start_time = time.time()
        for i in range(10000):
            large_list.add(i)
        insert_time = time.time() - start_time
        
        print(f"插入10000个元素时间: {insert_time*1000:.2f} ms")
        print(f"链表大小: {large_list.get_size()}")
        
        # 测试随机访问
        start_time = time.time()
        for i in range(1000):
            large_list.get(i * 10)
        access_time = time.time() - start_time
        
        print(f"1000次随机访问时间: {access_time*1000:.2f} ms")

if __name__ == "__main__":
    UnrolledLinkedList.test_unrolled_linked_list()

===============================================

