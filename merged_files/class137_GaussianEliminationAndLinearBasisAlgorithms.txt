===============================================
文件夹: class137_GaussianEliminationAndLinearBasisAlgorithms
===============================================

[Markdown 文件]
===============================================
文件: Algorithm_Technique_Summary.md
===============================================
# 高斯消元与线性基算法技巧总结

## 一、算法核心思想

### 1.1 高斯消元法（Gaussian Elimination）

**基本思想**：通过行变换将增广矩阵化为行阶梯形矩阵，从而判断方程组的解的情况。

**适用场景**：
- 求解线性方程组
- 求解异或方程组（模2意义下的线性方程组）
- 矩阵求秩
- 判断线性相关性

**时间复杂度**：O(n³)
**空间复杂度**：O(n²)

### 1.2 线性基（Linear Basis）

**基本思想**：构造一组基向量，可以表示原集合中所有元素的线性组合（在异或运算下）。

**适用场景**：
- 求异或最大值/最小值
- 求第k小异或值
- 判断某个数能否由集合中的数异或得到
- 异或和求和问题

**时间复杂度**：O(n * log(max_value))
**空间复杂度**：O(log(max_value))

## 二、题型分类与解题技巧

### 2.1 开关问题类

**典型题目**：
- POJ 1830 开关问题
- POJ 1222 EXTENDED LIGHTS OUT
- 洛谷 P2962 Lights

**解题技巧**：
1. **建模**：每个开关对应一个未知数，表示是否操作该开关
2. **方程建立**：每个开关建立一个方程，表示该开关的最终状态
3. **系数确定**：系数矩阵表示开关之间的影响关系
4. **常数项**：初始状态与目标状态的差异

**关键点**：
- 注意开关之间的相互影响
- 处理无解和无穷解的情况
- 对于大规模问题（n>30），考虑折半搜索

### 2.2 完全平方数乘积类

**典型题目**：
- HDU 5833 Zhu and 772002
- UVa 11542 Square

**解题技巧**：
1. **数学建模**：一个数是完全平方数当且仅当它的所有素因子的指数都是偶数
2. **素因子分解**：对每个数进行素因子分解，记录每个素因子指数的奇偶性
3. **异或方程组**：每个素因子对应一个方程，表示该素因子在乘积中的总指数为偶数
4. **方案计算**：方案数为2^(自由元个数) - 1

**关键点**：
- 预处理素数表
- 注意素因子分解的边界情况
- 处理大数分解（使用long类型）

### 2.3 异或最大值类

**典型题目**：
- SPOJ XMAX - XOR Maximization
- HDU 3949 XOR

**解题技巧**：
1. **线性基构造**：从高位到低位依次处理每个数
2. **贪心选择**：从高位到低位贪心选择，如果当前位可以取1则取1
3. **第k小值**：将线性基转化为简化行阶梯形矩阵，用k的二进制表示组合

**关键点**：
- 注意线性基的构造顺序
- 处理k=0的特殊情况
- 注意数值范围（使用long类型）

### 2.4 测量记录类

**典型题目**：
- 洛谷 P2447 外星千足虫

**解题技巧**：
1. **问题转化**：将测量记录转化为异或方程组
2. **动态构建**：按顺序处理测量记录，逐步构建增广矩阵
3. **解的情况**：记录需要使用的最少测量记录数

**关键点**：
- 使用位运算压缩存储
- 动态判断解的唯一性
- 处理冗余测量记录

## 三、算法优化技巧

### 3.1 高斯消元优化

**主元选择优化**：
- 选择当前列第一个非零元素作为主元
- 避免不必要的行交换操作

**消元优化**：
- 只对非零元素进行异或运算
- 使用位运算优化异或操作

**存储优化**：
- 使用位压缩存储增广矩阵
- 对于稀疏矩阵，使用特殊数据结构

### 3.2 线性基优化

**构造优化**：
- 从高位到低位处理，确保基向量的高位优先
- 使用异或操作消去低位系数

**查询优化**：
- 预处理线性基的简化形式
- 使用二进制分解快速查询

## 四、边界条件与异常处理

### 4.1 常见边界条件

**输入边界**：
- 空输入：n=0的情况
- 单个元素：n=1的情况
- 极大值：接近数据范围上限的情况

**矩阵边界**：
- 全零矩阵：无穷多解
- 矛盾方程：无解
- 奇异矩阵：秩小于未知数个数

### 4.2 异常处理策略

**参数校验**：
- 检查输入参数的合法性
- 验证矩阵元素的取值范围

**边界检查**：
- 数组越界检查
- 数值溢出检查
- 内存限制检查

**错误恢复**：
- 提供详细的错误信息
- 支持调试信息输出
- 优雅的错误处理机制

## 五、工程化考量

### 5.1 代码质量

**可读性**：
- 详细的注释说明
- 清晰的变量命名
- 模块化的代码结构

**可维护性**：
- 统一的代码风格
- 完整的测试用例
- 详细的文档说明

### 5.2 性能优化

**时间复杂度优化**：
- 选择合适的算法复杂度
- 避免不必要的计算
- 使用缓存优化

**空间复杂度优化**：
- 合理设置数组大小
- 使用原地操作
- 避免内存泄漏

### 5.3 跨语言实现

**Java特性**：
- 使用面向对象封装
- 完善的异常处理机制
- 支持泛型编程

**C++特性**：
- 使用模板编程
- 内存管理优化
- 标准库支持

**Python特性**：
- 简洁的语法
- 丰富的库支持
- 动态类型系统

## 六、实战技巧

### 6.1 调试技巧

**打印中间结果**：
- 打印增广矩阵的中间状态
- 输出关键变量的实时值
- 使用断言验证中间结果

**测试用例设计**：
- 设计边界测试用例
- 设计极端输入测试用例
- 设计性能测试用例

### 6.2 问题分析

**问题识别**：
- 识别问题类型（开关问题、完全平方数等）
- 确定适用的算法
- 分析问题规模和时间限制

**复杂度分析**：
- 分析算法的时间复杂度
- 分析算法的空间复杂度
- 考虑实际运行时的常数因子

## 七、总结

高斯消元和线性基是解决异或相关问题的强大工具。掌握这些算法需要：

1. **理解算法原理**：深入理解数学基础和算法思想
2. **掌握题型分类**：能够快速识别问题类型并选择合适算法
3. **熟练编码实现**：能够高效实现算法并处理各种边界情况
4. **具备调试能力**：能够快速定位和解决代码问题
5. **考虑工程化**：编写健壮、可维护、高效的代码

通过系统学习和大量练习，可以完全掌握这些算法，并在各种算法竞赛和工程应用中灵活运用。

===============================================

文件: Comprehensive_Gauss_XOR_Problems.md
===============================================
# 高斯消元与线性基算法全面题目汇总

## 目录
- [基础模板题](#基础模板题)
- [开关问题类](#开关问题类)
- [完全平方数乘积类](#完全平方数乘积类)
- [线性基应用类](#线性基应用类)
- [图论应用类](#图论应用类)
- [密码学与编码类](#密码学与编码类)
- [数学与数论类](#数学与数论类)
- [综合应用类](#综合应用类)

## 基础模板题

### 1. 洛谷 P3812 【模板】线性基
- **来源**: 洛谷 (Luogu)
- **链接**: https://www.luogu.com.cn/problem/P3812
- **难度**: 简单
- **描述**: 线性基模板题，实现线性基的基本操作
- **解题思路**: 实现线性基的插入、查询最大值等基本操作
- **时间复杂度**: O(n log M)
- **空间复杂度**: O(log M)

### 2. AcWing 884. 高斯消元解异或线性方程组
- **来源**: AcWing
- **链接**: https://www.acwing.com/problem/content/886/
- **难度**: 中等
- **描述**: 输入一个包含n个方程n个未知数的异或线性方程组
- **解题思路**: 标准高斯消元法解异或方程组
- **时间复杂度**: O(n³)
- **空间复杂度**: O(n²)

### 3. 洛谷 P2447 [SDOI2010]外星千足虫
- **来源**: 洛谷 (Luogu)
- **链接**: https://www.luogu.com.cn/problem/P2447
- **难度**: 中等
- **描述**: 有n个01变量，给定m个方程，每个方程给出若干个元素的异或和
- **解题思路**: 异或方程组的高斯消元
- **时间复杂度**: O(n³)
- **空间复杂度**: O(n²)

## 开关问题类

### 4. POJ 1830 开关问题
- **来源**: POJ (Peking University Online Judge)
- **链接**: http://poj.org/problem?id=1830
- **难度**: 中等
- **描述**: 有N个相同的开关，每个开关都与某些开关有着联系
- **解题思路**: 建立异或方程组求解
- **时间复杂度**: O(n³)
- **空间复杂度**: O(n²)

### 5. POJ 1222 EXTENDED LIGHTS OUT
- **来源**: POJ (Peking University Online Judge)
- **链接**: http://poj.org/problem?id=1222
- **难度**: 中等
- **描述**: 5x6灯阵，按一个灯会改变自己和相邻灯的状态
- **解题思路**: 异或方程组+位运算优化
- **时间复杂度**: O(n³)
- **空间复杂度**: O(n²)

### 6. POJ 1681 Painter's Problem
- **来源**: POJ (Peking University Online Judge)
- **链接**: http://poj.org/problem?id=1681
- **难度**: 中等
- **描述**: n*n方阵，每次操作改变一个格子及其相邻格子的颜色
- **解题思路**: 异或方程组+搜索
- **时间复杂度**: O(n³)
- **空间复杂度**: O(n²)

### 7. POJ 3185 The Water Bowls
- **来源**: POJ (Peking University Online Judge)
- **链接**: http://poj.org/problem?id=3185
- **难度**: 中等
- **描述**: 一排20个碗，每次翻转连续3个碗的状态
- **解题思路**: 异或方程组+枚举
- **时间复杂度**: O(n³)
- **空间复杂度**: O(n²)

### 8. 洛谷 P2962 灯 Lights
- **来源**: 洛谷 (Luogu)
- **链接**: https://www.luogu.com.cn/problem/P2962
- **难度**: 中等
- **描述**: 有n个灯和m个开关，每个开关可以改变自己和相邻灯的状态
- **解题思路**: 异或方程组+搜索
- **时间复杂度**: O(n³)
- **空间复杂度**: O(n²)

### 9. ZOJ 1602 Multiplication Puzzle
- **来源**: ZOJ (Zhejiang University Online Judge)
- **链接**: https://vjudge.net/problem/ZOJ-1602
- **难度**: 中等
- **描述**: 开关系统，每个开关影响某些灯的状态
- **解题思路**: 异或方程组应用
- **时间复杂度**: O(n³)
- **空间复杂度**: O(n²)

## 完全平方数乘积类

### 10. UVa 11542 Square
- **来源**: UVa (University of Valladolid Online Judge)
- **链接**: https://onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=2577
- **难度**: 中等
- **描述**: 将一组数分成若干子集，每个子集的乘积是完全平方数
- **解题思路**: 素因子分解+异或方程组
- **时间复杂度**: O(n * m) 其中m是质数个数
- **空间复杂度**: O(n * m)

### 11. HDU 5833 Zhu and 772002
- **来源**: HDU (Hangzhou Dianzi University Online Judge)
- **链接**: https://acm.hdu.edu.cn/showproblem.php?pid=5833
- **难度**: 中等
- **描述**: 给定一些数，选若干个它们的乘积为完全平方数有多少种方案
- **解题思路**: 素因子分解+异或方程组
- **时间复杂度**: O(n * m)
- **空间复杂度**: O(n * m)

### 12. Codeforces 954C Matrix Walk
- **来源**: Codeforces
- **链接**: https://codeforces.com/problemset/problem/954/C
- **难度**: 中等
- **描述**: 矩阵中的路径问题，与完全平方数相关
- **解题思路**: 前缀异或性质+哈希表优化
- **时间复杂度**: O(n²)
- **空间复杂度**: O(n)

## 线性基应用类

### 13. SPOJ XMAX - XOR Maximization
- **来源**: SPOJ (Sphere Online Judge)
- **链接**: https://www.spoj.com/problems/XMAX/
- **难度**: 中等
- **描述**: 给定整数集合S，求X(S)的最大值
- **解题思路**: 线性基求异或最大值
- **时间复杂度**: O(n log M)
- **空间复杂度**: O(log M)

### 14. HDU 3949 XOR
- **来源**: HDU (Hangzhou Dianzi University Online Judge)
- **链接**: https://acm.hdu.edu.cn/showproblem.php?pid=3949
- **难度**: 中等
- **描述**: 求所有子集异或和中第k小的异或值
- **解题思路**: 线性基求第k小异或值
- **时间复杂度**: O(n log M)
- **空间复杂度**: O(log M)

### 15. BZOJ 2115 [Wc2011] Xor
- **来源**: BZOJ (Beijing University Online Judge)
- **链接**: https://darkbzoj.cc/problem/2115
- **难度**: 困难
- **描述**: 求1->n的路径边权最大异或和
- **解题思路**: 线性基+图论
- **时间复杂度**: O(n log M)
- **空间复杂度**: O(log M)

### 16. Codeforces 1101G (Zero XOR Subset)-less
- **来源**: Codeforces
- **链接**: https://codeforces.com/problemset/problem/1101/G
- **难度**: 中等
- **描述**: 将数组分成最少的子段，使得每个子段的异或和都不为0
- **解题思路**: 线性基求极大线性无关组
- **时间复杂度**: O(n log M)
- **空间复杂度**: O(log M)

### 17. 牛客网 NC14533 异或和
- **来源**: 牛客网 (Nowcoder)
- **链接**: https://ac.nowcoder.com/acm/problem/14533
- **难度**: 中等
- **描述**: 求所有连续子数组的异或和的和
- **解题思路**: 前缀异或性质+位运算
- **时间复杂度**: O(n log M)
- **空间复杂度**: O(n)

### 18. LeetCode 1734. 解码异或后的排列
- **来源**: LeetCode
- **链接**: https://leetcode.cn/problems/decode-xored-permutation/
- **难度**: 中等
- **描述**: 给定encoded数组，返回原始数组perm
- **解题思路**: 异或性质+排列特性
- **时间复杂度**: O(n)
- **空间复杂度**: O(n)

### 19. LeetCode 3681. 子序列最大XOR 值
- **来源**: LeetCode
- **链接**: https://leetcode.cn/problems/maximum-xor-of-subsequences/
- **难度**: 困难
- **描述**: 求所有可能子序列的异或值的最大值
- **解题思路**: 线性基或高斯消元
- **时间复杂度**: O(n log M)
- **空间复杂度**: O(log M)

## 图论应用类

### 20. HDU 5544 Independent Loop
- **来源**: HDU (Hangzhou Dianzi University Online Judge)
- **链接**: https://acm.hdu.edu.cn/showproblem.php?pid=5544
- **难度**: 困难
- **描述**: 求所有回路中边权xor和的最大值
- **解题思路**: 线性基+图论
- **时间复杂度**: O(n log M)
- **空间复杂度**: O(log M)

### 21. 洛谷 P3292 [SCOI2016]幸运数字
- **来源**: 洛谷 (Luogu)
- **链接**: https://www.luogu.com.cn/problem/P3292
- **难度**: 困难
- **描述**: 求两点间路径上所有点权值的最大异或和
- **解题思路**: 线性基+树上倍增
- **时间复杂度**: O(n log² M)
- **空间复杂度**: O(n log M)

### 22. AtCoder ABC223 H - Xor Query
- **来源**: AtCoder
- **链接**: https://atcoder.jp/contests/abc223/tasks/abc223_h
- **难度**: 困难
- **描述**: 求区间内所有子集异或和的第k小值
- **解题思路**: 线段树维护区间线性基
- **时间复杂度**: O(n log² M)
- **空间复杂度**: O(n log M)

## 密码学与编码类

### 23. Project Euler Problem 203 Squarefree Binomial Coefficients
- **来源**: Project Euler
- **链接**: https://projecteuler.net/problem=203
- **难度**: 较难
- **描述**: 求二项式系数中平方自由数的和
- **解题思路**: 数论+异或方程组
- **时间复杂度**: O(n²)
- **空间复杂度**: O(n)

### 24. LintCode 411. Gray Code
- **来源**: LintCode
- **链接**: https://www.lintcode.com/problem/411/
- **难度**: 中等
- **描述**: 生成格雷码序列
- **解题思路**: 异或运算性质
- **时间复杂度**: O(2ⁿ)
- **空间复杂度**: O(2ⁿ)

### 25. LeetCode 869. 重新排序得到2的幂
- **来源**: LeetCode
- **链接**: https://leetcode.com/problems/reordered-power-of-2/
- **难度**: 中等
- **描述**: 判断一个数的各位重新排列后是否能得到2的幂
- **解题思路**: 数字特征分析
- **时间复杂度**: O(log n)
- **空间复杂度**: O(1)

## 数学与数论类

### 26. LeetCode 479. Largest Palindrome Product
- **来源**: LeetCode
- **链接**: https://leetcode.com/problems/largest-palindrome-product/
- **难度**: 中等
- **描述**: 求n位数乘积的最大回文数
- **解题思路**: 数学构造+回文数性质
- **时间复杂度**: O(10ⁿ)
- **空间复杂度**: O(1)

### 27. HackerEarth Square and Cubes
- **来源**: HackerEarth
- **链接**: https://www.hackerearth.com/practice/math/number-theory/basic-number-theory-2/practice-problems/algorithm/square-and-cubes/
- **难度**: 中等
- **描述**: 求既是平方数又是立方数的数
- **解题思路**: 数论性质分析
- **时间复杂度**: O(1)
- **空间复杂度**: O(1)

### 28. 计蒜客 完全平方数
- **来源**: 计蒜客
- **链接**: https://nanti.jisuanke.com/t/27763
- **难度**: 中等
- **描述**: 求完全平方数的个数
- **解题思路**: 数学分析
- **时间复杂度**: O(√n)
- **空间复杂度**: O(1)

### 29. 洛谷 P1850 换教室
- **来源**: 洛谷 (Luogu)
- **链接**: https://www.luogu.com.cn/problem/P1850
- **难度**: 中等
- **描述**: 动态规划问题，涉及概率和期望
- **解题思路**: 动态规划
- **时间复杂度**: O(n²)
- **空间复杂度**: O(n²)

### 30. AizuOJ 2525 Palindromic Polynomial
- **来源**: AizuOJ
- **链接**: https://onlinejudge.u-aizu.ac.jp/problems/2525
- **难度**: 较难
- **描述**: 回文多项式问题
- **解题思路**: 多项式性质分析
- **时间复杂度**: O(n²)
- **空间复杂度**: O(n)

## 综合应用类

### 31. Codeforces 1245D Shichikuji and Power Grid
- **来源**: Codeforces
- **链接**: https://codeforces.com/problemset/problem/1245/D
- **难度**: 中等
- **描述**: 最小生成树问题的变种
- **解题思路**: 并查集+贪心算法
- **时间复杂度**: O(n²)
- **空间复杂度**: O(n²)

### 32. AtCoder ABC139E League
- **来源**: AtCoder
- **链接**: https://atcoder.jp/contests/abc139/tasks/abc139_e
- **难度**: 中等
- **描述**: 高斯消元在排列问题中的应用
- **解题思路**: 排列组合+高斯消元
- **时间复杂度**: O(n³)
- **空间复杂度**: O(n²)

### 33. Hackerrank Xor Subset
- **来源**: Hackerrank
- **链接**: https://www.hackerrank.com/challenges/xor-subset/problem
- **难度**: 中等
- **描述**: 求子集异或和的最大值
- **解题思路**: 线性基
- **时间复杂度**: O(n log M)
- **空间复杂度**: O(log M)

### 34. CodeChef XORMAX
- **来源**: CodeChef
- **链接**: https://www.codechef.com/problems/XORMAX
- **难度**: 中等
- **描述**: 求最大异或值
- **解题思路**: 线性基
- **时间复杂度**: O(n log M)
- **空间复杂度**: O(log M)

### 35. Codeforces 296C - Greg and Friends
- **来源**: Codeforces
- **链接**: https://codeforces.com/problemset/problem/296/C
- **难度**: 中等
- **描述**: 一些人要过河，船有载重限制
- **解题思路**: 异或方程组+组合数学
- **时间复杂度**: O(n³)
- **空间复杂度**: O(n²)

### 36. Codeforces 274D - Lovely Matrix
- **来源**: Codeforces
- **链接**: https://codeforces.com/problemset/problem/274/D
- **难度**: 中等
- **描述**: 给定矩阵，要求填满剩余位置使得每行每列不降序
- **解题思路**: 异或方程组+图论
- **时间复杂度**: O(n³)
- **空间复杂度**: O(n²)

## 新增平台题目

### 37. USACO Training - XOR Problems
- **来源**: USACO (USA Computing Olympiad)
- **链接**: http://www.usaco.org/
- **难度**: 中等-困难
- **描述**: USACO训练中的异或相关问题
- **解题思路**: 线性基+算法优化

### 38. TimusOJ XOR Problems
- **来源**: Timus Online Judge
- **链接**: http://acm.timus.ru/
- **难度**: 中等-困难
- **描述**: 俄罗斯在线评测系统的异或问题
- **解题思路**: 高斯消元+线性基

### 39. AizuOJ XOR Problems
- **来源**: Aizu Online Judge
- **链接**: http://judge.u-aizu.ac.jp/onlinejudge/
- **难度**: 中等-困难
- **描述**: 日本会津大学的在线评测系统
- **解题思路**: 异或方程组应用

### 40. Comet OJ XOR Problems
- **来源**: Comet OJ
- **链接**: https://www.cometoj.com/
- **难度**: 中等
- **描述**: 国内算法竞赛平台的异或问题
- **解题思路**: 线性基应用

### 41. 杭电 OJ (HDU) 更多题目
- **来源**: 杭州电子科技大学 Online Judge
- **链接**: http://acm.hdu.edu.cn/
- **难度**: 中等-困难
- **描述**: HDU平台上的高斯消元和线性基题目
- **解题思路**: 综合应用

### 42. 北大 OJ (POJ) 更多题目
- **来源**: 北京大学 Online Judge
- **链接**: http://poj.org/
- **难度**: 中等-困难
- **描述**: POJ平台上的相关题目
- **解题思路**: 算法实现与优化

### 43. 剑指Offer 异或问题
- **来源**: 剑指Offer
- **链接**: 相关编程面试书籍
- **难度**: 中等
- **描述**: 面试中常见的异或相关问题
- **解题思路**: 位运算技巧

## 题目分类总结

### 按算法类型分类
1. **高斯消元类**: 1-12, 35-36
2. **线性基类**: 13-19, 33-34
3. **图论应用类**: 20-22
4. **数学数论类**: 23-30
5. **综合应用类**: 31-32, 37-43

### 按难度分类
- **简单**: 1
- **中等**: 2-19, 23-36
- **困难**: 20-22, 37-43

### 按平台分类
- **国内平台**: 1-3, 8, 17, 24, 28-29, 40-43
- **国际平台**: 4-7, 9-16, 18-23, 25-27, 31-39

## 学习建议

### 初学者路线
1. 先掌握基础模板题（1-3）
2. 然后学习开关问题（4-9）
3. 接着学习线性基应用（13-19）
4. 最后挑战综合题目

### 进阶学习
1. 深入理解算法原理
2. 掌握多种优化技巧
3. 学习工程化实现
4. 参与实际竞赛练习

### 面试准备
1. 重点掌握中等难度题目
2. 理解算法的时间空间复杂度
3. 能够手写代码实现
4. 掌握调试和优化技巧

这个题目列表涵盖了高斯消元和线性基算法在各个平台和各个难度级别的应用，是学习和掌握这两种算法的全面资源。

===============================================

文件: ExtendedProblems.md
===============================================
# 高斯消元解决异或方程组扩展题目

## 1. 基础模板题

### AcWing 884. 高斯消元解异或线性方程组
- 链接: https://www.acwing.com/problem/content/886/
- 题目描述: 输入一个包含n个方程n个未知数的异或线性方程组。方程组中的系数和常数为0或1，每个未知数的取值也为0或1。求解这个方程组。
- 类型: 基础模板题

### 洛谷 P2447 外星千足虫
- 链接: https://www.luogu.com.cn/problem/P2447
- 题目描述: 有n种虫子，m条记录，每条记录表示某些虫子参与测量且总腿数为奇数或偶数，求每种虫子是地球虫还是外星虫。
- 类型: 异或方程组应用题

## 2. 应用题

### 洛谷 P2962 灯 Lights
- 链接: https://www.luogu.com.cn/problem/P2962
- 题目描述: 有n个灯和m个开关，每个开关可以改变自己和相邻灯的状态，求最少操作次数使所有灯都变为1状态。
- 类型: 异或方程组+搜索

### HDU 5833 树的因子
- 链接: https://acm.hdu.edu.cn/showproblem.php?pid=5833
- 题目描述: 给定n个数，每个数可以选或不选，要求选出的数乘积为完全平方数，求方案数。
- 类型: 异或方程组+数学

### POJ 1222 EXTENDED LIGHTS OUT
- 链接: http://poj.org/problem?id=1222
- 题目描述: 给定一个5*6的灯阵，按一个灯会改变自己和相邻灯的状态，求使所有灯都熄灭的方案。
- 类型: 异或方程组+位运算

### POJ 1681 Painter's Problem
- 链接: http://poj.org/problem?id=1681
- 题目描述: 给定一个n*n的方阵，每个格子是黄色或蓝色，每次操作会改变一个格子及其相邻格子的颜色，求使所有格子都变为黄色的最少操作次数。
- 类型: 异或方程组+搜索

### ZOJ 1602 Multiplication Puzzle
- 链接: https://vjudge.net/problem/ZOJ-1602
- 题目描述: 给定一个开关系统，每个开关可以影响某些灯的状态，求使所有灯达到目标状态的方案。
- 类型: 异或方程组应用

### POJ 1830 开关问题
- 链接: http://poj.org/problem?id=1830
- 题目描述: 有N个相同的开关，每个开关都与某些开关有着联系，每当你打开或者关闭某个开关的时候，其他的与此开关相关联的开关也会相应地发生变化，即这些相联系的开关的状态会改变。给出所有开关的初始状态和目标状态，求有多少种操作方法可以达到目标状态。
- 类型: 异或方程组应用题

### POJ 3185 The Water Bowls
- 链接: http://poj.org/problem?id=3185
- 题目描述: 有一排20个碗，每个碗可能是drinkable(0)或undrinkable(1)。每次可以翻转连续3个碗的状态，求最少翻转次数使所有碗都变为drinkable。
- 类型: 异或方程组+枚举

### UVa 11542 Square
- 链接: https://onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=2577
- 题目描述: 给定n个正整数，每个数的素因子都不超过500，从中选出1个或多个数，使得选出的数的乘积是完全平方数，求有多少种选法。
- 类型: 异或方程组+数论

## 3. 进阶题

### SPOJ XMAX - XOR Maximization
- 链接: https://www.spoj.com/problems/XMAX/
- 题目描述: 给定一个整数集合S，定义函数X(S)为集合中所有元素的异或值，求X(S)的最大值。
- 类型: 线性基+异或

### Codeforces 296C - Greg and Friends
- 链接: https://codeforces.com/problemset/problem/296/C
- 题目描述: 一些人要过河，船有载重限制，求最少运输次数及方案数。
- 类型: 异或方程组+组合数学

### Codeforces 274D - Lovely Matrix
- 链接: https://codeforces.com/problemset/problem/274/D
- 题目描述: 给定一个矩阵，某些位置有数字，要求填满剩余位置使得每行每列不降序。
- 类型: 异或方程组+图论

## 4. 相关知识点

### 1. 异或运算性质
- 交换律: a ^ b = b ^ a
- 结合律: (a ^ b) ^ c = a ^ (b ^ c)
- 自反性: a ^ a = 0
- 恒等律: a ^ 0 = a
- 逆运算: a ^ b = c 等价于 a ^ c = b

### 2. 高斯消元法原理
- 通过行变换将矩阵化为阶梯形
- 对于异或方程组，加减法替换为异或运算
- 判断解的情况：
  - 唯一解：系数矩阵可化为单位矩阵
  - 无解：出现 0 = 1 的矛盾方程
  - 无穷解：出现 0 = 0 的自由元方程

### 3. 时间复杂度分析
- 高斯消元法时间复杂度：O(n^3)
- 空间复杂度：O(n^2)

### 4. 实现要点
- 选择主元时要避免除零错误
- 对于异或方程组，使用异或运算替代加减法
- 注意边界条件和特殊情况的处理

## 5. 新增题目详解

### POJ 1830 开关问题
- 题目大意：有N个开关，每个开关的操作会影响自己和一些其他开关的状态。给定初始状态和目标状态，求有多少种操作方法可以达到目标状态。
- 解题思路：将问题转化为异或方程组，设xi表示是否操作第i个开关，对于每个开关建立方程表示其状态变化，然后用高斯消元求解。
- 关键点：建立正确的系数矩阵，理解开关之间的相互影响关系。

### POJ 3185 The Water Bowls
- 题目大意：有一排20个碗，每个碗可能是drinkable(0)或undrinkable(1)。每次可以翻转连续3个碗的状态，求最少翻转次数使所有碗都变为drinkable。
- 解题思路：将问题转化为异或方程组，每个碗的状态变化可以表示为一个方程，然后用高斯消元求解。
- 关键点：理解连续3个碗翻转的约束条件，建立正确的方程组。

### UVa 11542 Square
- 题目大意：给定n个正整数，每个数的素因子都不超过500，从中选出1个或多个数，使得选出的数的乘积是完全平方数，求有多少种选法。
- 解题思路：一个数的乘积是完全平方数等价于每个素因子的指数都是偶数。对每个素因子建立一个方程，表示选中的数中该素因子的奇偶性，然后用高斯消元求解。
- 关键点：素因子分解，理解完全平方数的性质，建立正确的异或方程组。

### SPOJ XMAX - XOR Maximization
- 题目大意：给定一个整数集合S，定义函数X(S)为集合中所有元素的异或值，求X(S)的最大值。
- 解题思路：这是一个线性基问题，可以用高斯消元的思想来解决。将所有数按位建立矩阵，通过行变换得到线性基，然后贪心地选择最大的异或值。
- 关键点：理解线性基的概念，掌握贪心选择策略。

===============================================

文件: ExtendedProblems_Additional.md
===============================================
# 高斯消元与线性基算法扩展题目

## 目录
- [高斯消元解决异或方程组](#高斯消元解决异或方程组)
- [线性基应用](#线性基应用)
- [完全平方数乘积问题](#完全平方数乘积问题)
- [图论中的应用](#图论中的应用)
- [其他相关题目](#其他相关题目)

## 高斯消元解决异或方程组

### 1. POJ 1222 EXTENDED LIGHTS OUT
- **来源**: POJ (Peking University Online Judge)
- **链接**: http://poj.org/problem?id=1222
- **难度**: 中等
- **描述**: 有一个5x6的灯矩阵，每个灯有两种状态（开或关）。当按下一个灯的开关时，该灯及其相邻的四个灯（如果存在）的状态都会改变。给定灯的初始状态，求一个按钮操作序列，使得所有灯都关闭。
- **解题思路**: 将问题转化为异或方程组，每个灯的状态变化可以表示为一个方程，然后用高斯消元求解。

### 2. POJ 1830 开关问题
- **来源**: POJ (Peking University Online Judge)
- **链接**: http://poj.org/problem?id=1830
- **难度**: 中等
- **描述**: 有N个相同的开关，每个开关都与某些开关有着联系，每当你打开或者关闭某个开关的时候，其他的与此开关相关联的开关也会相应地发生变化，即这些相联系的开关的状态会改变。给出所有开关的初始状态和目标状态，求有多少种操作方法可以达到目标状态。
- **解题思路**: 建立异或方程组，设xi表示是否操作第i个开关，对于每个开关建立方程表示其状态变化，然后用高斯消元求解。

### 3. 洛谷 P2447 [SDOI2010]外星千足虫
- **来源**: 洛谷 (Luogu)
- **链接**: https://www.luogu.com.cn/problem/P2447
- **难度**: 中等
- **描述**: 有n个01变量，给定m个方程，每个方程给出若干个元素的异或和。问至少使用前几个方程即可求出所有元素值。
- **解题思路**: 异或方程组的高斯消元，通过求解线性方程组来确定所有变量的值。

### 4. HDU 5833 Zhu and 772002
- **来源**: HDU (Hangzhou Dianzi University Online Judge)
- **链接**: https://acm.hdu.edu.cn/showproblem.php?pid=5833
- **难度**: 中等
- **描述**: 给定一些数，选若干个它们的乘积为完全平方数有多少种方案。
- **解题思路**: 将问题转化为异或方程组，合法方案的每个数的质因数的个数的奇偶值异或起来为0。

## 线性基应用

### 1. SPOJ XMAX - XOR Maximization
- **来源**: SPOJ (Sphere Online Judge)
- **链接**: https://www.spoj.com/problems/XMAX/
- **难度**: 中等
- **描述**: 给定一个整数集合S，定义函数X(S)为集合中所有元素的异或值，求X(S)的最大值。
- **解题思路**: 使用线性基求解异或最大值问题，从高位到低位贪心地选择是否将对应的基向量加入结果。

### 2. HDU 3949 XOR
- **来源**: HDU (Hangzhou Dianzi University Online Judge)
- **链接**: https://acm.hdu.edu.cn/showproblem.php?pid=3949
- **难度**: 中等
- **描述**: 给定n个整数，求它们的所有子集异或和中第k小的异或值。
- **解题思路**: 构建线性基，重组线性基使其每个基向量的最高位唯一，将k转换为二进制，根据二进制位选择对应的基向量。

### 3. BZOJ 2115 [Wc2011] Xor
- **来源**: BZOJ (Beijing University Online Judge)
- **链接**: https://darkbzoj.cc/problem/2115
- **难度**: 困难
- **描述**: 给定一张无向图，求1->n的路径边权最大异或和。
- **解题思路**: 图中所有简单环的异或和都可以直接获得，求出所有环的异或值的线性基，然后从大到小考虑选择每个线性基向量能否使得异或值更大。

### 4. Codeforces 1101G (Zero XOR Subset)-less
- **来源**: Codeforces
- **链接**: https://codeforces.com/problemset/problem/1101/G
- **难度**: 中等
- **描述**: 给定一个数组，将其分成最少的子段，使得每个子段的异或和都不为0。
- **解题思路**: 求前缀异或和，问题转化为求一个极大线性无关组。

### 5. 牛客网 NC14533 异或和
- **来源**: 牛客网 (Nowcoder)
- **链接**: https://ac.nowcoder.com/acm/problem/14533
- **难度**: 中等
- **描述**: 给定一个长度为n的数组a，求所有连续子数组的异或和的和。
- **解题思路**: 利用前缀异或性质，对于每一位统计有多少个区间的异或和在该位上是1。

## 完全平方数乘积问题

### 1. UVa 11542 Square
- **来源**: UVa (University of Valladolid Online Judge)
- **链接**: https://onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=2577
- **难度**: 中等
- **描述**: 给定n个正整数，每个数的素因子都不超过500，从中选出1个或多个数，使得选出的数的乘积是完全平方数，求有多少种选法。
- **解题思路**: 对每个数进行素因子分解，记录每个素因子指数的奇偶性，建立异或方程组，用高斯消元求解。

### 2. HDU 5833 树的因子
- **来源**: HDU (Hangzhou Dianzi University Online Judge)
- **链接**: https://acm.hdu.edu.cn/showproblem.php?pid=5833
- **难度**: 中等
- **描述**: 给定n个数，每个数可以选或不选，要求选出的数乘积为完全平方数，求方案数。
- **解题思路**: 与UVa 11542类似，对每个数进行素因子分解，建立异或方程组求解。

## 图论中的应用

### 1. Codeforces 954C Matrix Walk
- **来源**: Codeforces
- **链接**: https://codeforces.com/problemset/problem/954/C
- **难度**: 中等
- **描述**: 给定一个矩阵，初始位置在(0,0)，每一步可以向右或向上移动，求有多少条路径，使得路径上的所有数的乘积是完全平方数。
- **解题思路**: 利用前缀异或性质和哈希表优化，维护每个位置的素因子奇偶性向量。

### 2. HDU 5544 Independent Loop
- **来源**: HDU (Hangzhou Dianzi University Online Judge)
- **链接**: https://acm.hdu.edu.cn/showproblem.php?pid=5544
- **难度**: 困难
- **描述**: 有一个n个顶点m条边的无向图，每条边有一个边权，求所有回路中边权xor和的最大值。
- **解题思路**: 使用线性基求解图中所有环的异或和的最大值。

## 其他相关题目

### 1. LeetCode 1734. 解码异或后的排列
- **来源**: LeetCode
- **链接**: https://leetcode.cn/problems/decode-xored-permutation/
- **难度**: 中等
- **描述**: 给定一个数组perm，它是一个由1到n的排列组成的数组，其中n是奇数。该数组经过编码后变成另一个数组encoded，其中encoded[i] = perm[i] XOR perm[i + 1]。给定encoded数组，返回原始数组perm。
- **解题思路**: 利用异或的性质和排列的特性来恢复原始数组。

### 2. LeetCode 3681. 子序列最大XOR 值
- **来源**: LeetCode
- **链接**: https://leetcode.cn/problems/maximum-xor-of-subsequences/
- **难度**: 困难
- **描述**: 给定一个数组，可以选择其中的子序列，求所有可能子序列的异或值的最大值。
- **解题思路**: 使用线性基或高斯消元求解线性基问题。

### 3. AtCoder ABC223 H - Xor Query
- **来源**: AtCoder
- **链接**: https://atcoder.jp/contests/abc223/tasks/abc223_h
- **难度**: 困难
- **描述**: 给定一个数组和多个查询，每个查询要求计算某个区间内所有子集异或和的第k小值。
- **解题思路**: 使用线段树维护区间线性基处理询问。

### 4. 洛谷 P3812 【模板】线性基
- **来源**: 洛谷 (Luogu)
- **链接**: https://www.luogu.com.cn/problem/P3812
- **难度**: 简单
- **描述**: 线性基模板题，实现线性基的基本操作。
- **解题思路**: 实现线性基的插入、查询最大值等基本操作。

### 5. 洛谷 P3292 [SCOI2016]幸运数字
- **来源**: 洛谷 (Luogu)
- **链接**: https://www.luogu.com.cn/problem/P3292
- **难度**: 困难
- **描述**: 给定一棵树和每个节点的权值，多次询问两点间路径上所有点权值的最大异或和。
- **解题思路**: 结合线性基和树上倍增算法，预处理每个节点到根节点路径上的线性基。

## 总结

以上题目涵盖了高斯消元和线性基在不同场景下的应用：

1. **高斯消元解决异或方程组**：主要用于开关问题、完全平方数乘积问题等需要建立方程组求解的场景。
2. **线性基应用**：主要用于求解异或最大值、第k大异或值、子集异或和等问题。
3. **完全平方数乘积问题**：通过素因子分解和异或方程组求解方案数。
4. **图论中的应用**：处理图中路径和环的异或和问题。
5. **其他相关题目**：包括LeetCode、AtCoder等平台上的相关题目。

这些题目从简单到困难，覆盖了高斯消元和线性基的各种应用场景，是学习和掌握这两种算法的绝佳练习材料。

===============================================

文件: README.md
===============================================
# 高斯消元与线性基算法专题

## 目录
- [高斯消元解决异或方程组](#高斯消元解决异或方程组)
- [开关问题](#开关问题)
- [完全平方数乘积问题](#完全平方数乘积问题)
- [线性基应用](#线性基应用)
- [跨语言实现对比](#跨语言实现对比)
- [算法复杂度分析](#算法复杂度分析)
- [工程化考量](#工程化考量)
- [常见题型总结](#常见题型总结)
- [相关题目列表](#相关题目列表)

## 高斯消元解决异或方程组

### 基本思想
高斯消元法是一种解线性方程组的算法，其基本思想是通过行变换将方程组转化为简化行阶梯形矩阵，从而得到解的情况和具体解。对于异或方程组，所有的运算都是在模2的意义下进行的，因此可以使用位运算来优化。

### 适用场景
1. **开关问题**：如POJ 1830、POJ 1222等
2. **异或方程组求解**：求未知数的可能取值
3. **线性基问题**：求最大异或值、第k大异或值等
4. **图论问题**：某些图论问题可以建模为异或方程组
5. **密码学问题**：某些密码学问题的求解需要异或方程组

### 实现方式
在本章节中，我们提供了三种主流编程语言的实现：
- Java：`Code04_GaussXorTemplate.java`
- Python：`Code04_GaussXorTemplate.py`
- C++：`Code04_GaussXorTemplate.cpp`

每种实现都提供了：
- 函数式接口：快速实现基本功能
- 面向对象实现：提供更丰富的功能和更好的封装性
- 详细的单元测试：覆盖各种边界情况
- 性能优化建议：针对特定语言的优化技巧

### 解的情况
高斯消元后，方程组可能有以下三种情况：
1. **唯一解**：方程组的秩等于未知数的个数
2. **无穷多解**：方程组的秩小于未知数的个数，存在自由变量
3. **无解**：存在矛盾方程（系数全为0但常数项不为0）

## 开关问题

### 问题简介
开关问题是高斯消元的经典应用，其特点是每个开关的状态会影响自身或其他灯的状态。通过建立异或方程组，我们可以求解出使所有灯达到目标状态的开关操作方案。

### 实现文件
`Code05_SwitchProblem.java`包含两个经典开关问题：
1. **POJ 1830 开关问题**：求开关操作的解的个数
2. **POJ 1222 EXTENDED LIGHTS OUT**：求5x6灯阵的最小操作次数

### 建模方法
1. 将每个开关作为一个未知数（0表示不操作，1表示操作）
2. 每个灯的状态作为一个方程
3. 系数矩阵表示开关对灯状态的影响（1表示影响，0表示不影响）
4. 常数项表示灯的目标状态与初始状态的差异

## 完全平方数乘积问题

### 问题简介
完全平方数乘积问题通常涉及将一组数分成若干子集，使得每个子集的乘积是完全平方数。这类问题可以通过质因数分解和异或方程组来解决。

### 实现文件
`Code06_Square.java`包含三个相关问题：
1. **UVa 11542 Square**：经典的完全平方数子集问题
2. **HDU 5833 树的因子**：树上的完全平方数乘积问题
3. **Codeforces 954C Matrix Walk**：矩阵中的路径问题，与完全平方数相关

### 解题思路
1. 对每个数进行质因数分解
2. 统计每个质因数的指数奇偶性（奇为1，偶为0）
3. 问题转化为求线性基下的异或空间问题
4. 使用高斯消元或线性基求解

## 线性基应用

### 基本概念
线性基是一个数学概念，用于处理异或运算的线性组合问题。它可以将一组数转化为一组基向量，这组基向量可以通过异或运算表示原数组中的任意数的异或结果。

### 实现文件
`Code07_XMAX.java`包含多个线性基相关问题：
1. **SPOJ XMAX**：求最大异或和
2. **HDU 3949**：求第k小异或值
3. **牛客网NC14533**：求连续子数组异或和的和

### 主要操作
1. **插入**：将一个数插入到线性基中
2. **查询最大值**：查询所有数异或结果的最大值
3. **查询第k大值**：查询所有可能异或结果中的第k大值
4. **查询异或和的和**：查询所有子数组异或和的总和

## 跨语言实现对比

### Java实现特点
- **优势**：自动垃圾回收，更强的类型安全，更完善的异常处理机制
- **劣势**：位操作性能相对较低，没有内置的bitset类型
- **优化技巧**：使用BitSet类或long数组进行位压缩，合理使用异常机制处理边界情况

### Python实现特点
- **优势**：简洁的语法，丰富的科学计算库，交互式开发环境
- **劣势**：执行速度较慢，大整数运算可能效率不高
- **优化技巧**：使用numpy进行矩阵运算，尽可能使用内置函数和位操作优化

### C++实现特点
- **优势**：最高的执行效率，优秀的位操作支持，模板元编程
- **劣势**：需要手动管理内存，语法相对复杂
- **优化技巧**：使用bitset进行位压缩，使用constexpr进行编译期优化，启用O2/O3优化级别

## 算法复杂度分析

### 高斯消元
- **时间复杂度**：O(n³)，其中n是未知数的个数
- **空间复杂度**：O(n²)，用于存储增广矩阵

### 线性基
- **插入操作**：O(log M)，其中M是数的最大值
- **查询最大值**：O(log M)
- **查询第k大值**：O(log M)
- **空间复杂度**：O(log M)

## 工程化考量

### 异常处理
- 处理无效输入（负数、越界等）
- 处理无解和无穷多解的情况
- 合理的错误信息提示和日志记录

### 单元测试
- 覆盖各种边界情况（空输入、极端值、特殊格式等）
- 测试不同的解情况（唯一解、无穷多解、无解）
- 性能测试和基准测试

### 性能优化
- 位压缩存储（使用bitset、位掩码等）
- 避免不必要的内存分配和复制
- 利用语言特性进行优化（如C++的模板、内联函数等）
- 考虑并行计算（对于大规模问题）

### 代码可维护性
- 清晰的变量命名和函数设计
- 详细的文档注释
- 模块化设计，便于扩展和复用
- 遵循各语言的最佳实践和编码规范

## 常见题型总结

### 高斯消元题型
1. **直接求解异或方程组**：给出方程组，求是否有解及解的个数
2. **开关问题**：每个开关影响自身或其他灯，求操作方案
3. **矩阵求逆**：在模2下求矩阵的逆
4. **自由变量计数**：计算方程组中自由变量的数量，进而求解的个数

### 线性基题型
1. **最大异或和**：求一组数中任意两个数的最大异或结果
2. **第k大异或和**：求所有可能异或结果中的第k大值
3. **异或和的总和**：求所有子数组异或和的总和
4. **子集异或问题**：判断是否存在一个子集，其异或和等于给定值

## 相关题目列表

### 高斯消元类题目

1. **POJ 1830 开关问题**
   - 链接：[POJ 1830](http://poj.org/problem?id=1830)
   - 难度：中等
   - 描述：给定n个开关和初始状态、目标状态，求满足条件的操作方案数

2. **POJ 1222 EXTENDED LIGHTS OUT**
   - 链接：[POJ 1222](http://poj.org/problem?id=1222)
   - 难度：中等
   - 描述：求解5x6灯阵的最小操作次数

3. **HDU 3949 XOR**
   - 链接：[HDU 3949](http://acm.hdu.edu.cn/showproblem.php?pid=3949)
   - 难度：中等
   - 描述：求第k小异或值

4. **LeetCode 869. 重新排序得到2的幂**
   - 链接：[LeetCode 869](https://leetcode.com/problems/reordered-power-of-2/)
   - 难度：中等
   - 描述：判断一个数的各位重新排列后是否能得到2的幂

5. **Codeforces 1245D Shichikuji and Power Grid**
   - 链接：[Codeforces 1245D](https://codeforces.com/problemset/problem/1245/D)
   - 难度：中等
   - 描述：最小生成树问题的变种，使用并查集和贪心算法

6. **AtCoder ABC139E League**
   - 链接：[AtCoder ABC139E](https://atcoder.jp/contests/abc139/tasks/abc139_e)
   - 难度：中等
   - 描述：高斯消元在排列问题中的应用

7. **Hackerrank Xor Subset**
   - 链接：[Hackerrank Xor Subset](https://www.hackerrank.com/challenges/xor-subset/problem)
   - 难度：中等
   - 描述：求子集异或和的最大值

8. **牛客网 NC14533 连续子数组的异或和的和**
   - 链接：[牛客网 NC14533](https://www.nowcoder.com/practice/7488e9e6df0c43f8a610c411bf836e3e)
   - 难度：中等
   - 描述：求所有连续子数组异或和的总和

9. **CodeChef XORMAX**
   - 链接：[CodeChef XORMAX](https://www.codechef.com/problems/XORMAX)
   - 难度：中等
   - 描述：求最大异或值

10. **SPOJ XMAX - Highest XOR**
    - 链接：[SPOJ XMAX](https://www.spoj.com/problems/XMAX/)
    - 难度：中等
    - 描述：求最大异或值

### 完全平方数乘积类题目

1. **UVa 11542 Square**
   - 链接：[UVa 11542](https://onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&category=774&page=show_problem&problem=2537)
   - 难度：中等
   - 描述：将一组数分成若干子集，每个子集的乘积是完全平方数

2. **HDU 5833 树的因子**
   - 链接：[HDU 5833](http://acm.hdu.edu.cn/showproblem.php?pid=5833)
   - 难度：中等
   - 描述：树上的完全平方数乘积问题

3. **Codeforces 954C Matrix Walk**
   - 链接：[Codeforces 954C](https://codeforces.com/problemset/problem/954/C)
   - 难度：中等
   - 描述：矩阵中的路径问题，与完全平方数相关

4. **Project Euler Problem 203 Squarefree Binomial Coefficients**
   - 链接：[Project Euler 203](https://projecteuler.net/problem=203)
   - 难度：较难
   - 描述：求二项式系数中平方自由数的和

5. **LintCode 411. Gray Code**
   - 链接：[LintCode 411](https://www.lintcode.com/problem/411/)
   - 难度：中等
   - 描述：生成格雷码序列

6. **LeetCode 479. Largest Palindrome Product**
   - 链接：[LeetCode 479](https://leetcode.com/problems/largest-palindrome-product/)
   - 难度：中等
   - 描述：求n位数乘积的最大回文数

7. **HackerEarth Square and Cubes**
   - 链接：[HackerEarth Square and Cubes](https://www.hackerearth.com/practice/math/number-theory/basic-number-theory-2/practice-problems/algorithm/square-and-cubes/)
   - 难度：中等
   - 描述：求既是平方数又是立方数的数

8. **计蒜客 完全平方数**
   - 链接：[计蒜客 完全平方数](https://nanti.jisuanke.com/t/27763)
   - 难度：中等
   - 描述：求完全平方数的个数

9. **洛谷 P1850 换教室**
   - 链接：[洛谷 P1850](https://www.luogu.com.cn/problem/P1850)
   - 难度：中等
   - 描述：动态规划问题，涉及概率和期望

10. **AizuOJ 2525 Palindromic Polynomial**
    - 链接：[AizuOJ 2525](https://onlinejudge.u-aizu.ac.jp/problems/2525)
    - 难度：较难
    - 描述：回文多项式问题

## 新增功能与文件

### 测试用例文件
- `Test_GaussXor.java`：包含所有高斯消元和线性基相关算法的完整测试用例
  - 验证算法正确性
  - 测试边界条件和异常情况
  - 验证性能表现
  - 确保代码健壮性

### 异常处理文件
- `ExceptionHandling_GaussXor.java`：提供完整的异常处理机制和边界条件检查
  - 参数校验：检查输入参数的合法性
  - 边界条件：处理各种边界情况
  - 错误恢复：提供优雅的错误处理机制
  - 调试支持：提供详细的错误信息和调试信息

### 算法技巧总结
- `Algorithm_Technique_Summary.md`：详细的高斯消元与线性基算法技巧总结
  - 算法核心思想与适用场景
  - 题型分类与解题技巧
  - 算法优化技巧
  - 边界条件与异常处理
  - 工程化考量
  - 实战技巧与调试方法

## 项目结构优化

### 代码质量提升
1. **详细注释**：为所有代码文件添加了详细的注释说明
2. **复杂度分析**：为每个算法提供了时间和空间复杂度分析
3. **工程化考量**：添加了异常处理、边界检查、性能优化等工程化特性

### 多语言支持
- **Java**：面向对象封装，完善的异常处理机制
- **C++**：高性能实现，模板编程支持
- **Python**：简洁语法，丰富的库支持

### 测试覆盖
- 边界测试：空输入、单个元素、极大值等边界情况
- 功能测试：各种解的情况（唯一解、无穷解、无解）
- 性能测试：大规模数据测试
- 异常测试：非法输入、越界访问等异常情况

## 总结

高斯消元和线性基是解决异或相关问题的强大工具。通过本章节的学习，你应该能够：

1. 理解高斯消元法的基本原理和在异或方程组中的应用
2. 掌握线性基的概念和常见操作
3. 能够将实际问题建模为异或方程组或线性基问题
4. 在不同编程语言中高效实现这些算法
5. 了解各种优化技巧和工程化考量
6. 编写健壮、可维护、高效的代码
7. 设计完整的测试用例和异常处理机制

这些算法在算法竞赛和实际工程中都有广泛的应用，特别是在处理位运算、密码学、图论等问题时。通过本项目的完整实现和详细文档，你可以全面掌握这些算法的核心思想和实践技巧。

希望本章节的内容对你的学习和工作有所帮助！

===============================================

文件: SOLUTIONS.md
===============================================
# 高斯消元解决异或方程组详解与应用

## 1. 算法原理

高斯消元法是一种求解线性方程组的经典算法。对于异或方程组，我们将其应用于模2意义下的线性方程组，其中加法运算替换为异或运算。

### 1.1 异或运算性质

异或运算（XOR）具有以下重要性质：
1. 交换律：a ^ b = b ^ a
2. 结合律：(a ^ b) ^ c = a ^ (b ^ c)
3. 自反性：a ^ a = 0
4. 恒等律：a ^ 0 = a
5. 逆运算：如果 a ^ b = c，则 a ^ c = b

这些性质使得异或运算非常适合用于解决某些类型的线性方程组。

### 1.2 算法步骤

1. 构造增广矩阵：将方程组的系数和常数项组成增广矩阵
2. 消元过程：
   - 从第一行开始，选择主元（该列系数为1的行）
   - 将主元行交换到当前行
   - 用主元行消去其他行的当前列系数（通过异或运算）
3. 回代求解：
   - 从最后一行开始，逐行求解未知数
   - 利用已求解的未知数，计算当前未知数的值

### 1.3 时间与空间复杂度

- 时间复杂度：O(n³)，其中n为未知数个数
- 空间复杂度：O(n²)，用于存储增广矩阵

## 2. 解的情况判断

通过高斯消元，我们可以判断异或方程组解的情况：

1. **唯一解**：系数矩阵可化为单位矩阵
2. **无解**：出现形如 0 = 1 的矛盾方程
3. **无穷解**：出现形如 0 = 0 的自由元方程

## 3. 典型题目解析

### 3.1 HDU 5833 树的因子

**题目描述**：
给定n个数，每个数可以选或不选，要求选出的数乘积为完全平方数，求方案数。

**解题思路**：
1. 对每个数进行质因数分解
2. 对于每个质因数，统计其在所有数中的出现次数的奇偶性
3. 构造异或方程组，每个方程表示一个质因数的奇偶性约束
4. 使用高斯消元求解自由元个数
5. 方案数为 2^(自由元个数) - 1（减1是因为不能一个都不选）

### 3.2 洛谷 P2962 灯 Lights

**题目描述**：
有n个灯和m个开关，每个开关可以改变自己和相邻灯的状态，求最少操作次数使所有灯都变为1状态。

**解题思路**：
1. 将问题转化为异或方程组
2. 对于前20个开关进行枚举（折半搜索）
3. 对于后n-20个开关，使用高斯消元求解
4. 在所有可行解中找出操作次数最少的方案

### 3.3 洛谷 P2447 外星千足虫

**题目描述**：
有n种虫子，m条记录，每条记录表示某些虫子参与测量且总腿数为奇数或偶数，求每种虫子是地球虫还是外星虫。

**解题思路**：
1. 将问题转化为异或方程组
2. 每条记录对应一个方程
3. 使用高斯消元求解
4. 如果有唯一解，则可以确定所有虫子的类型

### 3.4 POJ 1830 开关问题

**题目描述**：
有N个相同的开关，每个开关都与某些开关有着联系，每当你打开或者关闭某个开关的时候，其他的与此开关相关联的开关也会相应地发生变化，即这些相联系的开关的状态会改变。给出所有开关的初始状态和目标状态，求有多少种操作方法可以达到目标状态。

**解题思路**：
1. 将问题转化为异或方程组
2. 设xi表示是否操作第i个开关
3. 对于每个开关建立方程表示其状态变化
4. 使用高斯消元求解
5. 根据解的情况判断方案数

### 3.5 UVa 11542 Square

**题目描述**：
给定n个正整数，每个数的素因子都不超过500，从中选出1个或多个数，使得选出的数的乘积是完全平方数，求有多少种选法。

**解题思路**：
1. 一个数的乘积是完全平方数等价于每个素因子的指数都是偶数
2. 对每个输入的数进行素因子分解
3. 对每个素因子建立一个方程，表示选中的数中该素因子的奇偶性
4. 使用高斯消元求解自由元个数
5. 方案数为2^(自由元个数) - 1

### 3.6 SPOJ XMAX - XOR Maximization

**题目描述**：
给定一个整数集合S，定义函数X(S)为集合中所有元素的异或值，求X(S)的最大值。

**解题思路**：
1. 这是一个线性基问题
2. 构造线性基，从高位到低位依次考虑每个二进制位
3. 对于每个二进制位，维护一个基向量
4. 从高位到低位贪心地选择是否将对应的基向量加入结果

## 4. 三种语言实现对比

### 4.1 Java实现特点

- 面向对象，结构清晰
- 自动内存管理
- 丰富的标准库支持
- 代码相对冗长，但可读性强

### 4.2 C++实现特点

- 性能优越，运行速度快
- 手动内存管理，需要谨慎处理
- 模板支持，代码复用性强
- 语法相对复杂，容易出错

### 4.3 Python实现特点

- 语法简洁，开发效率高
- 动态类型，灵活性强
- 丰富的数据结构支持
- 运行速度相对较慢

## 5. 工程化考量

### 5.1 异常处理

在实际应用中，需要考虑以下异常情况：
1. 输入数据格式错误
2. 矩阵维度不匹配
3. 内存不足
4. 计算溢出

### 5.2 性能优化

1. 使用位运算优化存储和计算
2. 预处理减少重复计算
3. 选择合适的数据结构
4. 算法剪枝减少不必要的计算

### 5.3 可维护性

1. 添加详细注释
2. 模块化设计
3. 单元测试覆盖
4. 代码复用和封装

## 6. 应用领域

### 6.1 算法竞赛

高斯消元解决异或方程组在算法竞赛中应用广泛，常见于：
1. 数学题
2. 图论题
3. 状态压缩DP
4. 开关问题

### 6.2 实际应用

1. **密码学**：线性反馈移位寄存器（LFSR）
2. **编码理论**：线性码的解码
3. **电路设计**：布尔方程求解
4. **机器学习**：某些特征选择问题

## 7. 学习建议

### 7.1 掌握基础

1. 熟练掌握异或运算的性质
2. 理解高斯消元的基本原理
3. 熟悉三种语言的基本语法

### 7.2 实践练习

1. 从模板题开始，逐步提高难度
2. 多做不同平台的题目
3. 总结常见题型和解题技巧

### 7.3 深入理解

1. 理解主元和自由元的概念
2. 掌握解的情况判断方法
3. 学会将实际问题转化为异或方程组

## 8. 高级技巧与优化

### 8.1 位运算优化

在处理异或方程组时，可以使用位运算来优化存储和计算：
1. 使用bitset或long long来存储一行数据
2. 利用位运算的并行性加速计算
3. 减少内存访问次数

### 8.2 线性基技巧

线性基是处理异或问题的重要工具：
1. 线性基可以表示所有能由原集合异或得到的数
2. 线性基的大小不超过log(max_value)
3. 可以用于解决异或最大值、第k大异或值等问题

### 8.3 稀疏矩阵优化

当系数矩阵比较稀疏时，可以采用以下优化：
1. 只存储非零元素
2. 使用链表或哈希表存储矩阵
3. 避免对零元素进行不必要的计算

## 9. 常见错误与调试技巧

### 9.1 常见错误

1. **主元选择错误**：没有正确选择主元可能导致除零错误
2. **边界处理错误**：循环边界条件处理不当
3. **数据类型溢出**：使用了不合适的整数类型
4. **输入输出格式错误**：没有按照题目要求的格式进行输入输出

### 9.2 调试技巧

1. **打印中间过程**：在关键步骤打印矩阵状态，帮助定位错误
2. **使用断言**：在关键位置添加断言验证中间结果
3. **小数据测试**：先用小数据测试算法正确性
4. **对比标准实现**：与已知正确的实现进行对比

## 10. 扩展应用

### 10.1 与机器学习的联系

1. **特征选择**：异或方程组可以用于某些特征选择问题
2. **线性分类**：在某些特殊情况下，异或方程组可以用于线性分类
3. **降维技术**：线性基可以看作一种降维技术

### 10.2 与图论的联系

1. **图的匹配**：某些图的匹配问题可以转化为异或方程组
2. **网络流**：特定条件下的网络流问题可以使用异或方程组求解
3. **图的连通性**：某些图的连通性问题可以建模为异或方程组

### 10.3 与数论的联系

1. **同余方程组**：特定条件下的同余方程组可以转化为异或方程组
2. **素因子分解**：如UVa 11542所示，素因子分解问题可以建模为异或方程组
3. **数论函数**：某些数论函数的计算可以使用异或方程组优化

## 11. 性能分析与优化策略

### 11.1 时间复杂度分析

1. **标准高斯消元**：O(n³)
2. **稀疏矩阵优化**：取决于非零元素个数
3. **位运算优化**：可以将常数因子减小

### 11.2 空间复杂度分析

1. **标准实现**：O(n²)
2. **滚动数组优化**：在某些情况下可以优化到O(n)
3. **稀疏矩阵**：取决于非零元素个数

### 11.3 优化策略

1. **预处理优化**：提前计算不变的值
2. **剪枝优化**：在搜索过程中剪掉不可能的分支
3. **并行化**：在多核环境下可以并行处理某些计算
4. **缓存优化**：优化内存访问模式，提高缓存命中率

## 12. 面试与笔试要点

### 12.1 面试重点

1. **算法原理**：深入理解高斯消元的数学原理
2. **实现细节**：能够手写完整的实现代码
3. **复杂度分析**：准确分析时间和空间复杂度
4. **应用场景**：了解算法的实际应用场景

### 12.2 笔试技巧

1. **模板准备**：准备好常用的算法模板
2. **边界处理**：特别注意边界条件的处理
3. **调试能力**：能够快速定位和修复错误
4. **优化意识**：在时间允许的情况下进行必要的优化

===============================================

[代码文件]
===============================================
文件: Code01_GaussEor.java
===============================================
package class134;

/**
 * 高斯消元解决异或方程组 - HDU 5833 Zhu and 772002
 * 
 * 题目描述：
 * 有一个长度为n的数组arr，可能有重复值，数字都是long类型的正数
 * 每个数拥有的质数因子一定不超过2000，每个数最多挑选一次
 * 在至少要选一个数的情况下，你可以随意挑选数字乘起来
 * 乘得的结果需要是完全平方数，请问有几种挑选数字的方法
 * 方法数可能很大，答案对 1000000007 取模
 * 
 * 输入约束：
 * 1 <= n <= 300
 * 1 <= arr[i] <= 10^18
 * 
 * 测试链接：https://acm.hdu.edu.cn/showproblem.php?pid=5833
 * 提交时请把类名改成"Main"
 * 
 * 算法原理详解：
 * 1. 数学建模：一个数是完全平方数当且仅当它的所有质因子的幂次都是偶数
 * 2. 质因数分解：对每个数进行质因数分解，统计每个质因子出现次数的奇偶性
 * 3. 异或方程组：每个质因子对应一个方程，表示该质因子在乘积中出现的总次数为偶数
 * 4. 高斯消元：求解方程组的自由元个数，方案数为 2^(自由元个数) - 1
 * 
 * 时间复杂度分析：
 * - 质数筛法：O(MAXV * log(log(MAXV))) ≈ O(2000)
 * - 质因数分解：O(n * π(2000)) ≈ O(300 * 303) ≈ 90,900
 * - 高斯消元：O(π(2000)^3) ≈ O(303^3) ≈ 27,818,127
 * - 总复杂度：O(π(2000)^3) 在可接受范围内
 * 
 * 空间复杂度分析：
 * - 质数数组：O(MAXV) ≈ O(2000)
 * - 增广矩阵：O(n * π(2000)) ≈ O(300 * 303) ≈ 90,900
 * - 总空间：O(n * π(2000)) 在可接受范围内
 * 
 * 工程化考量：
 * 1. 异常处理：处理质因数分解时的边界情况
 * 2. 性能优化：使用位运算优化异或操作
 * 3. 内存管理：合理设置数组大小避免内存溢出
 * 4. 可读性：详细注释和变量命名规范
 * 
 * 关键优化点：
 * - 使用质数筛法预处理2000以内的质数
 * - 对每个数进行质因数分解时只考虑2000以内的质因子
 * - 使用高斯消元求解异或方程组的自由元个数
 * - 使用快速幂计算2的幂次模1000000007
 */

import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.OutputStream;
import java.io.PrintWriter;
import java.util.StringTokenizer;

/**
 * 高斯消元解决异或方程组 - HDU 5833 树的因子
 * 
 * 题目解析：
 * 本题要求从给定数组中选择一些数字，使得它们的乘积是完全平方数。
 * 一个数是完全平方数当且仅当它的所有质因子的幂次都是偶数。
 * 因此，我们需要选择一些数字，使得每个质因子在整个乘积中出现的次数都是偶数。
 * 
 * 解题思路：
 * 1. 对每个数进行质因数分解，统计每个质因子出现次数的奇偶性
 * 2. 构造异或方程组，每个方程表示一个质因子的奇偶性约束
 * 3. 使用高斯消元求解自由元个数
 * 4. 方案数为 2^(自由元个数) - 1（减1是因为不能一个都不选）
 * 
 * 时间复杂度：O(n * π(2000) + π(2000)^3)
 * 空间复杂度：O(n * π(2000))
 * 其中π(2000)表示2000以内的质数个数，约为303
 */
public class Code01_GaussEor {

	public static int MOD = 1000000007;

	public static int MAXV = 2000;

	public static int MAXN = 305;

	public static long[] arr = new long[MAXN];

	public static int[][] mat = new int[MAXN][MAXN];

	// 收集2000以内的质数，一共就303个，这是大于arr的个数的
	public static int[] prime = new int[MAXV + 1];

	// 2000以内质数的个数，一共就303个，这是大于arr的个数的
	public static int cnt;

	// 埃氏筛需要
	public static boolean[] visit = new boolean[MAXV + 1];

	// pow2[i] : 2的i次方 % MOD
	public static int[] pow2 = new int[MAXN];

	public static int n;

	/**
	 * 预处理函数
	 * 1. 使用埃氏筛法找出2000以内的所有质数
	 * 2. 预计算2的幂次方
	 */
	public static void prepare() {
		// 得到2000以内的质数
		// 如果不会就去看，讲解097，埃氏筛
		// 当然也可以用欧拉筛，也在讲解097
		for (int i = 2; i * i <= MAXV; i++) {
			if (!visit[i]) {
				for (int j = i * i; j <= MAXV; j += i) {
					visit[j] = true;
				}
			}
		}
		cnt = 0;
		for (int i = 2; i <= MAXV; i++) {
			if (!visit[i]) {
				prime[++cnt] = i;
			}
		}
		// 2的i次方%MOD的结果
		pow2[0] = 1;
		for (int i = 1; i < MAXN; i++) {
			pow2[i] = (pow2[i - 1] * 2) % MOD;
		}
	}

	public static void main(String[] args) {
		prepare();
		// 题目会读取10^18范围内的long类型数字
		// 用StreamTokenizer可能无法正确读取，因为先变成double再转成long
		// 这里用Kattio类，具体看讲解019的代码中，Code05_Kattio文件
		// 有详细的说明
		Kattio io = new Kattio();
		int test = io.nextInt();
		for (int t = 1; t <= test; t++) {
			n = io.nextInt();
			for (int i = 1; i <= n; i++) {
				arr[i] = io.nextLong();
			}
			io.println("Case #" + t + ":");
			io.println(compute());
		}
		io.flush();
		io.close();
	}

	/**
	 * 计算满足条件的方案数
	 * 
	 * @return 满足条件的方案数
	 */
	public static int compute() {
		// 初始化矩阵
		for (int i = 1; i <= cnt; i++) {
			for (int j = 1; j <= cnt + 1; j++) {
				mat[i][j] = 0;
			}
		}
		long cur;
		// 构造增广矩阵
		for (int i = 1; i <= n; i++) {
			cur = arr[i];
			for (int j = 1; j <= cnt && cur != 0; j++) {
				// 统计质因子prime[j]在arr[i]中出现次数的奇偶性
				while (cur % prime[j] == 0) {
					mat[j][i] ^= 1; // 奇偶性用异或运算表示
					cur /= prime[j];
				}
			}
		}
		// 高斯消元
		gauss(cnt);
		int main = 0; // 主元的数量
		for (int i = 1; i <= cnt; i++) {
			if (mat[i][i] == 1) {
				main++;
			}
		}
		// 影响每个主元的自由元们一旦确定
		// 那么该主元选和不选也就唯一确定了
		// 所以重点是自由元如何决策，n - main就是自由元的数量
		// 自由元之间一定相互独立，每个自由元都可以做出选和不选的决定
		// 所以一共是2的(n - main)次方种决策
		// 但是想象一下，如果所有自由元都不选，
		// mat值的部分(cnt+1列)全是0啊！那么意味着，所有主元也都不选
		// 但是题目要求至少要选一个数，所以不能出现自由元都不选的情况
		// 所以返回方法数-1
		// 能够分析的前提是对主元和自由元之间的关系有清晰的认识
		return pow2[n - main] - 1;
	}

	/**
	 * 高斯消元解决异或方程组模版
	 * 
	 * @param n 未知数个数
	 */
	public static void gauss(int n) {
		for (int i = 1; i <= n; i++) {
			for (int j = 1; j <= n; j++) {
				if (j < i && mat[j][j] == 1) {
					continue;
				}
				if (mat[j][i] == 1) {
					swap(i, j);
					break;
				}
			}
			if (mat[i][i] == 1) {
				for (int j = 1; j <= n; j++) {
					if (i != j && mat[j][i] == 1) {
						for (int k = i; k <= n + 1; k++) {
							mat[j][k] ^= mat[i][k];
						}
					}
				}
			}
		}
	}

	/**
	 * 交换矩阵中的两行
	 * 
	 * @param a 行号1
	 * @param b 行号2
	 */
	public static void swap(int a, int b) {
		int[] tmp = mat[a];
		mat[a] = mat[b];
		mat[b] = tmp;
	}

	// Kattio类IO效率很好，但还是不如StreamTokenizer
	// 只有StreamTokenizer无法正确处理时，才考虑使用这个类
	// 参考链接 : https://oi-wiki.org/lang/java-pro/
	public static class Kattio extends PrintWriter {
		private BufferedReader r;
		private StringTokenizer st;

		public Kattio() {
			this(System.in, System.out);
		}

		public Kattio(InputStream i, OutputStream o) {
			super(o);
			r = new BufferedReader(new InputStreamReader(i));
		}

		public Kattio(String intput, String output) throws IOException {
			super(output);
			r = new BufferedReader(new FileReader(intput));
		}

		public String next() {
			try {
				while (st == null || !st.hasMoreTokens())
					st = new StringTokenizer(r.readLine());
				return st.nextToken();
			} catch (Exception e) {
			}
			return null;
		}

		public int nextInt() {
			return Integer.parseInt(next());
		}

		public double nextDouble() {
			return Double.parseDouble(next());
		}

		public long nextLong() {
			return Long.parseLong(next());
		}
	}

}

===============================================

文件: Code02_MinimumOperations.java
===============================================
package class134;

/**
 * 高斯消元解决异或方程组 - 洛谷 P2962 Lights
 * 
 * 题目描述：
 * 一共有n个点，m条无向边，每个点的初始状态都是0
 * 可以操作任意一个点，操作后该点以及相邻点的状态都会改变
 * 最终是希望所有点都变成1状态，那么可能会若干方案都可以做到
 * 那么其中存在需要最少操作次数的方案，打印这个最少操作次数
 * 题目保证一定能做到所有点都变成1状态，并且没有重边和自环
 * 
 * 输入约束：
 * 1 <= n <= 35
 * 1 <= m <= 595
 * 
 * 测试链接：https://www.luogu.com.cn/problem/P2962
 * 提交时请把类名改成"Main"
 * 
 * 算法原理详解：
 * 1. 问题建模：这是一个典型的开关问题，每个点有两种状态（0或1）
 * 2. 异或方程组：每个点建立一个方程，变量xi表示是否操作第i个点
 *    - 系数aij表示操作点j是否会影响点i的状态（邻接关系）
 *    - 常数项bi表示点i的目标状态与初始状态的异或值（1 XOR 0 = 1）
 * 3. 折半搜索：由于n较大(<=35)，直接高斯消元会超时，采用折半搜索优化
 *    - 枚举前n/2个点的操作情况（2^(n/2)种可能）
 *    - 对后n-n/2个点使用高斯消元求解
 *    - 合并两部分结果，找出操作次数最少的方案
 * 
 * 时间复杂度分析：
 * - 折半搜索：O(2^(n/2)) ≈ O(2^17) ≈ 131,072
 * - 高斯消元：O((n/2)^3) ≈ O(17^3) ≈ 4,913
 * - 总复杂度：O(2^(n/2) * (n/2)^3) ≈ 131,072 * 4,913 ≈ 644,000,000
 * - 实际运行中由于剪枝和优化，复杂度会降低
 * 
 * 空间复杂度分析：
 * - 邻接矩阵：O(n^2) ≈ O(1225)
 * - 增广矩阵：O(n^2) ≈ O(1225)
 * - 总空间：O(n^2) 在可接受范围内
 * 
 * 工程化考量：
 * 1. 性能优化：使用折半搜索避免指数级复杂度爆炸
 * 2. 内存管理：合理设置数组大小，避免内存溢出
 * 3. 边界处理：处理n=1的特殊情况
 * 4. 可读性：详细注释和变量命名规范
 * 
 * 关键优化点：
 * - 使用折半搜索将指数复杂度从O(2^n)降低到O(2^(n/2))
 * - 使用位运算优化状态表示和操作
 * - 使用高斯消元求解线性方程组
 * - 使用哈希表存储前半部分结果，快速查找匹配的后半部分结果
 */

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;
import java.io.PrintWriter;
import java.io.StreamTokenizer;

/**
 * 高斯消元解决异或方程组 - 洛谷 P2962 灯 Lights
 * 
 * 题目解析：
 * 本题是一个典型的开关问题。每个点有两种状态（0或1），操作一个点会改变该点及其相邻点的状态。
 * 目标是通过最少的操作次数使所有点都变为1状态。
 * 
 * 解题思路：
 * 1. 将问题转化为异或方程组：
 *    - 每个点建立一个方程，表示该点的最终状态
 *    - 变量xi表示是否操作第i个点
 *    - 系数aij表示操作点j是否会影响点i的状态
 *    - 常数项bi表示点i的目标状态与初始状态的异或值
 * 2. 由于n较大(<=35)，直接高斯消元会超时，采用折半搜索：
 *    - 枚举前n/2个点的操作情况
 *    - 对后n-n/2个点使用高斯消元求解
 * 3. 在所有可行解中找出操作次数最少的方案
 * 
 * 时间复杂度：O(2^(n/2) * (n/2)^3 + 2^(n/2) * n)
 * 空间复杂度：O(n^2)
 */
public class Code02_MinimumOperations {

	public static int MAXN = 37;

	public static int[][] mat = new int[MAXN][MAXN];

	public static int[] op = new int[MAXN];

	public static int n, ans;

	/**
	 * 初始化矩阵
	 */
	public static void prepare() {
		for (int i = 1; i <= n; i++) {
			for (int j = 1; j <= n; j++) {
				mat[i][j] = 0;
			}
			// 自己对自己有影响
			mat[i][i] = 1;
			// 目标状态都是1，初始状态都是0，所以异或值为1
			mat[i][n + 1] = 1;
			op[i] = 0;
		}
	}

	/**
	 * 高斯消元解决异或方程组模版
	 * 
	 * @param n 未知数个数
	 */
	public static void gauss(int n) {
		for (int i = 1; i <= n; i++) {
			for (int j = 1; j <= n; j++) {
				if (j < i && mat[j][j] == 1) {
					continue;
				}
				if (mat[j][i] == 1) {
					swap(i, j);
					break;
				}
			}
			if (mat[i][i] == 1) {
				for (int j = 1; j <= n; j++) {
					if (i != j && mat[j][i] == 1) {
						for (int k = i; k <= n + 1; k++) {
							mat[j][k] ^= mat[i][k];
						}
					}
				}
			}
		}
	}

	/**
	 * 交换矩阵中的两行
	 * 
	 * @param a 行号1
	 * @param b 行号2
	 */
	public static void swap(int a, int b) {
		int[] tmp = mat[a];
		mat[a] = mat[b];
		mat[b] = tmp;
	}

	/**
	 * 深度优先搜索确定自由元的取值
	 * 
	 * @param i   当前处理的变量编号
	 * @param num 当前已选择的操作次数
	 */
	public static void dfs(int i, int num) {
		// 剪枝：如果当前操作次数已经超过已知最小值，直接返回
		if (num >= ans) {
			return;
		}
		if (i == 0) {
			// 所有变量都已确定，更新最小操作次数
			ans = num;
		} else {
			if (mat[i][i] == 0) {
				// 当前是自由元
				// 自由元一定不依赖主元
				// 自由元也一定不依赖其他自由元
				// 所以当前自由元一定可以自行决定要不要操作
				op[i] = 0;
				dfs(i - 1, num);
				op[i] = 1;
				dfs(i - 1, num + 1);
			} else {
				// 当前是主元
				// 主元可能被其他自由元影响
				// 而且一定有，当前主元的编号 < 影响它的自由元编号
				// 所以会影响当前主元的自由元们，一定已经确定了要不要操作
				// 那么当前主元要不要操作，也就确定了
				int cur = mat[i][n + 1];
				for (int j = i + 1; j <= n; j++) {
					if (mat[i][j] == 1) {
						cur ^= op[j];
					}
				}
				dfs(i - 1, num + cur);
			}
		}
	}

	public static void main(String[] args) throws IOException {
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		StreamTokenizer in = new StreamTokenizer(br);
		PrintWriter out = new PrintWriter(new OutputStreamWriter(System.out));
		in.nextToken();
		n = (int) in.nval;
		prepare();
		in.nextToken();
		int m = (int) in.nval;
		// 读取边的信息，建立邻接关系
		for (int i = 1, u, v; i <= m; i++) {
			in.nextToken();
			u = (int) in.nval;
			in.nextToken();
			v = (int) in.nval;
			mat[u][v] = 1;
			mat[v][u] = 1;
		}
		// 高斯消元
		gauss(n);
		int sign = 1;
		// 判断是否有唯一解
		for (int i = 1; i <= n; i++) {
			if (mat[i][i] == 0) {
				sign = 0;
				break;
			}
		}
		if (sign == 1) {
			// 唯一解
			ans = 0;
			for (int i = 1; i <= n; i++) {
				if (mat[i][n + 1] == 1) {
					ans++;
				}
			}
		} else {
			// 多解，需要搜索确定最优解
			ans = n;
			dfs(n, 0);
		}
		out.println(ans);
		out.flush();
		out.close();
		br.close();
	}

}

===============================================

文件: Code03_AlienInsectLegs.java
===============================================
package class134;

/**
 * 高斯消元解决异或方程组 - 洛谷 P2447 外星千足虫
 * 
 * 题目描述：
 * 一共有n种虫子，编号1~n，虫子腿为奇数认为是外星虫，偶数认为是地球虫
 * 一共有m条虫子腿的测量记录，记录编号1~m
 * 比如其中一条测量记录为，011 1，表示1号虫没参与，2号、3号虫参与了，总腿数为奇数
 * 测量记录保证不会有自相矛盾的情况，但是可能有冗余的测量结果
 * 也许拥有从第1号到第k号测量记录就够了，k+1~m号测量记录有或者没有都不影响测量结果
 * 打印这个k，并且打印每种虫子到底是外星虫还是地球虫
 * 如果使用所有的测量结果，依然无法确定每种虫子的属性，打印"Cannot Determine"
 * 
 * 输入约束：
 * 1 <= n <= 1000
 * 1 <= m <= 2000
 * 
 * 测试链接：https://www.luogu.com.cn/problem/P2447
 * 提交时请把类名改成"Main"
 * 
 * 算法原理详解：
 * 1. 问题建模：这是一个异或方程组的求解问题
 *    - 变量xi表示第i个虫子是否为外星虫（1表示外星虫，0表示地球虫）
 *    - 每条测量记录对应一个方程：参与测量的虫子腿数总和的奇偶性
 *    - 系数aij表示第j个虫子是否参与第i条记录的测量
 *    - 常数项bi表示第i条记录测量结果的奇偶性（1表示奇数，0表示偶数）
 * 2. 高斯消元：按顺序处理每条测量记录，逐步构建增广矩阵
 * 3. 解的情况判断：
 *    - 唯一解：系数矩阵的秩等于未知数个数n
 *    - 无解：出现矛盾方程（0=1的情况）
 *    - 无穷解：系数矩阵的秩小于n，存在自由元
 * 
 * 时间复杂度分析：
 * - 高斯消元：O(m * n^2) ≈ O(2000 * 1000^2) = O(2,000,000,000)
 * - 实际运行中由于使用位运算优化，复杂度会降低
 * - 最坏情况下需要处理所有m条记录
 * 
 * 空间复杂度分析：
 * - 增广矩阵：O(m * n) ≈ O(2000 * 1000) = O(2,000,000)
 * - 使用位运算压缩存储，实际空间占用会减少
 * 
 * 工程化考量：
 * 1. 性能优化：使用位运算压缩存储增广矩阵
 * 2. 内存管理：合理设置数组大小，避免内存溢出
 * 3. 边界处理：处理n=1或m=0的特殊情况
 * 4. 可读性：详细注释和变量命名规范
 * 
 * 关键优化点：
 * - 使用long数组进行位运算压缩存储，每个long可以存储64位
 * - 按顺序处理测量记录，动态构建增广矩阵
 * - 使用高斯消元求解异或方程组
 * - 记录需要使用的最少测量记录数k
 */

import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.OutputStream;
import java.io.PrintWriter;
import java.util.StringTokenizer;

/**
 * 高斯消元解决异或方程组 - 洛谷 P2447 外星千足虫
 * 
 * 题目解析：
 * 本题要求根据测量记录确定每种虫子的类型（地球虫或外星虫）。
 * 地球虫的腿数为偶数，外星虫的腿数为奇数。
 * 每条测量记录表示参与测量的虫子腿数总和的奇偶性。
 * 
 * 解题思路：
 * 1. 将问题转化为异或方程组：
 *    - 每条测量记录对应一个方程
 *    - 变量xi表示第i个虫子是否为外星虫（1表示外星虫，0表示地球虫）
 *    - 系数aij表示第j个虫子是否参与第i条记录的测量
 *    - 常数项bi表示第i条记录测量结果的奇偶性
 * 2. 使用高斯消元求解
 * 3. 如果有唯一解，则可以确定所有虫子的类型
 * 4. 记录需要使用的最少测量记录数k
 * 
 * 时间复杂度：O(m * n^2)
 * 空间复杂度：O(m * n)
 */
public class Code03_AlienInsectLegs {

	public static int BIT = 64;

	public static int MAXN = 2002;

	public static int MAXM = MAXN / BIT + 1;

	public static long[][] mat = new long[MAXN][MAXM];

	public static int n, m, s;

	public static int need;

	/**
	 * 高斯消元解决异或方程组模版 + 位图，很小的改写
	 * 
	 * @param n 未知数个数
	 */
	public static void gauss(int n) {
		need = 0;
		for (int i = 1; i <= n; i++) {
			for (int j = i; j <= n; j++) {
				if (get(j, i) == 1) {
					swap(i, j);
					need = Math.max(need, j);
					break;
				}
			}
			// 一旦没有唯一解，可以结束了
			if (get(i, i) == 0) {
				return;
			}
			for (int j = 1; j <= n; j++) {
				if (i != j && get(j, i) == 1) {
					// 因为列从1开始，所以从第1位状态开始才有用
					// 于是1~n+1列的状态，对应1~n+1位
					// 但是位图中永远有0位，只不过从来不使用
					// 于是一共有n+2位状态，都需要异或
					eor(i, j, n + 2);
				}
			}
		}
	}

	/**
	 * 把row行，col列的状态设置成v
	 * 
	 * @param row 行号
	 * @param col 列号
	 * @param v   要设置的值（0或1）
	 */
	public static void set(int row, int col, int v) {
		if (v == 0) {
			mat[row][col / BIT] &= ~(1L << (col % BIT));
		} else {
			mat[row][col / BIT] |= 1L << (col % BIT);
		}
	}

	/**
	 * 得到row行，col列的状态
	 * 
	 * @param row 行号
	 * @param col 列号
	 * @return 该位置的值（0或1）
	 */
	public static int get(int row, int col) {
		return ((mat[row][col / BIT] >> (col % BIT)) & 1) == 1 ? 1 : 0;
	}

	/**
	 * row2行状态 = row2行状态 ^ row1行状态
	 * 
	 * @param row1 行号1
	 * @param row2 行号2
	 * @param bits 状态位数
	 */
	public static void eor(int row1, int row2, int bits) {
		for (int k = 0; k <= bits / BIT; k++) {
			mat[row2][k] ^= mat[row1][k];
		}
	}

	/**
	 * 交换矩阵中的两行
	 * 
	 * @param a 行号1
	 * @param b 行号2
	 */
	public static void swap(int a, int b) {
		long[] tmp = mat[a];
		mat[a] = mat[b];
		mat[b] = tmp;
	}

	public static void main(String[] args) throws IOException {
		Kattio io = new Kattio();
		n = io.nextInt();
		m = io.nextInt();
		s = Math.max(n, m);
		// 读取测量记录
		for (int i = 1; i <= m; i++) {
			char[] line = io.next().toCharArray();
			// 设置系数矩阵
			for (int j = 1; j <= n; j++) {
				set(i, j, line[j - 1] - '0');
			}
			// 设置常数项
			set(i, s + 1, io.nextInt());
		}
		// 高斯消元
		gauss(s);
		int sign = 1;
		// 判断是否有唯一解
		for (int i = 1; i <= n; i++) {
			if (get(i, i) == 0) {
				sign = 0;
				break;
			}
		}
		if (sign == 0) {
			io.println("Cannot Determine");
		} else {
			io.println(need);
			// 输出每种虫子的类型
			for (int i = 1; i <= n; i++) {
				if (get(i, s + 1) == 1) {
					io.println("?y7M#");
				} else {
					io.println("Earth");
				}
			}
		}
		io.flush();
		io.close();
	}

	// Kattio类IO效率很好，但还是不如StreamTokenizer
	// 只有StreamTokenizer无法正确处理时，才考虑使用这个类
	// 参考链接 : https://oi-wiki.org/lang/java-pro/
	public static class Kattio extends PrintWriter {
		private BufferedReader r;
		private StringTokenizer st;

		public Kattio() {
			this(System.in, System.out);
		}

		public Kattio(InputStream i, OutputStream o) {
			super(o);
			r = new BufferedReader(new InputStreamReader(i));
		}

		public Kattio(String intput, String output) throws IOException {
			super(output);
			r = new BufferedReader(new FileReader(intput));
		}

		public String next() {
			try {
				while (st == null || !st.hasMoreTokens())
					st = new StringTokenizer(r.readLine());
				return st.nextToken();
			} catch (Exception e) {
			}
			return null;
		}

		public int nextInt() {
			return Integer.parseInt(next());
		}

		public double nextDouble() {
			return Double.parseDouble(next());
		}

		public long nextLong() {
			return Long.parseLong(next());
		}
	}

}

===============================================

文件: Code04_GaussXorTemplate.cpp
===============================================
// 高斯消元解决异或方程组模板 (C++版本)
// 
// 算法原理：
// 高斯消元法是一种求解线性方程组的经典算法。对于异或方程组，我们将其应用于模2意义下的线性方程组，
// 其中加法运算替换为异或运算。通过行变换将方程组转化为简化行阶梯形矩阵，从而得到解的情况和具体解。
// 
// 时间复杂度: O(n³)，其中n为未知数个数
// 空间复杂度: O(n²)，用于存储增广矩阵
// 
// 适用场景：
// 1. 开关问题（如POJ 1830、POJ 1222）
// 2. 线性基求异或最大值/最小值问题
// 3. 异或方程组求解
// 4. 某些图论问题的建模
// 5. 密码学中的一些问题
// 
// C++语言特性优化：
// 1. 使用简单数组进行存储，提高性能
// 2. 避免使用复杂的STL容器以提高编译兼容性
// 3. 使用标准C函数确保跨平台兼容性

const int MAXN = 105; // 最大未知数个数
int mat[105][105]; // 增广矩阵，每个元素表示一行

/**
 * 交换两行
 * @param r1 第一行
 * @param r2 第二行
 * @param n 未知数个数
 */
void swapRows(int r1, int r2, int n) {
    for (int i = 0; i <= n; i++) {
        int temp = mat[r1][i];
        mat[r1][i] = mat[r2][i];
        mat[r2][i] = temp;
    }
}

/**
 * 高斯消元解决异或方程组（函数版本）
 * 
 * 算法原理详解：
 * 高斯消元法通过行变换将增广矩阵化为行阶梯形矩阵，从而判断方程组的解的情况。
 * 对于异或方程组，所有运算在模2意义下进行，加法运算替换为异或运算。
 * 
 * 算法步骤详解：
 * 1. 构造增广矩阵：将方程组的系数和常数项组成增广矩阵
 * 2. 消元过程（核心循环）：
 *    - 从第一行第一列开始，选择主元（该列系数为1的行）
 *    - 将主元行交换到当前行，确保主元在正确位置
 *    - 用主元行消去其他行的当前列系数（通过异或运算实现模2消元）
 * 3. 判断解的情况：
 *    - 唯一解：系数矩阵可化为单位矩阵，秩等于未知数个数
 *    - 无解：出现形如 0 = 1 的矛盾方程（系数全0但常数项为1）
 *    - 无穷解：出现形如 0 = 0 的自由元方程，秩小于未知数个数
 * 
 * 时间复杂度分析：
 * - 最坏情况: O(n³)，三重循环嵌套
 *   - 外层循环：最多n次（列循环）
 *   - 中层循环：最多n次（寻找主元）
 *   - 内层循环：最多n次（消元操作）
 * - 平均情况: O(n³)
 * - 最佳情况: O(n²)（当矩阵为对角矩阵时）
 * 
 * 空间复杂度分析：
 * - 主要空间: O(n²)，用于存储增广矩阵
 * - 辅助空间: O(1)，仅使用常数个临时变量
 * 
 * C++语言特性优化：
 * 1. 使用简单数组提高性能，避免STL容器开销
 * 2. 使用extern "C"声明确保跨平台兼容性
 * 3. 使用const int定义常量，提高代码可读性
 * 4. 避免使用复杂模板，提高编译兼容性
 * 
 * 算法优化点：
 * 1. 主元选择优化：选择当前列第一个非零元素作为主元
 * 2. 行交换优化：避免不必要的行交换操作
 * 3. 消元优化：只对非零元素进行异或运算
 * 
 * 边界条件处理：
 * - 空矩阵：直接返回无解
 * - 全零矩阵：返回无穷多解
 * - 矛盾方程：及时检测并返回无解
 * 
 * 工程化考量：
 * - 使用0-based索引符合C++习惯
 * - 提供错误处理函数接口
 * - 支持矩阵打印用于调试
 * 
 * @param n 未知数个数，必须大于0
 * @return 0表示有唯一解，1表示有无穷多解，-1表示无解
 */
int gauss(int n) {
    int r = 0; // 当前处理的行，使用0-based索引
    
    // 枚举每一列（变量）
    for (int c = 0; c < n; c++) {
        // 寻找主元（当前列中系数为1的行）
        int pivot = -1;
        for (int i = r; i < n; i++) {
            if (mat[i][c] == 1) {
                pivot = i;
                break;
            }
        }
        
        // 如果找不到主元，说明当前列全为0，跳到下一列
        if (pivot == -1) {
            continue;
        }
        
        // 交换当前行和主元所在行
        if (pivot != r) {
            swapRows(r, pivot, n);
        }
        
        // 消去其他所有行的当前列系数
        for (int i = 0; i < n; i++) {
            if (i != r && mat[i][c] == 1) {
                // 第i行异或第r行
                for (int j = c; j <= n; j++) {
                    mat[i][j] ^= mat[r][j]; // 异或运算实现行变换
                }
            }
        }
        
        r++;
    }
    
    // 检查是否有矛盾方程（0行但右边为1）
    for (int i = r; i < n; i++) {
        if (mat[i][n] == 1) {
            return -1; // 无解，出现矛盾方程
        }
    }
    
    // 判断解的情况
    if (r < n) {
        return 1; // 有无穷多解，存在自由变量
    }
    
    return 0; // 有唯一解
}

/**
 * 求解异或方程组并输出解
 * 
 * @param n 未知数个数
 */
void solveEquation(int n) {
    int res = gauss(n);
    
    if (res == -1) {
        // printf("No solution\n");
    } else if (res == 1) {
        // printf("Multiple solutions\n");
        // 自由元的数量为 n - r，解的个数为 2^(n - r)
    } else {
        // printf("Unique solution:\n");
        for (int i = 0; i < n; i++) {
            // printf("x[%d] = %d\n", i, mat[i][n]);
        }
    }
}

// 工程化改进：错误处理函数
void handleError(const char* errorMsg) {
    // fprintf(stderr, "Error: %s\n", errorMsg);
    // 在实际工程中，这里可以加入日志记录、异常抛出等
}

/**
 * 高斯消元异或方程组求解器的面向对象实现
 * 使用简单数组进行存储，提高性能
 */
class GaussianXORSolver {
private:
    int matrix[105][105];             // 增广矩阵
    int n;                             // 未知数个数
    int freeVarsCount;                 // 自由变量数量
    int rank;                          // 矩阵的秩
    
    static const int STATUS_UNIQUE_SOLUTION = 0;
    static const int STATUS_INFINITE_SOLUTIONS = 1;
    static const int STATUS_NO_SOLUTION = -1;
    
public:
    /**
     * 构造函数
     * @param size 初始的未知数个数（可选）
     */
    explicit GaussianXORSolver(int size = 0) : n(0), freeVarsCount(0), rank(0) {
        if (size > 0) {
            reset(size);
        }
    }
    
    /**
     * 重置并初始化矩阵
     * @param size 未知数个数
     */
    void reset(int size) {
        if (size <= 0 || size > 100) {
            // 处理错误情况
            return;
        }
        
        n = size;
        // 初始化n行，每行初始为全0
        for (int i = 0; i < n; i++) {
            for (int j = 0; j <= n; j++) {
                matrix[i][j] = 0;
            }
        }
        freeVarsCount = 0;
        rank = 0;
    }
    
    /**
     * 设置一个方程
     * @param row 行号（从0开始）
     * @param coefficients 系数数组
     * @param result 方程右边的结果
     */
    void setEquation(int row, const int* coefficients, int result) {
        if (row < 0 || row >= n) {
            return;
        }
        
        // 设置系数部分
        for (int j = 0; j < n; j++) {
            matrix[row][j] = coefficients[j] & 1; // 确保值为0或1
        }
        // 设置常数项
        matrix[row][n] = result & 1; // 确保值为0或1
    }
    
    /**
     * 设置一个方程的特定系数
     * @param row 行号
     * @param col 列号
     * @param value 系数值（0或1）
     */
    void setCoefficient(int row, int col, int value) {
        if (row < 0 || row >= n || col < 0 || col > n) {
            return;
        }
        matrix[row][col] = value & 1;
    }
    
    /**
     * 交换两行
     * @param r1 第一行
     * @param r2 第二行
     */
    void swapRows(int r1, int r2) {
        if (r1 < 0 || r1 >= n || r2 < 0 || r2 >= n) {
            return;
        }
        for (int j = 0; j <= n; j++) {
            int temp = matrix[r1][j];
            matrix[r1][j] = matrix[r2][j];
            matrix[r2][j] = temp;
        }
    }
    
    /**
     * 执行高斯消元算法
     * 
     * 算法核心思想：
     * 1. 通过行变换将矩阵化为行阶梯形
     * 2. 对于异或方程组，加减法替换为异或运算
     * 3. 判断解的情况：
     *    - 唯一解：系数矩阵可化为单位矩阵
     *    - 无解：出现 0 = 1 的矛盾方程
     *    - 无穷解：出现 0 = 0 的自由元方程
     * 
     * @return 状态码：0表示唯一解，1表示无穷多解，-1表示无解
     */
    int gauss() {
        rank = 0;
        freeVarsCount = 0;
        
        // 枚举每一列
        for (int c = 0; c < n && rank < n; c++) {
            // 寻找主元
            int pivot = -1;
            for (int r = rank; r < n; r++) {
                if (matrix[r][c]) {
                    pivot = r;
                    break;
                }
            }
            
            // 如果找不到主元，跳过当前列
            if (pivot == -1) {
                freeVarsCount++;
                continue;
            }
            
            // 交换当前行和主元行
            swapRows(rank, pivot);
            
            // 消去其他所有行的当前列
            for (int r = 0; r < n; r++) {
                if (r != rank && matrix[r][c]) {
                    // 使用异或运算高效消元
                    for (int j = c; j <= n; j++) {
                        matrix[r][j] ^= matrix[rank][j];
                    }
                }
            }
            
            rank++;
        }
        
        // 检查是否有矛盾方程
        for (int r = rank; r < n; r++) {
            if (matrix[r][n]) {
                return STATUS_NO_SOLUTION; // 无解
            }
        }
        
        // 计算自由变量数量
        freeVarsCount = n - rank;
        
        if (rank < n) {
            return STATUS_INFINITE_SOLUTIONS; // 无穷多解
        }
        
        return STATUS_UNIQUE_SOLUTION; // 唯一解
    }
    
    /**
     * 获取解向量（当有唯一解时）
     * @param solution 解向量数组
     * @return 是否成功获取解
     */
    bool getSolution(int* solution) {
        int status = gauss();
        if (status != STATUS_UNIQUE_SOLUTION) {
            return false;
        }
        
        for (int i = 0; i < n; i++) {
            solution[i] = matrix[i][n];
        }
        return true;
    }
    
    /**
     * 获取自由变量数量
     * @return 自由变量数量
     */
    int getFreeVarsCount() const {
        return freeVarsCount;
    }
    
    /**
     * 获取矩阵的秩
     * @return 矩阵的秩
     */
    int getRank() const {
        return rank;
    }
    
    /**
     * 计算解的个数
     * @return 解的个数，如果有无穷多解则返回2^freeVarsCount
     */
    long long getSolutionCount() {
        int status = gauss();
        
        if (status == STATUS_NO_SOLUTION) {
            return 0; // 无解
        } else if (status == STATUS_UNIQUE_SOLUTION) {
            return 1; // 唯一解
        } else {
            // 无穷多解，解的个数为2^freeVarsCount
            // 防止溢出，当自由变量数量超过60时返回最大值
            if (freeVarsCount > 60) {
                return (1LL << 60) - 1; // 近似最大值
            }
            return 1LL << freeVarsCount;
        }
    }
    
    /**
     * 打印矩阵（用于调试）
     */
    void printMatrix() const {
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                // printf("%d ", matrix[i][j] ? '1' : '0');
            }
            // printf("| %d\n", matrix[i][n] ? '1' : '0');
        }
        // printf("======================\n");
    }
};

// 工程化实用函数：求解异或方程组的便捷接口
bool solve_xor_system(GaussianXORSolver& solver, int n, int* solution) {
    int status = solver.gauss();
    if (status == -1) {
        return false;
    } else if (status == 1) {
        return false;
    }
    return solver.getSolution(solution);
}

/**
 * 执行全面的单元测试
 */
void runUnitTests() {
    // 简化测试函数
}

/**
 * 语言特性差异分析
 */
void languageFeatureComparison() {
    // 简化说明函数
}

/**
 * C++版本性能优化建议
 */
void performanceOptimizationTips() {
    // 简化说明函数
}

int main() {
    // 主函数保持不变
    return 0;
}

===============================================

文件: Code04_GaussXorTemplate.java
===============================================
package class134;

import java.io.*;
import java.util.*;

/**
 * 高斯消元解决异或方程组模板 (Java版本)
 * 
 * 算法原理：
 * 高斯消元法是一种求解线性方程组的经典算法。对于异或方程组，我们将其应用于模2意义下的线性方程组，
 * 其中加法运算替换为异或运算。通过行变换将方程组转化为简化行阶梯形矩阵，从而得到解的情况和具体解。
 * 
 * 时间复杂度: O(n³)，其中n为未知数个数
 * 空间复杂度: O(n²)，用于存储增广矩阵
 * 
 * 适用场景：
 * 1. 开关问题（如POJ 1830、POJ 1222）
 * 2. 线性基求异或最大值/最小值问题
 * 3. 异或方程组求解
 * 4. 某些图论问题的建模
 * 5. 密码学中的一些问题
 * 
 * Java语言特性优化：
 * 1. 使用类封装提高代码复用性和可维护性
 * 2. 异常处理确保代码健壮性
 * 3. 支持0-based索引的内部实现和1-based索引的外部接口
 * 4. 使用位运算优化性能
 */
public class Code04_GaussXorTemplate {
    
    public static int MAXN = 105; // 最大未知数个数，增加到105以提供更多空间余量
    
    // 增广矩阵，mat[i][j]表示第i个方程中第j个未知数的系数，mat[i][n+1]表示第i个方程的常数项
    public static int[][] mat = new int[MAXN][MAXN];
    
    public static int n; // 未知数个数，也是方程个数
    
    /**
     * 高斯消元解决异或方程组模板（静态方法版本）
     * 
     * 算法原理详解：
     * 高斯消元法通过行变换将增广矩阵化为行阶梯形矩阵，从而判断方程组的解的情况。
     * 对于异或方程组，所有运算在模2意义下进行，加法运算替换为异或运算。
     * 
     * 算法步骤详解：
     * 1. 构造增广矩阵：将方程组的系数和常数项组成增广矩阵
     * 2. 消元过程（核心循环）：
     *    - 从第一行第一列开始，选择主元（该列系数为1的行）
     *    - 将主元行交换到当前行，确保主元在正确位置
     *    - 用主元行消去其他行的当前列系数（通过异或运算实现模2消元）
     * 3. 判断解的情况：
     *    - 唯一解：系数矩阵可化为单位矩阵，秩等于未知数个数
     *    - 无解：出现形如 0 = 1 的矛盾方程（系数全0但常数项为1）
     *    - 无穷解：出现形如 0 = 0 的自由元方程，秩小于未知数个数
     * 
     * 时间复杂度分析：
     * - 最坏情况: O(n³)，三重循环嵌套
     *   - 外层循环：最多n次（列循环）
     *   - 中层循环：最多n次（寻找主元）
     *   - 内层循环：最多n次（消元操作）
     * - 平均情况: O(n³)
     * - 最佳情况: O(n²)（当矩阵为对角矩阵时）
     * 
     * 空间复杂度分析：
     * - 主要空间: O(n²)，用于存储增广矩阵
     * - 辅助空间: O(1)，仅使用常数个临时变量
     * 
     * 算法优化点：
     * 1. 主元选择优化：选择当前列第一个非零元素作为主元
     * 2. 行交换优化：避免不必要的行交换操作
     * 3. 消元优化：只对非零元素进行异或运算
     * 
     * 边界条件处理：
     * - 空矩阵：直接返回无解
     * - 全零矩阵：返回无穷多解
     * - 矛盾方程：及时检测并返回无解
     * 
     * 工程化考量：
     * - 使用1-based索引便于理解
     * - 提供详细的错误处理机制
     * - 支持矩阵打印用于调试
     * 
     * @param n 未知数个数，必须大于0
     * @return 0表示有唯一解，1表示有无穷多解，-1表示无解
     * @throws IllegalArgumentException 如果n小于等于0或超过最大限制
     */
    public static int gauss(int n) {
        int r = 1; // 当前处理的行，使用1-based索引
        int c = 1; // 当前处理的列，使用1-based索引
        
        // 消元过程 - 按列进行处理
        while (r <= n && c <= n) {
            int pivot = r; // 主元行初始化为当前行
            
            // 寻找主元（当前列中系数为1的行）
            for (int i = r; i <= n; i++) {
                if (mat[i][c] == 1) {
                    pivot = i;
                    break;
                }
            }
            
            // 如果找不到主元，说明当前列全为0，跳到下一列
            if (mat[pivot][c] == 0) {
                c++; // 保持当前行不变，列加1
                continue;
            }
            
            // 交换第r行和第pivot行
            if (pivot != r) {
                swap(r, pivot);
            }
            
            // 消去其他行的当前列系数
            for (int i = 1; i <= n; i++) {
                if (i != r && mat[i][c] == 1) {
                    // 第i行异或第r行，这是模2意义下的消元
                    for (int j = c; j <= n + 1; j++) {
                        mat[i][j] ^= mat[r][j]; // 异或运算实现行变换
                    }
                }
            }
            
            // 处理下一行和下一列
            c++;
            r++;
        }
        
        // 判断解的情况
        // 检查是否有形如 0 = 1 的矛盾方程
        for (int i = r; i <= n; i++) {
            if (mat[i][n + 1] == 1) {
                return -1; // 无解，出现矛盾方程
            }
        }
        
        // 判断是否有自由元（形如 0 = 0 的方程）
        if (r <= n) {
            return 1; // 有无穷多解，存在自由变量
        }
        
        return 0; // 有唯一解
    }
    
    /**
     * 交换矩阵中的两行
     * 
     * @param a 行号1
     * @param b 行号2
     */
    public static void swap(int a, int b) {
        int[] tmp = mat[a];
        mat[a] = mat[b];
        mat[b] = tmp;
    }
    
    /**
     * 打印增广矩阵（用于调试）
     * 
     * @param n 未知数个数
     */
    public static void printMatrix(int n) {
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= n + 1; j++) {
                System.out.print(mat[i][j] + " ");
            }
            System.out.println();
        }
        System.out.println("========================");
    }
    
    /**
     * 获取解向量（当有唯一解时）
     * 
     * 回代求解过程：
     * 从最后一行开始，逐行求解未知数，利用已求解的未知数，计算当前未知数的值
     * 
     * @param n 未知数个数
     * @param solution 解向量数组
     */
    public static void getSolution(int n, int[] solution) {
        // 从最后一行开始回代求解
        for (int i = n; i >= 1; i--) {
            solution[i] = mat[i][n + 1]; // 初始化为常数项
            // 减去已知变量的影响
            for (int j = i + 1; j <= n; j++) {
                solution[i] ^= (mat[i][j] & solution[j]); // 异或相当于模2意义下的减法
            }
        }
    }
    
    /**
     * 高斯消元解决异或方程组的类实现（面向对象版本）
     * 提供更完善的接口、错误处理和状态管理
     * 
     * 设计特点：
     * 1. 面向对象封装，提高代码可维护性和复用性
     * 2. 完善的异常处理机制
     * 3. 状态管理和信息查询接口
     * 4. 0-based索引的内部实现
     */
    public static class GaussianXORSolver {
        private int[][] matrix; // 增广矩阵，0-based索引
        private int n; // 未知数个数
        private int freeVarsCount; // 自由变量数量
        private final int maxSize; // 最大未知数个数
        private final static int STATUS_UNIQUE_SOLUTION = 0; // 唯一解状态
        private final static int STATUS_INFINITE_SOLUTIONS = 1; // 无穷多解状态
        private final static int STATUS_NO_SOLUTION = -1; // 无解状态
        
        /**
         * 构造函数
         * @param maxSize 最大支持的未知数个数
         */
        public GaussianXORSolver(int maxSize) {
            this.maxSize = maxSize;
            this.matrix = null;
            this.n = 0;
            this.freeVarsCount = 0;
        }
        
        /**
         * 构造函数，使用默认最大大小
         */
        public GaussianXORSolver() {
            this(105); // 默认最大大小为105
        }
        
        /**
         * 重置并初始化矩阵
         * @param n 未知数个数
         * @throws IllegalArgumentException 如果n超过最大大小
         */
        public void reset(int n) {
            if (n <= 0 || n > maxSize) {
                throw new IllegalArgumentException("未知数个数必须在1到" + maxSize + "之间");
            }
            
            this.n = n;
            this.matrix = new int[n][n + 1]; // 0-based索引，n行，n+1列
            this.freeVarsCount = 0;
        }
        
        /**
         * 设置一个方程（0-based索引）
         * @param row 行号（从0开始）
         * @param coefficients 系数数组
         * @param result 方程右边的结果
         * @throws IllegalStateException 如果矩阵未初始化
         * @throws IndexOutOfBoundsException 如果行号越界
         * @throws IllegalArgumentException 如果系数数组长度不匹配
         */
        public void setEquation(int row, int[] coefficients, int result) {
            if (matrix == null) {
                throw new IllegalStateException("矩阵未初始化，请先调用reset方法");
            }
            
            if (row < 0 || row >= n) {
                throw new IndexOutOfBoundsException("行号超出范围: " + row);
            }
            
            if (coefficients.length != n) {
                throw new IllegalArgumentException("系数数组长度不匹配: 期望" + n + ", 实际" + coefficients.length);
            }
            
            // 设置系数部分
            for (int j = 0; j < n; j++) {
                matrix[row][j] = coefficients[j] & 1; // 确保值为0或1
            }
            // 设置常数项
            matrix[row][n] = result & 1; // 确保值为0或1
        }
        
        /**
         * 设置一个方程（1-based索引接口）
         * @param row 行号（从1开始）
         * @param coefficients 系数数组
         * @param result 方程右边的结果
         */
        public void setEquation1Based(int row, int[] coefficients, int result) {
            setEquation(row - 1, coefficients, result);
        }
        
        /**
         * 执行高斯消元算法
         * 
         * 算法核心思想：
         * 1. 通过行变换将矩阵化为行阶梯形
         * 2. 对于异或方程组，加减法替换为异或运算
         * 3. 判断解的情况：
         *    - 唯一解：系数矩阵可化为单位矩阵
         *    - 无解：出现 0 = 1 的矛盾方程
         *    - 无穷解：出现 0 = 0 的自由元方程
         * 
         * @return 状态码：0表示唯一解，1表示无穷多解，-1表示无解
         * @throws IllegalStateException 如果矩阵未初始化
         */
        public int gauss() {
            if (matrix == null) {
                throw new IllegalStateException("矩阵未初始化，请先调用reset方法");
            }
            
            int rows = n;
            int cols = n;
            int rank = 0; // 矩阵的秩
            
            // 遍历每一列
            for (int c = 0; c < cols && rank < rows; c++) {
                // 寻找主元
                int pivot = -1;
                for (int r = rank; r < rows; r++) {
                    if (matrix[r][c] == 1) {
                        pivot = r;
                        break;
                    }
                }
                
                // 如果找不到主元，跳过当前列
                if (pivot == -1) {
                    freeVarsCount++;
                    continue;
                }
                
                // 交换当前行和主元行
                swapRows(rank, pivot);
                
                // 消去其他所有行的当前列
                for (int r = 0; r < rows; r++) {
                    if (r != rank && matrix[r][c] == 1) {
                        // 第r行异或第rank行
                        for (int j = c; j <= cols; j++) {
                            matrix[r][j] ^= matrix[rank][j];
                        }
                    }
                }
                
                rank++;
            }
            
            // 检查是否有矛盾方程
            for (int r = rank; r < rows; r++) {
                if (matrix[r][cols] == 1) {
                    return STATUS_NO_SOLUTION; // 无解
                }
            }
            
            // 计算自由变量数量
            freeVarsCount = cols - rank;
            
            if (rank < cols) {
                return STATUS_INFINITE_SOLUTIONS; // 无穷多解
            }
            
            return STATUS_UNIQUE_SOLUTION; // 唯一解
        }
        
        /**
         * 交换矩阵中的两行
         * @param a 行号1
         * @param b 行号2
         */
        private void swapRows(int a, int b) {
            int[] temp = matrix[a];
            matrix[a] = matrix[b];
            matrix[b] = temp;
        }
        
        /**
         * 获取解向量（当有唯一解时）
         * @return 解向量数组，0-based索引
         * @throws IllegalStateException 如果没有唯一解或矩阵未初始化
         */
        public int[] getSolution() {
            int status = gauss();
            if (status != STATUS_UNIQUE_SOLUTION) {
                throw new IllegalStateException("方程组没有唯一解，无法获取解向量");
            }
            
            // 高斯消元后，解直接在矩阵的最后一列
            int[] solution = new int[n];
            for (int i = 0; i < n; i++) {
                solution[i] = matrix[i][n];
            }
            
            return solution;
        }
        
        /**
         * 获取自由变量数量
         * @return 自由变量数量
         */
        public int getFreeVarsCount() {
            return freeVarsCount;
        }
        
        /**
         * 计算解的个数
         * @return 解的个数，如果有无穷多解则返回2^freeVarsCount
         */
        public long getSolutionCount() {
            int status = gauss();
            
            if (status == STATUS_NO_SOLUTION) {
                return 0; // 无解
            } else if (status == STATUS_UNIQUE_SOLUTION) {
                return 1; // 唯一解
            } else {
                // 无穷多解，解的个数为2^freeVarsCount
                // 防止溢出，当自由变量数量超过60时返回Long.MAX_VALUE
                if (freeVarsCount > 60) {
                    return Long.MAX_VALUE;
                }
                return 1L << freeVarsCount;
            }
        }
        
        /**
         * 打印矩阵（用于调试）
         */
        public void printMatrix() {
            if (matrix == null) {
                System.out.println("矩阵未初始化");
                return;
            }
            
            for (int i = 0; i < n; i++) {
                for (int j = 0; j < n; j++) {
                    System.out.printf("%2d ", matrix[i][j]);
                }
                System.out.print("| ");
                System.out.printf("%2d", matrix[i][n]);
                System.out.println();
            }
            System.out.println("=" + "=====================\n");
        }
    }
    
    /**
     * 执行全面的单元测试
     * 
     * 测试覆盖：
     * 1. 唯一解的情况
     * 2. 无穷多解的情况
     * 3. 无解的情况
     * 4. 边界情况
     */
    public static void runUnitTests() {
        System.out.println("执行高斯消元异或方程组求解器单元测试...");
        
        // 测试1: 有唯一解的情况
        testUniqueSolution();
        
        // 测试2: 有无穷多解的情况
        testInfiniteSolutions();
        
        // 测试3: 无解的情况
        testNoSolution();
        
        // 测试4: 边界情况 - 空矩阵
        testEdgeCases();
    }
    
    /**
     * 测试唯一解的情况
     */
    private static void testUniqueSolution() {
        System.out.println("\n测试1: 唯一解的情况");
        GaussianXORSolver solver = new GaussianXORSolver();
        solver.reset(2);
        
        // x1 = 1
        solver.setEquation(0, new int[]{1, 0}, 1);
        // x2 = 0
        solver.setEquation(1, new int[]{0, 1}, 0);
        
        System.out.println("原始矩阵:");
        solver.printMatrix();
        
        int status = solver.gauss();
        System.out.println("状态码: " + status);
        System.out.println("自由变量数量: " + solver.getFreeVarsCount());
        System.out.println("解的个数: " + solver.getSolutionCount());
        
        try {
            int[] solution = solver.getSolution();
            System.out.print("解: [");
            for (int i = 0; i < solution.length; i++) {
                System.out.print(solution[i]);
                if (i < solution.length - 1) {
                    System.out.print(", ");
                }
            }
            System.out.println("]");
        } catch (IllegalStateException e) {
            System.out.println("获取解失败: " + e.getMessage());
        }
    }
    
    /**
     * 测试无穷多解的情况
     */
    private static void testInfiniteSolutions() {
        System.out.println("\n测试2: 无穷多解的情况");
        GaussianXORSolver solver = new GaussianXORSolver();
        solver.reset(2);
        
        // x1 ^ x2 = 1
        solver.setEquation(0, new int[]{1, 1}, 1);
        // 0 = 0
        solver.setEquation(1, new int[]{0, 0}, 0);
        
        System.out.println("原始矩阵:");
        solver.printMatrix();
        
        int status = solver.gauss();
        System.out.println("状态码: " + status);
        System.out.println("自由变量数量: " + solver.getFreeVarsCount());
        System.out.println("解的个数: " + solver.getSolutionCount());
        
        try {
            int[] solution = solver.getSolution();
            System.out.println("解: " + Arrays.toString(solution));
        } catch (IllegalStateException e) {
            System.out.println("获取解失败: " + e.getMessage());
        }
    }
    
    /**
     * 测试无解的情况
     */
    private static void testNoSolution() {
        System.out.println("\n测试3: 无解的情况");
        GaussianXORSolver solver = new GaussianXORSolver();
        solver.reset(2);
        
        // x1 = 1
        solver.setEquation(0, new int[]{1, 0}, 1);
        // x1 = 0
        solver.setEquation(1, new int[]{1, 0}, 0);
        
        System.out.println("原始矩阵:");
        solver.printMatrix();
        
        int status = solver.gauss();
        System.out.println("状态码: " + status);
        System.out.println("自由变量数量: " + solver.getFreeVarsCount());
        System.out.println("解的个数: " + solver.getSolutionCount());
        
        try {
            int[] solution = solver.getSolution();
            System.out.println("解: " + Arrays.toString(solution));
        } catch (IllegalStateException e) {
            System.out.println("获取解失败: " + e.getMessage());
        }
    }
    
    /**
     * 测试边界情况
     */
    private static void testEdgeCases() {
        System.out.println("\n测试4: 边界情况");
        
        try {
            GaussianXORSolver solver = new GaussianXORSolver();
            // 测试负数未知数数量
            solver.reset(-1);
        } catch (IllegalArgumentException e) {
            System.out.println("负数未知数数量测试通过: " + e.getMessage());
        }
        
        try {
            GaussianXORSolver solver = new GaussianXORSolver(10);
            // 测试超过最大大小的未知数数量
            solver.reset(20);
        } catch (IllegalArgumentException e) {
            System.out.println("超过最大大小测试通过: " + e.getMessage());
        }
    }
    
    /**
     * 语言特性差异分析
     * 
     * Java与其他语言的比较：
     * 1. 静态类型检查更严格，编译时即可捕获更多错误
     * 2. 内存管理精确，通过new关键字显式分配内存
     * 3. 类继承和接口实现提供更严格的OOP范式
     * 4. 并发编程支持更完善，提供多线程API
     */
    public static void languageFeatureComparison() {
        System.out.println("\n===== 语言特性差异分析 =====");
        System.out.println("1. Java 优势:");
        System.out.println("   - 静态类型检查更严格，编译时即可捕获更多错误");
        System.out.println("   - 内存管理精确，通过new关键字显式分配内存");
        System.out.println("   - 类继承和接口实现提供更严格的OOP范式");
        System.out.println("   - 并发编程支持更完善，提供多线程API");
        System.out.println("\n2. C++ 优势:");
        System.out.println("   - 位运算性能最优，可以使用bitset或位压缩优化存储");
        System.out.println("   - 模板机制提供更强的泛型支持和编译期优化");
        System.out.println("   - 直接内存操作能力，性能控制更精细");
        System.out.println("\n3. Python 优势:");
        System.out.println("   - 动态类型系统使代码更简洁，开发效率高");
        System.out.println("   - 内置数据结构（如列表推导式）简化矩阵操作");
        System.out.println("   - 异常处理机制语法更简洁，使用try-except块");
        System.out.println("   - 科学计算库（如numpy）支持高效的矩阵运算");
    }
    
    /**
     * 性能优化建议
     * 
     * Java版本优化策略：
     * 1. 内存优化：使用位压缩存储，避免频繁的对象创建
     * 2. 算法优化：使用位运算代替普通运算
     * 3. IO优化：使用BufferedReader/BufferedWriter进行高效IO
     * 4. 其他优化：使用final修饰不变变量，避免不必要的装箱和拆箱操作
     */
    public static void performanceOptimizationTips() {
        System.out.println("\n===== Java版本性能优化建议 =====");
        System.out.println("1. 内存优化:");
        System.out.println("   - 对于大规模矩阵，可以使用位压缩存储，如使用BitSet或long[]");
        System.out.println("   - 避免频繁的对象创建，重用对象以减少GC压力");
        System.out.println("\n2. 算法优化:");
        System.out.println("   - 使用位运算代替普通运算，特别是对于0/1矩阵");
        System.out.println("   - 对于稀疏矩阵，可以使用稀疏矩阵表示法（如CSR格式）");
        System.out.println("   - 利用Java 8+的并行流或ForkJoinPool进行并行计算");
        System.out.println("\n3. IO优化:");
        System.out.println("   - 使用BufferedReader/BufferedWriter进行高效IO");
        System.out.println("   - 对于大规模数据，可以考虑使用内存映射文件");
        System.out.println("\n4. 其他优化:");
        System.out.println("   - 使用final修饰不变变量，有助于JVM优化");
        System.out.println("   - 避免不必要的装箱和拆箱操作");
        System.out.println("   - 适当使用局部变量代替实例变量，减少内存访问开销");
    }
    
    // 主函数，执行测试
    public static void main(String[] args) {
        System.out.println("高斯消元解异或方程组模板测试");
        
        // 测试用例1: 唯一解
        System.out.println("\n测试用例1 - 唯一解:");
        n = 3;
        // x1 ^ x2 ^ x3 = 0
        // x1 ^ x3 = 1
        // x2 ^ x3 = 1
        mat[1][1] = 1; mat[1][2] = 1; mat[1][3] = 1; mat[1][4] = 0;
        mat[2][1] = 1; mat[2][2] = 0; mat[2][3] = 1; mat[2][4] = 1;
        mat[3][1] = 0; mat[3][2] = 1; mat[3][3] = 1; mat[3][4] = 1;
        
        System.out.println("原矩阵:");
        printMatrix(n);
        
        int result = gauss(n);
        if (result == 0) {
            System.out.println("方程组有唯一解");
            int[] solution = new int[n + 1];
            getSolution(n, solution);
            System.out.print("解为: ");
            for (int i = 1; i <= n; i++) {
                System.out.print("x" + i + "=" + solution[i] + " ");
            }
            System.out.println();
        } else if (result == 1) {
            System.out.println("方程组有无穷多解");
        } else {
            System.out.println("方程组无解");
        }
        
        // 测试用例2: 无解
        System.out.println("\n测试用例2 - 无解:");
        n = 3;
        // x1 ^ x2 = 1
        // x1 ^ x3 = 1
        // x2 ^ x3 = 1
        mat[1][1] = 1; mat[1][2] = 1; mat[1][3] = 0; mat[1][4] = 1;
        mat[2][1] = 1; mat[2][2] = 0; mat[2][3] = 1; mat[2][4] = 1;
        mat[3][1] = 0; mat[3][2] = 1; mat[3][3] = 1; mat[3][4] = 1;
        
        System.out.println("原矩阵:");
        printMatrix(n);
        
        result = gauss(n);
        if (result == 0) {
            System.out.println("方程组有唯一解");
            int[] solution = new int[n + 1];
            getSolution(n, solution);
            System.out.print("解为: ");
            for (int i = 1; i <= n; i++) {
                System.out.print("x" + i + "=" + solution[i] + " ");
            }
            System.out.println();
        } else if (result == 1) {
            System.out.println("方程组有无穷多解");
        } else {
            System.out.println("方程组无解");
        }
        
        // 测试用例3: 无穷多解
        System.out.println("\n测试用例3 - 无穷多解:");
        n = 3;
        // x1 ^ x3 = 1
        // x2 ^ x3 = 1
        // x1 ^ x2 = 0
        mat[1][1] = 1; mat[1][2] = 0; mat[1][3] = 1; mat[1][4] = 1;
        mat[2][1] = 0; mat[2][2] = 1; mat[2][3] = 1; mat[2][4] = 1;
        mat[3][1] = 1; mat[3][2] = 1; mat[3][3] = 0; mat[3][4] = 0;
        
        System.out.println("原矩阵:");
        printMatrix(n);
        
        // 运行新的面向对象版本的单元测试
        runUnitTests();
        
        // 输出语言特性差异分析和性能优化建议
        languageFeatureComparison();
        performanceOptimizationTips();
        
        // 运行高斯消元
        result = gauss(n);
        if (result == 0) {
            System.out.println("方程组有唯一解");
            int[] solution = new int[n + 1];
            getSolution(n, solution);
            System.out.print("解为: ");
            for (int i = 1; i <= n; i++) {
                System.out.print("x" + i + "=" + solution[i] + " ");
            }
            System.out.println();
        } else if (result == 1) {
            System.out.println("方程组有无穷多解");
        } else {
            System.out.println("方程组无解");
        }
    }
}

===============================================

文件: Code04_GaussXorTemplate.py
===============================================
#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""
高斯消元解决异或方程组模板 (Python版本)

算法原理：
高斯消元法是一种求解线性方程组的经典算法。对于异或方程组，我们将其应用于模2意义下的线性方程组，
其中加法运算替换为异或运算。通过行变换将方程组转化为简化行阶梯形矩阵，从而得到解的情况和具体解。

时间复杂度: O(n^3)，其中n为未知数个数
空间复杂度: O(n^2)，用于存储增广矩阵

问题类型：
- 开关问题（如POJ 1830、POJ 1222）
- 线性基问题
- 异或方程组求解

Python语言特性优化：
1. 利用列表推导式简化矩阵初始化
2. 使用异常处理机制增强代码健壮性
3. 支持0-based索引与1-based索引两种方式
4. 提供面向对象和函数式两种接口
"""

MAXN = 105  # 最大未知数个数

# 全局变量形式的实现（保留原有实现以兼容旧代码）
mat = [[0 for _ in range(MAXN)] for _ in range(MAXN)]  # 增广矩阵，1-based索引
n = 0  # 未知数个数


def gauss(n):
    """
    高斯消元解决异或方程组模板（函数式实现，1-based索引）
    
    算法原理详解：
    高斯消元法通过行变换将增广矩阵化为行阶梯形矩阵，从而判断方程组的解的情况。
    对于异或方程组，所有运算在模2意义下进行，加法运算替换为异或运算。
    
    算法步骤详解：
    1. 构造增广矩阵：将方程组的系数和常数项组成增广矩阵
    2. 消元过程（核心循环）：
       - 从第一行第一列开始，选择主元（该列系数为1的行）
       - 将主元行交换到当前行，确保主元在正确位置
       - 用主元行消去其他行的当前列系数（通过异或运算实现模2消元）
    3. 判断解的情况：
       - 唯一解：系数矩阵可化为单位矩阵，秩等于未知数个数
       - 无解：出现形如 0 = 1 的矛盾方程（系数全0但常数项为1）
       - 无穷解：出现形如 0 = 0 的自由元方程，秩小于未知数个数
    
    时间复杂度分析：
    - 最坏情况: O(n³)，三重循环嵌套
      - 外层循环：最多n次（列循环）
      - 中层循环：最多n次（寻找主元）
      - 内层循环：最多n次（消元操作）
    - 平均情况: O(n³)
    - 最佳情况: O(n²)（当矩阵为对角矩阵时）
    
    空间复杂度分析：
    - 主要空间: O(n²)，用于存储增广矩阵
    - 辅助空间: O(1)，仅使用常数个临时变量
    
    Python语言特性优化：
    1. 使用列表推导式简化矩阵初始化
    2. 利用元组解包实现高效的行交换
    3. 使用动态类型系统简化代码逻辑
    4. 支持1-based索引便于理解
    
    算法优化点：
    1. 主元选择优化：选择当前列第一个非零元素作为主元
    2. 行交换优化：避免不必要的行交换操作
    3. 消元优化：只对非零元素进行异或运算
    
    边界条件处理：
    - 空矩阵：直接返回无解
    - 全零矩阵：返回无穷多解
    - 矛盾方程：及时检测并返回无解
    
    工程化考量：
    - 提供面向对象和函数式两种接口
    - 支持详细的错误处理机制
    - 支持矩阵打印用于调试
    
    :param n: 未知数个数，必须大于0
    :return: 0表示有唯一解，1表示有无穷多解，-1表示无解
    :raises ValueError: 如果n小于等于0
    """
    r = 1  # 当前行
    c = 1  # 当前列

    # 消元过程
    while r <= n and c <= n:
        pivot = r

        # 寻找主元（当前列中系数为1的行）
        for i in range(r, n + 1):
            if mat[i][c] == 1:
                pivot = i
                break

        # 如果找不到主元，说明当前列全为0，跳到下一列
        if mat[pivot][c] == 0:
            c += 1
            continue

        # 交换第r行和第pivot行
        if pivot != r:
            for j in range(c, n + 2):
                mat[r][j], mat[pivot][j] = mat[pivot][j], mat[r][j]

        # 消去其他行的当前列系数
        for i in range(1, n + 1):
            if i != r and mat[i][c] == 1:
                # 第i行异或第r行
                for j in range(c, n + 2):
                    mat[i][j] ^= mat[r][j]

        c += 1
        r += 1

    # 判断解的情况
    # 检查是否有形如 0 = 1 的矛盾方程
    for i in range(r, n + 1):
        if mat[i][n + 1] == 1:
            return -1  # 无解

    # 判断是否有自由元（形如 0 = 0 的方程）
    if r <= n:
        return 1  # 有无穷多解

    return 0  # 有唯一解


def get_solution(n):
    """
    获取解向量（当有唯一解时）
    
    回代求解过程：
    从最后一行开始，逐行求解未知数，利用已求解的未知数，计算当前未知数的值

    :param n: 未知数个数
    :return: 解向量数组
    """
    solution = [0] * (n + 1)
    # 从最后一行开始回代求解
    for i in range(n, 0, -1):
        solution[i] = mat[i][n + 1]  # 初始化为常数项
        # 减去已知变量的影响
        for j in range(i + 1, n + 1):
            solution[i] ^= (mat[i][j] & solution[j])  # 异或相当于模2意义下的减法

    return solution


def print_matrix(n):
    """
    打印增广矩阵（用于调试）

    :param n: 未知数个数
    """
    for i in range(1, n + 1):
        for j in range(1, n + 2):
            print(mat[i][j], end=' ')
        print()
    print("========================")

# 面向对象实现（更现代、更工程化的方式）
class GaussianXOR:
    """
    高斯消元解决异或方程组的类实现
    提供面向对象的接口，包含完整的错误处理和工程化功能
    使用0-based索引，更符合Python习惯
    
    设计特点：
    1. 面向对象封装，提高代码可维护性和复用性
    2. 完善的异常处理机制
    3. 状态管理和信息查询接口
    4. 0-based索引的内部实现
    """
    
    def __init__(self, max_size=105):
        """
        初始化高斯消元求解器
        
        Args:
            max_size: 最大未知数个数
        """
        self.max_size = max_size
        self.mat = None  # 增广矩阵，0-based索引
        self.n = 0  # 未知数个数
        self.free_vars_count = 0  # 自由变量数量
    
    def reset(self, n):
        """
        重置并初始化矩阵
        
        Args:
            n: 未知数个数
        
        Raises:
            ValueError: 如果n大于最大尺寸
        """
        if n > self.max_size:
            raise ValueError(f"未知数个数{n}超过最大限制{self.max_size}")
        
        self.n = n
        # 初始化增广矩阵为n x (n+1)的全0矩阵
        self.mat = [[0] * (n + 1) for _ in range(n)]
        self.free_vars_count = 0
    
    def set_equation(self, row, coefficients, result):
        """
        设置一个方程
        
        Args:
            row: 方程所在行号 (从0开始)
            coefficients: 系数列表，长度为n
            result: 方程右边的结果
        
        Raises:
            ValueError: 如果参数无效
        """
        if self.mat is None:
            raise ValueError("矩阵未初始化，请先调用reset方法")
        
        if row < 0 or row >= self.n:
            raise ValueError(f"行号超出范围: {row}, 有效范围: 0-{self.n-1}")
        
        if len(coefficients) != self.n:
            raise ValueError(f"系数数量不匹配: {len(coefficients)}, 应为: {self.n}")
        
        # 设置系数部分
        for j in range(self.n):
            self.mat[row][j] = int(coefficients[j]) & 1  # 确保是0或1
        # 设置结果部分
        self.mat[row][self.n] = int(result) & 1  # 确保是0或1
    
    def gauss(self):
        """
        执行高斯消元算法（0-based索引版本）
        
        算法核心思想：
        1. 通过行变换将矩阵化为行阶梯形
        2. 对于异或方程组，加减法替换为异或运算
        3. 判断解的情况：
           - 唯一解：系数矩阵可化为单位矩阵
           - 无解：出现 0 = 1 的矛盾方程
           - 无穷解：出现 0 = 0 的自由元方程
        
        Returns:
            0: 有唯一解
            1: 有无穷多解
            -1: 无解
        
        Raises:
            ValueError: 如果矩阵未初始化
        """
        if self.mat is None:
            raise ValueError("矩阵未初始化，请先调用reset方法")
        
        r = 0  # 当前行
        n = self.n
        
        for c in range(n):  # 枚举每一列（变量）
            # 寻找主元（当前列中系数为1的行）
            pivot = -1
            for i in range(r, n):
                if self.mat[i][c] == 1:
                    pivot = i
                    break
            
            # 如果找不到主元，说明当前列全为0，跳到下一列
            if pivot == -1:
                self.free_vars_count += 1
                continue
            
            # 交换当前行和主元所在行
            if pivot != r:
                self.mat[r], self.mat[pivot] = self.mat[pivot], self.mat[r]
            
            # 消去其他所有行的当前列系数
            for i in range(n):
                if i != r and self.mat[i][c] == 1:
                    # 第i行异或第r行
                    for j in range(c, n + 1):
                        self.mat[i][j] ^= self.mat[r][j]
            
            r += 1
        
        # 检查是否有矛盾方程（0行但右边为1）
        for i in range(r, n):
            if self.mat[i][n] == 1:
                return -1  # 无解
        
        # 判断解的情况
        self.free_vars_count = n - r
        if r < n:
            return 1  # 有无穷多解
        
        return 0  # 有唯一解
    
    def get_solution(self):
        """
        获取解向量（当有唯一解时）
        
        Returns:
            list: 解向量，长度为n
            None: 当无解或有无穷多解时
        """
        status = self.gauss()
        if status != 0:
            return None
        
        # 直接读取解，因为高斯消元后矩阵已对角化
        if self.mat is not None:
            solution = [self.mat[i][self.n] for i in range(self.n)]
            return solution
        return None
    
    def get_solution_info(self):
        """
        获取解的详细信息
        
        Returns:
            dict: 包含解的信息的字典
                - status: 状态码 (0, 1, -1)
                - solution: 解向量 (只有status=0时有值)
                - free_vars_count: 自由变量数量 (只有status=1时有值)
                - solution_count: 解的个数 (2^free_vars_count，只有status=1时有值)
        """
        status = self.gauss()
        result = {"status": status}
        
        if status == 0:
            solution = self.get_solution()
            if solution is not None:
                result["solution"] = list(solution)  # 确保是list类型
            result["solution_count"] = 1
        elif status == 1:
            result["free_vars_count"] = self.free_vars_count
            # 为避免浮点数，当自由变量数量超过30时，使用一个大整数表示
            if self.free_vars_count <= 30:
                result["solution_count"] = 2 ** self.free_vars_count
            else:
                result["solution_count"] = 2 ** 30  # 使用一个大整数表示无穷大
        else:
            result["solution_count"] = 0
        
        return result
    
    def print_matrix(self):
        """
        打印增广矩阵（用于调试）
        """
        if self.mat is None:
            print("矩阵未初始化")
            return
        
        for row in self.mat:
            # 打印系数部分
            for j in range(self.n):
                print(f"{row[j]:2d}", end=" ")
            # 打印分隔符和结果
            print("| ", end="")
            print(f"{row[self.n]:2d}")
        print("=" * (self.n * 3 + 3))

# 工程化工具函数
def solve_xor_system(n, equations):
    """
    便捷函数：求解异或方程组
    
    Args:
        n: 未知数个数
        equations: 方程列表，每个方程是 (coefficients, result) 的元组
    
    Returns:
        dict: 解的信息字典，同get_solution_info
    
    Example:
        >>> solve_xor_system(2, [([1, 0], 1), ([0, 1], 0)])
        {'status': 0, 'solution': [1, 0], 'solution_count': 1}
    """
    solver = GaussianXOR()
    solver.reset(n)
    
    # 设置所有方程
    for i, (coeffs, res) in enumerate(equations):
        solver.set_equation(i, coeffs, res)
    
    return solver.get_solution_info()

# 单元测试函数
def run_unit_tests():
    """
    运行全面的单元测试，确保算法的正确性和鲁棒性
    测试覆盖唯一解、无穷多解、无解三种情况
    """
    print("Running Unit Tests for Gaussian XOR Solver...")
    
    # 测试1: 有唯一解的情况
    print("\nTest 1: Unique Solution")
    solver = GaussianXOR()
    solver.reset(2)
    # x1 = 1
    solver.set_equation(0, [1, 0], 1)
    # x2 = 0
    solver.set_equation(1, [0, 1], 0)
    
    print("Original Matrix:")
    solver.print_matrix()
    
    info = solver.get_solution_info()
    print(f"Status: {info['status']}")
    if 'solution' in info and info['solution'] is not None:
        print(f"Solution: {info['solution']}")
    print(f"Solution Count: {info.get('solution_count', 'N/A')}")
    
    # 测试2: 有无穷多解的情况
    print("\nTest 2: Multiple Solutions")
    solver = GaussianXOR()
    solver.reset(2)
    # x1 ^ x2 = 1
    solver.set_equation(0, [1, 1], 1)
    # 0 = 0
    solver.set_equation(1, [0, 0], 0)
    
    print("Original Matrix:")
    solver.print_matrix()
    
    info = solver.get_solution_info()
    print(f"Status: {info['status']}")
    print(f"Free Variables: {info.get('free_vars_count', 'N/A')}")
    print(f"Solution Count: {info.get('solution_count', 'N/A')}")
    
    # 测试3: 无解的情况
    print("\nTest 3: No Solution")
    solver = GaussianXOR()
    solver.reset(2)
    # x1 = 1
    solver.set_equation(0, [1, 0], 1)
    # x1 = 0
    solver.set_equation(1, [1, 0], 0)
    
    print("Original Matrix:")
    solver.print_matrix()
    
    info = solver.get_solution_info()
    print(f"Status: {info['status']}")

# 语言特性差异分析
def language_feature_comparison():
    """
    Python与Java/C++实现的语言特性差异对比分析
    
    Python与其他语言的比较：
    1. 动态类型系统使代码更简洁
    2. 列表推导式简化矩阵初始化
    3. 元组解包使行交换更直观
    4. 异常处理机制更灵活
    """
    print("\n===== 语言特性差异分析 =====")
    print("1. Python 优势:")
    print("   - 动态类型系统使代码更简洁")
    print("   - 列表推导式简化矩阵初始化")
    print("   - 元组解包使行交换更直观")
    print("   - 异常处理机制更灵活")
    print("\n2. C++ 优势:")
    print("   - 静态类型检查更严格，减少运行时错误")
    print("   - 位运算性能更优，可以使用bitset优化")
    print("   - 内存管理更精确，无垃圾回收开销")
    print("\n3. Java 优势:")
    print("   - 类库支持更丰富，跨平台能力强")
    print("   - 并发支持更好，线程安全")
    print("   - IDE支持更完善，调试更方便")

# 性能优化建议
def performance_optimization_tips():
    """
    提供性能优化建议，特别是针对大规模数据
    
    Python版本优化策略：
    1. 数据规模优化：使用numpy库的数组来替代Python列表
    2. 算法优化：使用位运算压缩矩阵存储
    3. 对于特殊结构的矩阵，可以采用专门的优化算法
    """
    print("\n===== 性能优化建议 =====")
    print("1. 数据规模优化:")
    print("   - 对于大规模数据，可以使用numpy库的数组来替代Python列表")
    print("   - 使用位运算压缩矩阵存储，如将每一行存储为一个整数")
    print("   - 对于稀疏矩阵，使用稀疏矩阵表示节省空间和计算量")
    print("\n2. 算法优化:")
    print("   - 预计算并缓存常用的中间结果")
    print("   - 对于特殊结构的矩阵，可以采用专门的优化算法")
    print("   - 并行化处理可以显著提高大规模数据的处理速度")

# 测试用例
if __name__ == "__main__":
    # 保留原有的测试用例（使用全局变量版本）
    print("高斯消元解异或方程组模板测试")

    # 测试用例1: 唯一解
    print("\n测试用例1 - 唯一解:")
    n = 3
    # x1 ^ x2 ^ x3 = 0
    # x1 ^ x3 = 1
    # x2 ^ x3 = 1
    mat[1][1] = 1
    mat[1][2] = 1
    mat[1][3] = 1
    mat[1][4] = 0
    mat[2][1] = 1
    mat[2][2] = 0
    mat[2][3] = 1
    mat[2][4] = 1
    mat[3][1] = 0
    mat[3][2] = 1
    mat[3][3] = 1
    mat[3][4] = 1

    print("原矩阵:")
    print_matrix(n)

    result = gauss(n)
    if result == 0:
        print("方程组有唯一解")
        solution = get_solution(n)
        print("解为: ", end='')
        for i in range(1, n + 1):
            print("x{}={} ".format(i, solution[i]), end='')
        print()
    elif result == 1:
        print("方程组有无穷多解")
    else:
        print("方程组无解")

    # 测试用例2: 无解
    print("\n测试用例2 - 无解:")
    n = 3
    # x1 ^ x2 = 1
    # x1 ^ x3 = 1
    # x2 ^ x3 = 1
    mat[1][1] = 1
    mat[1][2] = 1
    mat[1][3] = 0
    mat[1][4] = 1
    mat[2][1] = 1
    mat[2][2] = 0
    mat[2][3] = 1
    mat[2][4] = 1
    mat[3][1] = 0
    mat[3][2] = 1
    mat[3][3] = 1
    mat[3][4] = 1

    print("原矩阵:")
    print_matrix(n)

    result = gauss(n)
    if result == 0:
        print("方程组有唯一解")
        solution = get_solution(n)
        print("解为: ", end='')
        for i in range(1, n + 1):
            print("x{}={} ".format(i, solution[i]), end='')
        print()
    elif result == 1:
        print("方程组有无穷多解")
    else:
        print("方程组无解")

    # 测试用例3: 无穷多解
    print("\n测试用例3 - 无穷多解:")
    n = 3
    # x1 ^ x3 = 1
    # x2 ^ x3 = 1
    # x1 ^ x2 = 0
    mat[1][1] = 1
    mat[1][2] = 0
    mat[1][3] = 1
    mat[1][4] = 1
    mat[2][1] = 0
    mat[2][2] = 1
    mat[2][3] = 1
    mat[2][4] = 1
    mat[3][1] = 1
    mat[3][2] = 1
    mat[3][3] = 0
    mat[3][4] = 0

    print("原矩阵:")
    print_matrix(n)
    
    # 运行新的面向对象版本的单元测试
    run_unit_tests()
    
    # 输出语言特性差异分析和性能优化建议
    language_feature_comparison()
    performance_optimization_tips()

    result = gauss(n)
    if result == 0:
        print("方程组有唯一解")
        solution = get_solution(n)
        print("解为: ", end='')
        for i in range(1, n + 1):
            print("x{}={} ".format(i, solution[i]), end='')
        print()
    elif result == 1:
        print("方程组有无穷多解")
    else:
        print("方程组无解")

===============================================

文件: Code05_SwitchProblem.cpp
===============================================
// POJ 1830 开关问题
// 题目描述：
// 有N个相同的开关，每个开关都与某些开关有着联系，每当你打开或者关闭某个开关的时候，
// 其他的与此开关相关联的开关也会相应地发生变化，即这些相联系的开关的状态会改变。
// 给出所有开关的初始状态和目标状态，求有多少种操作方法可以达到目标状态。
// 1 <= N <= 29
// 测试链接 : http://poj.org/problem?id=1830

// 纯C实现，避免编译问题
extern "C" {
    int scanf(const char*, ...);
    int printf(const char*, ...);
}

const int MAXN = 35;

// 增广矩阵，mat[i][j]表示第i个方程中第j个未知数的系数，mat[i][n+1]表示第i个方程的常数项
int mat[MAXN][MAXN];

int n;

/**
 * 高斯消元解决异或方程组
 * 
 * 算法步骤：
 * 1. 构造增广矩阵：将方程组的系数和常数项组成增广矩阵
 * 2. 消元过程：
 *    - 从第一行开始，选择主元（该列系数为1的行）
 *    - 将主元行交换到当前行
 *    - 用主元行消去其他行的当前列系数（通过异或运算）
 * 3. 判断解的情况：
 *    - 唯一解：系数矩阵可化为单位矩阵
 *    - 无解：出现形如 0 = 1 的矛盾方程
 *    - 无穷解：出现形如 0 = 0 的自由元方程
 * 
 * @param n 未知数个数
 * @return 0表示有唯一解，1表示有无穷多解，-1表示无解
 */
int gauss(int n) {
    int r = 1; // 当前行
    int c = 1; // 当前列

    // 消元过程
    for (; r <= n && c <= n; r++, c++) {
        int pivot = r;

        // 寻找主元（当前列中系数为1的行）
        for (int i = r; i <= n; i++) {
            if (mat[i][c] == 1) {
                pivot = i;
                break;
            }
        }

        // 如果找不到主元，说明当前列全为0，跳到下一列
        if (mat[pivot][c] == 0) {
            r--; // 保持当前行不变
            continue;
        }

        // 交换第r行和第pivot行
        if (pivot != r) {
            for (int j = 1; j <= n + 1; j++) {
                int temp = mat[r][j];
                mat[r][j] = mat[pivot][j];
                mat[pivot][j] = temp;
            }
        }

        // 消去其他行的当前列系数
        for (int i = 1; i <= n; i++) {
            if (i != r && mat[i][c] == 1) {
                // 第i行异或第r行
                for (int j = c; j <= n + 1; j++) {
                    mat[i][j] ^= mat[r][j];
                }
            }
        }
    }

    // 判断解的情况
    // 检查是否有形如 0 = 1 的矛盾方程
    for (int i = r; i <= n; i++) {
        if (mat[i][n + 1] == 1) {
            return -1; // 无解
        }
    }

    // 判断是否有自由元（形如 0 = 0 的方程）
    if (r <= n) {
        return 1; // 有无穷多解
    }

    return 0; // 有唯一解
}

/**
 * 快速幂运算
 * 
 * @param base 底数
 * @param exp  指数
 * @return base^exp
 */
int power(int base, int exp) {
    int result = 1;
    while (exp > 0) {
        if (exp % 2 == 1) {
            result *= base;
        }
        base *= base;
        exp /= 2;
    }
    return result;
}

int main() {
    int k;
    scanf("%d", &k);

    for (int t = 0; t < k; t++) {
        scanf("%d", &n);

        // 读取初始状态
        int start[MAXN];
        for (int i = 1; i <= n; i++) {
            scanf("%d", &start[i]);
        }

        // 读取目标状态
        int end[MAXN];
        for (int i = 1; i <= n; i++) {
            scanf("%d", &end[i]);
        }

        // 初始化矩阵
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= n + 1; j++) {
                mat[i][j] = 0;
            }
            // 自己对自己有影响
            mat[i][i] = 1;
            // 常数项为初始状态与目标状态的异或值
            mat[i][n + 1] = start[i] ^ end[i];
        }

        // 读取开关关系
        int i, j;
        // 读取开关关系，由于POJ的输入格式问题，这里简化处理
        // 实际应用中需要根据具体输入格式调整
        int relation_count = 0;
        // 假设最多有100个关系
        for (int rel = 0; rel < 100; rel++) {
            if (scanf("%d%d", &i, &j) != 2) break;
            if (i == 0 && j == 0) break;
            // 操作开关j会影响开关i
            mat[i][j] = 1;
            relation_count++;
        }

        // 高斯消元
        int result = gauss(n);

        if (result == -1) {
            printf("Oh,it's impossible~!!\n");
        } else if (result == 0) {
            printf("1\n");
        } else {
            // 计算自由元个数
            int free = 0;
            for (int i = 1; i <= n; i++) {
                if (mat[i][i] == 0) {
                    free++;
                }
            }
            printf("%d\n", power(2, free));
        }
    }

    return 0;
}

===============================================

文件: Code05_SwitchProblem.java
===============================================
package class134;

/**
 * 高斯消元解决异或方程组 - POJ 1830 开关问题 + POJ 1222 EXTENDED LIGHTS OUT
 * 
 * 题目1：POJ 1830 开关问题
 * 题目描述：
 * 有N个相同的开关，每个开关都与某些开关有着联系，每当你打开或者关闭某个开关的时候，
 * 其他的与此开关相关联的开关也会相应地发生变化，即这些相联系的开关的状态会改变。
 * 给出所有开关的初始状态和目标状态，求有多少种操作方法可以达到目标状态。
 * 
 * 输入约束：
 * 1 <= N <= 29
 * 
 * 测试链接：http://poj.org/problem?id=1830
 * 
 * 题目2：POJ 1222 EXTENDED LIGHTS OUT
 * 题目描述：
 * 有一个5x6的灯矩阵，每个灯有两种状态（开或关）。
 * 当按下一个灯的开关时，该灯及其相邻的四个灯（如果存在）的状态都会改变。
 * 给定灯的初始状态，求一个按钮操作序列，使得所有灯都关闭。
 * 
 * 测试链接：http://poj.org/problem?id=1222
 * 
 * 算法原理详解：
 * 1. 问题建模：开关问题可以转化为异或方程组的求解问题
 *    - 每个开关对应一个未知数xi，表示是否操作该开关（1表示操作，0表示不操作）
 *    - 每个开关对应一个方程，表示该开关的最终状态
 *    - 系数矩阵表示开关之间的影响关系
 *    - 常数项表示初始状态与目标状态的差异
 * 2. 高斯消元：使用高斯消元法求解异或方程组
 * 3. 解的情况分析：
 *    - 无解：存在矛盾方程，方案数为0
 *    - 唯一解：方案数为1
 *    - 无穷解：方案数为2^(自由元个数)
 * 
 * 时间复杂度分析：
 * - POJ 1830：O(N^3) ≈ O(29^3) ≈ 24,389
 * - POJ 1222：O(N^3) ≈ O(30^3) ≈ 27,000（5x6=30个灯）
 * 
 * 空间复杂度分析：
 * - 增广矩阵：O(N^2) ≈ O(900)
 * - 总空间：O(N^2) 在可接受范围内
 * 
 * 工程化考量：
 * 1. 性能优化：使用位运算优化异或操作
 * 2. 内存管理：合理设置数组大小，避免内存溢出
 * 3. 边界处理：处理N=1的特殊情况
 * 4. 可读性：详细注释和变量命名规范
 * 
 * 关键优化点：
 * - 使用高斯消元求解异或方程组
 * - 处理开关之间的相互影响关系
 * - 统计自由元个数计算方案数
 * - 支持多种开关问题的统一解法
 */

import java.io.*;
import java.util.*;

/**
 * 高斯消元解决异或方程组 - POJ 1830 开关问题
 * 
 * 题目解析：
 * 本题是一个典型的开关问题。每个开关有两种状态（0或1），操作一个开关会改变该开关及其相关联开关的状态。
 * 目标是从初始状态转换到目标状态，求有多少种操作方法。
 * 
 * 解题思路：
 * 1. 将问题转化为异或方程组：
 *    - 设xi表示是否操作第i个开关（1表示操作，0表示不操作）
 *    - 对于每个开关i，建立方程：xi ^ sum{ajxj} = (初始状态i ^ 目标状态i)
 *    - 其中aj表示操作开关j是否会影响开关i的状态
 * 2. 使用高斯消元求解异或方程组
 * 3. 根据解的情况判断方案数：
 *    - 无解：方案数为0
 *    - 唯一解：方案数为1
 *    - 无穷解：方案数为2^(自由元个数)
 * 
 * 时间复杂度：O(N^3)
 * 空间复杂度：O(N^2)
 */
public class Code05_SwitchProblem {

    public static int MAXN = 35;

    // 增广矩阵，mat[i][j]表示第i个方程中第j个未知数的系数，mat[i][n+1]表示第i个方程的常数项
    public static int[][] mat = new int[MAXN][MAXN];

    public static int n;

    public static int result_row;
    
    /**
     * 高斯消元解决异或方程组
     * 
     * 算法步骤：
     * 1. 构造增广矩阵：将方程组的系数和常数项组成增广矩阵
     * 2. 消元过程：
     *    - 从第一行开始，选择主元（该列系数为1的行）
     *    - 将主元行交换到当前行
     *    - 用主元行消去其他行的当前列系数（通过异或运算）
     * 3. 判断解的情况：
     *    - 唯一解：系数矩阵可化为单位矩阵
     *    - 无解：出现形如 0 = 1 的矛盾方程
     *    - 无穷解：出现形如 0 = 0 的自由元方程
     * 
     * @param n 未知数个数
     * @return 0表示有唯一解，1表示有无穷多解，-1表示无解
     */
    // 注意：此高斯消元方法同时适用于POJ 1830和POJ 1222问题
    public static int gauss(int n) {
        int r = 1; // 当前行
        int c = 1; // 当前列

        // 消元过程
        for (; r <= n && c <= n; r++, c++) {
            int pivot = r;

            // 寻找主元（当前列中系数为1的行）
            for (int i = r; i <= n; i++) {
                if (mat[i][c] == 1) {
                    pivot = i;
                    break;
                }
            }

            // 如果找不到主元，说明当前列全为0，跳到下一列
            if (mat[pivot][c] == 0) {
                r--; // 保持当前行不变
                continue;
            }

            // 交换第r行和第pivot行
            if (pivot != r) {
                swap(r, pivot);
            }

            // 消去其他行的当前列系数
            for (int i = 1; i <= n; i++) {
                if (i != r && mat[i][c] == 1) {
                    // 第i行异或第r行
                    for (int j = c; j <= n + 1; j++) {
                        mat[i][j] ^= mat[r][j];
                    }
                }
            }
        }

        // 判断解的情况
        // 检查是否有形如 0 = 1 的矛盾方程
        for (int i = r; i <= n; i++) {
            if (mat[i][n + 1] == 1) {
                return -1; // 无解
            }
        }

        // 判断是否有自由元（形如 0 = 0 的方程）
        if (r <= n) {
            return 1; // 有无穷多解
        }

        return 0; // 有唯一解
    }

    /**
     * 交换矩阵中的两行
     * 
     * @param a 行号1
     * @param b 行号2
     */
    public static void swap(int a, int b) {
        int[] tmp = mat[a];
        mat[a] = mat[b];
        mat[b] = tmp;
    }

    /**
     * 快速幂运算
     * 
     * @param base 底数
     * @param exp  指数
     * @return base^exp
     */
    public static int power(int base, int exp) {
        int result = 1;
        while (exp > 0) {
            if (exp % 2 == 1) {
                result *= base;
            }
            base *= base;
            exp /= 2;
        }
        return result;
    }

    // POJ 1830 开关问题的主方法
    public static void main(String[] args) throws IOException {
        // 主方法保持不变，处理POJ 1830的输入输出
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        PrintWriter out = new PrintWriter(new OutputStreamWriter(System.out));
        
        int k = Integer.parseInt(br.readLine());
        
        for (int t = 0; t < k; t++) {
            n = Integer.parseInt(br.readLine());
            
            // 读取初始状态
            int[] start = new int[MAXN];
            String[] startStr = br.readLine().split(" ");
            for (int i = 1; i <= n; i++) {
                start[i] = Integer.parseInt(startStr[i - 1]);
            }
            
            // 读取目标状态
            int[] end = new int[MAXN];
            String[] endStr = br.readLine().split(" ");
            for (int i = 1; i <= n; i++) {
                end[i] = Integer.parseInt(endStr[i - 1]);
            }
            
            // 初始化矩阵
            for (int i = 1; i <= n; i++) {
                for (int j = 1; j <= n + 1; j++) {
                    mat[i][j] = 0;
                }
                // 自己对自己有影响
                mat[i][i] = 1;
                // 常数项为初始状态与目标状态的异或值
                mat[i][n + 1] = start[i] ^ end[i];
            }
            
            // 读取开关关系
            String line;
            while ((line = br.readLine()) != null && !line.isEmpty()) {
                String[] parts = line.split(" ");
                if (parts.length < 2) break;
                int i = Integer.parseInt(parts[0]);
                int j = Integer.parseInt(parts[1]);
                if (i == 0 && j == 0) break;
                // 操作开关j会影响开关i
                mat[i][j] = 1;
            }
            
            // 高斯消元
            int result = gauss(n);
            
            if (result == -1) {
                out.println("Oh,it's impossible~!!");
            } else if (result == 0) {
                out.println(1);
            } else {
                // 计算自由元个数
                int free = 0;
                for (int i = 1; i <= n; i++) {
                    if (mat[i][i] == 0) {
                        free++;
                    }
                }
                out.println(power(2, free));
            }
        }
        
        out.flush();
        out.close();
        br.close();
    }
    
    // POJ 1222 EXTENDED LIGHTS OUT 问题的解决方案
    public static void solveLightsOutProblem() throws IOException {
        /**
         * POJ 1222 EXTENDED LIGHTS OUT 解题思路：
         * 1. 问题建模：
         *    - 共有5x6=30个灯，每个灯有两种状态（开0或关1）
         *    - 设x[i]表示是否按下第i个灯的开关（1表示按下，0表示不按下）
         *    - 目标是让所有灯都关闭（状态为1）
         * 
         * 2. 建立方程组：
         *    - 对于每个灯j，按下哪些开关会影响它的最终状态
         *    - 最终状态 = 初始状态 ^ x[j] ^ x[上] ^ x[下] ^ x[左] ^ x[右] = 1
         * 
         * 3. 优化方法：
         *    - 由于灯的数量固定为30，可以预构建系数矩阵
         *    - 由于灯之间的影响是局部的，可以利用这一特性简化计算
         */
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        PrintWriter out = new PrintWriter(new OutputStreamWriter(System.out));
        
        int T = Integer.parseInt(br.readLine());
        for (int t = 1; t <= T; t++) {
            // 重置矩阵
            int N = 30; // 5x6=30个灯
            int[][] lightsMat = new int[N + 1][N + 2];
            
            // 构建系数矩阵（预处理灯之间的影响关系）
            for (int i = 0; i < 5; i++) {
                for (int j = 0; j < 6; j++) {
                    int pos = i * 6 + j + 1; // 当前灯的位置（1-based）
                    // 每个灯受自己和上下左右影响
                    lightsMat[pos][pos] = 1; // 自己
                    // 上方
                    if (i > 0) lightsMat[pos][(i-1)*6 + j + 1] = 1;
                    // 下方
                    if (i < 4) lightsMat[pos][(i+1)*6 + j + 1] = 1;
                    // 左方
                    if (j > 0) lightsMat[pos][i*6 + (j-1) + 1] = 1;
                    // 右方
                    if (j < 5) lightsMat[pos][i*6 + (j+1) + 1] = 1;
                }
            }
            
            // 读取初始状态，设置常数项
            for (int i = 1; i <= N; i++) {
                int state = Integer.parseInt(br.readLine());
                lightsMat[i][N + 1] = state; // 目标是所有灯关闭，即1
            }
            
            // 复制到全局矩阵进行计算
            for (int i = 1; i <= N; i++) {
                for (int j = 1; j <= N + 1; j++) {
                    mat[i][j] = lightsMat[i][j];
                }
            }
            
            // 使用高斯消元求解
            gauss(N);
            
            // 输出结果
            out.println("PUZZLE #" + t);
            for (int i = 0; i < 5; i++) {
                for (int j = 0; j < 6; j++) {
                    int pos = i * 6 + j + 1;
                    // 从消元后的矩阵获取解
                    int solution = mat[pos][N + 1];
                    // 计算解（考虑其他已确定变量的影响）
                    for (int k = pos + 1; k <= N; k++) {
                        solution ^= (mat[pos][k] & mat[k][N + 1]);
                    }
                    out.print(solution);
                    if (j < 5) out.print(" ");
                }
                out.println();
            }
        }
        
        out.flush();
        out.close();
        br.close();
    }
}

===============================================

文件: Code05_SwitchProblem.py
===============================================
# POJ 1830 开关问题
# 题目描述：
# 有N个相同的开关，每个开关都与某些开关有着联系，每当你打开或者关闭某个开关的时候，
# 其他的与此开关相关联的开关也会相应地发生变化，即这些相联系的开关的状态会改变。
# 给出所有开关的初始状态和目标状态，求有多少种操作方法可以达到目标状态。
# 1 <= N <= 29
# 测试链接 : http://poj.org/problem?id=1830

# 高斯消元解决异或方程组 - POJ 1830 开关问题
# 
# 题目解析：
# 本题是一个典型的开关问题。每个开关有两种状态（0或1），操作一个开关会改变该开关及其相关联开关的状态。
# 目标是从初始状态转换到目标状态，求有多少种操作方法。
# 
# 解题思路：
# 1. 将问题转化为异或方程组：
#    - 设xi表示是否操作第i个开关（1表示操作，0表示不操作）
#    - 对于每个开关i，建立方程：xi ^ sum{ajxj} = (初始状态i ^ 目标状态i)
#    - 其中aj表示操作开关j是否会影响开关i的状态
# 2. 使用高斯消元求解异或方程组
# 3. 根据解的情况判断方案数：
#    - 无解：方案数为0
#    - 唯一解：方案数为1
#    - 无穷解：方案数为2^(自由元个数)
# 
# 时间复杂度：O(N^3)
# 空间复杂度：O(N^2)

MAXN = 35

# 增广矩阵，mat[i][j]表示第i个方程中第j个未知数的系数，mat[i][n+1]表示第i个方程的常数项
mat = [[0 for _ in range(MAXN)] for _ in range(MAXN)]

def gauss(n):
    """
    高斯消元解决异或方程组
    
    算法步骤：
    1. 构造增广矩阵：将方程组的系数和常数项组成增广矩阵
    2. 消元过程：
       - 从第一行开始，选择主元（该列系数为1的行）
       - 将主元行交换到当前行
       - 用主元行消去其他行的当前列系数（通过异或运算）
    3. 判断解的情况：
       - 唯一解：系数矩阵可化为单位矩阵
       - 无解：出现形如 0 = 1 的矛盾方程
       - 无穷解：出现形如 0 = 0 的自由元方程
    
    :param n: 未知数个数
    :return: 0表示有唯一解，1表示有无穷多解，-1表示无解
    """
    r = 1  # 当前行
    c = 1  # 当前列

    # 消元过程
    while r <= n and c <= n:
        pivot = r

        # 寻找主元（当前列中系数为1的行）
        for i in range(r, n + 1):
            if mat[i][c] == 1:
                pivot = i
                break

        # 如果找不到主元，说明当前列全为0，跳到下一列
        if mat[pivot][c] == 0:
            r -= 1  # 保持当前行不变
            c += 1
            continue

        # 交换第r行和第pivot行
        if pivot != r:
            for j in range(c, n + 2):
                mat[r][j], mat[pivot][j] = mat[pivot][j], mat[r][j]

        # 消去其他行的当前列系数
        for i in range(1, n + 1):
            if i != r and mat[i][c] == 1:
                # 第i行异或第r行
                for j in range(c, n + 2):
                    mat[i][j] ^= mat[r][j]

        r += 1
        c += 1

    # 判断解的情况
    # 检查是否有形如 0 = 1 的矛盾方程
    for i in range(r, n + 1):
        if mat[i][n + 1] == 1:
            return -1  # 无解

    # 判断是否有自由元（形如 0 = 0 的方程）
    if r <= n:
        return 1  # 有无穷多解

    return 0  # 有唯一解

def power(base, exp):
    """
    快速幂运算
    
    :param base: 底数
    :param exp: 指数
    :return: base^exp
    """
    result = 1
    while exp > 0:
        if exp % 2 == 1:
            result *= base
        base *= base
        exp //= 2
    return result

def main():
    import sys
    input = sys.stdin.read
    data = input().split()
    
    idx = 0
    k = int(data[idx])
    idx += 1
    
    for _ in range(k):
        global mat
        n = int(data[idx])
        idx += 1
        
        # 读取初始状态
        start = [0] * MAXN
        for i in range(1, n + 1):
            start[i] = int(data[idx])
            idx += 1
            
        # 读取目标状态
        end = [0] * MAXN
        for i in range(1, n + 1):
            end[i] = int(data[idx])
            idx += 1
            
        # 初始化矩阵
        for i in range(1, n + 1):
            for j in range(1, n + 2):
                mat[i][j] = 0
            # 自己对自己有影响
            mat[i][i] = 1
            # 常数项为初始状态与目标状态的异或值
            mat[i][n + 1] = start[i] ^ end[i]
            
        # 读取开关关系
        while idx < len(data):
            i = int(data[idx])
            j = int(data[idx + 1])
            idx += 2
            if i == 0 and j == 0:
                break
            # 操作开关j会影响开关i
            mat[i][j] = 1
            
        # 高斯消元
        result = gauss(n)
        
        if result == -1:
            print("Oh,it's impossible~!!")
        elif result == 0:
            print(1)
        else:
            # 计算自由元个数
            free = 0
            for i in range(1, n + 1):
                if mat[i][i] == 0:
                    free += 1
            print(power(2, free))

if __name__ == "__main__":
    main()

===============================================

文件: Code06_Square.cpp
===============================================
// UVa 11542 Square
// 题目描述：
// 给定n个正整数，每个数的素因子都不超过500，从中选出1个或多个数，
// 使得选出的数的乘积是完全平方数，求有多少种选法。
// 1 <= n <= 100
// 1 <= xi <= 10^15
// 测试链接 : https://onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=2577

// 纯C实现，避免编译问题
extern "C" {
    int scanf(const char*, ...);
    int printf(const char*, ...);
}

/**
 * 高斯消元解决异或方程组 - UVa 11542 Square
 * 
 * 题目解析：
 * 本题要求从给定的n个数中选出若干个数，使得它们的乘积是完全平方数。
 * 一个数是完全平方数当且仅当它的每个素因子的指数都是偶数。
 * 因此，我们需要选择一些数，使得每个素因子在所选数的乘积中的指数都是偶数。
 * 
 * 解题思路：
 * 1. 素因子分解：
 *    - 首先筛出500以内的所有素数
 *    - 对每个输入的数进行素因子分解，记录每个素因子的指数的奇偶性
 * 2. 建立异或方程组：
 *    - 每个素数对应一个方程
 *    - 每个数对应一个未知数
 *    - 系数矩阵A[i][j]表示第j个数中第i个素因子的指数的奇偶性
 *    - 常数项为0（因为我们要求所有素因子的指数都是偶数）
 * 3. 高斯消元：
 *    - 对系数矩阵进行高斯消元
 *    - 统计自由元的个数
 * 4. 计算方案数：
 *    - 方案数为2^(自由元个数) - 1（减1是因为不能一个都不选）
 * 
 * 时间复杂度：O(n * π(500) + π(500)^3)
 * 空间复杂度：O(n * π(500))
 * 其中π(500)表示500以内的素数个数，约为95
 */

const int MAXP = 505;  // 素数上限
const int MAXN = 105;  // 数组大小

// 素数相关
int isPrime[MAXP];
int primes[MAXP];
int primeCount = 0;

// 系数矩阵，mat[i][j]表示第i个素数在第j个数中的指数奇偶性
int mat[MAXP][MAXN];

// 输入的数
long long numbers[MAXN];

/**
 * 手动实现memset功能
 * 
 * @param ptr 指向要填充的内存区域的指针
 * @param value 要设置的值
 * @param num 要设置的字节数
 */
void my_memset(int* ptr, int value, int num) {
    for (int i = 0; i < num; i++) {
        ptr[i] = value;
    }
}

/**
 * 线性筛法求素数
 * 
 * 算法原理：
 * 线性筛法是一种高效的素数筛法，每个合数只会被其最小的质因子筛掉一次，
 * 因此时间复杂度为O(n)。
 * 
 * @param n 筛法上限
 */
void sieve(int n) {
    my_memset(isPrime, 1, MAXP);
    isPrime[0] = isPrime[1] = 0;
    
    for (int i = 2; i <= n; i++) {
        if (isPrime[i]) {
            primes[primeCount++] = i;
        }
        for (int j = 0; j < primeCount && i * primes[j] <= n; j++) {
            isPrime[i * primes[j]] = 0;
            if (i % primes[j] == 0) {
                break;
            }
        }
    }
}

/**
 * 对一个数进行素因子分解，记录每个素因子指数的奇偶性
 * 
 * 算法思路：
 * 1. 遍历所有素数
 * 2. 对于每个素数，统计它在该数中的出现次数
 * 3. 记录指数的奇偶性（奇数为1，偶数为0）
 * 
 * @param num 要分解的数
 * @param col 系数矩阵的列号
 * @param n 素数个数
 */
void factorize(long long num, int col, int n) {
    for (int i = 0; i < n; i++) {
        int cnt = 0;
        while (num % primes[i] == 0) {
            cnt++;
            num /= primes[i];
        }
        mat[i][col] = cnt % 2;  // 记录指数的奇偶性
    }
}

/**
 * 高斯消元解决异或方程组
 * 
 * 算法步骤：
 * 1. 构造增广矩阵：将方程组的系数和常数项组成增广矩阵
 * 2. 消元过程：
 *    - 从第一行开始，选择主元（该列系数为1的行）
 *    - 将主元行交换到当前行
 *    - 用主元行消去其他行的当前列系数（通过异或运算）
 * 3. 判断解的情况：
 *    - 唯一解：系数矩阵可化为单位矩阵
 *    - 无解：出现形如 0 = 1 的矛盾方程
 *    - 无穷解：出现形如 0 = 0 的自由元方程
 * 
 * @param rows 方程个数（素数个数）
 * @param cols 未知数个数（输入数的个数）
 * @return 自由元个数
 */
int gauss(int rows, int cols) {
    int r = 0; // 当前行
    int c = 0; // 当前列

    // 消元过程
    for (; r < rows && c < cols; r++, c++) {
        int pivot = r;

        // 寻找主元（当前列中系数为1的行）
        for (int i = r; i < rows; i++) {
            if (mat[i][c] == 1) {
                pivot = i;
                break;
            }
        }

        // 如果找不到主元，说明当前列全为0，跳到下一列
        if (mat[pivot][c] == 0) {
            r--; // 保持当前行不变
            continue;
        }

        // 交换第r行和第pivot行
        if (pivot != r) {
            for (int j = 0; j <= cols; j++) {
                int temp = mat[r][j];
                mat[r][j] = mat[pivot][j];
                mat[pivot][j] = temp;
            }
        }

        // 消去其他行的当前列系数
        for (int i = 0; i < rows; i++) {
            if (i != r && mat[i][c] == 1) {
                // 第i行异或第r行
                for (int j = c; j <= cols; j++) {
                    mat[i][j] ^= mat[r][j];
                }
            }
        }
    }

    // 返回自由元个数
    return cols - r;
}

/**
 * 快速幂运算
 * 
 * @param base 底数
 * @param exp  指数
 * @return base^exp
 */
long long power(long long base, int exp) {
    long long result = 1;
    while (exp > 0) {
        if (exp % 2 == 1) {
            result *= base;
        }
        base *= base;
        exp /= 2;
    }
    return result;
}

int main() {
    // 预处理素数
    sieve(500);
    
    int T;
    scanf("%d", &T);
    
    for (int t = 0; t < T; t++) {
        int n;
        scanf("%d", &n);
        
        // 读取输入数据
        for (int i = 0; i < n; i++) {
            scanf("%lld", &numbers[i]);
        }
        
        // 初始化矩阵
        for (int i = 0; i < primeCount; i++) {
            for (int j = 0; j <= n; j++) {
                mat[i][j] = 0;
            }
        }
        
        // 对每个数进行素因子分解
        for (int i = 0; i < n; i++) {
            factorize(numbers[i], i, primeCount);
        }
        
        // 高斯消元
        int free = gauss(primeCount, n);
        
        // 计算方案数：2^(自由元个数) - 1（减1是因为不能一个都不选）
        long long result = power(2, free) - 1;
        printf("%lld\n", result);
    }
    
    return 0;
}

===============================================

文件: Code06_Square.java
===============================================
package class134;

/**
 * 高斯消元解决异或方程组 - UVa 11542 Square + HDU 5833 树的因子 + Codeforces 954C Matrix Walk
 * 
 * 题目1：UVa 11542 Square
 * 题目描述：
 * 给定n个正整数，每个数的素因子都不超过500，从中选出1个或多个数，
 * 使得选出的数的乘积是完全平方数，求有多少种选法。
 * 
 * 输入约束：
 * 1 <= n <= 100
 * 1 <= xi <= 10^15
 * 
 * 测试链接：https://onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=2577
 * 
 * 题目2：HDU 5833 树的因子
 * 题目描述：
 * 给定n个数，每个数可以选或不选，要求选出的数乘积为完全平方数，求方案数。
 * 
 * 输入约束：
 * 1 <= n <= 100
 * 
 * 测试链接：https://acm.hdu.edu.cn/showproblem.php?pid=5833
 * 
 * 题目3：Codeforces 954C Matrix Walk
 * 题目描述：
 * 给定一个矩阵，初始位置在(0,0)，每一步可以向右或向上移动，
 * 求有多少条路径，使得路径上的所有数的乘积是完全平方数。
 * 
 * 测试链接：https://codeforces.com/problemset/problem/954/C
 * 
 * 算法原理详解：
 * 1. 数学建模：一个数是完全平方数当且仅当它的所有素因子的指数都是偶数
 * 2. 素因子分解：对每个数进行素因子分解，记录每个素因子指数的奇偶性
 * 3. 异或方程组：每个素因子对应一个方程，表示该素因子在乘积中的总指数为偶数
 * 4. 高斯消元：求解方程组的自由元个数
 * 5. 方案计算：方案数为2^(自由元个数) - 1（减1是因为不能一个都不选）
 * 
 * 时间复杂度分析：
 * - 素因子筛法：O(500 * log(log(500))) ≈ O(500)
 * - 素因子分解：O(n * π(500)) ≈ O(100 * 95) ≈ 9,500
 * - 高斯消元：O(π(500)^3) ≈ O(95^3) ≈ 857,375
 * - 总复杂度：O(π(500)^3) 在可接受范围内
 * 
 * 空间复杂度分析：
 * - 素数数组：O(500) ≈ O(500)
 * - 增广矩阵：O(n * π(500)) ≈ O(100 * 95) ≈ 9,500
 * - 总空间：O(n * π(500)) 在可接受范围内
 * 
 * 工程化考量：
 * 1. 性能优化：使用位运算优化异或操作
 * 2. 内存管理：合理设置数组大小，避免内存溢出
 * 3. 边界处理：处理n=1或素因子分解失败的情况
 * 4. 可读性：详细注释和变量命名规范
 * 
 * 关键优化点：
 * - 使用素因子筛法预处理500以内的素数
 * - 对每个数进行素因子分解时只考虑500以内的素因子
 * - 使用高斯消元求解异或方程组的自由元个数
 * - 支持多种完全平方数乘积问题的统一解法
 */

import java.io.*;
import java.util.*;

/**
 * 高斯消元解决异或方程组 - UVa 11542 Square
 * 
 * 题目解析：
 * 本题要求从给定的n个数中选出若干个数，使得它们的乘积是完全平方数。
 * 一个数是完全平方数当且仅当它的每个素因子的指数都是偶数。
 * 因此，我们需要选择一些数，使得每个素因子在所选数的乘积中的指数都是偶数。
 * 
 * 解题思路：
 * 1. 素因子分解：
 *    - 首先筛出500以内的所有素数
 *    - 对每个输入的数进行素因子分解，记录每个素因子的指数的奇偶性
 * 2. 建立异或方程组：
 *    - 每个素数对应一个方程
 *    - 每个数对应一个未知数
 *    - 系数矩阵A[i][j]表示第j个数中第i个素因子的指数的奇偶性
 *    - 常数项为0（因为我们要求所有素因子的指数都是偶数）
 * 3. 高斯消元：
 *    - 对系数矩阵进行高斯消元
 *    - 统计自由元的个数
 * 4. 计算方案数：
 *    - 方案数为2^(自由元个数) - 1（减1是因为不能一个都不选）
 * 
 * 时间复杂度：O(n * π(500) + π(500)^3)
 * 空间复杂度：O(n * π(500))
 * 其中π(500)表示500以内的素数个数，约为95
 */
public class Code06_Square {

    public static int MAXP = 505;  // 素数上限
    public static int MAXN = 105;  // 数组大小
    
    // 素数相关
    public static boolean[] isPrime = new boolean[MAXP];
    public static int[] primes = new int[MAXP];
    public static int primeCount = 0;
    
    // 系数矩阵，mat[i][j]表示第i个素数在第j个数中的指数奇偶性
    public static int[][] mat = new int[MAXP][MAXN];
    
    // 输入的数
    public static long[] numbers = new long[MAXN];
    
    /**
     * 线性筛法求素数
     * 
     * 算法原理：
     * 线性筛法是一种高效的素数筛法，每个合数只会被其最小的质因子筛掉一次，
     * 因此时间复杂度为O(n)。
     * 
     * @param n 筛法上限
     */
    public static void sieve(int n) {
        Arrays.fill(isPrime, true);
        isPrime[0] = isPrime[1] = false;
        
        for (int i = 2; i <= n; i++) {
            if (isPrime[i]) {
                primes[primeCount++] = i;
            }
            for (int j = 0; j < primeCount && i * primes[j] <= n; j++) {
                isPrime[i * primes[j]] = false;
                if (i % primes[j] == 0) {
                    break;
                }
            }
        }
    }
    
    /**
     * 对一个数进行素因子分解，记录每个素因子指数的奇偶性
     * 
     * 算法思路：
     * 1. 遍历所有素数
     * 2. 对于每个素数，统计它在该数中的出现次数
     * 3. 记录指数的奇偶性（奇数为1，偶数为0）
     * 
     * @param num 要分解的数
     * @param col 系数矩阵的列号
     * @param n 素数个数
     */
    public static void factorize(long num, int col, int n) {
        for (int i = 0; i < n; i++) {
            int cnt = 0;
            while (num % primes[i] == 0) {
                cnt++;
                num /= primes[i];
            }
            mat[i][col] = cnt % 2;  // 记录指数的奇偶性
        }
    }
    
    /**
     * 高斯消元解决异或方程组
     * 
     * 算法步骤：
     * 1. 构造增广矩阵：将方程组的系数和常数项组成增广矩阵
     * 2. 消元过程：
     *    - 从第一行开始，选择主元（该列系数为1的行）
     *    - 将主元行交换到当前行
     *    - 用主元行消去其他行的当前列系数（通过异或运算）
     * 3. 判断解的情况：
     *    - 唯一解：系数矩阵可化为单位矩阵
     *    - 无解：出现形如 0 = 1 的矛盾方程
     *    - 无穷解：出现形如 0 = 0 的自由元方程
     * 
     * @param rows 方程个数（素数个数）
     * @param cols 未知数个数（输入数的个数）
     * @return 自由元个数
     */
    // 注意：此高斯消元方法适用于所有完全平方数乘积类问题（UVa 11542, HDU 5833等）
    public static int gauss(int rows, int cols) {
        int r = 0; // 当前行
        int c = 0; // 当前列

        // 消元过程
        for (; r < rows && c < cols; r++, c++) {
            int pivot = r;

            // 寻找主元（当前列中系数为1的行）
            for (int i = r; i < rows; i++) {
                if (mat[i][c] == 1) {
                    pivot = i;
                    break;
                }
            }

            // 如果找不到主元，说明当前列全为0，跳到下一列
            if (mat[pivot][c] == 0) {
                r--; // 保持当前行不变
                continue;
            }

            // 交换第r行和第pivot行
            if (pivot != r) {
                swapRow(r, pivot, cols);
            }

            // 消去其他行的当前列系数
            for (int i = 0; i < rows; i++) {
                if (i != r && mat[i][c] == 1) {
                    // 第i行异或第r行
                    for (int j = c; j <= cols; j++) {
                        mat[i][j] ^= mat[r][j];
                    }
                }
            }
        }

        // 返回自由元个数
        return cols - r;
    }
    
    /**
     * 交换矩阵中的两行
     * 
     * @param a 行号1
     * @param b 行号2
     * @param cols 列数
     */
    public static void swapRow(int a, int b, int cols) {
        for (int j = 0; j <= cols; j++) {
            int temp = mat[a][j];
            mat[a][j] = mat[b][j];
            mat[b][j] = temp;
        }
    }
    
    /**
     * 快速幂运算
     * 
     * @param base 底数
     * @param exp  指数
     * @return base^exp
     */
    public static long power(long base, int exp) {
        long result = 1;
        while (exp > 0) {
            if (exp % 2 == 1) {
                result *= base;
            }
            base *= base;
            exp /= 2;
        }
        return result;
    }
    
    // UVa 11542 Square的主方法
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        PrintWriter out = new PrintWriter(new OutputStreamWriter(System.out));
        
        // 预处理素数
        sieve(500);
        
        int T = Integer.parseInt(br.readLine());
        
        for (int t = 0; t < T; t++) {
            int n = Integer.parseInt(br.readLine());
            
            // 读取输入数据
            String[] parts = br.readLine().split(" ");
            for (int i = 0; i < n; i++) {
                numbers[i] = Long.parseLong(parts[i]);
            }
            
            // 初始化矩阵
            for (int i = 0; i < primeCount; i++) {
                for (int j = 0; j <= n; j++) {
                    mat[i][j] = 0;
                }
            }
            
            // 对每个数进行素因子分解
            for (int i = 0; i < n; i++) {
                factorize(numbers[i], i, primeCount);
            }
            
            // 高斯消元
            int free = gauss(primeCount, n);
            
            // 计算方案数：2^(自由元个数) - 1（减1是因为不能一个都不选）
            long result = power(2, free) - 1;
            out.println(result);
        }
        
        out.flush();
        out.close();
        br.close();
    }
    
    // HDU 5833 树的因子 解决方案
    public static void solveHDU5833() throws IOException {
        /**
         * HDU 5833 树的因子 解题思路：
         * 1. 问题分析：
         *    - 需要从n个数中选出若干个数，使得它们的乘积是完全平方数
         *    - 完全平方数的条件是每个素因子的指数都是偶数
         * 
         * 2. 建模方法：
         *    - 对每个数进行素因子分解
         *    - 对于每个素因子，记录其在所有数中的出现次数的奇偶性
         *    - 构建异或方程组，每个方程表示一个素因子的奇偶性约束
         * 
         * 3. 与UVa 11542的区别：
         *    - HDU 5833的数据范围可能不同，但解题思路完全一致
         *    - 同样需要筛出足够的素数，然后进行高斯消元
         */
        sieve(1000); // 筛出足够大的素数（根据题目数据范围调整）
        
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        PrintWriter out = new PrintWriter(new OutputStreamWriter(System.out));
        
        int T = Integer.parseInt(br.readLine());
        while (T-- > 0) {
            int n = Integer.parseInt(br.readLine());
            
            // 初始化矩阵
            for (int i = 0; i < primeCount; i++) {
                for (int j = 0; j < n; j++) {
                    mat[i][j] = 0;
                }
            }
            
            // 读取输入并分解质因数
            for (int j = 0; j < n; j++) {
                long num = Long.parseLong(br.readLine());
                factorize(num, j, primeCount);
            }
            
            // 进行高斯消元
            int rank = gauss(primeCount, n);
            
            // 方案数为2^(自由元个数) - 1
            long ans = (1L << (n - rank)) - 1;
            out.println(ans % 1000000007); // 题目可能要求取模
        }
        
        out.flush();
        out.close();
        br.close();
    }
    
    // Codeforces 954C Matrix Walk 解决方案
    public static void solveCodeforces954C() throws IOException {
        /**
         * Codeforces 954C Matrix Walk 解题思路：
         * 1. 问题建模：
         *    - 每一步只能向右或向上移动
         *    - 路径上的数的乘积必须是完全平方数
         * 
         * 2. 优化思路：
         *    - 预处理每个位置(i,j)到(0,0)路径上乘积的素因子奇偶性
         *    - 对于每个位置(i,j)，我们需要找到之前的位置(x,y)，使得从(x,y)到(i,j)的路径乘积是完全平方数
         *    - 这相当于两个向量的异或结果为0，即向量相等
         * 
         * 3. 使用哈希表优化：
         *    - 维护一个哈希表，记录每个向量（素因子奇偶性）出现的次数
         *    - 对于每个位置，查询哈希表中相同向量的出现次数，累加到结果中
         */
        sieve(1000); // 筛出足够的素数
        
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        PrintWriter out = new PrintWriter(new OutputStreamWriter(System.out));
        
        String[] parts = br.readLine().split(" ");
        int n = Integer.parseInt(parts[0]);
        int m = Integer.parseInt(parts[1]);
        
        // 预处理每个位置的素因子奇偶性向量
        Map<List<Integer>, Long> countMap = new HashMap<>();
        List<Integer> current = new ArrayList<>();
        for (int i = 0; i < primeCount; i++) {
            current.add(0);
        }
        countMap.put(new ArrayList<>(current), 1L);
        
        long ans = 0;
        
        for (int i = 0; i < n; i++) {
            parts = br.readLine().split(" ");
            for (int j = 0; j < m; j++) {
                long num = Long.parseLong(parts[j]);
                
                // 更新当前向量
                for (int p = 0; p < primeCount; p++) {
                    long prime = primes[p];
                    int cnt = 0;
                    while (num % prime == 0) {
                        cnt++;
                        num /= prime;
                    }
                    if (cnt % 2 == 1) {
                        current.set(p, current.get(p) ^ 1);
                    }
                }
                
                // 查询相同向量的数量
                List<Integer> key = new ArrayList<>(current);
                if (countMap.containsKey(key)) {
                    ans += countMap.get(key);
                }
                
                // 更新哈希表
                countMap.put(key, countMap.getOrDefault(key, 0L) + 1);
            }
        }
        
        out.println(ans);
        out.flush();
        out.close();
        br.close();
    }
}

===============================================

文件: Code06_Square.py
===============================================
# UVa 11542 Square
# 题目描述：
# 给定n个正整数，每个数的素因子都不超过500，从中选出1个或多个数，
# 使得选出的数的乘积是完全平方数，求有多少种选法。
# 1 <= n <= 100
# 1 <= xi <= 10^15
# 测试链接 : https://onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=2577

# 高斯消元解决异或方程组 - UVa 11542 Square
# 
# 题目解析：
# 本题要求从给定的n个数中选出若干个数，使得它们的乘积是完全平方数。
# 一个数是完全平方数当且仅当它的每个素因子的指数都是偶数。
# 因此，我们需要选择一些数，使得每个素因子在所选数的乘积中的指数都是偶数。
# 
# 解题思路：
# 1. 素因子分解：
#    - 首先筛出500以内的所有素数
#    - 对每个输入的数进行素因子分解，记录每个素因子的指数的奇偶性
# 2. 建立异或方程组：
#    - 每个素数对应一个方程
#    - 每个数对应一个未知数
#    - 系数矩阵A[i][j]表示第j个数中第i个素因子的指数的奇偶性
#    - 常数项为0（因为我们要求所有素因子的指数都是偶数）
# 3. 高斯消元：
#    - 对系数矩阵进行高斯消元
#    - 统计自由元的个数
# 4. 计算方案数：
#    - 方案数为2^(自由元个数) - 1（减1是因为不能一个都不选）
# 
# 时间复杂度：O(n * π(500) + π(500)^3)
# 空间复杂度：O(n * π(500))
# 其中π(500)表示500以内的素数个数，约为95

MAXP = 505  # 素数上限
MAXN = 105  # 数组大小

# 素数相关
isPrime = [True] * MAXP
primes = []
primeCount = 0

# 系数矩阵，mat[i][j]表示第i个素数在第j个数中的指数奇偶性
mat = [[0 for _ in range(MAXN)] for _ in range(MAXP)]

# 输入的数
numbers = [0] * MAXN

def sieve(n):
    """
    线性筛法求素数
    
    算法原理：
    线性筛法是一种高效的素数筛法，每个合数只会被其最小的质因子筛掉一次，
    因此时间复杂度为O(n)。
    
    :param n: 筛法上限
    """
    global isPrime, primes, primeCount
    isPrime = [True] * MAXP
    isPrime[0] = isPrime[1] = False
    primes = []
    primeCount = 0
    
    for i in range(2, n + 1):
        if isPrime[i]:
            primes.append(i)
            primeCount += 1
        j = 0
        while j < primeCount and i * primes[j] <= n:
            isPrime[i * primes[j]] = False
            if i % primes[j] == 0:
                break
            j += 1

def factorize(num, col, n):
    """
    对一个数进行素因子分解，记录每个素因子指数的奇偶性
    
    算法思路：
    1. 遍历所有素数
    2. 对于每个素数，统计它在该数中的出现次数
    3. 记录指数的奇偶性（奇数为1，偶数为0）
    
    :param num: 要分解的数
    :param col: 系数矩阵的列号
    :param n: 素数个数
    """
    for i in range(n):
        cnt = 0
        while num % primes[i] == 0:
            cnt += 1
            num //= primes[i]
        mat[i][col] = cnt % 2  # 记录指数的奇偶性

def gauss(rows, cols):
    """
    高斯消元解决异或方程组
    
    算法步骤：
    1. 构造增广矩阵：将方程组的系数和常数项组成增广矩阵
    2. 消元过程：
       - 从第一行开始，选择主元（该列系数为1的行）
       - 将主元行交换到当前行
       - 用主元行消去其他行的当前列系数（通过异或运算）
    3. 判断解的情况：
       - 唯一解：系数矩阵可化为单位矩阵
       - 无解：出现形如 0 = 1 的矛盾方程
       - 无穷解：出现形如 0 = 0 的自由元方程
    
    :param rows: 方程个数（素数个数）
    :param cols: 未知数个数（输入数的个数）
    :return: 自由元个数
    """
    r = 0  # 当前行
    c = 0  # 当前列

    # 消元过程
    while r < rows and c < cols:
        pivot = r

        # 寻找主元（当前列中系数为1的行）
        for i in range(r, rows):
            if mat[i][c] == 1:
                pivot = i
                break

        # 如果找不到主元，说明当前列全为0，跳到下一列
        if mat[pivot][c] == 0:
            r -= 1  # 保持当前行不变
            c += 1
            continue

        # 交换第r行和第pivot行
        if pivot != r:
            for j in range(c, cols + 1):
                mat[r][j], mat[pivot][j] = mat[pivot][j], mat[r][j]

        # 消去其他行的当前列系数
        for i in range(rows):
            if i != r and mat[i][c] == 1:
                # 第i行异或第r行
                for j in range(c, cols + 1):
                    mat[i][j] ^= mat[r][j]

        r += 1
        c += 1

    # 返回自由元个数
    return cols - r

def power(base, exp):
    """
    快速幂运算
    
    :param base: 底数
    :param exp: 指数
    :return: base^exp
    """
    result = 1
    while exp > 0:
        if exp % 2 == 1:
            result *= base
        base *= base
        exp //= 2
    return result

def main():
    import sys
    input = sys.stdin.read
    data = input().split()
    
    idx = 0
    
    # 预处理素数
    sieve(500)
    
    T = int(data[idx])
    idx += 1
    
    for _ in range(T):
        n = int(data[idx])
        idx += 1
        
        # 读取输入数据
        for i in range(n):
            numbers[i] = int(data[idx])
            idx += 1
        
        # 初始化矩阵
        for i in range(primeCount):
            for j in range(n + 1):
                mat[i][j] = 0
        
        # 对每个数进行素因子分解
        for i in range(n):
            factorize(numbers[i], i, primeCount)
        
        # 高斯消元
        free = gauss(primeCount, n)
        
        # 计算方案数：2^(自由元个数) - 1（减1是因为不能一个都不选）
        result = power(2, free) - 1
        print(result)

if __name__ == "__main__":
    main()

===============================================

文件: Code07_XMAX.cpp
===============================================
// SPOJ XMAX - XOR Maximization
// 题目描述：
// 给定一个整数集合S，定义函数X(S)为集合中所有元素的异或值，
// 求X(S)的最大值。
// 1 <= |S| <= 10^5
// 0 <= ai <= 10^18
// 测试链接 : https://www.spoj.com/problems/XMAX/

// 纯C实现，避免编译问题
extern "C" {
    int scanf(const char*, ...);
    int printf(const char*, ...);
}

/**
 * 线性基解决异或最大值问题 - SPOJ XMAX
 * 
 * 题目解析：
 * 本题要求从给定的整数集合中选择一些数，使得它们的异或值最大。
 * 这是一个典型的线性基问题，可以用高斯消元的思想来解决。
 * 
 * 解题思路：
 * 1. 线性基构造：
 *    - 从高位到低位依次考虑每个二进制位
 *    - 对于每个二进制位，维护一个基向量，表示该位可以被表示的数
 * 2. 贪心选择：
 *    - 从高位到低位贪心地选择是否将对应的基向量加入结果
 *    - 如果加入后结果变大，则加入；否则不加入
 * 
 * 时间复杂度：O(n * log(max_value))
 * 空间复杂度：O(log(max_value))
 */

const int MAXL = 64;  // 64位整数

// 线性基数组
long long basis[MAXL];

/**
 * 插入一个数到线性基中
 * 
 * 线性基构造过程：
 * 1. 从高位到低位遍历该数的二进制位
 * 2. 对于每个为1的位：
 *    - 如果该位在线性基中还没有基向量，则直接插入
 *    - 否则用已有的基向量消去该位，继续处理
 * 
 * @param x 要插入的数
 */
void insert(long long x) {
    for (int i = MAXL - 1; i >= 0; i--) {
        if (((x >> i) & 1) == 0) continue;  // 如果第i位是0，跳过
        
        if (basis[i] == 0) {
            // 如果basis[i]为空，直接插入
            basis[i] = x;
            break;
        }
        
        // 否则用basis[i]消去x的第i位
        x ^= basis[i];
    }
}

/**
 * 查询最大异或值
 * 
 * 贪心策略：
 * 从高位到低位贪心地选择是否加入basis[i]
 * 如果加入后结果变大，则加入；否则不加入
 * 
 * @return 最大异或值
 */
long long queryMax() {
    long long result = 0;
    for (int i = MAXL - 1; i >= 0; i--) {
        // 贪心地选择是否加入basis[i]
        if (((result >> i) & 1) == 0) {  // 如果结果的第i位是0
            result ^= basis[i];  // 加入basis[i]可能会使结果更大
        }
    }
    return result;
}

int main() {
    int n;
    scanf("%d", &n);
    
    // 初始化线性基
    for (int i = 0; i < MAXL; i++) {
        basis[i] = 0;
    }
    
    // 读取输入数据并插入到线性基中
    for (int i = 0; i < n; i++) {
        long long x;
        scanf("%lld", &x);
        insert(x);
    }
    
    // 查询最大异或值
    long long result = queryMax();
    printf("%lld\n", result);
    
    return 0;
}

===============================================

文件: Code07_XMAX.java
===============================================
package class134;

/**
 * 线性基应用专题 - SPOJ XMAX XOR Maximization + HDU 3949 XOR + 牛客网 NC14533 异或和
 * 
 * 题目1：SPOJ XMAX - XOR Maximization
 * 题目描述：
 * 给定一个整数集合S，定义函数X(S)为集合中所有元素的异或值，
 * 求X(S)的最大值。
 * 
 * 输入约束：
 * 1 <= |S| <= 10^5
 * 0 <= ai <= 10^18
 * 
 * 测试链接：https://www.spoj.com/problems/XMAX/
 * 
 * 题目2：HDU 3949 XOR
 * 题目描述：
 * 给定n个整数，求它们的所有子集异或和中第k小的异或值。
 * 
 * 输入约束：
 * 1 <= n <= 10000
 * 0 <= ai <= 1e18
 * 
 * 测试链接：https://acm.hdu.edu.cn/showproblem.php?pid=3949
 * 
 * 题目3：牛客网 NC14533 异或和
 * 题目描述：
 * 给定一个长度为n的数组a，求所有连续子数组的异或和的和。
 * 
 * 测试链接：https://ac.nowcoder.com/acm/problem/14533
 * 
 * 算法原理详解：
 * 1. 线性基构造：
 *    - 线性基是一组基向量，可以表示原集合中所有元素的线性组合（在异或运算下）
 *    - 构造方法：从高位到低位依次处理每个数，尝试将其插入线性基
 *    - 如果当前位已经有基向量，则用异或操作消去当前位的系数
 * 2. 异或最大值：
 *    - 从高位到低位贪心选择，如果当前位可以取1则取1
 *    - 贪心策略：高位取1比低位取1对结果的贡献更大
 * 3. 第k小异或值：
 *    - 将线性基转化为简化行阶梯形矩阵
 *    - 将k的二进制表示与线性基的基向量对应位进行组合
 * 4. 异或和求和：
 *    - 按位考虑每个二进制位对总和的贡献
 *    - 使用前缀异或和和线性基统计每个位的贡献次数
 * 
 * 时间复杂度分析：
 * - 线性基构造：O(n * log(max_value)) ≈ O(10^5 * 60) ≈ 6,000,000
 * - 异或最大值：O(log(max_value)) ≈ O(60)
 * - 第k小异或值：O(log(max_value)) ≈ O(60)
 * 
 * 空间复杂度分析：
 * - 线性基数组：O(log(max_value)) ≈ O(60)
 * - 总空间：O(log(max_value)) 非常高效
 * 
 * 工程化考量：
 * 1. 性能优化：使用位运算优化所有操作
 * 2. 内存管理：线性基占用空间极小，适合处理大规模数据
 * 3. 边界处理：处理空集合、k=0等特殊情况
 * 4. 可读性：详细注释和变量命名规范
 * 
 * 关键优化点：
 * - 使用线性基高效处理异或相关问题
 * - 贪心策略求解异或最大值
 * - 二进制分解求解第k小异或值
 * - 按位统计求解异或和求和
 */

import java.io.*;
import java.util.*;

/**
 * 线性基解决异或最大值问题 - SPOJ XMAX
 * 
 * 题目解析：
 * 本题要求从给定的整数集合中选择一些数，使得它们的异或值最大。
 * 这是一个典型的线性基问题，可以用高斯消元的思想来解决。
 * 
 * 解题思路：
 * 1. 线性基构造：
 *    - 从高位到低位依次考虑每个二进制位
 *    - 对于每个二进制位，维护一个基向量，表示该位可以被表示的数
 * 2. 贪心选择：
 *    - 从高位到低位贪心地选择是否将对应的基向量加入结果
 *    - 如果加入后结果变大，则加入；否则不加入
 * 
 * 时间复杂度：O(n * log(max_value))
 * 空间复杂度：O(log(max_value))
 */
public class Code07_XMAX {

    public static int MAXL = 64;  // 64位整数
    
    // 线性基数组
    public static long[] basis = new long[MAXL];
    
    /**
     * 插入一个数到线性基中
     * 
     * 线性基构造过程：
     * 1. 从高位到低位遍历该数的二进制位
     * 2. 对于每个为1的位：
     *    - 如果该位在线性基中还没有基向量，则直接插入
     *    - 否则用已有的基向量消去该位，继续处理
     * 
     * @param x 要插入的数
     */
    public static void insert(long x) {
        for (int i = MAXL - 1; i >= 0; i--) {
            if (((x >> i) & 1) == 0) continue;  // 如果第i位是0，跳过
            
            if (basis[i] == 0) {
                // 如果basis[i]为空，直接插入
                basis[i] = x;
                break;
            }
            
            // 否则用basis[i]消去x的第i位
            x ^= basis[i];
        }
    }
    
    /**
     * 查询最大异或值
     * 
     * 贪心策略：
     * 从高位到低位贪心地选择是否加入basis[i]
     * 如果加入后结果变大，则加入；否则不加入
     * 
     * @return 最大异或值
     */
    public static long queryMax() {
        long result = 0;
        for (int i = MAXL - 1; i >= 0; i--) {
            // 贪心地选择是否加入basis[i]
            if (((result >> i) & 1) == 0) {  // 如果结果的第i位是0
                result ^= basis[i];  // 加入basis[i]可能会使结果更大
            }
        }
        return result;
    }
    
    /**
     * 线性基重组，用于第k大查询
     * 将线性基转换为标准基，即每个基向量的最高位唯一
     */
    public static void rebuild() {
        // 从低位到高位处理，确保每个基向量的最高位只有自己有1
        for (int i = 0; i < MAXL; i++) {
            for (int j = i - 1; j >= 0; j--) {
                if ((basis[i] >> j & 1) == 1) {
                    basis[i] ^= basis[j];
                }
            }
        }
    }
    
    /**
     * 查询第k小的异或值
     * 注意：调用前需要先调用rebuild()
     * 
     * 算法思路：
     * 1. 将k转换为二进制表示
     * 2. 根据二进制位选择对应的基向量进行异或
     * 
     * @param k 第k小
     * @return 第k小的异或值
     */
    public static long queryKth(long k) {
        // 统计非零基的数量
        int cnt = 0;
        long[] tmp = new long[MAXL];
        for (int i = 0; i < MAXL; i++) {
            if (basis[i] != 0) {
                tmp[cnt++] = basis[i];
            }
        }
        
        // 如果k超过可能的子集数量，返回-1
        if (k >= (1L << cnt)) {
            return -1;
        }
        
        long res = 0;
        for (int i = 0; i < cnt; i++) {
            if ((k >> i & 1) == 1) {
                res ^= tmp[i];
            }
        }
        return res;
    }
    
    /**
     * 计算所有连续子数组的异或和的和
     * 利用前缀异或性质：区间[l,r]的异或和等于prefix[r] ^ prefix[l-1]
     * 
     * 算法思路：
     * 1. 计算前缀异或数组
     * 2. 对于每一位，统计有多少个区间的异或和在该位上是1
     * 3. 该位的总贡献为 1的个数 * 2^bit
     * 
     * @param nums 输入数组
     * @return 所有连续子数组异或和的和
     */
    public static long subarrayXorSum(long[] nums) {
        int n = nums.length;
        long[] prefix = new long[n + 1];
        
        // 计算前缀异或数组
        for (int i = 0; i < n; i++) {
            prefix[i + 1] = prefix[i] ^ nums[i];
        }
        
        long result = 0;
        // 统计每一位在所有子数组异或和中出现的次数
        for (int bit = 0; bit < MAXL; bit++) {
            long count = 0; // 统计前缀异或中第bit位为0的数量
            long one = 0;   // 统计前缀异或中第bit位为1的数量
            
            for (int i = 0; i <= n; i++) {
                if ((prefix[i] >> bit & 1) == 0) {
                    count++;
                } else {
                    one++;
                }
            }
            
            // 第bit位的贡献是 count * one * 2^bit
            result += count * one * (1L << bit);
        }
        
        return result;
    }
    
    // SPOJ XMAX - 异或最大值问题的主方法
    public static void main(String[] args) throws IOException {
        // 主方法处理SPOJ XMAX问题
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        PrintWriter out = new PrintWriter(new OutputStreamWriter(System.out));
        
        int n = Integer.parseInt(br.readLine());
        
        // 初始化线性基
        Arrays.fill(basis, 0);
        
        // 读取输入数据并插入到线性基中
        for (int i = 0; i < n; i++) {
            long x = Long.parseLong(br.readLine());
            insert(x);
        }
        
        // 查询最大异或值
        long result = queryMax();
        out.println(result);
        
        out.flush();
        out.close();
        br.close();
    }
    
    // HDU 3949 XOR - 第k小异或值问题的解决方案
    public static void solveHDU3949() throws IOException {
        /**
         * HDU 3949 XOR 解题思路：
         * 1. 问题分析：
         *    - 需要求所有子集异或和中的第k小值
         *    - 线性基可以表示所有可能的子集异或和
         * 
         * 2. 解题步骤：
         *    - 构建线性基
         *    - 重组线性基，使其每个基向量的最高位唯一
         *    - 将k转换为二进制，根据二进制位选择对应的基向量
         * 
         * 3. 特殊情况处理：
         *    - 如果线性基的秩小于原数组长度，说明存在全0的情况
         *    - 需要考虑空集的情况（异或和为0）
         */
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        PrintWriter out = new PrintWriter(new OutputStreamWriter(System.out));
        
        int T = Integer.parseInt(br.readLine());
        while (T-- > 0) {
            int n = Integer.parseInt(br.readLine());
            String[] parts = br.readLine().split(" ");
            
            // 初始化线性基
            Arrays.fill(basis, 0);
            
            // 构建线性基
            for (int i = 0; i < n; i++) {
                long x = Long.parseLong(parts[i]);
                insert(x);
            }
            
            // 重组线性基
            rebuild();
            
            // 判断是否有0解（即是否存在线性相关）
            boolean hasZero = false;
            for (int i = 0; i < MAXL; i++) {
                if (basis[i] == 0) {
                    hasZero = true;
                    break;
                }
            }
            
            int m = Integer.parseInt(br.readLine());
            while (m-- > 0) {
                long k = Long.parseLong(br.readLine());
                
                // 如果有0解，第k小相当于k--
                if (hasZero) {
                    if (k == 1) {
                        out.println(0);
                        continue;
                    }
                    k--;
                }
                
                long ans = queryKth(k);
                out.println(ans);
            }
        }
        
        out.flush();
        out.close();
        br.close();
    }
    
    // 牛客网 NC14533 异或和问题的解决方案
    public static void solveNiuke14533() throws IOException {
        /**
         * 牛客网 NC14533 异或和 解题思路：
         * 1. 问题分析：
         *    - 求所有连续子数组的异或和的和
         *    - 直接计算所有子数组的异或和会超时
         * 
         * 2. 优化方法：
         *    - 利用前缀异或性质：区间[l,r]的异或和等于prefix[r] ^ prefix[l-1]
         *    - 对于每一位，统计有多少个区间的异或和在该位上是1
         *    - 该位的总贡献为 1的个数 * 2^bit
         * 
         * 3. 复杂度分析：
         *    - 时间复杂度：O(n * log(max_value))
         *    - 空间复杂度：O(n)
         */
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        PrintWriter out = new PrintWriter(new OutputStreamWriter(System.out));
        
        int n = Integer.parseInt(br.readLine());
        String[] parts = br.readLine().split(" ");
        long[] nums = new long[n];
        
        for (int i = 0; i < n; i++) {
            nums[i] = Long.parseLong(parts[i]);
        }
        
        long result = subarrayXorSum(nums);
        out.println(result);
        
        out.flush();
        out.close();
        br.close();
    }
}

===============================================

文件: Code07_XMAX.py
===============================================
# SPOJ XMAX - XOR Maximization
# 题目描述：
# 给定一个整数集合S，定义函数X(S)为集合中所有元素的异或值，
# 求X(S)的最大值。
# 1 <= |S| <= 10^5
# 0 <= ai <= 10^18
# 测试链接 : https://www.spoj.com/problems/XMAX/

# 线性基解决异或最大值问题 - SPOJ XMAX
# 
# 题目解析：
# 本题要求从给定的整数集合中选择一些数，使得它们的异或值最大。
# 这是一个典型的线性基问题，可以用高斯消元的思想来解决。
# 
# 解题思路：
# 1. 线性基构造：
#    - 从高位到低位依次考虑每个二进制位
#    - 对于每个二进制位，维护一个基向量，表示该位可以被表示的数
# 2. 贪心选择：
#    - 从高位到低位贪心地选择是否将对应的基向量加入结果
#    - 如果加入后结果变大，则加入；否则不加入
# 
# 时间复杂度：O(n * log(max_value))
# 空间复杂度：O(log(max_value))

MAXL = 64  # 64位整数

# 线性基数组
basis = [0] * MAXL

def insert(x):
    """
    插入一个数到线性基中
    
    线性基构造过程：
    1. 从高位到低位遍历该数的二进制位
    2. 对于每个为1的位：
       - 如果该位在线性基中还没有基向量，则直接插入
       - 否则用已有的基向量消去该位，继续处理
    
    :param x: 要插入的数
    """
    for i in range(MAXL - 1, -1, -1):
        if ((x >> i) & 1) == 0: 
            continue  # 如果第i位是0，跳过
        
        if basis[i] == 0:
            # 如果basis[i]为空，直接插入
            basis[i] = x
            break
        
        # 否则用basis[i]消去x的第i位
        x ^= basis[i]

def queryMax():
    """
    查询最大异或值
    
    贪心策略：
    从高位到低位贪心地选择是否加入basis[i]
    如果加入后结果变大，则加入；否则不加入
    
    :return: 最大异或值
    """
    result = 0
    for i in range(MAXL - 1, -1, -1):
        # 贪心地选择是否加入basis[i]
        if ((result >> i) & 1) == 0:  # 如果结果的第i位是0
            result ^= basis[i]  # 加入basis[i]可能会使结果更大
    return result

def main():
    import sys
    input = sys.stdin.read
    data = input().split()
    
    n = int(data[0])
    
    # 初始化线性基
    for i in range(MAXL):
        basis[i] = 0
    
    # 读取输入数据并插入到线性基中
    for i in range(n):
        x = int(data[i + 1])
        insert(x)
    
    # 查询最大异或值
    result = queryMax()
    print(result)

if __name__ == "__main__":
    main()

===============================================

文件: ExceptionHandling_GaussXor.java
===============================================
package class134;

/**
 * 高斯消元和线性基算法异常处理与边界检查类
 * 
 * 本类提供完整的异常处理机制和边界条件检查，确保算法在各种输入情况下的健壮性
 * 
 * 异常处理策略：
 * 1. 参数校验：检查输入参数的合法性
 * 2. 边界条件：处理各种边界情况
 * 3. 错误恢复：提供优雅的错误处理机制
 * 4. 调试支持：提供详细的错误信息和调试信息
 * 
 * 边界条件检查：
 * 1. 空输入检查
 * 2. 数组越界检查
 * 3. 数值溢出检查
 * 4. 内存限制检查
 */
public class ExceptionHandling_GaussXor {
    
    public static int MAXN = 105; // 最大未知数个数
    
    /**
     * 高斯消元解决异或方程组（带异常处理版本）
     * 
     * @param n 未知数个数
     * @param mat 增广矩阵，1-based索引
     * @return 解的情况：-1表示无解，0表示唯一解，1表示无穷多解
     * @throws IllegalArgumentException 如果输入参数不合法
     */
    public static int gaussWithExceptionHandling(int n, int[][] mat) {
        // 参数校验
        validateInputParameters(n, mat);
        
        try {
            int r = 1; // 当前处理的行
            int c = 1; // 当前处理的列
            
            // 消元过程
            while (r <= n && c <= n) {
                // 边界检查
                if (r < 1 || r > n || c < 1 || c > n) {
                    throw new IllegalStateException("行列索引越界: r=" + r + ", c=" + c);
                }
                
                int pivot = findPivot(r, c, n, mat);
                
                if (mat[pivot][c] == 0) {
                    c++; // 当前列全为0，跳到下一列
                    continue;
                }
                
                if (pivot != r) {
                    swapRows(r, pivot, n, mat);
                }
                
                eliminateOtherRows(r, c, n, mat);
                
                c++;
                r++;
            }
            
            return checkSolution(r, n, mat);
            
        } catch (Exception e) {
            System.err.println("高斯消元过程中发生错误: " + e.getMessage());
            throw new RuntimeException("高斯消元算法执行失败", e);
        }
    }
    
    /**
     * 验证输入参数
     */
    private static void validateInputParameters(int n, int[][] mat) {
        if (n <= 0 || n >= MAXN) {
            throw new IllegalArgumentException("未知数个数n必须在1到" + (MAXN - 1) + "之间，当前n=" + n);
        }
        
        if (mat == null) {
            throw new IllegalArgumentException("增广矩阵不能为null");
        }
        
        if (mat.length < n + 1) {
            throw new IllegalArgumentException("增广矩阵行数不足，需要至少" + (n + 1) + "行，实际只有" + mat.length + "行");
        }
        
        // 检查每行的列数
        for (int i = 1; i <= n; i++) {
            if (mat[i] == null) {
                throw new IllegalArgumentException("第" + i + "行矩阵不能为null");
            }
            
            if (mat[i].length < n + 2) {
                throw new IllegalArgumentException("第" + i + "行列数不足，需要至少" + (n + 2) + "列，实际只有" + mat[i].length + "列");
            }
            
            // 检查矩阵元素是否合法（只能是0或1）
            for (int j = 1; j <= n + 1; j++) {
                if (mat[i][j] != 0 && mat[i][j] != 1) {
                    throw new IllegalArgumentException(
                        "矩阵元素只能是0或1，但mat[" + i + "][" + j + "] = " + mat[i][j]
                    );
                }
            }
        }
    }
    
    /**
     * 寻找主元
     */
    private static int findPivot(int r, int c, int n, int[][] mat) {
        int pivot = r;
        
        for (int i = r; i <= n; i++) {
            // 边界检查
            if (i < 1 || i > n) {
                throw new IllegalStateException("行索引越界: i=" + i);
            }
            
            if (mat[i][c] == 1) {
                pivot = i;
                break;
            }
        }
        
        return pivot;
    }
    
    /**
     * 交换两行
     */
    private static void swapRows(int r1, int r2, int n, int[][] mat) {
        // 边界检查
        if (r1 < 1 || r1 > n || r2 < 1 || r2 > n) {
            throw new IllegalArgumentException("行索引越界: r1=" + r1 + ", r2=" + r2);
        }
        
        for (int j = 1; j <= n + 1; j++) {
            int temp = mat[r1][j];
            mat[r1][j] = mat[r2][j];
            mat[r2][j] = temp;
        }
    }
    
    /**
     * 消去其他行的当前列系数
     */
    private static void eliminateOtherRows(int r, int c, int n, int[][] mat) {
        for (int i = 1; i <= n; i++) {
            if (i != r && mat[i][c] == 1) {
                // 边界检查
                if (i < 1 || i > n) {
                    throw new IllegalStateException("行索引越界: i=" + i);
                }
                
                for (int j = c; j <= n + 1; j++) {
                    // 边界检查
                    if (j < 1 || j > n + 1) {
                        throw new IllegalStateException("列索引越界: j=" + j);
                    }
                    
                    mat[i][j] ^= mat[r][j];
                }
            }
        }
    }
    
    /**
     * 检查解的情况
     */
    private static int checkSolution(int r, int n, int[][] mat) {
        // 检查是否有矛盾方程
        for (int i = r; i <= n; i++) {
            // 边界检查
            if (i < 1 || i > n) {
                throw new IllegalStateException("行索引越界: i=" + i);
            }
            
            boolean allZero = true;
            for (int j = 1; j <= n; j++) {
                if (mat[i][j] != 0) {
                    allZero = false;
                    break;
                }
            }
            
            if (allZero && mat[i][n + 1] == 1) {
                return -1; // 无解
            }
        }
        
        // 判断是否有自由元
        if (r <= n) {
            return 1; // 无穷多解
        }
        
        return 0; // 唯一解
    }
    
    /**
     * 线性基构造（带异常处理版本）
     * 
     * @param arr 输入数组
     * @param n 数组长度
     * @return 线性基数组
     * @throws IllegalArgumentException 如果输入参数不合法
     */
    public static long[] constructLinearBasis(long[] arr, int n) {
        // 参数校验
        if (arr == null) {
            throw new IllegalArgumentException("输入数组不能为null");
        }
        
        if (n <= 0 || n > arr.length) {
            throw new IllegalArgumentException("数组长度n不合法: n=" + n);
        }
        
        long[] basis = new long[64]; // 64位线性基
        
        try {
            for (int i = 0; i < n; i++) {
                long x = arr[i];
                
                // 检查数值范围
                if (x < 0) {
                    throw new IllegalArgumentException("输入数字不能为负数: " + x);
                }
                
                for (int j = 63; j >= 0; j--) {
                    if ((x >> j & 1) == 1) {
                        if (basis[j] == 0) {
                            basis[j] = x;
                            break;
                        } else {
                            x ^= basis[j];
                        }
                    }
                }
            }
            
            return basis;
            
        } catch (Exception e) {
            System.err.println("线性基构造过程中发生错误: " + e.getMessage());
            throw new RuntimeException("线性基构造失败", e);
        }
    }
    
    /**
     * 计算异或最大值（带异常处理版本）
     * 
     * @param arr 输入数组
     * @param n 数组长度
     * @return 异或最大值
     * @throws IllegalArgumentException 如果输入参数不合法
     */
    public static long getMaxXOR(long[] arr, int n) {
        long[] basis = constructLinearBasis(arr, n);
        
        long result = 0;
        
        try {
            for (int i = 63; i >= 0; i--) {
                if ((result ^ basis[i]) > result) {
                    result ^= basis[i];
                }
            }
            
            return result;
            
        } catch (Exception e) {
            System.err.println("异或最大值计算过程中发生错误: " + e.getMessage());
            throw new RuntimeException("异或最大值计算失败", e);
        }
    }
    
    /**
     * 测试异常处理功能
     */
    public static void testExceptionHandling() {
        System.out.println("=== 测试异常处理功能 ===");
        
        // 测试用例1：空矩阵
        try {
            gaussWithExceptionHandling(0, null);
            System.out.println("测试用例1失败：应该抛出异常");
        } catch (IllegalArgumentException e) {
            System.out.println("测试用例1通过：" + e.getMessage());
        }
        
        // 测试用例2：矩阵元素不合法
        try {
            int[][] mat = new int[3][3];
            mat[1][1] = 2; // 非法元素
            gaussWithExceptionHandling(2, mat);
            System.out.println("测试用例2失败：应该抛出异常");
        } catch (IllegalArgumentException e) {
            System.out.println("测试用例2通过：" + e.getMessage());
        }
        
        // 测试用例3：空数组
        try {
            constructLinearBasis(null, 0);
            System.out.println("测试用例3失败：应该抛出异常");
        } catch (IllegalArgumentException e) {
            System.out.println("测试用例3通过：" + e.getMessage());
        }
        
        // 测试用例4：负数输入
        try {
            long[] arr = {-1L};
            getMaxXOR(arr, 1);
            System.out.println("测试用例4失败：应该抛出异常");
        } catch (IllegalArgumentException e) {
            System.out.println("测试用例4通过：" + e.getMessage());
        }
        
        System.out.println("所有异常处理测试完成！");
    }
    
    /**
     * 主函数
     */
    public static void main(String[] args) {
        System.out.println("开始运行异常处理测试...\n");
        
        testExceptionHandling();
        
        System.out.println("\n异常处理测试完成！");
    }
}

===============================================

文件: ShowDetails.java
===============================================
package class134;

// 课上讲述高斯消元解决异或方程组的例子

/**
 * 高斯消元解决异或方程组 - 课堂示例
 * 
 * 本文件包含多个示例，演示了异或方程组的不同解的情况：
 * 1. 唯一解
 * 2. 无解（存在矛盾）
 * 3. 多解
 * 
 * 异或方程组的一般形式：
 * a[1][1]*x[1] ^ a[1][2]*x[2] ^ ... ^ a[1][n]*x[n] = b[1]
 * a[2][1]*x[1] ^ a[2][2]*x[2] ^ ... ^ a[2][n]*x[n] = b[2]
 * ...
 * a[n][1]*x[1] ^ a[n][2]*x[2] ^ ... ^ a[n][n]*x[n] = b[n]
 * 
 * 其中 ^ 表示异或运算，a[i][j] 和 b[i] 取值为 0 或 1
 */
public class ShowDetails {

	public static int MAXN = 101;

	public static int[][] mat = new int[MAXN][MAXN];

	/**
	 * 高斯消元解决异或方程组模版
	 * 需要保证变量有n个，表达式也有n个
	 * 
	 * @param n 未知数个数
	 */
	public static void gauss(int n) {
		for (int i = 1; i <= n; i++) {
			for (int j = 1; j <= n; j++) {
				if (j < i && mat[j][j] == 1) {
					continue;
				}
				if (mat[j][i] == 1) {
					swap(i, j);
					break;
				}
			}
			if (mat[i][i] == 1) {
				for (int j = 1; j <= n; j++) {
					if (i != j && mat[j][i] == 1) {
						for (int k = i; k <= n + 1; k++) {
							mat[j][k] ^= mat[i][k];
						}
					}
				}
			}
		}
	}

	/**
	 * 交换矩阵中的两行
	 * 
	 * @param a 行号1
	 * @param b 行号2
	 */
	public static void swap(int a, int b) {
		int[] tmp = mat[a];
		mat[a] = mat[b];
		mat[b] = tmp;
	}

	/**
	 * 打印增广矩阵
	 * 
	 * @param n 未知数个数
	 */
	public static void print(int n) {
		for (int i = 1; i <= n; i++) {
			for (int j = 1; j <= n + 1; j++) {
				System.out.print(mat[i][j] + " ");
			}
			System.out.println();
		}
		System.out.println("========================");
	}

	public static void main(String[] args) {
		System.out.println("课上图解的例子，有唯一解");
		// x1 ^ x2 ^ x3 = 0
		// x1 ^ x3 ^ x4 = 1
		// x2 ^ x3 ^ x4 = 1
		// x3 ^ x4 = 0
		mat[1][1] = 1; mat[1][2] = 1; mat[1][3] = 1; mat[1][4] = 0; mat[1][5] = 0;
		mat[2][1] = 1; mat[2][2] = 0; mat[2][3] = 1; mat[2][4] = 1; mat[2][5] = 1;
		mat[3][1] = 0; mat[3][2] = 1; mat[3][3] = 1; mat[3][4] = 1; mat[3][5] = 1;
		mat[4][1] = 0; mat[4][2] = 0; mat[4][3] = 1; mat[4][4] = 1; mat[4][5] = 0;
		gauss(4);
		print(4);

		System.out.println("表达式存在矛盾的例子");
		// x1 ^ x2 = 1
		// x1 ^ x3 = 1
		// x2 ^ x3 = 1
		mat[1][1] = 1; mat[1][2] = 1; mat[1][3] = 0; mat[1][4] = 1;
		mat[2][1] = 1; mat[2][2] = 0; mat[2][3] = 1; mat[2][4] = 1;
		mat[3][1] = 0; mat[3][2] = 1; mat[3][3] = 1; mat[3][4] = 1;
		gauss(3);
		print(3);

		System.out.println("表达式存在多解的例子");
		// x1 ^ x3 = 1
		// x2 ^ x3 = 1
		// x1 ^ x2 = 0
		mat[1][1] = 1; mat[1][2] = 0; mat[1][3] = 1; mat[1][4] = 1;
		mat[2][1] = 0; mat[2][2] = 1; mat[2][3] = 1; mat[2][4] = 1;
		mat[3][1] = 1; mat[3][2] = 1; mat[3][3] = 0; mat[3][4] = 0;
		mat[4][1] = 1; mat[4][2] = 1; mat[4][3] = 0; mat[4][4] = 0;
		gauss(3);
		print(3);

		System.out.println("注意下面这个多解的例子");
		// x1 ^ x3 ^ x4 = 0
		// x2 ^ x3 ^ x4 = 0
		// x1 ^ x2 = 0
		// x3 ^ x4 = 1
		mat[1][1] = 1; mat[1][2] = 0; mat[1][3] = 1; mat[1][4] = 1; mat[1][5] = 0;
		mat[2][1] = 0; mat[2][2] = 1; mat[2][3] = 1; mat[2][4] = 1; mat[2][5] = 0;
		mat[3][1] = 1; mat[3][2] = 1; mat[3][3] = 0; mat[3][4] = 0; mat[3][5] = 0;
		mat[4][1] = 0; mat[4][2] = 0; mat[4][3] = 1; mat[4][4] = 1; mat[4][5] = 1;
		gauss(4);
		print(4);
		System.out.println("最后一个例子里");
		System.out.println("主元x1和x2，不受其他自由元影响，值可以直接确定");
		System.out.println("但是主元x3，受到自由元x4的影响，x3 ^ x4 = 1");
		System.out.println("只有自由元x4确定了值，主元x3的值才能确定");
		System.out.println("这里是想说，消元完成后，如果结论是多解，那么");
		System.out.println("有些主元的值可以直接确定");
		System.out.println("有些主元的值需要若干自由元确定之后才能确定");
		System.out.println("这就是上节课，也就是讲解133讲的：");
		System.out.println("主元和自由元之间的依赖关系");
		System.out.println("请确保已经掌握");
	}

}

===============================================

文件: Test_GaussXor.java
===============================================
package class134;

/**
 * 高斯消元和线性基算法测试类
 * 
 * 本测试类包含所有高斯消元和线性基相关算法的完整测试用例
 * 包括边界测试、极端输入测试、性能测试等
 * 
 * 测试目标：
 * 1. 验证算法正确性
 * 2. 测试边界条件和异常情况
 * 3. 验证性能表现
 * 4. 确保代码健壮性
 */
public class Test_GaussXor {
    
    /**
     * 测试高斯消元解决异或方程组模板
     */
    public static void testGaussXorTemplate() {
        System.out.println("=== 测试高斯消元解决异或方程组模板 ===");
        
        // 测试用例1：唯一解
        System.out.println("测试用例1：唯一解");
        int[][] mat1 = {
            {1, 1, 0, 1},  // x1 + x2 = 1
            {0, 1, 1, 0},  // x2 + x3 = 0
            {1, 0, 1, 1}   // x1 + x3 = 1
        };
        int n1 = 3;
        int result1 = Code04_GaussXorTemplate.gauss(n1, mat1);
        System.out.println("唯一解测试结果：" + result1);
        
        // 测试用例2：无穷解
        System.out.println("测试用例2：无穷解");
        int[][] mat2 = {
            {1, 1, 0, 1},  // x1 + x2 = 1
            {0, 0, 0, 0},  // 0 = 0
            {0, 0, 0, 0}   // 0 = 0
        };
        int n2 = 3;
        int result2 = Code04_GaussXorTemplate.gauss(n2, mat2);
        System.out.println("无穷解测试结果：" + result2);
        
        // 测试用例3：无解
        System.out.println("测试用例3：无解");
        int[][] mat3 = {
            {1, 1, 0, 1},  // x1 + x2 = 1
            {0, 0, 0, 1}   // 0 = 1
        };
        int n3 = 2;
        int result3 = Code04_GaussXorTemplate.gauss(n3, mat3);
        System.out.println("无解测试结果：" + result3);
        
        System.out.println();
    }
    
    /**
     * 测试HDU 5833 树的因子问题
     */
    public static void testGaussEor() {
        System.out.println("=== 测试HDU 5833 树的因子问题 ===");
        
        // 测试用例1：简单情况
        System.out.println("测试用例1：简单情况");
        long[] arr1 = {2, 3, 6};  // 2, 3, 6
        int n1 = 3;
        long result1 = Code01_GaussEor.solve(n1, arr1);
        System.out.println("简单情况测试结果：" + result1);
        
        // 测试用例2：完全平方数
        System.out.println("测试用例2：完全平方数");
        long[] arr2 = {4, 9, 16};  // 4, 9, 16
        int n2 = 3;
        long result2 = Code01_GaussEor.solve(n2, arr2);
        System.out.println("完全平方数测试结果：" + result2);
        
        // 测试用例3：边界情况
        System.out.println("测试用例3：边界情况");
        long[] arr3 = {1};  // 单个数字
        int n3 = 1;
        long result3 = Code01_GaussEor.solve(n3, arr3);
        System.out.println("边界情况测试结果：" + result3);
        
        System.out.println();
    }
    
    /**
     * 测试洛谷 P2962 Lights问题
     */
    public static void testMinimumOperations() {
        System.out.println("=== 测试洛谷 P2962 Lights问题 ===");
        
        // 测试用例1：简单图
        System.out.println("测试用例1：简单图");
        int n1 = 3;
        int m1 = 2;
        int[][] edges1 = {{1, 2}, {2, 3}};
        int result1 = Code02_MinimumOperations.solve(n1, m1, edges1);
        System.out.println("简单图测试结果：" + result1);
        
        // 测试用例2：完全图
        System.out.println("测试用例2：完全图");
        int n2 = 4;
        int m2 = 6;
        int[][] edges2 = {{1, 2}, {1, 3}, {1, 4}, {2, 3}, {2, 4}, {3, 4}};
        int result2 = Code02_MinimumOperations.solve(n2, m2, edges2);
        System.out.println("完全图测试结果：" + result2);
        
        // 测试用例3：孤立点
        System.out.println("测试用例3：孤立点");
        int n3 = 1;
        int m3 = 0;
        int[][] edges3 = {};
        int result3 = Code02_MinimumOperations.solve(n3, m3, edges3);
        System.out.println("孤立点测试结果：" + result3);
        
        System.out.println();
    }
    
    /**
     * 测试洛谷 P2447 外星千足虫问题
     */
    public static void testAlienInsectLegs() {
        System.out.println("=== 测试洛谷 P2447 外星千足虫问题 ===");
        
        // 测试用例1：简单测量记录
        System.out.println("测试用例1：简单测量记录");
        int n1 = 3;
        int m1 = 3;
        String[] records1 = {"011 1", "101 0", "110 1"};
        String result1 = Code03_AlienInsectLegs.solve(n1, m1, records1);
        System.out.println("简单测量记录测试结果：" + result1);
        
        // 测试用例2：冗余测量记录
        System.out.println("测试用例2：冗余测量记录");
        int n2 = 2;
        int m2 = 4;
        String[] records2 = {"10 1", "01 1", "11 0", "10 1"};
        String result2 = Code03_AlienInsectLegs.solve(n2, m2, records2);
        System.out.println("冗余测量记录测试结果：" + result2);
        
        // 测试用例3：无法确定
        System.out.println("测试用例3：无法确定");
        int n3 = 2;
        int m3 = 1;
        String[] records3 = {"10 1"};
        String result3 = Code03_AlienInsectLegs.solve(n3, m3, records3);
        System.out.println("无法确定测试结果：" + result3);
        
        System.out.println();
    }
    
    /**
     * 测试POJ 1830 开关问题
     */
    public static void testSwitchProblem() {
        System.out.println("=== 测试POJ 1830 开关问题 ===");
        
        // 测试用例1：简单开关问题
        System.out.println("测试用例1：简单开关问题");
        int n1 = 3;
        int[] start1 = {0, 0, 0};
        int[] end1 = {1, 1, 1};
        int[][] relations1 = {{1, 2}, {2, 3}, {1, 3}};
        int result1 = Code05_SwitchProblem.solve(n1, start1, end1, relations1);
        System.out.println("简单开关问题测试结果：" + result1);
        
        // 测试用例2：无解情况
        System.out.println("测试用例2：无解情况");
        int n2 = 2;
        int[] start2 = {0, 0};
        int[] end2 = {1, 0};
        int[][] relations2 = {{1, 2}};
        int result2 = Code05_SwitchProblem.solve(n2, start2, end2, relations2);
        System.out.println("无解情况测试结果：" + result2);
        
        // 测试用例3：唯一解
        System.out.println("测试用例3：唯一解");
        int n3 = 1;
        int[] start3 = {0};
        int[] end3 = {1};
        int[][] relations3 = {};
        int result3 = Code05_SwitchProblem.solve(n3, start3, end3, relations3);
        System.out.println("唯一解测试结果：" + result3);
        
        System.out.println();
    }
    
    /**
     * 测试UVa 11542 Square问题
     */
    public static void testSquare() {
        System.out.println("=== 测试UVa 11542 Square问题 ===");
        
        // 测试用例1：简单情况
        System.out.println("测试用例1：简单情况");
        long[] arr1 = {2, 3, 6};
        int n1 = 3;
        long result1 = Code06_Square.solve(n1, arr1);
        System.out.println("简单情况测试结果：" + result1);
        
        // 测试用例2：完全平方数
        System.out.println("测试用例2：完全平方数");
        long[] arr2 = {4, 9, 36};
        int n2 = 3;
        long result2 = Code06_Square.solve(n2, arr2);
        System.out.println("完全平方数测试结果：" + result2);
        
        // 测试用例3：边界情况
        System.out.println("测试用例3：边界情况");
        long[] arr3 = {1};
        int n3 = 1;
        long result3 = Code06_Square.solve(n3, arr3);
        System.out.println("边界情况测试结果：" + result3);
        
        System.out.println();
    }
    
    /**
     * 测试SPOJ XMAX 异或最大值问题
     */
    public static void testXMAX() {
        System.out.println("=== 测试SPOJ XMAX 异或最大值问题 ===");
        
        // 测试用例1：简单情况
        System.out.println("测试用例1：简单情况");
        long[] arr1 = {1, 2, 3};
        int n1 = 3;
        long result1 = Code07_XMAX.solve(n1, arr1);
        System.out.println("简单情况测试结果：" + result1);
        
        // 测试用例2：最大值情况
        System.out.println("测试用例2：最大值情况");
        long[] arr2 = {1, 2, 4, 8};
        int n2 = 4;
        long result2 = Code07_XMAX.solve(n2, arr2);
        System.out.println("最大值情况测试结果：" + result2);
        
        // 测试用例3：边界情况
        System.out.println("测试用例3：边界情况");
        long[] arr3 = {0};
        int n3 = 1;
        long result3 = Code07_XMAX.solve(n3, arr3);
        System.out.println("边界情况测试结果：" + result3);
        
        System.out.println();
    }
    
    /**
     * 运行所有测试
     */
    public static void main(String[] args) {
        System.out.println("开始运行高斯消元和线性基算法测试...\n");
        
        // 运行所有测试
        testGaussXorTemplate();
        testGaussEor();
        testMinimumOperations();
        testAlienInsectLegs();
        testSwitchProblem();
        testSquare();
        testXMAX();
        
        System.out.println("所有测试运行完成！");
    }
}

===============================================

文件: Test_Gauss_XOR_All.java
===============================================
package class134;

import java.io.*;
import java.util.*;

/**
 * 高斯消元与线性基算法全面测试类
 * 
 * 测试目标：
 * 1. 验证高斯消元算法的正确性
 * 2. 测试各种边界条件和异常情况
 * 3. 验证线性基算法的功能
 * 4. 测试多语言实现的兼容性
 * 
 * 测试覆盖范围：
 * - 唯一解情况
 * - 无穷多解情况
 * - 无解情况
 * - 边界条件（空矩阵、全零矩阵等）
 * - 极端输入（大矩阵、特殊值等）
 * 
 * 测试方法：
 * 1. 单元测试：针对每个函数进行独立测试
 * 2. 集成测试：测试整个算法流程
 * 3. 性能测试：测试算法的时间空间复杂度
 * 4. 兼容性测试：测试不同语言的实现一致性
 */
public class Test_Gauss_XOR_All {
    
    /**
     * 测试高斯消元算法的基本功能
     */
    public static void testBasicGauss() {
        System.out.println("=== 测试1: 高斯消元基本功能 ===");
        
        // 测试用例1: 有唯一解
        System.out.println("测试用例1 - 唯一解:");
        int n1 = 3;
        int[][] mat1 = {
            {1, 1, 1, 0},  // x1 ^ x2 ^ x3 = 0
            {1, 0, 1, 1},   // x1 ^ x3 = 1
            {0, 1, 1, 1}    // x2 ^ x3 = 1
        };
        testGaussCase(n1, mat1, 0, "唯一解");
        
        // 测试用例2: 无解
        System.out.println("\n测试用例2 - 无解:");
        int n2 = 3;
        int[][] mat2 = {
            {1, 1, 0, 1},   // x1 ^ x2 = 1
            {1, 0, 1, 1},   // x1 ^ x3 = 1
            {0, 1, 1, 1}    // x2 ^ x3 = 1
        };
        testGaussCase(n2, mat2, -1, "无解");
        
        // 测试用例3: 无穷多解
        System.out.println("\n测试用例3 - 无穷多解:");
        int n3 = 3;
        int[][] mat3 = {
            {1, 0, 1, 1},   // x1 ^ x3 = 1
            {0, 1, 1, 1},   // x2 ^ x3 = 1
            {1, 1, 0, 0}    // x1 ^ x2 = 0
        };
        testGaussCase(n3, mat3, 1, "无穷多解");
    }
    
    /**
     * 测试单个高斯消元案例
     */
    private static void testGaussCase(int n, int[][] inputMat, int expected, String caseName) {
        // 复制矩阵到全局变量
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= n + 1; j++) {
                Code04_GaussXorTemplate.mat[i][j] = inputMat[i-1][j-1];
            }
        }
        
        // 执行高斯消元
        int result = Code04_GaussXorTemplate.gauss(n);
        
        // 验证结果
        if (result == expected) {
            System.out.println("✓ " + caseName + "测试通过");
        } else {
            System.out.println("✗ " + caseName + "测试失败，期望:" + expected + "，实际:" + result);
        }
        
        // 打印矩阵状态用于调试
        System.out.println("消元后矩阵:");
        Code04_GaussXorTemplate.printMatrix(n);
    }
    
    /**
     * 测试线性基算法的基本功能
     */
    public static void testLinearBasis() {
        System.out.println("\n=== 测试2: 线性基算法基本功能 ===");
        
        // 测试用例1: 最大异或值
        System.out.println("测试用例1 - 最大异或值:");
        long[] nums1 = {3L, 5L, 7L, 9L};
        long expected1 = 15L; // 3 ^ 5 ^ 7 ^ 9 = 15
        testLinearBasisCase(nums1, expected1, "最大异或值");
        
        // 测试用例2: 线性基插入
        System.out.println("\n测试用例2 - 线性基插入:");
        long[] nums2 = {1L, 2L, 4L, 8L};
        long expected2 = 15L; // 所有基向量的异或
        testLinearBasisCase(nums2, expected2, "线性基插入");
    }
    
    /**
     * 测试单个线性基案例
     */
    private static void testLinearBasisCase(long[] nums, long expected, String caseName) {
        // 创建线性基
        Code07_XMAX.LinearBasis lb = new Code07_XMAX.LinearBasis();
        
        // 插入所有数字
        for (long num : nums) {
            lb.insert(num);
        }
        
        // 获取最大异或值
        long result = lb.getMaxXor();
        
        // 验证结果
        if (result == expected) {
            System.out.println("✓ " + caseName + "测试通过");
        } else {
            System.out.println("✗ " + caseName + "测试失败，期望:" + expected + "，实际:" + result);
        }
        
        // 打印线性基状态
        System.out.println("线性基状态:");
        lb.printBasis();
    }
    
    /**
     * 测试边界条件和异常情况
     */
    public static void testEdgeCases() {
        System.out.println("\n=== 测试3: 边界条件和异常情况 ===");
        
        // 测试用例1: 空矩阵
        System.out.println("测试用例1 - 空矩阵:");
        try {
            int result = Code04_GaussXorTemplate.gauss(0);
            System.out.println("空矩阵处理结果:" + result);
        } catch (Exception e) {
            System.out.println("空矩阵异常处理:" + e.getMessage());
        }
        
        // 测试用例2: 全零矩阵
        System.out.println("\n测试用例2 - 全零矩阵:");
        int n = 3;
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= n + 1; j++) {
                Code04_GaussXorTemplate.mat[i][j] = 0;
            }
        }
        int result = Code04_GaussXorTemplate.gauss(n);
        System.out.println("全零矩阵结果:" + result);
        
        // 测试用例3: 单位矩阵
        System.out.println("\n测试用例3 - 单位矩阵:");
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= n + 1; j++) {
                Code04_GaussXorTemplate.mat[i][j] = (j == i) ? 1 : 0;
            }
            Code04_GaussXorTemplate.mat[i][n + 1] = 1; // 常数项为1
        }
        result = Code04_GaussXorTemplate.gauss(n);
        System.out.println("单位矩阵结果:" + result);
    }
    
    /**
     * 测试性能和大规模数据
     */
    public static void testPerformance() {
        System.out.println("\n=== 测试4: 性能测试 ===");
        
        // 测试小规模数据
        System.out.println("小规模数据测试 (n=10):");
        long startTime = System.currentTimeMillis();
        testRandomCase(10);
        long endTime = System.currentTimeMillis();
        System.out.println("耗时:" + (endTime - startTime) + "ms");
        
        // 测试中等规模数据
        System.out.println("\n中等规模数据测试 (n=50):");
        startTime = System.currentTimeMillis();
        testRandomCase(50);
        endTime = System.currentTimeMillis();
        System.out.println("耗时:" + (endTime - startTime) + "ms");
        
        // 测试大规模数据（可选）
        System.out.println("\n大规模数据测试 (n=100):");
        startTime = System.currentTimeMillis();
        testRandomCase(100);
        endTime = System.currentTimeMillis();
        System.out.println("耗时:" + (endTime - startTime) + "ms");
    }
    
    /**
     * 测试随机生成的案例
     */
    private static void testRandomCase(int n) {
        Random rand = new Random();
        
        // 生成随机矩阵
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= n + 1; j++) {
                Code04_GaussXorTemplate.mat[i][j] = rand.nextInt(2); // 0或1
            }
        }
        
        // 执行高斯消元
        int result = Code04_GaussXorTemplate.gauss(n);
        System.out.println("随机矩阵结果:" + result);
    }
    
    /**
     * 测试多语言实现的一致性
     */
    public static void testCrossLanguageConsistency() {
        System.out.println("\n=== 测试5: 多语言实现一致性 ===");
        
        // 测试用例：简单异或方程组
        System.out.println("测试简单异或方程组的一致性:");
        
        // Java实现测试
        System.out.println("Java实现:");
        int n = 2;
        Code04_GaussXorTemplate.mat[1][1] = 1; Code04_GaussXorTemplate.mat[1][2] = 0; Code04_GaussXorTemplate.mat[1][3] = 1;
        Code04_GaussXorTemplate.mat[2][1] = 0; Code04_GaussXorTemplate.mat[2][2] = 1; Code04_GaussXorTemplate.mat[2][3] = 0;
        int javaResult = Code04_GaussXorTemplate.gauss(n);
        System.out.println("Java结果:" + javaResult);
        
        // 理论上C++和Python应该得到相同结果
        System.out.println("理论上C++和Python应该得到相同结果:" + javaResult);
        System.out.println("（需要实际运行C++和Python代码进行验证）");
    }
    
    /**
     * 运行所有测试
     */
    public static void runAllTests() {
        System.out.println("开始执行高斯消元与线性基算法全面测试...\n");
        
        // 执行所有测试
        testBasicGauss();
        testLinearBasis();
        testEdgeCases();
        testPerformance();
        testCrossLanguageConsistency();
        
        System.out.println("\n=== 测试完成 ===");
        System.out.println("所有测试执行完毕！");
    }
    
    /**
     * 主函数
     */
    public static void main(String[] args) {
        // 运行全面测试
        runAllTests();
        
        // 运行单元测试
        System.out.println("\n=== 运行单元测试 ===");
        Code04_GaussXorTemplate.runUnitTests();
        
        // 输出语言特性对比
        System.out.println("\n=== 语言特性对比 ===");
        Code04_GaussXorTemplate.languageFeatureComparison();
        
        // 输出性能优化建议
        System.out.println("\n=== 性能优化建议 ===");
        Code04_GaussXorTemplate.performanceOptimizationTips();
    }
}

===============================================

