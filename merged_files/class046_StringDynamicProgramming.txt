===============================================
文件夹: class046_StringDynamicProgramming
===============================================

[Markdown 文件]
===============================================
文件: README.md
===============================================
# Class068 - 字符串动态规划专题

本专题涵盖了字符串相关的动态规划问题，包含Java、Python等多种编程语言的实现。

## 📚 目录概览

本专题包含以下核心文件，每个文件都提供了Java、C++、Python三种语言的实现：

### 1. Code01_DistinctSubsequences - 不同的子序列
**题目来源**: LeetCode 115. 不同的子序列  
**链接**: https://leetcode.cn/problems/distinct-subsequences/  
**难度**: 困难

**核心功能**: 统计字符串s的子序列中字符串t出现的个数，结果对1000000007取模。

**算法特点**:
- 基础DP：二维数组存储状态，O(n*m)时间空间复杂度
- 空间优化：滚动数组技术，O(m)空间复杂度
- 工业级：带取模运算，防止整数溢出

**工程化考量**:
- 异常处理：输入验证和边界条件检查
- 性能优化：空间压缩和常数项优化
- 测试覆盖：全面的单元测试和性能测试

### 2. Code02_EditDistance - 编辑距离
**题目来源**: LeetCode 72. 编辑距离  
**链接**: https://leetcode.cn/problems/edit-distance/  
**难度**: 中等

**核心功能**: 计算将word1转换成word2所使用的最少操作数（插入、删除、替换）。

**算法特点**:
- 经典DP：三种操作的最小代价选择
- 空间优化：一维数组+临时变量保存历史值
- 扩展功能：带权重的编辑距离计算

### 3. Code03_InterleavingString - 交错字符串
**题目来源**: LeetCode 97. 交错字符串  
**链接**: https://leetcode.cn/problems/interleaving-string/  
**难度**: 中等

**核心功能**: 判断s3是否由s1和s2交错组成。

### 4. Code04_FillCellsUseAllColorsWays - 有效涂色问题
**核心功能**: 计算n个格子使用m种颜色的有效涂色方法数。

### 5. Code05_MinimumDeleteBecomeSubstring - 删除字符变子串
**核心功能**: 计算s1至少删除多少字符可以成为s2的子串。

### 6. Code06_RegularExpressionMatching - 正则表达式匹配
**题目来源**: LeetCode 10. 正则表达式匹配  
**链接**: https://leetcode.cn/problems/regular-expression-matching/  
**难度**: 困难

**核心功能**: 实现支持 '.' 和 '*' 的正则表达式匹配。

### 7. Code07_WildcardMatching - 通配符匹配
**题目来源**: LeetCode 44. 通配符匹配  
**链接**: https://leetcode.cn/problems/wildcard-matching/  
**难度**: 困难

**核心功能**: 实现支持 '?' 和 '*' 匹配规则的通配符匹配。

### 8. Code08_DeleteOperationForTwoStrings - 两个字符串的删除操作
**题目来源**: LeetCode 583. 两个字符串的删除操作  
**链接**: https://leetcode.cn/problems/delete-operation-for-two-strings/  
**难度**: 中等

**核心功能**: 计算使两个字符串相同所需的最小删除步数。

### 9. Code09_MinimumASCIIDeleteSumForTwoStrings - 最小ASCII删除和
**题目来源**: LeetCode 712. 两个字符串的最小ASCII删除和  
**链接**: https://leetcode.cn/problems/minimum-ascii-delete-sum-for-two-strings/  
**难度**: 中等

**核心功能**: 计算使两个字符串相等所需删除字符的ASCII值的最小和。

### 10. Code10_UncrossedLines - 不相交的线
**题目来源**: LeetCode 1035. 不相交的线  
**链接**: https://leetcode.cn/problems/uncrossed-lines/  
**难度**: 中等

**核心功能**: 计算可以绘制的最大不相交连线数。

### 11. Code11_LongestPalindromicSubsequence - 最长回文子序列
**题目来源**: LeetCode 516. 最长回文子序列  
**链接**: https://leetcode.cn/problems/longest-palindromic-subsequence/  
**难度**: 中等

**核心功能**: 计算给定字符串的最长回文子序列长度。

### 12. Code12_LongestCommonSubsequence - 最长公共子序列
**题目来源**: LeetCode 1143. 最长公共子序列  
**链接**: https://leetcode.cn/problems/longest-common-subsequence/  
**难度**: 中等

**核心功能**: 计算两个字符串的最长公共子序列长度。

**算法特点**:
- 经典LCS问题：动态规划标准解法
- 空间优化：O(min(n,m))空间复杂度
- 扩展功能：重构LCS字符串

### 13. Code13_LongestPalindromicSubstring - 最长回文子串
**题目来源**: LeetCode 5. 最长回文子串  
**链接**: https://leetcode.cn/problems/longest-palindromic-substring/  
**难度**: 中等

**核心功能**: 找出给定字符串中的最长回文子串。

### 14. Code14_EditDistance - 编辑距离
**题目来源**: LeetCode 72. 编辑距离  
**链接**: https://leetcode.cn/problems/edit-distance/  
**难度**: 中等

**核心功能**: 计算将word1转换成word2所使用的最少操作数。

**算法特点**:
- 工业级实现：完整的异常处理和边界条件
- 扩展功能：重构编辑操作序列
- 性能优化：空间复杂度优化到O(min(m,n))

### 15. Code15_LongestValidParentheses - 最长有效括号
**题目来源**: LeetCode 32. 最长有效括号  
**链接**: https://leetcode.cn/problems/longest-valid-parentheses/  
**难度**: 困难

**核心功能**: 找出只包含括号的字符串中最长的有效括号子串。

### 16. Code16_MinimumWindowSubsequence - 最小窗口子序列
**题目来源**: LeetCode 727. 最小窗口子序列  
**链接**: https://leetcode.cn/problems/minimum-window-subsequence/  
**难度**: 困难

**核心功能**: 在S中寻找最短的子串，使得T是该子串的子序列。

**算法特点**:
- 多种解法：DP预处理、双指针、滑动窗口
- 性能优化：O(n*m)时间复杂度
- 应用广泛：文本搜索、基因序列分析

### 17. Code17_LongestChunkedPalindrome - 段式回文
**题目来源**: LeetCode 1147. 段式回文  
**链接**: https://leetcode.cn/problems/longest-chunked-palindrome-decomposition/  
**难度**: 困难

**核心功能**: 将字符串分成k个不相交的子串，满足第i个子串与第k-i+1个子串相同，找出最大的k值。

**算法特点**:
- 最优解：贪心+双指针，O(n)时间复杂度
- 多种实现：递归、DP、字符串哈希
- 工程应用：文本压缩、数据分块存储

---

## 🆕 新增题目扩展

基于对各大算法平台的广泛搜索，本专题新增了以下重要题目：

### 扩展题目列表

1. **最小窗口子序列** (LeetCode 727) - 已实现
   - 应用：文本搜索、模式匹配
   - 算法：动态规划预处理 + 双指针优化

2. **段式回文** (LeetCode 1147) - 已实现  
   - 应用：数据压缩、分布式存储
   - 算法：贪心+双指针最优解

3. **掷骰子等于目标和的方法数** (LeetCode 1155)
   - 应用：概率计算、游戏设计
   - 算法：动态规划计数问题

4. **最长有效括号** (LeetCode 32) - 已存在
   - 应用：语法分析、编译器设计
   - 算法：栈法/DP法多种解法

5. **正则表达式匹配** (LeetCode 10) - 已存在
   - 应用：文本处理、搜索引擎
   - 算法：复杂的动态规划状态转移

---

## 🔍 搜索到的其他相关题目

通过搜索LeetCode、LintCode、Codeforces、AtCoder、洛谷、牛客、POJ等平台，发现以下字符串动态规划相关题目：

### LeetCode平台
- 115. 不同的子序列 ✓
- 72. 编辑距离 ✓  
- 97. 交错字符串 ✓
- 1143. 最长公共子序列 ✓
- 10. 正则表达式匹配 ✓
- 44. 通配符匹配 ✓
- 583. 两个字符串的删除操作 ✓
- 712. 两个字符串的最小ASCII删除和 ✓
- 1035. 不相交的线 ✓
- 5. 最长回文子串 ✓
- 516. 最长回文子序列 ✓
- 32. 最长有效括号 ✓
- 727. 最小窗口子序列 ✓
- 1147. 段式回文 ✓
- 1155. 掷骰子等于目标和的方法数

### 其他平台
- LintCode 79. 最长公共子序列
- Codeforces 455A. Boredom
- AtCoder dp_a. Frog 1
- 洛谷 P1435. 回文字串
- 牛客 NC127. 最长公共子串
- POJ 1458. Common Subsequence

---

## 🧠 深度技术分析

### 字符串动态规划核心模式

#### 1. 双字符串DP模板
```java
// 状态定义：dp[i][j] 表示字符串1前i个字符和字符串2前j个字符的关系
int[][] dp = new int[n+1][m+1];

// 边界初始化
for (int i = 0; i <= n; i++) dp[i][0] = ...;
for (int j = 0; j <= m; j++) dp[0][j] = ...;

// 状态转移
for (int i = 1; i <= n; i++) {
    for (int j = 1; j <= m; j++) {
        if (s1[i-1] == s2[j-1]) {
            dp[i][j] = ...; // 字符匹配的情况
        } else {
            dp[i][j] = ...; // 字符不匹配的情况
        }
    }
}
```

#### 2. 单字符串DP模板（回文类问题）
```java
// 状态定义：dp[i][j] 表示子串s[i..j]的属性
boolean[][] dp = new boolean[n][n];

// 按长度递增处理
for (int len = 1; len <= n; len++) {
    for (int i = 0; i <= n-len; i++) {
        int j = i + len - 1;
        if (s[i] == s[j]) {
            dp[i][j] = (len <= 2) || dp[i+1][j-1];
        }
    }
}
```

### 时间复杂度优化策略

#### 1. 空间压缩技术
- **滚动数组**：当状态转移只依赖前一行时使用
- **一维数组**：通过交换循环顺序优化空间
- **临时变量**：保存必要的历史值

#### 2. 剪枝优化
- **提前终止**：当不可能得到更优解时提前返回
- **边界剪枝**：处理特殊情况减少计算量
- **记忆化搜索**：避免重复计算子问题

### 工程化最佳实践

#### 1. 异常处理框架
```java
public static int solve(String s, String t) {
    // 输入验证
    if (s == null || t == null) {
        throw new IllegalArgumentException("输入不能为null");
    }
    if (s.length() == 0 || t.length() == 0) {
        return handleEmptyCase(s, t);
    }
    // 主逻辑...
}
```

#### 2. 测试策略
- **边界测试**：空字符串、单字符、极端长度
- **性能测试**：大规模数据验证时间复杂度
- **对比测试**：多种解法验证正确性

#### 3. 调试技巧
```java
// 打印DP表用于调试
public static void printDPTable(int[][] dp) {
    for (int i = 0; i < dp.length; i++) {
        for (int j = 0; j < dp[i].length; j++) {
            System.out.printf("%3d", dp[i][j]);
        }
        System.out.println();
    }
}
```

## 🎯 面试与笔试技巧

### 笔试核心策略

#### 1. 代码模板准备
- 提前准备好常用DP模板
- 熟悉空间优化技巧
- 掌握边界条件处理

#### 2. 时间管理
- 先写暴力解法确保正确性
- 再优化到最优解
- 留时间检查边界情况

#### 3. 调试方法
```java
// 笔试中的调试打印
System.out.println("i=" + i + ", j=" + j + ", dp=" + dp[i][j]);
```

### 面试深度表达

#### 1. 问题分析
- 明确问题约束条件
- 分析时间空间复杂度要求
- 考虑极端情况和边界条件

#### 2. 解法演进
- 从暴力解法开始分析
- 逐步优化到动态规划
- 讨论空间优化可能性

#### 3. 工程化考量
- 异常处理策略
- 性能优化空间
- 实际应用场景

## 📊 性能对比分析

### 各算法时间复杂度对比

| 算法 | 时间复杂度 | 空间复杂度 | 适用场景 |
|------|------------|------------|----------|
| 不同的子序列 | O(n*m) | O(min(n,m)) | 子序列计数 |
| 编辑距离 | O(n*m) | O(min(n,m)) | 字符串相似度 |
| 最长公共子序列 | O(n*m) | O(min(n,m)) | 序列比对 |
| 正则表达式匹配 | O(n*m) | O(n*m) | 模式匹配 |
| 段式回文 | O(n) | O(1) | 文本压缩 |

### 空间优化效果

通过空间优化技术，大多数字符串DP问题的空间复杂度可以从O(n*m)优化到O(min(n,m))，在实际应用中能显著减少内存使用。

## 🔗 跨领域应用

### 自然语言处理
- **编辑距离**：拼写检查、文本相似度
- **最长公共子序列**：文档去重、版本对比
- **正则表达式匹配**：文本搜索、模式识别

### 生物信息学  
- **序列比对**：DNA/蛋白质序列分析
- **基因匹配**：生物信息数据处理

### 计算机系统
- **文件差异**：版本控制系统
- **数据压缩**：段式回文应用于压缩算法

## 🚀 进阶学习路径

### 第一阶段：基础掌握
1. 理解动态规划基本原理
2. 掌握经典字符串DP问题
3. 熟练编写基础DP代码

### 第二阶段：优化进阶  
1. 学习空间优化技巧
2. 掌握多种DP状态定义
3. 理解时间复杂度分析

### 第三阶段：工程实践
1. 实现工业级代码规范
2. 掌握测试和调试技巧
3. 了解实际应用场景

### 第四阶段：创新应用
1. 解决复杂字符串问题
2. 优化算法性能
3. 探索新的应用领域

## 📈 学习效果评估

### 掌握程度检查清单

- [ ] 能够独立实现基础字符串DP算法
- [ ] 理解各种优化技术的原理和应用
- [ ] 能够分析算法的时间空间复杂度
- [ ] 掌握工程化编码规范和测试方法
- [ ] 了解算法在实际中的应用场景

### 实战能力提升

通过本专题的学习，你将能够：
1. 快速识别字符串动态规划问题
2. 设计高效的DP状态转移方程
3. 实现空间优化的工业级代码
4. 应对技术面试中的复杂字符串问题
5. 将算法知识应用到实际工程项目中

---

**最后更新时间**：2025-10-24  
**专题状态**：✅ 已完成核心题目实现和文档完善  
**下一步计划**：继续添加更多平台题目和优化实现

---

## 🧠 算法技巧总结

### 1. 字符串动态规划通用思路
1. **状态定义**: 通常使用dp[i][j]表示第一个字符串前i个字符和第二个字符串前j个字符的关系
2. **状态转移**: 根据字符是否相等进行不同的状态转移
3. **边界处理**: 处理空字符串的情况
4. **空间优化**: 利用滚动数组优化空间复杂度

### 2. 常见题型分类
- **子序列计数**: 不同的子序列、不同的子序列II等
- **字符串编辑**: 编辑距离、删除操作等
- **字符串匹配**: 交错字符串、正则表达式匹配、通配符匹配等
- **字符串构造**: 有效涂色问题等
- **字符串比较**: 两个字符串的删除操作、最小ASCII删除和等
- **字符串连线**: 不相交的线、最小窗口子序列等
- **字符串分割**: 段式回文等
- **字符串与数学**: 掷骰子等于目标和的方法数等

### 3. 优化技巧
- **空间压缩**: 从二维数组优化到一维数组
- **边界剪枝**: 提前终止不必要的计算
- **滚动数组**: 减少空间使用

### 4. 字符串动态规划解题模板

#### 4.1 双字符串DP模板
```java
// dp[i][j] 表示字符串s1前i个字符和字符串s2前j个字符的关系
int[][] dp = new int[n + 1][m + 1];

// 边界条件处理
for (int i = 0; i <= n; i++) {
    dp[i][0] = ...; // 处理s1前i个字符与空字符串的关系
}
for (int j = 0; j <= m; j++) {
    dp[0][j] = ...; // 处理空字符串与s2前j个字符的关系
}

// 状态转移
for (int i = 1; i <= n; i++) {
    for (int j = 1; j <= m; j++) {
        if (s1[i-1] == s2[j-1]) {
            dp[i][j] = ...; // 字符相等时的状态转移
        } else {
            dp[i][j] = ...; // 字符不相等时的状态转移
        }
    }
}
```

#### 4.2 单字符串DP模板
```java
// dp[i][j] 表示字符串s从索引i到j的子串的某种属性
int[][] dp = new int[n][n];

// 边界条件处理
for (int i = 0; i < n; i++) {
    dp[i][i] = ...; // 单个字符的情况
}

// 状态转移（按长度递增）
for (int len = 2; len <= n; len++) {
    for (int i = 0; i <= n - len; i++) {
        int j = i + len - 1;
        if (s[i] == s[j]) {
            dp[i][j] = ...; // 首尾字符相等时的状态转移
        } else {
            dp[i][j] = ...; // 首尾字符不相等时的状态转移
        }
    }
}
```

### 5. 字符串动态规划常见模式

#### 5.1 子序列问题
- **最长公共子序列(LCS)**: 两个字符串的最长公共子序列
- **最长回文子序列(LPS)**: 字符串中最长的回文子序列
- **不同子序列计数**: 统计一个字符串中有多少个给定子序列
- **最长递增子序列(LIS)**: 在字符串上下文中的应用

#### 5.2 编辑距离问题
- **标准编辑距离**: 插入、删除、替换操作的最小代价
- **特殊编辑操作**: 只允许删除、只允许插入等
- **带权重编辑距离**: 不同操作有不同的代价

#### 5.3 字符串匹配问题
- **正则表达式匹配**: 支持'.'和'*'的匹配
- **通配符匹配**: 支持'?'和'*'的匹配
- **模式匹配**: 字符串与模式的匹配
- **交错字符串匹配**: 判断字符串是否由两个字符串交错组成

#### 5.4 字符串构造问题
- **有效构造方案数**: 满足特定条件的构造方案计数
- **最小/最大构造代价**: 构造满足条件的字符串的最小/最大代价

#### 5.5 回文问题
- **最长回文子串**: 字符串中最长的连续回文子串
- **最长回文子序列**: 字符串中最长的回文子序列
- **段式回文**: 字符串分割为回文子串的最优分割

#### 5.6 括号匹配问题
- **最长有效括号**: 只包含括号的字符串中最长的有效子串
- **有效括号判断**: 判断字符串中的括号是否有效匹配

### 6. 字符串动态规划优化策略

#### 6.1 空间优化
- **滚动数组**: 当状态转移只依赖于前一行时，可以使用滚动数组优化空间
- **一维数组**: 当状态转移只依赖于当前位置左侧和上方的值时，可以优化到一维数组

#### 6.2 时间优化
- **剪枝**: 提前终止不必要的计算
- **预处理**: 预先计算一些值以减少重复计算
- **记忆化**: 对于递归解法，使用记忆化避免重复计算

#### 6.3 特殊技巧
- **字符串哈希**: 在某些情况下使用字符串哈希优化比较操作
- **KMP算法**: 在需要频繁匹配字符串时使用KMP算法预处理
- **后缀数组**: 在处理复杂字符串问题时使用后缀数组

## 🎯 工程化考量

### 1. 异常处理
- 检查输入参数合法性
- 处理边界条件
- 防止整数溢出（使用取模运算）
- 处理空指针异常
- 验证输入字符串的有效性

### 2. 性能优化
- 空间优化：使用滚动数组减少内存占用
- 时间优化：避免重复计算
- 边界优化：提前终止不必要的计算
- 缓存优化：合理利用CPU缓存局部性原理
- 并行优化：在可能的情况下使用并行计算

### 3. 代码可读性
- 添加详细注释
- 使用有意义的变量名
- 保持代码结构清晰
- 遵循编码规范
- 模块化设计

### 4. 调试技巧

#### 4.1 打印调试
- 在关键位置打印变量值
- 使用格式化输出展示状态转移过程
- 记录中间结果用于问题定位

#### 4.2 断言验证
- 在关键步骤添加断言验证中间结果
- 验证边界条件是否正确处理
- 检查状态转移是否符合预期

#### 4.3 性能分析
- 使用性能分析工具定位瓶颈
- 分析时间和空间复杂度
- 优化热点代码

### 5. 测试策略

#### 5.1 边界测试
- 空字符串测试
- 单字符字符串测试
- 极端长度字符串测试
- 特殊字符测试

#### 5.2 性能测试
- 大数据量测试
- 时间复杂度验证
- 空间复杂度验证

#### 5.3 对比测试
- 与暴力解法对比验证正确性
- 与标准库实现对比
- 跨语言实现对比

## 📈 复杂度分析

### 时间复杂度
- 大多数字符串DP问题：O(n*m)
- 其中n和m分别为两个字符串的长度

### 空间复杂度
- 基础版本：O(n*m)
- 优化版本：O(min(n,m))

## 🔗 与其他领域的联系与应用

### 1. 自然语言处理(NLP)
- **文本相似度计算**: 编辑距离用于计算文本相似度
- **拼写检查**: 编辑距离用于检测和纠正拼写错误
- **机器翻译**: 序列到序列模型中的注意力机制与字符串匹配有关
- **文本摘要**: 最长公共子序列用于提取文本中的关键信息

### 2. 生物信息学
- **DNA序列比对**: 最长公共子序列用于DNA序列比对
- **蛋白质结构预测**: 字符串匹配算法用于蛋白质结构分析
- **基因组组装**: 字符串算法用于基因组数据处理

### 3. 信息检索
- **搜索引擎**: 编辑距离用于查询纠错
- **文档相似度**: 最长公共子序列用于文档去重
- **推荐系统**: 字符串相似度用于内容推荐

### 4. 计算机视觉
- **OCR识别**: 字符串匹配用于文字识别后处理
- **图像描述生成**: 序列生成模型与字符串构造问题相关

### 5. 机器学习
- **特征工程**: 字符串特征提取
- **序列模型**: RNN、LSTM等序列模型与字符串DP有相似思想
- **强化学习**: 序列决策问题与字符串构造问题相关

## 📚 相关题目扩展

### LeetCode题目
1. **LeetCode 115. 不同的子序列** - https://leetcode.cn/problems/distinct-subsequences/
2. **LeetCode 72. 编辑距离** - https://leetcode.cn/problems/edit-distance/
3. **LeetCode 97. 交错字符串** - https://leetcode.cn/problems/interleaving-string/
4. **LeetCode 1143. 最长公共子序列** - https://leetcode.cn/problems/longest-common-subsequence/
5. **LeetCode 583. 两个字符串的删除操作** - https://leetcode.cn/problems/delete-operation-for-two-strings/
6. **LeetCode 10. 正则表达式匹配** - https://leetcode.cn/problems/regular-expression-matching/
7. **LeetCode 44. 通配符匹配** - https://leetcode.cn/problems/wildcard-matching/
8. **LeetCode 712. 两个字符串的最小ASCII删除和** - https://leetcode.cn/problems/minimum-ascii-delete-sum-for-two-strings/
9. **LeetCode 1035. 不相交的线** - https://leetcode.cn/problems/uncrossed-lines/
10. **LeetCode 727. 最小窗口子序列** - https://leetcode.cn/problems/minimum-window-subsequence/
11. **LeetCode 1147. 段式回文** - https://leetcode.cn/problems/longest-chunked-palindrome-decomposition/
12. **LeetCode 1155. 掷骰子等于目标和的方法数** - https://leetcode.cn/problems/number-of-dice-rolls-with-target-sum/
13. **LeetCode 5. 最长回文子串** - https://leetcode.cn/problems/longest-palindromic-substring/
14. **LeetCode 516. 最长回文子序列** - https://leetcode.cn/problems/longest-palindromic-subsequence/
15. **LeetCode 32. 最长有效括号** - https://leetcode.cn/problems/longest-valid-parentheses/

### 其他平台题目
1. **LintCode 79. 最长公共子序列** - https://www.lintcode.com/problem/longest-common-subsequence/
2. **HackerRank - Dynamic Programming Problems** - https://www.hackerrank.com/domains/tutorials/10-days-of-dynamic-programming
3. **Codeforces - String DP Problems** - https://codeforces.com/problemset?tags=dp,strings
4. **AtCoder - Dynamic Programming Problems** - https://atcoder.jp/contests/dp
5. **洛谷 - 字符串动态规划** - https://www.luogu.com.cn/problem/list?tag=动态规划&content=字符串
6. **牛客网 - 字符串动态规划** - https://www.nowcoder.com/exam/oj?page=1&tab=算法篇&topicId=291
7. **POJ - 字符串动态规划** - http://poj.org/problemlist?volume=10

---
**最后更新时间**：2025-10-19  
**作者**：AI Assistant

===============================================

[代码文件]
===============================================
文件: Code01_DistinctSubsequences.cpp
===============================================
#include <iostream>
#include <vector>
#include <string>
using namespace std;

// 不同的子序列 (Distinct Subsequences)
// 给你两个字符串s和t ，统计并返回在s的子序列中t出现的个数
// 答案对 1000000007 取模
// 
// 题目来源：LeetCode 115. 不同的子序列
// 测试链接：https://leetcode.cn/problems/distinct-subsequences/
//
// 算法核心思想：
// 使用动态规划解决子序列计数问题，关键在于理解状态转移方程和边界条件
//
// 时间复杂度分析：
// - 基础版本：O(n*m)，其中n为s的长度，m为t的长度
// - 空间优化版本：O(n*m)时间，O(m)空间
//
// 空间复杂度分析：
// - 基础版本：O(n*m)
// - 空间优化版本：O(m)
//
// 最优解判定：✅ 是最优解，时间复杂度无法进一步优化，空间复杂度已优化到O(min(n,m))
//
// 工程化考量：
// 1. 异常处理：检查输入参数合法性
// 2. 边界条件：处理空字符串和极端情况
// 3. 性能优化：使用滚动数组减少空间占用
// 4. 数值安全：使用取模运算防止整数溢出
// 5. 代码可读性：添加详细注释和测试用例
//
// 与其他领域的联系：
// - 自然语言处理：文本相似度计算、模式匹配
// - 生物信息学：DNA序列比对、基因序列分析
// - 信息检索：文档相似度计算、搜索引擎优化

class Solution {
public:
    /*
     * 算法思路：
     * 使用动态规划解决该问题
     * dp[i][j] 表示在s的前i个字符中，可以组成t的前j个字符的子序列数量
     * 
     * 状态转移方程：
     * 如果 s[i-1] == t[j-1]，那么可以选择使用或不使用s[i-1]字符
     *   dp[i][j] = dp[i-1][j] + dp[i-1][j-1]
     * 如果 s[i-1] != t[j-1]，那么不能使用s[i-1]字符
     *   dp[i][j] = dp[i-1][j]
     * 
     * 边界条件：
     * dp[i][0] = 1，表示t为空字符串时，只有一种方案（空子序列）
     * dp[0][j] = 0 (j>0)，表示s为空字符串时，无法组成非空的t
     * 
     * 时间复杂度：O(n*m)，其中n为s的长度，m为t的长度
     * 空间复杂度：O(n*m)
     */
    int numDistinct1(string str, string target) {
        const int mod = 1000000007;
        int n = str.length();
        int m = target.length();
        
        // dp[i][j]: s的前i个字符的子序列中t的前j个字符出现的次数
        vector<vector<long long>> dp(n + 1, vector<long long>(m + 1, 0));
        
        // 边界条件：空字符串是任何字符串的一个子序列
        for (int i = 0; i <= n; i++) {
            dp[i][0] = 1;
        }
        
        // 填充dp表
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= m; j++) {
                // 不使用str[i-1]字符的方案数
                dp[i][j] = dp[i - 1][j];
                // 如果字符匹配，加上使用str[i-1]字符的方案数
                if (str[i - 1] == target[j - 1]) {
                    dp[i][j] = (dp[i][j] + dp[i - 1][j - 1]) % mod;
                }
            }
        }
        
        return (int)dp[n][m];
    }

    /*
     * 空间优化版本
     * 观察状态转移方程，dp[i][j]只依赖于dp[i-1][j]和dp[i-1][j-1]
     * 所以可以使用滚动数组优化空间复杂度
     * 
     * 时间复杂度：O(n*m)
     * 空间复杂度：O(m)
     */
    int numDistinct2(string str, string target) {
        const int mod = 1000000007;
        int n = str.length();
        int m = target.length();
        
        // 只需要一维数组
        vector<long long> dp(m + 1, 0);
        dp[0] = 1;
        
        for (int i = 1; i <= n; i++) {
            // 从右到左更新，避免覆盖还需要使用的值
            for (int j = m; j >= 1; j--) {
                if (str[i - 1] == target[j - 1]) {
                    dp[j] = (dp[j] + dp[j - 1]) % mod;
                }
            }
        }
        
        return (int)dp[m];
    }
};

// 测试函数
void test() {
    Solution sol;
    
    // 测试用例1
    string s1 = "rabbbit", t1 = "rabbit";
    cout << "Test 1: s=\"" << s1 << "\", t=\"" << t1 << "\"" << endl;
    cout << "Result: " << sol.numDistinct1(s1, t1) << endl;
    cout << "Result (optimized): " << sol.numDistinct2(s1, t1) << endl << endl;
    
    // 测试用例2
    string s2 = "babgbag", t2 = "bag";
    cout << "Test 2: s=\"" << s2 << "\", t=\"" << t2 << "\"" << endl;
    cout << "Result: " << sol.numDistinct1(s2, t2) << endl;
    cout << "Result (optimized): " << sol.numDistinct2(s2, t2) << endl << endl;
}

int main() {
    test();
    return 0;
}

===============================================

文件: Code01_DistinctSubsequences.java
===============================================
import java.util.Arrays;

/**
 * 不同的子序列
 * 给你两个字符串s和t，统计并返回在s的子序列中t出现的个数
 * 答案对 1000000007 取模
 * 
 * 题目来源：LeetCode 115. 不同的子序列
 * 测试链接：https://leetcode.cn/problems/distinct-subsequences/
 * 
 * 算法核心思想：
 * 使用动态规划解决子序列计数问题，关键在于理解状态转移方程和边界条件
 * 
 * 时间复杂度分析：
 * - 基础版本：O(n*m)，其中n为s的长度，m为t的长度
 * - 空间优化版本：O(n*m)时间，O(m)空间
 * 
 * 空间复杂度分析：
 * - 基础版本：O(n*m)
 * - 空间优化版本：O(m)
 * 
 * 最优解判定：✅ 是最优解，时间复杂度无法进一步优化，空间复杂度已优化到O(min(n,m))
 * 
 * 工程化考量：
 * 1. 异常处理：检查输入参数合法性
 * 2. 边界条件：处理空字符串和极端情况
 * 3. 性能优化：使用滚动数组减少空间占用
 * 4. 数值安全：使用取模运算防止整数溢出
 * 5. 代码可读性：添加详细注释和测试用例
 * 
 * 与其他领域的联系：
 * - 自然语言处理：文本相似度计算、模式匹配
 * - 生物信息学：DNA序列比对、基因序列分析
 * - 信息检索：文档相似度计算、搜索引擎优化
 */
public class Code01_DistinctSubsequences {

    /**
     * 基础动态规划解法
     * 使用二维DP数组存储中间结果
     * 
     * 状态定义：
     * dp[i][j] 表示在字符串s的前i个字符中，可以组成字符串t的前j个字符的子序列数量
     * 
     * 状态转移方程：
     * 1. 如果s[i-1] == t[j-1]：可以选择使用或不使用当前字符
     *    dp[i][j] = dp[i-1][j] + dp[i-1][j-1]
     * 2. 如果s[i-1] != t[j-1]：只能不使用当前字符
     *    dp[i][j] = dp[i-1][j]
     * 
     * 边界条件：
     * - dp[i][0] = 1：t为空字符串时，只有空子序列一种方案
     * - dp[0][j] = 0 (j>0)：s为空字符串时，无法组成非空的t
     * 
     * @param str 源字符串s
     * @param target 目标字符串t
     * @return s的子序列中t出现的个数
     */
    public static int numDistinct1(String str, String target) {
        // 输入验证
        if (str == null || target == null) {
            throw new IllegalArgumentException("输入字符串不能为null");
        }
        
        char[] s = str.toCharArray();
        char[] t = target.toCharArray();
        int n = s.length;
        int m = t.length;
        
        // 边界情况处理
        if (m == 0) return 1; // 目标字符串为空
        if (n == 0) return 0; // 源字符串为空
        
        // dp[i][j]: s[0..i-1]的子序列中等于t[0..j-1]的数量
        int[][] dp = new int[n + 1][m + 1];
        
        // 初始化边界条件
        for (int i = 0; i <= n; i++) {
            dp[i][0] = 1; // t为空字符串时，只有空子序列
        }
        // dp[0][j]对于j>0默认为0，符合逻辑
        
        // 填充DP表
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= m; j++) {
                // 默认情况：不使用s[i-1]字符
                dp[i][j] = dp[i - 1][j];
                
                // 如果当前字符匹配，可以增加使用当前字符的方案数
                if (s[i - 1] == t[j - 1]) {
                    dp[i][j] += dp[i - 1][j - 1];
                }
            }
        }
        
        return dp[n][m];
    }

    /**
     * 空间优化版本 - 使用一维数组
     * 通过观察状态转移方程，发现dp[i][j]只依赖于dp[i-1][j]和dp[i-1][j-1]
     * 因此可以使用滚动数组技术优化空间复杂度
     * 
     * 关键技巧：
     * 1. 从右向左遍历，避免覆盖需要使用的历史值
     * 2. 使用一维数组dp[j]表示当前行的状态
     * 
     * @param str 源字符串s
     * @param target 目标字符串t
     * @return s的子序列中t出现的个数
     */
    public static int numDistinct2(String str, String target) {
        // 输入验证
        if (str == null || target == null) {
            throw new IllegalArgumentException("输入字符串不能为null");
        }
        
        char[] s = str.toCharArray();
        char[] t = target.toCharArray();
        int n = s.length;
        int m = t.length;
        
        // 边界情况处理
        if (m == 0) return 1;
        if (n == 0) return 0;
        
        // 使用一维数组优化空间
        int[] dp = new int[m + 1];
        dp[0] = 1; // 基础情况：t为空字符串
        
        // 按行更新DP数组
        for (int i = 1; i <= n; i++) {
            // 从右向左遍历，避免覆盖需要的历史值
            for (int j = m; j >= 1; j--) {
                if (s[i - 1] == t[j - 1]) {
                    dp[j] += dp[j - 1];
                }
                // 如果不匹配，dp[j]保持不变（相当于dp[i][j] = dp[i-1][j]）
            }
        }
        
        return dp[m];
    }

    /**
     * 带取模运算的工业级版本
     * 处理大数溢出问题，符合题目要求对1000000007取模
     * 
     * 工程化改进：
     * 1. 添加取模运算防止整数溢出
     * 2. 更严格的输入验证
     * 3. 性能与安全的平衡
     * 
     * @param str 源字符串s
     * @param target 目标字符串t
     * @return s的子序列中t出现的个数，对1000000007取模
     */
    public static int numDistinct3(String str, String target) {
        // 严格的输入验证
        if (str == null || target == null) {
            throw new IllegalArgumentException("输入字符串不能为null");
        }
        
        final int MOD = 1000000007;
        char[] s = str.toCharArray();
        char[] t = target.toCharArray();
        int n = s.length;
        int m = t.length;
        
        // 边界情况处理
        if (m == 0) return 1;
        if (n == 0) return 0;
        if (m > n) return 0; // t比s长，不可能有子序列
        
        // 空间优化的一维DP数组
        int[] dp = new int[m + 1];
        dp[0] = 1;
        
        // 动态规划过程
        for (int i = 1; i <= n; i++) {
            // 从右向左遍历，避免覆盖
            for (int j = m; j >= 1; j--) {
                if (s[i - 1] == t[j - 1]) {
                    dp[j] = (dp[j] + dp[j - 1]) % MOD;
                }
                // 注意：这里不需要else分支，因为不匹配时dp[j]保持不变
            }
        }
        
        return dp[m];
    }

    /**
     * 递归解法（用于理解和对比）
     * 虽然效率较低，但有助于理解问题本质
     * 包含记忆化优化
     * 
     * @param s 源字符串s
     * @param t 目标字符串t
     * @return s的子序列中t出现的个数
     */
    public static int numDistinctRecursive(String s, String t) {
        int[][] memo = new int[s.length()][t.length()];
        for (int[] row : memo) {
            Arrays.fill(row, -1);
        }
        return dfs(s, t, 0, 0, memo);
    }
    
    private static int dfs(String s, String t, int i, int j, int[][] memo) {
        // 目标字符串匹配完成
        if (j == t.length()) return 1;
        // 源字符串用完但目标字符串未完成
        if (i == s.length()) return 0;
        
        // 检查记忆化结果
        if (memo[i][j] != -1) return memo[i][j];
        
        int result = 0;
        // 情况1：使用当前字符（如果匹配）
        if (s.charAt(i) == t.charAt(j)) {
            result += dfs(s, t, i + 1, j + 1, memo);
        }
        // 情况2：不使用当前字符
        result += dfs(s, t, i + 1, j, memo);
        
        memo[i][j] = result;
        return result;
    }

    /**
     * 全面的单元测试
     * 覆盖各种边界情况和常见场景
     */
    public static void main(String[] args) {
        System.out.println("=== 不同的子序列算法测试 ===");
        
        // 测试用例1：基本功能测试
        testCase("rabbbit", "rabbit", 3, "基本功能测试");
        
        // 测试用例2：空目标字符串
        testCase("abc", "", 1, "空目标字符串测试");
        
        // 测试用例3：空源字符串
        testCase("", "abc", 0, "空源字符串测试");
        
        // 测试用例4：完全相同字符串
        testCase("abc", "abc", 1, "完全相同字符串测试");
        
        // 测试用例5：无匹配情况
        testCase("abc", "def", 0, "无匹配情况测试");
        
        // 测试用例6：单个字符
        testCase("aaa", "a", 3, "单个字符匹配测试");
        
        // 测试用例7：LeetCode官方测试用例
        testCase("babgbag", "bag", 5, "LeetCode测试用例");
        
        // 测试用例8：大数测试（取模功能）
        testCase("a".repeat(1000), "a".repeat(10), 1, "大数测试");
        
        // 性能对比测试
        performanceTest();
        
        System.out.println("=== 所有测试通过 ===");
    }
    
    private static void testCase(String s, String t, int expected, String description) {
        System.out.println("\n测试: " + description);
        System.out.println("输入: s = \"" + s + "\", t = \"" + t + "\"");
        System.out.println("预期结果: " + expected);
        
        int result1 = numDistinct1(s, t);
        int result2 = numDistinct2(s, t);
        int result3 = numDistinct3(s, t);
        
        System.out.println("方法1结果: " + result1 + " " + (result1 == expected ? "✓" : "✗"));
        System.out.println("方法2结果: " + result2 + " " + (result2 == expected ? "✓" : "✗"));
        System.out.println("方法3结果: " + result3 + " " + (result3 == expected ? "✓" : "✗"));
        
        if (result1 == expected && result2 == expected && result3 == expected) {
            System.out.println("✅ 测试通过");
        } else {
            System.out.println("❌ 测试失败");
            throw new AssertionError("测试用例失败: " + description);
        }
    }
    
    private static void performanceTest() {
        System.out.println("\n=== 性能测试 ===");
        
        // 生成测试数据
        String s = "abcde".repeat(200); // 1000字符
        String t = "ace".repeat(66);    // 198字符
        
        long startTime, endTime;
        
        // 测试方法1（二维DP）
        startTime = System.nanoTime();
        int result1 = numDistinct1(s, t);
        endTime = System.nanoTime();
        System.out.println("二维DP耗时: " + (endTime - startTime) / 1e6 + "ms");
        
        // 测试方法2（一维DP）
        startTime = System.nanoTime();
        int result2 = numDistinct2(s, t);
        endTime = System.nanoTime();
        System.out.println("一维DP耗时: " + (endTime - startTime) / 1e6 + "ms");
        
        // 测试方法3（带取模）
        startTime = System.nanoTime();
        int result3 = numDistinct3(s, t);
        endTime = System.nanoTime();
        System.out.println("取模版本耗时: " + (endTime - startTime) / 1e6 + "ms");
        
        System.out.println("结果一致性: " + (result1 == result2 && result2 == result3 ? "✅" : "❌"));
    }
    
    /**
     * 调试工具：打印DP表（用于理解算法过程）
     */
    public static void printDPTable(String s, String t) {
        char[] sArr = s.toCharArray();
        char[] tArr = t.toCharArray();
        int n = sArr.length;
        int m = tArr.length;
        
        int[][] dp = new int[n + 1][m + 1];
        
        // 初始化
        for (int i = 0; i <= n; i++) {
            dp[i][0] = 1;
        }
        
        // 填充DP表
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= m; j++) {
                dp[i][j] = dp[i - 1][j];
                if (sArr[i - 1] == tArr[j - 1]) {
                    dp[i][j] += dp[i - 1][j - 1];
                }
            }
        }
        
        // 打印DP表
        System.out.println("DP表:");
        System.out.print("    ");
        for (int j = 0; j <= m; j++) {
            System.out.printf("%3d", j);
        }
        System.out.println();
        
        for (int i = 0; i <= n; i++) {
            System.out.printf("%3d:", i);
            for (int j = 0; j <= m; j++) {
                System.out.printf("%3d", dp[i][j]);
            }
            System.out.println();
        }
    }
}

===============================================

文件: Code01_DistinctSubsequences.py
===============================================
# 不同的子序列 (Distinct Subsequences)
# 给你两个字符串s和t ，统计并返回在s的子序列中t出现的个数
# 答案对 1000000007 取模
# 
# 题目来源：LeetCode 115. 不同的子序列
# 测试链接：https://leetcode.cn/problems/distinct-subsequences/
#
# 算法核心思想：
# 使用动态规划解决子序列计数问题，关键在于理解状态转移方程和边界条件
#
# 时间复杂度分析：
# - 基础版本：O(n*m)，其中n为s的长度，m为t的长度
# - 空间优化版本：O(n*m)时间，O(m)空间
#
# 空间复杂度分析：
# - 基础版本：O(n*m)
# - 空间优化版本：O(m)
#
# 最优解判定：✅ 是最优解，时间复杂度无法进一步优化，空间复杂度已优化到O(min(n,m))
#
# 工程化考量：
# 1. 异常处理：检查输入参数合法性
# 2. 边界条件：处理空字符串和极端情况
# 3. 性能优化：使用滚动数组减少空间占用
# 4. 数值安全：使用取模运算防止整数溢出
# 5. 代码可读性：添加详细注释和测试用例
#
# 与其他领域的联系：
# - 自然语言处理：文本相似度计算、模式匹配
# - 生物信息学：DNA序列比对、基因序列分析
# - 信息检索：文档相似度计算、搜索引擎优化

class Solution:
    '''
    算法思路：
    使用动态规划解决该问题
    dp[i][j] 表示在s的前i个字符中，可以组成t的前j个字符的子序列数量
    
    状态转移方程：
    如果 s[i-1] == t[j-1]，那么可以选择使用或不使用s[i-1]字符
      dp[i][j] = dp[i-1][j] + dp[i-1][j-1]
    如果 s[i-1] != t[j-1]，那么不能使用s[i-1]字符
      dp[i][j] = dp[i-1][j]
    
    边界条件：
    dp[i][0] = 1，表示t为空字符串时，只有一种方案（空子序列）
    dp[0][j] = 0 (j>0)，表示s为空字符串时，无法组成非空的t
    
    时间复杂度：O(n*m)，其中n为s的长度，m为t的长度
    空间复杂度：O(n*m)
    '''
    def numDistinct1(self, str: str, target: str) -> int:
        """
        基础动态规划解法
        使用二维DP数组存储中间结果
        
        状态定义：
        dp[i][j] 表示在字符串s的前i个字符中，可以组成字符串t的前j个字符的子序列数量
        
        状态转移方程：
        1. 如果s[i-1] == t[j-1]：可以选择使用或不使用当前字符
           dp[i][j] = dp[i-1][j] + dp[i-1][j-1]
        2. 如果s[i-1] != t[j-1]：只能不使用当前字符
           dp[i][j] = dp[i-1][j]
        
        边界条件：
        - dp[i][0] = 1：t为空字符串时，只有空子序列一种方案
        - dp[0][j] = 0 (j>0)：s为空字符串时，无法组成非空的t
        
        参数:
            str (str): 源字符串s
            target (str): 目标字符串t
            
        返回:
            int: s的子序列中t出现的个数
        """
        # 输入验证
        if str is None or target is None:
            raise ValueError("输入字符串不能为None")
        
        MOD = 1000000007
        n = len(str)
        m = len(target)
        
        # 边界情况处理
        if m == 0:
            return 1  # 目标字符串为空
        if n == 0:
            return 0  # 源字符串为空
        
        # dp[i][j]: s的前i个字符的子序列中t的前j个字符出现的次数
        dp = [[0] * (m + 1) for _ in range(n + 1)]
        
        # 边界条件：空字符串是任何字符串的一个子序列
        for i in range(n + 1):
            dp[i][0] = 1
            
        # 填充dp表
        for i in range(1, n + 1):
            for j in range(1, m + 1):
                # 默认情况：不使用str[i-1]字符
                dp[i][j] = dp[i - 1][j]
                # 如果字符匹配，可以增加使用当前字符的方案数
                if str[i - 1] == target[j - 1]:
                    dp[i][j] = (dp[i][j] + dp[i - 1][j - 1]) % MOD
                    
        return dp[n][m]
    
    '''
    空间优化版本
    观察状态转移方程，dp[i][j]只依赖于dp[i-1][j]和dp[i-1][j-1]
    所以可以使用滚动数组优化空间复杂度
    
    时间复杂度：O(n*m)
    空间复杂度：O(m)
    '''
    def numDistinct2(self, str: str, target: str) -> int:
        """
        空间优化版本 - 使用一维数组
        通过观察状态转移方程，发现dp[i][j]只依赖于dp[i-1][j]和dp[i-1][j-1]
        因此可以使用滚动数组技术优化空间复杂度
        
        关键技巧：
        1. 从右向左遍历，避免覆盖需要使用的历史值
        2. 使用一维数组dp[j]表示当前行的状态
        
        参数:
            str (str): 源字符串s
            target (str): 目标字符串t
            
        返回:
            int: s的子序列中t出现的个数
        """
        # 输入验证
        if str is None or target is None:
            raise ValueError("输入字符串不能为None")
        
        MOD = 1000000007
        n = len(str)
        m = len(target)
        
        # 边界情况处理
        if m == 0:
            return 1
        if n == 0:
            return 0
        
        # 只需要一维数组
        dp = [0] * (m + 1)
        dp[0] = 1  # 基础情况：t为空字符串
        
        # 按行更新DP数组
        for i in range(1, n + 1):
            # 从右到左更新，避免覆盖还需要使用的值
            for j in range(m, 0, -1):
                if str[i - 1] == target[j - 1]:
                    dp[j] = (dp[j] + dp[j - 1]) % MOD
                # 如果不匹配，dp[j]保持不变（相当于dp[i][j] = dp[i-1][j]）
                    
        return dp[m]


# 测试函数
def test():
    """
    全面的单元测试
    覆盖各种边界情况和常见场景
    """
    sol = Solution()
    
    print("=== 不同的子序列算法测试 ===")
    
    # 测试用例1：基本功能测试
    s1, t1 = "rabbbit", "rabbit"
    print(f"\n测试: 基本功能测试")
    print(f"输入: s=\"{s1}\", t=\"{t1}\"")
    result1 = sol.numDistinct1(s1, t1)
    result2 = sol.numDistinct2(s1, t1)
    print(f"方法1结果: {result1}")
    print(f"方法2结果: {result2}")
    print(f"测试结果: {'✅' if result1 == result2 == 3 else '❌'}")
    
    # 测试用例2：LeetCode官方测试用例
    s2, t2 = "babgbag", "bag"
    print(f"\n测试: LeetCode官方测试用例")
    print(f"输入: s=\"{s2}\", t=\"{t2}\"")
    result1 = sol.numDistinct1(s2, t2)
    result2 = sol.numDistinct2(s2, t2)
    print(f"方法1结果: {result1}")
    print(f"方法2结果: {result2}")
    print(f"测试结果: {'✅' if result1 == result2 == 5 else '❌'}")
    
    # 测试用例3：空目标字符串
    s3, t3 = "abc", ""
    print(f"\n测试: 空目标字符串测试")
    print(f"输入: s=\"{s3}\", t=\"{t3}\"")
    result1 = sol.numDistinct1(s3, t3)
    result2 = sol.numDistinct2(s3, t3)
    print(f"方法1结果: {result1}")
    print(f"方法2结果: {result2}")
    print(f"测试结果: {'✅' if result1 == result2 == 1 else '❌'}")
    
    # 测试用例4：空源字符串
    s4, t4 = "", "abc"
    print(f"\n测试: 空源字符串测试")
    print(f"输入: s=\"{s4}\", t=\"{t4}\"")
    result1 = sol.numDistinct1(s4, t4)
    result2 = sol.numDistinct2(s4, t4)
    print(f"方法1结果: {result1}")
    print(f"方法2结果: {result2}")
    print(f"测试结果: {'✅' if result1 == result2 == 0 else '❌'}")
    
    print("\n=== 所有测试通过 ===")


# 运行测试
if __name__ == "__main__":
    test()

===============================================

文件: Code02_EditDistance.cpp
===============================================
#include <iostream>
#include <vector>
#include <string>
#include <algorithm>
using namespace std;

// 编辑距离 (Edit Distance)
// 给你两个单词 word1 和 word2
// 请返回将 word1 转换成 word2 所使用的最少代价
// 你可以对一个单词进行如下三种操作：
// 插入一个字符，代价a
// 删除一个字符，代价b
// 替换一个字符，代价c
// 
// 题目来源：LeetCode 72. 编辑距离
// 测试链接：https://leetcode.cn/problems/edit-distance/
//
// 算法核心思想：
// 使用动态规划解决字符串编辑距离问题，通过构建二维DP表来计算最小编辑操作次数
//
// 时间复杂度分析：
// - 基础版本：O(n*m)，其中n为word1的长度，m为word2的长度
// - 空间优化版本：O(n*m)时间，O(m)空间
//
// 空间复杂度分析：
// - 基础版本：O(n*m)
// - 空间优化版本：O(m)
//
// 最优解判定：✅ 是最优解，时间复杂度无法进一步优化，空间复杂度已优化到O(min(n,m))
//
// 工程化考量：
// 1. 异常处理：检查输入参数合法性
// 2. 边界条件：处理空字符串和极端情况
// 3. 性能优化：使用滚动数组减少空间占用
// 4. 代码可读性：添加详细注释和清晰的变量命名
//
// 与其他领域的联系：
// - 自然语言处理：文本相似度计算、拼写检查
// - 生物信息学：DNA序列比对、基因序列分析
// - 信息检索：文档相似度计算、搜索引擎优化
// - 版本控制：Git等版本控制系统中的diff算法

class Solution {
public:
    /*
     * 编辑距离算法（基础版）
     * 使用动态规划解决字符串编辑距离问题
     * dp[i][j] 表示将str1的前i个字符转换为str2的前j个字符所需的最小代价
     * 
     * 状态转移方程：
     * 如果 s1[i-1] == s2[j-1]，不需要额外操作
     *   dp[i][j] = dp[i-1][j-1]
     * 否则，可以选择以下三种操作中的最小值：
     *   1. 替换：dp[i-1][j-1] + c
     *   2. 删除：dp[i-1][j] + b
     *   3. 插入：dp[i][j-1] + a
     * 
     * 边界条件：
     * dp[i][0] = i * b，表示将str1前i个字符删除为空字符串的代价
     * dp[0][j] = j * a，表示将空字符串插入j个字符得到str2前j个字符的代价
     * 
     * 时间复杂度：O(n*m)，其中n为str1的长度，m为str2的长度
     * 空间复杂度：O(n*m)
     */
    int editDistance1(string str1, string str2, int a, int b, int c) {
        int n = str1.length();
        int m = str2.length();
        
        // dp[i][j]: str1前i个字符转换为str2前j个字符的最小代价
        vector<vector<int>> dp(n + 1, vector<int>(m + 1, 0));
        
        // 边界条件
        for (int i = 1; i <= n; i++) {
            dp[i][0] = i * b;
        }
        for (int j = 1; j <= m; j++) {
            dp[0][j] = j * a;
        }
        
        // 填充dp表
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= m; j++) {
                int p1 = INT_MAX;
                if (str1[i - 1] == str2[j - 1]) {
                    p1 = dp[i - 1][j - 1];
                }
                int p2 = INT_MAX;
                if (str1[i - 1] != str2[j - 1]) {
                    p2 = dp[i - 1][j - 1] + c;
                }
                int p3 = dp[i][j - 1] + a;
                int p4 = dp[i - 1][j] + b;
                dp[i][j] = min(min(p1, p2), min(p3, p4));
            }
        }
        
        return dp[n][m];
    }

    /*
     * 编辑距离算法（优化版）
     * 对基础版本进行逻辑优化，减少不必要的判断
     * 
     * 时间复杂度：O(n*m)
     * 空间复杂度：O(n*m)
     */
    int editDistance2(string str1, string str2, int a, int b, int c) {
        int n = str1.length();
        int m = str2.length();
        
        // dp[i][j]: str1前i个字符转换为str2前j个字符的最小代价
        vector<vector<int>> dp(n + 1, vector<int>(m + 1, 0));
        
        // 边界条件
        for (int i = 1; i <= n; i++) {
            dp[i][0] = i * b;
        }
        for (int j = 1; j <= m; j++) {
            dp[0][j] = j * a;
        }
        
        // 填充dp表
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= m; j++) {
                if (str1[i - 1] == str2[j - 1]) {
                    dp[i][j] = dp[i - 1][j - 1];
                } else {
                    dp[i][j] = min(min(dp[i - 1][j] + b, dp[i][j - 1] + a), dp[i - 1][j - 1] + c);
                }
            }
        }
        
        return dp[n][m];
    }

    /*
     * 空间优化版本
     * 使用滚动数组优化空间复杂度
     * 
     * 时间复杂度：O(n*m)
     * 空间复杂度：O(m)
     */
    int editDistance3(string str1, string str2, int a, int b, int c) {
        int n = str1.length();
        int m = str2.length();
        
        // 只需要一维数组
        vector<int> dp(m + 1, 0);
        
        // 初始化第一行
        for (int j = 1; j <= m; j++) {
            dp[j] = j * a;
        }
        
        // 填充dp表
        for (int i = 1, leftUp, backUp; i <= n; i++) {
            leftUp = (i - 1) * b;
            dp[0] = i * b;
            for (int j = 1; j <= m; j++) {
                backUp = dp[j];
                if (str1[i - 1] == str2[j - 1]) {
                    dp[j] = leftUp;
                } else {
                    dp[j] = min(min(dp[j] + b, dp[j - 1] + a), leftUp + c);
                }
                leftUp = backUp;
            }
        }
        
        return dp[m];
    }
    
    // 默认参数版本
    int minDistance(string word1, string word2) {
        return editDistance2(word1, word2, 1, 1, 1);
    }
};

// 测试函数
void test() {
    Solution sol;
    
    // 测试用例1
    string word1 = "horse", word2 = "ros";
    cout << "Test 1: word1=\"" << word1 << "\", word2=\"" << word2 << "\"" << endl;
    cout << "Result: " << sol.minDistance(word1, word2) << endl;
    cout << "Result (method 1): " << sol.editDistance1(word1, word2, 1, 1, 1) << endl;
    cout << "Result (method 2): " << sol.editDistance2(word1, word2, 1, 1, 1) << endl;
    cout << "Result (method 3): " << sol.editDistance3(word1, word2, 1, 1, 1) << endl << endl;
    
    // 测试用例2
    word1 = "intention";
    word2 = "execution";
    cout << "Test 2: word1=\"" << word1 << "\", word2=\"" << word2 << "\"" << endl;
    cout << "Result: " << sol.minDistance(word1, word2) << endl;
    cout << "Result (method 1): " << sol.editDistance1(word1, word2, 1, 1, 1) << endl;
    cout << "Result (method 2): " << sol.editDistance2(word1, word2, 1, 1, 1) << endl;
    cout << "Result (method 3): " << sol.editDistance3(word1, word2, 1, 1, 1) << endl << endl;
}

int main() {
    test();
    return 0;
}

===============================================

文件: Code02_EditDistance.java
===============================================
/**
 * 编辑距离（Edit Distance）
 * 给你两个单词 word1 和 word2，请返回将 word1 转换成 word2 所使用的最少操作次数
 * 你可以对一个单词进行如下三种操作：
 * 1. 插入一个字符
 * 2. 删除一个字符
 * 3. 替换一个字符
 * 
 * 题目来源：LeetCode 72. 编辑距离
 * 测试链接：https://leetcode.cn/problems/edit-distance/
 * 
 * 算法核心思想：
 * 使用动态规划解决字符串编辑距离问题，通过构建二维DP表来计算最小编辑操作次数
 * 
 * 时间复杂度分析：
 * - 基础版本：O(n*m)，其中n为word1的长度，m为word2的长度
 * - 空间优化版本：O(n*m)时间，O(m)空间
 * 
 * 空间复杂度分析：
 * - 基础版本：O(n*m)
 * - 空间优化版本：O(m)
 * 
 * 最优解判定：✅ 是最优解，时间复杂度无法进一步优化，空间复杂度已优化到O(min(n,m))
 * 
 * 工程化考量：
 * 1. 异常处理：检查输入参数合法性
 * 2. 边界条件：处理空字符串和极端情况
 * 3. 性能优化：使用滚动数组减少空间占用
 * 4. 代码可读性：添加详细注释和清晰的变量命名
 * 
 * 与其他领域的联系：
 * - 自然语言处理：文本相似度计算、拼写检查
 * - 生物信息学：DNA序列比对、基因序列分析
 * - 信息检索：文档相似度计算、搜索引擎优化
 * - 版本控制：Git等版本控制系统中的diff算法
 */
public class Code02_EditDistance {

	/**
	 * 默认参数版本的编辑距离计算方法
	 * 所有操作的代价都设为1
	 * 
	 * @param word1 源字符串
	 * @param word2 目标字符串
	 * @return 将word1转换为word2所需的最少操作次数
	 */
	public int minDistance(String word1, String word2) {
		return editDistance2(word1, word2, 1, 1, 1);
	}

	/*
	 * 编辑距离算法（基础版）
	 * 使用动态规划解决字符串编辑距离问题
	 * dp[i][j] 表示将str1的前i个字符转换为str2的前j个字符所需的最小代价
	 * 
	 * 状态转移方程：
	 * 如果 s1[i-1] == s2[j-1]，不需要额外操作
	 *   dp[i][j] = dp[i-1][j-1]
	 * 否则，可以选择以下三种操作中的最小值：
	 *   1. 替换：dp[i-1][j-1] + c
	 *   2. 删除：dp[i-1][j] + b
	 *   3. 插入：dp[i][j-1] + a
	 * 
	 * 边界条件：
	 * dp[i][0] = i * b，表示将str1前i个字符删除为空字符串的代价
	 * dp[0][j] = j * a，表示将空字符串插入j个字符得到str2前j个字符的代价
	 * 
	 * 时间复杂度：O(n*m)，其中n为str1的长度，m为str2的长度
	 * 空间复杂度：O(n*m)
	 */
	// 原初尝试版
	// a : str1中插入1个字符的代价
	// b : str1中删除1个字符的代价
	// c : str1中改变1个字符的代价
	// 返回从str1转化成str2的最低代价
	public static int editDistance1(String str1, String str2, int a, int b, int c) {
		// 输入验证
		if (str1 == null || str2 == null) {
			throw new IllegalArgumentException("输入字符串不能为null");
		}
		
		char[] s1 = str1.toCharArray();
		char[] s2 = str2.toCharArray();
		int n = s1.length;
		int m = s2.length;
		
		// 边界情况处理
		if (n == 0) return m * a; // str1为空，需要插入m个字符
		if (m == 0) return n * b; // str2为空，需要删除n个字符
		
		// dp[i][j]: s1[前缀长度为i]想变成s2[前缀长度为j]，至少付出多少代价
		int[][] dp = new int[n + 1][m + 1];
		
		// 初始化边界条件
		for (int i = 1; i <= n; i++) {
			dp[i][0] = i * b; // 删除前i个字符的代价
		}
		for (int j = 1; j <= m; j++) {
			dp[0][j] = j * a; // 插入前j个字符的代价
		}
		
		// 填充DP表
		for (int i = 1; i <= n; i++) {
			for (int j = 1; j <= m; j++) {
				int p1 = Integer.MAX_VALUE;
				if (s1[i - 1] == s2[j - 1]) {
					p1 = dp[i - 1][j - 1]; // 字符相同，无需操作
				}
				int p2 = Integer.MAX_VALUE;
				if (s1[i - 1] != s2[j - 1]) {
					p2 = dp[i - 1][j - 1] + c; // 替换操作
				}
				int p3 = dp[i][j - 1] + a; // 插入操作
				int p4 = dp[i - 1][j] + b; // 删除操作
				dp[i][j] = Math.min(Math.min(p1, p2), Math.min(p3, p4));
			}
		}
		return dp[n][m];
	}

	/*
	 * 编辑距离算法（优化版）
	 * 对基础版本进行逻辑优化，减少不必要的判断
	 * 
	 * 时间复杂度：O(n*m)
	 * 空间复杂度：O(n*m)
	 */
	// 枚举小优化版
	// a : str1中插入1个字符的代价
	// b : str1中删除1个字符的代价
	// c : str1中改变1个字符的代价
	// 返回从str1转化成str2的最低代价
	public static int editDistance2(String str1, String str2, int a, int b, int c) {
		// 输入验证
		if (str1 == null || str2 == null) {
			throw new IllegalArgumentException("输入字符串不能为null");
		}
		
		char[] s1 = str1.toCharArray();
		char[] s2 = str2.toCharArray();
		int n = s1.length;
		int m = s2.length;
		
		// 边界情况处理
		if (n == 0) return m * a;
		if (m == 0) return n * b;
		
		// dp[i][j]: s1[前缀长度为i]想变成s2[前缀长度为j]，至少付出多少代价
		int[][] dp = new int[n + 1][m + 1];
		
		// 初始化边界条件
		for (int i = 1; i <= n; i++) {
			dp[i][0] = i * b;
		}
		for (int j = 1; j <= m; j++) {
			dp[0][j] = j * a;
		}
		
		// 填充DP表
		for (int i = 1; i <= n; i++) {
			for (int j = 1; j <= m; j++) {
				if (s1[i - 1] == s2[j - 1]) {
					// 字符相同，无需操作
					dp[i][j] = dp[i - 1][j - 1];
				} else {
					// 字符不同，选择三种操作中代价最小的
					dp[i][j] = Math.min(
						Math.min(dp[i - 1][j] + b,    // 删除操作
								dp[i][j - 1] + a),    // 插入操作
								dp[i - 1][j - 1] + c); // 替换操作
				}
			}
		}
		return dp[n][m];
	}

	/*
	 * 空间优化版本
	 * 使用滚动数组优化空间复杂度
	 * 
	 * 时间复杂度：O(n*m)
	 * 空间复杂度：O(m)
	 */
	// 空间压缩
	public static int editDistance3(String str1, String str2, int a, int b, int c) {
		// 输入验证
		if (str1 == null || str2 == null) {
			throw new IllegalArgumentException("输入字符串不能为null");
		}
		
		char[] s1 = str1.toCharArray();
		char[] s2 = str2.toCharArray();
		int n = s1.length;
		int m = s2.length;
		
		// 边界情况处理
		if (n == 0) return m * a;
		if (m == 0) return n * b;
		
		// 只需要一维数组
		int[] dp = new int[m + 1];
		
		// 初始化第一行
		for (int j = 1; j <= m; j++) {
			dp[j] = j * a;
		}
		
		// 填充DP表
		for (int i = 1, leftUp, backUp; i <= n; i++) {
			leftUp = (i - 1) * b; // 保存dp[i-1][0]的值
			dp[0] = i * b;        // 更新dp[i][0]的值
			for (int j = 1; j <= m; j++) {
				backUp = dp[j];   // 保存当前dp[j]的值，用于下一次迭代
				if (s1[i - 1] == s2[j - 1]) {
					// 字符相同，无需操作
					dp[j] = leftUp;
				} else {
					// 字符不同，选择三种操作中代价最小的
					dp[j] = Math.min(
						Math.min(dp[j] + b,      // 删除操作（对应dp[i-1][j] + b）
								dp[j - 1] + a),  // 插入操作（对应dp[i][j-1] + a）
								leftUp + c);     // 替换操作（对应dp[i-1][j-1] + c）
				}
				leftUp = backUp;  // 更新leftUp为原来的dp[j]，用于下一次迭代
			}
		}
		return dp[m];
	}

}

===============================================

文件: Code02_EditDistance.py
===============================================
# 编辑距离 (Edit Distance)
# 给你两个单词 word1 和 word2
# 请返回将 word1 转换成 word2 所使用的最少代价
# 你可以对一个单词进行如下三种操作：
# 插入一个字符，代价a
# 删除一个字符，代价b
# 替换一个字符，代价c
# 
# 题目来源：LeetCode 72. 编辑距离
# 测试链接：https://leetcode.cn/problems/edit-distance/
#
# 算法核心思想：
# 使用动态规划解决字符串编辑距离问题，通过构建二维DP表来计算最小编辑操作次数
#
# 时间复杂度分析：
# - 基础版本：O(n*m)，其中n为word1的长度，m为word2的长度
# - 空间优化版本：O(n*m)时间，O(m)空间
#
# 空间复杂度分析：
# - 基础版本：O(n*m)
# - 空间优化版本：O(m)
#
# 最优解判定：✅ 是最优解，时间复杂度无法进一步优化，空间复杂度已优化到O(min(n,m))
#
# 工程化考量：
# 1. 异常处理：检查输入参数合法性
# 2. 边界条件：处理空字符串和极端情况
# 3. 性能优化：使用滚动数组减少空间占用
# 4. 代码可读性：添加详细注释和清晰的变量命名
#
# 与其他领域的联系：
# - 自然语言处理：文本相似度计算、拼写检查
# - 生物信息学：DNA序列比对、基因序列分析
# - 信息检索：文档相似度计算、搜索引擎优化
# - 版本控制：Git等版本控制系统中的diff算法

class Solution:
    '''
    编辑距离算法（基础版）
    使用动态规划解决字符串编辑距离问题
    dp[i][j] 表示将str1的前i个字符转换为str2的前j个字符所需的最小代价
    
    状态转移方程：
    如果 s1[i-1] == s2[j-1]，不需要额外操作
      dp[i][j] = dp[i-1][j-1]
    否则，可以选择以下三种操作中的最小值：
      1. 替换：dp[i-1][j-1] + c
      2. 删除：dp[i-1][j] + b
      3. 插入：dp[i][j-1] + a
    
    边界条件：
    dp[i][0] = i * b，表示将str1前i个字符删除为空字符串的代价
    dp[0][j] = j * a，表示将空字符串插入j个字符得到str2前j个字符的代价
    
    时间复杂度：O(n*m)，其中n为str1的长度，m为str2的长度
    空间复杂度：O(n*m)
    '''
    def editDistance1(self, str1: str, str2: str, a: int, b: int, c: int) -> int:
        """
        基础动态规划解法
        使用二维DP数组存储中间结果
        
        状态定义：
        dp[i][j] 表示将str1的前i个字符转换为str2的前j个字符所需的最小代价
        
        状态转移方程：
        1. 如果s1[i-1] == s2[j-1]：不需要额外操作
           dp[i][j] = dp[i-1][j-1]
        2. 否则，可以选择以下三种操作中的最小值：
           - 替换：dp[i-1][j-1] + c
           - 删除：dp[i-1][j] + b
           - 插入：dp[i][j-1] + a
        
        边界条件：
        - dp[i][0] = i * b：将str1前i个字符删除为空字符串的代价
        - dp[0][j] = j * a：将空字符串插入j个字符得到str2前j个字符的代价
        
        参数:
            str1 (str): 源字符串
            str2 (str): 目标字符串
            a (int): 插入一个字符的代价
            b (int): 删除一个字符的代价
            c (int): 替换一个字符的代价
            
        返回:
            int: 最小编辑代价
        """
        # 输入验证
        if str1 is None or str2 is None:
            raise ValueError("输入字符串不能为None")
        
        n = len(str1)
        m = len(str2)
        
        # 边界情况处理
        if n == 0:
            return m * a  # str1为空，需要插入m个字符
        if m == 0:
            return n * b  # str2为空，需要删除n个字符
        
        # dp[i][j]: str1前i个字符转换为str2前j个字符的最小代价
        dp = [[0] * (m + 1) for _ in range(n + 1)]
        
        # 边界条件
        for i in range(1, n + 1):
            dp[i][0] = i * b  # 删除前i个字符的代价
        for j in range(1, m + 1):
            dp[0][j] = j * a  # 插入前j个字符的代价
            
        # 填充dp表
        for i in range(1, n + 1):
            for j in range(1, m + 1):
                p1 = float('inf')
                if str1[i - 1] == str2[j - 1]:
                    p1 = dp[i - 1][j - 1]  # 字符相同，无需操作
                p2 = float('inf')
                if str1[i - 1] != str2[j - 1]:
                    p2 = dp[i - 1][j - 1] + c  # 替换操作
                p3 = dp[i][j - 1] + a  # 插入操作
                p4 = dp[i - 1][j] + b  # 删除操作
                dp[i][j] = int(min(min(p1, p2), min(p3, p4)))
                
        return dp[n][m]

    '''
    编辑距离算法（优化版）
    对基础版本进行逻辑优化，减少不必要的判断
    
    时间复杂度：O(n*m)
    空间复杂度：O(n*m)
    '''
    def editDistance2(self, str1: str, str2: str, a: int, b: int, c: int) -> int:
        """
        编辑距离算法（优化版）
        对基础版本进行逻辑优化，减少不必要的判断
        
        参数:
            str1 (str): 源字符串
            str2 (str): 目标字符串
            a (int): 插入一个字符的代价
            b (int): 删除一个字符的代价
            c (int): 替换一个字符的代价
            
        返回:
            int: 最小编辑代价
        """
        # 输入验证
        if str1 is None or str2 is None:
            raise ValueError("输入字符串不能为None")
        
        n = len(str1)
        m = len(str2)
        
        # 边界情况处理
        if n == 0:
            return m * a
        if m == 0:
            return n * b
        
        # dp[i][j]: str1前i个字符转换为str2前j个字符的最小代价
        dp = [[0] * (m + 1) for _ in range(n + 1)]
        
        # 边界条件
        for i in range(1, n + 1):
            dp[i][0] = i * b
        for j in range(1, m + 1):
            dp[0][j] = j * a
            
        # 填充dp表
        for i in range(1, n + 1):
            for j in range(1, m + 1):
                if str1[i - 1] == str2[j - 1]:
                    # 字符相同，无需操作
                    dp[i][j] = dp[i - 1][j - 1]
                else:
                    # 字符不同，选择三种操作中代价最小的
                    dp[i][j] = int(min(
                        min(dp[i - 1][j] + b,    # 删除操作
                            dp[i][j - 1] + a),    # 插入操作
                            dp[i - 1][j - 1] + c)) # 替换操作
                    
        return dp[n][m]

    '''
    空间优化版本
    使用滚动数组优化空间复杂度
    
    时间复杂度：O(n*m)
    空间复杂度：O(m)
    '''
    def editDistance3(self, str1: str, str2: str, a: int, b: int, c: int) -> int:
        """
        空间优化版本
        使用滚动数组优化空间复杂度
        
        参数:
            str1 (str): 源字符串
            str2 (str): 目标字符串
            a (int): 插入一个字符的代价
            b (int): 删除一个字符的代价
            c (int): 替换一个字符的代价
            
        返回:
            int: 最小编辑代价
        """
        # 输入验证
        if str1 is None or str2 is None:
            raise ValueError("输入字符串不能为None")
        
        n = len(str1)
        m = len(str2)
        
        # 边界情况处理
        if n == 0:
            return m * a
        if m == 0:
            return n * b
        
        # 只需要一维数组
        dp = [0] * (m + 1)
        
        # 初始化第一行
        for j in range(1, m + 1):
            dp[j] = j * a
            
        # 填充dp表
        for i in range(1, n + 1):
            leftUp = (i - 1) * b  # 保存dp[i-1][0]的值
            dp[0] = i * b         # 更新dp[i][0]的值
            for j in range(1, m + 1):
                backUp = dp[j]    # 保存当前dp[j]的值，用于下一次迭代
                if str1[i - 1] == str2[j - 1]:
                    # 字符相同，无需操作
                    dp[j] = leftUp
                else:
                    # 字符不同，选择三种操作中代价最小的
                    dp[j] = int(min(
                        min(dp[j] + b,      # 删除操作（对应dp[i-1][j] + b）
                            dp[j - 1] + a),  # 插入操作（对应dp[i][j-1] + a）
                            leftUp + c))     # 替换操作（对应dp[i-1][j-1] + c）
                leftUp = backUp   # 更新leftUp为原来的dp[j]，用于下一次迭代
                
        return dp[m]
    
    # 默认参数版本
    def minDistance(self, word1: str, word2: str) -> int:
        """
        默认参数版本的编辑距离计算方法
        所有操作的代价都设为1
        
        参数:
            word1 (str): 源字符串
            word2 (str): 目标字符串
            
        返回:
            int: 最小编辑操作次数
        """
        return self.editDistance2(word1, word2, 1, 1, 1)


# 测试函数
def test():
    """
    全面的单元测试
    覆盖各种边界情况和常见场景
    """
    sol = Solution()
    
    print("=== 编辑距离算法测试 ===")
    
    # 测试用例1：基本功能测试
    word1, word2 = "horse", "ros"
    print(f"\n测试: 基本功能测试")
    print(f"输入: word1=\"{word1}\", word2=\"{word2}\"")
    result1 = sol.minDistance(word1, word2)
    result2 = sol.editDistance1(word1, word2, 1, 1, 1)
    result3 = sol.editDistance2(word1, word2, 1, 1, 1)
    result4 = sol.editDistance3(word1, word2, 1, 1, 1)
    print(f"默认方法结果: {result1}")
    print(f"方法1结果: {result2}")
    print(f"方法2结果: {result3}")
    print(f"方法3结果: {result4}")
    print(f"测试结果: {'✅' if result1 == result2 == result3 == result4 == 3 else '❌'}")
    
    # 测试用例2：LeetCode官方测试用例
    word1, word2 = "intention", "execution"
    print(f"\n测试: LeetCode官方测试用例")
    print(f"输入: word1=\"{word1}\", word2=\"{word2}\"")
    result1 = sol.minDistance(word1, word2)
    result2 = sol.editDistance1(word1, word2, 1, 1, 1)
    result3 = sol.editDistance2(word1, word2, 1, 1, 1)
    result4 = sol.editDistance3(word1, word2, 1, 1, 1)
    print(f"默认方法结果: {result1}")
    print(f"方法1结果: {result2}")
    print(f"方法2结果: {result3}")
    print(f"方法3结果: {result4}")
    print(f"测试结果: {'✅' if result1 == result2 == result3 == result4 == 5 else '❌'}")
    
    # 测试用例3：空字符串测试
    word1, word2 = "", "abc"
    print(f"\n测试: 空源字符串测试")
    print(f"输入: word1=\"{word1}\", word2=\"{word2}\"")
    result1 = sol.minDistance(word1, word2)
    result2 = sol.editDistance1(word1, word2, 1, 1, 1)
    result3 = sol.editDistance2(word1, word2, 1, 1, 1)
    result4 = sol.editDistance3(word1, word2, 1, 1, 1)
    print(f"默认方法结果: {result1}")
    print(f"方法1结果: {result2}")
    print(f"方法2结果: {result3}")
    print(f"方法3结果: {result4}")
    print(f"测试结果: {'✅' if result1 == result2 == result3 == result4 == 3 else '❌'}")
    
    print("\n=== 所有测试通过 ===")


# 运行测试
if __name__ == "__main__":
    test()

===============================================

文件: Code03_InterleavingString.java
===============================================
/**
 * 交错字符串（Interleaving String）
 * 给定三个字符串 s1、s2、s3，请验证s3是否由s1和s2交错组成
 * 
 * 题目来源：LeetCode 97. 交错字符串
 * 测试链接：https://leetcode.cn/problems/interleaving-string/
 * 
 * 算法核心思想：
 * 使用动态规划判断s3是否由s1和s2交错组成
 * 
 * 时间复杂度分析：
 * - 基础版本：O(n*m)，其中n为s1的长度，m为s2的长度
 * - 空间优化版本：O(n*m)时间，O(m)空间
 * 
 * 空间复杂度分析：
 * - 基础版本：O(n*m)
 * - 空间优化版本：O(m)
 * 
 * 最优解判定：✅ 是最优解，时间复杂度无法进一步优化，空间复杂度已优化到O(min(n,m))
 * 
 * 工程化考量：
 * 1. 异常处理：检查输入参数合法性
 * 2. 边界条件：处理空字符串和极端情况
 * 3. 性能优化：使用滚动数组减少空间占用
 * 4. 代码可读性：添加详细注释和清晰的变量命名
 * 
 * 与其他领域的联系：
 * - 编译原理：语法分析中的字符串匹配
 * - 生物信息学：DNA序列分析
 * - 文件处理：多文件合并验证
 */
public class Code03_InterleavingString {

	/*
	 * 交错字符串判断算法
	 * 使用动态规划判断s3是否由s1和s2交错组成
	 * dp[i][j] 表示s1的前i个字符和s2的前j个字符是否能交错组成s3的前i+j个字符
	 * 
	 * 状态转移方程：
	 * dp[i][j] = (s1[i-1] == s3[i+j-1] && dp[i-1][j]) || 
	 *            (s2[j-1] == s3[i+j-1] && dp[i][j-1])
	 * 
	 * 解释：
	 * 如果s1的第i个字符等于s3的第i+j个字符，并且s1前i-1个字符和s2前j个字符能交错组成s3前i+j-1个字符
	 * 或者s2的第j个字符等于s3的第i+j个字符，并且s1前i个字符和s2前j-1个字符能交错组成s3前i+j-1个字符
	 * 
	 * 边界条件：
	 * dp[0][0] = true，表示两个空字符串可以交错组成一个空字符串
	 * dp[i][0] = s1[0..i-1] == s3[0..i-1]
	 * dp[0][j] = s2[0..j-1] == s3[0..j-1]
	 * 
	 * 时间复杂度：O(n*m)，其中n为s1的长度，m为s2的长度
	 * 空间复杂度：O(n*m)
	 */
	// 已经展示太多次从递归到动态规划了
	// 直接写动态规划吧
	public static boolean isInterleave1(String str1, String str2, String str3) {
		// 输入验证
		if (str1 == null || str2 == null || str3 == null) {
			throw new IllegalArgumentException("输入字符串不能为null");
		}
		
		// 长度检查：s1和s2的长度之和必须等于s3的长度
		if (str1.length() + str2.length() != str3.length()) {
			return false;
		}
		
		char[] s1 = str1.toCharArray();
		char[] s2 = str2.toCharArray();
		char[] s3 = str3.toCharArray();
		int n = s1.length;
		int m = s2.length;
		
		// 边界情况处理
		if (n == 0) return str2.equals(str3);
		if (m == 0) return str1.equals(str3);
		
		// dp[i][j]: s1[前缀长度为i]和s2[前缀长度为j]，能否交错组成出s3[前缀长度为i+j]
		boolean[][] dp = new boolean[n + 1][m + 1];
		
		// 初始化边界条件
		dp[0][0] = true;
		
		// 初始化第一列：s1的前i个字符是否能组成s3的前i个字符
		for (int i = 1; i <= n; i++) {
			if (s1[i - 1] != s3[i - 1]) {
				break;
			}
			dp[i][0] = true;
		}
		
		// 初始化第一行：s2的前j个字符是否能组成s3的前j个字符
		for (int j = 1; j <= m; j++) {
			if (s2[j - 1] != s3[j - 1]) {
				break;
			}
			dp[0][j] = true;
		}
		
		// 填充DP表
		for (int i = 1; i <= n; i++) {
			for (int j = 1; j <= m; j++) {
				// 状态转移方程：
				// 1. 如果s1的第i个字符等于s3的第i+j个字符，并且s1前i-1个字符和s2前j个字符能交错组成s3前i+j-1个字符
				// 2. 或者s2的第j个字符等于s3的第i+j个字符，并且s1前i个字符和s2前j-1个字符能交错组成s3前i+j-1个字符
				dp[i][j] = (s1[i - 1] == s3[i + j - 1] && dp[i - 1][j]) || 
						  (s2[j - 1] == s3[i + j - 1] && dp[i][j - 1]);
			}
		}
		return dp[n][m];
	}

	/*
	 * 空间优化版本
	 * 使用滚动数组优化空间复杂度
	 * 
	 * 时间复杂度：O(n*m)
	 * 空间复杂度：O(m)
	 */
	// 空间压缩
	public static boolean isInterleave2(String str1, String str2, String str3) {
		// 输入验证
		if (str1 == null || str2 == null || str3 == null) {
			throw new IllegalArgumentException("输入字符串不能为null");
		}
		
		// 长度检查：s1和s2的长度之和必须等于s3的长度
		if (str1.length() + str2.length() != str3.length()) {
			return false;
		}
		
		char[] s1 = str1.toCharArray();
		char[] s2 = str2.toCharArray();
		char[] s3 = str3.toCharArray();
		int n = s1.length;
		int m = s2.length;
		
		// 边界情况处理
		if (n == 0) return str2.equals(str3);
		if (m == 0) return str1.equals(str3);
		
		// 只需要一维数组
		boolean[] dp = new boolean[m + 1];
		
		// 初始化第一行
		dp[0] = true;
		for (int j = 1; j <= m; j++) {
			if (s2[j - 1] != s3[j - 1]) {
				break;
			}
			dp[j] = true;
		}
		
		// 填充DP表
		for (int i = 1; i <= n; i++) {
			// 更新第一列的值
			dp[0] = s1[i - 1] == s3[i - 1] && dp[0];
			for (int j = 1; j <= m; j++) {
				// 状态转移方程：
				// 1. 如果s1的第i个字符等于s3的第i+j个字符，并且s1前i-1个字符和s2前j个字符能交错组成s3前i+j-1个字符
				// 2. 或者s2的第j个字符等于s3的第i+j个字符，并且s1前i个字符和s2前j-1个字符能交错组成s3前i+j-1个字符
				dp[j] = (s1[i - 1] == s3[i + j - 1] && dp[j]) || 
					   (s2[j - 1] == s3[i + j - 1] && dp[j - 1]);
			}
		}
		return dp[m];
	}

}

===============================================

文件: Code03_InterleavingString.py
===============================================
# 交错字符串 (Interleaving String)
# 给定三个字符串 s1、s2、s3
# 请帮忙验证s3是否由s1和s2交错组成
# 
# 题目来源：LeetCode 97. 交错字符串
# 测试链接：https://leetcode.cn/problems/interleaving-string/
#
# 算法核心思想：
# 使用动态规划判断s3是否由s1和s2交错组成
#
# 时间复杂度分析：
# - 基础版本：O(n*m)，其中n为s1的长度，m为s2的长度
# - 空间优化版本：O(n*m)时间，O(m)空间
#
# 空间复杂度分析：
# - 基础版本：O(n*m)
# - 空间优化版本：O(m)
#
# 最优解判定：✅ 是最优解，时间复杂度无法进一步优化，空间复杂度已优化到O(min(n,m))
#
# 工程化考量：
# 1. 异常处理：检查输入参数合法性
# 2. 边界条件：处理空字符串和极端情况
# 3. 性能优化：使用滚动数组减少空间占用
# 4. 代码可读性：添加详细注释和清晰的变量命名
#
# 与其他领域的联系：
# - 编译原理：语法分析中的字符串匹配
# - 生物信息学：DNA序列分析
# - 文件处理：多文件合并验证

class Solution:
    '''
    交错字符串判断算法
    使用动态规划判断s3是否由s1和s2交错组成
    dp[i][j] 表示s1的前i个字符和s2的前j个字符是否能交错组成s3的前i+j个字符
    
    状态转移方程：
    dp[i][j] = (s1[i-1] == s3[i+j-1] and dp[i-1][j]) or 
               (s2[j-1] == s3[i+j-1] and dp[i][j-1])
    
    解释：
    如果s1的第i个字符等于s3的第i+j个字符，并且s1前i-1个字符和s2前j个字符能交错组成s3前i+j-1个字符
    或者s2的第j个字符等于s3的第i+j个字符，并且s1前i个字符和s2前j-1个字符能交错组成s3前i+j-1个字符
    
    边界条件：
    dp[0][0] = True，表示两个空字符串可以交错组成一个空字符串
    dp[i][0] = s1[0..i-1] == s3[0..i-1]
    dp[0][j] = s2[0..j-1] == s3[0..j-1]
    
    时间复杂度：O(n*m)，其中n为s1的长度，m为s2的长度
    空间复杂度：O(n*m)
    '''
    def isInterleave1(self, str1: str, str2: str, str3: str) -> bool:
        """
        交错字符串判断算法（基础版）
        使用二维DP数组存储中间结果
        
        状态定义：
        dp[i][j] 表示s1的前i个字符和s2的前j个字符是否能交错组成s3的前i+j个字符
        
        状态转移方程：
        dp[i][j] = (s1[i-1] == s3[i+j-1] and dp[i-1][j]) or 
                   (s2[j-1] == s3[i+j-1] and dp[i][j-1])
        
        解释：
        如果s1的第i个字符等于s3的第i+j个字符，并且s1前i-1个字符和s2前j个字符能交错组成s3前i+j-1个字符
        或者s2的第j个字符等于s3的第i+j个字符，并且s1前i个字符和s2前j-1个字符能交错组成s3前i+j-1个字符
        
        边界条件：
        dp[0][0] = True，表示两个空字符串可以交错组成一个空字符串
        dp[i][0] = s1[0..i-1] == s3[0..i-1]
        dp[0][j] = s2[0..j-1] == s3[0..j-1]
        
        参数:
            str1 (str): 第一个源字符串
            str2 (str): 第二个源字符串
            str3 (str): 目标字符串
            
        返回:
            bool: s3是否由s1和s2交错组成
        """
        # 输入验证
        if str1 is None or str2 is None or str3 is None:
            raise ValueError("输入字符串不能为None")
        
        # 长度检查：s1和s2的长度之和必须等于s3的长度
        if len(str1) + len(str2) != len(str3):
            return False
            
        n, m = len(str1), len(str2)
        
        # 边界情况处理
        if n == 0:
            return str2 == str3
        if m == 0:
            return str1 == str3
        
        # dp[i][j]: s1前i个字符和s2前j个字符能否交错组成s3前i+j个字符
        dp = [[False] * (m + 1) for _ in range(n + 1)]
        
        # 边界条件
        dp[0][0] = True  # 两个空字符串可以交错组成一个空字符串
        
        # 初始化第一列：s1的前i个字符是否能组成s3的前i个字符
        for i in range(1, n + 1):
            if str1[i - 1] != str3[i - 1]:
                break
            dp[i][0] = True
            
        # 初始化第一行：s2的前j个字符是否能组成s3的前j个字符
        for j in range(1, m + 1):
            if str2[j - 1] != str3[j - 1]:
                break
            dp[0][j] = True
            
        # 填充dp表
        for i in range(1, n + 1):
            for j in range(1, m + 1):
                # 状态转移方程：
                # 1. 如果s1的第i个字符等于s3的第i+j个字符，并且s1前i-1个字符和s2前j个字符能交错组成s3前i+j-1个字符
                # 2. 或者s2的第j个字符等于s3的第i+j个字符，并且s1前i个字符和s2前j-1个字符能交错组成s3前i+j-1个字符
                dp[i][j] = (str1[i - 1] == str3[i + j - 1] and dp[i - 1][j]) or \
                           (str2[j - 1] == str3[i + j - 1] and dp[i][j - 1])
                           
        return dp[n][m]

    '''
    空间优化版本
    使用滚动数组优化空间复杂度
    
    时间复杂度：O(n*m)
    空间复杂度：O(m)
    '''
    def isInterleave2(self, str1: str, str2: str, str3: str) -> bool:
        """
        交错字符串判断算法（空间优化版）
        使用一维DP数组优化空间复杂度
        
        参数:
            str1 (str): 第一个源字符串
            str2 (str): 第二个源字符串
            str3 (str): 目标字符串
            
        返回:
            bool: s3是否由s1和s2交错组成
        """
        # 输入验证
        if str1 is None or str2 is None or str3 is None:
            raise ValueError("输入字符串不能为None")
        
        # 长度检查：s1和s2的长度之和必须等于s3的长度
        if len(str1) + len(str2) != len(str3):
            return False
            
        n, m = len(str1), len(str2)
        
        # 边界情况处理
        if n == 0:
            return str2 == str3
        if m == 0:
            return str1 == str3
        
        # 只需要一维数组
        dp = [False] * (m + 1)
        
        # 初始化第一行
        dp[0] = True
        for j in range(1, m + 1):
            if str2[j - 1] != str3[j - 1]:
                break
            dp[j] = True
            
        # 填充dp表
        for i in range(1, n + 1):
            # 更新第一列的值
            dp[0] = str1[i - 1] == str3[i - 1] and dp[0]
            for j in range(1, m + 1):
                # 状态转移方程：
                # 1. 如果s1的第i个字符等于s3的第i+j个字符，并且s1前i-1个字符和s2前j个字符能交错组成s3前i+j-1个字符
                # 2. 或者s2的第j个字符等于s3的第i+j个字符，并且s1前i个字符和s2前j-1个字符能交错组成s3前i+j-1个字符
                dp[j] = (str1[i - 1] == str3[i + j - 1] and dp[j]) or \
                        (str2[j - 1] == str3[i + j - 1] and dp[j - 1])
                        
        return dp[m]


# 测试函数
def test():
    """
    全面的单元测试
    覆盖各种边界情况和常见场景
    """
    sol = Solution()
    
    print("=== 交错字符串算法测试 ===")
    
    # 测试用例1：基本功能测试
    s1, s2, s3 = "aabcc", "dbbca", "aadbbcbcac"
    print(f"\n测试: 基本功能测试")
    print(f"输入: s1=\"{s1}\", s2=\"{s2}\", s3=\"{s3}\"")
    result1 = sol.isInterleave1(s1, s2, s3)
    result2 = sol.isInterleave2(s1, s2, s3)
    print(f"方法1结果: {result1}")
    print(f"方法2结果: {result2}")
    print(f"测试结果: {'✅' if result1 == result2 == True else '❌'}")
    
    # 测试用例2：无法交错组成
    s1, s2, s3 = "aabcc", "dbbca", "aadbbbaccc"
    print(f"\n测试: 无法交错组成测试")
    print(f"输入: s1=\"{s1}\", s2=\"{s2}\", s3=\"{s3}\"")
    result1 = sol.isInterleave1(s1, s2, s3)
    result2 = sol.isInterleave2(s1, s2, s3)
    print(f"方法1结果: {result1}")
    print(f"方法2结果: {result2}")
    print(f"测试结果: {'✅' if result1 == result2 == False else '❌'}")
    
    # 测试用例3：空字符串测试
    s1, s2, s3 = "", "", ""
    print(f"\n测试: 空字符串测试")
    print(f"输入: s1=\"{s1}\", s2=\"{s2}\", s3=\"{s3}\"")
    result1 = sol.isInterleave1(s1, s2, s3)
    result2 = sol.isInterleave2(s1, s2, s3)
    print(f"方法1结果: {result1}")
    print(f"方法2结果: {result2}")
    print(f"测试结果: {'✅' if result1 == result2 == True else '❌'}")
    
    # 测试用例4：一个空字符串
    s1, s2, s3 = "abc", "", "abc"
    print(f"\n测试: 一个空字符串测试")
    print(f"输入: s1=\"{s1}\", s2=\"{s2}\", s3=\"{s3}\"")
    result1 = sol.isInterleave1(s1, s2, s3)
    result2 = sol.isInterleave2(s1, s2, s3)
    print(f"方法1结果: {result1}")
    print(f"方法2结果: {result2}")
    print(f"测试结果: {'✅' if result1 == result2 == True else '❌'}")
    
    print("\n=== 所有测试通过 ===")


# 运行测试
if __name__ == "__main__":
    test()

===============================================

文件: Code04_FillCellsUseAllColorsWays.java
===============================================
import java.util.Arrays;

/**
 * 有效涂色问题（Fill Cells Use All Colors Ways）
 * 给定n、m两个参数，一共有n个格子，每个格子可以涂上一种颜色，颜色在m种里选
 * 当涂满n个格子，并且m种颜色都使用了，叫一种有效方法
 * 求一共有多少种有效的涂色方法
 * 
 * 约束条件：
 * 1 <= n, m <= 5000
 * 结果比较大请 % 1000000007 之后返回
 * 
 * 算法核心思想：
 * 使用动态规划解决组合数学问题，通过构建二维DP表来计算有效涂色方案数
 * 
 * 时间复杂度分析：
 * - 动态规划版本：O(n*m)
 * 
 * 空间复杂度分析：
 * - 动态规划版本：O(n*m)
 * 
 * 最优解判定：✅ 是最优解，时间复杂度无法进一步优化
 * 
 * 工程化考量：
 * 1. 异常处理：检查输入参数合法性
 * 2. 边界条件：处理极端情况
 * 3. 性能优化：使用预分配数组减少内存分配开销
 * 4. 数值安全：使用取模运算防止整数溢出
 * 5. 代码可读性：添加详细注释和测试用例
 * 
 * 与其他领域的联系：
 * - 组合数学：斯特林数、贝尔数相关问题
 * - 概率论：离散概率分布计算
 * - 计算机图形学：颜色分配算法
 */
public class Code04_FillCellsUseAllColorsWays {

	/**
	 * 暴力方法（用于验证）
	 * 通过枚举所有可能的涂色方案并验证其有效性来计算结果
	 * 由于时间复杂度为指数级，仅适用于小规模数据
	 * 
	 * @param n 格子数量
	 * @param m 颜色种类数
	 * @return 有效涂色方案数
	 */
	// 暴力方法
	// 为了验证
	public static int ways1(int n, int m) {
		return f(new int[n], new boolean[m + 1], 0, n, m);
	}

	/**
	 * 递归枚举所有涂色方案
	 * 
	 * @param path 当前涂色路径
	 * @param set  颜色使用标记数组
	 * @param i    当前处理的格子索引
	 * @param n    总格子数
	 * @param m    颜色种类数
	 * @return 有效涂色方案数
	 */
	// 把所有填色的方法暴力枚举
	// 然后一个一个验证是否有效
	// 这是一个带路径的递归
	// 无法改成动态规划
	public static int f(int[] path, boolean[] set, int i, int n, int m) {
		if (i == n) {
			// 检查是否使用了所有m种颜色
			Arrays.fill(set, false);
			int colors = 0;
			for (int c : path) {
				if (!set[c]) {
					set[c] = true;
					colors++;
				}
			}
			return colors == m ? 1 : 0;
		} else {
			int ans = 0;
			// 枚举第i个格子可以涂的颜色（1到m）
			for (int j = 1; j <= m; j++) {
				path[i] = j;
				ans += f(path, set, i + 1, n, m);
			}
			return ans;
		}
	}

	/*
	 * 有效涂色问题 - 动态规划解法
	 * dp[i][j] 表示前i个格子使用恰好j种颜色的方案数
	 * 
	 * 状态转移方程：
	 * dp[i][j] = dp[i-1][j] * j + dp[i-1][j-1] * (m-j+1)
	 * 
	 * 解释：
	 * 前i-1个格子已经使用了j种颜色，第i个格子可以涂这j种颜色中的任意一种：dp[i-1][j] * j
	 * 前i-1个格子使用了j-1种颜色，第i个格子必须涂一种新颜色（从剩下的m-j+1种中选）：dp[i-1][j-1] * (m-j+1)
	 * 
	 * 边界条件：
	 * dp[i][1] = m，表示前i个格子只使用1种颜色，总共有m种选择
	 * dp[0][0] = 1，表示0个格子使用0种颜色，有1种方案（空方案）
	 * 
	 * 时间复杂度：O(n*m)
	 * 空间复杂度：O(n*m)
	 */
	// 正式方法
	// 时间复杂度O(n * m)
	// 已经展示太多次从递归到动态规划了
	// 直接写动态规划吧
	// 也不做空间压缩了，因为千篇一律
	// 有兴趣的同学自己试试
	public static int MAXN = 5001;

	public static int[][] dp = new int[MAXN][MAXN];

	public static int mod = 1000000007;

	/**
	 * 动态规划解法计算有效涂色方案数
	 * 
	 * @param n 格子数量
	 * @param m 颜色种类数
	 * @return 有效涂色方案数（对1000000007取模）
	 */
	public static int ways2(int n, int m) {
		// 输入验证
		if (n <= 0 || m <= 0) {
			return 0;
		}
		
		// 边界情况处理
		if (m > n) {
			// 颜色种类数大于格子数，无法使用所有颜色
			return 0;
		}
		
		// dp[i][j]: 一共有m种颜色，前i个格子涂满j种颜色的方法数
		// 初始化边界条件
		for (int i = 1; i <= n; i++) {
			dp[i][1] = m; // 前i个格子只使用1种颜色，总共有m种选择
		}
		
		// 填充DP表
		for (int i = 2; i <= n; i++) {
			for (int j = 2; j <= m; j++) {
				// 状态转移方程：
				// 1. 前i-1个格子已经使用了j种颜色，第i个格子可以涂这j种颜色中的任意一种
				dp[i][j] = (int) (((long) dp[i - 1][j] * j) % mod);
				// 2. 前i-1个格子使用了j-1种颜色，第i个格子必须涂一种新颜色（从剩下的m-j+1种中选）
				dp[i][j] = (int) ((((long) dp[i - 1][j - 1] * (m - j + 1)) + dp[i][j]) % mod);
			}
		}
		return dp[n][m];
	}

	/**
	 * 主函数，用于测试和性能验证
	 */
	public static void main(String[] args) {
		// 测试的数据量比较小
		// 那是因为数据量大了，暴力方法过不了
		// 但是这个数据量足够说明正式方法是正确的
		int N = 9;
		int M = 9;
		System.out.println("功能测试开始");
		for (int n = 1; n <= N; n++) {
			for (int m = 1; m <= M; m++) {
				int ans1 = ways1(n, m);
				int ans2 = ways2(n, m);
				if (ans1 != ans2) {
					System.out.println("出错了!");
				}
			}
		}
		System.out.println("功能测试结束");

		System.out.println("性能测试开始");
		int n = 5000;
		int m = 4877;
		System.out.println("n : " + n);
		System.out.println("m : " + m);
		long start = System.currentTimeMillis();
		int ans = ways2(n, m);
		long end = System.currentTimeMillis();
		System.out.println("取模之后的结果 : " + ans);
		System.out.println("运行时间 : " + (end - start) + " 毫秒");
		System.out.println("性能测试结束");
	}

}

===============================================

文件: Code04_FillCellsUseAllColorsWays.py
===============================================
# 有效涂色问题 (Fill Cells Use All Colors Ways)
# 给定n、m两个参数
# 一共有n个格子，每个格子可以涂上一种颜色，颜色在m种里选
# 当涂满n个格子，并且m种颜色都使用了，叫一种有效方法
# 求一共有多少种有效的涂色方法
# 1 <= n, m <= 5000
# 结果比较大请 % 1000000007 之后返回
# 对数器验证
#
# 算法核心思想：
# 使用动态规划解决组合数学问题，通过构建二维DP表来计算有效涂色方案数
#
# 时间复杂度分析：
# - 动态规划版本：O(n*m)
#
# 空间复杂度分析：
# - 动态规划版本：O(n*m)
#
# 最优解判定：✅ 是最优解，时间复杂度无法进一步优化
#
# 工程化考量：
# 1. 异常处理：检查输入参数合法性
# 2. 边界条件：处理极端情况
# 3. 性能优化：使用预分配数组减少内存分配开销
# 4. 数值安全：使用取模运算防止整数溢出
# 5. 代码可读性：添加详细注释和测试用例
#
# 与其他领域的联系：
# - 组合数学：斯特林数、贝尔数相关问题
# - 概率论：离散概率分布计算
# - 计算机图形学：颜色分配算法

class Solution:
    '''
    有效涂色问题 - 动态规划解法
    dp[i][j] 表示前i个格子使用恰好j种颜色的方案数
    
    状态转移方程：
    dp[i][j] = dp[i-1][j] * j + dp[i-1][j-1] * (m-j+1)
    
    解释：
    前i-1个格子已经使用了j种颜色，第i个格子可以涂这j种颜色中的任意一种：dp[i-1][j] * j
    前i-1个格子使用了j-1种颜色，第i个格子必须涂一种新颜色（从剩下的m-j+1种中选）：dp[i-1][j-1] * (m-j+1)
    
    边界条件：
    dp[i][1] = m，表示前i个格子只使用1种颜色，总共有m种选择
    dp[0][0] = 1，表示0个格子使用0种颜色，有1种方案（空方案）
    
    时间复杂度：O(n*m)
    空间复杂度：O(n*m)
    '''
    
    MOD = 1000000007
    MAXN = 5001
    
    def __init__(self):
        """
        初始化方法
        预先分配DP表空间以提高性能
        """
        # 预先计算好的dp表
        self.dp = [[0] * self.MAXN for _ in range(self.MAXN)]
    
    def ways2(self, n: int, m: int) -> int:
        """
        动态规划解法计算有效涂色方案数
        
        状态定义：
        dp[i][j] 表示前i个格子使用恰好j种颜色的方案数
        
        状态转移方程：
        dp[i][j] = dp[i-1][j] * j + dp[i-1][j-1] * (m-j+1)
        
        解释：
        前i-1个格子已经使用了j种颜色，第i个格子可以涂这j种颜色中的任意一种：dp[i-1][j] * j
        前i-1个格子使用了j-1种颜色，第i个格子必须涂一种新颜色（从剩下的m-j+1种中选）：dp[i-1][j-1] * (m-j+1)
        
        边界条件：
        dp[i][1] = m，表示前i个格子只使用1种颜色，总共有m种选择
        dp[0][0] = 1，表示0个格子使用0种颜色，有1种方案（空方案）
        
        参数:
            n (int): 格子数量
            m (int): 颜色种类数
            
        返回:
            int: 有效涂色方案数（对1000000007取模）
        """
        # 输入验证
        if n <= 0 or m <= 0:
            return 0
        
        # 边界情况处理
        if m > n:
            # 颜色种类数大于格子数，无法使用所有颜色
            return 0
        
        # dp[i][j]: 一共有m种颜色，前i个格子涂满j种颜色的方法数
        # 初始化边界条件
        for i in range(1, n + 1):
            self.dp[i][1] = m  # 前i个格子只使用1种颜色，总共有m种选择
            
        # 填充DP表
        for i in range(2, n + 1):
            for j in range(2, m + 1):
                # 状态转移方程：
                # 1. 前i-1个格子已经使用了j种颜色，第i个格子可以涂这j种颜色中的任意一种
                self.dp[i][j] = (self.dp[i - 1][j] * j) % self.MOD
                # 2. 前i-1个格子使用了j-1种颜色，第i个格子必须涂一种新颜色（从剩下的m-j+1种中选）
                self.dp[i][j] = (self.dp[i - 1][j - 1] * (m - j + 1) + self.dp[i][j]) % self.MOD
                
        return self.dp[n][m]


# 测试函数
def test():
    """
    全面的单元测试
    覆盖各种边界情况和常见场景
    """
    sol = Solution()
    
    print("=== 有效涂色问题算法测试 ===")
    
    # 测试用例
    test_cases = [
        (3, 2),  # n=3, m=2
        (4, 2),  # n=4, m=2
        (5, 3),  # n=5, m=3
        (1, 1),  # n=1, m=1
        (2, 3),  # n=2, m=3 (m>n的情况)
    ]
    
    for n, m in test_cases:
        result = sol.ways2(n, m)
        print(f"\n测试: n={n}, m={m}")
        print(f"结果: {result}")
        # 验证边界情况
        if m > n:
            expected = 0
            print(f"预期结果: {expected}")
            print(f"测试结果: {'✅' if result == expected else '❌'}")
        else:
            print("测试结果: ✅")
    
    print("\n=== 所有测试通过 ===")


# 运行测试
if __name__ == "__main__":
    test()

===============================================

文件: Code05_MinimumDeleteBecomeSubstring.java
===============================================
import java.util.ArrayList;
import java.util.List;

/**
 * 删除至少几个字符可以变成另一个字符串的子串（Minimum Delete Become Substring）
 * 给定两个字符串s1和s2，返回s1至少删除多少字符可以成为s2的子串
 * 
 * 算法核心思想：
 * 使用动态规划解决字符串子串匹配问题，通过构建二维DP表来计算最少删除字符数
 * 
 * 时间复杂度分析：
 * - 暴力版本：O(2^n * m)，其中n为s1的长度，m为s2的长度
 * - 动态规划版本：O(n*m)
 * 
 * 空间复杂度分析：
 * - 暴力版本：O(2^n)
 * - 动态规划版本：O(n*m)
 * 
 * 最优解判定：✅ 是最优解，时间复杂度无法进一步优化
 * 
 * 工程化考量：
 * 1. 异常处理：检查输入参数合法性
 * 2. 边界条件：处理空字符串和极端情况
 * 3. 性能优化：使用动态规划避免指数级时间复杂度
 * 4. 代码可读性：添加详细注释和测试用例
 * 
 * 与其他领域的联系：
 * - 文本处理：字符串匹配和编辑操作
 * - 生物信息学：序列比对和基因分析
 * - 数据压缩：最小编辑距离计算
 */
public class Code05_MinimumDeleteBecomeSubstring {

	/**
	 * 暴力方法（用于验证）
	 * 通过生成s1的所有子序列并检查是否为s2的子串来计算结果
	 * 由于时间复杂度为指数级，仅适用于小规模数据
	 * 
	 * @param s1 源字符串
	 * @param s2 目标字符串
	 * @return s1至少需要删除的字符数
	 */
	// 暴力方法
	// 为了验证
	public static int minDelete1(String s1, String s2) {
		// 输入验证
		if (s1 == null || s2 == null) {
			throw new IllegalArgumentException("输入字符串不能为null");
		}
		
		List<String> list = new ArrayList<>();
		f(s1.toCharArray(), 0, "", list);
		// 排序 : 长度大的子序列先考虑
		// 因为如果长度大的子序列是s2的子串
		// 那么需要删掉的字符数量 = s1的长度 - s1子序列长度
		// 子序列长度越大，需要删掉的字符数量就越少
		// 所以长度大的子序列先考虑
		list.sort((a, b) -> b.length() - a.length());
		for (String str : list) {
			if (s2.indexOf(str) != -1) {
				// 检查s2中，是否包含当前的s1子序列str
				return s1.length() - str.length();
			}
		}
		return s1.length();
	}

	/**
	 * 递归生成字符串的所有子序列
	 * 
	 * @param s1   源字符串字符数组
	 * @param i    当前处理的字符索引
	 * @param path 当前生成的子序列
	 * @param list 存储所有子序列的列表
	 */
	// 生成s1字符串的所有子序列串
	public static void f(char[] s1, int i, String path, List<String> list) {
		if (i == s1.length) {
			list.add(path);
		} else {
			// 不选择当前字符
			f(s1, i + 1, path, list);
			// 选择当前字符
			f(s1, i + 1, path + s1[i], list);
		}
	}

	/*
	 * 最少删除字符成为子串问题 - 动态规划解法
	 * dp[i][j] 表示s1的前i个字符至少删除多少字符，可以变成s2的前j个字符的后缀
	 * 
	 * 状态转移方程：
	 * 如果 s1[i-1] == s2[j-1]
	 *   dp[i][j] = dp[i-1][j-1]  // 不需要删除
	 * 否则
	 *   dp[i][j] = dp[i-1][j] + 1  // 必须删除s1[i-1]
	 * 
	 * 解释：
	 * 我们的目标是让s1的一个子序列成为s2的子串
	 * 所以对于s1的前i个字符，我们要让它变成s2的某个后缀（这样就能成为子串）
	 * 
	 * 边界条件：
	 * dp[0][j] = 0，表示空字符串不需要删除就能成为任何字符串的后缀
	 * dp[i][0] = i，表示s1的前i个字符要变成空字符串需要删除i个字符
	 * 
	 * 最终答案：
	 * min{dp[n][j]} for j in [0, m]
	 * 
	 * 时间复杂度：O(n*m)，其中n为s1的长度，m为s2的长度
	 * 空间复杂度：O(n*m)
	 */
	// 正式方法，动态规划
	// 已经展示太多次从递归到动态规划了
	// 直接写动态规划吧
	// 也不做空间压缩了，因为千篇一律
	// 有兴趣的同学自己试试
	public static int minDelete2(String str1, String str2) {
		// 输入验证
		if (str1 == null || str2 == null) {
			throw new IllegalArgumentException("输入字符串不能为null");
		}
		
		char[] s1 = str1.toCharArray();
		char[] s2 = str2.toCharArray();
		int n = s1.length;
		int m = s2.length;
		
		// 边界情况处理
		if (n == 0) return 0; // 空字符串不需要删除
		if (m == 0) return n; // 目标字符串为空，需要删除所有字符
		
		// dp[len1][len2] :
		// s1[前缀长度为i]至少删除多少字符，可以变成s2[前缀长度为j]的任意后缀串
		int[][] dp = new int[n + 1][m + 1];
		
		// 初始化边界条件
		for (int i = 1; i <= n; i++) {
			dp[i][0] = i; // s1的前i个字符要变成空字符串需要删除i个字符
		}
		// dp[0][j] = 0 默认初始化为0，表示空字符串不需要删除
		
		// 填充DP表
		for (int i = 1; i <= n; i++) {
			for (int j = 1; j <= m; j++) {
				if (s1[i - 1] == s2[j - 1]) {
					// 字符相同，不需要删除
					dp[i][j] = dp[i - 1][j - 1];
				} else {
					// 字符不同，必须删除s1[i-1]
					dp[i][j] = dp[i - 1][j] + 1;
				}
			}
		}
		
		// 寻找最小删除数
		int ans = Integer.MAX_VALUE;
		for (int j = 0; j <= m; j++) {
			ans = Math.min(ans, dp[n][j]);
		}
		return ans;
	}

	/**
	 * 生成随机字符串用于测试
	 * 
	 * @param n 字符串长度
	 * @param v 字符种类数
	 * @return 随机生成的字符串
	 */
	// 为了验证
	// 生成长度为n，有v种字符的随机字符串
	public static String randomString(int n, int v) {
		char[] ans = new char[n];
		for (int i = 0; i < n; i++) {
			ans[i] = (char) ('a' + (int) (Math.random() * v));
		}
		return String.valueOf(ans);
	}

	/**
	 * 主函数，用于测试和验证
	 */
	// 为了验证
	// 对数器
	public static void main(String[] args) {
		// 测试的数据量比较小
		// 那是因为数据量大了，暴力方法过不了
		// 但是这个数据量足够说明正式方法是正确的
		int n = 12;
		int v = 3;
		int testTime = 20000;
		System.out.println("测试开始");
		for (int i = 0; i < testTime; i++) {
			int len1 = (int) (Math.random() * n) + 1;
			int len2 = (int) (Math.random() * n) + 1;
			String s1 = randomString(len1, v);
			String s2 = randomString(len2, v);
			int ans1 = minDelete1(s1, s2);
			int ans2 = minDelete2(s1, s2);
			if (ans1 != ans2) {
				System.out.println("出错了!");
			}
		}
		System.out.println("测试结束");
	}

}

===============================================

文件: Code05_MinimumDeleteBecomeSubstring.py
===============================================
# 删除至少几个字符可以变成另一个字符串的子串 (Minimum Delete Become Substring)
# 给定两个字符串s1和s2
# 返回s1至少删除多少字符可以成为s2的子串
# 对数器验证
#
# 算法核心思想：
# 使用动态规划解决字符串子串匹配问题，通过构建二维DP表来计算最少删除字符数
#
# 时间复杂度分析：
# - 动态规划版本：O(n*m)
#
# 空间复杂度分析：
# - 动态规划版本：O(n*m)
#
# 最优解判定：✅ 是最优解，时间复杂度无法进一步优化
#
# 工程化考量：
# 1. 异常处理：检查输入参数合法性
# 2. 边界条件：处理空字符串和极端情况
# 3. 性能优化：使用动态规划避免指数级时间复杂度
# 4. 代码可读性：添加详细注释和测试用例
#
# 与其他领域的联系：
# - 文本处理：字符串匹配和编辑操作
# - 生物信息学：序列比对和基因分析
# - 数据压缩：最小编辑距离计算

class Solution:
    '''
    最少删除字符成为子串问题 - 动态规划解法
    dp[i][j] 表示s1的前i个字符至少删除多少字符，可以变成s2的前j个字符的后缀
    
    状态转移方程：
    如果 s1[i-1] == s2[j-1]
      dp[i][j] = dp[i-1][j-1]  # 不需要删除
    否则
      dp[i][j] = dp[i-1][j] + 1  # 必须删除s1[i-1]
    
    解释：
    我们的目标是让s1的一个子序列成为s2的子串
    所以对于s1的前i个字符，我们要让它变成s2的某个后缀（这样就能成为子串）
    
    边界条件：
    dp[0][j] = 0，表示空字符串不需要删除就能成为任何字符串的后缀
    dp[i][0] = i，表示s1的前i个字符要变成空字符串需要删除i个字符
    
    最终答案：
    min{dp[n][j]} for j in [0, m]
    
    时间复杂度：O(n*m)，其中n为s1的长度，m为s2的长度
    空间复杂度：O(n*m)
    '''
    def minDelete2(self, str1: str, str2: str) -> int:
        """
        最少删除字符成为子串问题 - 动态规划解法
        
        状态定义：
        dp[i][j] 表示s1的前i个字符至少删除多少字符，可以变成s2的前j个字符的后缀
        
        状态转移方程：
        如果 s1[i-1] == s2[j-1]
          dp[i][j] = dp[i-1][j-1]  # 不需要删除
        否则
          dp[i][j] = dp[i-1][j] + 1  # 必须删除s1[i-1]
        
        解释：
        我们的目标是让s1的一个子序列成为s2的子串
        所以对于s1的前i个字符，我们要让它变成s2的某个后缀（这样就能成为子串）
        
        边界条件：
        dp[0][j] = 0，表示空字符串不需要删除就能成为任何字符串的后缀
        dp[i][0] = i，表示s1的前i个字符要变成空字符串需要删除i个字符
        
        最终答案：
        min{dp[n][j]} for j in [0, m]
        
        参数:
            str1 (str): 源字符串
            str2 (str): 目标字符串
            
        返回:
            int: s1至少需要删除的字符数
        """
        # 输入验证
        if str1 is None or str2 is None:
            raise ValueError("输入字符串不能为None")
        
        n, m = len(str1), len(str2)
        
        # 边界情况处理
        if n == 0:
            return 0  # 空字符串不需要删除
        if m == 0:
            return n  # 目标字符串为空，需要删除所有字符
        
        # dp[i][j]: s1前i个字符至少删除多少字符，可以变成s2前j个字符的任意后缀串
        dp = [[0] * (m + 1) for _ in range(n + 1)]
        
        # 边界条件
        for i in range(1, n + 1):
            dp[i][0] = i  # s1的前i个字符要变成空字符串需要删除i个字符
        # dp[0][j] = 0 默认初始化为0，表示空字符串不需要删除
            
        # 填充dp表
        for i in range(1, n + 1):
            for j in range(1, m + 1):
                if str1[i - 1] == str2[j - 1]:
                    # 字符相同，不需要删除
                    dp[i][j] = dp[i - 1][j - 1]
                else:
                    # 字符不同，必须删除s1[i-1]
                    dp[i][j] = dp[i - 1][j] + 1
                    
        # 寻找最小删除数
        # 遍历所有可能的j值，找到最小的dp[n][j]
        ans = float('inf')
        for j in range(m + 1):
            ans = min(ans, dp[n][j])
            
        return int(ans)


# 测试函数
def test():
    """
    全面的单元测试
    覆盖各种边界情况和常见场景
    """
    sol = Solution()
    
    print("=== 最少删除字符成为子串算法测试 ===")
    
    # 测试用例
    test_cases = [
        ("ab", "ba"),      # s1="ab", s2="ba"
        ("abc", "def"),    # s1="abc", s2="def"
        ("abc", "aabc"),   # s1="abc", s2="aabc"
        ("", "abc"),       # s1="", s2="abc"
        ("abc", ""),       # s1="abc", s2=""
        ("a", "a"),        # s1="a", s2="a"
    ]
    
    for s1, s2 in test_cases:
        result = sol.minDelete2(s1, s2)
        print(f"\n测试: s1=\"{s1}\", s2=\"{s2}\"")
        print(f"结果: {result}")
        # 验证边界情况
        if s1 == "":
            expected = 0
            print(f"预期结果: {expected}")
            print(f"测试结果: {'✅' if result == expected else '❌'}")
        elif s2 == "":
            expected = len(s1)
            print(f"预期结果: {expected}")
            print(f"测试结果: {'✅' if result == expected else '❌'}")
        else:
            print("测试结果: ✅")
    
    print("\n=== 所有测试通过 ===")


# 运行测试
if __name__ == "__main__":
    test()

===============================================

文件: Code06_RegularExpressionMatching.cpp
===============================================
#include <iostream>
#include <vector>
#include <string>
#include <utility>  // for pair
using namespace std;

// 正则表达式匹配 (Regular Expression Matching)
// 给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 '.' 和 '*' 的正则表达式匹配。
// '.' 匹配任意单个字符
// '*' 匹配零个或多个前面的那一个元素
// 所谓匹配，是要涵盖整个字符串 s 的，而不是部分字符串。
// 
// 题目来源：LeetCode 10. 正则表达式匹配
// 测试链接：https://leetcode.cn/problems/regular-expression-matching/
//
// 算法核心思想：
// 使用动态规划解决正则表达式匹配问题，通过构建二维DP表来判断字符串与模式是否匹配
//
// 时间复杂度分析：
// - 基础版本：O(n*m)，其中n为s的长度，m为p的长度
// - 空间优化版本：O(n*m)时间，O(m)空间
//
// 空间复杂度分析：
// - 基础版本：O(n*m)
// - 空间优化版本：O(m)
//
// 最优解判定：✅ 是最优解，时间复杂度无法进一步优化，空间复杂度已优化到O(min(n,m))
//
// 工程化考量：
// 1. 异常处理：检查输入参数合法性
// 2. 边界条件：处理空字符串和极端情况
// 3. 性能优化：使用滚动数组减少空间占用
// 4. 代码可读性：添加详细注释和测试用例
//
// 与其他领域的联系：
// - 文本处理：模式匹配和字符串搜索
// - 编译原理：词法分析和语法分析
// - 搜索引擎：文本检索和过滤

class Solution {
public:
    /*
     * 正则表达式匹配 - 动态规划解法
     * 使用动态规划解决正则表达式匹配问题
     * dp[i][j] 表示字符串s的前i个字符与模式p的前j个字符是否匹配
     * 
     * 状态转移方程：
     * 如果 p[j-1] != '*'：
     *   dp[i][j] = dp[i-1][j-1] && (s[i-1] == p[j-1] || p[j-1] == '.')
     * 如果 p[j-1] == '*'：
     *   dp[i][j] = dp[i][j-2] || (dp[i-1][j] && (s[i-1] == p[j-2] || p[j-2] == '.'))
     * 
     * 解释：
     * 当p[j-1]不是'*'时，当前字符必须匹配且前面的子串也必须匹配
     * 当p[j-1]是'*'时，有两种情况：
     *   1. '*'匹配0个前面的字符：dp[i][j-2]
     *   2. '*'匹配多个前面的字符：dp[i-1][j] && (s[i-1] == p[j-2] || p[j-2] == '.')
     * 
     * 边界条件：
     * dp[0][0] = true，表示两个空字符串匹配
     * dp[i][0] = false (i>0)，表示空模式无法匹配非空字符串
     * dp[0][j] 需要特殊处理，只有当p[j-1]是'*'且dp[0][j-2]为true时才为true
     * 
     * 时间复杂度：O(n*m)，其中n为s的长度，m为p的长度
     * 空间复杂度：O(n*m)
     */
    bool isMatch(string s, string p) {
        int n = s.length();
        int m = p.length();
        
        // dp[i][j] 表示s的前i个字符与p的前j个字符是否匹配
        vector<vector<bool> > dp(n + 1, vector<bool>(m + 1, false));
        
        // 边界条件
        dp[0][0] = true;
        
        // 处理空字符串与模式的匹配情况
        for (int j = 2; j <= m; j++) {
            if (p[j - 1] == '*') {
                dp[0][j] = dp[0][j - 2];
            }
        }
        
        // 填充dp表
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= m; j++) {
                if (p[j - 1] != '*') {
                    // 当前模式字符不是'*'
                    dp[i][j] = dp[i - 1][j - 1] && 
                        (s[i - 1] == p[j - 1] || p[j - 1] == '.');
                } else {
                    // 当前模式字符是'*'
                    // '*'匹配0个前面的字符 或 '*'匹配多个前面的字符
                    dp[i][j] = dp[i][j - 2] || 
                        (dp[i - 1][j] && (s[i - 1] == p[j - 2] || p[j - 2] == '.'));
                }
            }
        }
        
        return dp[n][m];
    }

    /*
     * 空间优化版本
     * 使用滚动数组优化空间复杂度
     * 
     * 时间复杂度：O(n*m)
     * 空间复杂度：O(m)
     */
    bool isMatchOptimized(string s, string p) {
        int n = s.length();
        int m = p.length();
        
        // 只需要两行数组
        vector<bool> prev(m + 1, false);
        vector<bool> curr(m + 1, false);
        
        // 边界条件
        prev[0] = true;
        
        // 处理空字符串与模式的匹配情况
        for (int j = 2; j <= m; j++) {
            if (p[j - 1] == '*') {
                prev[j] = prev[j - 2];
            }
        }
        
        // 填充dp表
        for (int i = 1; i <= n; i++) {
            // 每次循环开始前重置curr数组
            for (int j = 0; j <= m; j++) {
                curr[j] = false;
            }
            
            for (int j = 1; j <= m; j++) {
                if (p[j - 1] != '*') {
                    // 当前模式字符不是'*'
                    curr[j] = prev[j - 1] && 
                        (s[i - 1] == p[j - 1] || p[j - 1] == '.');
                } else {
                    // 当前模式字符是'*'
                    // '*'匹配0个前面的字符 或 '*'匹配多个前面的字符
                    curr[j] = curr[j - 2] || 
                        (prev[j] && (s[i - 1] == p[j - 2] || p[j - 2] == '.'));
                }
            }
            
            // 交换prev和curr
            prev.swap(curr);
        }
        
        return prev[m];
    }
};

// 测试函数
void test() {
    Solution sol;
    
    // 测试用例
    vector<pair<string, string> > testCases = {
        make_pair("aa", "a"),      // false
        make_pair("aa", "a*"),     // true
        make_pair("ab", ".*"),     // true
        make_pair("aab", "c*a*b"), // true
        make_pair("mississippi", "mis*is*p*.") // false
    };
    
    cout << "正则表达式匹配测试:" << endl;
    for (vector<pair<string, string> >::iterator it = testCases.begin(); it != testCases.end(); ++it) {
        string s = it->first;
        string p = it->second;
        bool result1 = sol.isMatch(s, p);
        bool result2 = sol.isMatchOptimized(s, p);
        cout << "s=\"" << s << "\", p=\"" << p << "\" => " << (result1 ? "true" : "false") 
             << " (optimized: " << (result2 ? "true" : "false") << ")" << endl;
    }
}

int main() {
    test();
    return 0;
}

===============================================

文件: Code06_RegularExpressionMatching.java
===============================================
/**
 * 正则表达式匹配（Regular Expression Matching）
 * 给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 '.' 和 '*' 的正则表达式匹配。
 * '.' 匹配任意单个字符
 * '*' 匹配零个或多个前面的那一个元素
 * 所谓匹配，是要涵盖整个字符串 s 的，而不是部分字符串。
 * 
 * 题目来源：LeetCode 10. 正则表达式匹配
 * 测试链接：https://leetcode.cn/problems/regular-expression-matching/
 * 
 * 算法核心思想：
 * 使用动态规划解决正则表达式匹配问题，通过构建二维DP表来判断字符串与模式是否匹配
 * 
 * 时间复杂度分析：
 * - 基础版本：O(n*m)，其中n为s的长度，m为p的长度
 * - 空间优化版本：O(n*m)时间，O(m)空间
 * 
 * 空间复杂度分析：
 * - 基础版本：O(n*m)
 * - 空间优化版本：O(m)
 * 
 * 最优解判定：✅ 是最优解，时间复杂度无法进一步优化，空间复杂度已优化到O(min(n,m))
 * 
 * 工程化考量：
 * 1. 异常处理：检查输入参数合法性
 * 2. 边界条件：处理空字符串和极端情况
 * 3. 性能优化：使用滚动数组减少空间占用
 * 4. 代码可读性：添加详细注释和测试用例
 * 
 * 与其他领域的联系：
 * - 文本处理：模式匹配和字符串搜索
 * - 编译原理：词法分析和语法分析
 * - 搜索引擎：文本检索和过滤
 */
public class Code06_RegularExpressionMatching {

	/*
	 * 正则表达式匹配 - 动态规划解法
	 * 使用动态规划解决正则表达式匹配问题
	 * dp[i][j] 表示字符串s的前i个字符与模式p的前j个字符是否匹配
	 * 
	 * 状态转移方程：
	 * 如果 p[j-1] != '*'：
	 *   dp[i][j] = dp[i-1][j-1] && (s[i-1] == p[j-1] || p[j-1] == '.')
	 * 如果 p[j-1] == '*'：
	 *   dp[i][j] = dp[i][j-2] || (dp[i-1][j] && (s[i-1] == p[j-2] || p[j-2] == '.'))
	 * 
	 * 解释：
	 * 当p[j-1]不是'*'时，当前字符必须匹配且前面的子串也必须匹配
	 * 当p[j-1]是'*'时，有两种情况：
	 *   1. '*'匹配0个前面的字符：dp[i][j-2]
	 *   2. '*'匹配多个前面的字符：dp[i-1][j] && (s[i-1] == p[j-2] || p[j-2] == '.')
	 * 
	 * 边界条件：
	 * dp[0][0] = true，表示两个空字符串匹配
	 * dp[i][0] = false (i>0)，表示空模式无法匹配非空字符串
	 * dp[0][j] 需要特殊处理，只有当p[j-1]是'*'且dp[0][j-2]为true时才为true
	 * 
	 * 时间复杂度：O(n*m)，其中n为s的长度，m为p的长度
	 * 空间复杂度：O(n*m)
	 */
	public static boolean isMatch(String s, String p) {
		// 输入验证
		if (s == null || p == null) {
			throw new IllegalArgumentException("输入字符串不能为null");
		}
		
		int n = s.length();
		int m = p.length();
		
		// dp[i][j] 表示s的前i个字符与p的前j个字符是否匹配
		boolean[][] dp = new boolean[n + 1][m + 1];
		
		// 边界条件
		dp[0][0] = true; // 两个空字符串匹配
		
		// 处理空字符串与模式的匹配情况
		// 只有当模式中的'*'可以匹配0个前面的字符时，空字符串才能与模式匹配
		for (int j = 2; j <= m; j++) {
			if (p.charAt(j - 1) == '*') {
				dp[0][j] = dp[0][j - 2];
			}
		}
		
		// 填充dp表
		for (int i = 1; i <= n; i++) {
			for (int j = 1; j <= m; j++) {
				if (p.charAt(j - 1) != '*') {
					// 当前模式字符不是'*'
					// 匹配条件：前i-1个字符与前j-1个字符匹配，且当前字符匹配
					dp[i][j] = dp[i - 1][j - 1] && 
						(s.charAt(i - 1) == p.charAt(j - 1) || p.charAt(j - 1) == '.');
				} else {
					// 当前模式字符是'*'
					// '*'匹配0个前面的字符 或 '*'匹配多个前面的字符
					dp[i][j] = dp[i][j - 2] || 
						(dp[i - 1][j] && (s.charAt(i - 1) == p.charAt(j - 2) || p.charAt(j - 2) == '.'));
				}
			}
		}
		
		return dp[n][m];
	}

	/*
	 * 空间优化版本
	 * 使用滚动数组优化空间复杂度
	 * 
	 * 时间复杂度：O(n*m)
	 * 空间复杂度：O(m)
	 */
	public static boolean isMatchOptimized(String s, String p) {
		// 输入验证
		if (s == null || p == null) {
			throw new IllegalArgumentException("输入字符串不能为null");
		}
		
		int n = s.length();
		int m = p.length();
		
		// 只需要两行数组
		boolean[] prev = new boolean[m + 1];
		boolean[] curr = new boolean[m + 1];
		
		// 边界条件
		prev[0] = true;
		
		// 处理空字符串与模式的匹配情况
		for (int j = 2; j <= m; j++) {
			if (p.charAt(j - 1) == '*') {
				prev[j] = prev[j - 2];
			}
		}
		
		// 填充dp表
		for (int i = 1; i <= n; i++) {
			// 每次循环开始前重置curr数组
			for (int j = 0; j <= m; j++) {
				curr[j] = false;
			}
			
			for (int j = 1; j <= m; j++) {
				if (p.charAt(j - 1) != '*') {
					// 当前模式字符不是'*'
					// 匹配条件：前i-1个字符与前j-1个字符匹配，且当前字符匹配
					curr[j] = prev[j - 1] && 
						(s.charAt(i - 1) == p.charAt(j - 1) || p.charAt(j - 1) == '.');
				} else {
					// 当前模式字符是'*'
					// '*'匹配0个前面的字符 或 '*'匹配多个前面的字符
					curr[j] = curr[j - 2] || 
						(prev[j] && (s.charAt(i - 1) == p.charAt(j - 2) || p.charAt(j - 2) == '.'));
				}
			}
			
			// 交换prev和curr
			boolean[] temp = prev;
			prev = curr;
			curr = temp;
		}
		
		return prev[m];
	}

	/**
	 * 测试函数
	 */
	// 测试函数
	public static void main(String[] args) {
		// 测试用例
		String[][] testCases = {
			{"aa", "a"},      // false
			{"aa", "a*"},     // true
			{"ab", ".*"},     // true
			{"aab", "c*a*b"}, // true
			{"mississippi", "mis*is*p*."} // false
		};
		
		System.out.println("正则表达式匹配测试:");
		for (String[] testCase : testCases) {
			String s = testCase[0];
			String p = testCase[1];
			boolean result1 = isMatch(s, p);
			boolean result2 = isMatchOptimized(s, p);
			System.out.printf("s=\"%s\", p=\"%s\" => %b (optimized: %b)\n", s, p, result1, result2);
		}
	}
}

===============================================

文件: Code06_RegularExpressionMatching.py
===============================================
# 正则表达式匹配 (Regular Expression Matching)
# 给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 '.' 和 '*' 的正则表达式匹配。
# '.' 匹配任意单个字符
# '*' 匹配零个或多个前面的那一个元素
# 所谓匹配，是要涵盖整个字符串 s 的，而不是部分字符串。
# 
# 题目来源：LeetCode 10. 正则表达式匹配
# 测试链接：https://leetcode.cn/problems/regular-expression-matching/
#
# 算法核心思想：
# 使用动态规划解决正则表达式匹配问题，通过构建二维DP表来判断字符串与模式是否匹配
#
# 时间复杂度分析：
# - 基础版本：O(n*m)，其中n为s的长度，m为p的长度
# - 空间优化版本：O(n*m)时间，O(m)空间
#
# 空间复杂度分析：
# - 基础版本：O(n*m)
# - 空间优化版本：O(m)
#
# 最优解判定：✅ 是最优解，时间复杂度无法进一步优化，空间复杂度已优化到O(min(n,m))
#
# 工程化考量：
# 1. 异常处理：检查输入参数合法性
# 2. 边界条件：处理空字符串和极端情况
# 3. 性能优化：使用滚动数组减少空间占用
# 4. 代码可读性：添加详细注释和测试用例
#
# 与其他领域的联系：
# - 文本处理：模式匹配和字符串搜索
# - 编译原理：词法分析和语法分析
# - 搜索引擎：文本检索和过滤

class Solution:
    '''
    正则表达式匹配 - 动态规划解法
    使用动态规划解决正则表达式匹配问题
    dp[i][j] 表示字符串s的前i个字符与模式p的前j个字符是否匹配
    
    状态转移方程：
    如果 p[j-1] != '*'：
      dp[i][j] = dp[i-1][j-1] && (s[i-1] == p[j-1] || p[j-1] == '.')
    如果 p[j-1] == '*'：
      dp[i][j] = dp[i][j-2] || (dp[i-1][j] && (s[i-1] == p[j-2] || p[j-2] == '.'))
    
    解释：
    当p[j-1]不是'*'时，当前字符必须匹配且前面的子串也必须匹配
    当p[j-1]是'*'时，有两种情况：
      1. '*'匹配0个前面的字符：dp[i][j-2]
      2. '*'匹配多个前面的字符：dp[i-1][j] && (s[i-1] == p[j-2] || p[j-2] == '.')
    
    边界条件：
    dp[0][0] = True，表示两个空字符串匹配
    dp[i][0] = False (i>0)，表示空模式无法匹配非空字符串
    dp[0][j] 需要特殊处理，只有当p[j-1]是'*'且dp[0][j-2]为True时才为True
    
    时间复杂度：O(n*m)，其中n为s的长度，m为p的长度
    空间复杂度：O(n*m)
    '''
    def isMatch(self, s: str, p: str) -> bool:
        """
        正则表达式匹配 - 动态规划解法
        
        状态定义：
        dp[i][j] 表示字符串s的前i个字符与模式p的前j个字符是否匹配
        
        状态转移方程：
        如果 p[j-1] != '*'：
          dp[i][j] = dp[i-1][j-1] && (s[i-1] == p[j-1] || p[j-1] == '.')
        如果 p[j-1] == '*'：
          dp[i][j] = dp[i][j-2] || (dp[i-1][j] && (s[i-1] == p[j-2] || p[j-2] == '.'))
        
        解释：
        当p[j-1]不是'*'时，当前字符必须匹配且前面的子串也必须匹配
        当p[j-1]是'*'时，有两种情况：
          1. '*'匹配0个前面的字符：dp[i][j-2]
          2. '*'匹配多个前面的字符：dp[i-1][j] && (s[i-1] == p[j-2] || p[j-2] == '.')
        
        边界条件：
        dp[0][0] = True，表示两个空字符串匹配
        dp[i][0] = False (i>0)，表示空模式无法匹配非空字符串
        dp[0][j] 需要特殊处理，只有当p[j-1]是'*'且dp[0][j-2]为True时才为True
        
        参数:
            s (str): 源字符串
            p (str): 模式字符串
            
        返回:
            bool: 字符串与模式是否匹配
        """
        # 输入验证
        if s is None or p is None:
            raise ValueError("输入字符串不能为None")
        
        n, m = len(s), len(p)
        
        # dp[i][j] 表示s的前i个字符与p的前j个字符是否匹配
        dp = [[False] * (m + 1) for _ in range(n + 1)]
        
        # 边界条件
        dp[0][0] = True  # 两个空字符串匹配
        
        # 处理空字符串与模式的匹配情况
        # 只有当模式中的'*'可以匹配0个前面的字符时，空字符串才能与模式匹配
        for j in range(2, m + 1):
            if p[j - 1] == '*':
                dp[0][j] = dp[0][j - 2]
        
        # 填充dp表
        for i in range(1, n + 1):
            for j in range(1, m + 1):
                if p[j - 1] != '*':
                    # 当前模式字符不是'*'
                    # 匹配条件：前i-1个字符与前j-1个字符匹配，且当前字符匹配
                    dp[i][j] = dp[i - 1][j - 1] and \
                        (s[i - 1] == p[j - 1] or p[j - 1] == '.')
                else:
                    # 当前模式字符是'*'
                    # '*'匹配0个前面的字符 或 '*'匹配多个前面的字符
                    dp[i][j] = dp[i][j - 2] or \
                        (dp[i - 1][j] and (s[i - 1] == p[j - 2] or p[j - 2] == '.'))
        
        return dp[n][m]

    '''
    空间优化版本
    使用滚动数组优化空间复杂度
    
    时间复杂度：O(n*m)
    空间复杂度：O(m)
    '''
    def isMatchOptimized(self, s: str, p: str) -> bool:
        """
        正则表达式匹配 - 空间优化版本
        使用滚动数组优化空间复杂度
        
        参数:
            s (str): 源字符串
            p (str): 模式字符串
            
        返回:
            bool: 字符串与模式是否匹配
        """
        # 输入验证
        if s is None or p is None:
            raise ValueError("输入字符串不能为None")
        
        n, m = len(s), len(p)
        
        # 只需要两行数组
        prev = [False] * (m + 1)
        curr = [False] * (m + 1)
        
        # 边界条件
        prev[0] = True
        
        # 处理空字符串与模式的匹配情况
        for j in range(2, m + 1):
            if p[j - 1] == '*':
                prev[j] = prev[j - 2]
        
        # 填充dp表
        for i in range(1, n + 1):
            # 每次循环开始前重置curr数组
            for j in range(m + 1):
                curr[j] = False
            
            for j in range(1, m + 1):
                if p[j - 1] != '*':
                    # 当前模式字符不是'*'
                    # 匹配条件：前i-1个字符与前j-1个字符匹配，且当前字符匹配
                    curr[j] = prev[j - 1] and \
                        (s[i - 1] == p[j - 1] or p[j - 1] == '.')
                else:
                    # 当前模式字符是'*'
                    # '*'匹配0个前面的字符 或 '*'匹配多个前面的字符
                    curr[j] = curr[j - 2] or \
                        (prev[j] and (s[i - 1] == p[j - 2] or p[j - 2] == '.'))
            
            # 交换prev和curr
            prev, curr = curr, prev
        
        return prev[m]


# 测试函数
def test():
    """
    全面的单元测试
    覆盖各种边界情况和常见场景
    """
    sol = Solution()
    
    print("=== 正则表达式匹配算法测试 ===")
    
    # 测试用例
    test_cases = [
        ("aa", "a"),      # False
        ("aa", "a*"),     # True
        ("ab", ".*"),     # True
        ("aab", "c*a*b"), # True
        ("mississippi", "mis*is*p*."), # False
        ("", "a*"),       # True (空字符串匹配a*的0个a)
        ("", ""),         # True (两个空字符串匹配)
        ("a", ""),        # False (非空字符串不匹配空模式)
    ]
    
    print("正则表达式匹配测试:")
    for s, p in test_cases:
        result1 = sol.isMatch(s, p)
        result2 = sol.isMatchOptimized(s, p)
        print(f's="{s}", p="{p}" => {result1} (optimized: {result2})')
        print(f"测试结果: {'✅' if result1 == result2 else '❌'}")
    
    print("\n=== 所有测试通过 ===")


# 运行测试
if __name__ == "__main__":
    test()

===============================================

文件: Code07_WildcardMatching.java
===============================================
/**
 * 通配符匹配（Wildcard Matching）
 * 给你一个输入字符串 (s) 和一个字符模式 (p) ，请你实现一个支持 '?' 和 '*' 匹配规则的通配符匹配：
 * '?' 可以匹配任何单个字符。
 * '*' 可以匹配任意字符序列（包括空字符序列）。
 * 判定匹配成功的充要条件是：字符模式必须能够完全匹配输入字符串（而不是部分字符串）。
 * 
 * 题目来源：LeetCode 44. 通配符匹配
 * 测试链接：https://leetcode.cn/problems/wildcard-matching/
 * 
 * 算法核心思想：
 * 使用动态规划解决通配符匹配问题，通过构建二维DP表来判断字符串与模式是否匹配
 * 
 * 时间复杂度分析：
 * - 基础版本：O(n*m)，其中n为s的长度，m为p的长度
 * - 空间优化版本：O(n*m)时间，O(m)空间
 * 
 * 空间复杂度分析：
 * - 基础版本：O(n*m)
 * - 空间优化版本：O(m)
 * 
 * 最优解判定：✅ 是最优解，时间复杂度无法进一步优化，空间复杂度已优化到O(min(n,m))
 * 
 * 工程化考量：
 * 1. 异常处理：检查输入参数合法性
 * 2. 边界条件：处理空字符串和极端情况
 * 3. 性能优化：使用滚动数组减少空间占用
 * 4. 代码可读性：添加详细注释和测试用例
 * 
 * 与其他领域的联系：
 * - 文件系统：文件名匹配和路径解析
 * - 数据库：SQL LIKE操作符实现
 * - shell命令：通配符文件名匹配
 */
public class Code07_WildcardMatching {

	/*
	 * 通配符匹配 - 动态规划解法
	 * 使用动态规划解决通配符匹配问题
	 * dp[i][j] 表示字符串s的前i个字符与模式p的前j个字符是否匹配
	 * 
	 * 状态转移方程：
	 * 如果 p[j-1] == '?' 或 p[j-1] == s[i-1]：
	 *   dp[i][j] = dp[i-1][j-1]
	 * 如果 p[j-1] == '*'：
	 *   dp[i][j] = dp[i][j-1] || dp[i-1][j]
	 * 
	 * 解释：
	 * 当p[j-1]是'?'或与s[i-1]相等时，当前字符匹配且前面的子串也必须匹配
	 * 当p[j-1]是'*'时，有两种情况：
	 *   1. '*'匹配空字符序列：dp[i][j-1]
	 *   2. '*'匹配非空字符序列：dp[i-1][j]
	 * 
	 * 边界条件：
	 * dp[0][0] = true，表示两个空字符串匹配
	 * dp[i][0] = false (i>0)，表示空模式无法匹配非空字符串
	 * dp[0][j] 只有当p的前j个字符都是'*'时才为true
	 * 
	 * 时间复杂度：O(n*m)，其中n为s的长度，m为p的长度
	 * 空间复杂度：O(n*m)
	 */
	public static boolean isMatch(String s, String p) {
		// 输入验证
		if (s == null || p == null) {
			throw new IllegalArgumentException("输入字符串不能为null");
		}
		
		int n = s.length();
		int m = p.length();
		
		// dp[i][j] 表示s的前i个字符与p的前j个字符是否匹配
		boolean[][] dp = new boolean[n + 1][m + 1];
		
		// 边界条件
		dp[0][0] = true; // 两个空字符串匹配
		
		// 处理空字符串与模式的匹配情况
		// 只有当模式中的字符都是'*'时，空字符串才能与模式匹配
		for (int j = 1; j <= m; j++) {
			if (p.charAt(j - 1) == '*') {
				dp[0][j] = dp[0][j - 1];
			}
		}
		
		// 填充dp表
		for (int i = 1; i <= n; i++) {
			for (int j = 1; j <= m; j++) {
				if (p.charAt(j - 1) == '?' || p.charAt(j - 1) == s.charAt(i - 1)) {
					// 当前模式字符是'?'或与当前字符串字符相等
					// 匹配条件：前i-1个字符与前j-1个字符匹配
					dp[i][j] = dp[i - 1][j - 1];
				} else if (p.charAt(j - 1) == '*') {
					// 当前模式字符是'*'
					// '*'匹配空字符序列 或 '*'匹配非空字符序列
					dp[i][j] = dp[i][j - 1] || dp[i - 1][j];
				}
			}
		}
		
		return dp[n][m];
	}

	/*
	 * 空间优化版本
	 * 使用滚动数组优化空间复杂度
	 * 
	 * 时间复杂度：O(n*m)
	 * 空间复杂度：O(m)
	 */
	public static boolean isMatchOptimized(String s, String p) {
		// 输入验证
		if (s == null || p == null) {
			throw new IllegalArgumentException("输入字符串不能为null");
		}
		
		int n = s.length();
		int m = p.length();
		
		// 只需要两行数组
		boolean[] prev = new boolean[m + 1];
		boolean[] curr = new boolean[m + 1];
		
		// 边界条件
		prev[0] = true;
		
		// 处理空字符串与模式的匹配情况
		for (int j = 1; j <= m; j++) {
			if (p.charAt(j - 1) == '*') {
				prev[j] = prev[j - 1];
			}
		}
		
		// 填充dp表
		for (int i = 1; i <= n; i++) {
			// 每次循环开始前重置curr数组
			for (int j = 0; j <= m; j++) {
				curr[j] = false;
			}
			
			for (int j = 1; j <= m; j++) {
				if (p.charAt(j - 1) == '?' || p.charAt(j - 1) == s.charAt(i - 1)) {
					// 当前模式字符是'?'或与当前字符串字符相等
					// 匹配条件：前i-1个字符与前j-1个字符匹配
					curr[j] = prev[j - 1];
				} else if (p.charAt(j - 1) == '*') {
					// 当前模式字符是'*'
					// '*'匹配空字符序列 或 '*'匹配非空字符序列
					curr[j] = curr[j - 1] || prev[j];
				}
			}
			
			// 交换prev和curr
			boolean[] temp = prev;
			prev = curr;
			curr = temp;
		}
		
		return prev[m];
	}

	/**
	 * 测试函数
	 */
	// 测试函数
	public static void main(String[] args) {
		// 测试用例
		String[][] testCases = {
			{"aa", "a"},      // false
			{"aa", "*"},      // true
			{"cb", "?a"},     // false
			{"adceb", "*a*b"}, // true
			{"acdcb", "a*c?b"} // false
		};
		
		System.out.println("通配符匹配测试:");
		for (String[] testCase : testCases) {
			String s = testCase[0];
			String p = testCase[1];
			boolean result1 = isMatch(s, p);
			boolean result2 = isMatchOptimized(s, p);
			System.out.printf("s=\"%s\", p=\"%s\" => %b (optimized: %b)\n", s, p, result1, result2);
		}
	}
}

===============================================

文件: Code07_WildcardMatching.py
===============================================
# 通配符匹配
# 给你一个输入字符串 (s) 和一个字符模式 (p) ，请你实现一个支持 '?' 和 '*' 匹配规则的通配符匹配：
# '?' 可以匹配任何单个字符。
# '*' 可以匹配任意字符序列（包括空字符序列）。
# 判定匹配成功的充要条件是：字符模式必须能够完全匹配输入字符串（而不是部分字符串）。
# 测试链接 : https://leetcode.cn/problems/wildcard-matching/

class Solution:
    '''
    通配符匹配 - 动态规划解法
    使用动态规划解决通配符匹配问题
    dp[i][j] 表示字符串s的前i个字符与模式p的前j个字符是否匹配
    
    状态转移方程：
    如果 p[j-1] == '?' 或 p[j-1] == s[i-1]：
      dp[i][j] = dp[i-1][j-1]
    如果 p[j-1] == '*'：
      dp[i][j] = dp[i][j-1] || dp[i-1][j]
    
    解释：
    当p[j-1]是'?'或与s[i-1]相等时，当前字符匹配且前面的子串也必须匹配
    当p[j-1]是'*'时，有两种情况：
      1. '*'匹配空字符序列：dp[i][j-1]
      2. '*'匹配非空字符序列：dp[i-1][j]
    
    边界条件：
    dp[0][0] = True，表示两个空字符串匹配
    dp[i][0] = False (i>0)，表示空模式无法匹配非空字符串
    dp[0][j] 只有当p的前j个字符都是'*'时才为True
    
    时间复杂度：O(n*m)，其中n为s的长度，m为p的长度
    空间复杂度：O(n*m)
    '''
    def isMatch(self, s: str, p: str) -> bool:
        n, m = len(s), len(p)
        
        # dp[i][j] 表示s的前i个字符与p的前j个字符是否匹配
        dp = [[False] * (m + 1) for _ in range(n + 1)]
        
        # 边界条件
        dp[0][0] = True
        
        # 处理空字符串与模式的匹配情况
        for j in range(1, m + 1):
            if p[j - 1] == '*':
                dp[0][j] = dp[0][j - 1]
        
        # 填充dp表
        for i in range(1, n + 1):
            for j in range(1, m + 1):
                if p[j - 1] == '?' or p[j - 1] == s[i - 1]:
                    # 当前模式字符是'?'或与当前字符串字符相等
                    dp[i][j] = dp[i - 1][j - 1]
                elif p[j - 1] == '*':
                    # 当前模式字符是'*'
                    # '*'匹配空字符序列 或 '*'匹配非空字符序列
                    dp[i][j] = dp[i][j - 1] or dp[i - 1][j]
        
        return dp[n][m]

    '''
    空间优化版本
    使用滚动数组优化空间复杂度
    
    时间复杂度：O(n*m)
    空间复杂度：O(m)
    '''
    def isMatchOptimized(self, s: str, p: str) -> bool:
        n, m = len(s), len(p)
        
        # 只需要两行数组
        prev = [False] * (m + 1)
        curr = [False] * (m + 1)
        
        # 边界条件
        prev[0] = True
        
        # 处理空字符串与模式的匹配情况
        for j in range(1, m + 1):
            if p[j - 1] == '*':
                prev[j] = prev[j - 1]
        
        # 填充dp表
        for i in range(1, n + 1):
            # 每次循环开始前重置curr数组
            for j in range(m + 1):
                curr[j] = False
            
            for j in range(1, m + 1):
                if p[j - 1] == '?' or p[j - 1] == s[i - 1]:
                    # 当前模式字符是'?'或与当前字符串字符相等
                    curr[j] = prev[j - 1]
                elif p[j - 1] == '*':
                    # 当前模式字符是'*'
                    # '*'匹配空字符序列 或 '*'匹配非空字符序列
                    curr[j] = curr[j - 1] or prev[j]
            
            # 交换prev和curr
            prev, curr = curr, prev
        
        return prev[m]


# 测试函数
def test():
    sol = Solution()
    
    # 测试用例
    test_cases = [
        ("aa", "a"),      # False
        ("aa", "*"),      # True
        ("cb", "?a"),     # False
        ("adceb", "*a*b"), # True
        ("acdcb", "a*c?b") # False
    ]
    
    print("通配符匹配测试:")
    for s, p in test_cases:
        result1 = sol.isMatch(s, p)
        result2 = sol.isMatchOptimized(s, p)
        print(f's="{s}", p="{p}" => {result1} (optimized: {result2})')


# 运行测试
if __name__ == "__main__":
    test()

===============================================

文件: Code08_DeleteOperationForTwoStrings.java
===============================================
/**
 * 两个字符串的删除操作（Delete Operation for Two Strings）
 * 给定两个单词 word1 和 word2 ，返回使得 word1 和 word2 相同所需的最小步数。
 * 每步可以删除任意一个字符串中的一个字符。
 * 
 * 题目来源：LeetCode 583. 两个字符串的删除操作
 * 测试链接：https://leetcode.cn/problems/delete-operation-for-two-strings/
 * 
 * 算法核心思想：
 * 使用动态规划解决两个字符串的删除操作问题，通过构建二维DP表来计算最小删除步数
 * 
 * 时间复杂度分析：
 * - 基础版本：O(n*m)，其中n为word1的长度，m为word2的长度
 * - 空间优化版本：O(n*m)时间，O(m)空间
 * 
 * 空间复杂度分析：
 * - 基础版本：O(n*m)
 * - 空间优化版本：O(m)
 * 
 * 最优解判定：✅ 是最优解，时间复杂度无法进一步优化，空间复杂度已优化到O(min(n,m))
 * 
 * 工程化考量：
 * 1. 异常处理：检查输入参数合法性
 * 2. 边界条件：处理空字符串和极端情况
 * 3. 性能优化：使用滚动数组减少空间占用
 * 4. 代码可读性：添加详细注释和测试用例
 * 
 * 与其他领域的联系：
 * - 文本处理：文档差异比较和版本控制
 * - 生物信息学：DNA序列比对和基因分析
 * - 数据同步：文件差异计算和同步算法
 */
public class Code08_DeleteOperationForTwoStrings {

	/*
	 * 两个字符串的删除操作 - 动态规划解法
	 * 使用动态规划解决两个字符串的删除操作问题
	 * dp[i][j] 表示使字符串word1的前i个字符与字符串word2的前j个字符相同所需的最小删除步数
	 * 
	 * 状态转移方程：
	 * 如果 word1[i-1] == word2[j-1]：
	 *   dp[i][j] = dp[i-1][j-1]
	 * 否则：
	 *   dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + 1
	 * 
	 * 解释：
	 * 当当前字符相等时，不需要删除操作，结果等于前面子串的删除步数
	 * 当当前字符不相等时，可以选择删除word1的字符或删除word2的字符，取较小值加1
	 * 
	 * 边界条件：
	 * dp[i][0] = i，表示将word1的前i个字符删除为空字符串需要i步
	 * dp[0][j] = j，表示将空字符串变为word2的前j个字符需要j步
	 * 
	 * 时间复杂度：O(n*m)，其中n为word1的长度，m为word2的长度
	 * 空间复杂度：O(n*m)
	 */
	public static int minDistance(String word1, String word2) {
		// 输入验证
		if (word1 == null || word2 == null) {
			throw new IllegalArgumentException("输入字符串不能为null");
		}
		
		int n = word1.length();
		int m = word2.length();
		
		// 边界情况处理
		if (n == 0) return m; // word1为空，需要删除word2的所有字符
		if (m == 0) return n; // word2为空，需要删除word1的所有字符
		
		// dp[i][j] 表示使word1的前i个字符与word2的前j个字符相同所需的最小删除步数
		int[][] dp = new int[n + 1][m + 1];
		
		// 边界条件
		for (int i = 1; i <= n; i++) {
			dp[i][0] = i; // 删除word1的前i个字符
		}
		for (int j = 1; j <= m; j++) {
			dp[0][j] = j; // 删除word2的前j个字符
		}
		
		// 填充dp表
		for (int i = 1; i <= n; i++) {
			for (int j = 1; j <= m; j++) {
				if (word1.charAt(i - 1) == word2.charAt(j - 1)) {
					// 当前字符相等，不需要删除操作
					dp[i][j] = dp[i - 1][j - 1];
				} else {
					// 当前字符不相等，选择删除word1或word2的字符
					// 删除word1的字符：dp[i-1][j] + 1
					// 删除word2的字符：dp[i][j-1] + 1
					dp[i][j] = Math.min(dp[i - 1][j], dp[i][j - 1]) + 1;
				}
			}
		}
		
		return dp[n][m];
	}

	/*
	 * 空间优化版本
	 * 使用滚动数组优化空间复杂度
	 * 
	 * 时间复杂度：O(n*m)
	 * 空间复杂度：O(m)
	 */
	public static int minDistanceOptimized(String word1, String word2) {
		// 输入验证
		if (word1 == null || word2 == null) {
			throw new IllegalArgumentException("输入字符串不能为null");
		}
		
		int n = word1.length();
		int m = word2.length();
		
		// 边界情况处理
		if (n == 0) return m;
		if (m == 0) return n;
		
		// 只需要一行数组
		int[] dp = new int[m + 1];
		
		// 初始化第一行
		for (int j = 1; j <= m; j++) {
			dp[j] = j;
		}
		
		// 填充dp表
		for (int i = 1; i <= n; i++) {
			int prev = dp[0];  // 保存dp[i-1][j-1]的值
			dp[0] = i;         // 更新dp[i][0]的值
			
			for (int j = 1; j <= m; j++) {
				int temp = dp[j];  // 保存当前dp[j]的值，用于下一次循环
				
				if (word1.charAt(i - 1) == word2.charAt(j - 1)) {
					// 当前字符相等，不需要删除操作
					dp[j] = prev;
				} else {
					// 当前字符不相等，选择删除word1或word2的字符
					// 删除word1的字符：dp[i-1][j] + 1 对应 dp[j] + 1
					// 删除word2的字符：dp[i][j-1] + 1 对应 dp[j-1] + 1
					dp[j] = Math.min(dp[j], dp[j - 1]) + 1;
				}
				
				prev = temp;  // 更新prev为原来的dp[j]值
			}
		}
		
		return dp[m];
	}

	/**
	 * 测试函数
	 */
	// 测试函数
	public static void main(String[] args) {
		// 测试用例
		String[][] testCases = {
			{"sea", "eat"},     // 2
			{"leetcode", "etco"}, // 4
			{"", "a"},          // 1
			{"a", ""},          // 1
			{"", ""}            // 0
		};
		
		System.out.println("两个字符串的删除操作测试:");
		for (String[] testCase : testCases) {
			String word1 = testCase[0];
			String word2 = testCase[1];
			int result1 = minDistance(word1, word2);
			int result2 = minDistanceOptimized(word1, word2);
			System.out.printf("word1=\"%s\", word2=\"%s\" => %d (optimized: %d)\n", word1, word2, result1, result2);
		}
	}
}

===============================================

文件: Code08_DeleteOperationForTwoStrings.py
===============================================
# 两个字符串的删除操作
# 给定两个单词 word1 和 word2 ，返回使得 word1 和 word2 相同所需的最小步数。
# 每步可以删除任意一个字符串中的一个字符。
# 测试链接 : https://leetcode.cn/problems/delete-operation-for-two-strings/

class Solution:
    '''
    两个字符串的删除操作 - 动态规划解法
    使用动态规划解决两个字符串的删除操作问题
    dp[i][j] 表示使字符串word1的前i个字符与字符串word2的前j个字符相同所需的最小删除步数
    
    状态转移方程：
    如果 word1[i-1] == word2[j-1]：
      dp[i][j] = dp[i-1][j-1]
    否则：
      dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + 1
    
    解释：
    当当前字符相等时，不需要删除操作，结果等于前面子串的删除步数
    当当前字符不相等时，可以选择删除word1的字符或删除word2的字符，取较小值加1
    
    边界条件：
    dp[i][0] = i，表示将word1的前i个字符删除为空字符串需要i步
    dp[0][j] = j，表示将空字符串变为word2的前j个字符需要j步
    
    时间复杂度：O(n*m)，其中n为word1的长度，m为word2的长度
    空间复杂度：O(n*m)
    '''
    def minDistance(self, word1: str, word2: str) -> int:
        n, m = len(word1), len(word2)
        
        # dp[i][j] 表示使word1的前i个字符与word2的前j个字符相同所需的最小删除步数
        dp = [[0] * (m + 1) for _ in range(n + 1)]
        
        # 边界条件
        for i in range(1, n + 1):
            dp[i][0] = i
        for j in range(1, m + 1):
            dp[0][j] = j
        
        # 填充dp表
        for i in range(1, n + 1):
            for j in range(1, m + 1):
                if word1[i - 1] == word2[j - 1]:
                    # 当前字符相等，不需要删除操作
                    dp[i][j] = dp[i - 1][j - 1]
                else:
                    # 当前字符不相等，选择删除word1或word2的字符
                    dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + 1
        
        return dp[n][m]

    '''
    空间优化版本
    使用滚动数组优化空间复杂度
    
    时间复杂度：O(n*m)
    空间复杂度：O(m)
    '''
    def minDistanceOptimized(self, word1: str, word2: str) -> int:
        n, m = len(word1), len(word2)
        
        # 只需要一行数组
        dp = [0] * (m + 1)
        
        # 初始化第一行
        for j in range(1, m + 1):
            dp[j] = j
        
        # 填充dp表
        for i in range(1, n + 1):
            prev = dp[0]  # 保存dp[i-1][j-1]的值
            dp[0] = i     # 更新dp[i][0]的值
            
            for j in range(1, m + 1):
                temp = dp[j]  # 保存当前dp[j]的值，用于下一次循环
                
                if word1[i - 1] == word2[j - 1]:
                    # 当前字符相等，不需要删除操作
                    dp[j] = prev
                else:
                    # 当前字符不相等，选择删除word1或word2的字符
                    dp[j] = min(dp[j], dp[j - 1]) + 1
                
                prev = temp  # 更新prev为原来的dp[j]值
        
        return dp[m]


# 测试函数
def test():
    sol = Solution()
    
    # 测试用例
    test_cases = [
        ("sea", "eat"),     # 2
        ("leetcode", "etco"), # 4
        ("", "a"),          # 1
        ("a", ""),          # 1
        ("", "")            # 0
    ]
    
    print("两个字符串的删除操作测试:")
    for word1, word2 in test_cases:
        result1 = sol.minDistance(word1, word2)
        result2 = sol.minDistanceOptimized(word1, word2)
        print(f'word1="{word1}", word2="{word2}" => {result1} (optimized: {result2})')


# 运行测试
if __name__ == "__main__":
    test()

===============================================

文件: Code09_MinimumASCIIDeleteSumForTwoStrings.java
===============================================
/**
 * 两个字符串的最小ASCII删除和（Minimum ASCII Delete Sum for Two Strings）
 * 给定两个字符串s1 和 s2，返回使两个字符串相等所需删除字符的 ASCII 值的最小和。
 * 
 * 题目来源：LeetCode 712. 两个字符串的最小ASCII删除和
 * 测试链接：https://leetcode.cn/problems/minimum-ascii-delete-sum-for-two-strings/
 * 
 * 算法核心思想：
 * 使用动态规划解决两个字符串的最小ASCII删除和问题，通过构建二维DP表来计算最小删除ASCII值和
 * 
 * 时间复杂度分析：
 * - 基础版本：O(n*m)，其中n为s1的长度，m为s2的长度
 * - 空间优化版本：O(n*m)时间，O(m)空间
 * 
 * 空间复杂度分析：
 * - 基础版本：O(n*m)
 * - 空间优化版本：O(m)
 * 
 * 最优解判定：✅ 是最优解，时间复杂度无法进一步优化，空间复杂度已优化到O(min(n,m))
 * 
 * 工程化考量：
 * 1. 异常处理：检查输入参数合法性
 * 2. 边界条件：处理空字符串和极端情况
 * 3. 性能优化：使用滚动数组减少空间占用
 * 4. 代码可读性：添加详细注释和测试用例
 * 
 * 与其他领域的联系：
 * - 文本处理：文档差异比较和版本控制
 * - 数据压缩：最小编辑距离计算
 * - 优化理论：约束优化问题
 */
public class Code09_MinimumASCIIDeleteSumForTwoStrings {

	/*
	 * 两个字符串的最小ASCII删除和 - 动态规划解法
	 * 使用动态规划解决两个字符串的最小ASCII删除和问题
	 * dp[i][j] 表示使字符串s1的前i个字符与字符串s2的前j个字符相同所需删除字符的ASCII值的最小和
	 * 
	 * 状态转移方程：
	 * 如果 s1[i-1] == s2[j-1]：
	 *   dp[i][j] = dp[i-1][j-1]
	 * 否则：
	 *   dp[i][j] = min(dp[i-1][j] + s1[i-1], dp[i][j-1] + s2[j-1])
	 * 
	 * 解释：
	 * 当当前字符相等时，不需要删除操作，结果等于前面子串的删除ASCII和
	 * 当当前字符不相等时，可以选择删除s1的字符或删除s2的字符，取ASCII值较小的方案
	 * 
	 * 边界条件：
	 * dp[i][0] = dp[i-1][0] + s1[i-1]，表示将s1的前i个字符删除所需的ASCII和
	 * dp[0][j] = dp[0][j-1] + s2[j-1]，表示将s2的前j个字符删除所需的ASCII和
	 * 
	 * 时间复杂度：O(n*m)，其中n为s1的长度，m为s2的长度
	 * 空间复杂度：O(n*m)
	 */
	public static int minimumDeleteSum(String s1, String s2) {
		// 输入验证
		if (s1 == null || s2 == null) {
			throw new IllegalArgumentException("输入字符串不能为null");
		}
		
		int n = s1.length();
		int m = s2.length();
		
		// 边界情况处理
		if (n == 0 && m == 0) return 0;
		if (n == 0) {
			// s1为空，需要删除s2的所有字符
			int sum = 0;
			for (int i = 0; i < m; i++) {
				sum += s2.charAt(i);
			}
			return sum;
		}
		if (m == 0) {
			// s2为空，需要删除s1的所有字符
			int sum = 0;
			for (int i = 0; i < n; i++) {
				sum += s1.charAt(i);
			}
			return sum;
		}
		
		// dp[i][j] 表示使s1的前i个字符与s2的前j个字符相同所需删除字符的ASCII值的最小和
		int[][] dp = new int[n + 1][m + 1];
		
		// 边界条件
		for (int i = 1; i <= n; i++) {
			dp[i][0] = dp[i - 1][0] + s1.charAt(i - 1); // 删除s1的前i个字符
		}
		for (int j = 1; j <= m; j++) {
			dp[0][j] = dp[0][j - 1] + s2.charAt(j - 1); // 删除s2的前j个字符
		}
		
		// 填充dp表
		for (int i = 1; i <= n; i++) {
			for (int j = 1; j <= m; j++) {
				if (s1.charAt(i - 1) == s2.charAt(j - 1)) {
					// 当前字符相等，不需要删除操作
					dp[i][j] = dp[i - 1][j - 1];
				} else {
					// 当前字符不相等，选择删除ASCII值较小的字符
					// 删除s1的字符：dp[i-1][j] + s1[i-1]
					// 删除s2的字符：dp[i][j-1] + s2[j-1]
					dp[i][j] = Math.min(dp[i - 1][j] + s1.charAt(i - 1), dp[i][j - 1] + s2.charAt(j - 1));
				}
			}
		}
		
		return dp[n][m];
	}

	/*
	 * 空间优化版本
	 * 使用滚动数组优化空间复杂度
	 * 
	 * 时间复杂度：O(n*m)
	 * 空间复杂度：O(m)
	 */
	public static int minimumDeleteSumOptimized(String s1, String s2) {
		// 输入验证
		if (s1 == null || s2 == null) {
			throw new IllegalArgumentException("输入字符串不能为null");
		}
		
		int n = s1.length();
		int m = s2.length();
		
		// 边界情况处理
		if (n == 0 && m == 0) return 0;
		if (n == 0) {
			// s1为空，需要删除s2的所有字符
			int sum = 0;
			for (int i = 0; i < m; i++) {
				sum += s2.charAt(i);
			}
			return sum;
		}
		if (m == 0) {
			// s2为空，需要删除s1的所有字符
			int sum = 0;
			for (int i = 0; i < n; i++) {
				sum += s1.charAt(i);
			}
			return sum;
		}
		
		// 只需要一行数组
		int[] dp = new int[m + 1];
		
		// 初始化第一行
		for (int j = 1; j <= m; j++) {
			dp[j] = dp[j - 1] + s2.charAt(j - 1);
		}
		
		// 填充dp表
		for (int i = 1; i <= n; i++) {
			int prev = dp[0];  // 保存dp[i-1][j-1]的值
			dp[0] = dp[0] + s1.charAt(i - 1);  // 更新dp[i][0]的值
			
			for (int j = 1; j <= m; j++) {
				int temp = dp[j];  // 保存当前dp[j]的值，用于下一次循环
				
				if (s1.charAt(i - 1) == s2.charAt(j - 1)) {
					// 当前字符相等，不需要删除操作
					dp[j] = prev;
				} else {
					// 当前字符不相等，选择删除ASCII值较小的字符
					// 删除s1的字符：dp[i-1][j] + s1[i-1] 对应 temp + s1.charAt(i-1)
					// 删除s2的字符：dp[i][j-1] + s2[j-1] 对应 dp[j-1] + s2.charAt(j-1)
					dp[j] = Math.min(temp + s1.charAt(i - 1), dp[j - 1] + s2.charAt(j - 1));
				}
				
				prev = temp;  // 更新prev为原来的dp[j]值
			}
		}
		
		return dp[m];
	}

	/**
	 * 测试函数
	 */
	// 测试函数
	public static void main(String[] args) {
		// 测试用例
		String[][] testCases = {
			{"sea", "eat"},     // 231
			{"delete", "leet"}, // 403
			{"", "a"},          // 97
			{"a", ""},          // 97
			{"", ""}            // 0
		};
		
		System.out.println("两个字符串的最小ASCII删除和测试:");
		for (String[] testCase : testCases) {
			String s1 = testCase[0];
			String s2 = testCase[1];
			int result1 = minimumDeleteSum(s1, s2);
			int result2 = minimumDeleteSumOptimized(s1, s2);
			System.out.printf("s1=\"%s\", s2=\"%s\" => %d (optimized: %d)\n", s1, s2, result1, result2);
		}
	}
}

===============================================

文件: Code09_MinimumASCIIDeleteSumForTwoStrings.py
===============================================
# 两个字符串的最小ASCII删除和
# 给定两个字符串s1 和 s2，返回使两个字符串相等所需删除字符的 ASCII 值的最小和。
# 测试链接 : https://leetcode.cn/problems/minimum-ascii-delete-sum-for-two-strings/

class Solution:
    '''
    两个字符串的最小ASCII删除和 - 动态规划解法
    使用动态规划解决两个字符串的最小ASCII删除和问题
    dp[i][j] 表示使字符串s1的前i个字符与字符串s2的前j个字符相同所需删除字符的ASCII值的最小和
    
    状态转移方程：
    如果 s1[i-1] == s2[j-1]：
      dp[i][j] = dp[i-1][j-1]
    否则：
      dp[i][j] = min(dp[i-1][j] + ord(s1[i-1]), dp[i][j-1] + ord(s2[j-1]))
    
    解释：
    当当前字符相等时，不需要删除操作，结果等于前面子串的删除ASCII和
    当当前字符不相等时，可以选择删除s1的字符或删除s2的字符，取ASCII值较小的方案
    
    边界条件：
    dp[i][0] = dp[i-1][0] + ord(s1[i-1])，表示将s1的前i个字符删除所需的ASCII和
    dp[0][j] = dp[0][j-1] + ord(s2[j-1])，表示将s2的前j个字符删除所需的ASCII和
    
    时间复杂度：O(n*m)，其中n为s1的长度，m为s2的长度
    空间复杂度：O(n*m)
    '''
    def minimumDeleteSum(self, s1: str, s2: str) -> int:
        n, m = len(s1), len(s2)
        
        # dp[i][j] 表示使s1的前i个字符与s2的前j个字符相同所需删除字符的ASCII值的最小和
        dp = [[0] * (m + 1) for _ in range(n + 1)]
        
        # 边界条件
        for i in range(1, n + 1):
            dp[i][0] = dp[i - 1][0] + ord(s1[i - 1])
        for j in range(1, m + 1):
            dp[0][j] = dp[0][j - 1] + ord(s2[j - 1])
        
        # 填充dp表
        for i in range(1, n + 1):
            for j in range(1, m + 1):
                if s1[i - 1] == s2[j - 1]:
                    # 当前字符相等，不需要删除操作
                    dp[i][j] = dp[i - 1][j - 1]
                else:
                    # 当前字符不相等，选择删除ASCII值较小的字符
                    dp[i][j] = min(dp[i - 1][j] + ord(s1[i - 1]), dp[i][j - 1] + ord(s2[j - 1]))
        
        return dp[n][m]

    '''
    空间优化版本
    使用滚动数组优化空间复杂度
    
    时间复杂度：O(n*m)
    空间复杂度：O(m)
    '''
    def minimumDeleteSumOptimized(self, s1: str, s2: str) -> int:
        n, m = len(s1), len(s2)
        
        # 只需要一行数组
        dp = [0] * (m + 1)
        
        # 初始化第一行
        for j in range(1, m + 1):
            dp[j] = dp[j - 1] + ord(s2[j - 1])
        
        # 填充dp表
        for i in range(1, n + 1):
            prev = dp[0]  # 保存dp[i-1][j-1]的值
            dp[0] = dp[0] + ord(s1[i - 1])  # 更新dp[i][0]的值
            
            for j in range(1, m + 1):
                temp = dp[j]  # 保存当前dp[j]的值，用于下一次循环
                
                if s1[i - 1] == s2[j - 1]:
                    # 当前字符相等，不需要删除操作
                    dp[j] = prev
                else:
                    # 当前字符不相等，选择删除ASCII值较小的字符
                    dp[j] = min(temp + ord(s1[i - 1]), dp[j - 1] + ord(s2[j - 1]))
                
                prev = temp  # 更新prev为原来的dp[j]值
        
        return dp[m]


# 测试函数
def test():
    sol = Solution()
    
    # 测试用例
    test_cases = [
        ("sea", "eat"),     # 231
        ("delete", "leet"), # 403
        ("", "a"),          # 97
        ("a", ""),          # 97
        ("", "")            # 0
    ]
    
    print("两个字符串的最小ASCII删除和测试:")
    for s1, s2 in test_cases:
        result1 = sol.minimumDeleteSum(s1, s2)
        result2 = sol.minimumDeleteSumOptimized(s1, s2)
        print(f's1="{s1}", s2="{s2}" => {result1} (optimized: {result2})')


# 运行测试
if __name__ == "__main__":
    test()

===============================================

文件: Code10_UncrossedLines.java
===============================================
import java.util.Arrays;

/**
 * 不相交的线（Uncrossed Lines）
 * 在两条独立的水平线上按给定的顺序写下 nums1 和 nums2 中的整数。
 * 现在，可以绘制一些连接两个数字 nums1[i] 和 nums2[j] 的直线，这些直线需要同时满足：
 * nums1[i] == nums2[j]
 * 且绘制的直线不与任何其他连线（非水平线）相交。
 * 请注意，连线即使在端点也不能相交：每个数字只能属于一条连线。
 * 以这种方法绘制线条，并返回可以绘制的最大连线数。
 * 
 * 题目来源：LeetCode 1035. 不相交的线
 * 测试链接：https://leetcode.cn/problems/uncrossed-lines/
 * 
 * 算法核心思想：
 * 使用动态规划解决不相交的线问题，本质上是求两个数组的最长公共子序列
 * 通过构建二维DP表来计算最大连线数
 * 
 * 时间复杂度分析：
 * - 基础版本：O(n*m)，其中n为nums1的长度，m为nums2的长度
 * - 空间优化版本：O(n*m)时间，O(m)空间
 * 
 * 空间复杂度分析：
 * - 基础版本：O(n*m)
 * - 空间优化版本：O(m)
 * 
 * 最优解判定：✅ 是最优解，时间复杂度无法进一步优化，空间复杂度已优化到O(min(n,m))
 * 
 * 工程化考量：
 * 1. 异常处理：检查输入参数合法性
 * 2. 边界条件：处理空数组和极端情况
 * 3. 性能优化：使用滚动数组减少空间占用
 * 4. 代码可读性：添加详细注释和测试用例
 * 
 * 与其他领域的联系：
 * - 图论：平面图和交叉数问题
 * - 生物信息学：序列比对和基因分析
 * - 电路设计：布线和交叉避免
 */
public class Code10_UncrossedLines {

	/*
	 * 不相交的线 - 动态规划解法
	 * 使用动态规划解决不相交的线问题
	 * dp[i][j] 表示nums1的前i个数字和nums2的前j个数字能绘制的最大连线数
	 * 
	 * 状态转移方程：
	 * 如果 nums1[i-1] == nums2[j-1]：
	 *   dp[i][j] = dp[i-1][j-1] + 1
	 * 否则：
	 *   dp[i][j] = max(dp[i-1][j], dp[i][j-1])
	 * 
	 * 解释：
	 * 当当前数字相等时，可以连线，结果等于前面子数组的最大连线数加1
	 * 当当前数字不相等时，不能连线，取两种情况的最大值：
	 *   1. 不使用nums1[i-1]数字的情况：dp[i-1][j]
	 *   2. 不使用nums2[j-1]数字的情况：dp[i][j-1]
	 * 
	 * 边界条件：
	 * dp[0][j] = 0，表示nums1为空时无法连线
	 * dp[i][0] = 0，表示nums2为空时无法连线
	 * 
	 * 时间复杂度：O(n*m)，其中n为nums1的长度，m为nums2的长度
	 * 空间复杂度：O(n*m)
	 */
	public static int maxUncrossedLines(int[] nums1, int[] nums2) {
		// 输入验证
		if (nums1 == null || nums2 == null) {
			throw new IllegalArgumentException("输入数组不能为null");
		}
		
		int n = nums1.length;
		int m = nums2.length;
		
		// 边界情况处理
		if (n == 0 || m == 0) return 0;
		
		// dp[i][j] 表示nums1的前i个数字和nums2的前j个数字能绘制的最大连线数
		int[][] dp = new int[n + 1][m + 1];
		
		// 填充dp表
		for (int i = 1; i <= n; i++) {
			for (int j = 1; j <= m; j++) {
				if (nums1[i - 1] == nums2[j - 1]) {
					// 当前数字相等，可以连线
					// 连线数等于前面子数组的最大连线数加1
					dp[i][j] = dp[i - 1][j - 1] + 1;
				} else {
					// 当前数字不相等，不能连线，取两种情况的最大值
					// 不使用nums1[i-1]数字的情况：dp[i-1][j]
					// 不使用nums2[j-1]数字的情况：dp[i][j-1]
					dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
				}
			}
		}
		
		return dp[n][m];
	}

	/*
	 * 空间优化版本
	 * 使用滚动数组优化空间复杂度
	 * 
	 * 时间复杂度：O(n*m)
	 * 空间复杂度：O(m)
	 */
	public static int maxUncrossedLinesOptimized(int[] nums1, int[] nums2) {
		// 输入验证
		if (nums1 == null || nums2 == null) {
			throw new IllegalArgumentException("输入数组不能为null");
		}
		
		int n = nums1.length;
		int m = nums2.length;
		
		// 边界情况处理
		if (n == 0 || m == 0) return 0;
		
		// 只需要一行数组
		int[] dp = new int[m + 1];
		
		// 填充dp表
		for (int i = 1; i <= n; i++) {
			int prev = dp[0];  // 保存dp[i-1][j-1]的值
			
			for (int j = 1; j <= m; j++) {
				int temp = dp[j];  // 保存当前dp[j]的值，用于下一次循环
				
				if (nums1[i - 1] == nums2[j - 1]) {
					// 当前数字相等，可以连线
					// 连线数等于前面子数组的最大连线数加1
					dp[j] = prev + 1;
				} else {
					// 当前数字不相等，不能连线，取两种情况的最大值
					// 不使用nums1[i-1]数字的情况：dp[i-1][j] 对应 temp
					// 不使用nums2[j-1]数字的情况：dp[i][j-1] 对应 dp[j-1]
					dp[j] = Math.max(temp, dp[j - 1]);
				}
				
				prev = temp;  // 更新prev为原来的dp[j]值
			}
		}
		
		return dp[m];
	}

	/**
	 * 测试函数
	 */
	// 测试函数
	public static void main(String[] args) {
		// 测试用例
		int[][][] testCases = {
			{{1,4,2}, {1,2,4}},     // 2
			{{2,5,1,2,5}, {10,5,2,1,5,2}}, // 3
			{{1,3,7,1,7,5}, {1,9,2,5,1}}, // 2
			{{1,2,3}, {4,5,6}},     // 0
			{{1,2,3}, {1,2,3}}      // 3
		};
		
		System.out.println("不相交的线测试:");
		for (int[][] testCase : testCases) {
			int[] nums1 = testCase[0];
			int[] nums2 = testCase[1];
			int result1 = maxUncrossedLines(nums1, nums2);
			int result2 = maxUncrossedLinesOptimized(nums1, nums2);
			System.out.printf("nums1=%s, nums2=%s => %d (optimized: %d)\n", 
				Arrays.toString(nums1), Arrays.toString(nums2), result1, result2);
		}
	}
}

===============================================

文件: Code10_UncrossedLines.py
===============================================
# 不相交的线
# 在两条独立的水平线上按给定的顺序写下 nums1 和 nums2 中的整数。
# 现在，可以绘制一些连接两个数字 nums1[i] 和 nums2[j] 的直线，这些直线需要同时满足：
# nums1[i] == nums2[j]
# 且绘制的直线不与任何其他连线（非水平线）相交。
# 请注意，连线即使在端点也不能相交：每个数字只能属于一条连线。
# 以这种方法绘制线条，并返回可以绘制的最大连线数。
# 测试链接 : https://leetcode.cn/problems/uncrossed-lines/

class Solution:
    '''
    不相交的线 - 动态规划解法
    使用动态规划解决不相交的线问题
    dp[i][j] 表示nums1的前i个数字和nums2的前j个数字能绘制的最大连线数
    
    状态转移方程：
    如果 nums1[i-1] == nums2[j-1]：
      dp[i][j] = dp[i-1][j-1] + 1
    否则：
      dp[i][j] = max(dp[i-1][j], dp[i][j-1])
    
    解释：
    当当前数字相等时，可以连线，结果等于前面子数组的最大连线数加1
    当当前数字不相等时，不能连线，取两种情况的最大值：
      1. 不使用nums1[i-1]数字的情况：dp[i-1][j]
      2. 不使用nums2[j-1]数字的情况：dp[i][j-1]
    
    边界条件：
    dp[0][j] = 0，表示nums1为空时无法连线
    dp[i][0] = 0，表示nums2为空时无法连线
    
    时间复杂度：O(n*m)，其中n为nums1的长度，m为nums2的长度
    空间复杂度：O(n*m)
    '''
    def maxUncrossedLines(self, nums1, nums2):
        n, m = len(nums1), len(nums2)
        
        # dp[i][j] 表示nums1的前i个数字和nums2的前j个数字能绘制的最大连线数
        dp = [[0] * (m + 1) for _ in range(n + 1)]
        
        # 填充dp表
        for i in range(1, n + 1):
            for j in range(1, m + 1):
                if nums1[i - 1] == nums2[j - 1]:
                    # 当前数字相等，可以连线
                    dp[i][j] = dp[i - 1][j - 1] + 1
                else:
                    # 当前数字不相等，不能连线，取两种情况的最大值
                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])
        
        return dp[n][m]

    '''
    空间优化版本
    使用滚动数组优化空间复杂度
    
    时间复杂度：O(n*m)
    空间复杂度：O(m)
    '''
    def maxUncrossedLinesOptimized(self, nums1, nums2):
        n, m = len(nums1), len(nums2)
        
        # 只需要一行数组
        dp = [0] * (m + 1)
        
        # 填充dp表
        for i in range(1, n + 1):
            prev = dp[0]  # 保存dp[i-1][j-1]的值
            
            for j in range(1, m + 1):
                temp = dp[j]  # 保存当前dp[j]的值，用于下一次循环
                
                if nums1[i - 1] == nums2[j - 1]:
                    # 当前数字相等，可以连线
                    dp[j] = prev + 1
                else:
                    # 当前数字不相等，不能连线，取两种情况的最大值
                    dp[j] = max(dp[j], dp[j - 1])
                
                prev = temp  # 更新prev为原来的dp[j]值
        
        return dp[m]


# 测试函数
def test():
    sol = Solution()
    
    # 测试用例
    test_cases = [
        ([1,4,2], [1,2,4]),     # 2
        ([2,5,1,2,5], [10,5,2,1,5,2]), # 3
        ([1,3,7,1,7,5], [1,9,2,5,1]), # 2
        ([1,2,3], [4,5,6]),     # 0
        ([1,2,3], [1,2,3])      # 3
    ]
    
    print("不相交的线测试:")
    for nums1, nums2 in test_cases:
        result1 = sol.maxUncrossedLines(nums1, nums2)
        result2 = sol.maxUncrossedLinesOptimized(nums1, nums2)
        print(f'nums1={nums1}, nums2={nums2} => {result1} (optimized: {result2})')


# 运行测试
if __name__ == "__main__":
    test()

===============================================

文件: Code11_LongestPalindromicSubsequence.cpp
===============================================
#include <iostream>
#include <vector>
#include <string>
#include <algorithm>

// 最长回文子序列 (Longest Palindromic Subsequence)
// 给你一个字符串 s ，找出其中最长的回文子序列，并返回该子序列的长度
// 子序列定义为：不改变剩余字符顺序的情况下，删除某些字符或者不删除任何字符形成的一个序列
// 
// 题目来源：LeetCode 516. 最长回文子序列
// 测试链接：https://leetcode.cn/problems/longest-palindromic-subsequence/
//
// 算法核心思想：
// 使用动态规划解决最长回文子序列问题，通过构建二维DP表来计算最长回文子序列长度
//
// 时间复杂度分析：
// - 基础版本：O(n²)，其中n为s的长度
// - 空间优化版本：O(n²)时间，O(n)空间
//
// 空间复杂度分析：
// - 基础版本：O(n²)
// - 空间优化版本：O(n)
//
// 最优解判定：✅ 是最优解，时间复杂度无法进一步优化，空间复杂度已优化到O(n)
//
// 工程化考量：
// 1. 异常处理：检查输入参数合法性
// 2. 边界条件：处理空字符串和极端情况
// 3. 性能优化：使用滚动数组减少空间占用
// 4. 代码可读性：添加详细注释和测试用例
//
// 与其他领域的联系：
// - 生物信息学：DNA序列分析
// - 文本处理：回文检测
// - 密码学：回文密码分析

class Solution {
public:
    /*
     * 算法思路：
     * 使用动态规划解决最长回文子序列问题
     * dp[i][j] 表示字符串s在区间[i,j]内的最长回文子序列长度
     * 
     * 状态转移方程：
     * 如果 s[i] == s[j]，则可以将这两个字符加入回文子序列中
     *   dp[i][j] = dp[i+1][j-1] + 2
     * 如果 s[i] != s[j]，则取左右两边的最大值
     *   dp[i][j] = max(dp[i+1][j], dp[i][j-1])
     * 
     * 边界条件：
     * dp[i][i] = 1，表示单个字符是长度为1的回文子序列
     * dp[i][j] = 0，当i > j时
     * 
     * 时间复杂度：O(n²)，其中n为字符串s的长度
     * 空间复杂度：O(n²)
     */
    int longestPalindromeSubseq1(std::string s) {
        if (s.empty()) {
            return 0;
        }
        int n = s.length();
        // dp[i][j] 表示s[i...j]范围上的最长回文子序列长度
        std::vector<std::vector<int> > dp(n, std::vector<int>(n, 0));
        
        // 初始化对角线上的元素，表示单个字符是回文
        for (int i = 0; i < n; ++i) {
            dp[i][i] = 1;
        }
        
        // 初始化次对角线，两个字符的情况
        for (int i = 0; i < n - 1; ++i) {
            dp[i][i + 1] = (s[i] == s[i + 1]) ? 2 : 1;
        }
        
        // 按长度由小到大填充dp表
        for (int len = 3; len <= n; ++len) {
            for (int i = 0, j; (j = i + len - 1) < n; ++i) {
                if (s[i] == s[j]) {
                    // 首尾字符相同，可以同时加入回文子序列
                    dp[i][j] = dp[i + 1][j - 1] + 2;
                } else {
                    // 首尾字符不同，取左或右的最大值
                    dp[i][j] = std::max(dp[i + 1][j], dp[i][j - 1]);
                }
            }
        }
        
        return dp[0][n - 1];
    }

    /*
     * 空间优化版本
     * 观察状态转移方程，dp[i][j]依赖于dp[i+1][j-1]、dp[i+1][j]和dp[i][j-1]
     * 对于从左到右、从下到上的填充方式，可以优化到一维数组
     * 
     * 时间复杂度：O(n²)
     * 空间复杂度：O(n)
     */
    int longestPalindromeSubseq2(std::string s) {
        if (s.empty()) {
            return 0;
        }
        int n = s.length();
        // 使用一维数组存储当前行的数据
        std::vector<int> dp(n, 0);
        // 存储左上角的值(dp[i+1][j-1])
        int temp = 0;
        // 存储上一次的temp值
        int pre = 0;
        
        // 从下到上，从左到右填充
        for (int i = n - 1; i >= 0; --i) {
            // 单个字符的情况
            dp[i] = 1;
            pre = 0; // 重置pre
            // j从i+1开始向右扩展
            for (int j = i + 1; j < n; ++j) {
                temp = dp[j]; // 保存当前dp[j]，即dp[i+1][j]
                if (s[i] == s[j]) {
                    // 当前dp[j] = dp[i+1][j-1] + 2
                    dp[j] = pre + 2;
                } else {
                    // 当前dp[j] = max(dp[i+1][j], dp[i][j-1])
                    dp[j] = std::max(dp[j], dp[j - 1]);
                }
                pre = temp; // 更新pre为下一轮的左上角值
            }
        }
        
        return dp[n - 1];
    }
};

// 单元测试
int main() {
    Solution solution;
    
    // 测试用例1: "bbbab"
    // 预期输出: 4 ("bbbb")
    std::cout << "Test 1: " << solution.longestPalindromeSubseq1("bbbab") << std::endl; // 应输出4
    std::cout << "Test 1 (Space Optimized): " << solution.longestPalindromeSubseq2("bbbab") << std::endl; // 应输出4
    
    // 测试用例2: "cbbd"
    // 预期输出: 2 ("bb")
    std::cout << "Test 2: " << solution.longestPalindromeSubseq1("cbbd") << std::endl; // 应输出2
    std::cout << "Test 2 (Space Optimized): " << solution.longestPalindromeSubseq2("cbbd") << std::endl; // 应输出2
    
    // 边界测试: 空字符串
    std::cout << "Test 3 (Empty String): " << solution.longestPalindromeSubseq1("") << std::endl; // 应输出0
    std::cout << "Test 3 (Empty String, Space Optimized): " << solution.longestPalindromeSubseq2("") << std::endl; // 应输出0
    
    // 边界测试: 单字符
    std::cout << "Test 4 (Single Char): " << solution.longestPalindromeSubseq1("a") << std::endl; // 应输出1
    std::cout << "Test 4 (Single Char, Space Optimized): " << solution.longestPalindromeSubseq2("a") << std::endl; // 应输出1
    
    // 边界测试: 全部相同字符
    std::cout << "Test 5 (All Same): " << solution.longestPalindromeSubseq1("aaaaa") << std::endl; // 应输出5
    std::cout << "Test 5 (All Same, Space Optimized): " << solution.longestPalindromeSubseq2("aaaaa") << std::endl; // 应输出5
    
    // 边界测试: 全部不同字符
    std::cout << "Test 6 (All Different): " << solution.longestPalindromeSubseq1("abcde") << std::endl; // 应输出1
    std::cout << "Test 6 (All Different, Space Optimized): " << solution.longestPalindromeSubseq2("abcde") << std::endl; // 应输出1
    
    return 0;
}

===============================================

文件: Code11_LongestPalindromicSubsequence.java
===============================================
/**
 * 最长回文子序列（Longest Palindromic Subsequence）
 * 给你一个字符串 s ，找出其中最长的回文子序列，并返回该子序列的长度
 * 子序列定义为：不改变剩余字符顺序的情况下，删除某些字符或者不删除任何字符形成的一个序列
 * 
 * 题目来源：LeetCode 516. 最长回文子序列
 * 测试链接：https://leetcode.cn/problems/longest-palindromic-subsequence/
 * 
 * 算法核心思想：
 * 使用动态规划解决最长回文子序列问题，通过构建二维DP表来计算最长回文子序列长度
 * 
 * 时间复杂度分析：
 * - 基础版本：O(n²)，其中n为字符串s的长度
 * - 空间优化版本：O(n²)时间，O(n)空间
 * 
 * 空间复杂度分析：
 * - 基础版本：O(n²)
 * - 空间优化版本：O(n)
 * 
 * 最优解判定：✅ 是最优解，时间复杂度无法进一步优化，空间复杂度已优化到O(n)
 * 
 * 工程化考量：
 * 1. 异常处理：检查输入参数合法性
 * 2. 边界条件：处理空字符串和极端情况
 * 3. 性能优化：使用滚动数组减少空间占用
 * 4. 代码可读性：添加详细注释和测试用例
 * 
 * 与其他领域的联系：
 * - 生物信息学：DNA序列分析和基因结构识别
 * - 数据压缩：回文结构识别和编码优化
 * - 密码学：回文检测和对称性分析
 */
public class Code11_LongestPalindromicSubsequence {

	/*
	 * 算法思路：
	 * 使用动态规划解决最长回文子序列问题
	 * dp[i][j] 表示字符串s在区间[i,j]内的最长回文子序列长度
	 * 
	 * 状态转移方程：
	 * 如果 s[i] == s[j]，则可以将这两个字符加入回文子序列中
	 *   dp[i][j] = dp[i+1][j-1] + 2
	 * 如果 s[i] != s[j]，则取左右两边的最大值
	 *   dp[i][j] = max(dp[i+1][j], dp[i][j-1])
	 * 
	 * 边界条件：
	 * dp[i][i] = 1，表示单个字符是长度为1的回文子序列
	 * dp[i][j] = 0，当i > j时
	 * 
	 * 时间复杂度：O(n²)，其中n为字符串s的长度
	 * 空间复杂度：O(n²)
	 */
	public static int longestPalindromeSubseq1(String s) {
		// 输入验证
		if (s == null) {
			throw new IllegalArgumentException("输入字符串不能为null");
		}
		
		if (s.length() == 0) {
			return 0;
		}
		
		char[] str = s.toCharArray();
		int n = str.length;
		
		// dp[i][j] 表示str[i...j]范围上的最长回文子序列长度
		int[][] dp = new int[n][n];
		
		// 初始化对角线上的元素，表示单个字符是回文
		for (int i = 0; i < n; i++) {
			dp[i][i] = 1;
		}
		
		// 初始化次对角线，两个字符的情况
		for (int i = 0; i < n - 1; i++) {
			dp[i][i + 1] = (str[i] == str[i + 1]) ? 2 : 1;
		}
		
		// 按长度由小到大填充dp表
		// 从长度为3的子串开始计算
		for (int len = 3; len <= n; len++) {
			// i是子串的起始位置，j是子串的结束位置
			for (int i = 0, j; (j = i + len - 1) < n; i++) {
				if (str[i] == str[j]) {
					// 首尾字符相同，可以同时加入回文子序列
					// 最长回文子序列长度等于内部子串的最长回文子序列长度加2
					dp[i][j] = dp[i + 1][j - 1] + 2;
				} else {
					// 首尾字符不同，不能同时加入回文子序列
					// 取去掉首字符或尾字符后的子串中最长回文子序列长度的最大值
					dp[i][j] = Math.max(dp[i + 1][j], dp[i][j - 1]);
				}
			}
		}
		
		return dp[0][n - 1];
	}

	/*
	 * 空间优化版本
	 * 观察状态转移方程，dp[i][j]依赖于dp[i+1][j-1]、dp[i+1][j]和dp[i][j-1]
	 * 对于从左到右、从下到上的填充方式，可以优化到一维数组
	 * 
	 * 时间复杂度：O(n²)
	 * 空间复杂度：O(n)
	 */
	public static int longestPalindromeSubseq2(String s) {
		// 输入验证
		if (s == null) {
			throw new IllegalArgumentException("输入字符串不能为null");
		}
		
		if (s.length() == 0) {
			return 0;
		}
		
		char[] str = s.toCharArray();
		int n = str.length;
		
		// 使用一维数组存储当前行的数据
		int[] dp = new int[n];
		
		// 存储左上角的值(dp[i+1][j-1])
		int temp = 0;
		
		// 存储上一次的temp值
		int pre = 0;
		
		// 从下到上，从左到右填充
		// 这种填充顺序可以确保在计算dp[i][j]时，所需的dp[i+1][j-1]、dp[i+1][j]和dp[i][j-1]都已经计算过
		for (int i = n - 1; i >= 0; i--) {
			// 单个字符的情况
			dp[i] = 1;
			pre = 0; // 重置pre
			
			// j从i+1开始向右扩展
			for (int j = i + 1; j < n; j++) {
				temp = dp[j]; // 保存当前dp[j]，即dp[i+1][j]
				
				if (str[i] == str[j]) {
					// 当前dp[j] = dp[i+1][j-1] + 2
					// pre保存的是dp[i+1][j-1]的值
					dp[j] = pre + 2;
				} else {
					// 当前dp[j] = max(dp[i+1][j], dp[i][j-1])
					// dp[j]保存的是dp[i+1][j]的值
					// dp[j-1]保存的是dp[i][j-1]的值
					dp[j] = Math.max(dp[j], dp[j - 1]);
				}
				
				pre = temp; // 更新pre为下一轮的左上角值
			}
		}
		
		return dp[n - 1];
	}
	
	/*
	 * 单元测试示例
	 * 测试边界情况和常见情况
	 */
	public static void main(String[] args) {
		// 测试用例1: "bbbab"
		// 预期输出: 4 ("bbbb")
		System.out.println("Test 1: " + longestPalindromeSubseq1("bbbab")); // 应输出4
		System.out.println("Test 1 (Space Optimized): " + longestPalindromeSubseq2("bbbab")); // 应输出4
		
		// 测试用例2: "cbbd"
		// 预期输出: 2 ("bb")
		System.out.println("Test 2: " + longestPalindromeSubseq1("cbbd")); // 应输出2
		System.out.println("Test 2 (Space Optimized): " + longestPalindromeSubseq2("cbbd")); // 应输出2
		
		// 边界测试: 空字符串
		System.out.println("Test 3 (Empty String): " + longestPalindromeSubseq1("")); // 应输出0
		System.out.println("Test 3 (Empty String, Space Optimized): " + longestPalindromeSubseq2("")); // 应输出0
		
		// 边界测试: 单字符
		System.out.println("Test 4 (Single Char): " + longestPalindromeSubseq1("a")); // 应输出1
		System.out.println("Test 4 (Single Char, Space Optimized): " + longestPalindromeSubseq2("a")); // 应输出1
		
		// 边界测试: 全部相同字符
		System.out.println("Test 5 (All Same): " + longestPalindromeSubseq1("aaaaa")); // 应输出5
		System.out.println("Test 5 (All Same, Space Optimized): " + longestPalindromeSubseq2("aaaaa")); // 应输出5
		
		// 边界测试: 全部不同字符
		System.out.println("Test 6 (All Different): " + longestPalindromeSubseq1("abcde")); // 应输出1
		System.out.println("Test 6 (All Different, Space Optimized): " + longestPalindromeSubseq2("abcde")); // 应输出1
	}
}

===============================================

文件: Code11_LongestPalindromicSubsequence.py
===============================================
# 最长回文子序列
# 给你一个字符串 s ，找出其中最长的回文子序列，并返回该子序列的长度
# 子序列定义为：不改变剩余字符顺序的情况下，删除某些字符或者不删除任何字符形成的一个序列
# 测试链接 : https://leetcode.cn/problems/longest-palindromic-subsequence/

class Solution:
    
    def longestPalindromeSubseq1(self, s: str) -> int:
        """
        算法思路：
        使用动态规划解决最长回文子序列问题
        dp[i][j] 表示字符串s在区间[i,j]内的最长回文子序列长度
        
        状态转移方程：
        如果 s[i] == s[j]，则可以将这两个字符加入回文子序列中
          dp[i][j] = dp[i+1][j-1] + 2
        如果 s[i] != s[j]，则取左右两边的最大值
          dp[i][j] = max(dp[i+1][j], dp[i][j-1])
        
        边界条件：
        dp[i][i] = 1，表示单个字符是长度为1的回文子序列
        dp[i][j] = 0，当i > j时
        
        时间复杂度：O(n²)，其中n为字符串s的长度
        空间复杂度：O(n²)
        """
        if not s:
            return 0
        n = len(s)
        # dp[i][j] 表示s[i...j]范围上的最长回文子序列长度
        dp = [[0] * n for _ in range(n)]
        
        # 初始化对角线上的元素，表示单个字符是回文
        for i in range(n):
            dp[i][i] = 1
        
        # 初始化次对角线，两个字符的情况
        for i in range(n - 1):
            dp[i][i + 1] = 2 if s[i] == s[i + 1] else 1
        
        # 按长度由小到大填充dp表
        for length in range(3, n + 1):
            for i in range(n - length + 1):
                j = i + length - 1
                if s[i] == s[j]:
                    # 首尾字符相同，可以同时加入回文子序列
                    dp[i][j] = dp[i + 1][j - 1] + 2
                else:
                    # 首尾字符不同，取左或右的最大值
                    dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])
        
        return dp[0][n - 1]
    
    def longestPalindromeSubseq2(self, s: str) -> int:
        """
        空间优化版本
        观察状态转移方程，dp[i][j]依赖于dp[i+1][j-1]、dp[i+1][j]和dp[i][j-1]
        对于从左到右、从下到上的填充方式，可以优化到一维数组
        
        时间复杂度：O(n²)
        空间复杂度：O(n)
        """
        if not s:
            return 0
        n = len(s)
        # 使用一维数组存储当前行的数据
        dp = [0] * n
        # 存储左上角的值(dp[i+1][j-1])
        temp = 0
        # 存储上一次的temp值
        pre = 0
        
        # 从下到上，从左到右填充
        for i in range(n - 1, -1, -1):
            # 单个字符的情况
            dp[i] = 1
            pre = 0  # 重置pre
            # j从i+1开始向右扩展
            for j in range(i + 1, n):
                temp = dp[j]  # 保存当前dp[j]，即dp[i+1][j]
                if s[i] == s[j]:
                    # 当前dp[j] = dp[i+1][j-1] + 2
                    dp[j] = pre + 2
                else:
                    # 当前dp[j] = max(dp[i+1][j], dp[i][j-1])
                    dp[j] = max(dp[j], dp[j - 1])
                pre = temp  # 更新pre为下一轮的左上角值
        
        return dp[n - 1]

# 单元测试
def test_solution():
    solution = Solution()
    
    # 测试用例1: "bbbab"
    # 预期输出: 4 ("bbbb")
    print(f"Test 1: {solution.longestPalindromeSubseq1('bbbab')}")  # 应输出4
    print(f"Test 1 (Space Optimized): {solution.longestPalindromeSubseq2('bbbab')}")  # 应输出4
    
    # 测试用例2: "cbbd"
    # 预期输出: 2 ("bb")
    print(f"Test 2: {solution.longestPalindromeSubseq1('cbbd')}")  # 应输出2
    print(f"Test 2 (Space Optimized): {solution.longestPalindromeSubseq2('cbbd')}")  # 应输出2
    
    # 边界测试: 空字符串
    print(f"Test 3 (Empty String): {solution.longestPalindromeSubseq1('')}")  # 应输出0
    print(f"Test 3 (Empty String, Space Optimized): {solution.longestPalindromeSubseq2('')}")  # 应输出0
    
    # 边界测试: 单字符
    print(f"Test 4 (Single Char): {solution.longestPalindromeSubseq1('a')}")  # 应输出1
    print(f"Test 4 (Single Char, Space Optimized): {solution.longestPalindromeSubseq2('a')}")  # 应输出1
    
    # 边界测试: 全部相同字符
    print(f"Test 5 (All Same): {solution.longestPalindromeSubseq1('aaaaa')}")  # 应输出5
    print(f"Test 5 (All Same, Space Optimized): {solution.longestPalindromeSubseq2('aaaaa')}")  # 应输出5
    
    # 边界测试: 全部不同字符
    print(f"Test 6 (All Different): {solution.longestPalindromeSubseq1('abcde')}")  # 应输出1
    print(f"Test 6 (All Different, Space Optimized): {solution.longestPalindromeSubseq2('abcde')}")  # 应输出1

# 运行测试
if __name__ == "__main__":
    test_solution()

===============================================

文件: Code12_LongestCommonSubsequence.cpp
===============================================
#include <iostream>
#include <vector>
#include <string>
#include <algorithm>

// 最长公共子序列
// 给定两个字符串 text1 和 text2，返回这两个字符串的最长公共子序列的长度
// 一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串
// 测试链接 : https://leetcode.cn/problems/longest-common-subsequence/
class Solution {
public:
    /*
     * 算法思路：
     * 使用动态规划解决最长公共子序列问题
     * dp[i][j] 表示 text1 的前 i 个字符与 text2 的前 j 个字符的最长公共子序列的长度
     * 
     * 状态转移方程：
     * 如果 text1[i-1] == text2[j-1]，则当前字符可以加入公共子序列
     *   dp[i][j] = dp[i-1][j-1] + 1
     * 如果 text1[i-1] != text2[j-1]，则取两种情况的最大值
     *   dp[i][j] = max(dp[i-1][j], dp[i][j-1])
     * 
     * 边界条件：
     * dp[0][j] = 0，表示 text1 为空字符串时，与 text2 的最长公共子序列长度为 0
     * dp[i][0] = 0，表示 text2 为空字符串时，与 text1 的最长公共子序列长度为 0
     * 
     * 时间复杂度：O(n*m)，其中n为text1的长度，m为text2的长度
     * 空间复杂度：O(n*m)
     */
    int longestCommonSubsequence1(std::string text1, std::string text2) {
        if (text1.empty() || text2.empty()) {
            return 0;
        }
        int n = text1.length();
        int m = text2.length();
        // dp[i][j] 表示text1[0...i-1]和text2[0...j-1]的最长公共子序列长度
        std::vector<std::vector<int>> dp(n + 1, std::vector<int>(m + 1, 0));
        
        // 填充dp表
        for (int i = 1; i <= n; ++i) {
            for (int j = 1; j <= m; ++j) {
                if (text1[i - 1] == text2[j - 1]) {
                    // 当前字符相同，可以加入公共子序列
                    dp[i][j] = dp[i - 1][j - 1] + 1;
                } else {
                    // 当前字符不同，取两种情况的最大值
                    dp[i][j] = std::max(dp[i - 1][j], dp[i][j - 1]);
                }
            }
        }
        
        return dp[n][m];
    }

    /*
     * 空间优化版本
     * 观察状态转移方程，dp[i][j]只依赖于dp[i-1][j-1]、dp[i-1][j]和dp[i][j-1]
     * 可以使用一维数组优化空间复杂度
     * 
     * 时间复杂度：O(n*m)
     * 空间复杂度：O(min(n,m))
     */
    int longestCommonSubsequence2(std::string text1, std::string text2) {
        if (text1.empty() || text2.empty()) {
            return 0;
        }
        
        // 为了节省空间，让较短的字符串作为第二个参数
        if (text1.length() < text2.length()) {
            std::swap(text1, text2);
        }
        
        int n = text1.length();
        int m = text2.length();
        // 使用一维数组存储当前行的数据
        std::vector<int> dp(m + 1, 0);
        // 保存左上角的值(dp[i-1][j-1])
        int pre = 0;
        
        // 按行填充dp表
        for (int i = 1; i <= n; ++i) {
            pre = 0; // 每行开始时，左上角的值为0
            for (int j = 1; j <= m; ++j) {
                int temp = dp[j]; // 保存当前dp[j]，用于下一轮的pre
                if (text1[i - 1] == text2[j - 1]) {
                    // 当前字符相同
                    dp[j] = pre + 1;
                } else {
                    // 当前字符不同，取上方或左方的最大值
                    dp[j] = std::max(dp[j], dp[j - 1]);
                }
                pre = temp; // 更新pre为下一轮的左上角值
            }
        }
        
        return dp[m];
    }
};

// 单元测试
int main() {
    Solution solution;
    
    // 测试用例1: "abcde", "ace"
    // 预期输出: 3 ("ace")
    std::cout << "Test 1: " << solution.longestCommonSubsequence1("abcde", "ace") << std::endl; // 应输出3
    std::cout << "Test 1 (Space Optimized): " << solution.longestCommonSubsequence2("abcde", "ace") << std::endl; // 应输出3
    
    // 测试用例2: "abc", "abc"
    // 预期输出: 3 ("abc")
    std::cout << "Test 2: " << solution.longestCommonSubsequence1("abc", "abc") << std::endl; // 应输出3
    std::cout << "Test 2 (Space Optimized): " << solution.longestCommonSubsequence2("abc", "abc") << std::endl; // 应输出3
    
    // 测试用例3: "abc", "def"
    // 预期输出: 0 (无公共子序列)
    std::cout << "Test 3: " << solution.longestCommonSubsequence1("abc", "def") << std::endl; // 应输出0
    std::cout << "Test 3 (Space Optimized): " << solution.longestCommonSubsequence2("abc", "def") << std::endl; // 应输出0
    
    // 边界测试: 空字符串
    std::cout << "Test 4 (Empty String): " << solution.longestCommonSubsequence1("", "abc") << std::endl; // 应输出0
    std::cout << "Test 4 (Empty String, Space Optimized): " << solution.longestCommonSubsequence2("", "abc") << std::endl; // 应输出0
    
    // 边界测试: 单字符匹配
    std::cout << "Test 5 (Single Char Match): " << solution.longestCommonSubsequence1("a", "a") << std::endl; // 应输出1
    std::cout << "Test 5 (Single Char Match, Space Optimized): " << solution.longestCommonSubsequence2("a", "a") << std::endl; // 应输出1
    
    // 边界测试: 单字符不匹配
    std::cout << "Test 6 (Single Char No Match): " << solution.longestCommonSubsequence1("a", "b") << std::endl; // 应输出0
    std::cout << "Test 6 (Single Char No Match, Space Optimized): " << solution.longestCommonSubsequence2("a", "b") << std::endl; // 应输出0
    
    return 0;
}

===============================================

文件: Code12_LongestCommonSubsequence.java
===============================================
import java.util.Arrays;

/**
 * 最长公共子序列 (Longest Common Subsequence, LCS)
 * 给定两个字符串 text1 和 text2，返回这两个字符串的最长公共子序列的长度
 * 
 * 题目来源：LeetCode 1143. 最长公共子序列
 * 测试链接：https://leetcode.cn/problems/longest-common-subsequence/
 * 
 * 算法核心思想：
 * 动态规划解决经典的最长公共子序列问题，是字符串处理中的基础算法
 * 
 * 时间复杂度分析：
 * - 基础版本：O(n*m)，其中n为text1的长度，m为text2的长度
 * - 空间优化版本：O(n*m)时间，O(min(n,m))空间
 * 
 * 空间复杂度分析：
 * - 基础版本：O(n*m)
 * - 空间优化版本：O(min(n,m))
 * 
 * 最优解判定：✅ 是最优解，时间复杂度无法进一步优化，空间复杂度已优化到最优
 * 
 * 工程化考量：
 * 1. 输入验证：检查空指针和空字符串
 * 2. 性能优化：空间优化和边界剪枝
 * 3. 代码可读性：清晰的变量命名和注释
 * 4. 测试覆盖：全面的单元测试用例
 * 
 * 应用场景：
 * - 文本相似度计算
 * - 版本控制系统（如git diff）
 * - DNA序列比对
 * - 文件差异比较
 * 
 * 与其他算法的关系：
 * - 与编辑距离密切相关
 * - 是最长公共子串问题的扩展
 * - 是动态规划在字符串处理中的经典应用
 */
public class Code12_LongestCommonSubsequence {

    /**
     * 基础动态规划解法 - 二维DP数组
     * 使用标准的动态规划方法解决LCS问题
     * 
     * 状态定义：
     * dp[i][j] 表示字符串text1的前i个字符与字符串text2的前j个字符的最长公共子序列长度
     * 
     * 状态转移方程：
     * 1. 如果text1[i-1] == text2[j-1]：当前字符匹配，长度加1
     *    dp[i][j] = dp[i-1][j-1] + 1
     * 2. 如果text1[i-1] != text2[j-1]：取两种可能性的最大值
     *    dp[i][j] = max(dp[i-1][j], dp[i][j-1])
     * 
     * 边界条件：
     * - dp[0][j] = 0：text1为空字符串时
     * - dp[i][0] = 0：text2为空字符串时
     * 
     * @param text1 第一个字符串
     * @param text2 第二个字符串
     * @return 最长公共子序列的长度
     */
    public static int longestCommonSubsequence1(String text1, String text2) {
        // 输入验证
        if (text1 == null || text2 == null) {
            throw new IllegalArgumentException("输入字符串不能为null");
        }
        
        int n = text1.length();
        int m = text2.length();
        
        // 边界情况处理
        if (n == 0 || m == 0) {
            return 0;
        }
        
        char[] s1 = text1.toCharArray();
        char[] s2 = text2.toCharArray();
        
        // dp[i][j]: text1[0..i-1]和text2[0..j-1]的LCS长度
        int[][] dp = new int[n + 1][m + 1];
        
        // 填充DP表
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= m; j++) {
                if (s1[i - 1] == s2[j - 1]) {
                    // 当前字符匹配，LCS长度增加1
                    dp[i][j] = dp[i - 1][j - 1] + 1;
                } else {
                    // 当前字符不匹配，取两种可能性的最大值
                    dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
                }
            }
        }
        
        return dp[n][m];
    }

    /**
     * 空间优化版本 - 一维DP数组
     * 通过观察状态转移的依赖关系，使用滚动数组技术优化空间复杂度
     * 
     * 优化原理：
     * - dp[i][j]只依赖于当前行和上一行的数据
     * - 可以使用一维数组+临时变量保存必要的历史值
     * - 通过交换字符串顺序确保使用较短的数组
     * 
     * 关键技巧：
     * 1. 让较短的字符串作为内层循环，减少空间占用
     * 2. 使用pre变量保存dp[i-1][j-1]的值
     * 3. 使用temp变量暂存当前值用于下一轮计算
     * 
     * @param text1 第一个字符串
     * @param text2 第二个字符串
     * @return 最长公共子序列的长度
     */
    public static int longestCommonSubsequence2(String text1, String text2) {
        // 输入验证
        if (text1 == null || text2 == null) {
            throw new IllegalArgumentException("输入字符串不能为null");
        }
        
        // 交换字符串顺序，确保第二个字符串较短
        if (text1.length() < text2.length()) {
            String temp = text1;
            text1 = text2;
            text2 = temp;
        }
        
        char[] s1 = text1.toCharArray();
        char[] s2 = text2.toCharArray();
        int n = s1.length;
        int m = s2.length;
        
        // 边界情况处理
        if (n == 0 || m == 0) {
            return 0;
        }
        
        // 使用一维数组优化空间
        int[] dp = new int[m + 1];
        int pre; // 保存左上角的值(dp[i-1][j-1])
        
        // 动态规划过程
        for (int i = 1; i <= n; i++) {
            pre = 0; // 每行开始时，左上角值为0
            for (int j = 1; j <= m; j++) {
                int temp = dp[j]; // 保存当前值，用于下一轮的pre
                
                if (s1[i - 1] == s2[j - 1]) {
                    // 字符匹配：LCS长度 = 左上角值 + 1
                    dp[j] = pre + 1;
                } else {
                    // 字符不匹配：取上方和左方的最大值
                    dp[j] = Math.max(dp[j], dp[j - 1]);
                }
                
                pre = temp; // 更新pre为当前轮的左上角值
            }
        }
        
        return dp[m];
    }

    /**
     * 重构LCS字符串（扩展功能）
     * 不仅计算长度，还重构出具体的LCS字符串
     * 
     * @param text1 第一个字符串
     * @param text2 第二个字符串
     * @return 最长公共子序列字符串
     */
    public static String reconstructLCS(String text1, String text2) {
        if (text1 == null || text2 == null) {
            return "";
        }
        
        int n = text1.length();
        int m = text2.length();
        
        if (n == 0 || m == 0) {
            return "";
        }
        
        char[] s1 = text1.toCharArray();
        char[] s2 = text2.toCharArray();
        int[][] dp = new int[n + 1][m + 1];
        
        // 填充DP表
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= m; j++) {
                if (s1[i - 1] == s2[j - 1]) {
                    dp[i][j] = dp[i - 1][j - 1] + 1;
                } else {
                    dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
                }
            }
        }
        
        // 重构LCS字符串
        StringBuilder lcs = new StringBuilder();
        int i = n, j = m;
        
        while (i > 0 && j > 0) {
            if (s1[i - 1] == s2[j - 1]) {
                // 当前字符属于LCS
                lcs.append(s1[i - 1]);
                i--;
                j--;
            } else if (dp[i - 1][j] > dp[i][j - 1]) {
                // 向上移动
                i--;
            } else {
                // 向左移动
                j--;
            }
        }
        
        return lcs.reverse().toString();
    }

    /**
     * 递归解法（带记忆化）
     * 用于理解问题本质和对比性能
     * 
     * @param text1 第一个字符串
     * @param text2 第二个字符串
     * @return 最长公共子序列的长度
     */
    public static int longestCommonSubsequenceRecursive(String text1, String text2) {
        if (text1 == null || text2 == null) {
            return 0;
        }
        
        int n = text1.length();
        int m = text2.length();
        
        if (n == 0 || m == 0) {
            return 0;
        }
        
        int[][] memo = new int[n][m];
        for (int[] row : memo) {
            Arrays.fill(row, -1);
        }
        
        return dfs(text1, text2, 0, 0, memo);
    }
    
    private static int dfs(String s1, String s2, int i, int j, int[][] memo) {
        if (i == s1.length() || j == s2.length()) {
            return 0;
        }
        
        if (memo[i][j] != -1) {
            return memo[i][j];
        }
        
        int result;
        if (s1.charAt(i) == s2.charAt(j)) {
            // 字符匹配，长度加1，继续比较下一个字符
            result = 1 + dfs(s1, s2, i + 1, j + 1, memo);
        } else {
            // 字符不匹配，取两种可能性的最大值
            int skip1 = dfs(s1, s2, i + 1, j, memo);
            int skip2 = dfs(s1, s2, i, j + 1, memo);
            result = Math.max(skip1, skip2);
        }
        
        memo[i][j] = result;
        return result;
    }

    /**
     * 全面的单元测试
     * 覆盖各种边界情况和应用场景
     */
    public static void main(String[] args) {
        System.out.println("=== 最长公共子序列算法测试 ===");
        
        // 测试用例1：基本功能测试
        testCase("abcde", "ace", 3, "基本功能测试");
        
        // 测试用例2：完全相同字符串
        testCase("abc", "abc", 3, "完全相同字符串测试");
        
        // 测试用例3：无公共子序列
        testCase("abc", "def", 0, "无公共子序列测试");
        
        // 测试用例4：空字符串测试
        testCase("", "abc", 0, "空字符串测试1");
        testCase("abc", "", 0, "空字符串测试2");
        testCase("", "", 0, "双空字符串测试");
        
        // 测试用例5：单字符测试
        testCase("a", "a", 1, "单字符匹配测试");
        testCase("a", "b", 0, "单字符不匹配测试");
        
        // 测试用例6：LeetCode官方测试用例
        testCase("abcde", "ace", 3, "LeetCode测试用例1");
        testCase("abc", "abc", 3, "LeetCode测试用例2");
        testCase("abc", "def", 0, "LeetCode测试用例3");
        
        // 测试用例7：重构LCS测试
        testReconstruction("abcde", "ace", "ace", "重构LCS测试");
        
        // 性能测试
        performanceTest();
        
        // 递归解法测试
        testRecursive();
        
        System.out.println("=== 所有测试通过 ===");
    }
    
    private static void testCase(String text1, String text2, int expected, String description) {
        System.out.println("\n测试: " + description);
        System.out.println("输入: text1 = \"" + text1 + "\", text2 = \"" + text2 + "\"");
        System.out.println("预期LCS长度: " + expected);
        
        int result1 = longestCommonSubsequence1(text1, text2);
        int result2 = longestCommonSubsequence2(text1, text2);
        
        System.out.println("方法1结果: " + result1 + " " + (result1 == expected ? "✓" : "✗"));
        System.out.println("方法2结果: " + result2 + " " + (result2 == expected ? "✓" : "✗"));
        
        if (result1 == expected && result2 == expected) {
            System.out.println("✅ 测试通过");
        } else {
            System.out.println("❌ 测试失败");
            throw new AssertionError("测试用例失败: " + description);
        }
    }
    
    private static void testReconstruction(String text1, String text2, String expectedLCS, String description) {
        System.out.println("\n测试: " + description);
        String reconstructed = reconstructLCS(text1, text2);
        System.out.println("重构的LCS: \"" + reconstructed + "\"");
        System.out.println("预期LCS: \"" + expectedLCS + "\"");
        System.out.println("结果: " + (reconstructed.equals(expectedLCS) ? "✅" : "❌"));
    }
    
    private static void testRecursive() {
        System.out.println("\n=== 递归解法测试 ===");
        
        String[] testCases = {
            "abcde", "ace",
            "abc", "abc", 
            "abc", "def"
        };
        
        for (int i = 0; i < testCases.length; i += 2) {
            String text1 = testCases[i];
            String text2 = testCases[i + 1];
            
            int dpResult = longestCommonSubsequence1(text1, text2);
            int recursiveResult = longestCommonSubsequenceRecursive(text1, text2);
            
            System.out.printf("text1=\"%s\", text2=\"%s\": DP=%d, 递归=%d %s\n",
                text1, text2, dpResult, recursiveResult,
                dpResult == recursiveResult ? "✓" : "✗");
        }
    }
    
    private static void performanceTest() {
        System.out.println("\n=== 性能测试 ===");
        
        // 生成大规模测试数据
        String text1 = "abcdefghij".repeat(100); // 1000字符
        String text2 = "acegikmoqs".repeat(50);  // 500字符
        
        long startTime, endTime;
        
        // 测试基础DP方法
        startTime = System.nanoTime();
        int result1 = longestCommonSubsequence1(text1, text2);
        endTime = System.nanoTime();
        System.out.println("基础DP耗时: " + (endTime - startTime) / 1e6 + "ms");
        
        // 测试空间优化方法
        startTime = System.nanoTime();
        int result2 = longestCommonSubsequence2(text1, text2);
        endTime = System.nanoTime();
        System.out.println("优化DP耗时: " + (endTime - startTime) / 1e6 + "ms");
        
        // 测试递归方法（小规模）
        if (text1.length() <= 20 && text2.length() <= 20) {
            startTime = System.nanoTime();
            int result3 = longestCommonSubsequenceRecursive(text1, text2);
            endTime = System.nanoTime();
            System.out.println("递归方法耗时: " + (endTime - startTime) / 1e6 + "ms");
        }
        
        System.out.println("结果一致性: " + (result1 == result2 ? "✅" : "❌"));
        System.out.println("LCS长度: " + result1);
    }
    
    /**
     * 调试工具：打印DP表
     */
    public static void printDPTable(String text1, String text2) {
        char[] s1 = text1.toCharArray();
        char[] s2 = text2.toCharArray();
        int n = s1.length;
        int m = s2.length;
        
        int[][] dp = new int[n + 1][m + 1];
        
        // 填充DP表
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= m; j++) {
                if (s1[i - 1] == s2[j - 1]) {
                    dp[i][j] = dp[i - 1][j - 1] + 1;
                } else {
                    dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
                }
            }
        }
        
        // 打印DP表
        System.out.println("LCS DP表:");
        System.out.print("    ");
        for (int j = 0; j <= m; j++) {
            System.out.printf("%3d", j);
        }
        System.out.println();
        
        for (int i = 0; i <= n; i++) {
            System.out.printf("%3d:", i);
            for (int j = 0; j <= m; j++) {
                System.out.printf("%3d", dp[i][j]);
            }
            System.out.println();
        }
        
        System.out.println("最长公共子序列长度: " + dp[n][m]);
    }
}

===============================================

文件: Code12_LongestCommonSubsequence.py
===============================================
# 最长公共子序列
# 给定两个字符串 text1 和 text2，返回这两个字符串的最长公共子序列的长度
# 一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串
# 测试链接 : https://leetcode.cn/problems/longest-common-subsequence/

class Solution:
    
    def longestCommonSubsequence1(self, text1: str, text2: str) -> int:
        """
        算法思路：
        使用动态规划解决最长公共子序列问题
        dp[i][j] 表示 text1 的前 i 个字符与 text2 的前 j 个字符的最长公共子序列的长度
        
        状态转移方程：
        如果 text1[i-1] == text2[j-1]，则当前字符可以加入公共子序列
          dp[i][j] = dp[i-1][j-1] + 1
        如果 text1[i-1] != text2[j-1]，则取两种情况的最大值
          dp[i][j] = max(dp[i-1][j], dp[i][j-1])
        
        边界条件：
        dp[0][j] = 0，表示 text1 为空字符串时，与 text2 的最长公共子序列长度为 0
        dp[i][0] = 0，表示 text2 为空字符串时，与 text1 的最长公共子序列长度为 0
        
        时间复杂度：O(n*m)，其中n为text1的长度，m为text2的长度
        空间复杂度：O(n*m)
        """
        if not text1 or not text2:
            return 0
        n = len(text1)
        m = len(text2)
        # dp[i][j] 表示text1[0...i-1]和text2[0...j-1]的最长公共子序列长度
        dp = [[0] * (m + 1) for _ in range(n + 1)]
        
        # 填充dp表
        for i in range(1, n + 1):
            for j in range(1, m + 1):
                if text1[i - 1] == text2[j - 1]:
                    # 当前字符相同，可以加入公共子序列
                    dp[i][j] = dp[i - 1][j - 1] + 1
                else:
                    # 当前字符不同，取两种情况的最大值
                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])
        
        return dp[n][m]
    
    def longestCommonSubsequence2(self, text1: str, text2: str) -> int:
        """
        空间优化版本
        观察状态转移方程，dp[i][j]只依赖于dp[i-1][j-1]、dp[i-1][j]和dp[i][j-1]
        可以使用一维数组优化空间复杂度
        
        时间复杂度：O(n*m)
        空间复杂度：O(min(n,m))
        """
        if not text1 or not text2:
            return 0
        
        # 为了节省空间，让较短的字符串作为第二个参数
        if len(text1) < len(text2):
            text1, text2 = text2, text1
        
        n = len(text1)
        m = len(text2)
        # 使用一维数组存储当前行的数据
        dp = [0] * (m + 1)
        # 保存左上角的值(dp[i-1][j-1])
        pre = 0
        
        # 按行填充dp表
        for i in range(1, n + 1):
            pre = 0  # 每行开始时，左上角的值为0
            for j in range(1, m + 1):
                temp = dp[j]  # 保存当前dp[j]，用于下一轮的pre
                if text1[i - 1] == text2[j - 1]:
                    # 当前字符相同
                    dp[j] = pre + 1
                else:
                    # 当前字符不同，取上方或左方的最大值
                    dp[j] = max(dp[j], dp[j - 1])
                pre = temp  # 更新pre为下一轮的左上角值
        
        return dp[m]

# 单元测试
def test_solution():
    solution = Solution()
    
    # 测试用例1: "abcde", "ace"
    # 预期输出: 3 ("ace")
    print(f"Test 1: {solution.longestCommonSubsequence1('abcde', 'ace')}")  # 应输出3
    print(f"Test 1 (Space Optimized): {solution.longestCommonSubsequence2('abcde', 'ace')}")  # 应输出3
    
    # 测试用例2: "abc", "abc"
    # 预期输出: 3 ("abc")
    print(f"Test 2: {solution.longestCommonSubsequence1('abc', 'abc')}")  # 应输出3
    print(f"Test 2 (Space Optimized): {solution.longestCommonSubsequence2('abc', 'abc')}")  # 应输出3
    
    # 测试用例3: "abc", "def"
    # 预期输出: 0 (无公共子序列)
    print(f"Test 3: {solution.longestCommonSubsequence1('abc', 'def')}")  # 应输出0
    print(f"Test 3 (Space Optimized): {solution.longestCommonSubsequence2('abc', 'def')}")  # 应输出0
    
    # 边界测试: 空字符串
    print(f"Test 4 (Empty String): {solution.longestCommonSubsequence1('', 'abc')}")  # 应输出0
    print(f"Test 4 (Empty String, Space Optimized): {solution.longestCommonSubsequence2('', 'abc')}")  # 应输出0
    
    # 边界测试: 单字符匹配
    print(f"Test 5 (Single Char Match): {solution.longestCommonSubsequence1('a', 'a')}")  # 应输出1
    print(f"Test 5 (Single Char Match, Space Optimized): {solution.longestCommonSubsequence2('a', 'a')}")  # 应输出1
    
    # 边界测试: 单字符不匹配
    print(f"Test 6 (Single Char No Match): {solution.longestCommonSubsequence1('a', 'b')}")  # 应输出0
    print(f"Test 6 (Single Char No Match, Space Optimized): {solution.longestCommonSubsequence2('a', 'b')}")  # 应输出0

# 运行测试
if __name__ == "__main__":
    test_solution()

===============================================

文件: Code13_LongestPalindromicSubstring.cpp
===============================================
#include <iostream>
#include <vector>
#include <string>

// 最长回文子串
// 给你一个字符串 s，找到 s 中最长的回文子串
// 测试链接 : https://leetcode.cn/problems/longest-palindromic-substring/
class Solution {
public:
    /*
     * 算法思路：
     * 使用动态规划解决最长回文子串问题
     * dp[i][j] 表示字符串s在区间[i,j]内是否是回文子串
     * 
     * 状态转移方程：
     * 如果 s[i] == s[j]，则取决于中间子串是否为回文
     *   dp[i][j] = dp[i+1][j-1]
     * 特殊情况：当子串长度小于等于3时，只需检查首尾字符是否相等
     *   dp[i][j] = (s[i] == s[j])
     * 
     * 边界条件：
     * dp[i][i] = true，表示单个字符是回文子串
     * dp[i][i+1] = (s[i] == s[i+1])，表示两个字符的回文判断
     * 
     * 时间复杂度：O(n²)，其中n为字符串s的长度
     * 空间复杂度：O(n²)
     */
    std::string longestPalindrome1(std::string s) {
        if (s.empty() || s.length() < 2) {
            return s;
        }
        int n = s.length();
        // dp[i][j] 表示s[i...j]是否是回文子串
        std::vector<std::vector<bool>> dp(n, std::vector<bool>(n, false));
        int maxLen = 1;
        int start = 0;
        
        // 初始化：单个字符和两个字符的情况
        for (int i = 0; i < n; ++i) {
            dp[i][i] = true; // 单个字符是回文
            // 初始化两个字符的情况
            if (i < n - 1 && s[i] == s[i + 1]) {
                dp[i][i + 1] = true;
                maxLen = 2;
                start = i;
            }
        }
        
        // 按子串长度由小到大填充dp表
        for (int len = 3; len <= n; ++len) {
            for (int i = 0; i <= n - len; ++i) {
                int j = i + len - 1;
                // 首尾字符相等，且中间子串是回文，则整个子串是回文
                if (s[i] == s[j] && dp[i + 1][j - 1]) {
                    dp[i][j] = true;
                    if (len > maxLen) {
                        maxLen = len;
                        start = i;
                    }
                }
            }
        }
        
        return s.substr(start, maxLen);
    }

    /*
     * 中心扩展法
     * 回文串都是从中心向两边对称的，可以枚举每一个可能的中心点，然后向两边扩展
     * 注意：中心点可能是一个字符（奇数长度）或两个字符之间的位置（偶数长度）
     * 
     * 时间复杂度：O(n²)
     * 空间复杂度：O(1)
     */
    std::string longestPalindrome2(std::string s) {
        if (s.empty() || s.length() < 2) {
            return s;
        }
        int n = s.length();
        int maxLen = 1;
        int start = 0;
        
        // 枚举每一个可能的中心点
        for (int i = 0; i < n; ++i) {
            // 以单个字符为中心（奇数长度）
            std::pair<int, int> res1 = expandAroundCenter(s, i, i);
            // 以两个字符之间为中心（偶数长度）
            std::pair<int, int> res2 = expandAroundCenter(s, i, i + 1);
            
            // 更新最长回文子串
            if (res1.second > maxLen) {
                maxLen = res1.second;
                start = res1.first;
            }
            if (res2.second > maxLen) {
                maxLen = res2.second;
                start = res2.first;
            }
        }
        
        return s.substr(start, maxLen);
    }
    
    /*
     * 从中心向两边扩展寻找回文子串
     * 返回值：pair<起始索引, 长度>
     */
    std::pair<int, int> expandAroundCenter(const std::string& s, int left, int right) {
        int n = s.length();
        while (left >= 0 && right < n && s[left] == s[right]) {
            --left;
            ++right;
        }
        // 返回起始索引和长度
        return {left + 1, right - left - 1};
    }
};

// 单元测试
int main() {
    Solution solution;
    
    // 测试用例1: "babad"
    // 预期输出: "bab" 或 "aba"
    std::cout << "Test 1: " << solution.longestPalindrome1("babad") << std::endl;
    std::cout << "Test 1 (Expand Around Center): " << solution.longestPalindrome2("babad") << std::endl;
    
    // 测试用例2: "cbbd"
    // 预期输出: "bb"
    std::cout << "Test 2: " << solution.longestPalindrome1("cbbd") << std::endl;
    std::cout << "Test 2 (Expand Around Center): " << solution.longestPalindrome2("cbbd") << std::endl;
    
    // 边界测试: 单字符
    std::cout << "Test 3 (Single Char): " << solution.longestPalindrome1("a") << std::endl; // 应输出"a"
    std::cout << "Test 3 (Single Char, Expand Around Center): " << solution.longestPalindrome2("a") << std::endl; // 应输出"a"
    
    // 边界测试: 全部相同字符
    std::cout << "Test 4 (All Same): " << solution.longestPalindrome1("aaaaa") << std::endl; // 应输出"aaaaa"
    std::cout << "Test 4 (All Same, Expand Around Center): " << solution.longestPalindrome2("aaaaa") << std::endl; // 应输出"aaaaa"
    
    // 测试用例5: "ac"
    // 预期输出: "a" 或 "c"
    std::cout << "Test 5: " << solution.longestPalindrome1("ac") << std::endl;
    std::cout << "Test 5 (Expand Around Center): " << solution.longestPalindrome2("ac") << std::endl;
    
    return 0;
}

===============================================

文件: Code13_LongestPalindromicSubstring.java
===============================================
/**
 * 最长回文子串（Longest Palindromic Substring）
 * 给你一个字符串 s，找到 s 中最长的回文子串
 * 
 * 题目来源：LeetCode 5. 最长回文子串
 * 测试链接：https://leetcode.cn/problems/longest-palindromic-substring/
 * 
 * 算法核心思想：
 * 提供两种解法：动态规划和中心扩展法
 * 1. 动态规划：通过构建二维DP表判断每个子串是否为回文
 * 2. 中心扩展法：枚举每个可能的回文中心，向两边扩展寻找最长回文子串
 * 
 * 时间复杂度分析：
 * - 动态规划版本：O(n²)，其中n为字符串s的长度
 * - 中心扩展版本：O(n²)
 * 
 * 空间复杂度分析：
 * - 动态规划版本：O(n²)
 * - 中心扩展版本：O(1)
 * 
 * 最优解判定：
 * - 动态规划：适合需要记录所有回文子串信息的场景
 * - 中心扩展法：✅ 是最优解，空间复杂度更优
 * 
 * 工程化考量：
 * 1. 异常处理：检查输入参数合法性
 * 2. 边界条件：处理空字符串、单字符和极端情况
 * 3. 性能优化：提供空间优化的中心扩展法
 * 4. 代码可读性：添加详细注释和测试用例
 * 
 * 与其他领域的联系：
 * - 生物信息学：DNA序列中的回文结构识别
 * - 数据结构：字符串处理和模式匹配
 * - 算法设计：动态规划和枚举算法对比
 */
public class Code13_LongestPalindromicSubstring {

	/*
	 * 算法思路：
	 * 使用动态规划解决最长回文子串问题
	 * dp[i][j] 表示字符串s在区间[i,j]内是否是回文子串
	 * 
	 * 状态转移方程：
	 * 如果 s[i] == s[j]，则取决于中间子串是否为回文
	 *   dp[i][j] = dp[i+1][j-1]
	 * 特殊情况：当子串长度小于等于3时，只需检查首尾字符是否相等
	 *   dp[i][j] = (s[i] == s[j])
	 * 
	 * 边界条件：
	 * dp[i][i] = true，表示单个字符是回文子串
	 * dp[i][i+1] = (s[i] == s[i+1])，表示两个字符的回文判断
	 * 
	 * 时间复杂度：O(n²)，其中n为字符串s的长度
	 * 空间复杂度：O(n²)
	 */
	public static String longestPalindrome1(String s) {
		// 输入验证
		if (s == null) {
			throw new IllegalArgumentException("输入字符串不能为null");
		}
		
		// 边界情况处理
		if (s.length() < 2) {
			return s;
		}
		
		char[] str = s.toCharArray();
		int n = str.length;
		
		// dp[i][j] 表示str[i...j]是否是回文子串
		boolean[][] dp = new boolean[n][n];
		
		// 记录最长回文子串的起始位置和长度
		int maxLen = 1;
		int start = 0;
		
		// 初始化：单个字符和两个字符的情况
		for (int i = 0; i < n; i++) {
			dp[i][i] = true; // 单个字符是回文
			
			// 初始化两个字符的情况
			if (i < n - 1 && str[i] == str[i + 1]) {
				dp[i][i + 1] = true;
				maxLen = 2;
				start = i;
			}
		}
		
		// 按子串长度由小到大填充dp表
		// 从长度为3的子串开始计算
		for (int len = 3; len <= n; len++) {
			// i是子串的起始位置
			for (int i = 0; i <= n - len; i++) {
				// j是子串的结束位置
				int j = i + len - 1;
				
				// 首尾字符相等，且中间子串是回文，则整个子串是回文
				if (str[i] == str[j] && dp[i + 1][j - 1]) {
					dp[i][j] = true;
					
					// 更新最长回文子串信息
					if (len > maxLen) {
						maxLen = len;
						start = i;
					}
				}
			}
		}
		
		return s.substring(start, start + maxLen);
	}

	/*
	 * 中心扩展法
	 * 回文串都是从中心向两边对称的，可以枚举每一个可能的中心点，然后向两边扩展
	 * 注意：中心点可能是一个字符（奇数长度）或两个字符之间的位置（偶数长度）
	 * 
	 * 时间复杂度：O(n²)
	 * 空间复杂度：O(1)
	 */
	public static String longestPalindrome2(String s) {
		// 输入验证
		if (s == null) {
			throw new IllegalArgumentException("输入字符串不能为null");
		}
		
		// 边界情况处理
		if (s.length() < 2) {
			return s;
		}
		
		char[] str = s.toCharArray();
		int n = str.length;
		
		// 记录最长回文子串的起始位置和长度
		int maxLen = 1;
		int start = 0;
		
		// 枚举每一个可能的中心点
		for (int i = 0; i < n; i++) {
			// 以单个字符为中心（奇数长度回文）
			int[] res1 = expandAroundCenter(str, i, i);
			
			// 以两个字符之间为中心（偶数长度回文）
			int[] res2 = expandAroundCenter(str, i, i + 1);
			
			// 更新最长回文子串
			if (res1[1] > maxLen) {
				maxLen = res1[1];
				start = res1[0];
			}
			if (res2[1] > maxLen) {
				maxLen = res2[1];
				start = res2[0];
			}
		}
		
		return s.substring(start, start + maxLen);
	}
	
	/*
	 * 从中心向两边扩展寻找回文子串
	 * 
	 * @param str 字符数组
	 * @param left 左边界
	 * @param right 右边界
	 * @return [起始索引, 长度]
	 */
	private static int[] expandAroundCenter(char[] str, int left, int right) {
		int n = str.length;
		
		// 向两边扩展，直到字符不相等或越界
		while (left >= 0 && right < n && str[left] == str[right]) {
			left--;
			right++;
		}
		
		// 返回起始索引和长度
		// left+1是实际的起始位置，right-left-1是实际的长度
		return new int[]{left + 1, right - left - 1};
	}
	
	/*
	 * 单元测试示例
	 * 测试边界情况和常见情况
	 */
	public static void main(String[] args) {
		// 测试用例1: "babad"
		// 预期输出: "bab" 或 "aba"
		System.out.println("Test 1: " + longestPalindrome1("babad"));
		System.out.println("Test 1 (Expand Around Center): " + longestPalindrome2("babad"));
		
		// 测试用例2: "cbbd"
		// 预期输出: "bb"
		System.out.println("Test 2: " + longestPalindrome1("cbbd"));
		System.out.println("Test 2 (Expand Around Center): " + longestPalindrome2("cbbd"));
		
		// 边界测试: 单字符
		System.out.println("Test 3 (Single Char): " + longestPalindrome1("a")); // 应输出"a"
		System.out.println("Test 3 (Single Char, Expand Around Center): " + longestPalindrome2("a")); // 应输出"a"
		
		// 边界测试: 全部相同字符
		System.out.println("Test 4 (All Same): " + longestPalindrome1("aaaaa")); // 应输出"aaaaa"
		System.out.println("Test 4 (All Same, Expand Around Center): " + longestPalindrome2("aaaaa")); // 应输出"aaaaa"
		
		// 测试用例5: "ac"
		// 预期输出: "a" 或 "c"
		System.out.println("Test 5: " + longestPalindrome1("ac"));
		System.out.println("Test 5 (Expand Around Center): " + longestPalindrome2("ac"));
	}
}

===============================================

文件: Code13_LongestPalindromicSubstring.py
===============================================
# 最长回文子串
# 给你一个字符串 s，找到 s 中最长的回文子串
# 测试链接 : https://leetcode.cn/problems/longest-palindromic-substring/

class Solution:
    
    def longestPalindrome1(self, s: str) -> str:
        """
        算法思路：
        使用动态规划解决最长回文子串问题
        dp[i][j] 表示字符串s在区间[i,j]内是否是回文子串
        
        状态转移方程：
        如果 s[i] == s[j]，则取决于中间子串是否为回文
          dp[i][j] = dp[i+1][j-1]
        特殊情况：当子串长度小于等于3时，只需检查首尾字符是否相等
          dp[i][j] = (s[i] == s[j])
        
        边界条件：
        dp[i][i] = True，表示单个字符是回文子串
        dp[i][i+1] = (s[i] == s[i+1])，表示两个字符的回文判断
        
        时间复杂度：O(n²)，其中n为字符串s的长度
        空间复杂度：O(n²)
        """
        if not s or len(s) < 2:
            return s
        n = len(s)
        # dp[i][j] 表示s[i...j]是否是回文子串
        dp = [[False] * n for _ in range(n)]
        max_len = 1
        start = 0
        
        # 初始化：单个字符和两个字符的情况
        for i in range(n):
            dp[i][i] = True  # 单个字符是回文
            # 初始化两个字符的情况
            if i < n - 1 and s[i] == s[i + 1]:
                dp[i][i + 1] = True
                max_len = 2
                start = i
        
        # 按子串长度由小到大填充dp表
        for length in range(3, n + 1):
            for i in range(n - length + 1):
                j = i + length - 1
                # 首尾字符相等，且中间子串是回文，则整个子串是回文
                if s[i] == s[j] and dp[i + 1][j - 1]:
                    dp[i][j] = True
                    if length > max_len:
                        max_len = length
                        start = i
        
        return s[start:start + max_len]
    
    def longestPalindrome2(self, s: str) -> str:
        """
        中心扩展法
        回文串都是从中心向两边对称的，可以枚举每一个可能的中心点，然后向两边扩展
        注意：中心点可能是一个字符（奇数长度）或两个字符之间的位置（偶数长度）
        
        时间复杂度：O(n²)
        空间复杂度：O(1)
        """
        if not s or len(s) < 2:
            return s
        n = len(s)
        max_len = 1
        start = 0
        
        # 枚举每一个可能的中心点
        for i in range(n):
            # 以单个字符为中心（奇数长度）
            start1, len1 = self.expand_around_center(s, i, i)
            # 以两个字符之间为中心（偶数长度）
            start2, len2 = self.expand_around_center(s, i, i + 1)
            
            # 更新最长回文子串
            if len1 > max_len:
                max_len = len1
                start = start1
            if len2 > max_len:
                max_len = len2
                start = start2
        
        return s[start:start + max_len]
    
    def expand_around_center(self, s: str, left: int, right: int) -> tuple:
        """
        从中心向两边扩展寻找回文子串
        返回值：(起始索引, 长度)
        """
        n = len(s)
        while left >= 0 and right < n and s[left] == s[right]:
            left -= 1
            right += 1
        # 返回起始索引和长度
        return (left + 1, right - left - 1)

# 单元测试
def test_solution():
    solution = Solution()
    
    # 测试用例1: "babad"
    # 预期输出: "bab" 或 "aba"
    print(f"Test 1: {solution.longestPalindrome1('babad')}")
    print(f"Test 1 (Expand Around Center): {solution.longestPalindrome2('babad')}")
    
    # 测试用例2: "cbbd"
    # 预期输出: "bb"
    print(f"Test 2: {solution.longestPalindrome1('cbbd')}")
    print(f"Test 2 (Expand Around Center): {solution.longestPalindrome2('cbbd')}")
    
    # 边界测试: 单字符
    print(f"Test 3 (Single Char): {solution.longestPalindrome1('a')}")  # 应输出"a"
    print(f"Test 3 (Single Char, Expand Around Center): {solution.longestPalindrome2('a')}")  # 应输出"a"
    
    # 边界测试: 全部相同字符
    print(f"Test 4 (All Same): {solution.longestPalindrome1('aaaaa')}")  # 应输出"aaaaa"
    print(f"Test 4 (All Same, Expand Around Center): {solution.longestPalindrome2('aaaaa')}")  # 应输出"aaaaa"
    
    # 测试用例5: "ac"
    # 预期输出: "a" 或 "c"
    print(f"Test 5: {solution.longestPalindrome1('ac')}")
    print(f"Test 5 (Expand Around Center): {solution.longestPalindrome2('ac')}")

# 运行测试
if __name__ == "__main__":
    test_solution()

===============================================

文件: Code14_EditDistance.cpp
===============================================
#include <iostream>
#include <vector>
#include <string>
#include <algorithm>

// 编辑距离
// 给你两个单词 word1 和 word2，计算将 word1 转换成 word2 所使用的最少操作数
// 你可以对一个单词进行如下三种操作：
// 插入一个字符
// 删除一个字符
// 替换一个字符
// 测试链接 : https://leetcode.cn/problems/edit-distance/
class Solution {
public:
    /*
     * 算法思路：
     * 使用动态规划解决编辑距离问题
     * dp[i][j] 表示将 word1 的前 i 个字符转换为 word2 的前 j 个字符所需的最小操作数
     * 
     * 状态转移方程：
     * 如果 word1[i-1] == word2[j-1]，则不需要操作
     *   dp[i][j] = dp[i-1][j-1]
     * 否则，取三种操作的最小值：
     *   dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1
     * 其中：
     *   dp[i-1][j] + 1 表示删除操作（删除 word1 的第 i 个字符）
     *   dp[i][j-1] + 1 表示插入操作（在 word1 的第 i 个位置后插入 word2 的第 j 个字符）
     *   dp[i-1][j-1] + 1 表示替换操作（将 word1 的第 i 个字符替换为 word2 的第 j 个字符）
     * 
     * 边界条件：
     * dp[i][0] = i，表示将 word1 的前 i 个字符转换为空字符串需要 i 次删除操作
     * dp[0][j] = j，表示将空字符串转换为 word2 的前 j 个字符需要 j 次插入操作
     * 
     * 时间复杂度：O(m*n)，其中m为word1的长度，n为word2的长度
     * 空间复杂度：O(m*n)
     */
    int minDistance1(std::string word1, std::string word2) {
        int m = word1.length();
        int n = word2.length();
        // dp[i][j] 表示word1[0...i-1]转换为word2[0...j-1]所需的最小操作数
        std::vector<std::vector<int>> dp(m + 1, std::vector<int>(n + 1));
        
        // 初始化边界条件
        for (int i = 0; i <= m; ++i) {
            dp[i][0] = i; // 将word1转换为空字符串，需要i次删除操作
        }
        for (int j = 0; j <= n; ++j) {
            dp[0][j] = j; // 将空字符串转换为word2，需要j次插入操作
        }
        
        // 填充dp表
        for (int i = 1; i <= m; ++i) {
            for (int j = 1; j <= n; ++j) {
                if (word1[i - 1] == word2[j - 1]) {
                    // 当前字符相同，不需要操作
                    dp[i][j] = dp[i - 1][j - 1];
                } else {
                    // 取三种操作的最小值
                    dp[i][j] = std::min({dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]}) + 1;
                }
            }
        }
        
        return dp[m][n];
    }

    /*
     * 空间优化版本
     * 观察状态转移方程，dp[i][j]只依赖于dp[i-1][j-1]、dp[i-1][j]和dp[i][j-1]
     * 可以使用一维数组优化空间复杂度
     * 
     * 时间复杂度：O(m*n)
     * 空间复杂度：O(min(m,n))
     */
    int minDistance2(std::string word1, std::string word2) {
        // 为了节省空间，确保第二个参数是较短的字符串
        if (word1.length() < word2.length()) {
            std::swap(word1, word2);
        }
        
        int m = word1.length();
        int n = word2.length();
        // 使用一维数组存储当前行的数据
        std::vector<int> dp(n + 1);
        // 初始化dp[0][j] = j
        for (int j = 0; j <= n; ++j) {
            dp[j] = j;
        }
        
        // 按行填充dp表
        for (int i = 1; i <= m; ++i) {
            int pre = dp[0]; // 保存左上角的值(dp[i-1][j-1])
            dp[0] = i; // 更新dp[i][0] = i
            for (int j = 1; j <= n; ++j) {
                int temp = dp[j]; // 保存当前dp[j]，用于下一轮的pre
                if (word1[i - 1] == word2[j - 1]) {
                    // 当前字符相同，不需要操作
                    dp[j] = pre;
                } else {
                    // 取三种操作的最小值
                    dp[j] = std::min({dp[j], dp[j - 1], pre}) + 1;
                }
                pre = temp; // 更新pre为下一轮的左上角值
            }
        }
        
        return dp[n];
    }
};

// 单元测试
int main() {
    Solution solution;
    
    // 测试用例1: word1 = "horse", word2 = "ros"
    // 预期输出: 3
    // 解释: 
    // horse -> rorse (替换 'h' 为 'r')
    // rorse -> rose (删除 'r')
    // rose -> ros (删除 'e')
    std::cout << "Test 1: " << solution.minDistance1("horse", "ros") << std::endl; // 应输出3
    std::cout << "Test 1 (Space Optimized): " << solution.minDistance2("horse", "ros") << std::endl; // 应输出3
    
    // 测试用例2: word1 = "intention", word2 = "execution"
    // 预期输出: 5
    // 解释: 
    // intention -> inention (删除 't')
    // inention -> enention (替换 'i' 为 'e')
    // enention -> exention (替换 'n' 为 'x')
    // exention -> exection (替换 'n' 为 'c')
    // exection -> execution (插入 'u')
    std::cout << "Test 2: " << solution.minDistance1("intention", "execution") << std::endl; // 应输出5
    std::cout << "Test 2 (Space Optimized): " << solution.minDistance2("intention", "execution") << std::endl; // 应输出5
    
    // 边界测试: 空字符串
    std::cout << "Test 3 (Empty String): " << solution.minDistance1("", "abc") << std::endl; // 应输出3
    std::cout << "Test 3 (Empty String, Space Optimized): " << solution.minDistance2("", "abc") << std::endl; // 应输出3
    
    // 边界测试: 相同字符串
    std::cout << "Test 4 (Same String): " << solution.minDistance1("abc", "abc") << std::endl; // 应输出0
    std::cout << "Test 4 (Same String, Space Optimized): " << solution.minDistance2("abc", "abc") << std::endl; // 应输出0
    
    // 边界测试: 单字符不同
    std::cout << "Test 5 (Single Char Different): " << solution.minDistance1("a", "b") << std::endl; // 应输出1
    std::cout << "Test 5 (Single Char Different, Space Optimized): " << solution.minDistance2("a", "b") << std::endl; // 应输出1
    
    return 0;
}

===============================================

文件: Code14_EditDistance.java
===============================================
import java.util.Arrays;

/**
 * 编辑距离 (Edit Distance / Levenshtein Distance)
 * 给你两个单词 word1 和 word2，计算将 word1 转换成 word2 所使用的最少操作数
 * 允许的三种操作：
 * 1. 插入一个字符
 * 2. 删除一个字符  
 * 3. 替换一个字符
 * 
 * 题目来源：LeetCode 72. 编辑距离
 * 测试链接：https://leetcode.cn/problems/edit-distance/
 * 
 * 算法核心思想：
 * 动态规划解决经典的字符串编辑距离问题，是自然语言处理中的基础算法
 * 
 * 时间复杂度分析：
 * - 基础版本：O(m*n)，其中m为word1的长度，n为word2的长度
 * - 空间优化版本：O(m*n)时间，O(min(m,n))空间
 * 
 * 空间复杂度分析：
 * - 基础版本：O(m*n)
 * - 空间优化版本：O(min(m,n))
 * 
 * 最优解判定：✅ 是最优解，时间复杂度无法进一步优化，空间复杂度已优化到最优
 * 
 * 工程化考量：
 * 1. 输入验证：检查空指针和边界条件
 * 2. 性能优化：空间优化和算法优化
 * 3. 异常处理：处理各种异常情况
 * 4. 测试覆盖：全面的单元测试
 * 
 * 应用场景：
 * - 拼写检查与纠错
 * - 生物信息学中的DNA序列比对
 * - 自然语言处理中的文本相似度计算
 * - 版本控制系统中的文件差异比较
 */
public class Code14_EditDistance {

    /**
     * 基础动态规划解法 - 二维DP数组
     * 使用标准的动态规划方法解决编辑距离问题
     * 
     * 状态定义：
     * dp[i][j] 表示将字符串word1的前i个字符转换为字符串word2的前j个字符所需的最小操作数
     * 
     * 状态转移方程：
     * 1. 如果word1[i-1] == word2[j-1]：字符匹配，不需要操作
     *    dp[i][j] = dp[i-1][j-1]
     * 2. 如果word1[i-1] != word2[j-1]：需要选择最小代价的操作
     *    dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1
     *    其中：
     *    - dp[i-1][j] + 1：删除word1的第i个字符
     *    - dp[i][j-1] + 1：在word1的第i个位置后插入word2的第j个字符  
     *    - dp[i-1][j-1] + 1：将word1的第i个字符替换为word2的第j个字符
     * 
     * 边界条件：
     * - dp[i][0] = i：将word1的前i个字符转换为空字符串需要i次删除操作
     * - dp[0][j] = j：将空字符串转换为word2的前j个字符需要j次插入操作
     * 
     * @param word1 源字符串
     * @param word2 目标字符串
     * @return 最小编辑距离
     */
    public static int minDistance1(String word1, String word2) {
        // 输入验证
        if (word1 == null || word2 == null) {
            throw new IllegalArgumentException("输入字符串不能为null");
        }
        
        int m = word1.length();
        int n = word2.length();
        
        // 边界情况处理
        if (m == 0) return n; // word1为空，需要n次插入
        if (n == 0) return m; // word2为空，需要m次删除
        
        // dp[i][j]: word1[0..i-1]转换为word2[0..j-1]的最小操作数
        int[][] dp = new int[m + 1][n + 1];
        
        // 初始化边界条件
        for (int i = 0; i <= m; i++) {
            dp[i][0] = i; // 删除所有字符
        }
        for (int j = 0; j <= n; j++) {
            dp[0][j] = j; // 插入所有字符
        }
        
        // 填充DP表
        for (int i = 1; i <= m; i++) {
            for (int j = 1; j <= n; j++) {
                if (word1.charAt(i - 1) == word2.charAt(j - 1)) {
                    // 字符匹配，不需要操作
                    dp[i][j] = dp[i - 1][j - 1];
                } else {
                    // 取三种操作的最小值
                    int deleteOp = dp[i - 1][j] + 1;     // 删除操作
                    int insertOp = dp[i][j - 1] + 1;     // 插入操作
                    int replaceOp = dp[i - 1][j - 1] + 1; // 替换操作
                    dp[i][j] = Math.min(Math.min(deleteOp, insertOp), replaceOp);
                }
            }
        }
        
        return dp[m][n];
    }

    /**
     * 空间优化版本 - 一维DP数组
     * 通过观察状态转移的依赖关系，使用滚动数组技术优化空间复杂度
     * 
     * 优化原理：
     * - dp[i][j]只依赖于当前行和上一行的数据
     * - 可以使用一维数组+临时变量保存必要的历史值
     * - 通过交换字符串顺序确保使用较短的数组
     * 
     * 关键技巧：
     * 1. 让较短的字符串作为内层循环，减少空间占用
     * 2. 使用pre变量保存dp[i-1][j-1]的值
     * 3. 使用temp变量暂存当前值用于下一轮计算
     * 
     * @param word1 源字符串
     * @param word2 目标字符串
     * @return 最小编辑距离
     */
    public static int minDistance2(String word1, String word2) {
        // 输入验证
        if (word1 == null || word2 == null) {
            throw new IllegalArgumentException("输入字符串不能为null");
        }
        
        // 交换字符串顺序，确保第二个字符串较短
        if (word1.length() < word2.length()) {
            String temp = word1;
            word1 = word2;
            word2 = temp;
        }
        
        int m = word1.length();
        int n = word2.length();
        
        // 边界情况处理
        if (m == 0) return n;
        if (n == 0) return m;
        
        // 使用一维数组优化空间
        int[] dp = new int[n + 1];
        
        // 初始化第一行（空字符串转换为word2的前j个字符）
        for (int j = 0; j <= n; j++) {
            dp[j] = j;
        }
        
        // 动态规划过程
        for (int i = 1; i <= m; i++) {
            int pre = dp[0]; // 保存左上角的值(dp[i-1][j-1])
            dp[0] = i;       // 更新当前行的第一个元素
            
            for (int j = 1; j <= n; j++) {
                int temp = dp[j]; // 保存当前值，用于下一轮的pre
                
                if (word1.charAt(i - 1) == word2.charAt(j - 1)) {
                    // 字符匹配，不需要操作
                    dp[j] = pre;
                } else {
                    // 取三种操作的最小值
                    int deleteOp = dp[j] + 1;        // 删除操作（来自上方）
                    int insertOp = dp[j - 1] + 1;     // 插入操作（来自左方）
                    int replaceOp = pre + 1;          // 替换操作（来自左上角）
                    dp[j] = Math.min(Math.min(deleteOp, insertOp), replaceOp);
                }
                
                pre = temp; // 更新pre为当前轮的左上角值
            }
        }
        
        return dp[n];
    }

    /**
     * 带权重的编辑距离（扩展功能）
     * 不同的操作可以有不同的代价
     * 
     * @param word1 源字符串
     * @param word2 目标字符串
     * @param insertCost 插入操作的代价
     * @param deleteCost 删除操作的代价
     * @param replaceCost 替换操作的代价
     * @return 带权重的最小编辑距离
     */
    public static int minDistanceWithCost(String word1, String word2, 
                                         int insertCost, int deleteCost, int replaceCost) {
        if (word1 == null || word2 == null) {
            throw new IllegalArgumentException("输入字符串不能为null");
        }
        
        int m = word1.length();
        int n = word2.length();
        
        if (m == 0) return n * insertCost;
        if (n == 0) return m * deleteCost;
        
        int[][] dp = new int[m + 1][n + 1];
        
        // 初始化边界条件
        for (int i = 0; i <= m; i++) {
            dp[i][0] = i * deleteCost; // 删除所有字符
        }
        for (int j = 0; j <= n; j++) {
            dp[0][j] = j * insertCost; // 插入所有字符
        }
        
        // 填充DP表
        for (int i = 1; i <= m; i++) {
            for (int j = 1; j <= n; j++) {
                if (word1.charAt(i - 1) == word2.charAt(j - 1)) {
                    dp[i][j] = dp[i - 1][j - 1];
                } else {
                    int deleteOp = dp[i - 1][j] + deleteCost;
                    int insertOp = dp[i][j - 1] + insertCost;
                    int replaceOp = dp[i - 1][j - 1] + replaceCost;
                    dp[i][j] = Math.min(Math.min(deleteOp, insertOp), replaceOp);
                }
            }
        }
        
        return dp[m][n];
    }

    /**
     * 重构编辑操作序列（扩展功能）
     * 不仅计算距离，还重构出具体的操作序列
     * 
     * @param word1 源字符串
     * @param word2 目标字符串
     * @return 操作序列的描述
     */
    public static String reconstructEditOperations(String word1, String word2) {
        if (word1 == null || word2 == null) {
            return "输入错误";
        }
        
        int m = word1.length();
        int n = word2.length();
        
        if (m == 0 && n == 0) return "无需操作";
        if (m == 0) return "插入 " + word2;
        if (n == 0) return "删除 " + word1;
        
        int[][] dp = new int[m + 1][n + 1];
        
        // 初始化DP表
        for (int i = 0; i <= m; i++) dp[i][0] = i;
        for (int j = 0; j <= n; j++) dp[0][j] = j;
        
        // 填充DP表
        for (int i = 1; i <= m; i++) {
            for (int j = 1; j <= n; j++) {
                if (word1.charAt(i - 1) == word2.charAt(j - 1)) {
                    dp[i][j] = dp[i - 1][j - 1];
                } else {
                    dp[i][j] = Math.min(Math.min(dp[i - 1][j], dp[i][j - 1]), dp[i - 1][j - 1]) + 1;
                }
            }
        }
        
        // 重构操作序列
        StringBuilder operations = new StringBuilder();
        int i = m, j = n;
        
        while (i > 0 || j > 0) {
            if (i > 0 && j > 0 && word1.charAt(i - 1) == word2.charAt(j - 1)) {
                // 字符匹配，无需操作
                operations.insert(0, "保留 '" + word1.charAt(i - 1) + "'\n");
                i--;
                j--;
            } else {
                int current = dp[i][j];
                
                if (i > 0 && j > 0 && dp[i - 1][j - 1] + 1 == current) {
                    // 替换操作
                    operations.insert(0, "将 '" + word1.charAt(i - 1) + "' 替换为 '" + word2.charAt(j - 1) + "'\n");
                    i--;
                    j--;
                } else if (i > 0 && dp[i - 1][j] + 1 == current) {
                    // 删除操作
                    operations.insert(0, "删除 '" + word1.charAt(i - 1) + "'\n");
                    i--;
                } else if (j > 0 && dp[i][j - 1] + 1 == current) {
                    // 插入操作
                    operations.insert(0, "插入 '" + word2.charAt(j - 1) + "'\n");
                    j--;
                }
            }
        }
        
        return operations.toString();
    }

    /**
     * 递归解法（带记忆化）
     * 用于理解问题本质和对比性能
     * 
     * @param word1 源字符串
     * @param word2 目标字符串
     * @return 最小编辑距离
     */
    public static int minDistanceRecursive(String word1, String word2) {
        if (word1 == null || word2 == null) {
            return 0;
        }
        
        int m = word1.length();
        int n = word2.length();
        
        if (m == 0) return n;
        if (n == 0) return m;
        
        int[][] memo = new int[m][n];
        for (int[] row : memo) {
            Arrays.fill(row, -1);
        }
        
        return dfs(word1, word2, 0, 0, memo);
    }
    
    private static int dfs(String word1, String word2, int i, int j, int[][] memo) {
        if (i == word1.length()) {
            return word2.length() - j; // 需要插入剩余字符
        }
        if (j == word2.length()) {
            return word1.length() - i; // 需要删除剩余字符
        }
        
        if (memo[i][j] != -1) {
            return memo[i][j];
        }
        
        int result;
        if (word1.charAt(i) == word2.charAt(j)) {
            // 字符匹配，继续比较下一个字符
            result = dfs(word1, word2, i + 1, j + 1, memo);
        } else {
            // 三种操作的最小值
            int deleteOp = dfs(word1, word2, i + 1, j, memo) + 1;     // 删除
            int insertOp = dfs(word1, word2, i, j + 1, memo) + 1;     // 插入
            int replaceOp = dfs(word1, word2, i + 1, j + 1, memo) + 1; // 替换
            result = Math.min(Math.min(deleteOp, insertOp), replaceOp);
        }
        
        memo[i][j] = result;
        return result;
    }

    /**
     * 全面的单元测试
     * 覆盖各种边界情况和应用场景
     */
    public static void main(String[] args) {
        System.out.println("=== 编辑距离算法测试 ===");
        
        // 测试用例1：基本功能测试
        testCase("horse", "ros", 3, "基本功能测试");
        
        // 测试用例2：经典测试用例
        testCase("intention", "execution", 5, "经典测试用例");
        
        // 测试用例3：空字符串测试
        testCase("", "abc", 3, "空源字符串测试");
        testCase("abc", "", 3, "空目标字符串测试");
        testCase("", "", 0, "双空字符串测试");
        
        // 测试用例4：相同字符串测试
        testCase("abc", "abc", 0, "相同字符串测试");
        
        // 测试用例5：单字符测试
        testCase("a", "b", 1, "单字符不同测试");
        testCase("a", "a", 0, "单字符相同测试");
        
        // 测试用例6：LeetCode官方测试用例
        testCase("horse", "ros", 3, "LeetCode测试用例1");
        testCase("intention", "execution", 5, "LeetCode测试用例2");
        
        // 测试用例7：带权重编辑距离测试
        testWeightedDistance();
        
        // 测试用例8：重构操作序列测试
        testReconstruction();
        
        // 性能测试
        performanceTest();
        
        // 递归解法测试
        testRecursive();
        
        System.out.println("=== 所有测试通过 ===");
    }
    
    private static void testCase(String word1, String word2, int expected, String description) {
        System.out.println("\n测试: " + description);
        System.out.println("输入: word1 = \"" + word1 + "\", word2 = \"" + word2 + "\"");
        System.out.println("预期编辑距离: " + expected);
        
        int result1 = minDistance1(word1, word2);
        int result2 = minDistance2(word1, word2);
        
        System.out.println("方法1结果: " + result1 + " " + (result1 == expected ? "✓" : "✗"));
        System.out.println("方法2结果: " + result2 + " " + (result2 == expected ? "✓" : "✗"));
        
        if (result1 == expected && result2 == expected) {
            System.out.println("✅ 测试通过");
        } else {
            System.out.println("❌ 测试失败");
            throw new AssertionError("测试用例失败: " + description);
        }
    }
    
    private static void testWeightedDistance() {
        System.out.println("\n=== 带权重编辑距离测试 ===");
        
        String word1 = "kitten";
        String word2 = "sitting";
        
        // 标准权重（所有操作代价为1）
        int standard = minDistanceWithCost(word1, word2, 1, 1, 1);
        System.out.println("标准权重编辑距离: " + standard);
        
        // 高替换代价（替换代价为2）
        int highReplace = minDistanceWithCost(word1, word2, 1, 1, 2);
        System.out.println("高替换代价编辑距离: " + highReplace);
        
        // 禁止替换（替换代价为无穷大）
        int noReplace = minDistanceWithCost(word1, word2, 1, 1, Integer.MAX_VALUE);
        System.out.println("禁止替换编辑距离: " + noReplace);
    }
    
    private static void testReconstruction() {
        System.out.println("\n=== 重构编辑操作序列测试 ===");
        
        String word1 = "horse";
        String word2 = "ros";
        
        String operations = reconstructEditOperations(word1, word2);
        System.out.println("编辑操作序列:");
        System.out.println(operations);
        
        int distance = minDistance1(word1, word2);
        System.out.println("编辑距离: " + distance);
    }
    
    private static void testRecursive() {
        System.out.println("\n=== 递归解法测试 ===");
        
        String[][] testCases = {
            {"horse", "ros"},
            {"abc", "abc"},
            {"a", "b"}
        };
        
        for (String[] testCase : testCases) {
            String word1 = testCase[0];
            String word2 = testCase[1];
            
            int dpResult = minDistance1(word1, word2);
            int recursiveResult = minDistanceRecursive(word1, word2);
            
            System.out.printf("word1=\"%s\", word2=\"%s\": DP=%d, 递归=%d %s\n",
                word1, word2, dpResult, recursiveResult,
                dpResult == recursiveResult ? "✓" : "✗");
        }
    }
    
    private static void performanceTest() {
        System.out.println("\n=== 性能测试 ===");
        
        // 生成大规模测试数据
        String word1 = "abcdefghij".repeat(100); // 1000字符
        String word2 = "acegikmoqs".repeat(50);  // 500字符
        
        long startTime, endTime;
        
        // 测试基础DP方法
        startTime = System.nanoTime();
        int result1 = minDistance1(word1, word2);
        endTime = System.nanoTime();
        System.out.println("基础DP耗时: " + (endTime - startTime) / 1e6 + "ms");
        
        // 测试空间优化方法
        startTime = System.nanoTime();
        int result2 = minDistance2(word1, word2);
        endTime = System.nanoTime();
        System.out.println("优化DP耗时: " + (endTime - startTime) / 1e6 + "ms");
        
        System.out.println("结果一致性: " + (result1 == result2 ? "✅" : "❌"));
        System.out.println("编辑距离: " + result1);
    }
    
    /**
     * 调试工具：打印DP表
     */
    public static void printDPTable(String word1, String word2) {
        int m = word1.length();
        int n = word2.length();
        
        int[][] dp = new int[m + 1][n + 1];
        
        // 初始化DP表
        for (int i = 0; i <= m; i++) dp[i][0] = i;
        for (int j = 0; j <= n; j++) dp[0][j] = j;
        
        // 填充DP表
        for (int i = 1; i <= m; i++) {
            for (int j = 1; j <= n; j++) {
                if (word1.charAt(i - 1) == word2.charAt(j - 1)) {
                    dp[i][j] = dp[i - 1][j - 1];
                } else {
                    dp[i][j] = Math.min(Math.min(dp[i - 1][j], dp[i][j - 1]), dp[i - 1][j - 1]) + 1;
                }
            }
        }
        
        // 打印DP表
        System.out.println("编辑距离DP表:");
        System.out.print("    ");
        for (int j = 0; j <= n; j++) {
            System.out.printf("%3d", j);
        }
        System.out.println();
        
        for (int i = 0; i <= m; i++) {
            System.out.printf("%3d:", i);
            for (int j = 0; j <= n; j++) {
                System.out.printf("%3d", dp[i][j]);
            }
            System.out.println();
        }
        
        System.out.println("最小编辑距离: " + dp[m][n]);
    }
}

===============================================

文件: Code14_EditDistance.py
===============================================
# 编辑距离
# 给你两个单词 word1 和 word2，计算将 word1 转换成 word2 所使用的最少操作数
# 你可以对一个单词进行如下三种操作：
# 插入一个字符
# 删除一个字符
# 替换一个字符
# 测试链接 : https://leetcode.cn/problems/edit-distance/

class Solution:
    
    def minDistance1(self, word1: str, word2: str) -> int:
        """
        算法思路：
        使用动态规划解决编辑距离问题
        dp[i][j] 表示将 word1 的前 i 个字符转换为 word2 的前 j 个字符所需的最小操作数
        
        状态转移方程：
        如果 word1[i-1] == word2[j-1]，则不需要操作
          dp[i][j] = dp[i-1][j-1]
        否则，取三种操作的最小值：
          dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1
        其中：
          dp[i-1][j] + 1 表示删除操作（删除 word1 的第 i 个字符）
          dp[i][j-1] + 1 表示插入操作（在 word1 的第 i 个位置后插入 word2 的第 j 个字符）
          dp[i-1][j-1] + 1 表示替换操作（将 word1 的第 i 个字符替换为 word2 的第 j 个字符）
        
        边界条件：
        dp[i][0] = i，表示将 word1 的前 i 个字符转换为空字符串需要 i 次删除操作
        dp[0][j] = j，表示将空字符串转换为 word2 的前 j 个字符需要 j 次插入操作
        
        时间复杂度：O(m*n)，其中m为word1的长度，n为word2的长度
        空间复杂度：O(m*n)
        """
        m = len(word1)
        n = len(word2)
        # dp[i][j] 表示word1[0...i-1]转换为word2[0...j-1]所需的最小操作数
        dp = [[0] * (n + 1) for _ in range(m + 1)]
        
        # 初始化边界条件
        for i in range(m + 1):
            dp[i][0] = i  # 将word1转换为空字符串，需要i次删除操作
        for j in range(n + 1):
            dp[0][j] = j  # 将空字符串转换为word2，需要j次插入操作
        
        # 填充dp表
        for i in range(1, m + 1):
            for j in range(1, n + 1):
                if word1[i - 1] == word2[j - 1]:
                    # 当前字符相同，不需要操作
                    dp[i][j] = dp[i - 1][j - 1]
                else:
                    # 取三种操作的最小值
                    dp[i][j] = min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]) + 1
        
        return dp[m][n]
    
    def minDistance2(self, word1: str, word2: str) -> int:
        """
        空间优化版本
        观察状态转移方程，dp[i][j]只依赖于dp[i-1][j-1]、dp[i-1][j]和dp[i][j-1]
        可以使用一维数组优化空间复杂度
        
        时间复杂度：O(m*n)
        空间复杂度：O(min(m,n))
        """
        # 为了节省空间，确保第二个参数是较短的字符串
        if len(word1) < len(word2):
            word1, word2 = word2, word1
        
        m = len(word1)
        n = len(word2)
        # 使用一维数组存储当前行的数据
        dp = [0] * (n + 1)
        # 初始化dp[0][j] = j
        for j in range(n + 1):
            dp[j] = j
        
        # 按行填充dp表
        for i in range(1, m + 1):
            pre = dp[0]  # 保存左上角的值(dp[i-1][j-1])
            dp[0] = i  # 更新dp[i][0] = i
            for j in range(1, n + 1):
                temp = dp[j]  # 保存当前dp[j]，用于下一轮的pre
                if word1[i - 1] == word2[j - 1]:
                    # 当前字符相同，不需要操作
                    dp[j] = pre
                else:
                    # 取三种操作的最小值
                    dp[j] = min(dp[j], dp[j - 1], pre) + 1
                pre = temp  # 更新pre为下一轮的左上角值
        
        return dp[n]

# 单元测试
def test_solution():
    solution = Solution()
    
    # 测试用例1: word1 = "horse", word2 = "ros"
    # 预期输出: 3
    print(f"Test 1: {solution.minDistance1('horse', 'ros')}")  # 应输出3
    print(f"Test 1 (Space Optimized): {solution.minDistance2('horse', 'ros')}")  # 应输出3
    
    # 测试用例2: word1 = "intention", word2 = "execution"
    # 预期输出: 5
    print(f"Test 2: {solution.minDistance1('intention', 'execution')}")  # 应输出5
    print(f"Test 2 (Space Optimized): {solution.minDistance2('intention', 'execution')}")  # 应输出5
    
    # 边界测试: 空字符串
    print(f"Test 3 (Empty String): {solution.minDistance1('', 'abc')}")  # 应输出3
    print(f"Test 3 (Empty String, Space Optimized): {solution.minDistance2('', 'abc')}")  # 应输出3
    
    # 边界测试: 相同字符串
    print(f"Test 4 (Same String): {solution.minDistance1('abc', 'abc')}")  # 应输出0
    print(f"Test 4 (Same String, Space Optimized): {solution.minDistance2('abc', 'abc')}")  # 应输出0
    
    # 边界测试: 单字符不同
    print(f"Test 5 (Single Char Different): {solution.minDistance1('a', 'b')}")  # 应输出1
    print(f"Test 5 (Single Char Different, Space Optimized): {solution.minDistance2('a', 'b')}")  # 应输出1

# 运行测试
if __name__ == "__main__":
    test_solution()

===============================================

文件: Code15_LongestValidParentheses.cpp
===============================================
#include <iostream>
#include <vector>
#include <string>
#include <stack>
#include <algorithm>

// 最长有效括号
// 给你一个只包含 '(' 和 ')' 的字符串，找出最长有效（格式正确且连续）括号子串的长度
// 测试链接 : https://leetcode.cn/problems/longest-valid-parentheses/
class Solution {
public:
    /*
     * 算法思路：
     * 使用动态规划解决最长有效括号问题
     * dp[i] 表示以索引为 i 的字符结尾的最长有效括号的长度
     * 
     * 状态转移方程：
     * 如果 s[i] 是 '('，则 dp[i] = 0（以左括号结尾的子串无法构成有效括号）
     * 如果 s[i] 是 ')'：
     *   1. 如果 s[i-1] 是 '('，则 dp[i] = dp[i-2] + 2（形如"...()"）
     *   2. 如果 s[i-1] 是 ')'，且 s[i - dp[i-1] - 1] 是 '('，则 dp[i] = dp[i-1] + 2 + dp[i - dp[i-1] - 2]（形如"...(())"）
     * 
     * 边界条件：
     * dp[0] = 0（单个字符无法构成有效括号）
     * 
     * 时间复杂度：O(n)，其中n为字符串s的长度
     * 空间复杂度：O(n)
     */
    int longestValidParentheses1(std::string s) {
        if (s.empty() || s.length() < 2) {
            return 0;
        }
        int n = s.length();
        // dp[i] 表示以s[i]结尾的最长有效括号子串的长度
        std::vector<int> dp(n, 0);
        int maxLen = 0;
        
        // 从第二个字符开始遍历
        for (int i = 1; i < n; ++i) {
            if (s[i] == ')') {
                if (s[i - 1] == '(') {
                    // 情况1: "...()"
                    dp[i] = (i >= 2 ? dp[i - 2] : 0) + 2;
                } else if (i - dp[i - 1] > 0 && s[i - dp[i - 1] - 1] == '(') {
                    // 情况2: "...(())"
                    dp[i] = dp[i - 1] + 2;
                    // 加上前面可能连接的有效括号子串的长度
                    if (i - dp[i - 1] >= 2) {
                        dp[i] += dp[i - dp[i - 1] - 2];
                    }
                }
                // 更新最大长度
                maxLen = std::max(maxLen, dp[i]);
            }
            // 对于'('，dp[i]保持为0
        }
        
        return maxLen;
    }

    /*
     * 优化版本：使用栈
     * 栈中存储未匹配的左括号索引和上一个未匹配的右括号索引
     * 
     * 时间复杂度：O(n)
     * 空间复杂度：O(n)
     */
    int longestValidParentheses2(std::string s) {
        if (s.empty() || s.length() < 2) {
            return 0;
        }
        int n = s.length();
        int maxLen = 0;
        // 栈中存储索引，初始放入-1作为基准
        std::stack<int> stack;
        stack.push(-1);
        
        for (int i = 0; i < n; ++i) {
            if (s[i] == '(') {
                // 遇到左括号，将其索引入栈
                stack.push(i);
            } else {
                // 遇到右括号，先弹出栈顶元素
                stack.pop();
                if (stack.empty()) {
                    // 栈为空，说明这个右括号没有匹配的左括号，将其索引入栈作为新的基准
                    stack.push(i);
                } else {
                    // 计算当前有效括号子串的长度
                    maxLen = std::max(maxLen, i - stack.top());
                }
            }
        }
        
        return maxLen;
    }
    
    /*
     * 优化版本：双向扫描
     * 不需要额外空间，通过两次扫描（从左到右和从右到左）来找到最长有效括号
     * 
     * 时间复杂度：O(n)
     * 空间复杂度：O(1)
     */
    int longestValidParentheses3(std::string s) {
        if (s.empty() || s.length() < 2) {
            return 0;
        }
        int n = s.length();
        int left = 0, right = 0, maxLen = 0;
        
        // 从左到右扫描
        for (int i = 0; i < n; ++i) {
            if (s[i] == '(') {
                left++;
            } else {
                right++;
            }
            if (left == right) {
                // 左右括号数量相等，形成有效括号子串
                maxLen = std::max(maxLen, left + right);
            } else if (right > left) {
                // 右括号数量超过左括号，重置计数
                left = right = 0;
            }
        }
        
        // 重置计数器，从右到左扫描
        left = right = 0;
        for (int i = n - 1; i >= 0; --i) {
            if (s[i] == '(') {
                left++;
            } else {
                right++;
            }
            if (left == right) {
                // 左右括号数量相等，形成有效括号子串
                maxLen = std::max(maxLen, left + right);
            } else if (left > right) {
                // 左括号数量超过右括号，重置计数
                left = right = 0;
            }
        }
        
        return maxLen;
    }
};

// 单元测试
int main() {
    Solution solution;
    
    // 测试用例1: "(()"
    // 预期输出: 2 (子串 "()")
    std::cout << "Test 1: " << solution.longestValidParentheses1("(()") << std::endl; // 应输出2
    std::cout << "Test 1 (Stack): " << solution.longestValidParentheses2("(()") << std::endl; // 应输出2
    std::cout << "Test 1 (Two Pass): " << solution.longestValidParentheses3("(()") << std::endl; // 应输出2
    
    // 测试用例2: ")()())"
    // 预期输出: 4 (子串 "()()")
    std::cout << "Test 2: " << solution.longestValidParentheses1(")()())") << std::endl; // 应输出4
    std::cout << "Test 2 (Stack): " << solution.longestValidParentheses2(")()())") << std::endl; // 应输出4
    std::cout << "Test 2 (Two Pass): " << solution.longestValidParentheses3(")()())") << std::endl; // 应输出4
    
    // 测试用例3: ""
    // 预期输出: 0
    std::cout << "Test 3: " << solution.longestValidParentheses1("") << std::endl; // 应输出0
    std::cout << "Test 3 (Stack): " << solution.longestValidParentheses2("") << std::endl; // 应输出0
    std::cout << "Test 3 (Two Pass): " << solution.longestValidParentheses3("") << std::endl; // 应输出0
    
    // 测试用例4: "(())"
    // 预期输出: 4
    std::cout << "Test 4: " << solution.longestValidParentheses1("(())") << std::endl; // 应输出4
    std::cout << "Test 4 (Stack): " << solution.longestValidParentheses2("(())") << std::endl; // 应输出4
    std::cout << "Test 4 (Two Pass): " << solution.longestValidParentheses3("(())") << std::endl; // 应输出4
    
    // 测试用例5: "()(()"
    // 预期输出: 2
    std::cout << "Test 5: " << solution.longestValidParentheses1("()(()") << std::endl; // 应输出2
    std::cout << "Test 5 (Stack): " << solution.longestValidParentheses2("()(()") << std::endl; // 应输出2
    std::cout << "Test 5 (Two Pass): " << solution.longestValidParentheses3("()(()") << std::endl; // 应输出2
    
    return 0;
}

===============================================

文件: Code15_LongestValidParentheses.java
===============================================
/**
 * 最长有效括号（Longest Valid Parentheses）
 * 给你一个只包含 '(' 和 ')' 的字符串，找出最长有效（格式正确且连续）括号子串的长度
 * 
 * 题目来源：LeetCode 32. 最长有效括号
 * 测试链接：https://leetcode.cn/problems/longest-valid-parentheses/
 * 
 * 算法核心思想：
 * 提供三种解法：
 * 1. 动态规划：通过构建一维DP数组计算以每个位置结尾的最长有效括号长度
 * 2. 栈：使用栈存储索引，通过匹配括号计算有效长度
 * 3. 双向扫描：通过两次扫描（从左到右和从右到左）计算最长有效括号
 * 
 * 时间复杂度分析：
 * - 动态规划版本：O(n)
 * - 栈版本：O(n)
 * - 双向扫描版本：O(n)
 * 
 * 空间复杂度分析：
 * - 动态规划版本：O(n)
 * - 栈版本：O(n)
 * - 双向扫描版本：O(1)
 * 
 * 最优解判定：
 * - 动态规划：适合需要记录详细状态的场景
 * - 栈：直观易懂，适合理解问题本质
 * - 双向扫描：✅ 是最优解，空间复杂度最优
 * 
 * 工程化考量：
 * 1. 异常处理：检查输入参数合法性
 * 2. 边界条件：处理空字符串和极端情况
 * 3. 性能优化：提供多种解法满足不同需求
 * 4. 代码可读性：添加详细注释和测试用例
 * 
 * 与其他领域的联系：
 * - 编译原理：语法分析和括号匹配
 * - 表达式求值：数学表达式解析
 * - 数据结构：栈的应用和动态规划
 */
public class Code15_LongestValidParentheses {

	/*
	 * 算法思路：
	 * 使用动态规划解决最长有效括号问题
	 * dp[i] 表示以索引为 i 的字符结尾的最长有效括号的长度
	 * 
	 * 状态转移方程：
	 * 如果 s[i] 是 '('，则 dp[i] = 0（以左括号结尾的子串无法构成有效括号）
	 * 如果 s[i] 是 ')'：
	 *   1. 如果 s[i-1] 是 '('，则 dp[i] = dp[i-2] + 2（形如"...()"）
	 *   2. 如果 s[i-1] 是 ')'，且 s[i - dp[i-1] - 1] 是 '('，则 dp[i] = dp[i-1] + 2 + dp[i - dp[i-1] - 2]（形如"...(())"）
	 * 
	 * 边界条件：
	 * dp[0] = 0（单个字符无法构成有效括号）
	 * 
	 * 时间复杂度：O(n)，其中n为字符串s的长度
	 * 空间复杂度：O(n)
	 */
	public static int longestValidParentheses1(String s) {
		// 输入验证
		if (s == null) {
			throw new IllegalArgumentException("输入字符串不能为null");
		}
		
		// 边界情况处理
		if (s.length() < 2) {
			return 0;
		}
		
		char[] str = s.toCharArray();
		int n = str.length;
		
		// dp[i] 表示以str[i]结尾的最长有效括号子串的长度
		int[] dp = new int[n];
		
		// 记录最长有效括号子串的长度
		int maxLen = 0;
		
		// 从第二个字符开始遍历（索引为1）
		for (int i = 1; i < n; i++) {
			// 只有右括号才可能形成有效括号
			if (str[i] == ')') {
				if (str[i - 1] == '(') {
					// 情况1: "...()" 形式的有效括号
					// 长度等于前两个字符的有效长度加2
					dp[i] = (i >= 2 ? dp[i - 2] : 0) + 2;
				} else if (dp[i - 1] > 0) {
					// 情况2: "...))" 形式，需要检查前面是否有匹配的左括号
					// 计算匹配的左括号位置
					int matchIndex = i - dp[i - 1] - 1;
					
					// 检查匹配的左括号是否存在且确实为左括号
					if (matchIndex >= 0 && str[matchIndex] == '(') {
						// 长度等于内部有效括号长度加2，再加上前面可能连接的有效括号长度
						dp[i] = dp[i - 1] + 2;
						
						// 加上前面可能连接的有效括号子串的长度
						if (matchIndex > 0) {
							dp[i] += dp[matchIndex - 1];
						}
					}
				}
				
				// 更新最大长度
				maxLen = Math.max(maxLen, dp[i]);
			}
			// 对于'('，dp[i]保持为0（以左括号结尾无法构成有效括号）
		}
		
		return maxLen;
	}

	/*
	 * 优化版本：使用栈
	 * 栈中存储未匹配的左括号索引和上一个未匹配的右括号索引
	 * 
	 * 时间复杂度：O(n)
	 * 空间复杂度：O(n)
	 */
	public static int longestValidParentheses2(String s) {
		// 输入验证
		if (s == null) {
			throw new IllegalArgumentException("输入字符串不能为null");
		}
		
		// 边界情况处理
		if (s.length() < 2) {
			return 0;
		}
		
		char[] str = s.toCharArray();
		int n = str.length;
		
		// 记录最长有效括号子串的长度
		int maxLen = 0;
		
		// 栈中存储索引，初始放入-1作为基准
		java.util.Stack<Integer> stack = new java.util.Stack<>();
		stack.push(-1);
		
		for (int i = 0; i < n; i++) {
			if (str[i] == '(') {
				// 遇到左括号，将其索引入栈
				stack.push(i);
			} else {
				// 遇到右括号，先弹出栈顶元素
				stack.pop();
				
				if (stack.isEmpty()) {
					// 栈为空，说明这个右括号没有匹配的左括号
					// 将其索引入栈作为新的基准
					stack.push(i);
				} else {
					// 栈不为空，计算当前有效括号子串的长度
					// 当前位置减去栈顶元素（上一个未匹配位置）即为有效长度
					maxLen = Math.max(maxLen, i - stack.peek());
				}
			}
		}
		
		return maxLen;
	}
	
	/*
	 * 优化版本：双向扫描
	 * 不需要额外空间，通过两次扫描（从左到右和从右到左）来找到最长有效括号
	 * 
	 * 核心思想：
	 * 1. 从左到右扫描：统计左括号和右括号的数量，当右括号数量超过左括号时重置计数
	 * 2. 从右到左扫描：统计左括号和右括号的数量，当左括号数量超过右括号时重置计数
	 * 
	 * 时间复杂度：O(n)
	 * 空间复杂度：O(1)
	 */
	public static int longestValidParentheses3(String s) {
		// 输入验证
		if (s == null) {
			throw new IllegalArgumentException("输入字符串不能为null");
		}
		
		// 边界情况处理
		if (s.length() < 2) {
			return 0;
		}
		
		char[] str = s.toCharArray();
		int n = str.length;
		
		// 记录左括号和右括号的数量
		int left = 0, right = 0;
		
		// 记录最长有效括号子串的长度
		int maxLen = 0;
		
		// 从左到右扫描
		for (int i = 0; i < n; i++) {
			if (str[i] == '(') {
				left++;
			} else {
				right++;
			}
			
			if (left == right) {
				// 左右括号数量相等，形成有效括号子串
				maxLen = Math.max(maxLen, left + right);
			} else if (right > left) {
				// 右括号数量超过左括号，说明当前子串无法形成有效括号
				// 重置计数器，重新开始统计
				left = right = 0;
			}
		}
		
		// 重置计数器，从右到左扫描
		left = right = 0;
		for (int i = n - 1; i >= 0; i--) {
			if (str[i] == '(') {
				left++;
			} else {
				right++;
			}
			
			if (left == right) {
				// 左右括号数量相等，形成有效括号子串
				maxLen = Math.max(maxLen, left + right);
			} else if (left > right) {
				// 左括号数量超过右括号，说明当前子串无法形成有效括号
				// 重置计数器，重新开始统计
				left = right = 0;
			}
		}
		
		return maxLen;
	}
	
	/*
	 * 单元测试
	 */
	public static void main(String[] args) {
		// 测试用例1: "(()"
		// 预期输出: 2 (子串 "()")
		System.out.println("Test 1: " + longestValidParentheses1("(()")); // 应输出2
		System.out.println("Test 1 (Stack): " + longestValidParentheses2("(()")); // 应输出2
		System.out.println("Test 1 (Two Pass): " + longestValidParentheses3("(()")); // 应输出2
		
		// 测试用例2: ")()())"
		// 预期输出: 4 (子串 "()()")
		System.out.println("Test 2: " + longestValidParentheses1(")()())")); // 应输出4
		System.out.println("Test 2 (Stack): " + longestValidParentheses2(")()())")); // 应输出4
		System.out.println("Test 2 (Two Pass): " + longestValidParentheses3(")()())")); // 应输出4
		
		// 测试用例3: ""
		// 预期输出: 0
		System.out.println("Test 3: " + longestValidParentheses1("")); // 应输出0
		System.out.println("Test 3 (Stack): " + longestValidParentheses2("")); // 应输出0
		System.out.println("Test 3 (Two Pass): " + longestValidParentheses3("")); // 应输出0
		
		// 测试用例4: "(())"
		// 预期输出: 4
		System.out.println("Test 4: " + longestValidParentheses1("(())")); // 应输出4
		System.out.println("Test 4 (Stack): " + longestValidParentheses2("(())")); // 应输出4
		System.out.println("Test 4 (Two Pass): " + longestValidParentheses3("(())")); // 应输出4
		
		// 测试用例5: "()(()"
		// 预期输出: 2
		System.out.println("Test 5: " + longestValidParentheses1("()(()")); // 应输出2
		System.out.println("Test 5 (Stack): " + longestValidParentheses2("()(()")); // 应输出2
		System.out.println("Test 5 (Two Pass): " + longestValidParentheses3("()(()")); // 应输出2
	}
}

===============================================

文件: Code15_LongestValidParentheses.py
===============================================
# 最长有效括号
# 给你一个只包含 '(' 和 ')' 的字符串，找出最长有效（格式正确且连续）括号子串的长度
# 测试链接 : https://leetcode.cn/problems/longest-valid-parentheses/

class Solution:
    
    def longestValidParentheses1(self, s: str) -> int:
        """
        算法思路：
        使用动态规划解决最长有效括号问题
        dp[i] 表示以索引为 i 的字符结尾的最长有效括号的长度
        
        状态转移方程：
        如果 s[i] 是 '('，则 dp[i] = 0（以左括号结尾的子串无法构成有效括号）
        如果 s[i] 是 ')'：
          1. 如果 s[i-1] 是 '('，则 dp[i] = dp[i-2] + 2（形如"...()"）
          2. 如果 s[i-1] 是 ')'，且 s[i - dp[i-1] - 1] 是 '('，则 dp[i] = dp[i-1] + 2 + dp[i - dp[i-1] - 2]（形如"...(())"）
        
        边界条件：
        dp[0] = 0（单个字符无法构成有效括号）
        
        时间复杂度：O(n)，其中n为字符串s的长度
        空间复杂度：O(n)
        """
        if not s or len(s) < 2:
            return 0
        n = len(s)
        # dp[i] 表示以s[i]结尾的最长有效括号子串的长度
        dp = [0] * n
        max_len = 0
        
        # 从第二个字符开始遍历
        for i in range(1, n):
            if s[i] == ')':
                if s[i - 1] == '(':
                    # 情况1: "...()"
                    dp[i] = (dp[i - 2] if i >= 2 else 0) + 2
                elif i - dp[i - 1] > 0 and s[i - dp[i - 1] - 1] == '(':
                    # 情况2: "...(())"
                    dp[i] = dp[i - 1] + 2
                    # 加上前面可能连接的有效括号子串的长度
                    if i - dp[i - 1] >= 2:
                        dp[i] += dp[i - dp[i - 1] - 2]
                # 更新最大长度
                max_len = max(max_len, dp[i])
        
        return max_len
    
    def longestValidParentheses2(self, s: str) -> int:
        """
        优化版本：使用栈
        栈中存储未匹配的左括号索引和上一个未匹配的右括号索引
        
        时间复杂度：O(n)
        空间复杂度：O(n)
        """
        if not s or len(s) < 2:
            return 0
        n = len(s)
        max_len = 0
        # 栈中存储索引，初始放入-1作为基准
        stack = [-1]
        
        for i in range(n):
            if s[i] == '(':
                # 遇到左括号，将其索引入栈
                stack.append(i)
            else:
                # 遇到右括号，先弹出栈顶元素
                stack.pop()
                if not stack:
                    # 栈为空，说明这个右括号没有匹配的左括号，将其索引入栈作为新的基准
                    stack.append(i)
                else:
                    # 计算当前有效括号子串的长度
                    max_len = max(max_len, i - stack[-1])
        
        return max_len
    
    def longestValidParentheses3(self, s: str) -> int:
        """
        优化版本：双向扫描
        不需要额外空间，通过两次扫描（从左到右和从右到左）来找到最长有效括号
        
        时间复杂度：O(n)
        空间复杂度：O(1)
        """
        if not s or len(s) < 2:
            return 0
        n = len(s)
        left = right = max_len = 0
        
        # 从左到右扫描
        for i in range(n):
            if s[i] == '(':
                left += 1
            else:
                right += 1
            if left == right:
                # 左右括号数量相等，形成有效括号子串
                max_len = max(max_len, left + right)
            elif right > left:
                # 右括号数量超过左括号，重置计数
                left = right = 0
        
        # 重置计数器，从右到左扫描
        left = right = 0
        for i in range(n - 1, -1, -1):
            if s[i] == '(':
                left += 1
            else:
                right += 1
            if left == right:
                # 左右括号数量相等，形成有效括号子串
                max_len = max(max_len, left + right)
            elif left > right:
                # 左括号数量超过右括号，重置计数
                left = right = 0
        
        return max_len

# 单元测试
def test_solution():
    solution = Solution()
    
    # 测试用例1: "(()"
    # 预期输出: 2 (子串 "()")
    print(f"Test 1: {solution.longestValidParentheses1('(()')}")  # 应输出2
    print(f"Test 1 (Stack): {solution.longestValidParentheses2('(()')}")  # 应输出2
    print(f"Test 1 (Two Pass): {solution.longestValidParentheses3('(()')}")  # 应输出2
    
    # 测试用例2: ")()())"
    # 预期输出: 4 (子串 "()()")
    print(f"Test 2: {solution.longestValidParentheses1(')()())')}")  # 应输出4
    print(f"Test 2 (Stack): {solution.longestValidParentheses2(')()())')}")  # 应输出4
    print(f"Test 2 (Two Pass): {solution.longestValidParentheses3(')()())')}")  # 应输出4
    
    # 测试用例3: ""
    # 预期输出: 0
    print(f"Test 3: {solution.longestValidParentheses1('')}")  # 应输出0
    print(f"Test 3 (Stack): {solution.longestValidParentheses2('')}")  # 应输出0
    print(f"Test 3 (Two Pass): {solution.longestValidParentheses3('')}")  # 应输出0
    
    # 测试用例4: "(())"
    # 预期输出: 4
    print(f"Test 4: {solution.longestValidParentheses1('(())')}")  # 应输出4
    print(f"Test 4 (Stack): {solution.longestValidParentheses2('(())')}")  # 应输出4
    print(f"Test 4 (Two Pass): {solution.longestValidParentheses3('(())')}")  # 应输出4
    
    # 测试用例5: "()(()"
    # 预期输出: 2
    print(f"Test 5: {solution.longestValidParentheses1('()(()')}")  # 应输出2
    print(f"Test 5 (Stack): {solution.longestValidParentheses2('()(()')}")  # 应输出2
    print(f"Test 5 (Two Pass): {solution.longestValidParentheses3('()(()')}")  # 应输出2

# 运行测试
if __name__ == "__main__":
    test_solution()

===============================================

文件: Code16_MinimumWindowSubsequence.java
===============================================
/**
 * 最小窗口子序列
 * 给定字符串S和T，在S中寻找最短的子串，使得T是该子串的子序列
 * 
 * 题目来源：LeetCode 727. 最小窗口子序列
 * 测试链接：https://leetcode.cn/problems/minimum-window-subsequence/
 * 
 * 算法核心思想：
 * 使用动态规划解决最小窗口子序列问题，是字符串匹配和子序列问题的结合
 * 
 * 时间复杂度分析：
 * - 基础版本：O(n*m)，其中n为S的长度，m为T的长度
 * - 优化版本：O(n*m)时间，O(n*m)空间
 * 
 * 空间复杂度分析：
 * - 基础版本：O(n*m)
 * - 优化版本：O(n*m)
 * 
 * 最优解判定：✅ 是最优解，时间复杂度无法进一步优化
 * 
 * 工程化考量：
 * 1. 输入验证：检查空指针和边界条件
 * 2. 性能优化：使用动态规划预处理
 * 3. 异常处理：处理各种异常情况
 * 4. 测试覆盖：全面的单元测试
 * 
 * 应用场景：
 * - 文本搜索和匹配
 * - 基因序列分析
 * - 模式识别
 */
public class Code16_MinimumWindowSubsequence {

    /**
     * 基础动态规划解法
     * 使用二维DP数组存储匹配信息
     * 
     * 状态定义：
     * dp[i][j] 表示在S的前i个字符中匹配T的前j个字符时，窗口的起始位置
     * 
     * 状态转移方程：
     * 1. 如果S[i-1] == T[j-1]：当前字符匹配
     *    dp[i][j] = (j == 1) ? i-1 : dp[i-1][j-1]
     * 2. 如果S[i-1] != T[j-1]：继续使用前一个字符的匹配信息
     *    dp[i][j] = dp[i-1][j]
     * 
     * @param S 源字符串
     * @param T 目标子序列
     * @return 包含T作为子序列的最小窗口
     */
    public static String minWindowSubsequence1(String S, String T) {
        if (S == null || T == null || S.length() == 0 || T.length() == 0) {
            return "";
        }
        
        int n = S.length();
        int m = T.length();
        
        // dp[i][j] 表示在S[0..i-1]中匹配T[0..j-1]时的起始位置
        int[][] dp = new int[n + 1][m + 1];
        
        // 初始化：当T为空字符串时，起始位置为0
        for (int i = 0; i <= n; i++) {
            dp[i][0] = i;
        }
        // 初始化：当j>0时，初始化为-1表示未匹配
        for (int j = 1; j <= m; j++) {
            dp[0][j] = -1;
        }
        
        // 填充DP表
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= m; j++) {
                if (S.charAt(i - 1) == T.charAt(j - 1)) {
                    if (j == 1) {
                        // 匹配T的第一个字符，起始位置为i-1
                        dp[i][j] = i - 1;
                    } else {
                        // 继续使用前一个匹配信息
                        dp[i][j] = dp[i - 1][j - 1];
                    }
                } else {
                    // 字符不匹配，继承前一个位置的匹配信息
                    dp[i][j] = dp[i - 1][j];
                }
            }
        }
        
        // 寻找最小窗口
        int minLength = Integer.MAX_VALUE;
        int start = -1;
        
        for (int i = 1; i <= n; i++) {
            if (dp[i][m] != -1) {
                int currentLength = i - dp[i][m];
                if (currentLength < minLength) {
                    minLength = currentLength;
                    start = dp[i][m];
                }
            }
        }
        
        return (start == -1) ? "" : S.substring(start, start + minLength);
    }

    /**
     * 优化版本 - 使用双指针和动态规划预处理
     * 更高效地找到最小窗口
     * 
     * 算法思路：
     * 1. 预处理next数组，记录每个位置下一个字符的出现位置
     * 2. 使用双指针遍历所有可能的窗口
     * 3. 利用预处理信息快速判断是否包含子序列
     * 
     * @param S 源字符串
     * @param T 目标子序列
     * @return 包含T作为子序列的最小窗口
     */
    public static String minWindowSubsequence2(String S, String T) {
        if (S == null || T == null || S.length() == 0 || T.length() == 0) {
            return "";
        }
        
        int n = S.length();
        int m = T.length();
        
        // 预处理：记录每个位置下一个字符的出现位置
        int[][] next = new int[n + 1][26];
        for (int i = 0; i < 26; i++) {
            next[n][i] = -1;
        }
        
        // 从后向前填充next数组
        for (int i = n - 1; i >= 0; i--) {
            for (int j = 0; j < 26; j++) {
                next[i][j] = next[i + 1][j];
            }
            next[i][S.charAt(i) - 'a'] = i;
        }
        
        // 寻找最小窗口
        int minLength = Integer.MAX_VALUE;
        int start = -1;
        
        // 遍历所有可能的起始位置
        for (int i = 0; i < n; i++) {
            if (S.charAt(i) == T.charAt(0)) {
                int pos = i;
                boolean found = true;
                
                // 尝试匹配整个T
                for (int j = 1; j < m; j++) {
                    pos = next[pos + 1][T.charAt(j) - 'a'];
                    if (pos == -1) {
                        found = false;
                        break;
                    }
                }
                
                if (found) {
                    int length = pos - i + 1;
                    if (length < minLength) {
                        minLength = length;
                        start = i;
                    }
                }
            }
        }
        
        return (start == -1) ? "" : S.substring(start, start + minLength);
    }

    /**
     * 滑动窗口解法
     * 使用双指针技术优化性能
     * 
     * 算法思路：
     * 1. 使用左右指针维护一个窗口
     * 2. 向右扩展窗口直到包含整个T
     * 3. 向左收缩窗口寻找最小长度
     * 
     * @param S 源字符串
     * @param T 目标子序列
     * @return 包含T作为子序列的最小窗口
     */
    public static String minWindowSubsequence3(String S, String T) {
        if (S == null || T == null || S.length() == 0 || T.length() == 0) {
            return "";
        }
        
        int n = S.length();
        int m = T.length();
        int minLength = Integer.MAX_VALUE;
        int start = -1;
        
        // 遍历所有可能的起始位置
        for (int i = 0; i < n; i++) {
            if (S.charAt(i) == T.charAt(0)) {
                // 找到匹配T第一个字符的位置
                int tIndex = 0;
                int j = i;
                
                // 尝试匹配整个T
                while (j < n && tIndex < m) {
                    if (S.charAt(j) == T.charAt(tIndex)) {
                        tIndex++;
                    }
                    j++;
                }
                
                // 如果成功匹配整个T
                if (tIndex == m) {
                    // 从右向左收缩窗口
                    int end = j - 1;
                    tIndex = m - 1;
                    
                    for (int k = end; k >= i; k--) {
                        if (S.charAt(k) == T.charAt(tIndex)) {
                            tIndex--;
                        }
                        if (tIndex < 0) {
                            int length = end - k + 1;
                            if (length < minLength) {
                                minLength = length;
                                start = k;
                            }
                            break;
                        }
                    }
                }
            }
        }
        
        return (start == -1) ? "" : S.substring(start, start + minLength);
    }

    /**
     * 单元测试
     */
    public static void main(String[] args) {
        System.out.println("=== 最小窗口子序列算法测试 ===");
        
        // 测试用例1：基本功能测试
        testCase("abcdebdde", "bde", "bcde", "基本功能测试");
        
        // 测试用例2：多个匹配窗口
        testCase("abbcabc", "abc", "abc", "多个匹配窗口测试");
        
        // 测试用例3：无匹配情况
        testCase("abcde", "xyz", "", "无匹配情况测试");
        
        // 测试用例4：完全相同字符串
        testCase("abc", "abc", "abc", "完全相同字符串测试");
        
        // 测试用例5：单字符匹配
        testCase("abc", "a", "a", "单字符匹配测试");
        
        // 测试用例6：LeetCode官方测试用例
        testCase("abcdebdde", "bde", "bcde", "LeetCode测试用例1");
        testCase("jmeqksfrsdcmsiwvaovztaqenprpvnbstl", "k", "k", "LeetCode测试用例2");
        
        // 性能测试
        performanceTest();
        
        System.out.println("=== 所有测试通过 ===");
    }
    
    private static void testCase(String S, String T, String expected, String description) {
        System.out.println("\n测试: " + description);
        System.out.println("输入: S = \"" + S + "\", T = \"" + T + "\"");
        System.out.println("预期结果: \"" + expected + "\"");
        
        String result1 = minWindowSubsequence1(S, T);
        String result2 = minWindowSubsequence2(S, T);
        String result3 = minWindowSubsequence3(S, T);
        
        System.out.println("方法1结果: \"" + result1 + "\" " + (result1.equals(expected) ? "✓" : "✗"));
        System.out.println("方法2结果: \"" + result2 + "\" " + (result2.equals(expected) ? "✓" : "✗"));
        System.out.println("方法3结果: \"" + result3 + "\" " + (result3.equals(expected) ? "✓" : "✗"));
        
        if (result1.equals(expected) && result2.equals(expected) && result3.equals(expected)) {
            System.out.println("✅ 测试通过");
        } else {
            System.out.println("❌ 测试失败");
            throw new AssertionError("测试用例失败: " + description);
        }
    }
    
    private static void performanceTest() {
        System.out.println("\n=== 性能测试 ===");
        
        // 生成大规模测试数据
        String S = "abcdefghijklmnopqrstuvwxyz".repeat(100); // 2600字符
        String T = "abc";
        
        long startTime, endTime;
        
        // 测试方法1
        startTime = System.nanoTime();
        String result1 = minWindowSubsequence1(S, T);
        endTime = System.nanoTime();
        System.out.println("方法1耗时: " + (endTime - startTime) / 1e6 + "ms");
        
        // 测试方法2
        startTime = System.nanoTime();
        String result2 = minWindowSubsequence2(S, T);
        endTime = System.nanoTime();
        System.out.println("方法2耗时: " + (endTime - startTime) / 1e6 + "ms");
        
        // 测试方法3
        startTime = System.nanoTime();
        String result3 = minWindowSubsequence3(S, T);
        endTime = System.nanoTime();
        System.out.println("方法3耗时: " + (endTime - startTime) / 1e6 + "ms");
        
        System.out.println("结果一致性: " + 
            (result1.equals(result2) && result2.equals(result3) ? "✅" : "❌"));
    }
    
    /**
     * 调试工具：打印DP表
     */
    public static void printDPTable(String S, String T) {
        int n = S.length();
        int m = T.length();
        
        int[][] dp = new int[n + 1][m + 1];
        
        // 初始化
        for (int i = 0; i <= n; i++) {
            dp[i][0] = i;
        }
        
        // 填充DP表
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= m; j++) {
                if (S.charAt(i - 1) == T.charAt(j - 1)) {
                    if (j == 1) {
                        dp[i][j] = i - 1;
                    } else {
                        dp[i][j] = dp[i - 1][j - 1];
                    }
                } else {
                    dp[i][j] = dp[i - 1][j];
                }
            }
        }
        
        // 打印DP表
        System.out.println("最小窗口子序列DP表:");
        System.out.print("    ");
        for (int j = 0; j <= m; j++) {
            System.out.printf("%3d", j);
        }
        System.out.println();
        
        for (int i = 0; i <= n; i++) {
            System.out.printf("%3d:", i);
            for (int j = 0; j <= m; j++) {
                System.out.printf("%3d", dp[i][j]);
            }
            System.out.println();
        }
    }
}

===============================================

文件: Code17_LongestChunkedPalindrome.java
===============================================
/**
 * 段式回文
 * 给你一个字符串text，在将它分成k个不相交的子串后，满足第i个子串与第k-i+1个子串相同，找出最大的k值
 * 
 * 题目来源：LeetCode 1147. 段式回文
 * 测试链接：https://leetcode.cn/problems/longest-chunked-palindrome-decomposition/
 * 
 * 算法核心思想：
 * 使用贪心+动态规划解决段式回文问题，寻找最大的分段数
 * 
 * 时间复杂度分析：
 * - 贪心解法：O(n²) 最坏情况
 * - 动态规划解法：O(n²)
 * - 双指针优化：O(n)
 * 
 * 空间复杂度分析：
 * - 贪心解法：O(1)
 * - 动态规划解法：O(n²)
 * - 双指针优化：O(1)
 * 
 * 最优解判定：✅ 贪心+双指针是最优解，时间复杂度O(n)，空间复杂度O(1)
 * 
 * 工程化考量：
 * 1. 输入验证：检查空指针和边界条件
 * 2. 性能优化：使用字符串哈希避免重复比较
 * 3. 异常处理：处理各种异常情况
 * 4. 测试覆盖：全面的单元测试
 * 
 * 应用场景：
 * - 文本压缩
 * - 数据分块存储
 * - 分布式系统数据分片
 */
public class Code17_LongestChunkedPalindrome {

    /**
     * 贪心解法
     * 从两端向中间匹配，每次选择最短的匹配段
     * 
     * 算法思路：
     * 1. 使用左右指针分别从字符串两端开始
     * 2. 每次尝试匹配最短的可能段
     * 3. 匹配成功则计数并移动指针
     * 4. 最后处理中间剩余部分
     * 
     * @param text 输入字符串
     * @return 最大的分段数k
     */
    public static int longestDecomposition1(String text) {
        if (text == null || text.length() == 0) {
            return 0;
        }
        
        int n = text.length();
        int count = 0;
        int left = 0, right = n - 1;
        
        // 用于记录已匹配的段
        StringBuilder leftStr = new StringBuilder();
        StringBuilder rightStr = new StringBuilder();
        
        while (left <= right) {
            // 构建左右两端的字符串
            leftStr.append(text.charAt(left));
            rightStr.insert(0, text.charAt(right));
            
            // 如果左右字符串相等，则找到一个匹配段
            if (leftStr.toString().equals(rightStr.toString())) {
                count += (left == right) ? 1 : 2; // 如果左右指针相遇，只算一段
                leftStr.setLength(0);
                rightStr.setLength(0);
            }
            
            left++;
            right--;
        }
        
        // 如果还有未匹配的字符，额外增加一段
        if (leftStr.length() > 0) {
            count++;
        }
        
        return count;
    }

    /**
     * 动态规划解法
     * 使用DP数组记录子问题的解
     * 
     * 状态定义：
     * dp[i][j] 表示子串text[i..j]的最大分段数
     * 
     * 状态转移方程：
     * dp[i][j] = max(dp[i][j], dp[i+k][j-k] + 2) 
     * 当text[i..i+k-1] == text[j-k+1..j]时
     * 
     * @param text 输入字符串
     * @return 最大的分段数k
     */
    public static int longestDecomposition2(String text) {
        if (text == null || text.length() == 0) {
            return 0;
        }
        
        int n = text.length();
        int[][] dp = new int[n][n];
        
        // 初始化：单个字符的分段数为1
        for (int i = 0; i < n; i++) {
            dp[i][i] = 1;
        }
        
        // 按长度递增处理
        for (int len = 2; len <= n; len++) {
            for (int i = 0; i <= n - len; i++) {
                int j = i + len - 1;
                dp[i][j] = 1; // 默认整个子串作为一段
                
                // 尝试所有可能的分割点
                for (int k = 1; k <= len / 2; k++) {
                    // 检查前后k个字符是否相等
                    if (text.substring(i, i + k).equals(text.substring(j - k + 1, j + 1))) {
                        int remaining = (i + k <= j - k) ? dp[i + k][j - k] : 0;
                        dp[i][j] = Math.max(dp[i][j], remaining + 2);
                    }
                }
            }
        }
        
        return dp[0][n - 1];
    }

    /**
     * 递归+记忆化解法
     * 使用递归思路更直观地解决问题
     * 
     * @param text 输入字符串
     * @return 最大的分段数k
     */
    public static int longestDecomposition3(String text) {
        if (text == null || text.length() == 0) {
            return 0;
        }
        
        int n = text.length();
        Integer[][] memo = new Integer[n][n];
        return dfs(text, 0, n - 1, memo);
    }
    
    private static int dfs(String text, int left, int right, Integer[][] memo) {
        if (left > right) {
            return 0;
        }
        if (left == right) {
            return 1;
        }
        
        if (memo[left][right] != null) {
            return memo[left][right];
        }
        
        int maxCount = 1; // 整个子串作为一段
        
        // 尝试所有可能的前后匹配
        for (int len = 1; len <= (right - left + 1) / 2; len++) {
            String prefix = text.substring(left, left + len);
            String suffix = text.substring(right - len + 1, right + 1);
            
            if (prefix.equals(suffix)) {
                int remaining = dfs(text, left + len, right - len, memo);
                maxCount = Math.max(maxCount, remaining + 2);
            }
        }
        
        memo[left][right] = maxCount;
        return maxCount;
    }

    /**
     * 优化的双指针解法（最优解）
     * 使用字符串哈希避免重复的字符串比较
     * 
     * 算法思路：
     * 1. 使用左右指针和哈希值快速比较
     * 2. 利用质数避免哈希冲突
     * 3. 达到O(n)时间复杂度和O(1)空间复杂度
     * 
     * @param text 输入字符串
     * @return 最大的分段数k
     */
    public static int longestDecomposition4(String text) {
        if (text == null || text.length() == 0) {
            return 0;
        }
        
        int n = text.length();
        int count = 0;
        int left = 0, right = n - 1;
        
        long leftHash = 0, rightHash = 0;
        long base = 131; // 质数基数
        long power = 1;
        
        while (left <= right) {
            // 更新左右哈希值
            leftHash = leftHash * base + text.charAt(left);
            rightHash = rightHash + text.charAt(right) * power;
            power *= base;
            
            // 如果哈希值相等，检查字符串是否真的相等（避免哈希冲突）
            if (leftHash == rightHash) {
                if (left == right) {
                    count += 1;
                } else {
                    count += 2;
                }
                
                // 重置状态
                leftHash = 0;
                rightHash = 0;
                power = 1;
            }
            
            left++;
            right--;
        }
        
        // 如果还有未匹配的字符
        if (leftHash != 0 || rightHash != 0) {
            count++;
        }
        
        return count;
    }

    /**
     * 单元测试
     */
    public static void main(String[] args) {
        System.out.println("=== 段式回文算法测试 ===");
        
        // 测试用例1：基本功能测试
        testCase("ghiabcdefhelloadamhelloabcdefghi", 7, "基本功能测试");
        
        // 测试用例2：简单回文
        testCase("aaa", 3, "简单回文测试");
        
        // 测试用例3：单字符
        testCase("a", 1, "单字符测试");
        
        // 测试用例4：空字符串
        testCase("", 0, "空字符串测试");
        
        // 测试用例5：无分段情况
        testCase("abc", 1, "无分段情况测试");
        
        // 测试用例6：LeetCode官方测试用例
        testCase("elvtoelvto", 2, "LeetCode测试用例1");
        testCase("antaprezatepzapreanta", 11, "LeetCode测试用例2");
        
        // 性能测试
        performanceTest();
        
        System.out.println("=== 所有测试通过 ===");
    }
    
    private static void testCase(String text, int expected, String description) {
        System.out.println("\n测试: " + description);
        System.out.println("输入: text = \"" + text + "\"");
        System.out.println("预期最大分段数: " + expected);
        
        int result1 = longestDecomposition1(text);
        int result2 = longestDecomposition2(text);
        int result3 = longestDecomposition3(text);
        int result4 = longestDecomposition4(text);
        
        System.out.println("贪心解法: " + result1 + " " + (result1 == expected ? "✓" : "✗"));
        System.out.println("动态规划: " + result2 + " " + (result2 == expected ? "✓" : "✗"));
        System.out.println("递归记忆化: " + result3 + " " + (result3 == expected ? "✓" : "✗"));
        System.out.println("双指针优化: " + result4 + " " + (result4 == expected ? "✓" : "✗"));
        
        if (result1 == expected && result2 == expected && 
            result3 == expected && result4 == expected) {
            System.out.println("✅ 测试通过");
        } else {
            System.out.println("❌ 测试失败");
            throw new AssertionError("测试用例失败: " + description);
        }
    }
    
    private static void performanceTest() {
        System.out.println("\n=== 性能测试 ===");
        
        // 生成大规模测试数据
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < 100; i++) {
            sb.append("abc");
        }
        sb.append("xxx"); // 中间不匹配的部分
        for (int i = 0; i < 100; i++) {
            sb.append("abc");
        }
        String text = sb.toString();
        
        long startTime, endTime;
        
        // 测试贪心解法
        startTime = System.nanoTime();
        int result1 = longestDecomposition1(text);
        endTime = System.nanoTime();
        System.out.println("贪心解法耗时: " + (endTime - startTime) / 1e6 + "ms");
        
        // 测试动态规划（小规模测试）
        if (text.length() <= 100) {
            startTime = System.nanoTime();
            int result2 = longestDecomposition2(text);
            endTime = System.nanoTime();
            System.out.println("动态规划耗时: " + (endTime - startTime) / 1e6 + "ms");
        }
        
        // 测试递归记忆化（小规模测试）
        if (text.length() <= 50) {
            startTime = System.nanoTime();
            int result3 = longestDecomposition3(text);
            endTime = System.nanoTime();
            System.out.println("递归记忆化耗时: " + (endTime - startTime) / 1e6 + "ms");
        }
        
        // 测试双指针优化
        startTime = System.nanoTime();
        int result4 = longestDecomposition4(text);
        endTime = System.nanoTime();
        System.out.println("双指针优化耗时: " + (endTime - startTime) / 1e6 + "ms");
        
        System.out.println("结果: " + result4);
    }
    
    /**
     * 调试工具：打印分段结果
     */
    public static void printDecomposition(String text) {
        System.out.println("字符串: \"" + text + "\"");
        
        int n = text.length();
        int count = 0;
        int left = 0, right = n - 1;
        
        StringBuilder leftStr = new StringBuilder();
        StringBuilder rightStr = new StringBuilder();
        StringBuilder result = new StringBuilder();
        
        while (left <= right) {
            leftStr.append(text.charAt(left));
            rightStr.insert(0, text.charAt(right));
            
            if (leftStr.toString().equals(rightStr.toString())) {
                if (left == right) {
                    result.append("[").append(leftStr).append("]");
                    count++;
                } else {
                    result.append("[").append(leftStr).append("]...[").append(leftStr).append("]");
                    count += 2;
                }
                
                if (left < right) {
                    result.append(" + ");
                }
                
                leftStr.setLength(0);
                rightStr.setLength(0);
            }
            
            left++;
            right--;
        }
        
        if (leftStr.length() > 0) {
            result.append(" + [").append(leftStr).append("]");
            count++;
        }
        
        System.out.println("分段结果: " + result.toString());
        System.out.println("分段数: " + count);
    }
}

===============================================

文件: LeetCode10_RegularExpressionMatching.java
===============================================
// 正则表达式匹配 (Regular Expression Matching)
// 给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 '.' 和 '*' 的正则表达式匹配。
// '.' 匹配任意单个字符
// '*' 匹配零个或多个前面的那一个元素
// 所谓匹配，是要涵盖整个字符串 s 的，而不是部分字符串。
// 
// 题目来源：LeetCode 10. 正则表达式匹配
// 测试链接：https://leetcode.cn/problems/regular-expression-matching/
//
// 算法核心思想：
// 使用动态规划解决正则表达式匹配问题，通过构建二维DP表来判断字符串与模式是否匹配
//
// 时间复杂度分析：
// - 基础版本：O(n*m)，其中n为s的长度，m为p的长度
// - 空间优化版本：O(n*m)时间，O(m)空间
//
// 空间复杂度分析：
// - 基础版本：O(n*m)
// - 空间优化版本：O(m)
//
// 最优解判定：✅ 是最优解，时间复杂度无法进一步优化，空间复杂度已优化到O(m)
//
// 工程化考量：
// 1. 异常处理：检查输入参数合法性
// 2. 边界条件：处理空字符串和极端情况
// 3. 性能优化：使用滚动数组减少空间占用
// 4. 代码可读性：添加详细注释和测试用例
//
// 与其他领域的联系：
// - 文本处理：模式匹配和字符串搜索
// - 编译原理：词法分析和语法分析
// - 搜索引擎：文本检索和过滤

public class LeetCode10_RegularExpressionMatching {
    
    /*
     * 算法思路：
     * 使用动态规划解决正则表达式匹配问题
     * dp[i][j] 表示字符串s的前i个字符与模式p的前j个字符是否匹配
     * 
     * 状态转移方程：
     * 如果 p[j-1] != '*'：
     *   dp[i][j] = dp[i-1][j-1] && (s[i-1] == p[j-1] || p[j-1] == '.')
     * 如果 p[j-1] == '*'：
     *   dp[i][j] = dp[i][j-2] || (dp[i-1][j] && (s[i-1] == p[j-2] || p[j-2] == '.'))
     * 
     * 解释：
     * 当p[j-1]不是'*'时，当前字符必须匹配且前面的子串也必须匹配
     * 当p[j-1]是'*'时，有两种情况：
     *   1. '*'匹配0个前面的字符：dp[i][j-2]
     *   2. '*'匹配多个前面的字符：dp[i-1][j] && (s[i-1] == p[j-2] || p[j-2] == '.')
     * 
     * 边界条件：
     * dp[0][0] = true，表示两个空字符串匹配
     * dp[i][0] = false (i>0)，表示空模式无法匹配非空字符串
     * dp[0][j] 需要特殊处理，只有当p[j-1]是'*'且dp[0][j-2]为true时才为true
     * 
     * 时间复杂度：O(n*m)，其中n为s的长度，m为p的长度
     * 空间复杂度：O(n*m)
     */
    public boolean isMatch(String s, String p) {
        // 输入验证
        if (s == null || p == null) {
            throw new IllegalArgumentException("输入字符串不能为null");
        }
        
        int n = s.length();
        int m = p.length();
        
        // dp[i][j] 表示s的前i个字符与p的前j个字符是否匹配
        boolean[][] dp = new boolean[n + 1][m + 1];
        
        // 边界条件
        dp[0][0] = true;
        
        // 处理空字符串与模式的匹配情况
        for (int j = 2; j <= m; j++) {
            if (p.charAt(j - 1) == '*') {
                dp[0][j] = dp[0][j - 2];
            }
        }
        
        // 填充dp表
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= m; j++) {
                if (p.charAt(j - 1) != '*') {
                    // 当前模式字符不是'*'
                    dp[i][j] = dp[i - 1][j - 1] && 
                        (s.charAt(i - 1) == p.charAt(j - 1) || p.charAt(j - 1) == '.');
                } else {
                    // 当前模式字符是'*'
                    // '*'匹配0个前面的字符 或 '*'匹配多个前面的字符
                    dp[i][j] = dp[i][j - 2] || 
                        (dp[i - 1][j] && (s.charAt(i - 1) == p.charAt(j - 2) || p.charAt(j - 2) == '.'));
                }
            }
        }
        
        return dp[n][m];
    }

    /*
     * 空间优化版本
     * 使用滚动数组优化空间复杂度
     * 
     * 时间复杂度：O(n*m)
     * 空间复杂度：O(m)
     */
    public boolean isMatchOptimized(String s, String p) {
        // 输入验证
        if (s == null || p == null) {
            throw new IllegalArgumentException("输入字符串不能为null");
        }
        
        int n = s.length();
        int m = p.length();
        
        // 只需要两行数组
        boolean[] prev = new boolean[m + 1];
        boolean[] curr = new boolean[m + 1];
        
        // 边界条件
        prev[0] = true;
        
        // 处理空字符串与模式的匹配情况
        for (int j = 2; j <= m; j++) {
            if (p.charAt(j - 1) == '*') {
                prev[j] = prev[j - 2];
            }
        }
        
        // 填充dp表
        for (int i = 1; i <= n; i++) {
            // 每次循环开始前重置curr数组
            for (int j = 0; j <= m; j++) {
                curr[j] = false;
            }
            
            for (int j = 1; j <= m; j++) {
                if (p.charAt(j - 1) != '*') {
                    // 当前模式字符不是'*'
                    curr[j] = prev[j - 1] && 
                        (s.charAt(i - 1) == p.charAt(j - 1) || p.charAt(j - 1) == '.');
                } else {
                    // 当前模式字符是'*'
                    // '*'匹配0个前面的字符 或 '*'匹配多个前面的字符
                    curr[j] = curr[j - 2] || 
                        (prev[j] && (s.charAt(i - 1) == p.charAt(j - 2) || p.charAt(j - 2) == '.'));
                }
            }
            
            // 交换prev和curr
            boolean[] temp = prev;
            prev = curr;
            curr = temp;
        }
        
        return prev[m];
    }

    // 测试函数
    public static void main(String[] args) {
        LeetCode10_RegularExpressionMatching solution = new LeetCode10_RegularExpressionMatching();
        
        // 测试用例
        System.out.println("正则表达式匹配测试:");
        
        // 测试用例1: s="aa", p="a"
        // 预期输出: false
        System.out.println("s=\"aa\", p=\"a\" => " + solution.isMatch("aa", "a") + 
                          " (optimized: " + solution.isMatchOptimized("aa", "a") + ")");
        
        // 测试用例2: s="aa", p="a*"
        // 预期输出: true
        System.out.println("s=\"aa\", p=\"a*\" => " + solution.isMatch("aa", "a*") + 
                          " (optimized: " + solution.isMatchOptimized("aa", "a*") + ")");
        
        // 测试用例3: s="ab", p=".*"
        // 预期输出: true
        System.out.println("s=\"ab\", p=\".*\" => " + solution.isMatch("ab", ".*") + 
                          " (optimized: " + solution.isMatchOptimized("ab", ".*") + ")");
        
        // 测试用例4: s="aab", p="c*a*b"
        // 预期输出: true
        System.out.println("s=\"aab\", p=\"c*a*b\" => " + solution.isMatch("aab", "c*a*b") + 
                          " (optimized: " + solution.isMatchOptimized("aab", "c*a*b") + ")");
        
        // 测试用例5: s="mississippi", p="mis*is*p*."
        // 预期输出: false
        System.out.println("s=\"mississippi\", p=\"mis*is*p*.\" => " + solution.isMatch("mississippi", "mis*is*p*.") + 
                          " (optimized: " + solution.isMatchOptimized("mississippi", "mis*is*p*.") + ")");
        
        // 测试用例6: s="", p="a*"
        // 预期输出: true (空字符串匹配a*的0个a)
        System.out.println("s=\"\", p=\"a*\" => " + solution.isMatch("", "a*") + 
                          " (optimized: " + solution.isMatchOptimized("", "a*") + ")");
        
        // 测试用例7: s="", p=""
        // 预期输出: true (两个空字符串匹配)
        System.out.println("s=\"\", p=\"\" => " + solution.isMatch("", "") + 
                          " (optimized: " + solution.isMatchOptimized("", "") + ")");
        
        // 测试用例8: s="a", p=""
        // 预期输出: false (非空字符串不匹配空模式)
        System.out.println("s=\"a\", p=\"\" => " + solution.isMatch("a", "") + 
                          " (optimized: " + solution.isMatchOptimized("a", "") + ")");
    }
}

===============================================

文件: LeetCode10_RegularExpressionMatching.py
===============================================
# 正则表达式匹配 (Regular Expression Matching)
# 给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 '.' 和 '*' 的正则表达式匹配。
# '.' 匹配任意单个字符
# '*' 匹配零个或多个前面的那一个元素
# 所谓匹配，是要涵盖整个字符串 s 的，而不是部分字符串。
# 
# 题目来源：LeetCode 10. 正则表达式匹配
# 测试链接：https://leetcode.cn/problems/regular-expression-matching/
#
# 算法核心思想：
# 使用动态规划解决正则表达式匹配问题，通过构建二维DP表来判断字符串与模式是否匹配
#
# 时间复杂度分析：
# - 基础版本：O(n*m)，其中n为s的长度，m为p的长度
# - 空间优化版本：O(n*m)时间，O(m)空间
#
# 空间复杂度分析：
# - 基础版本：O(n*m)
# - 空间优化版本：O(m)
#
# 最优解判定：✅ 是最优解，时间复杂度无法进一步优化，空间复杂度已优化到O(m)
#
# 工程化考量：
# 1. 异常处理：检查输入参数合法性
# 2. 边界条件：处理空字符串和极端情况
# 3. 性能优化：使用滚动数组减少空间占用
# 4. 代码可读性：添加详细注释和测试用例
#
# 与其他领域的联系：
# - 文本处理：模式匹配和字符串搜索
# - 编译原理：词法分析和语法分析
# - 搜索引擎：文本检索和过滤

class LeetCode10_RegularExpressionMatching:
    
    def isMatch(self, s: str, p: str) -> bool:
        """
        算法思路：
        使用动态规划解决正则表达式匹配问题
        dp[i][j] 表示字符串s的前i个字符与模式p的前j个字符是否匹配
        
        状态转移方程：
        如果 p[j-1] != '*'：
          dp[i][j] = dp[i-1][j-1] && (s[i-1] == p[j-1] || p[j-1] == '.')
        如果 p[j-1] == '*'：
          dp[i][j] = dp[i][j-2] || (dp[i-1][j] && (s[i-1] == p[j-2] || p[j-2] == '.'))
        
        解释：
        当p[j-1]不是'*'时，当前字符必须匹配且前面的子串也必须匹配
        当p[j-1]是'*'时，有两种情况：
          1. '*'匹配0个前面的字符：dp[i][j-2]
          2. '*'匹配多个前面的字符：dp[i-1][j] && (s[i-1] == p[j-2] || p[j-2] == '.')
        
        边界条件：
        dp[0][0] = True，表示两个空字符串匹配
        dp[i][0] = False (i>0)，表示空模式无法匹配非空字符串
        dp[0][j] 需要特殊处理，只有当p[j-1]是'*'且dp[0][j-2]为True时才为True
        
        参数:
            s (str): 源字符串
            p (str): 模式字符串
            
        返回:
            bool: 字符串与模式是否匹配
            
        时间复杂度：O(n*m)，其中n为s的长度，m为p的长度
        空间复杂度：O(n*m)
        """
        # 输入验证
        if s is None or p is None:
            raise ValueError("输入字符串不能为None")
        
        n, m = len(s), len(p)
        
        # dp[i][j] 表示s的前i个字符与p的前j个字符是否匹配
        dp = [[False] * (m + 1) for _ in range(n + 1)]
        
        # 边界条件
        dp[0][0] = True  # 两个空字符串匹配
        
        # 处理空字符串与模式的匹配情况
        # 只有当模式中的'*'可以匹配0个前面的字符时，空字符串才能与模式匹配
        for j in range(2, m + 1):
            if p[j - 1] == '*':
                dp[0][j] = dp[0][j - 2]
        
        # 填充dp表
        for i in range(1, n + 1):
            for j in range(1, m + 1):
                if p[j - 1] != '*':
                    # 当前模式字符不是'*'
                    # 匹配条件：前i-1个字符与前j-1个字符匹配，且当前字符匹配
                    dp[i][j] = dp[i - 1][j - 1] and \
                        (s[i - 1] == p[j - 1] or p[j - 1] == '.')
                else:
                    # 当前模式字符是'*'
                    # '*'匹配0个前面的字符 或 '*'匹配多个前面的字符
                    dp[i][j] = dp[i][j - 2] or \
                        (dp[i - 1][j] and (s[i - 1] == p[j - 2] or p[j - 2] == '.'))
        
        return dp[n][m]

    def isMatchOptimized(self, s: str, p: str) -> bool:
        """
        空间优化版本
        使用滚动数组优化空间复杂度
        
        参数:
            s (str): 源字符串
            p (str): 模式字符串
            
        返回:
            bool: 字符串与模式是否匹配
            
        时间复杂度：O(n*m)
        空间复杂度：O(m)
        """
        # 输入验证
        if s is None or p is None:
            raise ValueError("输入字符串不能为None")
        
        n, m = len(s), len(p)
        
        # 只需要两行数组
        prev = [False] * (m + 1)
        curr = [False] * (m + 1)
        
        # 边界条件
        prev[0] = True
        
        # 处理空字符串与模式的匹配情况
        for j in range(2, m + 1):
            if p[j - 1] == '*':
                prev[j] = prev[j - 2]
        
        # 填充dp表
        for i in range(1, n + 1):
            # 每次循环开始前重置curr数组
            for j in range(m + 1):
                curr[j] = False
            
            for j in range(1, m + 1):
                if p[j - 1] != '*':
                    # 当前模式字符不是'*'
                    # 匹配条件：前i-1个字符与前j-1个字符匹配，且当前字符匹配
                    curr[j] = prev[j - 1] and \
                        (s[i - 1] == p[j - 1] or p[j - 1] == '.')
                else:
                    # 当前模式字符是'*'
                    # '*'匹配0个前面的字符 或 '*'匹配多个前面的字符
                    curr[j] = curr[j - 2] or \
                        (prev[j] and (s[i - 1] == p[j - 2] or p[j - 2] == '.'))
            
            # 交换prev和curr
            prev, curr = curr, prev
        
        return prev[m]


# 测试函数
def test():
    """
    全面的单元测试
    覆盖各种边界情况和常见场景
    """
    sol = LeetCode10_RegularExpressionMatching()
    
    print("=== 正则表达式匹配算法测试 ===")
    
    # 测试用例
    test_cases = [
        ("aa", "a"),      # False
        ("aa", "a*"),     # True
        ("ab", ".*"),     # True
        ("aab", "c*a*b"), # True
        ("mississippi", "mis*is*p*."), # False
        ("", "a*"),       # True (空字符串匹配a*的0个a)
        ("", ""),         # True (两个空字符串匹配)
        ("a", ""),        # False (非空字符串不匹配空模式)
    ]
    
    print("正则表达式匹配测试:")
    for s, p in test_cases:
        result1 = sol.isMatch(s, p)
        result2 = sol.isMatchOptimized(s, p)
        print(f's="{s}", p="{p}" => {result1} (optimized: {result2})')
        print(f"测试结果: {'✅' if result1 == result2 else '❌'}")
    
    print("\n=== 所有测试通过 ===")


# 运行测试
if __name__ == "__main__":
    test()

===============================================

文件: LeetCode1143_LongestCommonSubsequence.cpp
===============================================
#include <iostream>
#include <vector>
#include <string>
#include <algorithm>
using namespace std;

// 最长公共子序列 (Longest Common Subsequence)
// 给定两个字符串 text1 和 text2，返回这两个字符串的最长公共子序列的长度
// 一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串
// 
// 题目来源：LeetCode 1143. 最长公共子序列
// 测试链接：https://leetcode.cn/problems/longest-common-subsequence/
//
// 算法核心思想：
// 使用动态规划解决最长公共子序列问题，通过构建二维DP表来计算最长公共子序列长度
//
// 时间复杂度分析：
// - 基础版本：O(n*m)，其中n为text1的长度，m为text2的长度
// - 空间优化版本：O(n*m)时间，O(min(n,m))空间
//
// 空间复杂度分析：
// - 基础版本：O(n*m)
// - 空间优化版本：O(min(n,m))
//
// 最优解判定：✅ 是最优解，时间复杂度无法进一步优化，空间复杂度已优化到O(min(n,m))
//
// 工程化考量：
// 1. 异常处理：检查输入参数合法性
// 2. 边界条件：处理空字符串和极端情况
// 3. 性能优化：使用滚动数组减少空间占用
// 4. 代码可读性：添加详细注释和测试用例
//
// 与其他领域的联系：
// - 生物信息学：DNA序列比对
// - 文本处理：文档相似度计算
// - 版本控制：Git等版本控制系统中的diff算法

class LeetCode1143_LongestCommonSubsequence {
public:
    /*
     * 算法思路：
     * 使用动态规划解决最长公共子序列问题
     * dp[i][j] 表示 text1 的前 i 个字符与 text2 的前 j 个字符的最长公共子序列的长度
     * 
     * 状态转移方程：
     * 如果 text1[i-1] == text2[j-1]，则当前字符可以加入公共子序列
     *   dp[i][j] = dp[i-1][j-1] + 1
     * 如果 text1[i-1] != text2[j-1]，则取两种情况的最大值
     *   dp[i][j] = max(dp[i-1][j], dp[i][j-1])
     * 
     * 边界条件：
     * dp[0][j] = 0，表示 text1 为空字符串时，与 text2 的最长公共子序列长度为 0
     * dp[i][0] = 0，表示 text2 为空字符串时，与 text1 的最长公共子序列长度为 0
     * 
     * 时间复杂度：O(n*m)，其中n为text1的长度，m为text2的长度
     * 空间复杂度：O(n*m)
     */
    int longestCommonSubsequence1(string text1, string text2) {
        if (text1.empty() || text2.empty()) {
            return 0;
        }
        int n = text1.length();
        int m = text2.length();
        // dp[i][j] 表示text1[0...i-1]和text2[0...j-1]的最长公共子序列长度
        vector<vector<int> > dp(n + 1, vector<int>(m + 1, 0));
        
        // 填充dp表
        for (int i = 1; i <= n; ++i) {
            for (int j = 1; j <= m; ++j) {
                if (text1[i - 1] == text2[j - 1]) {
                    // 当前字符相同，可以加入公共子序列
                    dp[i][j] = dp[i - 1][j - 1] + 1;
                } else {
                    // 当前字符不同，取两种情况的最大值
                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);
                }
            }
        }
        
        return dp[n][m];
    }

    /*
     * 空间优化版本
     * 观察状态转移方程，dp[i][j]只依赖于dp[i-1][j-1]、dp[i-1][j]和dp[i][j-1]
     * 可以使用一维数组优化空间复杂度
     * 
     * 时间复杂度：O(n*m)
     * 空间复杂度：O(min(n,m))
     */
    int longestCommonSubsequence2(string text1, string text2) {
        if (text1.empty() || text2.empty()) {
            return 0;
        }
        
        // 为了节省空间，让较短的字符串作为第二个参数
        if (text1.length() < text2.length()) {
            swap(text1, text2);
        }
        
        int n = text1.length();
        int m = text2.length();
        // 使用一维数组存储当前行的数据
        vector<int> dp(m + 1, 0);
        // 保存左上角的值(dp[i-1][j-1])
        int pre = 0;
        
        // 按行填充dp表
        for (int i = 1; i <= n; ++i) {
            pre = 0; // 每行开始时，左上角的值为0
            for (int j = 1; j <= m; ++j) {
                int temp = dp[j]; // 保存当前dp[j]，用于下一轮的pre
                if (text1[i - 1] == text2[j - 1]) {
                    // 当前字符相同
                    dp[j] = pre + 1;
                } else {
                    // 当前字符不同，取上方或左方的最大值
                    dp[j] = max(dp[j], dp[j - 1]);
                }
                pre = temp; // 更新pre为下一轮的左上角值
            }
        }
        
        return dp[m];
    }
};

// 单元测试
int main() {
    LeetCode1143_LongestCommonSubsequence solution;
    
    // 测试用例1: "abcde", "ace"
    // 预期输出: 3 ("ace")
    cout << "Test 1: " << solution.longestCommonSubsequence1("abcde", "ace") << endl; // 应输出3
    cout << "Test 1 (Space Optimized): " << solution.longestCommonSubsequence2("abcde", "ace") << endl; // 应输出3
    
    // 测试用例2: "abc", "abc"
    // 预期输出: 3 ("abc")
    cout << "Test 2: " << solution.longestCommonSubsequence1("abc", "abc") << endl; // 应输出3
    cout << "Test 2 (Space Optimized): " << solution.longestCommonSubsequence2("abc", "abc") << endl; // 应输出3
    
    // 测试用例3: "abc", "def"
    // 预期输出: 0 (无公共子序列)
    cout << "Test 3: " << solution.longestCommonSubsequence1("abc", "def") << endl; // 应输出0
    cout << "Test 3 (Space Optimized): " << solution.longestCommonSubsequence2("abc", "def") << endl; // 应输出0
    
    // 边界测试: 空字符串
    cout << "Test 4 (Empty String): " << solution.longestCommonSubsequence1("", "abc") << endl; // 应输出0
    cout << "Test 4 (Empty String, Space Optimized): " << solution.longestCommonSubsequence2("", "abc") << endl; // 应输出0
    
    // 边界测试: 单字符匹配
    cout << "Test 5 (Single Char Match): " << solution.longestCommonSubsequence1("a", "a") << endl; // 应输出1
    cout << "Test 5 (Single Char Match, Space Optimized): " << solution.longestCommonSubsequence2("a", "a") << endl; // 应输出1
    
    // 边界测试: 单字符不匹配
    cout << "Test 6 (Single Char No Match): " << solution.longestCommonSubsequence1("a", "b") << endl; // 应输出0
    cout << "Test 6 (Single Char No Match, Space Optimized): " << solution.longestCommonSubsequence2("a", "b") << endl; // 应输出0
    
    return 0;
}

===============================================

文件: LeetCode1143_LongestCommonSubsequence.java
===============================================
// 最长公共子序列 (Longest Common Subsequence)
// 给定两个字符串 text1 和 text2，返回这两个字符串的最长公共子序列的长度
// 一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串
// 
// 题目来源：LeetCode 1143. 最长公共子序列
// 测试链接：https://leetcode.cn/problems/longest-common-subsequence/
//
// 算法核心思想：
// 使用动态规划解决最长公共子序列问题，通过构建二维DP表来计算最长公共子序列长度
//
// 时间复杂度分析：
// - 基础版本：O(n*m)，其中n为text1的长度，m为text2的长度
// - 空间优化版本：O(n*m)时间，O(min(n,m))空间
//
// 空间复杂度分析：
// - 基础版本：O(n*m)
// - 空间优化版本：O(min(n,m))
//
// 最优解判定：✅ 是最优解，时间复杂度无法进一步优化，空间复杂度已优化到O(min(n,m))
//
// 工程化考量：
// 1. 异常处理：检查输入参数合法性
// 2. 边界条件：处理空字符串和极端情况
// 3. 性能优化：使用滚动数组减少空间占用
// 4. 代码可读性：添加详细注释和测试用例
//
// 与其他领域的联系：
// - 生物信息学：DNA序列比对
// - 文本处理：文档相似度计算
// - 版本控制：Git等版本控制系统中的diff算法

public class LeetCode1143_LongestCommonSubsequence {
    
    /*
     * 算法思路：
     * 使用动态规划解决最长公共子序列问题
     * dp[i][j] 表示 text1 的前 i 个字符与 text2 的前 j 个字符的最长公共子序列的长度
     * 
     * 状态转移方程：
     * 如果 text1[i-1] == text2[j-1]，则当前字符可以加入公共子序列
     *   dp[i][j] = dp[i-1][j-1] + 1
     * 如果 text1[i-1] != text2[j-1]，则取两种情况的最大值
     *   dp[i][j] = max(dp[i-1][j], dp[i][j-1])
     * 
     * 边界条件：
     * dp[0][j] = 0，表示 text1 为空字符串时，与 text2 的最长公共子序列长度为 0
     * dp[i][0] = 0，表示 text2 为空字符串时，与 text1 的最长公共子序列长度为 0
     * 
     * 时间复杂度：O(n*m)，其中n为text1的长度，m为text2的长度
     * 空间复杂度：O(n*m)
     */
    public int longestCommonSubsequence1(String text1, String text2) {
        // 输入验证
        if (text1 == null || text2 == null) {
            throw new IllegalArgumentException("输入字符串不能为null");
        }
        
        if (text1.isEmpty() || text2.isEmpty()) {
            return 0;
        }
        
        int n = text1.length();
        int m = text2.length();
        // dp[i][j] 表示text1[0...i-1]和text2[0...j-1]的最长公共子序列长度
        int[][] dp = new int[n + 1][m + 1];
        
        // 填充dp表
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= m; j++) {
                if (text1.charAt(i - 1) == text2.charAt(j - 1)) {
                    // 当前字符相同，可以加入公共子序列
                    dp[i][j] = dp[i - 1][j - 1] + 1;
                } else {
                    // 当前字符不同，取两种情况的最大值
                    dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
                }
            }
        }
        
        return dp[n][m];
    }

    /*
     * 空间优化版本
     * 观察状态转移方程，dp[i][j]只依赖于dp[i-1][j-1]、dp[i-1][j]和dp[i][j-1]
     * 可以使用一维数组优化空间复杂度
     * 
     * 时间复杂度：O(n*m)
     * 空间复杂度：O(min(n,m))
     */
    public int longestCommonSubsequence2(String text1, String text2) {
        // 输入验证
        if (text1 == null || text2 == null) {
            throw new IllegalArgumentException("输入字符串不能为null");
        }
        
        if (text1.isEmpty() || text2.isEmpty()) {
            return 0;
        }
        
        // 为了节省空间，让较短的字符串作为第二个参数
        if (text1.length() < text2.length()) {
            String temp = text1;
            text1 = text2;
            text2 = temp;
        }
        
        int n = text1.length();
        int m = text2.length();
        // 使用一维数组存储当前行的数据
        int[] dp = new int[m + 1];
        // 保存左上角的值(dp[i-1][j-1])
        int pre = 0;
        
        // 按行填充dp表
        for (int i = 1; i <= n; i++) {
            pre = 0; // 每行开始时，左上角的值为0
            for (int j = 1; j <= m; j++) {
                int temp = dp[j]; // 保存当前dp[j]，用于下一轮的pre
                if (text1.charAt(i - 1) == text2.charAt(j - 1)) {
                    // 当前字符相同
                    dp[j] = pre + 1;
                } else {
                    // 当前字符不同，取上方或左方的最大值
                    dp[j] = Math.max(dp[j], dp[j - 1]);
                }
                pre = temp; // 更新pre为下一轮的左上角值
            }
        }
        
        return dp[m];
    }

    // 测试函数
    public static void main(String[] args) {
        LeetCode1143_LongestCommonSubsequence solution = new LeetCode1143_LongestCommonSubsequence();
        
        // 测试用例1: "abcde", "ace"
        // 预期输出: 3 ("ace")
        System.out.println("Test 1: " + solution.longestCommonSubsequence1("abcde", "ace")); // 应输出3
        System.out.println("Test 1 (Space Optimized): " + solution.longestCommonSubsequence2("abcde", "ace")); // 应输出3
        
        // 测试用例2: "abc", "abc"
        // 预期输出: 3 ("abc")
        System.out.println("Test 2: " + solution.longestCommonSubsequence1("abc", "abc")); // 应输出3
        System.out.println("Test 2 (Space Optimized): " + solution.longestCommonSubsequence2("abc", "abc")); // 应输出3
        
        // 测试用例3: "abc", "def"
        // 预期输出: 0 (无公共子序列)
        System.out.println("Test 3: " + solution.longestCommonSubsequence1("abc", "def")); // 应输出0
        System.out.println("Test 3 (Space Optimized): " + solution.longestCommonSubsequence2("abc", "def")); // 应输出0
        
        // 边界测试: 空字符串
        System.out.println("Test 4 (Empty String): " + solution.longestCommonSubsequence1("", "abc")); // 应输出0
        System.out.println("Test 4 (Empty String, Space Optimized): " + solution.longestCommonSubsequence2("", "abc")); // 应输出0
        
        // 边界测试: 单字符匹配
        System.out.println("Test 5 (Single Char Match): " + solution.longestCommonSubsequence1("a", "a")); // 应输出1
        System.out.println("Test 5 (Single Char Match, Space Optimized): " + solution.longestCommonSubsequence2("a", "a")); // 应输出1
        
        // 边界测试: 单字符不匹配
        System.out.println("Test 6 (Single Char No Match): " + solution.longestCommonSubsequence1("a", "b")); // 应输出0
        System.out.println("Test 6 (Single Char No Match, Space Optimized): " + solution.longestCommonSubsequence2("a", "b")); // 应输出0
    }
}

===============================================

文件: LeetCode1143_LongestCommonSubsequence.py
===============================================
# 最长公共子序列 (Longest Common Subsequence)
# 给定两个字符串 text1 和 text2，返回这两个字符串的最长公共子序列的长度
# 一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串
# 
# 题目来源：LeetCode 1143. 最长公共子序列
# 测试链接：https://leetcode.cn/problems/longest-common-subsequence/
#
# 算法核心思想：
# 使用动态规划解决最长公共子序列问题，通过构建二维DP表来计算最长公共子序列长度
#
# 时间复杂度分析：
# - 基础版本：O(n*m)，其中n为text1的长度，m为text2的长度
# - 空间优化版本：O(n*m)时间，O(min(n,m))空间
#
# 空间复杂度分析：
# - 基础版本：O(n*m)
# - 空间优化版本：O(min(n,m))
#
# 最优解判定：✅ 是最优解，时间复杂度无法进一步优化，空间复杂度已优化到O(min(n,m))
#
# 工程化考量：
# 1. 异常处理：检查输入参数合法性
# 2. 边界条件：处理空字符串和极端情况
# 3. 性能优化：使用滚动数组减少空间占用
# 4. 代码可读性：添加详细注释和测试用例
#
# 与其他领域的联系：
# - 生物信息学：DNA序列比对
# - 文本处理：文档相似度计算
# - 版本控制：Git等版本控制系统中的diff算法

class LeetCode1143_LongestCommonSubsequence:
    
    def longestCommonSubsequence1(self, text1: str, text2: str) -> int:
        """
        算法思路：
        使用动态规划解决最长公共子序列问题
        dp[i][j] 表示 text1 的前 i 个字符与 text2 的前 j 个字符的最长公共子序列的长度
        
        状态转移方程：
        如果 text1[i-1] == text2[j-1]，则当前字符可以加入公共子序列
          dp[i][j] = dp[i-1][j-1] + 1
        如果 text1[i-1] != text2[j-1]，则取两种情况的最大值
          dp[i][j] = max(dp[i-1][j], dp[i][j-1])
        
        边界条件：
        dp[0][j] = 0，表示 text1 为空字符串时，与 text2 的最长公共子序列长度为 0
        dp[i][0] = 0，表示 text2 为空字符串时，与 text1 的最长公共子序列长度为 0
        
        参数:
            text1 (str): 第一个字符串
            text2 (str): 第二个字符串
            
        返回:
            int: 最长公共子序列的长度
            
        时间复杂度：O(n*m)，其中n为text1的长度，m为text2的长度
        空间复杂度：O(n*m)
        """
        # 输入验证
        if text1 is None or text2 is None:
            raise ValueError("输入字符串不能为None")
        
        if len(text1) == 0 or len(text2) == 0:
            return 0
            
        n = len(text1)
        m = len(text2)
        # dp[i][j] 表示text1[0...i-1]和text2[0...j-1]的最长公共子序列长度
        dp = [[0] * (m + 1) for _ in range(n + 1)]
        
        # 填充dp表
        for i in range(1, n + 1):
            for j in range(1, m + 1):
                if text1[i - 1] == text2[j - 1]:
                    # 当前字符相同，可以加入公共子序列
                    dp[i][j] = dp[i - 1][j - 1] + 1
                else:
                    # 当前字符不同，取两种情况的最大值
                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])
        
        return dp[n][m]
    
    def longestCommonSubsequence2(self, text1: str, text2: str) -> int:
        """
        空间优化版本
        观察状态转移方程，dp[i][j]只依赖于dp[i-1][j-1]、dp[i-1][j]和dp[i][j-1]
        可以使用一维数组优化空间复杂度
        
        参数:
            text1 (str): 第一个字符串
            text2 (str): 第二个字符串
            
        返回:
            int: 最长公共子序列的长度
            
        时间复杂度：O(n*m)
        空间复杂度：O(min(n,m))
        """
        # 输入验证
        if text1 is None or text2 is None:
            raise ValueError("输入字符串不能为None")
        
        if len(text1) == 0 or len(text2) == 0:
            return 0
        
        # 为了节省空间，让较短的字符串作为第二个参数
        if len(text1) < len(text2):
            text1, text2 = text2, text1
        
        n = len(text1)
        m = len(text2)
        # 使用一维数组存储当前行的数据
        dp = [0] * (m + 1)
        # 保存左上角的值(dp[i-1][j-1])
        pre = 0
        
        # 按行填充dp表
        for i in range(1, n + 1):
            pre = 0  # 每行开始时，左上角的值为0
            for j in range(1, m + 1):
                temp = dp[j]  # 保存当前dp[j]，用于下一轮的pre
                if text1[i - 1] == text2[j - 1]:
                    # 当前字符相同
                    dp[j] = pre + 1
                else:
                    # 当前字符不同，取上方或左方的最大值
                    dp[j] = max(dp[j], dp[j - 1])
                pre = temp  # 更新pre为下一轮的左上角值
        
        return dp[m]


# 测试函数
def test():
    solution = LeetCode1143_LongestCommonSubsequence()
    
    # 测试用例1: "abcde", "ace"
    # 预期输出: 3 ("ace")
    print(f"Test 1: {solution.longestCommonSubsequence1('abcde', 'ace')}")  # 应输出3
    print(f"Test 1 (Space Optimized): {solution.longestCommonSubsequence2('abcde', 'ace')}")  # 应输出3
    
    # 测试用例2: "abc", "abc"
    # 预期输出: 3 ("abc")
    print(f"Test 2: {solution.longestCommonSubsequence1('abc', 'abc')}")  # 应输出3
    print(f"Test 2 (Space Optimized): {solution.longestCommonSubsequence2('abc', 'abc')}")  # 应输出3
    
    # 测试用例3: "abc", "def"
    # 预期输出: 0 (无公共子序列)
    print(f"Test 3: {solution.longestCommonSubsequence1('abc', 'def')}")  # 应输出0
    print(f"Test 3 (Space Optimized): {solution.longestCommonSubsequence2('abc', 'def')}")  # 应输出0
    
    # 边界测试: 空字符串
    print(f"Test 4 (Empty String): {solution.longestCommonSubsequence1('', 'abc')}")  # 应输出0
    print(f"Test 4 (Empty String, Space Optimized): {solution.longestCommonSubsequence2('', 'abc')}")  # 应输出0
    
    # 边界测试: 单字符匹配
    print(f"Test 5 (Single Char Match): {solution.longestCommonSubsequence1('a', 'a')}")  # 应输出1
    print(f"Test 5 (Single Char Match, Space Optimized): {solution.longestCommonSubsequence2('a', 'a')}")  # 应输出1
    
    # 边界测试: 单字符不匹配
    print(f"Test 6 (Single Char No Match): {solution.longestCommonSubsequence1('a', 'b')}")  # 应输出0
    print(f"Test 6 (Single Char No Match, Space Optimized): {solution.longestCommonSubsequence2('a', 'b')}")  # 应输出0


# 运行测试
if __name__ == "__main__":
    test()

===============================================

文件: LeetCode5_LongestPalindromicSubstring.java
===============================================
// 最长回文子串 (Longest Palindromic Substring)
// 给你一个字符串 s，找到 s 中最长的回文子串
// 
// 题目来源：LeetCode 5. 最长回文子串
// 测试链接：https://leetcode.cn/problems/longest-palindromic-substring/
//
// 算法核心思想：
// 使用动态规划解决最长回文子串问题，通过构建二维DP表来判断子串是否为回文
//
// 时间复杂度分析：
// - 动态规划版本：O(n²)，其中n为s的长度
// - 中心扩展版本：O(n²)时间，O(1)空间
//
// 空间复杂度分析：
// - 动态规划版本：O(n²)
// - 中心扩展版本：O(1)
//
// 最优解判定：✅ 中心扩展法是最优解，时间复杂度O(n²)，空间复杂度O(1)
//
// 工程化考量：
// 1. 异常处理：检查输入参数合法性
// 2. 边界条件：处理空字符串和极端情况
// 3. 性能优化：使用中心扩展法减少空间占用
// 4. 代码可读性：添加详细注释和测试用例
//
// 与其他领域的联系：
// - 生物信息学：DNA回文序列分析
// - 密码学：回文密码检测
// - 文本处理：回文文本识别

public class LeetCode5_LongestPalindromicSubstring {
    
    /*
     * 算法思路：
     * 使用动态规划解决最长回文子串问题
     * dp[i][j] 表示字符串s在区间[i,j]内是否是回文子串
     * 
     * 状态转移方程：
     * 如果 s[i] == s[j]，则取决于中间子串是否为回文
     *   dp[i][j] = dp[i+1][j-1]
     * 特殊情况：当子串长度小于等于3时，只需检查首尾字符是否相等
     *   dp[i][j] = (s[i] == s[j])
     * 
     * 边界条件：
     * dp[i][i] = true，表示单个字符是回文子串
     * dp[i][i+1] = (s[i] == s[i+1])，表示两个字符的回文判断
     * 
     * 时间复杂度：O(n²)，其中n为字符串s的长度
     * 空间复杂度：O(n²)
     */
    public String longestPalindrome1(String s) {
        // 输入验证
        if (s == null) {
            throw new IllegalArgumentException("输入字符串不能为null");
        }
        
        if (s.length() < 2) {
            return s;
        }
        
        int n = s.length();
        // dp[i][j] 表示s[i...j]是否是回文子串
        boolean[][] dp = new boolean[n][n];
        int maxLen = 1;
        int start = 0;
        
        // 初始化：单个字符和两个字符的情况
        for (int i = 0; i < n; i++) {
            dp[i][i] = true; // 单个字符是回文
            // 初始化两个字符的情况
            if (i < n - 1 && s.charAt(i) == s.charAt(i + 1)) {
                dp[i][i + 1] = true;
                maxLen = 2;
                start = i;
            }
        }
        
        // 按子串长度由小到大填充dp表
        for (int len = 3; len <= n; len++) {
            for (int i = 0; i <= n - len; i++) {
                int j = i + len - 1;
                // 首尾字符相等，且中间子串是回文，则整个子串是回文
                if (s.charAt(i) == s.charAt(j) && dp[i + 1][j - 1]) {
                    dp[i][j] = true;
                    if (len > maxLen) {
                        maxLen = len;
                        start = i;
                    }
                }
            }
        }
        
        return s.substring(start, start + maxLen);
    }

    /*
     * 中心扩展法
     * 回文串都是从中心向两边对称的，可以枚举每一个可能的中心点，然后向两边扩展
     * 注意：中心点可能是一个字符（奇数长度）或两个字符之间的位置（偶数长度）
     * 
     * 时间复杂度：O(n²)
     * 空间复杂度：O(1)
     */
    public String longestPalindrome2(String s) {
        // 输入验证
        if (s == null) {
            throw new IllegalArgumentException("输入字符串不能为null");
        }
        
        if (s.length() < 2) {
            return s;
        }
        
        int n = s.length();
        int maxLen = 1;
        int start = 0;
        
        // 枚举每一个可能的中心点
        for (int i = 0; i < n; i++) {
            // 以单个字符为中心（奇数长度）
            int[] res1 = expandAroundCenter(s, i, i);
            // 以两个字符之间为中心（偶数长度）
            int[] res2 = expandAroundCenter(s, i, i + 1);
            
            // 更新最长回文子串
            if (res1[1] > maxLen) {
                maxLen = res1[1];
                start = res1[0];
            }
            if (res2[1] > maxLen) {
                maxLen = res2[1];
                start = res2[0];
            }
        }
        
        return s.substring(start, start + maxLen);
    }
    
    /*
     * 从中心向两边扩展寻找回文子串
     * 返回值：int[2]数组，[0]为起始索引，[1]为长度
     */
    private int[] expandAroundCenter(String s, int left, int right) {
        int n = s.length();
        while (left >= 0 && right < n && s.charAt(left) == s.charAt(right)) {
            left--;
            right++;
        }
        // 返回起始索引和长度
        return new int[]{left + 1, right - left - 1};
    }

    // 测试函数
    public static void main(String[] args) {
        LeetCode5_LongestPalindromicSubstring solution = new LeetCode5_LongestPalindromicSubstring();
        
        // 测试用例1: "babad"
        // 预期输出: "bab" 或 "aba"
        System.out.println("Test 1: " + solution.longestPalindrome1("babad"));
        System.out.println("Test 1 (Expand Around Center): " + solution.longestPalindrome2("babad"));
        
        // 测试用例2: "cbbd"
        // 预期输出: "bb"
        System.out.println("Test 2: " + solution.longestPalindrome1("cbbd"));
        System.out.println("Test 2 (Expand Around Center): " + solution.longestPalindrome2("cbbd"));
        
        // 边界测试: 单字符
        System.out.println("Test 3 (Single Char): " + solution.longestPalindrome1("a")); // 应输出"a"
        System.out.println("Test 3 (Single Char, Expand Around Center): " + solution.longestPalindrome2("a")); // 应输出"a"
        
        // 边界测试: 全部相同字符
        System.out.println("Test 4 (All Same): " + solution.longestPalindrome1("aaaaa")); // 应输出"aaaaa"
        System.out.println("Test 4 (All Same, Expand Around Center): " + solution.longestPalindrome2("aaaaa")); // 应输出"aaaaa"
        
        // 测试用例5: "ac"
        // 预期输出: "a" 或 "c"
        System.out.println("Test 5: " + solution.longestPalindrome1("ac"));
        System.out.println("Test 5 (Expand Around Center): " + solution.longestPalindrome2("ac"));
    }
}

===============================================

文件: LeetCode5_LongestPalindromicSubstring.py
===============================================
# 最长回文子串 (Longest Palindromic Substring)
# 给你一个字符串 s，找到 s 中最长的回文子串
# 
# 题目来源：LeetCode 5. 最长回文子串
# 测试链接：https://leetcode.cn/problems/longest-palindromic-substring/
#
# 算法核心思想：
# 使用动态规划解决最长回文子串问题，通过构建二维DP表来判断子串是否为回文
#
# 时间复杂度分析：
# - 动态规划版本：O(n²)，其中n为s的长度
# - 中心扩展版本：O(n²)时间，O(1)空间
#
# 空间复杂度分析：
# - 动态规划版本：O(n²)
# - 中心扩展版本：O(1)
#
# 最优解判定：✅ 中心扩展法是最优解，时间复杂度O(n²)，空间复杂度O(1)
#
# 工程化考量：
# 1. 异常处理：检查输入参数合法性
# 2. 边界条件：处理空字符串和极端情况
# 3. 性能优化：使用中心扩展法减少空间占用
# 4. 代码可读性：添加详细注释和测试用例
#
# 与其他领域的联系：
# - 生物信息学：DNA回文序列分析
# - 密码学：回文密码检测
# - 文本处理：回文文本识别

class LeetCode5_LongestPalindromicSubstring:
    
    def longestPalindrome1(self, s: str) -> str:
        """
        算法思路：
        使用动态规划解决最长回文子串问题
        dp[i][j] 表示字符串s在区间[i,j]内是否是回文子串
        
        状态转移方程：
        如果 s[i] == s[j]，则取决于中间子串是否为回文
          dp[i][j] = dp[i+1][j-1]
        特殊情况：当子串长度小于等于3时，只需检查首尾字符是否相等
          dp[i][j] = (s[i] == s[j])
        
        边界条件：
        dp[i][i] = True，表示单个字符是回文子串
        dp[i][i+1] = (s[i] == s[i+1])，表示两个字符的回文判断
        
        参数:
            s (str): 输入字符串
            
        返回:
            str: 最长回文子串
            
        时间复杂度：O(n²)，其中n为字符串s的长度
        空间复杂度：O(n²)
        """
        # 输入验证
        if s is None:
            raise ValueError("输入字符串不能为None")
        
        if len(s) < 2:
            return s
            
        n = len(s)
        # dp[i][j] 表示s[i...j]是否是回文子串
        dp = [[False] * n for _ in range(n)]
        max_len = 1
        start = 0
        
        # 初始化：单个字符和两个字符的情况
        for i in range(n):
            dp[i][i] = True  # 单个字符是回文
            # 初始化两个字符的情况
            if i < n - 1 and s[i] == s[i + 1]:
                dp[i][i + 1] = True
                max_len = 2
                start = i
        
        # 按子串长度由小到大填充dp表
        for length in range(3, n + 1):
            for i in range(n - length + 1):
                j = i + length - 1
                # 首尾字符相等，且中间子串是回文，则整个子串是回文
                if s[i] == s[j] and dp[i + 1][j - 1]:
                    dp[i][j] = True
                    if length > max_len:
                        max_len = length
                        start = i
        
        return s[start:start + max_len]
    
    def longestPalindrome2(self, s: str) -> str:
        """
        中心扩展法
        回文串都是从中心向两边对称的，可以枚举每一个可能的中心点，然后向两边扩展
        注意：中心点可能是一个字符（奇数长度）或两个字符之间的位置（偶数长度）
        
        参数:
            s (str): 输入字符串
            
        返回:
            str: 最长回文子串
            
        时间复杂度：O(n²)
        空间复杂度：O(1)
        """
        # 输入验证
        if s is None:
            raise ValueError("输入字符串不能为None")
        
        if len(s) < 2:
            return s
            
        n = len(s)
        max_len = 1
        start = 0
        
        # 枚举每一个可能的中心点
        for i in range(n):
            # 以单个字符为中心（奇数长度）
            start1, len1 = self.expand_around_center(s, i, i)
            # 以两个字符之间为中心（偶数长度）
            start2, len2 = self.expand_around_center(s, i, i + 1)
            
            # 更新最长回文子串
            if len1 > max_len:
                max_len = len1
                start = start1
            if len2 > max_len:
                max_len = len2
                start = start2
        
        return s[start:start + max_len]
    
    def expand_around_center(self, s: str, left: int, right: int) -> tuple:
        """
        从中心向两边扩展寻找回文子串
        返回值：(起始索引, 长度)
        """
        n = len(s)
        while left >= 0 and right < n and s[left] == s[right]:
            left -= 1
            right += 1
        # 返回起始索引和长度
        return (left + 1, right - left - 1)


# 测试函数
def test():
    solution = LeetCode5_LongestPalindromicSubstring()
    
    # 测试用例1: "babad"
    # 预期输出: "bab" 或 "aba"
    print(f"Test 1: {solution.longestPalindrome1('babad')}")
    print(f"Test 1 (Expand Around Center): {solution.longestPalindrome2('babad')}")
    
    # 测试用例2: "cbbd"
    # 预期输出: "bb"
    print(f"Test 2: {solution.longestPalindrome1('cbbd')}")
    print(f"Test 2 (Expand Around Center): {solution.longestPalindrome2('cbbd')}")
    
    # 边界测试: 单字符
    print(f"Test 3 (Single Char): {solution.longestPalindrome1('a')}")  # 应输出"a"
    print(f"Test 3 (Single Char, Expand Around Center): {solution.longestPalindrome2('a')}")  # 应输出"a"
    
    # 边界测试: 全部相同字符
    print(f"Test 4 (All Same): {solution.longestPalindrome1('aaaaa')}")  # 应输出"aaaaa"
    print(f"Test 4 (All Same, Expand Around Center): {solution.longestPalindrome2('aaaaa')}")  # 应输出"aaaaa"
    
    # 测试用例5: "ac"
    # 预期输出: "a" 或 "c"
    print(f"Test 5: {solution.longestPalindrome1('ac')}")
    print(f"Test 5 (Expand Around Center): {solution.longestPalindrome2('ac')}")


# 运行测试
if __name__ == "__main__":
    test()

===============================================

文件: LeetCode72_EditDistance.java
===============================================
// 编辑距离 (Edit Distance)
// 给你两个单词 word1 和 word2，计算将 word1 转换成 word2 所使用的最少操作数
// 你可以对一个单词进行如下三种操作：
// 插入一个字符
// 删除一个字符
// 替换一个字符
// 
// 题目来源：LeetCode 72. 编辑距离
// 测试链接：https://leetcode.cn/problems/edit-distance/
//
// 算法核心思想：
// 使用动态规划解决字符串编辑距离问题，通过构建二维DP表来计算最小编辑操作次数
//
// 时间复杂度分析：
// - 基础版本：O(n*m)，其中n为word1的长度，m为word2的长度
// - 空间优化版本：O(n*m)时间，O(min(n,m))空间
//
// 空间复杂度分析：
// - 基础版本：O(n*m)
// - 空间优化版本：O(min(n,m))
//
// 最优解判定：✅ 是最优解，时间复杂度无法进一步优化，空间复杂度已优化到O(min(n,m))
//
// 工程化考量：
// 1. 异常处理：检查输入参数合法性
// 2. 边界条件：处理空字符串和极端情况
// 3. 性能优化：使用滚动数组减少空间占用
// 4. 代码可读性：添加详细注释和测试用例
//
// 与其他领域的联系：
// - 自然语言处理：文本相似度计算、拼写检查
// - 生物信息学：DNA序列比对、基因序列分析
// - 信息检索：文档相似度计算、搜索引擎优化
// - 版本控制：Git等版本控制系统中的diff算法

public class LeetCode72_EditDistance {
    
    /*
     * 算法思路：
     * 使用动态规划解决编辑距离问题
     * dp[i][j] 表示将 word1 的前 i 个字符转换为 word2 的前 j 个字符所需的最小操作数
     * 
     * 状态转移方程：
     * 如果 word1[i-1] == word2[j-1]，则不需要操作
     *   dp[i][j] = dp[i-1][j-1]
     * 否则，取三种操作的最小值：
     *   dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1
     * 其中：
     *   dp[i-1][j] + 1 表示删除操作（删除 word1 的第 i 个字符）
     *   dp[i][j-1] + 1 表示插入操作（在 word1 的第 i 个位置后插入 word2 的第 j 个字符）
     *   dp[i-1][j-1] + 1 表示替换操作（将 word1 的第 i 个字符替换为 word2 的第 j 个字符）
     * 
     * 边界条件：
     * dp[i][0] = i，表示将 word1 的前 i 个字符转换为空字符串需要 i 次删除操作
     * dp[0][j] = j，表示将空字符串转换为 word2 的前 j 个字符需要 j 次插入操作
     * 
     * 时间复杂度：O(m*n)，其中m为word1的长度，n为word2的长度
     * 空间复杂度：O(m*n)
     */
    public int minDistance1(String word1, String word2) {
        // 输入验证
        if (word1 == null || word2 == null) {
            throw new IllegalArgumentException("输入字符串不能为null");
        }
        
        int m = word1.length();
        int n = word2.length();
        // dp[i][j] 表示word1[0...i-1]转换为word2[0...j-1]所需的最小操作数
        int[][] dp = new int[m + 1][n + 1];
        
        // 初始化边界条件
        for (int i = 0; i <= m; i++) {
            dp[i][0] = i; // 将word1转换为空字符串，需要i次删除操作
        }
        for (int j = 0; j <= n; j++) {
            dp[0][j] = j; // 将空字符串转换为word2，需要j次插入操作
        }
        
        // 填充dp表
        for (int i = 1; i <= m; i++) {
            for (int j = 1; j <= n; j++) {
                if (word1.charAt(i - 1) == word2.charAt(j - 1)) {
                    // 当前字符相同，不需要操作
                    dp[i][j] = dp[i - 1][j - 1];
                } else {
                    // 取三种操作的最小值
                    dp[i][j] = Math.min(Math.min(dp[i - 1][j], dp[i][j - 1]), dp[i - 1][j - 1]) + 1;
                }
            }
        }
        
        return dp[m][n];
    }

    /*
     * 空间优化版本
     * 观察状态转移方程，dp[i][j]只依赖于dp[i-1][j-1]、dp[i-1][j]和dp[i][j-1]
     * 可以使用一维数组优化空间复杂度
     * 
     * 时间复杂度：O(m*n)
     * 空间复杂度：O(min(m,n))
     */
    public int minDistance2(String word1, String word2) {
        // 输入验证
        if (word1 == null || word2 == null) {
            throw new IllegalArgumentException("输入字符串不能为null");
        }
        
        // 为了节省空间，确保第二个参数是较短的字符串
        if (word1.length() < word2.length()) {
            String temp = word1;
            word1 = word2;
            word2 = temp;
        }
        
        int m = word1.length();
        int n = word2.length();
        // 使用一维数组存储当前行的数据
        int[] dp = new int[n + 1];
        // 初始化dp[0][j] = j
        for (int j = 0; j <= n; j++) {
            dp[j] = j;
        }
        
        // 按行填充dp表
        for (int i = 1; i <= m; i++) {
            int pre = dp[0]; // 保存左上角的值(dp[i-1][j-1])
            dp[0] = i; // 更新dp[i][0] = i
            for (int j = 1; j <= n; j++) {
                int temp = dp[j]; // 保存当前dp[j]，用于下一轮的pre
                if (word1.charAt(i - 1) == word2.charAt(j - 1)) {
                    // 当前字符相同，不需要操作
                    dp[j] = pre;
                } else {
                    // 取三种操作的最小值
                    dp[j] = Math.min(Math.min(dp[j], dp[j - 1]), pre) + 1;
                }
                pre = temp; // 更新pre为下一轮的左上角值
            }
        }
        
        return dp[n];
    }

    // 测试函数
    public static void main(String[] args) {
        LeetCode72_EditDistance solution = new LeetCode72_EditDistance();
        
        // 测试用例1: word1 = "horse", word2 = "ros"
        // 预期输出: 3
        // 解释: 
        // horse -> rorse (替换 'h' 为 'r')
        // rorse -> rose (删除 'r')
        // rose -> ros (删除 'e')
        System.out.println("Test 1: " + solution.minDistance1("horse", "ros")); // 应输出3
        System.out.println("Test 1 (Space Optimized): " + solution.minDistance2("horse", "ros")); // 应输出3
        
        // 测试用例2: word1 = "intention", word2 = "execution"
        // 预期输出: 5
        // 解释: 
        // intention -> inention (删除 't')
        // inention -> enention (替换 'i' 为 'e')
        // enention -> exention (替换 'n' 为 'x')
        // exention -> exection (替换 'n' 为 'c')
        // exection -> execution (插入 'u')
        System.out.println("Test 2: " + solution.minDistance1("intention", "execution")); // 应输出5
        System.out.println("Test 2 (Space Optimized): " + solution.minDistance2("intention", "execution")); // 应输出5
        
        // 边界测试: 空字符串
        System.out.println("Test 3 (Empty String): " + solution.minDistance1("", "abc")); // 应输出3
        System.out.println("Test 3 (Empty String, Space Optimized): " + solution.minDistance2("", "abc")); // 应输出3
        
        // 边界测试: 相同字符串
        System.out.println("Test 4 (Same String): " + solution.minDistance1("abc", "abc")); // 应输出0
        System.out.println("Test 4 (Same String, Space Optimized): " + solution.minDistance2("abc", "abc")); // 应输出0
        
        // 边界测试: 单字符不同
        System.out.println("Test 5 (Single Char Different): " + solution.minDistance1("a", "b")); // 应输出1
        System.out.println("Test 5 (Single Char Different, Space Optimized): " + solution.minDistance2("a", "b")); // 应输出1
    }
}

===============================================

文件: LeetCode72_EditDistance.py
===============================================
# 编辑距离 (Edit Distance)
# 给你两个单词 word1 和 word2，计算将 word1 转换成 word2 所使用的最少操作数
# 你可以对一个单词进行如下三种操作：
# 插入一个字符
# 删除一个字符
# 替换一个字符
# 
# 题目来源：LeetCode 72. 编辑距离
# 测试链接：https://leetcode.cn/problems/edit-distance/
#
# 算法核心思想：
# 使用动态规划解决字符串编辑距离问题，通过构建二维DP表来计算最小编辑操作次数
#
# 时间复杂度分析：
# - 基础版本：O(n*m)，其中n为word1的长度，m为word2的长度
# - 空间优化版本：O(n*m)时间，O(min(n,m))空间
#
# 空间复杂度分析：
# - 基础版本：O(n*m)
# - 空间优化版本：O(min(n,m))
#
# 最优解判定：✅ 是最优解，时间复杂度无法进一步优化，空间复杂度已优化到O(min(n,m))
#
# 工程化考量：
# 1. 异常处理：检查输入参数合法性
# 2. 边界条件：处理空字符串和极端情况
# 3. 性能优化：使用滚动数组减少空间占用
# 4. 代码可读性：添加详细注释和测试用例
#
# 与其他领域的联系：
# - 自然语言处理：文本相似度计算、拼写检查
# - 生物信息学：DNA序列比对、基因序列分析
# - 信息检索：文档相似度计算、搜索引擎优化
# - 版本控制：Git等版本控制系统中的diff算法

class LeetCode72_EditDistance:
    
    def minDistance1(self, word1: str, word2: str) -> int:
        """
        算法思路：
        使用动态规划解决编辑距离问题
        dp[i][j] 表示将 word1 的前 i 个字符转换为 word2 的前 j 个字符所需的最小操作数
        
        状态转移方程：
        如果 word1[i-1] == word2[j-1]，则不需要操作
          dp[i][j] = dp[i-1][j-1]
        否则，取三种操作的最小值：
          dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1
        其中：
          dp[i-1][j] + 1 表示删除操作（删除 word1 的第 i 个字符）
          dp[i][j-1] + 1 表示插入操作（在 word1 的第 i 个位置后插入 word2 的第 j 个字符）
          dp[i-1][j-1] + 1 表示替换操作（将 word1 的第 i 个字符替换为 word2 的第 j 个字符）
        
        边界条件：
        dp[i][0] = i，表示将 word1 的前 i 个字符转换为空字符串需要 i 次删除操作
        dp[0][j] = j，表示将空字符串转换为 word2 的前 j 个字符需要 j 次插入操作
        
        参数:
            word1 (str): 源字符串
            word2 (str): 目标字符串
            
        返回:
            int: 最小编辑操作数
            
        时间复杂度：O(m*n)，其中m为word1的长度，n为word2的长度
        空间复杂度：O(m*n)
        """
        # 输入验证
        if word1 is None or word2 is None:
            raise ValueError("输入字符串不能为None")
        
        m = len(word1)
        n = len(word2)
        # dp[i][j] 表示word1[0...i-1]转换为word2[0...j-1]所需的最小操作数
        dp = [[0] * (n + 1) for _ in range(m + 1)]
        
        # 初始化边界条件
        for i in range(m + 1):
            dp[i][0] = i  # 将word1转换为空字符串，需要i次删除操作
        for j in range(n + 1):
            dp[0][j] = j  # 将空字符串转换为word2，需要j次插入操作
        
        # 填充dp表
        for i in range(1, m + 1):
            for j in range(1, n + 1):
                if word1[i - 1] == word2[j - 1]:
                    # 当前字符相同，不需要操作
                    dp[i][j] = dp[i - 1][j - 1]
                else:
                    # 取三种操作的最小值
                    dp[i][j] = min(min(dp[i - 1][j], dp[i][j - 1]), dp[i - 1][j - 1]) + 1
        
        return dp[m][n]
    
    def minDistance2(self, word1: str, word2: str) -> int:
        """
        空间优化版本
        观察状态转移方程，dp[i][j]只依赖于dp[i-1][j-1]、dp[i-1][j]和dp[i][j-1]
        可以使用一维数组优化空间复杂度
        
        参数:
            word1 (str): 源字符串
            word2 (str): 目标字符串
            
        返回:
            int: 最小编辑操作数
            
        时间复杂度：O(m*n)
        空间复杂度：O(min(m,n))
        """
        # 输入验证
        if word1 is None or word2 is None:
            raise ValueError("输入字符串不能为None")
        
        # 为了节省空间，确保第二个参数是较短的字符串
        if len(word1) < len(word2):
            word1, word2 = word2, word1
        
        m = len(word1)
        n = len(word2)
        # 使用一维数组存储当前行的数据
        dp = [0] * (n + 1)
        # 初始化dp[0][j] = j
        for j in range(n + 1):
            dp[j] = j
        
        # 按行填充dp表
        for i in range(1, m + 1):
            pre = dp[0]  # 保存左上角的值(dp[i-1][j-1])
            dp[0] = i  # 更新dp[i][0] = i
            for j in range(1, n + 1):
                temp = dp[j]  # 保存当前dp[j]，用于下一轮的pre
                if word1[i - 1] == word2[j - 1]:
                    # 当前字符相同，不需要操作
                    dp[j] = pre
                else:
                    # 取三种操作的最小值
                    dp[j] = min(min(dp[j], dp[j - 1]), pre) + 1
                pre = temp  # 更新pre为下一轮的左上角值
        
        return dp[n]


# 测试函数
def test():
    solution = LeetCode72_EditDistance()
    
    # 测试用例1: word1 = "horse", word2 = "ros"
    # 预期输出: 3
    # 解释: 
    # horse -> rorse (替换 'h' 为 'r')
    # rorse -> rose (删除 'r')
    # rose -> ros (删除 'e')
    print(f"Test 1: {solution.minDistance1('horse', 'ros')}")  # 应输出3
    print(f"Test 1 (Space Optimized): {solution.minDistance2('horse', 'ros')}")  # 应输出3
    
    # 测试用例2: word1 = "intention", word2 = "execution"
    # 预期输出: 5
    # 解释: 
    # intention -> inention (删除 't')
    # inention -> enention (替换 'i' 为 'e')
    # enention -> exention (替换 'n' 为 'x')
    # exention -> exection (替换 'n' 为 'c')
    # exection -> execution (插入 'u')
    print(f"Test 2: {solution.minDistance1('intention', 'execution')}")  # 应输出5
    print(f"Test 2 (Space Optimized): {solution.minDistance2('intention', 'execution')}")  # 应输出5
    
    # 边界测试: 空字符串
    print(f"Test 3 (Empty String): {solution.minDistance1('', 'abc')}")  # 应输出3
    print(f"Test 3 (Empty String, Space Optimized): {solution.minDistance2('', 'abc')}")  # 应输出3
    
    # 边界测试: 相同字符串
    print(f"Test 4 (Same String): {solution.minDistance1('abc', 'abc')}")  # 应输出0
    print(f"Test 4 (Same String, Space Optimized): {solution.minDistance2('abc', 'abc')}")  # 应输出0
    
    # 边界测试: 单字符不同
    print(f"Test 5 (Single Char Different): {solution.minDistance1('a', 'b')}")  # 应输出1
    print(f"Test 5 (Single Char Different, Space Optimized): {solution.minDistance2('a', 'b')}")  # 应输出1


# 运行测试
if __name__ == "__main__":
    test()

===============================================

