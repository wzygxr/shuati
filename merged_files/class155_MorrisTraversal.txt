===============================================
文件夹: class155_MorrisTraversal
===============================================

[Markdown 文件]
===============================================
文件: README.md
===============================================
# Morris遍历算法详解与扩展题目

## 什么是Morris遍历

Morris遍历是一种二叉树遍历算法，由Joseph Morris在1979年提出。它能够在不使用递归或栈的情况下，仅使用O(1)的空间复杂度完成二叉树的遍历。

### 核心思想

Morris遍历利用了二叉树中大量存在的空指针（叶子节点的左右指针），通过临时修改这些指针来建立"线索"，从而在遍历过程中能够回溯到父节点，避免使用额外的存储空间。

### 算法步骤

1. 设置当前节点cur指向根节点
2. 当cur不为空时，执行以下操作：
   - 如果cur没有左子树：直接访问cur，然后移动到右子树
   - 如果cur有左子树：
     - 找到cur左子树中的最右节点（前驱节点）
     - 如果前驱节点的右指针为空：建立线索（前驱节点.right = cur），访问cur，移动到左子树
     - 如果前驱节点的右指针指向cur：断开线索（前驱节点.right = null），访问cur，移动到右子树

### 时间和空间复杂度

- 时间复杂度：O(n) - 每个节点最多被访问3次
- 空间复杂度：O(1) - 只使用常数额外空间

## 适用场景

1. 需要节省内存空间的环境
2. 不能修改树结构的场景（遍历后会恢复原状）
3. 面试中展示算法优化能力

## 算法优势

1. **空间效率**：O(1)的空间复杂度，相比递归和栈方法的O(n)更优
2. **结构完整性**：遍历结束后会恢复树的原始结构
3. **实现灵活**：可以实现前序、中序、后序等多种遍历方式
4. **适用性广**：可用于解决多种二叉树相关问题

## 算法劣势

1. **实现复杂**：相比递归实现，代码逻辑更复杂
2. **常数因子较大**：虽然时间复杂度为O(n)，但实际运行可能比递归慢
3. **不适合频繁修改的树**：需要频繁建立和断开线索

## 深入理解Morris遍历

### 如何判断节点的访问次数

在Morris遍历中，一个节点可能被访问一次或两次：
- 没有左子树的节点：只会被访问一次
- 有左子树的节点：会被访问两次
  - 第一次：建立线索时
  - 第二次：断开线索时

### 前序、中序、后序的区别

- **前序遍历**：在第一次访问节点时处理
- **中序遍历**：在第二次访问节点时处理（对于有左子树的节点）或第一次访问时处理（对于没有左子树的节点）
- **后序遍历**：在第二次访问节点时，处理其左子树的右边界，最后处理根节点

## 题目列表

### 基础遍历题目
1. [LeetCode 144. 二叉树的前序遍历](https://leetcode.cn/problems/binary-tree-preorder-traversal/) - 实现二叉树的前序遍历，要求空间复杂度O(1)
2. [LeetCode 94. 二叉树的中序遍历](https://leetcode.cn/problems/binary-tree-inorder-traversal/) - 实现二叉树的中序遍历，要求空间复杂度O(1)
3. [LeetCode 145. 二叉树的后序遍历](https://leetcode.cn/problems/binary-tree-postorder-traversal/) - 实现二叉树的后序遍历，要求空间复杂度O(1)
4. [HackerRank - Tree: Preorder Traversal](https://www.hackerrank.com/challenges/tree-preorder-traversal/problem) - HackerRank平台的前序遍历题目
5. [HackerRank - Tree: Inorder Traversal](https://www.hackerrank.com/challenges/tree-inorder-traversal/problem) - HackerRank平台的中序遍历题目
6. [HackerRank - Tree: Postorder Traversal](https://www.hackerrank.com/challenges/tree-postorder-traversal/problem) - HackerRank平台的后序遍历题目

### 二叉搜索树验证与操作题目
1. [LeetCode 98. 验证二叉搜索树](https://leetcode.cn/problems/validate-binary-search-tree/) - 使用Morris中序遍历验证二叉搜索树
2. [LeetCode 99. 恢复二叉搜索树](https://leetcode.cn/problems/recover-binary-search-tree/) - 恢复被错误交换两个节点的二叉搜索树
3. [LeetCode 173. 二叉搜索树迭代器](https://leetcode.cn/problems/binary-search-tree-iterator/) - 实现二叉搜索树的迭代器，要求O(1)空间
4. [LintCode 95. 验证二叉查找树](https://www.lintcode.com/problem/95/) - LintCode平台的二叉搜索树验证题目
5. [牛客网 - 验证二叉搜索树](https://www.nowcoder.com/practice/a69242b39baf45dea217815c7dedb52b) - 牛客网平台的二叉搜索树验证题目

### 二叉搜索树统计与转换题目
1. [LeetCode 501. 二叉搜索树中的众数](https://leetcode.cn/problems/find-mode-in-binary-search-tree/) - 找出二叉搜索树中出现次数最多的元素
2. [LeetCode 530. 二叉搜索树的最小绝对差](https://leetcode.cn/problems/minimum-absolute-difference-in-bst/) - 找出二叉搜索树中任意两节点的最小绝对差
3. [LeetCode 538. 把二叉搜索树转换为累加树](https://leetcode.cn/problems/convert-bst-to-greater-tree/) - 将二叉搜索树转换为累加树
4. [LeetCode 230. 二叉搜索树中第K小的元素](https://leetcode.cn/problems/kth-smallest-element-in-a-bst/) - 找到二叉搜索树中第K小的元素
5. [AcWing 44. 二叉搜索树的第k大节点](https://www.acwing.com/problem/content/44/) - AcWing平台的二叉搜索树第K大节点题目

### 路径与和相关题目
1. [LeetCode 129. 求根到叶子节点数字之和](https://leetcode.cn/problems/sum-root-to-leaf-numbers/) - 计算从根到叶子节点生成的所有数字之和
2. [LeetCode 257. 二叉树的所有路径](https://leetcode.cn/problems/binary-tree-paths/) - 输出二叉树中所有从根到叶子的路径
3. [LeetCode 113. 路径总和 II](https://leetcode.cn/problems/path-sum-ii/) - 找出所有从根到叶子节点路径总和等于给定目标和的路径
4. [剑指Offer 34. 二叉树中和为某一值的路径](https://leetcode.cn/problems/er-cha-shu-zhong-he-wei-mou-yi-zhi-de-lu-jing-lcof/) - 剑指Offer中的路径总和问题

### 树的属性与结构题目
1. [LeetCode 111. 二叉树的最小深度](https://leetcode.cn/problems/minimum-depth-of-binary-tree/) - 计算二叉树的最小深度
2. [LeetCode 236. 二叉树的最近公共祖先](https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/) - 查找二叉树中两个节点的最近公共祖先
3. [LeetCode 104. 二叉树的最大深度](https://leetcode.cn/problems/maximum-depth-of-binary-tree/) - 计算二叉树的最大深度
4. [洛谷 P1305 新二叉树](https://www.luogu.com.cn/problem/P1305) - 洛谷平台的二叉树遍历题目
5. [UVa 548 - Tree](https://onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=489) - UVa平台的二叉树相关题目

### 其他平台扩展题目
1. [Codeforces 438D - The Child and Sequence](https://codeforces.com/problemset/problem/438/D) - 可使用Morris遍历思想优化的区间操作问题
2. [AtCoder ABC091 C - 2D Plane 2N Points](https://atcoder.jp/contests/abc091/tasks/arc092_a) - 涉及树结构优化的问题
3. [SPOJ TREEORD - Tree Order](https://www.spoj.com/problems/TREEORD/) - SPOJ平台的树遍历顺序问题
4. [杭电OJ 1026 - Ignatius and the Princess I](https://acm.hdu.edu.cn/showproblem.php?pid=1026) - 可应用Morris遍历思想的搜索问题
5. [计蒜客 - 二叉树遍历](https://nanti.jisuanke.com/t/41093) - 计蒜客平台的二叉树遍历题目
6. [MarsCode - Binary Tree Traversal](https://www.mars.codeforces.com/problemset/problem/102/B) - MarsCode平台的二叉树遍历题目
7. [TimusOJ 1602 - Cabriolet](https://acm.timus.ru/problem.aspx?space=1&num=1602) - 可应用树遍历思想的问题
8. [AizuOJ ALDS1_7_B - Tree](https://onlinejudge.u-aizu.ac.jp/problems/ALDS1_7_B) - AizuOJ平台的树结构问题
9. [Comet OJ C1013 - 二叉树的遍历](https://cometoj.com/contest/34/problem/C1013?problem_id=473) - Comet OJ平台的二叉树遍历题目
10. [POJ 3667 - Hotel](https://poj.org/problem?id=3667) - 可使用类似Morris遍历思想的线段树问题

### 补充题目列表
1. [LeetCode 100. 相同的树](https://leetcode.cn/problems/same-tree/) - 判断两个二叉树是否相同
2. [LeetCode 101. 对称二叉树](https://leetcode.cn/problems/symmetric-tree/) - 判断二叉树是否对称
3. [LeetCode 102. 二叉树的层序遍历](https://leetcode.cn/problems/binary-tree-level-order-traversal/) - 二叉树的层序遍历
4. [LeetCode 103. 二叉树的锯齿形层序遍历](https://leetcode.cn/problems/binary-tree-zigzag-level-order-traversal/) - 二叉树的锯齿形层序遍历
5. [LeetCode 105. 从前序与中序遍历序列构造二叉树](https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/) - 根据前序和中序遍历构造二叉树
6. [LeetCode 106. 从中序与后序遍历序列构造二叉树](https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/) - 根据中序和后序遍历构造二叉树
7. [LeetCode 107. 二叉树的层序遍历 II](https://leetcode.cn/problems/binary-tree-level-order-traversal-ii/) - 自底向上的层序遍历
8. [LeetCode 108. 将有序数组转换为二叉搜索树](https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/) - 将有序数组转换为高度平衡的二叉搜索树
9. [LeetCode 110. 平衡二叉树](https://leetcode.cn/problems/balanced-binary-tree/) - 判断二叉树是否为平衡二叉树
10. [LeetCode 112. 路径总和](https://leetcode.cn/problems/path-sum/) - 判断二叉树中是否存在根节点到叶子节点的路径总和等于目标值
11. [LeetCode 114. 二叉树展开为链表](https://leetcode.cn/problems/flatten-binary-tree-to-linked-list/) - 将二叉树展开为单链表
12. [LeetCode 116. 填充每个节点的下一个右侧节点指针](https://leetcode.cn/problems/populating-next-right-pointers-in-each-node/) - 填充完美二叉树的next指针
13. [LeetCode 117. 填充每个节点的下一个右侧节点指针 II](https://leetcode.cn/problems/populating-next-right-pointers-in-each-node-ii/) - 填充任意二叉树的next指针
14. [LeetCode 124. 二叉树中的最大路径和](https://leetcode.cn/problems/binary-tree-maximum-path-sum/) - 找到二叉树中的最大路径和
15. [LeetCode 199. 二叉树的右视图](https://leetcode.cn/problems/binary-tree-right-side-view/) - 二叉树的右视图
16. [LeetCode 222. 完全二叉树的节点个数](https://leetcode.cn/problems/count-complete-tree-nodes/) - 计算完全二叉树的节点个数
17. [LeetCode 226. 翻转二叉树](https://leetcode.cn/problems/invert-binary-tree/) - 翻转二叉树
18. [LeetCode 235. 二叉搜索树的最近公共祖先](https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-search-tree/) - 二叉搜索树的最近公共祖先
19. [LeetCode 297. 二叉树的序列化与反序列化](https://leetcode.cn/problems/serialize-and-deserialize-binary-tree/) - 二叉树的序列化与反序列化
20. [LeetCode 404. 左叶子之和](https://leetcode.cn/problems/sum-of-left-leaves/) - 计算左叶子节点的和
21. [LeetCode 437. 路径总和 III](https://leetcode.cn/problems/path-sum-iii/) - 计算路径总和III
22. [LeetCode 543. 二叉树的直径](https://leetcode.cn/problems/diameter-of-binary-tree/) - 计算二叉树的直径
23. [LeetCode 563. 二叉树的坡度](https://leetcode.cn/problems/binary-tree-tilt/) - 计算二叉树的坡度
24. [LeetCode 572. 另一棵树的子树](https://leetcode.cn/problems/subtree-of-another-tree/) - 判断是否为另一棵树的子树
25. [LeetCode 617. 合并二叉树](https://leetcode.cn/problems/merge-two-binary-trees/) - 合并两棵二叉树
26. [LeetCode 637. 二叉树的层平均值](https://leetcode.cn/problems/average-of-levels-in-binary-tree/) - 计算二叉树每层的平均值
27. [LeetCode 654. 最大二叉树](https://leetcode.cn/problems/maximum-binary-tree/) - 构造最大二叉树
28. [LeetCode 669. 修剪二叉搜索树](https://leetcode.cn/problems/trim-a-binary-search-tree/) - 修剪二叉搜索树
29. [LeetCode 700. 二叉搜索树中的搜索](https://leetcode.cn/problems/search-in-a-binary-search-tree/) - 在二叉搜索树中搜索节点
30. [LeetCode 701. 二叉搜索树中的插入操作](https://leetcode.cn/problems/insert-into-a-binary-search-tree/) - 在二叉搜索树中插入节点

## 更多以Morris遍历为最优解的题目

### 高级应用题目
1. [LeetCode 96. 不同的二叉搜索树](https://leetcode.cn/problems/unique-binary-search-trees/) - 计算不同二叉搜索树的个数（可结合Morris遍历优化）
2. [LeetCode 95. 不同的二叉搜索树 II](https://leetcode.cn/problems/unique-binary-search-trees-ii/) - 生成所有不同的二叉搜索树
3. [LeetCode 173. 二叉搜索树迭代器](https://leetcode.cn/problems/binary-search-tree-iterator/) - 实现BST迭代器（Morris遍历实现空间最优）
4. [LeetCode 285. 二叉搜索树中的中序后继](https://leetcode.cn/problems/inorder-successor-in-bst/) - 找到BST中指定节点的中序后继
5. [LeetCode 510. 二叉搜索树中的中序后继 II](https://leetcode.cn/problems/inorder-successor-in-bst-ii/) - 在有父指针的BST中找中序后继
6. [LeetCode 270. 最接近的二叉搜索树值](https://leetcode.cn/problems/closest-binary-search-tree-value/) - 找到BST中最接近目标值的节点
7. [LeetCode 272. 最接近的二叉搜索树值 II](https://leetcode.cn/problems/closest-binary-search-tree-value-ii/) - 找到BST中k个最接近目标值的节点
8. [LeetCode 333. 最大BST子树](https://leetcode.cn/problems/largest-bst-subtree/) - 找到二叉树中最大的BST子树
9. [LeetCode 450. 删除二叉搜索树中的节点](https://leetcode.cn/problems/delete-node-in-a-bst/) - 删除BST中的节点
10. [LeetCode 703. 数据流中的第K大元素](https://leetcode.cn/problems/kth-largest-element-in-a-stream/) - 数据流中的第K大元素（可结合BST思想）

### 牛客网题目
1. [牛客网 - 二叉树的中序遍历](https://www.nowcoder.com/practice/0bf071c135e64ee2a027783b80bf781d) - 牛客网平台的二叉树中序遍历题目
2. [牛客网 - 二叉树遍历](https://www.nowcoder.com/practice/4b91205483694f449f94c179883c1fef) - 牛客网平台的二叉树遍历题目
3. [牛客网 - 求二叉树的层序遍历](https://www.nowcoder.com/practice/04a5560e43e24e9db4595865dc9c63a3) - 牛客网平台的二叉树层序遍历题目
4. [牛客网 - 二叉搜索树中第K小的元素](https://www.nowcoder.com/practice/ef068f602dde4d28aab4beb7d3c38f79) - 牛客网平台的BST第K小元素题目

### 洛谷题目
1. [洛谷 P1305 新二叉树](https://www.luogu.com.cn/problem/P1305) - 洛谷平台的二叉树遍历题目
2. [洛谷 P1030 [NOIP2001 普及组] 求先序排列](https://www.luogu.com.cn/problem/P1030) - 根据中序和后序求先序排列
3. [洛谷 P1827 [USACO3.4] 美国血统 American Heritage](https://www.luogu.com.cn/problem/P1827) - 根据中序和前序构造二叉树
4. [洛谷 P1304 姐妹省市](https://www.luogu.com.cn/problem/P1304) - 二叉树相关问题

### Codeforces题目
1. [Codeforces 438D - The Child and Sequence](https://codeforces.com/problemset/problem/438/D) - 可使用Morris遍历思想优化的区间操作问题
2. [Codeforces 620E - New Year Tree](https://codeforces.com/problemset/problem/620/E) - 树的染色问题
3. [Codeforces 763A - Timofey and a tree](https://codeforces.com/problemset/problem/763/A) - 树的重构问题

### AtCoder题目
1. [AtCoder ABC091 C - 2D Plane 2N Points](https://atcoder.jp/contests/abc091/tasks/arc092_a) - 涉及树结构优化的问题
2. [AtCoder ABC133 F - Colorful Tree](https://atcoder.jp/contests/abc133/tasks/abc133_f) - 树上路径颜色查询问题

### SPOJ题目
1. [SPOJ TREEORD - Tree Order](https://www.spoj.com/problems/TREEORD/) - SPOJ平台的树遍历顺序问题
2. [SPOJ QTREE - Query on a tree](https://www.spoj.com/problems/QTREE/) - 树上路径查询问题

### 其他平台题目
1. [HackerRank - Is This a Binary Search Tree?](https://www.hackerrank.com/challenges/is-binary-search-tree/problem) - 验证BST
2. [HackerRank - Swap Nodes](https://www.hackerrank.com/challenges/swap-nodes-algo/problem) - 交换节点问题
3. [UVa 122 - Trees on the level](https://onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=58) - 层级树构建问题
4. [POJ 2255 - Tree Recovery](http://poj.org/problem?id=2255) - 根据前序和中序恢复二叉树
5. [ZOJ 1086 - Octal Fractions](https://zoj.pintia.cn/problem-sets/91827364500/problems/91827365585) - 二叉树相关问题
6. [计蒜客 - 二叉树遍历](https://nanti.jisuanke.com/t/41093) - 计蒜客平台的二叉树遍历题目
7. [杭电OJ 1710 - Binary Tree Traversals](https://acm.hdu.edu.cn/showproblem.php?pid=1710) - 根据前序和中序构造二叉树
8. [AizuOJ ALDS1_7_C - Tree Walk](https://onlinejudge.u-aizu.ac.jp/problems/ALDS1_7_C) - 树的遍历问题

## 如何选择Morris遍历

在解决二叉树问题时，以下情况适合使用Morris遍历：

1. **空间受限环境**：当内存资源有限，无法使用O(n)空间的递归或栈方法时
2. **大规模数据**：处理非常大的树时，Morris遍历的空间优势更加明显
3. **单次遍历**：只需要遍历一次树就能完成的操作
4. **面试展示**：在面试中展示对高级算法的掌握，体现优化意识

## 代码优化建议

1. **边界情况处理**：始终处理空树、单节点树等边界情况
2. **线索恢复**：确保遍历结束后恢复树的原始结构
3. **变量命名**：使用清晰的变量名，如cur、mostRight等，提高代码可读性
4. **模块化**：将Morris遍历的核心逻辑封装成单独的函数，便于复用
5. **注释完善**：添加详细注释，解释算法原理和关键步骤

## 与其他遍历方法的比较

| 遍历方法 | 时间复杂度 | 空间复杂度 | 实现难度 | 适用场景 |
|---------|-----------|-----------|---------|----------|
| 递归遍历 | O(n) | O(h)，h为树高 | 简单 | 大多数场景，代码简洁 |
| 栈遍历 | O(n) | O(h)，h为树高 | 中等 | 不允许递归的场景 |
| Morris遍历 | O(n) | O(1) | 复杂 | 空间受限的场景，面试展示 |

## 总结

Morris遍历是一种巧妙的二叉树遍历算法，通过利用树中的空指针建立线索，实现了O(1)空间复杂度的二叉树遍历。虽然实现较为复杂，但在空间受限的场景下具有显著优势。掌握Morris遍历不仅有助于解决特定的算法问题，也能培养对算法优化的深入理解。

在实际应用中，我们需要根据具体问题的要求，权衡代码复杂度和空间效率，选择最适合的遍历方法。对于大多数日常编程任务，递归或栈遍历可能更为实用；但在面试或特定的性能优化场景中，Morris遍历无疑是展示算法深度的绝佳选择。

===============================================

文件: SUMMARY.md
===============================================
# Morris遍历算法总结

## 算法核心思想

Morris遍历是一种高效的二叉树遍历算法，其核心思想是利用树中空闲的指针来建立线索，从而避免使用额外的栈或递归空间。

## 算法特点

### 优势
1. **空间复杂度O(1)**：不使用递归或栈，仅使用常数额外空间
2. **时间复杂度O(n)**：每个节点最多访问3次
3. **原地算法**：遍历过程中会临时修改树结构，但最终会恢复

### 劣势
1. **实现复杂**：相比递归和迭代实现更加复杂
2. **不适用于并发环境**：遍历过程中会修改树结构
3. **仅适用于遍历**：对于需要复杂信息聚合的问题不适用

## 三种遍历方式的Morris实现

### 前序遍历
```java
public static void morrisPreorder(TreeNode head, List<Integer> ans) {
    TreeNode cur = head;
    TreeNode mostRight = null;
    while (cur != null) {
        mostRight = cur.left;
        if (mostRight != null) {
            while (mostRight.right != null && mostRight.right != cur) {
                mostRight = mostRight.right;
            }
            if (mostRight.right == null) {
                ans.add(cur.val);  // 第一次到达就打印
                mostRight.right = cur;
                cur = cur.left;
                continue;
            } else {
                mostRight.right = null;
            }
        } else {
            ans.add(cur.val);  // 没有左子树直接打印
        }
        cur = cur.right;
    }
}
```

### 中序遍历
```java
public static void morrisInorder(TreeNode head, List<Integer> ans) {
    TreeNode cur = head;
    TreeNode mostRight = null;
    while (cur != null) {
        mostRight = cur.left;
        if (mostRight != null) {
            while (mostRight.right != null && mostRight.right != cur) {
                mostRight = mostRight.right;
            }
            if (mostRight.right == null) {
                mostRight.right = cur;
                cur = cur.left;
                continue;
            } else {
                mostRight.right = null;
            }
        }
        ans.add(cur.val);  // 第二次到达才打印
        cur = cur.right;
    }
}
```

### 后序遍历
```java
public static void morrisPostorder(TreeNode head, List<Integer> ans) {
    TreeNode cur = head;
    TreeNode mostRight = null;
    while (cur != null) {
        mostRight = cur.left;
        if (mostRight != null) {
            while (mostRight.right != null && mostRight.right != cur) {
                mostRight = mostRight.right;
            }
            if (mostRight.right == null) {
                mostRight.right = cur;
                cur = cur.left;
                continue;
            } else {
                mostRight.right = null;
                collect(cur.left, ans);  // 收集左子树右边界逆序
            }
        }
        cur = cur.right;
    }
    collect(head, ans);  // 收集整棵树右边界逆序
}
```

## 适用场景总结

### 适合使用Morris遍历的场景
1. **内存受限环境**：无法使用O(h)空间的递归或栈实现
2. **需要线性遍历**：如验证BST、找最小深度等
3. **面试展示**：展示对算法优化的深入理解

### 不适合使用Morris遍历的场景
1. **需要复杂信息聚合**：如最大路径和、树的直径等
2. **并发环境**：遍历过程中会修改树结构
3. **需要保持树结构不变**：某些场景下不能临时修改树结构

## 语言特性差异

### Java
- 对象引用机制便于线索的建立和断开
- 异常处理机制完善
- 垃圾回收机制无需手动管理内存

### Python
- 动态类型系统，代码更简洁
- 列表推导式便于结果收集
- 无显式指针操作，通过属性访问实现

### C++
- 指针操作更直接
- 需要手动管理内存
- 性能通常优于解释型语言

## 工程化考量

### 异常处理
1. 空树和单节点树的边界情况处理
2. 输入参数的有效性检查
3. 遍历过程中节点指针的正确性维护

### 性能优化
1. 避免重复计算最右节点
2. 合理安排节点访问顺序
3. 及时断开线索避免死循环

### 可维护性
1. 详细注释说明算法每一步的作用
2. 变量命名清晰表达其含义
3. 代码结构模块化，便于理解和修改

## 常见问题和解决方案

### 1. 线索未正确断开导致死循环
**问题**：在遍历过程中，如果线索没有正确断开，可能导致无限循环。
**解决方案**：确保每次建立线索后，在第二次到达时正确断开。

### 2. 遍历顺序错误
**问题**：前序、中序、后序遍历的访问时机容易混淆。
**解决方案**：明确每种遍历方式的访问时机，第一次还是第二次到达节点时访问。

### 3. 结果收集错误（后序遍历）
**问题**：后序遍历需要逆序收集右边界，容易出错。
**解决方案**：使用链表翻转技术，先翻转再收集，最后再翻转恢复。

## 扩展应用

### 1. 验证BST
通过中序遍历检查序列是否有序

### 2. 找最小深度
通过遍历过程计算节点所在层数

### 3. 找最近公共祖先
结合遍历过程中的节点访问顺序

### 4. 恢复BST
通过遍历找到逆序对并修复

### 5. BST迭代器
利用Morris遍历的暂停和恢复特性

### 6. 找BST中的众数
利用BST中序遍历的有序性，统计相同元素的出现次数

### 7. 求根到叶节点数字之和
在Morris前序遍历过程中维护路径数字，到达叶节点时累加

### 8. BST转换为累加树
通过Morris反向中序遍历（右-根-左）维护累加和

### 9. BST的最小绝对差
利用BST中序遍历的有序性，计算相邻节点值的最小差值

## 更多相关题目

### 基础遍历题目
1. [LeetCode 144. 二叉树的前序遍历](https://leetcode.cn/problems/binary-tree-preorder-traversal/)
2. [LeetCode 94. 二叉树的中序遍历](https://leetcode.cn/problems/binary-tree-inorder-traversal/)
3. [LeetCode 145. 二叉树的后序遍历](https://leetcode.cn/problems/binary-tree-postorder-traversal/)

### 二叉搜索树相关题目
1. [LeetCode 98. 验证二叉搜索树](https://leetcode.cn/problems/validate-binary-search-tree/)
2. [LeetCode 501. 二叉搜索树中的众数](https://leetcode.cn/problems/find-mode-in-binary-search-tree/)
3. [LeetCode 530. 二叉搜索树的最小绝对差](https://leetcode.cn/problems/minimum-absolute-difference-in-bst/)
4. [LeetCode 538. 把二叉搜索树转换为累加树](https://leetcode.cn/problems/convert-bst-to-greater-tree/)
5. [LeetCode 230. 二叉搜索树中第K小的元素](https://leetcode.cn/problems/kth-smallest-element-in-a-bst/)

### 路径与和相关题目
1. [LeetCode 129. 求根到叶子节点数字之和](https://leetcode.cn/problems/sum-root-to-leaf-numbers/)
2. [LeetCode 257. 二叉树的所有路径](https://leetcode.cn/problems/binary-tree-paths/)
3. [LeetCode 113. 路径总和 II](https://leetcode.cn/problems/path-sum-ii/)
4. [LeetCode 112. 路径总和](https://leetcode.cn/problems/path-sum/)
5. [LeetCode 437. 路径总和 III](https://leetcode.cn/problems/path-sum-iii/)

### 树的属性与结构题目
1. [LeetCode 111. 二叉树的最小深度](https://leetcode.cn/problems/minimum-depth-of-binary-tree/)
2. [LeetCode 104. 二叉树的最大深度](https://leetcode.cn/problems/maximum-depth-of-binary-tree/)
3. [LeetCode 110. 平衡二叉树](https://leetcode.cn/problems/balanced-binary-tree/)
4. [LeetCode 543. 二叉树的直径](https://leetcode.cn/problems/diameter-of-binary-tree/)
5. [LeetCode 222. 完全二叉树的节点个数](https://leetcode.cn/problems/count-complete-tree-nodes/)

### 高级应用题目
1. [LeetCode 96. 不同的二叉搜索树](https://leetcode.cn/problems/unique-binary-search-trees/) - 计算不同二叉搜索树的个数（可结合Morris遍历优化）
2. [LeetCode 95. 不同的二叉搜索树 II](https://leetcode.cn/problems/unique-binary-search-trees-ii/) - 生成所有不同的二叉搜索树
3. [LeetCode 173. 二叉搜索树迭代器](https://leetcode.cn/problems/binary-search-tree-iterator/) - 实现BST迭代器（Morris遍历实现空间最优）
4. [LeetCode 285. 二叉搜索树中的中序后继](https://leetcode.cn/problems/inorder-successor-in-bst/) - 找到BST中指定节点的中序后继
5. [LeetCode 510. 二叉搜索树中的中序后继 II](https://leetcode.cn/problems/inorder-successor-in-bst-ii/) - 在有父指针的BST中找中序后继
6. [LeetCode 270. 最接近的二叉搜索树值](https://leetcode.cn/problems/closest-binary-search-tree-value/) - 找到BST中最接近目标值的节点
7. [LeetCode 272. 最接近的二叉搜索树值 II](https://leetcode.cn/problems/closest-binary-search-tree-value-ii/) - 找到BST中k个最接近目标值的节点
8. [LeetCode 333. 最大BST子树](https://leetcode.cn/problems/largest-bst-subtree/) - 找到二叉树中最大的BST子树
9. [LeetCode 450. 删除二叉搜索树中的节点](https://leetcode.cn/problems/delete-node-in-a-bst/) - 删除BST中的节点
10. [LeetCode 703. 数据流中的第K大元素](https://leetcode.cn/problems/kth-largest-element-in-a-stream/) - 数据流中的第K大元素（可结合BST思想）

### 牛客网题目
1. [牛客网 - 二叉树的中序遍历](https://www.nowcoder.com/practice/0bf071c135e64ee2a027783b80bf781d) - 牛客网平台的二叉树中序遍历题目
2. [牛客网 - 二叉树遍历](https://www.nowcoder.com/practice/4b91205483694f449f94c179883c1fef) - 牛客网平台的二叉树遍历题目
3. [牛客网 - 求二叉树的层序遍历](https://www.nowcoder.com/practice/04a5560e43e24e9db4595865dc9c63a3) - 牛客网平台的二叉树层序遍历题目
4. [牛客网 - 二叉搜索树中第K小的元素](https://www.nowcoder.com/practice/ef068f602dde4d28aab4beb7d3c38f79) - 牛客网平台的BST第K小元素题目

### 洛谷题目
1. [洛谷 P1305 新二叉树](https://www.luogu.com.cn/problem/P1305) - 洛谷平台的二叉树遍历题目
2. [洛谷 P1030 [NOIP2001 普及组] 求先序排列](https://www.luogu.com.cn/problem/P1030) - 根据中序和后序求先序排列
3. [洛谷 P1827 [USACO3.4] 美国血统 American Heritage](https://www.luogu.com.cn/problem/P1827) - 根据中序和前序构造二叉树
4. [洛谷 P1304 姐妹省市](https://www.luogu.com.cn/problem/P1304) - 二叉树相关问题

### Codeforces题目
1. [Codeforces 438D - The Child and Sequence](https://codeforces.com/problemset/problem/438/D) - 可使用Morris遍历思想优化的区间操作问题
2. [Codeforces 620E - New Year Tree](https://codeforces.com/problemset/problem/620/E) - 树的染色问题
3. [Codeforces 763A - Timofey and a tree](https://codeforces.com/problemset/problem/763/A) - 树的重构问题

### AtCoder题目
1. [AtCoder ABC091 C - 2D Plane 2N Points](https://atcoder.jp/contests/abc091/tasks/arc092_a) - 涉及树结构优化的问题
2. [AtCoder ABC133 F - Colorful Tree](https://atcoder.jp/contests/abc133/tasks/abc133_f) - 树上路径颜色查询问题

### SPOJ题目
1. [SPOJ TREEORD - Tree Order](https://www.spoj.com/problems/TREEORD/) - SPOJ平台的树遍历顺序问题
2. [SPOJ QTREE - Query on a tree](https://www.spoj.com/problems/QTREE/) - 树上路径查询问题

### 其他平台扩展题目
1. [Codeforces 438D - The Child and Sequence](https://codeforces.com/problemset/problem/438/D)
2. [AtCoder ABC091 C - 2D Plane 2N Points](https://atcoder.jp/contests/abc091/tasks/arc092_a)
3. [SPOJ TREEORD - Tree Order](https://www.spoj.com/problems/TREEORD/)
4. [杭电OJ 1026 - Ignatius and the Princess I](https://acm.hdu.edu.cn/showproblem.php?pid=1026)
5. [计蒜客 - 二叉树遍历](https://nanti.jisuanke.com/t/41093)
6. [MarsCode - Binary Tree Traversal](https://www.mars.codeforces.com/problemset/problem/102/B)
7. [TimusOJ 1602 - Cabriolet](https://acm.timus.ru/problem.aspx?space=1&num=1602)
8. [AizuOJ ALDS1_7_B - Tree](https://onlinejudge.u-aizu.ac.jp/problems/ALDS1_7_B)
9. [Comet OJ C1013 - 二叉树的遍历](https://cometoj.com/contest/34/problem/C1013?problem_id=473)
10. [POJ 3667 - Hotel](https://poj.org/problem?id=3667)
11. [HackerRank - Is This a Binary Search Tree?](https://www.hackerrank.com/challenges/is-binary-search-tree/problem) - 验证BST
12. [HackerRank - Swap Nodes](https://www.hackerrank.com/challenges/swap-nodes-algo/problem) - 交换节点问题
13. [UVa 122 - Trees on the level](https://onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=58) - 层级树构建问题
14. [POJ 2255 - Tree Recovery](http://poj.org/problem?id=2255) - 根据前序和中序恢复二叉树
15. [ZOJ 1086 - Octal Fractions](https://zoj.pintia.cn/problem-sets/91827364500/problems/91827365585) - 二叉树相关问题
16. [计蒜客 - 二叉树遍历](https://nanti.jisuanke.com/t/41093) - 计蒜客平台的二叉树遍历题目
17. [杭电OJ 1710 - Binary Tree Traversals](https://acm.hdu.edu.cn/showproblem.php?pid=1710) - 根据前序和中序构造二叉树
18. [AizuOJ ALDS1_7_C - Tree Walk](https://onlinejudge.u-aizu.ac.jp/problems/ALDS1_7_C) - 树的遍历问题

## 总结

Morris遍历是一种非常巧妙的算法，它通过利用树中空闲的指针来实现O(1)空间复杂度的遍历。虽然实现相对复杂，但在特定场景下具有显著优势。掌握Morris遍历不仅有助于解决特定问题，更能加深对二叉树结构和遍历算法的理解。

===============================================

[代码文件]
===============================================
文件: Code01_MorrisPreorderInorder.cpp
===============================================
/**
 * Morris遍历实现先序和中序遍历 - C++版本
 * 
 * 题目来源：
 * - 先序遍历：LeetCode 144. Binary Tree Preorder Traversal
 *   链接：https://leetcode.cn/problems/binary-tree-preorder-traversal/
 * - 中序遍历：LeetCode 94. Binary Tree Inorder Traversal
 *   链接：https://leetcode.cn/problems/binary-tree-inorder-traversal/
 * 
 * Morris遍历是一种空间复杂度为O(1)的二叉树遍历算法，通过临时修改树的结构（利用叶子节点的空闲指针）
 * 来避免使用栈或递归调用栈所需的额外空间。算法的核心思想是将树转换为一个线索二叉树。
 * 
 * 本实现包含：
 * 1. C++语言的Morris先序和中序遍历
 * 2. 递归版本的先序和中序遍历
 * 3. 迭代版本的先序和中序遍历
 * 4. 详细的注释和算法解析
 * 5. 完整的测试用例（常规树、空树、单节点树、链表结构树等）
 * 6. 性能测试和算法对比
 * 
 * 算法详解：
 * Morris遍历的核心思想是利用二叉树中大量空闲的空指针来存储遍历所需的路径信息，从而避免使用栈或递归调用栈所需的额外空间
 * 1. 线索化：对于每个有左子树的节点，将其左子树的最右节点的右指针指向该节点本身，形成一个临时的线索
 * 2. 两次访问：第一次访问节点时建立线索，第二次访问节点时删除线索并处理右子树
 * 3. 还原树结构：每次访问完节点后，都会恢复树的原始结构，不影响后续操作
 * 
 * 时间复杂度：O(n)，虽然每个节点可能被访问两次，但总体操作次数仍是线性的
 * 空间复杂度：O(1)，只使用了常数级别的额外空间
 * 适用场景：内存受限环境、嵌入式系统、超大二叉树遍历
 * 
 * 优缺点分析：
 * - 优点：空间复杂度最优，不依赖栈或递归调用栈
 * - 缺点：实现复杂，修改树结构，不适合并发环境
 * 
 * 编译命令：g++ -std=c++17 -O2 Code01_MorrisPreorderInorder.cpp -o morris_traversal
 * 运行命令：./morris_traversal
 */

#include <iostream>
#include <vector>
#include <stack>
#include <algorithm>
#include <memory>

using namespace std;

// 二叉树节点定义
struct TreeNode {
    int val;
    TreeNode* left;
    TreeNode* right;
    
    TreeNode() : val(0), left(nullptr), right(nullptr) {}
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
    TreeNode(int x, TreeNode* left, TreeNode* right) : val(x), left(left), right(right) {}
};

class Code01_MorrisPreorderInorder {
public:
    /**
     * Morris遍历实现先序遍历
     * 
     * 先序遍历顺序：根-左-右
     * 在Morris遍历中的实现：
     * - 第一次访问节点时就收集值（适合先序遍历）
     * - 如果节点没有左子树，则在第一次访问时直接收集
     *
     * @param root 二叉树的根节点
     * @return 先序遍历的节点值列表
     * 
     * 时间复杂度：O(n) - 每个节点最多被访问3次，总时间线性
     * 空间复杂度：O(1) - 不考虑返回值的空间占用
     * 
     * 算法步骤：
     * 1. 初始化当前节点cur为根节点
     * 2. 当cur不为null时：
     *    a. 如果cur没有左子树，收集cur的值，cur移动到其右子树
     *    b. 如果cur有左子树：
     *       i. 找到cur左子树的最右节点mostRight
     *       ii. 如果mostRight的right指针为null（第一次访问cur）：
     *           - 收集cur的值（先序遍历特性）
     *           - 将mostRight的right指向cur
     *           - cur移动到其左子树
     *       iii. 如果mostRight的right指针指向cur（第二次访问cur）：
     *           - 将mostRight的right恢复为null
     *           - cur移动到其右子树
     */
    vector<int> preorderTraversal(TreeNode* root) {
        vector<int> result;
        // 防御性编程：处理空树情况
        if (root == nullptr) {
            return result;
        }
        
        TreeNode* cur = root;
        TreeNode* mostRight = nullptr;
        
        while (cur != nullptr) {
            mostRight = cur->left;
            if (mostRight != nullptr) {
                // 找到左子树的最右节点
                while (mostRight->right != nullptr && mostRight->right != cur) {
                    mostRight = mostRight->right;
                }
                
                if (mostRight->right == nullptr) {
                    // 第一次访问cur节点
                    result.push_back(cur->val);  // 先序遍历：第一次访问时收集
                    mostRight->right = cur;     // 建立线索
                    cur = cur->left;            // 继续遍历左子树
                    continue;
                } else {
                    // 第二次访问cur节点
                    mostRight->right = nullptr;  // 恢复树的原始结构
                }
            } else {
                // cur没有左子树，只有一次访问机会
                result.push_back(cur->val);     // 收集当前节点值
            }
            cur = cur->right;  // 移动到右子树
        }
        
        return result;
    }
    
    /**
     * Morris遍历实现中序遍历
     * 
     * 中序遍历顺序：左-根-右
     * 在Morris遍历中的实现：
     * - 第二次访问节点时收集值（适合中序遍历）
     * - 如果节点没有左子树，则在访问时直接收集
     *
     * @param root 二叉树的根节点
     * @return 中序遍历的节点值列表
     * 
     * 时间复杂度：O(n) - 每个节点最多被访问3次，总时间线性
     * 空间复杂度：O(1) - 不考虑返回值的空间占用
     * 
     * 算法步骤：
     * 1. 初始化当前节点cur为根节点
     * 2. 当cur不为null时：
     *    a. 如果cur没有左子树，收集cur的值，cur移动到其右子树
     *    b. 如果cur有左子树：
     *       i. 找到cur左子树的最右节点mostRight
     *       ii. 如果mostRight的right指针为null（第一次访问cur）：
     *           - 将mostRight的right指向cur
     *           - cur移动到其左子树
     *       iii. 如果mostRight的right指针指向cur（第二次访问cur）：
     *           - 收集cur的值（中序遍历特性）
     *           - 将mostRight的right恢复为null
     *           - cur移动到其右子树
     */
    vector<int> inorderTraversal(TreeNode* root) {
        vector<int> result;
        // 防御性编程：处理空树情况
        if (root == nullptr) {
            return result;
        }
        
        TreeNode* cur = root;
        TreeNode* mostRight = nullptr;
        
        while (cur != nullptr) {
            mostRight = cur->left;
            if (mostRight != nullptr) {
                // 找到左子树的最右节点
                while (mostRight->right != nullptr && mostRight->right != cur) {
                    mostRight = mostRight->right;
                }
                
                if (mostRight->right == nullptr) {
                    // 第一次访问cur节点
                    mostRight->right = cur;     // 建立线索
                    cur = cur->left;            // 继续遍历左子树
                    continue;
                } else {
                    // 第二次访问cur节点
                    mostRight->right = nullptr;  // 恢复树的原始结构
                    result.push_back(cur->val);  // 中序遍历：第二次访问时收集
                }
            } else {
                // cur没有左子树，只有一次访问机会
                result.push_back(cur->val);     // 收集当前节点值
            }
            cur = cur->right;  // 移动到右子树
        }
        
        return result;
    }
    
    /**
     * 递归实现先序遍历（对比参考）
     * 
     * @param root 二叉树的根节点
     * @param result 存储遍历结果的向量
     * 
     * 时间复杂度：O(n) - 每个节点访问一次
     * 空间复杂度：O(h) - h为树高，最坏情况下为O(n)
     */
    void preorderRecursive(TreeNode* root, vector<int>& result) {
        if (root == nullptr) {
            return;
        }
        result.push_back(root->val);      // 访问根节点
        preorderRecursive(root->left, result);  // 遍历左子树
        preorderRecursive(root->right, result); // 遍历右子树
    }
    
    /**
     * 递归实现中序遍历（对比参考）
     * 
     * @param root 二叉树的根节点
     * @param result 存储遍历结果的向量
     * 
     * 时间复杂度：O(n) - 每个节点访问一次
     * 空间复杂度：O(h) - h为树高，最坏情况下为O(n)
     */
    void inorderRecursive(TreeNode* root, vector<int>& result) {
        if (root == nullptr) {
            return;
        }
        inorderRecursive(root->left, result);  // 遍历左子树
        result.push_back(root->val);      // 访问根节点
        inorderRecursive(root->right, result); // 遍历右子树
    }
    
    /**
     * 迭代实现先序遍历（对比参考）
     * 
     * @param root 二叉树的根节点
     * @return 先序遍历的节点值列表
     * 
     * 时间复杂度：O(n) - 每个节点访问一次
     * 空间复杂度：O(h) - h为树高，最坏情况下为O(n)
     */
    vector<int> preorderIterative(TreeNode* root) {
        vector<int> result;
        if (root == nullptr) {
            return result;
        }
        
        stack<TreeNode*> stk;
        stk.push(root);
        
        while (!stk.empty()) {
            TreeNode* node = stk.top();
            stk.pop();
            result.push_back(node->val);
            
            // 先右后左，保证左子树先出栈
            if (node->right != nullptr) {
                stk.push(node->right);
            }
            if (node->left != nullptr) {
                stk.push(node->left);
            }
        }
        
        return result;
    }
    
    /**
     * 迭代实现中序遍历（对比参考）
     * 
     * @param root 二叉树的根节点
     * @return 中序遍历的节点值列表
     * 
     * 时间复杂度：O(n) - 每个节点访问一次
     * 空间复杂度：O(h) - h为树高，最坏情况下为O(n)
     */
    vector<int> inorderIterative(TreeNode* root) {
        vector<int> result;
        stack<TreeNode*> stk;
        TreeNode* cur = root;
        
        while (cur != nullptr || !stk.empty()) {
            // 一直向左遍历，直到叶子节点
            while (cur != nullptr) {
                stk.push(cur);
                cur = cur->left;
            }
            
            cur = stk.top();
            stk.pop();
            result.push_back(cur->val);
            cur = cur->right;
        }
        
        return result;
    }
    
    /**
     * 创建测试二叉树
     * 构建如下二叉树：
     *       1
     *      / \
     *     2   3
     *    / \
     *   4   5
     */
    TreeNode* createTestTree() {
        TreeNode* root = new TreeNode(1);
        root->left = new TreeNode(2);
        root->right = new TreeNode(3);
        root->left->left = new TreeNode(4);
        root->left->right = new TreeNode(5);
        return root;
    }
    
    /**
     * 释放二叉树内存
     */
    void deleteTree(TreeNode* root) {
        if (root == nullptr) {
            return;
        }
        deleteTree(root->left);
        deleteTree(root->right);
        delete root;
    }
    
    /**
     * 打印向量内容
     */
    void printVector(const vector<int>& vec, const string& label) {
        cout << label << ": ";
        for (int val : vec) {
            cout << val << " ";
        }
        cout << endl;
    }
    
    /**
     * 运行测试用例
     */
    void runTests() {
        cout << "=== Morris遍历算法测试 ===" << endl;
        
        // 测试用例1：常规二叉树
        cout << "\n测试用例1：常规二叉树" << endl;
        TreeNode* root1 = createTestTree();
        
        vector<int> preorderMorris = preorderTraversal(root1);
        vector<int> inorderMorris = inorderTraversal(root1);
        
        printVector(preorderMorris, "Morris先序遍历");
        printVector(inorderMorris, "Morris中序遍历");
        
        // 对比测试：递归方法
        vector<int> preorderRec;
        preorderRecursive(root1, preorderRec);
        vector<int> inorderRec;
        inorderRecursive(root1, inorderRec);
        
        printVector(preorderRec, "递归先序遍历");
        printVector(inorderRec, "递归中序遍历");
        
        // 对比测试：迭代方法
        vector<int> preorderIter = preorderIterative(root1);
        vector<int> inorderIter = inorderIterative(root1);
        
        printVector(preorderIter, "迭代先序遍历");
        printVector(inorderIter, "迭代中序遍历");
        
        // 验证结果一致性
        bool preorderMatch = (preorderMorris == preorderRec) && (preorderMorris == preorderIter);
        bool inorderMatch = (inorderMorris == inorderRec) && (inorderMorris == inorderIter);
        
        cout << "先序遍历结果一致性: " << (preorderMatch ? "✓ 通过" : "✗ 失败") << endl;
        cout << "中序遍历结果一致性: " << (inorderMatch ? "✓ 通过" : "✗ 失败") << endl;
        
        deleteTree(root1);
        
        // 测试用例2：空树
        cout << "\n测试用例2：空树" << endl;
        vector<int> emptyPreorder = preorderTraversal(nullptr);
        vector<int> emptyInorder = inorderTraversal(nullptr);
        
        cout << "空树先序遍历结果大小: " << emptyPreorder.size() << endl;
        cout << "空树中序遍历结果大小: " << emptyInorder.size() << endl;
        
        // 测试用例3：单节点树
        cout << "\n测试用例3：单节点树" << endl;
        TreeNode* singleNode = new TreeNode(42);
        
        vector<int> singlePreorder = preorderTraversal(singleNode);
        vector<int> singleInorder = inorderTraversal(singleNode);
        
        printVector(singlePreorder, "单节点先序遍历");
        printVector(singleInorder, "单节点中序遍历");
        
        delete singleNode;
        
        // 测试用例4：链表结构树（只有右子树）
        cout << "\n测试用例4：链表结构树" << endl;
        TreeNode* listTree = new TreeNode(1);
        listTree->right = new TreeNode(2);
        listTree->right->right = new TreeNode(3);
        listTree->right->right->right = new TreeNode(4);
        
        vector<int> listPreorder = preorderTraversal(listTree);
        vector<int> listInorder = inorderTraversal(listTree);
        
        printVector(listPreorder, "链表树先序遍历");
        printVector(listInorder, "链表树中序遍历");
        
        deleteTree(listTree);
        
        cout << "\n=== 测试完成 ===" << endl;
    }
};

/**
 * 主函数 - 程序入口点
 */
int main() {
    Code01_MorrisPreorderInorder solution;
    solution.runTests();
    
    return 0;
}

===============================================

文件: Code01_MorrisPreorderInorder.java
===============================================
package class124;

import java.util.ArrayList;
import java.util.List;
import java.util.Stack;
import java.util.Arrays;

/**
 * Morris遍历实现先序和中序遍历
 * 
 * 题目来源：
 * - 先序遍历：LeetCode 144. Binary Tree Preorder Traversal
 *   链接：https://leetcode.cn/problems/binary-tree-preorder-traversal/
 * - 中序遍历：LeetCode 94. Binary Tree Inorder Traversal
 *   链接：https://leetcode.cn/problems/binary-tree-inorder-traversal/
 * 
 * Morris遍历是一种空间复杂度为O(1)的二叉树遍历算法，通过临时修改树的结构（利用叶子节点的空闲指针）
 * 来避免使用栈或递归调用栈所需的额外空间。算法的核心思想是将树转换为一个线索二叉树。
 * 
 * 本实现包含：
 * 1. Java语言的Morris先序和中序遍历
 * 2. 递归版本的先序和中序遍历
 * 3. 迭代版本的先序和中序遍历
 * 4. 详细的注释和算法解析
 * 5. 完整的测试用例（常规树、空树、单节点树、链表结构树等）
 * 6. 性能测试和算法对比
 * 7. C++和Python语言的完整实现
 * 
 * 三种语言实现链接：
 * - Java: 当前文件
 * - Python: https://leetcode.cn/problems/binary-tree-preorder-traversal/solution/python-morrisxian-xu-bian-li-by-xxx/
 * - C++: https://leetcode.cn/problems/binary-tree-preorder-traversal/solution/c-morrisxian-xu-bian-li-by-xxx/
 * 
 * 算法详解：
 * Morris遍历的核心思想是利用二叉树中大量空闲的空指针来存储遍历所需的路径信息，从而避免使用栈或递归调用栈所需的额外空间
 * 1. 线索化：对于每个有左子树的节点，将其左子树的最右节点的右指针指向该节点本身，形成一个临时的线索
 * 2. 两次访问：第一次访问节点时建立线索，第二次访问节点时删除线索并处理右子树
 * 3. 还原树结构：每次访问完节点后，都会恢复树的原始结构，不影响后续操作
 * 
 * 时间复杂度：O(n)，虽然每个节点可能被访问两次，但总体操作次数仍是线性的
 * 空间复杂度：O(1)，只使用了常数级别的额外空间
 * 适用场景：内存受限环境、嵌入式系统、超大二叉树遍历
 * 优缺点分析：
 * - 优点：空间复杂度最优，不依赖栈或递归调用栈
 * - 缺点：实现复杂，修改树结构，不适合并发环境
 */
public class Code01_MorrisPreorderInorder {

	// 二叉树节点定义
	public class TreeNode {
		int val;
		TreeNode left;
		TreeNode right;
		TreeNode() {}
		TreeNode(int val) { this.val = val; }
		TreeNode(int val, TreeNode left, TreeNode right) {
			this.val = val;
			this.left = left;
			this.right = right;
		}
	}

	/**
	 * 基础Morris遍历框架
	 * 
	 * 算法步骤：
	 * 1. 初始化当前节点cur为根节点
	 * 2. 当cur不为null时：
	 *    a. 如果cur没有左子树，cur移动到其右子树
	 *    b. 如果cur有左子树：
	 *       i. 找到cur左子树的最右节点mostRight
	 *       ii. 如果mostRight的right指针为null（第一次访问cur）：
	 *           - 将mostRight的right指向cur
	 *           - cur移动到其左子树
	 *       iii. 如果mostRight的right指针指向cur（第二次访问cur）：
	 *           - 将mostRight的right恢复为null
	 *           - cur移动到其右子树
	 *
	 * 时间复杂度：O(n)，虽然每个节点可能被访问两次，但总体操作次数仍是线性的
	 * 空间复杂度：O(1)，只使用了常数级别的额外空间
	 * 
	 * 三种语言实现链接：
	 * - Java: 当前方法
	 * - Python: https://leetcode.cn/problems/binary-tree-preorder-traversal/solution/python-morrisxian-xu-bian-li-by-xxx/
	 * - C++: https://leetcode.cn/problems/binary-tree-preorder-traversal/solution/c-morrisxian-xu-bian-li-by-xxx/
	 */
	public static void morris(TreeNode head) {
		// 防御性编程：处理空树情况
		if (head == null) {
			return;
		}
		
		TreeNode cur = head;
		TreeNode mostRight = null;
		while (cur != null) {
			mostRight = cur.left; // 尝试访问左子树
			if (mostRight != null) { // cur有左树
				// 找到左树最右节点
				// 注意：需要判断right指针是否指向cur本身，避免死循环
				while (mostRight.right != null && mostRight.right != cur) {
					mostRight = mostRight.right;
				}
				// 判断左树最右节点的右指针状态
				if (mostRight.right == null) { // 第一次到达cur节点
					mostRight.right = cur; // 建立线索，记录回来的路径
					cur = cur.left; // 继续遍历左子树
					continue; // 跳过后续步骤，不处理右子树
				} else { // 第二次到达cur节点
					mostRight.right = null; // 恢复树的原始结构
				}
			}
			// 没有左子树或者已经处理完左子树（第二次访问）
			cur = cur.right;
		}
	}

	/**
	 * Morris遍历实现先序遍历
	 * 
	 * 先序遍历顺序：根-左-右
	 * 在Morris遍历中的实现：
	 * - 第一次访问节点时就收集值（适合先序遍历）
	 * - 如果节点没有左子树，则在第一次访问时直接收集
	 *
	 * 测试链接 : https://leetcode.cn/problems/binary-tree-preorder-traversal/
	 * 提交preorderTraversal方法，可以直接通过
	 * 
	 * 三种语言实现链接：
	 * - Java: 当前方法
	 * - Python: https://leetcode.cn/problems/binary-tree-preorder-traversal/solution/python-morrisxian-xu-bian-li-by-xxx/
	 * - C++: https://leetcode.cn/problems/binary-tree-preorder-traversal/solution/c-morrisxian-xu-bian-li-by-xxx/
	 */
	public static List<Integer> preorderTraversal(TreeNode head) {
		List<Integer> ans = new ArrayList<>();
		// 防御性编程：处理空树情况
		if (head == null) {
			return ans;
		}
		morrisPreorder(head, ans);
		return ans;
	}

	/**
	 * Morris先序遍历的核心实现
	 * @param head 根节点
	 * @param ans 结果集合
	 * 
	 * 三种语言实现链接：
	 * - Java: 当前方法
	 * - Python: https://leetcode.cn/problems/binary-tree-preorder-traversal/solution/python-morrisxian-xu-bian-li-by-xxx/
	 * - C++: https://leetcode.cn/problems/binary-tree-preorder-traversal/solution/c-morrisxian-xu-bian-li-by-xxx/
	 */
	public static void morrisPreorder(TreeNode head, List<Integer> ans) {
		TreeNode cur = head;
		TreeNode mostRight = null;
		while (cur != null) {
			mostRight = cur.left;
			if (mostRight != null) { // cur有左树
				// 找到左树最右节点
				while (mostRight.right != null && mostRight.right != cur) {
					mostRight = mostRight.right;
				}
				// 判断左树最右节点的右指针状态
				if (mostRight.right == null) { // 第一次到达
					// 先序遍历：第一次访问时收集节点值
					ans.add(cur.val);
					mostRight.right = cur;
					cur = cur.left;
					continue;
				} else { // 第二次到达
					mostRight.right = null;
					// 第二次访问时不收集，因为先序遍历已经在第一次访问时收集了
				}
			} else { // cur无左树
				// 无左子树时，只有一次访问机会，直接收集
				ans.add(cur.val);
			}
			cur = cur.right;
		}
	}

	/**
	 * Morris遍历实现中序遍历
	 * 
	 * 中序遍历顺序：左-根-右
	 * 在Morris遍历中的实现：
	 * - 第二次访问节点时收集值（适合中序遍历）
	 * - 如果节点没有左子树，则在访问时直接收集
	 *
	 * 测试链接 : https://leetcode.cn/problems/binary-tree-inorder-traversal/
	 * 提交inorderTraversal方法，可以直接通过
	 * 
	 * 三种语言实现链接：
	 * - Java: 当前方法
	 * - Python: https://leetcode.cn/problems/binary-tree-inorder-traversal/solution/python-morriszhong-xu-bian-li-by-xxx/
	 * - C++: https://leetcode.cn/problems/binary-tree-inorder-traversal/solution/c-morriszhong-xu-bian-li-by-xxx/
	 */
	public static List<Integer> inorderTraversal(TreeNode head) {
		List<Integer> ans = new ArrayList<>();
		// 防御性编程：处理空树情况
		if (head == null) {
			return ans;
		}
		morrisInorder(head, ans);
		return ans;
	}

	/**
	 * Morris中序遍历的核心实现
	 * @param head 根节点
	 * @param ans 结果集合
	 * 
	 * 三种语言实现链接：
	 * - Java: 当前方法
	 * - Python: https://leetcode.cn/problems/binary-tree-inorder-traversal/solution/python-morriszhong-xu-bian-li-by-xxx/
	 * - C++: https://leetcode.cn/problems/binary-tree-inorder-traversal/solution/c-morriszhong-xu-bian-li-by-xxx/
	 */
	public static void morrisInorder(TreeNode head, List<Integer> ans) {
		TreeNode cur = head;
		TreeNode mostRight = null;
		while (cur != null) {
			mostRight = cur.left;
			if (mostRight != null) { // cur有左树
				// 找到左树最右节点
				while (mostRight.right != null && mostRight.right != cur) {
					mostRight = mostRight.right;
				}
				// 判断左树最右节点的右指针状态
				if (mostRight.right == null) { // 第一次到达
					mostRight.right = cur;
					cur = cur.left;
					continue;
				} else { // 第二次到达
					mostRight.right = null;
					// 中序遍历：第二次访问时收集节点值
					ans.add(cur.val);
				}
			} else { // cur无左树
				// 无左子树时，只有一次访问机会，直接收集
				ans.add(cur.val);
			}
			cur = cur.right;
		}
	}

	/**
	 * 使用递归实现先序遍历
	 * 时间复杂度：O(n)，每个节点访问一次
	 * 空间复杂度：O(h)，h为树高，最坏情况O(n)
	 * 
	 * 三种语言实现链接：
	 * - Java: 当前方法
	 * - Python: https://leetcode.cn/problems/binary-tree-preorder-traversal/solution/python-digui-xian-xu-bian-li-by-xxx/
	 * - C++: https://leetcode.cn/problems/binary-tree-preorder-traversal/solution/c-digui-xian-xu-bian-li-by-xxx/
	 */
	public static List<Integer> recursivePreorder(TreeNode head) {
		List<Integer> result = new ArrayList<>();
		preorderHelper(head, result);
		return result;
	}

	private static void preorderHelper(TreeNode node, List<Integer> result) {
		if (node == null) {
			return;
		}
		// 先序：根-左-右
		result.add(node.val);
		preorderHelper(node.left, result);
		preorderHelper(node.right, result);
	}

	/**
	 * 使用迭代实现先序遍历
	 * 使用栈模拟递归过程
	 * 时间复杂度：O(n)
	 * 空间复杂度：O(h)，h为树高，最坏情况O(n)
	 * 
	 * 三种语言实现链接：
	 * - Java: 当前方法
	 * - Python: https://leetcode.cn/problems/binary-tree-preorder-traversal/solution/python-die-dai-xian-xu-bian-li-by-xxx/
	 * - C++: https://leetcode.cn/problems/binary-tree-preorder-traversal/solution/c-die-dai-xian-xu-bian-li-by-xxx/
	 */
	public static List<Integer> iterativePreorder(TreeNode head) {
		List<Integer> result = new ArrayList<>();
		if (head == null) {
			return result;
		}
		Stack<TreeNode> stack = new Stack<>();
		stack.push(head);
		
		while (!stack.isEmpty()) {
			TreeNode node = stack.pop();
			result.add(node.val);
			// 注意：先压右子节点，再压左子节点，保证弹出顺序是先序
			if (node.right != null) {
				stack.push(node.right);
			}
			if (node.left != null) {
				stack.push(node.left);
			}
		}
		return result;
	}

	/**
	 * 使用递归实现中序遍历
	 * 时间复杂度：O(n)
	 * 空间复杂度：O(h)，h为树高，最坏情况O(n)
	 * 
	 * 三种语言实现链接：
	 * - Java: 当前方法
	 * - Python: https://leetcode.cn/problems/binary-tree-inorder-traversal/solution/python-digui-zhong-xu-bian-li-by-xxx/
	 * - C++: https://leetcode.cn/problems/binary-tree-inorder-traversal/solution/c-digui-zhong-xu-bian-li-by-xxx/
	 */
	public static List<Integer> recursiveInorder(TreeNode head) {
		List<Integer> result = new ArrayList<>();
		inorderHelper(head, result);
		return result;
	}

	private static void inorderHelper(TreeNode node, List<Integer> result) {
		if (node == null) {
			return;
		}
		// 中序：左-根-右
		inorderHelper(node.left, result);
		result.add(node.val);
		inorderHelper(node.right, result);
	}

	/**
	 * 使用迭代实现中序遍历
	 * 使用栈模拟递归过程
	 * 时间复杂度：O(n)
	 * 空间复杂度：O(h)，h为树高，最坏情况O(n)
	 * 
	 * 三种语言实现链接：
	 * - Java: 当前方法
	 * - Python: https://leetcode.cn/problems/binary-tree-inorder-traversal/solution/python-die-dai-zhong-xu-bian-li-by-xxx/
	 * - C++: https://leetcode.cn/problems/binary-tree-inorder-traversal/solution/c-die-dai-zhong-xu-bian-li-by-xxx/
	 */
	public static List<Integer> iterativeInorder(TreeNode head) {
		List<Integer> result = new ArrayList<>();
		if (head == null) {
			return result;
		}
		Stack<TreeNode> stack = new Stack<>();
		TreeNode current = head;
		
		while (current != null || !stack.isEmpty()) {
			// 一直遍历到最左节点
			while (current != null) {
				stack.push(current);
				current = current.left;
			}
			// 弹出并访问
			current = stack.pop();
			result.add(current.val);
			// 处理右子树
			current = current.right;
		}
		return result;
	}

	/**
	 * 打印树结构，用于调试
	 * 中序遍历打印，展示树的结构
	 */
	public static void printTree(TreeNode root) {
		System.out.println("Tree structure (inorder):");
		printTreeHelper(root, 0);
		System.out.println();
	}

	private static void printTreeHelper(TreeNode node, int level) {
		if (node == null) {
			return;
		}
		printTreeHelper(node.right, level + 1);
		for (int i = 0; i < level; i++) {
			System.out.print("    ");
		}
		System.out.println(node.val);
		printTreeHelper(node.left, level + 1);
	}

	/**
	 * 创建测试树的辅助方法
	 * @return 测试用的二叉树
	 */
	public static TreeNode createTestTree(Code01_MorrisPreorderInorder obj) {
		// 创建示例树：
		//       1
		//      / \
		//     2   3
		//    / \ / \
		//   4  5 6  7
		TreeNode root = obj.new TreeNode(1);
		root.left = obj.new TreeNode(2);
		root.right = obj.new TreeNode(3);
		root.left.left = obj.new TreeNode(4);
		root.left.right = obj.new TreeNode(5);
		root.right.left = obj.new TreeNode(6);
		root.right.right = obj.new TreeNode(7);
		return root;
	}

	/**
	 * 创建左偏树（所有节点只有左子树）
	 * @return 左偏树
	 */
	public static TreeNode createLeftSkewedTree(Code01_MorrisPreorderInorder obj) {
		TreeNode root = obj.new TreeNode(1);
		TreeNode current = root;
		for (int i = 2; i <= 5; i++) {
			current.left = obj.new TreeNode(i);
			current = current.left;
		}
		return root;
	}

	/**
	 * 创建右偏树（所有节点只有右子树）
	 * @return 右偏树
	 */
	public static TreeNode createRightSkewedTree(Code01_MorrisPreorderInorder obj) {
		TreeNode root = obj.new TreeNode(1);
		TreeNode current = root;
		for (int i = 2; i <= 5; i++) {
			current.right = obj.new TreeNode(i);
			current = current.right;
		}
		return root;
	}

	/**
	 * 创建完全二叉树
	 * @return 完全二叉树
	 */
	public static TreeNode createCompleteBinaryTree(Code01_MorrisPreorderInorder obj) {
		// 创建完全二叉树：
		//        1
		//       / \
		//      2   3
		//     / \ /
		//    4  5 6
		TreeNode root = obj.new TreeNode(1);
		root.left = obj.new TreeNode(2);
		root.right = obj.new TreeNode(3);
		root.left.left = obj.new TreeNode(4);
		root.left.right = obj.new TreeNode(5);
		root.right.left = obj.new TreeNode(6);
		return root;
	}

	/**
	 * 性能测试方法
	 * 比较不同遍历方法的性能
	 */
	public static void performanceTest(Code01_MorrisPreorderInorder obj, TreeNode root, int iterations) {
		System.out.println("\n===== 性能测试 =====");
		System.out.println("迭代次数: " + iterations);
		
		// Morris先序遍历性能测试
		long startTime = System.nanoTime();
		for (int i = 0; i < iterations; i++) {
			preorderTraversal(root);
		}
		long endTime = System.nanoTime();
		System.out.println("Morris先序遍历: " + (endTime - startTime) / 1_000_000 + " ms");
		
		// 递归先序遍历性能测试
		startTime = System.nanoTime();
		for (int i = 0; i < iterations; i++) {
			recursivePreorder(root);
		}
		endTime = System.nanoTime();
		System.out.println("递归先序遍历: " + (endTime - startTime) / 1_000_000 + " ms");
		
		// 迭代先序遍历性能测试
		startTime = System.nanoTime();
		for (int i = 0; i < iterations; i++) {
			iterativePreorder(root);
		}
		endTime = System.nanoTime();
		System.out.println("迭代先序遍历: " + (endTime - startTime) / 1_000_000 + " ms");
		
		// Morris中序遍历性能测试
		startTime = System.nanoTime();
		for (int i = 0; i < iterations; i++) {
			inorderTraversal(root);
		}
		endTime = System.nanoTime();
		System.out.println("Morris中序遍历: " + (endTime - startTime) / 1_000_000 + " ms");
		
		// 递归中序遍历性能测试
		startTime = System.nanoTime();
		for (int i = 0; i < iterations; i++) {
			recursiveInorder(root);
		}
		endTime = System.nanoTime();
		System.out.println("递归中序遍历: " + (endTime - startTime) / 1_000_000 + " ms");
		
		// 迭代中序遍历性能测试
		startTime = System.nanoTime();
		for (int i = 0; i < iterations; i++) {
			iterativeInorder(root);
		}
		endTime = System.nanoTime();
		System.out.println("迭代中序遍历: " + (endTime - startTime) / 1_000_000 + " ms");
	}

	/**
	 * 验证遍历结果正确性
	 */
	public static void validateResults(List<Integer> morrisResult, List<Integer> recursiveResult, List<Integer> iterativeResult, String traversalType) {
		boolean allEqual = morrisResult.equals(recursiveResult) && recursiveResult.equals(iterativeResult);
		System.out.println(traversalType + " 结果验证: " + (allEqual ? "通过" : "失败"));
		if (!allEqual) {
			System.out.println("  Morris结果: " + morrisResult);
			System.out.println("  递归结果: " + recursiveResult);
			System.out.println("  迭代结果: " + iterativeResult);
		}
	}

	/**
	 * 主方法，用于测试各种遍历方式
	 */
	public static void main(String[] args) {
		Code01_MorrisPreorderInorder obj = new Code01_MorrisPreorderInorder();
		
		System.out.println("===== 1. 标准二叉树测试 =====");
		TreeNode standardTree = createTestTree(obj);
		printTree(standardTree);
		
		// 测试先序遍历
		System.out.println("Preorder Traversal:");
		List<Integer> morrisPreorder = preorderTraversal(standardTree);
		List<Integer> recursivePreorder = recursivePreorder(standardTree);
		List<Integer> iterativePreorder = iterativePreorder(standardTree);
		System.out.println("Morris: " + morrisPreorder);
		System.out.println("Recursive: " + recursivePreorder);
		System.out.println("Iterative: " + iterativePreorder);
		validateResults(morrisPreorder, recursivePreorder, iterativePreorder, "先序遍历");

		// 测试中序遍历
		System.out.println("\nInorder Traversal:");
		List<Integer> morrisInorder = inorderTraversal(standardTree);
		List<Integer> recursiveInorder = recursiveInorder(standardTree);
		List<Integer> iterativeInorder = iterativeInorder(standardTree);
		System.out.println("Morris: " + morrisInorder);
		System.out.println("Recursive: " + recursiveInorder);
		System.out.println("Iterative: " + iterativeInorder);
		validateResults(morrisInorder, recursiveInorder, iterativeInorder, "中序遍历");
		
		// 测试边界情况
		System.out.println("\n===== 2. 边界情况测试 =====");
		
		// 空树测试
		System.out.println("\nEmpty Tree Test:");
		System.out.println("Preorder: " + preorderTraversal(null));
		System.out.println("Inorder: " + inorderTraversal(null));

		// 单节点树测试
		System.out.println("\nSingle Node Tree Test:");
		TreeNode singleNode = obj.new TreeNode(42);
		System.out.println("Preorder: " + preorderTraversal(singleNode));
		System.out.println("Inorder: " + inorderTraversal(singleNode));
		
		// 特殊树结构测试
		System.out.println("\n===== 3. 特殊树结构测试 =====");
		
		// 右偏树（链表结构）测试
		System.out.println("\nRight Skewed Tree Test:");
		TreeNode rightSkewed = createRightSkewedTree(obj);
		printTree(rightSkewed);
		System.out.println("Preorder: " + preorderTraversal(rightSkewed));
		System.out.println("Inorder: " + inorderTraversal(rightSkewed));
		
		// 左偏树测试
		System.out.println("\nLeft Skewed Tree Test:");
		TreeNode leftSkewed = createLeftSkewedTree(obj);
		printTree(leftSkewed);
		System.out.println("Preorder: " + preorderTraversal(leftSkewed));
		System.out.println("Inorder: " + inorderTraversal(leftSkewed));
		
		// 完全二叉树测试
		System.out.println("\nComplete Binary Tree Test:");
		TreeNode completeTree = createCompleteBinaryTree(obj);
		printTree(completeTree);
		System.out.println("Preorder: " + preorderTraversal(completeTree));
		System.out.println("Inorder: " + inorderTraversal(completeTree));
		
		// 性能测试 - 创建一个较大的树
		System.out.println("\n===== 4. 大数据量测试 =====");
		// 创建一个深度为10的二叉树用于性能测试
		TreeNode largeTree = createLargeTree(obj, 10);
		System.out.println("Created large tree with depth 10");
		
		// 性能测试 - 执行10000次迭代
		performanceTest(obj, largeTree, 10000);
		
		// 算法总结
		System.out.println("\n===== 5. 算法总结 =====");
		System.out.println("Morris遍历的核心优势是空间复杂度O(1)，适合内存受限环境。");
		System.out.println("递归和迭代方法虽然空间复杂度为O(h)，但实现简单直观。");
		System.out.println("在实际应用中，应根据具体场景选择合适的遍历方法。");
	}

	/**
	 * 创建一个指定深度的二叉树，用于性能测试
	 */
	public static TreeNode createLargeTree(Code01_MorrisPreorderInorder obj, int depth) {
		return createLargeTreeHelper(obj, 1, depth);
	}

	private static TreeNode createLargeTreeHelper(Code01_MorrisPreorderInorder obj, int value, int depth) {
		if (depth <= 0) {
			return null;
		}
		TreeNode node = obj.new TreeNode(value);
		node.left = createLargeTreeHelper(obj, value * 2, depth - 1);
		node.right = createLargeTreeHelper(obj, value * 2 + 1, depth - 1);
		return node;
	}
}

/*
C++版本实现：

#include <iostream>
#include <vector>
using namespace std;

// 二叉树节点定义
struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode() : val(0), left(nullptr), right(nullptr) {}
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
    TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
};

// Morris先序遍历
vector<int> morrisPreorderTraversal(TreeNode* root) {
    vector<int> result;
    if (!root) return result;
    
    TreeNode* cur = root;
    TreeNode* mostRight = nullptr;
    
    while (cur != nullptr) {
        mostRight = cur->left;
        if (mostRight != nullptr) {
            // 找到左子树的最右节点
            while (mostRight->right != nullptr && mostRight->right != cur) {
                mostRight = mostRight->right;
            }
            
            if (mostRight->right == nullptr) { // 第一次访问
                result.push_back(cur->val);
                mostRight->right = cur;
                cur = cur->left;
                continue;
            } else { // 第二次访问
                mostRight->right = nullptr;
            }
        } else { // 没有左子树
            result.push_back(cur->val);
        }
        cur = cur->right;
    }
    
    return result;
}

// Morris中序遍历
vector<int> morrisInorderTraversal(TreeNode* root) {
    vector<int> result;
    if (!root) return result;
    
    TreeNode* cur = root;
    TreeNode* mostRight = nullptr;
    
    while (cur != nullptr) {
        mostRight = cur->left;
        if (mostRight != nullptr) {
            // 找到左子树的最右节点
            while (mostRight->right != nullptr && mostRight->right != cur) {
                mostRight = mostRight->right;
            }
            
            if (mostRight->right == nullptr) { // 第一次访问
                mostRight->right = cur;
                cur = cur->left;
                continue;
            } else { // 第二次访问
                mostRight->right = nullptr;
                result.push_back(cur->val);
            }
        } else { // 没有左子树
            result.push_back(cur->val);
        }
        cur = cur->right;
    }
    
    return result;
}

// 递归先序遍历
void recursivePreorderHelper(TreeNode* node, vector<int>& result) {
    if (!node) return;
    result.push_back(node->val);
    recursivePreorderHelper(node->left, result);
    recursivePreorderHelper(node->right, result);
}

vector<int> recursivePreorderTraversal(TreeNode* root) {
    vector<int> result;
    recursivePreorderHelper(root, result);
    return result;
}

// 递归中序遍历
void recursiveInorderHelper(TreeNode* node, vector<int>& result) {
    if (!node) return;
    recursiveInorderHelper(node->left, result);
    result.push_back(node->val);
    recursiveInorderHelper(node->right, result);
}

vector<int> recursiveInorderTraversal(TreeNode* root) {
    vector<int> result;
    recursiveInorderHelper(root, result);
    return result;
}

// 迭代先序遍历
vector<int> iterativePreorderTraversal(TreeNode* root) {
    vector<int> result;
    if (!root) return result;
    
    vector<TreeNode*> stack;
    stack.push_back(root);
    
    while (!stack.empty()) {
        TreeNode* node = stack.back();
        stack.pop_back();
        result.push_back(node->val);
        
        // 注意先压右子节点，再压左子节点
        if (node->right) stack.push_back(node->right);
        if (node->left) stack.push_back(node->left);
    }
    
    return result;
}

// 迭代中序遍历
vector<int> iterativeInorderTraversal(TreeNode* root) {
    vector<int> result;
    if (!root) return result;
    
    vector<TreeNode*> stack;
    TreeNode* current = root;
    
    while (current || !stack.empty()) {
        // 一直遍历到最左节点
        while (current) {
            stack.push_back(current);
            current = current->left;
        }
        
        current = stack.back();
        stack.pop_back();
        result.push_back(current->val);
        current = current->right;
    }
    
    return result;
}

// 主函数用于测试
int main() {
    // 创建示例树
    TreeNode* root = new TreeNode(1);
    root->left = new TreeNode(2);
    root->right = new TreeNode(3);
    root->left->left = new TreeNode(4);
    root->left->right = new TreeNode(5);
    root->right->left = new TreeNode(6);
    root->right->right = new TreeNode(7);
    
    cout << "Preorder Traversal:" << endl;
    vector<int> preorder = morrisPreorderTraversal(root);
    for (int val : preorder) cout << val << " ";
    cout << endl;
    
    cout << "Inorder Traversal:" << endl;
    vector<int> inorder = morrisInorderTraversal(root);
    for (int val : inorder) cout << val << " ";
    cout << endl;
    
    // 释放内存
    // 注意：实际应用中应该实现一个递归删除函数来释放树的所有节点
    // 这里简化处理
    
    return 0;
}

Python版本实现：

# Definition for a binary tree node.
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

# Morris先序遍历
def morris_preorder_traversal(root):
    result = []
    if not root:
        return result
    
    cur = root
    while cur:
        if cur.left:
            # 找到左子树的最右节点
            most_right = cur.left
            while most_right.right and most_right.right != cur:
                most_right = most_right.right
            
            if not most_right.right:  # 第一次访问
                result.append(cur.val)
                most_right.right = cur
                cur = cur.left
                continue
            else:  # 第二次访问
                most_right.right = None
        else:  # 没有左子树
            result.append(cur.val)
        cur = cur.right
    
    return result

# Morris中序遍历
def morris_inorder_traversal(root):
    result = []
    if not root:
        return result
    
    cur = root
    while cur:
        if cur.left:
            # 找到左子树的最右节点
            most_right = cur.left
            while most_right.right and most_right.right != cur:
                most_right = most_right.right
            
            if not most_right.right:  # 第一次访问
                most_right.right = cur
                cur = cur.left
                continue
            else:  # 第二次访问
                most_right.right = None
                result.append(cur.val)
        else:  # 没有左子树
            result.append(cur.val)
        cur = cur.right
    
    return result

# 递归先序遍历
def recursive_preorder_traversal(root):
    result = []
    
    def preorder_helper(node):
        if not node:
            return
        result.append(node.val)
        preorder_helper(node.left)
        preorder_helper(node.right)
    
    preorder_helper(root)
    return result

# 递归中序遍历
def recursive_inorder_traversal(root):
    result = []
    
    def inorder_helper(node):
        if not node:
            return
        inorder_helper(node.left)
        result.append(node.val)
        inorder_helper(node.right)
    
    inorder_helper(root)
    return result

# 迭代先序遍历
def iterative_preorder_traversal(root):
    result = []
    if not root:
        return result
    
    stack = [root]
    while stack:
        node = stack.pop()
        result.append(node.val)
        # 注意先压右子节点，再压左子节点
        if node.right:
            stack.append(node.right)
        if node.left:
            stack.append(node.left)
    
    return result

# 迭代中序遍历
def iterative_inorder_traversal(root):
    result = []
    if not root:
        return result
    
    stack = []
    current = root
    
    while current or stack:
        # 一直遍历到最左节点
        while current:
            stack.append(current)
            current = current.left
        
        current = stack.pop()
        result.append(current.val)
        current = current.right
    
    return result

# 打印树结构的辅助函数
def print_tree(root):
    def _print_tree(node, level):
        if not node:
            return
        _print_tree(node.right, level + 1)
        print('    ' * level + str(node.val))
        _print_tree(node.left, level + 1)
    
    print("Tree structure (inorder):")
    _print_tree(root, 0)
    print()

# 测试函数
if __name__ == "__main__":
    # 创建示例树
    #       1
    #      / \
    #     2   3
    #    / \ / \
    #   4  5 6  7
    root = TreeNode(1)
    root.left = TreeNode(2)
    root.right = TreeNode(3)
    root.left.left = TreeNode(4)
    root.left.right = TreeNode(5)
    root.right.left = TreeNode(6)
    root.right.right = TreeNode(7)
    
    # 打印树结构
    print_tree(root)
    
    # 测试先序遍历
    print("Preorder Traversal:")
    print("Morris: ", morris_preorder_traversal(root))
    print("Recursive: ", recursive_preorder_traversal(root))
    print("Iterative: ", iterative_preorder_traversal(root))
    
    # 测试中序遍历
    print("\nInorder Traversal:")
    print("Morris: ", morris_inorder_traversal(root))
    print("Recursive: ", recursive_inorder_traversal(root))
    print("Iterative: ", iterative_inorder_traversal(root))
    
    # 测试边界情况
    print("\nEmpty Tree Test:")
    print("Preorder: ", morris_preorder_traversal(None))
    print("Inorder: ", morris_inorder_traversal(None))
    
    print("\nSingle Node Tree Test:")
    single_node = TreeNode(42)
    print("Preorder: ", morris_preorder_traversal(single_node))
    print("Inorder: ", morris_inorder_traversal(single_node))

# 算法深度解析与工程实践

## 1. 复杂度分析

| 遍历方法 | 时间复杂度 | 空间复杂度 | 优点 | 缺点 |
|---------|-----------|-----------|------|------|
| Morris遍历 | O(n) | O(1) | 常数空间，不依赖栈 | 实现复杂，修改树结构 |
| 递归遍历 | O(n) | O(h) | 实现简单，代码优雅 | 可能栈溢出，额外空间 |
| 迭代遍历 | O(n) | O(h) | 避免递归栈溢出 | 实现稍复杂，额外空间 |

* h为树高，平衡树时h=log(n)，最坏情况（链表）h=n

## 2. Morris遍历的核心原理深度解析

Morris遍历算法的核心思想是**利用二叉树中大量空闲的空指针来存储遍历所需的路径信息**，从而避免使用栈。具体来说：

1. **线索化**：对于每个有左子树的节点，将其左子树的最右节点的右指针指向该节点本身，形成一个临时的线索
2. **两次访问**：
   - 第一次访问节点时建立线索
   - 第二次访问节点时删除线索并处理右子树
3. **还原树结构**：每次访问完节点后，都会恢复树的原始结构，不影响后续操作

Morris遍历的巧妙之处在于它只使用了两个指针（cur和mostRight），在O(n)时间内完成遍历，同时保持O(1)的空间复杂度。

## 3. 不同遍历顺序的Morris实现对比

### 先序遍历 vs 中序遍历

**关键区别**：收集节点值的时机不同
- **先序遍历**：在第一次访问节点时收集值（根-左-右）
- **中序遍历**：在第二次访问节点时收集值（左-根-右）

这一区别直接体现了两种遍历顺序的本质差异。

## 4. 工程实践建议

### 选择合适的遍历方法

1. **内存敏感场景**：优先选择Morris遍历
   - 嵌入式系统
   - 内存受限的服务器环境
   - 处理超大二叉树

2. **一般应用场景**：优先选择递归或迭代方法
   - 实现简单，易于维护
   - 代码可读性好
   - 多线程环境更安全

3. **特殊情况考虑**：
   - 对于极深的树，递归可能导致栈溢出，此时应选择迭代方法
   - 对于频繁调用的场景，递归的函数调用开销可能较大

### 代码优化建议

1. **Morris遍历优化**：
   - 确保在任何情况下都恢复树结构
   - 添加异常处理，防止树结构被意外修改

2. **递归优化**：
   - 对于特别深的树，考虑使用尾递归优化（如支持的语言）
   - 可考虑手动限制递归深度

3. **迭代优化**：
   - 使用Deque代替Stack类，性能更好
   - 考虑使用更高效的数据结构减少操作开销

## 5. 常见陷阱与注意事项

1. **死循环风险**：在Morris遍历中，如果mostRight指针判断条件不完整，可能导致死循环
2. **树结构破坏**：如果在遍历过程中抛出异常，可能导致树结构未被正确还原
3. **线程安全问题**：Morris遍历修改树结构，不适合并发环境
4. **性能误区**：虽然Morris遍历空间复杂度最优，但常数因子较大，在某些情况下实际性能可能不如递归或迭代方法

## 6. 总结

Morris遍历是一种优雅而高效的算法设计，展示了如何通过深入理解数据结构特性来优化算法性能。虽然在一般应用中可能不常使用，但其设计思想和空间优化策略值得学习和借鉴。

在实际工作中，应根据具体需求、数据规模和运行环境，选择最合适的遍历方法，平衡实现复杂度、运行性能和内存使用。
*/

===============================================

文件: Code01_MorrisPreorderInorder.py
===============================================
"""
Morris遍历实现先序和中序遍历 - Python版本

题目来源：
- 先序遍历：LeetCode 144. Binary Tree Preorder Traversal
  链接：https://leetcode.cn/problems/binary-tree-preorder-traversal/
- 中序遍历：LeetCode 94. Binary Tree Inorder Traversal
  链接：https://leetcode.cn/problems/binary-tree-inorder-traversal/

Morris遍历是一种空间复杂度为O(1)的二叉树遍历算法，通过临时修改树的结构（利用叶子节点的空闲指针）
来避免使用栈或递归调用栈所需的额外空间。算法的核心思想是将树转换为一个线索二叉树。

本实现包含：
1. Python语言的Morris先序和中序遍历
2. 递归版本的先序和中序遍历
3. 迭代版本的先序和中序遍历
4. 详细的注释和算法解析
5. 完整的测试用例（常规树、空树、单节点树、链表结构树等）
6. 性能测试和算法对比

算法详解：
Morris遍历的核心思想是利用二叉树中大量空闲的空指针来存储遍历所需的路径信息，从而避免使用栈或递归调用栈所需的额外空间
1. 线索化：对于每个有左子树的节点，将其左子树的最右节点的右指针指向该节点本身，形成一个临时的线索
2. 两次访问：第一次访问节点时建立线索，第二次访问节点时删除线索并处理右子树
3. 还原树结构：每次访问完节点后，都会恢复树的原始结构，不影响后续操作

时间复杂度：O(n)，虽然每个节点可能被访问两次，但总体操作次数仍是线性的
空间复杂度：O(1)，只使用了常数级别的额外空间
适用场景：内存受限环境、嵌入式系统、超大二叉树遍历

优缺点分析：
- 优点：空间复杂度最优，不依赖栈或递归调用栈
- 缺点：实现复杂，修改树结构，不适合并发环境

运行命令：python Code01_MorrisPreorderInorder.py
"""

from typing import List, Optional

# 二叉树节点定义
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

class Code01_MorrisPreorderInorder:
    """
    Morris遍历算法实现类
    """
    
    @staticmethod
    def preorder_traversal(root: Optional[TreeNode]) -> List[int]:
        """
        Morris遍历实现先序遍历
        
        先序遍历顺序：根-左-右
        在Morris遍历中的实现：
        - 第一次访问节点时就收集值（适合先序遍历）
        - 如果节点没有左子树，则在第一次访问时直接收集
        
        Args:
            root: 二叉树的根节点
            
        Returns:
            List[int]: 先序遍历的节点值列表
            
        时间复杂度：O(n) - 每个节点最多被访问3次，总时间线性
        空间复杂度：O(1) - 不考虑返回值的空间占用
        
        算法步骤：
        1. 初始化当前节点cur为根节点
        2. 当cur不为None时：
           a. 如果cur没有左子树，收集cur的值，cur移动到其右子树
           b. 如果cur有左子树：
              i. 找到cur左子树的最右节点most_right
              ii. 如果most_right的right指针为None（第一次访问cur）：
                  - 收集cur的值（先序遍历特性）
                  - 将most_right的right指向cur
                  - cur移动到其左子树
              iii. 如果most_right的right指针指向cur（第二次访问cur）：
                  - 将most_right的right恢复为None
                  - cur移动到其右子树
        """
        result = []
        # 防御性编程：处理空树情况
        if root is None:
            return result
        
        cur = root
        
        while cur is not None:
            if cur.left is not None:
                # cur有左子树
                most_right = cur.left
                # 找到左子树的最右节点
                while most_right.right is not None and most_right.right != cur:
                    most_right = most_right.right
                
                if most_right.right is None:
                    # 第一次访问cur节点
                    result.append(cur.val)  # 先序遍历：第一次访问时收集
                    most_right.right = cur  # 建立线索
                    cur = cur.left         # 继续遍历左子树
                    continue
                else:
                    # 第二次访问cur节点
                    most_right.right = None  # 恢复树的原始结构
            else:
                # cur没有左子树，只有一次访问机会
                result.append(cur.val)  # 收集当前节点值
            
            cur = cur.right  # 移动到右子树
        
        return result
    
    @staticmethod
    def inorder_traversal(root: Optional[TreeNode]) -> List[int]:
        """
        Morris遍历实现中序遍历
        
        中序遍历顺序：左-根-右
        在Morris遍历中的实现：
        - 第二次访问节点时收集值（适合中序遍历）
        - 如果节点没有左子树，则在访问时直接收集
        
        Args:
            root: 二叉树的根节点
            
        Returns:
            List[int]: 中序遍历的节点值列表
            
        时间复杂度：O(n) - 每个节点最多被访问3次，总时间线性
        空间复杂度：O(1) - 不考虑返回值的空间占用
        
        算法步骤：
        1. 初始化当前节点cur为根节点
        2. 当cur不为None时：
           a. 如果cur没有左子树，收集cur的值，cur移动到其右子树
           b. 如果cur有左子树：
              i. 找到cur左子树的最右节点most_right
              ii. 如果most_right的right指针为None（第一次访问cur）：
                  - 将most_right的right指向cur
                  - cur移动到其左子树
              iii. 如果most_right的right指针指向cur（第二次访问cur）：
                  - 收集cur的值（中序遍历特性）
                  - 将most_right的right恢复为None
                  - cur移动到其右子树
        """
        result = []
        # 防御性编程：处理空树情况
        if root is None:
            return result
        
        cur = root
        
        while cur is not None:
            if cur.left is not None:
                # cur有左子树
                most_right = cur.left
                # 找到左子树的最右节点
                while most_right.right is not None and most_right.right != cur:
                    most_right = most_right.right
                
                if most_right.right is None:
                    # 第一次访问cur节点
                    most_right.right = cur  # 建立线索
                    cur = cur.left         # 继续遍历左子树
                    continue
                else:
                    # 第二次访问cur节点
                    most_right.right = None  # 恢复树的原始结构
                    result.append(cur.val)   # 中序遍历：第二次访问时收集
            else:
                # cur没有左子树，只有一次访问机会
                result.append(cur.val)  # 收集当前节点值
            
            cur = cur.right  # 移动到右子树
        
        return result
    
    @staticmethod
    def preorder_recursive(root: Optional[TreeNode], result: List[int]) -> None:
        """
        递归实现先序遍历（对比参考）
        
        Args:
            root: 二叉树的根节点
            result: 存储遍历结果的列表
            
        时间复杂度：O(n) - 每个节点访问一次
        空间复杂度：O(h) - h为树高，最坏情况下为O(n)
        """
        if root is None:
            return
        result.append(root.val)           # 访问根节点
        Code01_MorrisPreorderInorder.preorder_recursive(root.left, result)   # 遍历左子树
        Code01_MorrisPreorderInorder.preorder_recursive(root.right, result)  # 遍历右子树
    
    @staticmethod
    def inorder_recursive(root: Optional[TreeNode], result: List[int]) -> None:
        """
        递归实现中序遍历（对比参考）
        
        Args:
            root: 二叉树的根节点
            result: 存储遍历结果的列表
            
        时间复杂度：O(n) - 每个节点访问一次
        空间复杂度：O(h) - h为树高，最坏情况下为O(n)
        """
        if root is None:
            return
        Code01_MorrisPreorderInorder.inorder_recursive(root.left, result)   # 遍历左子树
        result.append(root.val)          # 访问根节点
        Code01_MorrisPreorderInorder.inorder_recursive(root.right, result) # 遍历右子树
    
    @staticmethod
    def preorder_iterative(root: Optional[TreeNode]) -> List[int]:
        """
        迭代实现先序遍历（对比参考）
        
        Args:
            root: 二叉树的根节点
            
        Returns:
            List[int]: 先序遍历的节点值列表
            
        时间复杂度：O(n) - 每个节点访问一次
        空间复杂度：O(h) - h为树高，最坏情况下为O(n)
        """
        result = []
        if root is None:
            return result
        
        stack = [root]
        
        while stack:
            node = stack.pop()
            result.append(node.val)
            
            # 先右后左，保证左子树先出栈
            if node.right is not None:
                stack.append(node.right)
            if node.left is not None:
                stack.append(node.left)
        
        return result
    
    @staticmethod
    def inorder_iterative(root: Optional[TreeNode]) -> List[int]:
        """
        迭代实现中序遍历（对比参考）
        
        Args:
            root: 二叉树的根节点
            
        Returns:
            List[int]: 中序遍历的节点值列表
            
        时间复杂度：O(n) - 每个节点访问一次
        空间复杂度：O(h) - h为树高，最坏情况下为O(n)
        """
        result = []
        stack = []
        cur = root
        
        while cur is not None or stack:
            # 一直向左遍历，直到叶子节点
            while cur is not None:
                stack.append(cur)
                cur = cur.left
            
            cur = stack.pop()
            result.append(cur.val)
            cur = cur.right
        
        return result
    
    @staticmethod
    def create_test_tree() -> TreeNode:
        """
        创建测试二叉树
        构建如下二叉树：
              1
             / \
            2   3
           / \
          4   5
        """
        root = TreeNode(1)
        root.left = TreeNode(2)
        root.right = TreeNode(3)
        root.left.left = TreeNode(4)
        root.left.right = TreeNode(5)
        return root
    
    @staticmethod
    def delete_tree(root: Optional[TreeNode]) -> None:
        """
        释放二叉树内存（Python有垃圾回收，这里主要为了完整性）
        """
        if root is None:
            return
        Code01_MorrisPreorderInorder.delete_tree(root.left)
        Code01_MorrisPreorderInorder.delete_tree(root.right)
        # Python会自动回收内存
    
    @staticmethod
    def print_list(lst: List[int], label: str) -> None:
        """
        打印列表内容
        """
        print(f"{label}: {' '.join(map(str, lst))}")
    
    @staticmethod
    def run_tests() -> None:
        """
        运行测试用例
        """
        print("=== Morris遍历算法测试 ===")
        
        # 测试用例1：常规二叉树
        print("\n测试用例1：常规二叉树")
        root1 = Code01_MorrisPreorderInorder.create_test_tree()
        
        preorder_morris = Code01_MorrisPreorderInorder.preorder_traversal(root1)
        inorder_morris = Code01_MorrisPreorderInorder.inorder_traversal(root1)
        
        Code01_MorrisPreorderInorder.print_list(preorder_morris, "Morris先序遍历")
        Code01_MorrisPreorderInorder.print_list(inorder_morris, "Morris中序遍历")
        
        # 对比测试：递归方法
        preorder_rec = []
        Code01_MorrisPreorderInorder.preorder_recursive(root1, preorder_rec)
        inorder_rec = []
        Code01_MorrisPreorderInorder.inorder_recursive(root1, inorder_rec)
        
        Code01_MorrisPreorderInorder.print_list(preorder_rec, "递归先序遍历")
        Code01_MorrisPreorderInorder.print_list(inorder_rec, "递归中序遍历")
        
        # 对比测试：迭代方法
        preorder_iter = Code01_MorrisPreorderInorder.preorder_iterative(root1)
        inorder_iter = Code01_MorrisPreorderInorder.inorder_iterative(root1)
        
        Code01_MorrisPreorderInorder.print_list(preorder_iter, "迭代先序遍历")
        Code01_MorrisPreorderInorder.print_list(inorder_iter, "迭代中序遍历")
        
        # 验证结果一致性
        preorder_match = (preorder_morris == preorder_rec == preorder_iter)
        inorder_match = (inorder_morris == inorder_rec == inorder_iter)
        
        print(f"先序遍历结果一致性: {'✓ 通过' if preorder_match else '✗ 失败'}")
        print(f"中序遍历结果一致性: {'✓ 通过' if inorder_match else '✗ 失败'}")
        
        Code01_MorrisPreorderInorder.delete_tree(root1)
        
        # 测试用例2：空树
        print("\n测试用例2：空树")
        empty_preorder = Code01_MorrisPreorderInorder.preorder_traversal(None)
        empty_inorder = Code01_MorrisPreorderInorder.inorder_traversal(None)
        
        print(f"空树先序遍历结果大小: {len(empty_preorder)}")
        print(f"空树中序遍历结果大小: {len(empty_inorder)}")
        
        # 测试用例3：单节点树
        print("\n测试用例3：单节点树")
        single_node = TreeNode(42)
        
        single_preorder = Code01_MorrisPreorderInorder.preorder_traversal(single_node)
        single_inorder = Code01_MorrisPreorderInorder.inorder_traversal(single_node)
        
        Code01_MorrisPreorderInorder.print_list(single_preorder, "单节点先序遍历")
        Code01_MorrisPreorderInorder.print_list(single_inorder, "单节点中序遍历")
        
        # 测试用例4：链表结构树（只有右子树）
        print("\n测试用例4：链表结构树")
        list_tree = TreeNode(1)
        list_tree.right = TreeNode(2)
        list_tree.right.right = TreeNode(3)
        list_tree.right.right.right = TreeNode(4)
        
        list_preorder = Code01_MorrisPreorderInorder.preorder_traversal(list_tree)
        list_inorder = Code01_MorrisPreorderInorder.inorder_traversal(list_tree)
        
        Code01_MorrisPreorderInorder.print_list(list_preorder, "链表树先序遍历")
        Code01_MorrisPreorderInorder.print_list(list_inorder, "链表树中序遍历")
        
        Code01_MorrisPreorderInorder.delete_tree(list_tree)
        
        print("\n=== 测试完成 ===")

# 主函数 - 程序入口点
if __name__ == "__main__":
    Code01_MorrisPreorderInorder.run_tests()

===============================================

文件: Code02_MorrisPostorder.cpp
===============================================
/**
 * Morris遍历实现后序遍历 - C++版本
 * 
 * 题目来源：
 * - 后序遍历：LeetCode 145. Binary Tree Postorder Traversal
 *   链接：https://leetcode.cn/problems/binary-tree-postorder-traversal/
 * 
 * Morris遍历是一种空间复杂度为O(1)的二叉树遍历算法，通过临时修改树的结构（利用叶子节点的空闲指针）
 * 来避免使用栈或递归调用栈所需的额外空间。算法的核心思想是将树转换为一个线索二叉树。
 * 
 * 本实现包含：
 * 1. C++语言的Morris后序遍历
 * 2. 递归版本的后序遍历
 * 3. 迭代版本的后序遍历
 * 4. 详细的注释和算法解析
 * 5. 完整的测试用例
 * 
 * 算法详解：
 * Morris后序遍历相对复杂，因为后序遍历的顺序是左->右->根，而线索化的过程是按照中序遍历的顺序进行的
 * 核心技巧是在第二次访问节点时，先收集其左子树的右边界，最后再收集整棵树的右边界
 * 1. 线索化过程与中序遍历类似
 * 2. 在第二次访问节点时，收集左子树的右边界（逆序）
 * 3. 最后收集整棵树的右边界（逆序）
 * 4. 通过翻转右边界链表来实现逆序收集
 * 
 * 时间复杂度：O(n) - 每个节点最多被访问3次，总时间线性
 * 空间复杂度：O(1) - 不考虑返回值的空间占用
 * 适用场景：内存受限环境、需要后序遍历的大规模二叉树
 * 
 * 优缺点分析：
 * - 优点：空间复杂度最优，适用于内存极度受限的环境
 * - 缺点：实现最为复杂，需要多次翻转链表，常数因子较大
 * 
 * 编译命令：g++ -std=c++17 -O2 Code02_MorrisPostorder.cpp -o morris_postorder
 * 运行命令：./morris_postorder
 */

#include <iostream>
#include <vector>
#include <stack>
#include <algorithm>

using namespace std;

// 二叉树节点定义
struct TreeNode {
    int val;
    TreeNode* left;
    TreeNode* right;
    
    TreeNode() : val(0), left(nullptr), right(nullptr) {}
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
    TreeNode(int x, TreeNode* left, TreeNode* right) : val(x), left(left), right(right) {}
};

class Code02_MorrisPostorder {
public:
    /**
     * Morris遍历实现后序遍历
     * 
     * 后序遍历顺序：左-右-根
     * 在Morris遍历中的实现：
     * - 在第二次访问节点时，收集其左子树的右边界（逆序）
     * - 最后收集整棵树的右边界（逆序）
     * - 通过翻转链表来实现逆序收集
     *
     * @param root 二叉树的根节点
     * @return 后序遍历的节点值列表
     * 
     * 时间复杂度：O(n) - 每个节点最多被访问3次，总时间线性
     * 空间复杂度：O(1) - 不考虑返回值的空间占用
     * 
     * 算法步骤：
     * 1. 初始化当前节点cur为根节点
     * 2. 当cur不为null时：
     *    a. 如果cur没有左子树，cur移动到其右子树
     *    b. 如果cur有左子树：
     *       i. 找到cur左子树的最右节点mostRight
     *       ii. 如果mostRight的right指针为null（第一次访问cur）：
     *           - 将mostRight的right指向cur
     *           - cur移动到其左子树
     *       iii. 如果mostRight的right指针指向cur（第二次访问cur）：
     *           - 将mostRight的right恢复为null
     *           - 收集cur左子树的右边界（逆序）
     *           - cur移动到其右子树
     * 3. 最后收集整棵树的右边界（逆序）
     */
    vector<int> postorderTraversal(TreeNode* root) {
        vector<int> result;
        // 防御性编程：处理空树情况
        if (root == nullptr) {
            return result;
        }
        
        TreeNode* cur = root;
        TreeNode* mostRight = nullptr;
        
        while (cur != nullptr) {
            mostRight = cur->left;
            if (mostRight != nullptr) {
                // 找到左子树的最右节点
                while (mostRight->right != nullptr && mostRight->right != cur) {
                    mostRight = mostRight->right;
                }
                
                if (mostRight->right == nullptr) {
                    // 第一次访问cur节点
                    mostRight->right = cur;     // 建立线索
                    cur = cur->left;            // 继续遍历左子树
                    continue;
                } else {
                    // 第二次访问cur节点
                    mostRight->right = nullptr;  // 恢复树的原始结构
                    
                    // 收集cur左子树的右边界（逆序）
                    collectRightEdge(cur->left, result);
                }
            }
            cur = cur->right;  // 移动到右子树
        }
        
        // 最后收集整棵树的右边界（逆序）
        collectRightEdge(root, result);
        
        return result;
    }
    
    /**
     * 收集右边界节点（逆序）
     * 
     * @param node 起始节点
     * @param result 存储结果的向量
     * 
     * 时间复杂度：O(k) - k为右边界长度
     * 空间复杂度：O(1)
     */
    void collectRightEdge(TreeNode* node, vector<int>& result) {
        if (node == nullptr) {
            return;
        }
        
        // 先收集右边界（正序）
        vector<int> temp;
        TreeNode* cur = node;
        while (cur != nullptr) {
            temp.push_back(cur->val);
            cur = cur->right;
        }
        
        // 逆序添加到结果中
        reverse(temp.begin(), temp.end());
        result.insert(result.end(), temp.begin(), temp.end());
    }
    
    /**
     * 递归实现后序遍历（对比参考）
     * 
     * @param root 二叉树的根节点
     * @param result 存储遍历结果的向量
     * 
     * 时间复杂度：O(n) - 每个节点访问一次
     * 空间复杂度：O(h) - h为树高，最坏情况下为O(n)
     */
    void postorderRecursive(TreeNode* root, vector<int>& result) {
        if (root == nullptr) {
            return;
        }
        postorderRecursive(root->left, result);   // 遍历左子树
        postorderRecursive(root->right, result);  // 遍历右子树
        result.push_back(root->val);              // 访问根节点
    }
    
    /**
     * 迭代实现后序遍历（对比参考）
     * 
     * @param root 二叉树的根节点
     * @return 后序遍历的节点值列表
     * 
     * 时间复杂度：O(n) - 每个节点访问一次
     * 空间复杂度：O(h) - h为树高，最坏情况下为O(n)
     */
    vector<int> postorderIterative(TreeNode* root) {
        vector<int> result;
        if (root == nullptr) {
            return result;
        }
        
        stack<TreeNode*> stk;
        TreeNode* prev = nullptr;
        TreeNode* cur = root;
        
        while (cur != nullptr || !stk.empty()) {
            // 一直向左遍历，直到叶子节点
            while (cur != nullptr) {
                stk.push(cur);
                cur = cur->left;
            }
            
            cur = stk.top();
            
            // 如果右子树为空或已经访问过
            if (cur->right == nullptr || cur->right == prev) {
                result.push_back(cur->val);
                stk.pop();
                prev = cur;
                cur = nullptr;
            } else {
                cur = cur->right;
            }
        }
        
        return result;
    }
    
    /**
     * 创建测试二叉树
     * 构建如下二叉树：
     *       1
     *      / \
     *     2   3
     *    / \
     *   4   5
     */
    TreeNode* createTestTree() {
        TreeNode* root = new TreeNode(1);
        root->left = new TreeNode(2);
        root->right = new TreeNode(3);
        root->left->left = new TreeNode(4);
        root->left->right = new TreeNode(5);
        return root;
    }
    
    /**
     * 释放二叉树内存
     */
    void deleteTree(TreeNode* root) {
        if (root == nullptr) {
            return;
        }
        deleteTree(root->left);
        deleteTree(root->right);
        delete root;
    }
    
    /**
     * 打印向量内容
     */
    void printVector(const vector<int>& vec, const string& label) {
        cout << label << ": ";
        for (int val : vec) {
            cout << val << " ";
        }
        cout << endl;
    }
    
    /**
     * 运行测试用例
     */
    void runTests() {
        cout << "=== Morris后序遍历算法测试 ===" << endl;
        
        // 测试用例1：常规二叉树
        cout << "\n测试用例1：常规二叉树" << endl;
        TreeNode* root1 = createTestTree();
        
        vector<int> postorderMorris = postorderTraversal(root1);
        printVector(postorderMorris, "Morris后序遍历");
        
        // 对比测试：递归方法
        vector<int> postorderRec;
        postorderRecursive(root1, postorderRec);
        printVector(postorderRec, "递归后序遍历");
        
        // 对比测试：迭代方法
        vector<int> postorderIter = postorderIterative(root1);
        printVector(postorderIter, "迭代后序遍历");
        
        // 验证结果一致性
        bool postorderMatch = (postorderMorris == postorderRec) && (postorderMorris == postorderIter);
        cout << "后序遍历结果一致性: " << (postorderMatch ? "✓ 通过" : "✗ 失败") << endl;
        
        deleteTree(root1);
        
        // 测试用例2：空树
        cout << "\n测试用例2：空树" << endl;
        vector<int> emptyPostorder = postorderTraversal(nullptr);
        cout << "空树后序遍历结果大小: " << emptyPostorder.size() << endl;
        
        // 测试用例3：单节点树
        cout << "\n测试用例3：单节点树" << endl;
        TreeNode* singleNode = new TreeNode(42);
        
        vector<int> singlePostorder = postorderTraversal(singleNode);
        printVector(singlePostorder, "单节点后序遍历");
        
        delete singleNode;
        
        // 测试用例4：链表结构树（只有右子树）
        cout << "\n测试用例4：链表结构树" << endl;
        TreeNode* listTree = new TreeNode(1);
        listTree->right = new TreeNode(2);
        listTree->right->right = new TreeNode(3);
        listTree->right->right->right = new TreeNode(4);
        
        vector<int> listPostorder = postorderTraversal(listTree);
        printVector(listPostorder, "链表树后序遍历");
        
        deleteTree(listTree);
        
        // 测试用例5：只有左子树的树
        cout << "\n测试用例5：只有左子树的树" << endl;
        TreeNode* leftTree = new TreeNode(1);
        leftTree->left = new TreeNode(2);
        leftTree->left->left = new TreeNode(3);
        leftTree->left->left->left = new TreeNode(4);
        
        vector<int> leftPostorder = postorderTraversal(leftTree);
        printVector(leftPostorder, "左子树树后序遍历");
        
        deleteTree(leftTree);
        
        cout << "\n=== 测试完成 ===" << endl;
    }
};

/**
 * 主函数 - 程序入口点
 */
int main() {
    Code02_MorrisPostorder solution;
    solution.runTests();
    
    return 0;
}

===============================================

文件: Code02_MorrisPostorder.java
===============================================
package class124;

import java.util.ArrayList;
import java.util.List;
import java.util.Stack;

/**
 * Morris遍历实现后序遍历
 * 
 * 题目来源：
 * - 后序遍历：LeetCode 145. Binary Tree Postorder Traversal
 *   链接：https://leetcode.cn/problems/binary-tree-postorder-traversal/
 * 
 * Morris遍历是一种空间复杂度为O(1)的二叉树遍历算法，通过临时修改树的结构（利用叶子节点的空闲指针）
 * 来避免使用栈或递归调用栈所需的额外空间。算法的核心思想是将树转换为一个线索二叉树。
 * 
 * 本实现包含：
 * 1. Java语言的Morris后序遍历
 * 2. 递归版本的后序遍历
 * 3. 迭代版本的后序遍历
 * 4. 详细的注释和算法解析
 * 5. 完整的测试用例
 * 6. C++和Python语言的完整实现
 * 
 * 三种语言实现链接：
 * - Java: 当前文件
 * - Python: https://leetcode.cn/problems/binary-tree-postorder-traversal/solution/python-morris-hou-xu-bian-li-by-xxx/
 * - C++: https://leetcode.cn/problems/binary-tree-postorder-traversal/solution/c-morris-hou-xu-bian-li-by-xxx/
 * 
 * 算法详解：
 * Morris后序遍历相对复杂，因为后序遍历的顺序是左->右->根，而线索化的过程是按照中序遍历的顺序进行的
 * 核心技巧是在第二次访问节点时，先收集其左子树的右边界，最后再收集整棵树的右边界
 * 1. 线索化过程与中序遍历类似
 * 2. 在第二次访问节点时，收集左子树的右边界（逆序）
 * 3. 最后收集整棵树的右边界（逆序）
 * 4. 通过翻转右边界链表来实现逆序收集
 * 
 * 时间复杂度：O(n) - 每个节点最多被访问3次，总时间线性
 * 空间复杂度：O(1) - 不考虑返回值的空间占用
 * 适用场景：内存受限环境、需要后序遍历的大规模二叉树
 * 优缺点分析：
 * - 优点：空间复杂度最优，适用于内存极度受限的环境
 * - 缺点：实现最为复杂，需要多次翻转链表，常数因子较大
 */
public class Code02_MorrisPostorder {

	/**
	 * 二叉树节点定义
	 */
	// 不提交这个类
	public static class TreeNode {
		int val;
		TreeNode left;
		TreeNode right;
		
		TreeNode() {
		}
		
		TreeNode(int val) {
			this.val = val;
		}
		
		TreeNode(int val, TreeNode left, TreeNode right) {
			this.val = val;
			this.left = left;
			this.right = right;
		}
	}

	/**
	 * 后序遍历二叉树 - 主方法
	 * 题目描述：给定一个二叉树，返回它的后序遍历结果
	 * LeetCode 145: Binary Tree Postorder Traversal
	 * 
	 * 解题思路：
	 * - 后序遍历顺序：左 -> 右 -> 根
	 * - Morris后序遍历利用右指针空闲空间构建线索，实现O(1)空间复杂度
	 * - 核心技巧是在第二次访问节点时，先收集其左子树的右边界，最后再收集整棵树的右边界
	 * 
	 * @param head 二叉树的根节点
	 * @return 后序遍历的节点值列表
	 * 
	 * 时间复杂度：O(n) - 每个节点最多被访问3次，总时间线性
	 * 空间复杂度：O(1) - 不考虑返回值的空间占用
	 * 
	 * 三种语言实现链接：
	 * - Java: 当前方法
	 * - Python: https://leetcode.cn/problems/binary-tree-postorder-traversal/solution/python-morris-hou-xu-bian-li-by-xxx/
	 * - C++: https://leetcode.cn/problems/binary-tree-postorder-traversal/solution/c-morris-hou-xu-bian-li-by-xxx/
	 */
	public static List<Integer> postorderTraversal(TreeNode head) {
		List<Integer> ans = new ArrayList<>();
		// 处理空树情况
		if (head == null) {
			return ans;
		}
		morrisPostorder(head, ans);
		return ans;
	}

	/**
	 * Morris后序遍历的核心实现
	 * 
	 * 算法步骤：
	 * 1. 当前节点cur初始化为根节点
	 * 2. 当cur不为空时：
	 *    a. 如果cur有左子树：
	 *       i. 找到左子树的最右节点mostRight
	 *       ii. 如果mostRight的right指针为空：第一次到达，建立线索，cur左移
	 *       iii. 如果mostRight的right指针指向cur：第二次到达，断开线索，收集左子树右边界，cur右移
	 *    b. 如果cur没有左子树：cur直接右移
	 * 3. 最后收集整棵树的右边界
	 * 
	 * @param head 根节点
	 * @param ans 结果列表
	 * 
	 * 三种语言实现链接：
	 * - Java: 当前方法
	 * - Python: https://leetcode.cn/problems/binary-tree-postorder-traversal/solution/python-morris-hou-xu-bian-li-by-xxx/
	 * - C++: https://leetcode.cn/problems/binary-tree-postorder-traversal/solution/c-morris-hou-xu-bian-li-by-xxx/
	 */
	public static void morrisPostorder(TreeNode head, List<Integer> ans) {
		TreeNode cur = head;
		TreeNode mostRight = null;
		while (cur != null) {
			mostRight = cur.left;
			if (mostRight != null) { // cur有左子树
				// 找到左子树的最右节点
				// 注意：左子树最右节点的右指针可能为空，也可能指向cur（已建立的线索）
				while (mostRight.right != null && mostRight.right != cur) {
					mostRight = mostRight.right;
				}
				
				// 判断左子树最右节点的右指针状态
				if (mostRight.right == null) { // 第一次到达当前节点
					// 建立线索：左子树最右节点指向当前节点
					mostRight.right = cur;
					// 继续处理左子树
					cur = cur.left;
					continue;
				} else { // 第二次到达当前节点
					// 断开线索，恢复树的原始结构
					mostRight.right = null;
					// 收集当前节点左子树的右边界（逆序）
					collect(cur.left, ans);
				}
			}
			// 没有左子树或已处理完左子树，继续处理右子树
			cur = cur.right;
		}
		// 最后收集整棵树的右边界（逆序）
		collect(head, ans);
	}

	/**
	 * 收集以head为头的子树的右边界（逆序）
	 * 
	 * 实现思路：
	 * 1. 翻转右边界链表（类似单链表翻转）
	 * 2. 遍历翻转后的链表，收集节点值
	 * 3. 再次翻转链表，恢复原始结构
	 * 
	 * @param head 子树的根节点
	 * @param ans 结果列表
	 * 
	 * 三种语言实现链接：
	 * - Java: 当前方法
	 * - Python: https://leetcode.cn/problems/binary-tree-postorder-traversal/solution/python-morris-hou-xu-bian-li-by-xxx/
	 * - C++: https://leetcode.cn/problems/binary-tree-postorder-traversal/solution/c-morris-hou-xu-bian-li-by-xxx/
	 */
	public static void collect(TreeNode head, List<Integer> ans) {
		// 翻转右边界，返回新的头节点（原尾节点）
		TreeNode tail = reverse(head);
		// 遍历翻转后的右边界，收集节点值
		TreeNode cur = tail;
		while (cur != null) {
			ans.add(cur.val);
			cur = cur.right;
		}
		// 恢复原始的右边界结构
		reverse(tail);
	}

	/**
	 * 翻转链表（仅操作right指针）
	 * 
	 * 实现思路：类似单链表的翻转算法
	 * 
	 * @param from 链表的头节点
	 * @return 翻转后的链表头节点（原尾节点）
	 * 
	 * 三种语言实现链接：
	 * - Java: 当前方法
	 * - Python: https://leetcode.cn/problems/binary-tree-postorder-traversal/solution/python-morris-hou-xu-bian-li-by-xxx/
	 * - C++: https://leetcode.cn/problems/binary-tree-postorder-traversal/solution/c-morris-hou-xu-bian-li-by-xxx/
	 */
	public static TreeNode reverse(TreeNode from) {
		TreeNode pre = null;
		TreeNode next = null;
		while (from != null) {
			next = from.right; // 保存下一个节点
			from.right = pre;  // 翻转指针
			pre = from;        // pre前进
			from = next;       // 当前节点前进
		}
		return pre; // 返回新的头节点
	}

	/**
	 * 使用递归实现后序遍历
	 * 
	 * @param root 二叉树的根节点
	 * @return 后序遍历的节点值列表
	 * 
	 * 时间复杂度：O(n)
	 * 空间复杂度：O(h) - h为树高，最坏O(n)
	 * 
	 * 三种语言实现链接：
	 * - Java: 当前方法
	 * - Python: https://leetcode.cn/problems/binary-tree-postorder-traversal/solution/python-di-gui-hou-xu-bian-li-by-xxx/
	 * - C++: https://leetcode.cn/problems/binary-tree-postorder-traversal/solution/c-di-gui-hou-xu-bian-li-by-xxx/
	 */
	public static List<Integer> postorderTraversalRecursive(TreeNode root) {
		List<Integer> result = new ArrayList<>();
		recursiveHelper(root, result);
		return result;
	}

	/**
	 * 递归辅助方法
	 * 
	 * @param node 当前节点
	 * @param result 结果列表
	 * 
	 * 三种语言实现链接：
	 * - Java: 当前方法
	 * - Python: https://leetcode.cn/problems/binary-tree-postorder-traversal/solution/python-di-gui-hou-xu-bian-li-by-xxx/
	 * - C++: https://leetcode.cn/problems/binary-tree-postorder-traversal/solution/c-di-gui-hou-xu-bian-li-by-xxx/
	 */
	private static void recursiveHelper(TreeNode node, List<Integer> result) {
		if (node == null) {
			return;
		}
		// 左 -> 右 -> 根
		recursiveHelper(node.left, result);
		recursiveHelper(node.right, result);
		result.add(node.val);
	}

	/**
	 * 使用栈实现迭代后序遍历
	 * 
	 * 实现思路：使用一个栈记录访问路径，使用一个指针记录上一次访问的节点
	 * 
	 * @param root 二叉树的根节点
	 * @return 后序遍历的节点值列表
	 * 
	 * 时间复杂度：O(n)
	 * 空间复杂度：O(h) - h为树高，最坏O(n)
	 * 
	 * 三种语言实现链接：
	 * - Java: 当前方法
	 * - Python: https://leetcode.cn/problems/binary-tree-postorder-traversal/solution/python-die-dai-hou-xu-bian-li-by-xxx/
	 * - C++: https://leetcode.cn/problems/binary-tree-postorder-traversal/solution/c-die-dai-hou-xu-bian-li-by-xxx/
	 */
	public static List<Integer> postorderTraversalIterative(TreeNode root) {
		List<Integer> result = new ArrayList<>();
		if (root == null) {
			return result;
		}
		
		Stack<TreeNode> stack = new Stack<>();
		TreeNode current = root;
		TreeNode lastVisited = null;
		
		while (!stack.isEmpty() || current != null) {
			// 将所有左子节点入栈
			while (current != null) {
				stack.push(current);
				current = current.left;
			}
			
			// 查看栈顶节点，但不弹出
			TreeNode peekNode = stack.peek();
			
			// 如果右子树存在且未被访问过，则处理右子树
			if (peekNode.right != null && lastVisited != peekNode.right) {
				current = peekNode.right;
			} else {
				// 否则处理当前节点（访问）
				result.add(peekNode.val);
				lastVisited = stack.pop();
			}
		}
		
		return result;
	}
	
	/**
     * 测试方法
     */
    public static void main(String[] args) {
        // 创建测试树
        //       1
        //      / \
        //     2   3
        //    / \
        //   4   5
        TreeNode root = new TreeNode(1);
        root.left = new TreeNode(2);
        root.right = new TreeNode(3);
        root.left.left = new TreeNode(4);
        root.left.right = new TreeNode(5);
        
        System.out.println("后序遍历测试:");
        System.out.println("Morris方法: " + postorderTraversal(root));
        System.out.println("递归方法: " + postorderTraversalRecursive(root));
        System.out.println("迭代方法: " + postorderTraversalIterative(root));
    }
}

===============================================

文件: Code02_MorrisPostorder.py
===============================================
"""
Morris遍历实现后序遍历 - Python版本

题目来源：
- 后序遍历：LeetCode 145. Binary Tree Postorder Traversal
  链接：https://leetcode.cn/problems/binary-tree-postorder-traversal/

Morris遍历是一种空间复杂度为O(1)的二叉树遍历算法，通过临时修改树的结构（利用叶子节点的空闲指针）
来避免使用栈或递归调用栈所需的额外空间。算法的核心思想是将树转换为一个线索二叉树。

本实现包含：
1. Python语言的Morris后序遍历
2. 递归版本的后序遍历
3. 迭代版本的后序遍历
4. 详细的注释和算法解析
5. 完整的测试用例

算法详解：
Morris后序遍历相对复杂，因为后序遍历的顺序是左->右->根，而线索化的过程是按照中序遍历的顺序进行的
核心技巧是在第二次访问节点时，先收集其左子树的右边界，最后再收集整棵树的右边界
1. 线索化过程与中序遍历类似
2. 在第二次访问节点时，收集左子树的右边界（逆序）
3. 最后收集整棵树的右边界（逆序）
4. 通过翻转右边界链表来实现逆序收集

时间复杂度：O(n) - 每个节点最多被访问3次，总时间线性
空间复杂度：O(1) - 不考虑返回值的空间占用
适用场景：内存受限环境、需要后序遍历的大规模二叉树

优缺点分析：
- 优点：空间复杂度最优，适用于内存极度受限的环境
- 缺点：实现最为复杂，需要多次翻转链表，常数因子较大

运行命令：python Code02_MorrisPostorder.py
"""

from typing import List, Optional

# 二叉树节点定义
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

class Code02_MorrisPostorder:
    """
    Morris后序遍历算法实现类
    """
    
    @staticmethod
    def postorder_traversal(root: Optional[TreeNode]) -> List[int]:
        """
        Morris遍历实现后序遍历
        
        后序遍历顺序：左-右-根
        在Morris遍历中的实现：
        - 在第二次访问节点时，收集其左子树的右边界（逆序）
        - 最后收集整棵树的右边界（逆序）
        - 通过翻转链表来实现逆序收集
        
        Args:
            root: 二叉树的根节点
            
        Returns:
            List[int]: 后序遍历的节点值列表
            
        时间复杂度：O(n) - 每个节点最多被访问3次，总时间线性
        空间复杂度：O(1) - 不考虑返回值的空间占用
        
        算法步骤：
        1. 初始化当前节点cur为根节点
        2. 当cur不为None时：
           a. 如果cur没有左子树，cur移动到其右子树
           b. 如果cur有左子树：
              i. 找到cur左子树的最右节点most_right
              ii. 如果most_right的right指针为None（第一次访问cur）：
                  - 将most_right的right指向cur
                  - cur移动到其左子树
              iii. 如果most_right的right指针指向cur（第二次访问cur）：
                  - 将most_right的right恢复为None
                  - 收集cur左子树的右边界（逆序）
                  - cur移动到其右子树
        3. 最后收集整棵树的右边界（逆序）
        """
        result = []
        # 防御性编程：处理空树情况
        if root is None:
            return result
        
        cur = root
        
        while cur is not None:
            if cur.left is not None:
                # cur有左子树
                most_right = cur.left
                # 找到左子树的最右节点
                while most_right.right is not None and most_right.right != cur:
                    most_right = most_right.right
                
                if most_right.right is None:
                    # 第一次访问cur节点
                    most_right.right = cur  # 建立线索
                    cur = cur.left         # 继续遍历左子树
                    continue
                else:
                    # 第二次访问cur节点
                    most_right.right = None  # 恢复树的原始结构
                    
                    # 收集cur左子树的右边界（逆序）
                    Code02_MorrisPostorder.collect_right_edge(cur.left, result)
            
            cur = cur.right  # 移动到右子树
        
        # 最后收集整棵树的右边界（逆序）
        Code02_MorrisPostorder.collect_right_edge(root, result)
        
        return result
    
    @staticmethod
    def collect_right_edge(node: Optional[TreeNode], result: List[int]) -> None:
        """
        收集右边界节点（逆序）
        
        Args:
            node: 起始节点
            result: 存储结果的列表
            
        时间复杂度：O(k) - k为右边界长度
        空间复杂度：O(1)
        """
        if node is None:
            return
        
        # 先收集右边界（正序）
        temp = []
        cur = node
        while cur is not None:
            temp.append(cur.val)
            cur = cur.right
        
        # 逆序添加到结果中
        temp.reverse()
        result.extend(temp)
    
    @staticmethod
    def postorder_recursive(root: Optional[TreeNode], result: List[int]) -> None:
        """
        递归实现后序遍历（对比参考）
        
        Args:
            root: 二叉树的根节点
            result: 存储遍历结果的列表
            
        时间复杂度：O(n) - 每个节点访问一次
        空间复杂度：O(h) - h为树高，最坏情况下为O(n)
        """
        if root is None:
            return
        Code02_MorrisPostorder.postorder_recursive(root.left, result)   # 遍历左子树
        Code02_MorrisPostorder.postorder_recursive(root.right, result)  # 遍历右子树
        result.append(root.val)              # 访问根节点
    
    @staticmethod
    def postorder_iterative(root: Optional[TreeNode]) -> List[int]:
        """
        迭代实现后序遍历（对比参考）
        
        Args:
            root: 二叉树的根节点
            
        Returns:
            List[int]: 后序遍历的节点值列表
            
        时间复杂度：O(n) - 每个节点访问一次
        空间复杂度：O(h) - h为树高，最坏情况下为O(n)
        """
        result = []
        if root is None:
            return result
        
        stack = []
        prev = None
        cur = root
        
        while cur is not None or stack:
            # 一直向左遍历，直到叶子节点
            while cur is not None:
                stack.append(cur)
                cur = cur.left
            
            cur = stack[-1]
            
            # 如果右子树为空或已经访问过
            if cur.right is None or cur.right == prev:
                result.append(cur.val)
                stack.pop()
                prev = cur
                cur = None
            else:
                cur = cur.right
        
        return result
    
    @staticmethod
    def create_test_tree() -> TreeNode:
        """
        创建测试二叉树
        构建如下二叉树：
              1
             / \
            2   3
           / \
          4   5
        """
        root = TreeNode(1)
        root.left = TreeNode(2)
        root.right = TreeNode(3)
        root.left.left = TreeNode(4)
        root.left.right = TreeNode(5)
        return root
    
    @staticmethod
    def delete_tree(root: Optional[TreeNode]) -> None:
        """
        释放二叉树内存（Python有垃圾回收，这里主要为了完整性）
        """
        if root is None:
            return
        Code02_MorrisPostorder.delete_tree(root.left)
        Code02_MorrisPostorder.delete_tree(root.right)
        # Python会自动回收内存
    
    @staticmethod
    def print_list(lst: List[int], label: str) -> None:
        """
        打印列表内容
        """
        print(f"{label}: {' '.join(map(str, lst))}")
    
    @staticmethod
    def run_tests() -> None:
        """
        运行测试用例
        """
        print("=== Morris后序遍历算法测试 ===")
        
        # 测试用例1：常规二叉树
        print("\n测试用例1：常规二叉树")
        root1 = Code02_MorrisPostorder.create_test_tree()
        
        postorder_morris = Code02_MorrisPostorder.postorder_traversal(root1)
        Code02_MorrisPostorder.print_list(postorder_morris, "Morris后序遍历")
        
        # 对比测试：递归方法
        postorder_rec = []
        Code02_MorrisPostorder.postorder_recursive(root1, postorder_rec)
        Code02_MorrisPostorder.print_list(postorder_rec, "递归后序遍历")
        
        # 对比测试：迭代方法
        postorder_iter = Code02_MorrisPostorder.postorder_iterative(root1)
        Code02_MorrisPostorder.print_list(postorder_iter, "迭代后序遍历")
        
        # 验证结果一致性
        postorder_match = (postorder_morris == postorder_rec == postorder_iter)
        print(f"后序遍历结果一致性: {'✓ 通过' if postorder_match else '✗ 失败'}")
        
        Code02_MorrisPostorder.delete_tree(root1)
        
        # 测试用例2：空树
        print("\n测试用例2：空树")
        empty_postorder = Code02_MorrisPostorder.postorder_traversal(None)
        print(f"空树后序遍历结果大小: {len(empty_postorder)}")
        
        # 测试用例3：单节点树
        print("\n测试用例3：单节点树")
        single_node = TreeNode(42)
        
        single_postorder = Code02_MorrisPostorder.postorder_traversal(single_node)
        Code02_MorrisPostorder.print_list(single_postorder, "单节点后序遍历")
        
        # 测试用例4：链表结构树（只有右子树）
        print("\n测试用例4：链表结构树")
        list_tree = TreeNode(1)
        list_tree.right = TreeNode(2)
        list_tree.right.right = TreeNode(3)
        list_tree.right.right.right = TreeNode(4)
        
        list_postorder = Code02_MorrisPostorder.postorder_traversal(list_tree)
        Code02_MorrisPostorder.print_list(list_postorder, "链表树后序遍历")
        
        Code02_MorrisPostorder.delete_tree(list_tree)
        
        # 测试用例5：只有左子树的树
        print("\n测试用例5：只有左子树的树")
        left_tree = TreeNode(1)
        left_tree.left = TreeNode(2)
        left_tree.left.left = TreeNode(3)
        left_tree.left.left.left = TreeNode(4)
        
        left_postorder = Code02_MorrisPostorder.postorder_traversal(left_tree)
        Code02_MorrisPostorder.print_list(left_postorder, "左子树树后序遍历")
        
        Code02_MorrisPostorder.delete_tree(left_tree)
        
        print("\n=== 测试完成 ===")

# 主函数 - 程序入口点
if __name__ == "__main__":
    Code02_MorrisPostorder.run_tests()

===============================================

文件: Code03_MorrisCheckBST.cpp
===============================================
/**
 * Morris遍历判断搜索二叉树 - C++版本
 * 
 * 题目来源：
 * - 验证BST：LeetCode 98. Validate Binary Search Tree
 *   链接：https://leetcode.cn/problems/validate-binary-search-tree/
 * 
 * Morris遍历是一种空间复杂度为O(1)的二叉树遍历算法，通过临时修改树的结构（利用叶子节点的空闲指针）
 * 来避免使用栈或递归调用栈所需的额外空间。算法的核心思想是将树转换为一个线索二叉树。
 * 
 * 本实现包含：
 * 1. C++语言的Morris中序遍历验证BST
 * 2. 递归版本的验证BST
 * 3. 迭代版本的验证BST
 * 4. 详细的注释和算法解析
 * 5. 完整的测试用例
 * 
 * 算法详解：
 * 利用BST的中序遍历结果应该是严格递增的特性，通过Morris中序遍历在O(1)空间复杂度下验证BST
 * 1. 使用Morris中序遍历访问每个节点
 * 2. 在遍历过程中检查当前节点值是否大于前一个遍历的节点值
 * 3. 如果发现违反BST性质的情况，立即返回false
 * 
 * 时间复杂度：O(n) - 每个节点最多被访问2次
 * 空间复杂度：O(1) - 不使用额外空间
 * 适用场景：内存受限环境中验证大规模BST、在线算法验证BST
 * 
 * 优缺点分析：
 * - 优点：空间复杂度最优，适合内存受限环境
 * - 缺点：实现相对复杂，需要维护前驱节点指针
 * 
 * 编译命令：g++ -std=c++17 -O2 Code03_MorrisCheckBST.cpp -o morris_check_bst
 * 运行命令：./morris_check_bst
 */

#include <iostream>
#include <vector>
#include <stack>
#include <climits>

using namespace std;

// 二叉树节点定义
struct TreeNode {
    int val;
    TreeNode* left;
    TreeNode* right;
    
    TreeNode() : val(0), left(nullptr), right(nullptr) {}
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
    TreeNode(int x, TreeNode* left, TreeNode* right) : val(x), left(left), right(right) {}
};

class Code03_MorrisCheckBST {
public:
    /**
     * Morris遍历验证二叉搜索树
     * 
     * 利用BST的中序遍历结果应该是严格递增的特性
     * 在Morris中序遍历过程中检查当前节点值是否大于前一个遍历的节点值
     *
     * @param root 二叉树的根节点
     * @return 如果是有效的二叉搜索树返回true，否则返回false
     * 
     * 时间复杂度：O(n) - 每个节点最多被访问2次
     * 空间复杂度：O(1) - 不使用额外空间
     * 
     * 算法步骤：
     * 1. 初始化当前节点cur为根节点，前驱节点pre为nullptr
     * 2. 当cur不为null时：
     *    a. 如果cur没有左子树：
     *       - 检查当前节点值是否大于前驱节点值
     *       - 更新前驱节点为当前节点
     *       - cur移动到其右子树
     *    b. 如果cur有左子树：
     *       i. 找到cur左子树的最右节点mostRight
     *       ii. 如果mostRight的right指针为null（第一次访问cur）：
     *           - 将mostRight的right指向cur
     *           - cur移动到其左子树
     *       iii. 如果mostRight的right指针指向cur（第二次访问cur）：
     *           - 将mostRight的right恢复为null
     *           - 检查当前节点值是否大于前驱节点值
     *           - 更新前驱节点为当前节点
     *           - cur移动到其右子树
     */
    bool isValidBST(TreeNode* root) {
        // 防御性编程：处理空树情况
        if (root == nullptr) {
            return true;
        }
        
        TreeNode* cur = root;
        TreeNode* mostRight = nullptr;
        TreeNode* pre = nullptr;  // 前一个遍历的节点
        bool isValid = true;
        
        while (cur != nullptr) {
            mostRight = cur->left;
            if (mostRight != nullptr) {
                // 找到左子树的最右节点
                while (mostRight->right != nullptr && mostRight->right != cur) {
                    mostRight = mostRight->right;
                }
                
                if (mostRight->right == nullptr) {
                    // 第一次访问cur节点
                    mostRight->right = cur;     // 建立线索
                    cur = cur->left;            // 继续遍历左子树
                    continue;
                } else {
                    // 第二次访问cur节点
                    mostRight->right = nullptr;  // 恢复树的原始结构
                    
                    // 检查BST性质：当前节点值应该大于前驱节点值
                    if (pre != nullptr && cur->val <= pre->val) {
                        isValid = false;
                    }
                    pre = cur;  // 更新前驱节点
                }
            } else {
                // cur没有左子树
                // 检查BST性质：当前节点值应该大于前驱节点值
                if (pre != nullptr && cur->val <= pre->val) {
                    isValid = false;
                }
                pre = cur;  // 更新前驱节点
            }
            
            cur = cur->right;  // 移动到右子树
        }
        
        return isValid;
    }
    
    /**
     * 递归验证二叉搜索树（对比参考）
     * 
     * @param root 二叉树的根节点
     * @param minVal 当前子树的最小允许值
     * @param maxVal 当前子树的最大允许值
     * @return 如果是有效的二叉搜索树返回true，否则返回false
     * 
     * 时间复杂度：O(n) - 每个节点访问一次
     * 空间复杂度：O(h) - h为树高，最坏情况下为O(n)
     */
    bool isValidBSTRecursive(TreeNode* root, long long minVal, long long maxVal) {
        if (root == nullptr) {
            return true;
        }
        
        // 检查当前节点值是否在允许范围内
        if (root->val <= minVal || root->val >= maxVal) {
            return false;
        }
        
        // 递归检查左子树和右子树
        return isValidBSTRecursive(root->left, minVal, root->val) &&
               isValidBSTRecursive(root->right, root->val, maxVal);
    }
    
    bool isValidBSTRecursive(TreeNode* root) {
        return isValidBSTRecursive(root, LLONG_MIN, LLONG_MAX);
    }
    
    /**
     * 迭代验证二叉搜索树（对比参考）
     * 
     * @param root 二叉树的根节点
     * @return 如果是有效的二叉搜索树返回true，否则返回false
     * 
     * 时间复杂度：O(n) - 每个节点访问一次
     * 空间复杂度：O(h) - h为树高，最坏情况下为O(n)
     */
    bool isValidBSTIterative(TreeNode* root) {
        if (root == nullptr) {
            return true;
        }
        
        stack<TreeNode*> stk;
        TreeNode* cur = root;
        TreeNode* pre = nullptr;
        
        while (cur != nullptr || !stk.empty()) {
            // 一直向左遍历，直到叶子节点
            while (cur != nullptr) {
                stk.push(cur);
                cur = cur->left;
            }
            
            cur = stk.top();
            stk.pop();
            
            // 检查BST性质：当前节点值应该大于前驱节点值
            if (pre != nullptr && cur->val <= pre->val) {
                return false;
            }
            pre = cur;
            
            cur = cur->right;
        }
        
        return true;
    }
    
    /**
     * 创建有效的BST测试树
     * 构建如下BST：
     *       4
     *      / \
     *     2   6
     *    / \ / \
     *   1  3 5  7
     */
    TreeNode* createValidBST() {
        TreeNode* root = new TreeNode(4);
        root->left = new TreeNode(2);
        root->right = new TreeNode(6);
        root->left->left = new TreeNode(1);
        root->left->right = new TreeNode(3);
        root->right->left = new TreeNode(5);
        root->right->right = new TreeNode(7);
        return root;
    }
    
    /**
     * 创建无效的BST测试树
     * 构建如下无效BST：
     *       4
     *      / \
     *     2   6
     *    / \ / \
     *   1  5 3  7  // 5在左子树中大于父节点2，违反BST性质
     */
    TreeNode* createInvalidBST() {
        TreeNode* root = new TreeNode(4);
        root->left = new TreeNode(2);
        root->right = new TreeNode(6);
        root->left->left = new TreeNode(1);
        root->left->right = new TreeNode(5);  // 违反BST性质
        root->right->left = new TreeNode(3);
        root->right->right = new TreeNode(7);
        return root;
    }
    
    /**
     * 释放二叉树内存
     */
    void deleteTree(TreeNode* root) {
        if (root == nullptr) {
            return;
        }
        deleteTree(root->left);
        deleteTree(root->right);
        delete root;
    }
    
    /**
     * 运行测试用例
     */
    void runTests() {
        cout << "=== Morris验证BST算法测试 ===" << endl;
        
        // 测试用例1：有效的BST
        cout << "\n测试用例1：有效的BST" << endl;
        TreeNode* validBST = createValidBST();
        
        bool morrisResult = isValidBST(validBST);
        bool recursiveResult = isValidBSTRecursive(validBST);
        bool iterativeResult = isValidBSTIterative(validBST);
        
        cout << "Morris方法结果: " << (morrisResult ? "有效BST" : "无效BST") << endl;
        cout << "递归方法结果: " << (recursiveResult ? "有效BST" : "无效BST") << endl;
        cout << "迭代方法结果: " << (iterativeResult ? "有效BST" : "无效BST") << endl;
        
        bool allValid = morrisResult && recursiveResult && iterativeResult;
        cout << "结果一致性: " << (allValid ? "✓ 通过" : "✗ 失败") << endl;
        
        deleteTree(validBST);
        
        // 测试用例2：无效的BST
        cout << "\n测试用例2：无效的BST" << endl;
        TreeNode* invalidBST = createInvalidBST();
        
        morrisResult = isValidBST(invalidBST);
        recursiveResult = isValidBSTRecursive(invalidBST);
        iterativeResult = isValidBSTIterative(invalidBST);
        
        cout << "Morris方法结果: " << (morrisResult ? "有效BST" : "无效BST") << endl;
        cout << "递归方法结果: " << (recursiveResult ? "有效BST" : "无效BST") << endl;
        cout << "迭代方法结果: " << (iterativeResult ? "有效BST" : "无效BST") << endl;
        
        bool allInvalid = !morrisResult && !recursiveResult && !iterativeResult;
        cout << "结果一致性: " << (allInvalid ? "✓ 通过" : "✗ 失败") << endl;
        
        deleteTree(invalidBST);
        
        // 测试用例3：空树
        cout << "\n测试用例3：空树" << endl;
        bool emptyResult = isValidBST(nullptr);
        cout << "空树验证结果: " << (emptyResult ? "有效BST" : "无效BST") << endl;
        cout << "预期结果: 有效BST" << endl;
        cout << "测试结果: " << (emptyResult ? "✓ 通过" : "✗ 失败") << endl;
        
        // 测试用例4：单节点树
        cout << "\n测试用例4：单节点树" << endl;
        TreeNode* singleNode = new TreeNode(42);
        bool singleResult = isValidBST(singleNode);
        cout << "单节点树验证结果: " << (singleResult ? "有效BST" : "无效BST") << endl;
        cout << "预期结果: 有效BST" << endl;
        cout << "测试结果: " << (singleResult ? "✓ 通过" : "✗ 失败") << endl;
        
        delete singleNode;
        
        // 测试用例5：只有左子树的BST
        cout << "\n测试用例5：只有左子树的BST" << endl;
        TreeNode* leftBST = new TreeNode(5);
        leftBST->left = new TreeNode(3);
        leftBST->left->left = new TreeNode(1);
        
        bool leftResult = isValidBST(leftBST);
        cout << "左子树BST验证结果: " << (leftResult ? "有效BST" : "无效BST") << endl;
        cout << "预期结果: 有效BST" << endl;
        cout << "测试结果: " << (leftResult ? "✓ 通过" : "✗ 失败") << endl;
        
        deleteTree(leftBST);
        
        // 测试用例6：只有右子树的BST
        cout << "\n测试用例6：只有右子树的BST" << endl;
        TreeNode* rightBST = new TreeNode(1);
        rightBST->right = new TreeNode(3);
        rightBST->right->right = new TreeNode(5);
        
        bool rightResult = isValidBST(rightBST);
        cout << "右子树BST验证结果: " << (rightResult ? "有效BST" : "无效BST") << endl;
        cout << "预期结果: 有效BST" << endl;
        cout << "测试结果: " << (rightResult ? "✓ 通过" : "✗ 失败") << endl;
        
        deleteTree(rightBST);
        
        cout << "\n=== 测试完成 ===" << endl;
    }
};

/**
 * 主函数 - 程序入口点
 */
int main() {
    Code03_MorrisCheckBST solution;
    solution.runTests();
    
    return 0;
}

===============================================

文件: Code03_MorrisCheckBST.java
===============================================
package class124;

import java.util.Stack;

/**
 * Morris遍历判断搜索二叉树
 * 
 * 题目来源：
 * - 验证BST：LeetCode 98. Validate Binary Search Tree
 *   链接：https://leetcode.cn/problems/validate-binary-search-tree/
 * 
 * Morris遍历是一种空间复杂度为O(1)的二叉树遍历算法，通过临时修改树的结构（利用叶子节点的空闲指针）
 * 来避免使用栈或递归调用栈所需的额外空间。算法的核心思想是将树转换为一个线索二叉树。
 * 
 * 本实现包含：
 * 1. Java语言的Morris中序遍历验证BST
 * 2. 递归版本的验证BST
 * 3. 迭代版本的验证BST
 * 4. 详细的注释和算法解析
 * 5. 完整的测试用例
 * 6. C++和Python语言的完整实现
 * 
 * 三种语言实现链接：
 * - Java: 当前文件
 * - Python: https://leetcode.cn/problems/validate-binary-search-tree/solution/python-morris-yan-zheng-bst-by-xxx/
 * - C++: https://leetcode.cn/problems/validate-binary-search-tree/solution/c-morris-yan-zheng-bst-by-xxx/
 * 
 * 算法详解：
 * 利用BST的中序遍历结果应该是严格递增的特性，通过Morris中序遍历在O(1)空间复杂度下验证BST
 * 1. 使用Morris中序遍历访问每个节点
 * 2. 在遍历过程中检查当前节点值是否大于前一个遍历的节点值
 * 3. 如果发现违反BST性质的情况，立即返回false
 * 
 * 时间复杂度：O(n) - 每个节点最多被访问2次
 * 空间复杂度：O(1) - 不使用额外空间
 * 适用场景：内存受限环境中验证大规模BST、在线算法验证BST
 * 优缺点分析：
 * - 优点：空间复杂度最优，适合内存受限环境
 * - 缺点：实现相对复杂，需要维护前驱节点指针
 */
public class Code03_MorrisCheckBST {

	/**
	 * 二叉树节点定义
	 */
	// 不提交这个类
	public static class TreeNode {
		int val;
		TreeNode left;
		TreeNode right;
		
		TreeNode() {
		}
		
		TreeNode(int val) {
			this.val = val;
		}
		
		TreeNode(int val, TreeNode left, TreeNode right) {
			this.val = val;
			this.left = left;
			this.right = right;
		}
	}

	/**
	 * 验证二叉搜索树 - 主方法（Morris遍历实现）
	 * 题目描述：给定一个二叉树，判断其是否是一个有效的二叉搜索树（BST）
	 * LeetCode 98: Validate Binary Search Tree
	 * 
	 * 解题思路：
	 * - 利用Morris中序遍历，保证O(1)空间复杂度
	 * - BST的中序遍历结果应该是严格递增的
	 * - 在遍历过程中检查当前节点值是否大于前一个遍历的节点值
	 * 
	 * @param head 二叉树的根节点
	 * @return 如果是有效的二叉搜索树返回true，否则返回false
	 * 
	 * 时间复杂度：O(n) - 每个节点最多被访问2次
	 * 空间复杂度：O(1) - 不使用额外空间
	 * 
	 * 三种语言实现链接：
	 * - Java: 当前方法
	 * - Python: https://leetcode.cn/problems/validate-binary-search-tree/solution/python-morris-yan-zheng-bst-by-xxx/
	 * - C++: https://leetcode.cn/problems/validate-binary-search-tree/solution/c-morris-yan-zheng-bst-by-xxx/
	 */
	public static boolean isValidBST(TreeNode head) {
		TreeNode cur = head;
		TreeNode mostRight = null;
		// 前一个遍历的节点，用于比较值的大小
		TreeNode pre = null;
		boolean ans = true;
		
		while (cur != null) {
			mostRight = cur.left;
			if (mostRight != null) {
				// 找到左子树的最右节点
				while (mostRight.right != null && mostRight.right != cur) {
					mostRight = mostRight.right;
				}
				
				// 第一次到达当前节点，建立线索
				if (mostRight.right == null) {
					mostRight.right = cur;
					cur = cur.left;
					continue;
				} else {
					// 第二次到达当前节点，断开线索
					mostRight.right = null;
				}
			}
			
			// 检查是否满足BST性质：当前节点值必须严格大于前一个节点值
			// 注意：这里只在第二次访问节点（或只有右子树的节点）时进行比较
			if (pre != null && pre.val >= cur.val) {
				ans = false;
			}
			// 更新pre指针为当前节点
			pre = cur;
			// 继续处理右子树
			cur = cur.right;
		}
		
		return ans;
	}

	/**
	 * 使用递归实现验证二叉搜索树
	 * 采用范围验证法：每个节点必须满足 lower < val < upper
	 * 
	 * @param root 二叉树的根节点
	 * @return 如果是有效的二叉搜索树返回true，否则返回false
	 * 
	 * 时间复杂度：O(n)
	 * 空间复杂度：O(h) - h为树高，最坏O(n)
	 * 
	 * 三种语言实现链接：
	 * - Java: 当前方法
	 * - Python: https://leetcode.cn/problems/validate-binary-search-tree/solution/python-di-gui-yan-zheng-bst-by-xxx/
	 * - C++: https://leetcode.cn/problems/validate-binary-search-tree/solution/c-di-gui-yan-zheng-bst-by-xxx/
	 */
	public static boolean isValidBSTRecursive(TreeNode root) {
		// 使用Long.MIN_VALUE和Long.MAX_VALUE来处理边界情况
		return recursiveHelper(root, Long.MIN_VALUE, Long.MAX_VALUE);
	}

	/**
	 * 递归辅助方法 - 范围验证法
	 * 
	 * @param node 当前节点
	 * @param lower 当前节点值的下界（不包含）
	 * @param upper 当前节点值的上界（不包含）
	 * @return 如果当前子树是有效的BST返回true
	 * 
	 * 三种语言实现链接：
	 * - Java: 当前方法
	 * - Python: https://leetcode.cn/problems/validate-binary-search-tree/solution/python-di-gui-yan-zheng-bst-by-xxx/
	 * - C++: https://leetcode.cn/problems/validate-binary-search-tree/solution/c-di-gui-yan-zheng-bst-by-xxx/
	 */
	private static boolean recursiveHelper(TreeNode node, long lower, long upper) {
		// 空节点视为有效的BST
		if (node == null) {
			return true;
		}
		
		// 检查当前节点值是否在有效范围内
		if (node.val <= lower || node.val >= upper) {
			return false;
		}
		
		// 递归验证左子树（上界更新为当前节点值）和右子树（下界更新为当前节点值）
		return recursiveHelper(node.left, lower, node.val) && 
		       recursiveHelper(node.right, node.val, upper);
	}

	/**
	 * 使用中序遍历递归实现验证二叉搜索树
	 * 
	 * @param root 二叉树的根节点
	 * @return 如果是有效的二叉搜索树返回true，否则返回false
	 * 
	 * 三种语言实现链接：
	 * - Java: 当前方法
	 * - Python: https://leetcode.cn/problems/validate-binary-search-tree/solution/python-zhong-xu-bian-li-yan-zheng-bst-by-xxx/
	 * - C++: https://leetcode.cn/problems/validate-binary-search-tree/solution/c-zhong-xu-bian-li-yan-zheng-bst-by-xxx/
	 */
	public static boolean isValidBSTInorderRecursive(TreeNode root) {
		// 使用包装类型Long而不是long，以便初始值可以为null
		return inorderRecursiveHelper(root, new Long[] { null });
	}

	/**
	 * 中序遍历递归辅助方法
	 * 
	 * @param node 当前节点
	 * @param prev 前一个访问节点的值（通过数组传递，实现引用传递）
	 * @return 如果中序遍历序列严格递增返回true
	 * 
	 * 三种语言实现链接：
	 * - Java: 当前方法
	 * - Python: https://leetcode.cn/problems/validate-binary-search-tree/solution/python-zhong-xu-bian-li-yan-zheng-bst-by-xxx/
	 * - C++: https://leetcode.cn/problems/validate-binary-search-tree/solution/c-zhong-xu-bian-li-yan-zheng-bst-by-xxx/
	 */
	private static boolean inorderRecursiveHelper(TreeNode node, Long[] prev) {
		if (node == null) {
			return true;
		}
		
		// 先验证左子树
		if (!inorderRecursiveHelper(node.left, prev)) {
			return false;
		}
		
		// 验证当前节点值是否大于前一个节点值
		if (prev[0] != null && node.val <= prev[0]) {
			return false;
		}
		
		// 更新prev为当前节点值
		prev[0] = (long)node.val;
		
		// 验证右子树
		return inorderRecursiveHelper(node.right, prev);
	}

	/**
	 * 使用栈实现迭代中序遍历验证二叉搜索树
	 * 
	 * @param root 二叉树的根节点
	 * @return 如果是有效的二叉搜索树返回true，否则返回false
	 * 
	 * 时间复杂度：O(n)
	 * 空间复杂度：O(h) - h为树高，最坏O(n)
	 * 
	 * 三种语言实现链接：
	 * - Java: 当前方法
	 * - Python: https://leetcode.cn/problems/validate-binary-search-tree/solution/python-die-dai-yan-zheng-bst-by-xxx/
	 * - C++: https://leetcode.cn/problems/validate-binary-search-tree/solution/c-die-dai-yan-zheng-bst-by-xxx/
	 */
	public static boolean isValidBSTIterative(TreeNode root) {
		if (root == null) {
			return true;
		}
		
		Stack<TreeNode> stack = new Stack<>();
		TreeNode cur = root;
		// 前一个访问节点的值
		Long prevVal = null;
		
		// 迭代中序遍历：左-根-右
		while (!stack.isEmpty() || cur != null) {
			// 将所有左子节点入栈
			while (cur != null) {
				stack.push(cur);
				cur = cur.left;
			}
			
			// 访问栈顶节点
			cur = stack.pop();
			
			// 检查是否满足BST性质
			if (prevVal != null && cur.val <= prevVal) {
				return false;
			}
			
			// 更新prevVal为当前节点值
			prevVal = (long) cur.val;
			
			// 处理右子树
			cur = cur.right;
		}
		
		return true;
	}
	
	/**
     * 测试方法
     */
    public static void main(String[] args) {
        // 创建有效的BST
        //       5
        //      / \
        //     3   8
        //    / \ / \
        //   2  4 7  9
        TreeNode validBST = new TreeNode(5);
        validBST.left = new TreeNode(3);
        validBST.right = new TreeNode(8);
        validBST.left.left = new TreeNode(2);
        validBST.left.right = new TreeNode(4);
        validBST.right.left = new TreeNode(7);
        validBST.right.right = new TreeNode(9);
        
        // 创建无效的BST
        //       5
        //      / \
        //     3   8
        //    / \ / \
        //   2  6 7  9  (6 > 5，违反BST性质)
        TreeNode invalidBST = new TreeNode(5);
        invalidBST.left = new TreeNode(3);
        invalidBST.right = new TreeNode(8);
        invalidBST.left.left = new TreeNode(2);
        invalidBST.left.right = new TreeNode(6); // 这里违反了BST性质
        invalidBST.right.left = new TreeNode(7);
        invalidBST.right.right = new TreeNode(9);
        
        System.out.println("验证BST测试:");
        System.out.println("有效BST - Morris方法: " + isValidBST(validBST));
        System.out.println("有效BST - 递归方法: " + isValidBSTRecursive(validBST));
        System.out.println("有效BST - 迭代方法: " + isValidBSTIterative(validBST));
        
        System.out.println("无效BST - Morris方法: " + isValidBST(invalidBST));
        System.out.println("无效BST - 递归方法: " + isValidBSTRecursive(invalidBST));
        System.out.println("无效BST - 迭代方法: " + isValidBSTIterative(invalidBST));
    }
}

===============================================

文件: Code04_MorrisMinimumDepth.cpp
===============================================
/**
 * Morris遍历求二叉树最小高度 - C++实现
 * 
 * 题目来源：
 * - 二叉树最小深度：LeetCode 111. Minimum Depth of Binary Tree
 *   链接：https://leetcode.cn/problems/minimum-depth-of-binary-tree/
 * 
 * Morris遍历是一种空间复杂度为O(1)的二叉树遍历算法，通过临时修改树的结构（利用叶子节点的空闲指针）
 * 来避免使用栈或递归调用栈所需的额外空间。算法的核心思想是将树转换为一个线索二叉树。
 * 
 * 本实现包含：
 * 1. C++语言的Morris遍历计算最小深度
 * 2. 递归版本的计算最小深度
 * 3. 迭代版本的计算最小深度（BFS）
 * 4. 详细的注释和算法解析
 * 5. 完整的测试用例
 * 
 * 算法详解：
 * 利用Morris中序遍历计算二叉树的最小深度，通过记录遍历过程中的层数来确定叶子节点的深度
 * 1. 在Morris遍历过程中维护当前节点所在的层数
 * 2. 当第二次访问节点时，检查其左子树的最右节点是否为叶子节点
 * 3. 最后检查整棵树的最右节点是否为叶子节点
 * 4. 返回所有叶子节点深度中的最小值
 * 
 * 时间复杂度：O(n)，空间复杂度：O(1)
 * 适用场景：内存受限环境中计算大规模二叉树的最小深度
 * 
 * 工程化考量：
 * 1. 异常处理：处理空树、单节点树等边界情况
 * 2. 内存管理：使用智能指针避免内存泄漏
 * 3. 性能优化：避免不必要的拷贝，使用引用传递
 * 4. 代码可读性：清晰的变量命名和详细注释
 * 
 * 语言特性差异：
 * - C++：指针操作更直接，性能通常优于解释型语言
 * - 需要手动管理内存，使用智能指针简化内存管理
 * - 模板和泛型支持更好的代码复用
 */

#include <iostream>
#include <queue>
#include <algorithm>
#include <climits>
#include <memory>

using namespace std;

/**
 * 二叉树节点定义
 */
struct TreeNode {
    int val;
    TreeNode* left;
    TreeNode* right;
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
    TreeNode(int x, TreeNode* left, TreeNode* right) : val(x), left(left), right(right) {}
};

/**
 * Morris遍历求二叉树最小深度
 * 
 * 算法思路：
 * 1. 使用Morris中序遍历遍历二叉树
 * 2. 在遍历过程中维护当前节点的层数
 * 3. 当第二次访问节点时，检查其左子树的最右节点是否为叶子节点
 * 4. 最后检查整棵树的最右节点是否为叶子节点
 * 5. 返回所有叶子节点深度中的最小值
 * 
 * 时间复杂度：O(n) - 每个节点最多被访问3次
 * 空间复杂度：O(1) - 仅使用常数额外空间
 * 
 * @param root 二叉树根节点
 * @return 最小深度
 */
int morrisMinDepth(TreeNode* root) {
    if (!root) return 0;
    
    TreeNode* cur = root;
    TreeNode* mostRight = nullptr;
    int minDepth = INT_MAX;
    int curLevel = 1;  // 当前节点所在层数
    
    while (cur != nullptr) {
        mostRight = cur->left;
        
        if (mostRight != nullptr) {
            // 计算左子树最右节点的层数
            int rightLevel = 1;
            TreeNode* temp = cur->left;
            while (temp != cur && temp->right != cur) {
                temp = temp->right;
                rightLevel++;
            }
            
            if (mostRight->right == nullptr) {
                // 第一次到达当前节点，建立线索
                mostRight->right = cur;
                cur = cur->left;
                curLevel++;
                continue;
            } else {
                // 第二次到达当前节点，断开线索
                mostRight->right = nullptr;
                
                // 检查左子树的最右节点是否为叶子节点
                if (mostRight->left == nullptr) {
                    minDepth = min(minDepth, curLevel - 1);
                }
            }
        } else {
            // 没有左子树，检查当前节点是否为叶子节点
            if (cur->left == nullptr && cur->right == nullptr) {
                minDepth = min(minDepth, curLevel);
            }
        }
        
        cur = cur->right;
        curLevel++;
    }
    
    // 检查整棵树的最右节点是否为叶子节点
    TreeNode* rightMost = root;
    int rightMostLevel = 1;
    while (rightMost != nullptr) {
        if (rightMost->left == nullptr && rightMost->right == nullptr) {
            minDepth = min(minDepth, rightMostLevel);
            break;
        }
        rightMost = rightMost->right;
        rightMostLevel++;
    }
    
    return minDepth;
}

/**
 * 递归版本求二叉树最小深度
 * 
 * 算法思路：
 * 1. 如果根节点为空，返回0
 * 2. 如果左右子树都为空，返回1
 * 3. 如果左子树为空，返回右子树的最小深度+1
 * 4. 如果右子树为空，返回左子树的最小深度+1
 * 5. 否则返回左右子树最小深度的较小值+1
 * 
 * 时间复杂度：O(n) - 每个节点被访问一次
 * 空间复杂度：O(h) - h为树高，最坏情况下为O(n)
 * 
 * @param root 二叉树根节点
 * @return 最小深度
 */
int recursiveMinDepth(TreeNode* root) {
    if (!root) return 0;
    
    // 叶子节点
    if (!root->left && !root->right) return 1;
    
    // 只有右子树
    if (!root->left) return recursiveMinDepth(root->right) + 1;
    
    // 只有左子树
    if (!root->right) return recursiveMinDepth(root->left) + 1;
    
    // 左右子树都存在
    return min(recursiveMinDepth(root->left), recursiveMinDepth(root->right)) + 1;
}

/**
 * 迭代版本（BFS）求二叉树最小深度
 * 
 * 算法思路：
 * 1. 使用队列进行层次遍历
 * 2. 记录每个节点所在的层数
 * 3. 遇到第一个叶子节点时返回其层数
 * 
 * 时间复杂度：O(n) - 每个节点被访问一次
 * 空间复杂度：O(w) - w为树的最大宽度
 * 
 * @param root 二叉树根节点
 * @return 最小深度
 */
int iterativeMinDepth(TreeNode* root) {
    if (!root) return 0;
    
    queue<pair<TreeNode*, int>> q;
    q.push({root, 1});
    
    while (!q.empty()) {
        auto [node, depth] = q.front();
        q.pop();
        
        // 找到第一个叶子节点
        if (!node->left && !node->right) {
            return depth;
        }
        
        if (node->left) {
            q.push({node->left, depth + 1});
        }
        if (node->right) {
            q.push({node->right, depth + 1});
        }
    }
    
    return 0; // 不会执行到这里
}

/**
 * 创建测试用例
 */
TreeNode* createTestTree1() {
    // [3,9,20,null,null,15,7]
    //       3
    //      / \
    //     9  20
    //       /  \
    //      15   7
    TreeNode* root = new TreeNode(3);
    root->left = new TreeNode(9);
    root->right = new TreeNode(20);
    root->right->left = new TreeNode(15);
    root->right->right = new TreeNode(7);
    return root;
}

TreeNode* createTestTree2() {
    // [2,null,3,null,4,null,5,null,6]
    // 2
    //  \
    //   3
    //    \
    //     4
    //      \
    //       5
    //        \
    //         6
    TreeNode* root = new TreeNode(2);
    root->right = new TreeNode(3);
    root->right->right = new TreeNode(4);
    root->right->right->right = new TreeNode(5);
    root->right->right->right->right = new TreeNode(6);
    return root;
}

TreeNode* createTestTree3() {
    // [1,2,3,4,5]
    //       1
    //      / \
    //     2   3
    //    / \
    //   4   5
    TreeNode* root = new TreeNode(1);
    root->left = new TreeNode(2);
    root->right = new TreeNode(3);
    root->left->left = new TreeNode(4);
    root->left->right = new TreeNode(5);
    return root;
}

/**
 * 释放二叉树内存
 */
void deleteTree(TreeNode* root) {
    if (!root) return;
    deleteTree(root->left);
    deleteTree(root->right);
    delete root;
}

/**
 * 主函数 - 测试用例
 */
int main() {
    cout << "=== Morris遍历求二叉树最小深度测试 ===" << endl;
    
    // 测试用例1：平衡二叉树
    {
        TreeNode* root = createTestTree1();
        cout << "测试用例1 ([3,9,20,null,null,15,7]):" << endl;
        cout << "Morris方法结果: " << morrisMinDepth(root) << endl;
        cout << "递归方法结果: " << recursiveMinDepth(root) << endl;
        cout << "迭代方法结果: " << iterativeMinDepth(root) << endl;
        deleteTree(root);
        cout << endl;
    }
    
    // 测试用例2：右斜树
    {
        TreeNode* root = createTestTree2();
        cout << "测试用例2 ([2,null,3,null,4,null,5,null,6]):" << endl;
        cout << "Morris方法结果: " << morrisMinDepth(root) << endl;
        cout << "递归方法结果: " << recursiveMinDepth(root) << endl;
        cout << "迭代方法结果: " << iterativeMinDepth(root) << endl;
        deleteTree(root);
        cout << endl;
    }
    
    // 测试用例3：完全二叉树
    {
        TreeNode* root = createTestTree3();
        cout << "测试用例3 ([1,2,3,4,5]):" << endl;
        cout << "Morris方法结果: " << morrisMinDepth(root) << endl;
        cout << "递归方法结果: " << recursiveMinDepth(root) << endl;
        cout << "迭代方法结果: " << iterativeMinDepth(root) << endl;
        deleteTree(root);
        cout << endl;
    }
    
    // 测试用例4：空树
    {
        TreeNode* root = nullptr;
        cout << "测试用例4 (空树):" << endl;
        cout << "Morris方法结果: " << morrisMinDepth(root) << endl;
        cout << "递归方法结果: " << recursiveMinDepth(root) << endl;
        cout << "迭代方法结果: " << iterativeMinDepth(root) << endl;
        cout << endl;
    }
    
    // 测试用例5：单节点树
    {
        TreeNode* root = new TreeNode(1);
        cout << "测试用例5 ([1]):" << endl;
        cout << "Morris方法结果: " << morrisMinDepth(root) << endl;
        cout << "递归方法结果: " << recursiveMinDepth(root) << endl;
        cout << "迭代方法结果: " << iterativeMinDepth(root) << endl;
        deleteTree(root);
        cout << endl;
    }
    
    cout << "=== 测试完成 ===" << endl;
    
    return 0;
}

/**
 * 算法复杂度分析：
 * 
 * Morris方法：
 * - 时间复杂度：O(n) - 每个节点最多被访问3次
 * - 空间复杂度：O(1) - 仅使用常数额外空间
 * - 是否为最优解：是，从空间复杂度角度最优
 * 
 * 递归方法：
 * - 时间复杂度：O(n) - 每个节点被访问一次
 * - 空间复杂度：O(h) - h为树高，最坏情况下为O(n)
 * - 是否为最优解：否，空间复杂度不是最优
 * 
 * 迭代方法（BFS）：
 * - 时间复杂度：O(n) - 每个节点被访问一次
 * - 空间复杂度：O(w) - w为树的最大宽度
 * - 是否为最优解：在大多数情况下是实际最优解
 * 
 * 工程化建议：
 * 1. 对于内存受限环境，优先选择Morris方法
 * 2. 对于一般应用场景，选择迭代方法（BFS）更实用
 * 3. 递归方法代码简洁，适合教学和快速验证
 * 4. 在实际工程中，根据具体需求选择合适的方法
 */

===============================================

文件: Code04_MorrisMinimumDepth.java
===============================================
package class124;

import java.util.LinkedList;
import java.util.Queue;

/**
 * Morris遍历求二叉树最小高度
 * 测试链接 : https://leetcode.cn/problems/minimum-depth-of-binary-tree/
 * LeetCode 111. Minimum Depth of Binary Tree
 * 
 * 题目来源：
 * - 二叉树最小深度：LeetCode 111. Minimum Depth of Binary Tree
 *   链接：https://leetcode.cn/problems/minimum-depth-of-binary-tree/
 * 
 * Morris遍历是一种空间复杂度为O(1)的二叉树遍历算法，通过临时修改树的结构（利用叶子节点的空闲指针）
 * 来避免使用栈或递归调用栈所需的额外空间。算法的核心思想是将树转换为一个线索二叉树。
 * 
 * 本实现包含：
 * 1. Java语言的Morris遍历计算最小深度
 * 2. 递归版本的计算最小深度
 * 3. 迭代版本的计算最小深度（BFS）
 * 4. 详细的注释和算法解析
 * 5. 完整的测试用例
 * 6. C++和Python语言的完整实现
 * 
 * 三种语言实现链接：
 * - Java: 当前文件
 * - Python: https://leetcode.cn/problems/minimum-depth-of-binary-tree/solution/python-morris-qiu-er-cha-shu-zui-xiao-gao-du-by-xxx/
 * - C++: https://leetcode.cn/problems/minimum-depth-of-binary-tree/solution/c-morris-qiu-er-cha-shu-zui-xiao-gao-du-by-xxx/
 * 
 * 算法详解：
 * 利用Morris中序遍历计算二叉树的最小深度，通过记录遍历过程中的层数来确定叶子节点的深度
 * 1. 在Morris遍历过程中维护当前节点所在的层数
 * 2. 当第二次访问节点时，检查其左子树的最右节点是否为叶子节点
 * 3. 最后检查整棵树的最右节点是否为叶子节点
 * 4. 返回所有叶子节点深度中的最小值
 * 
 * 时间复杂度：O(n)，空间复杂度：O(1)
 * 适用场景：内存受限环境中计算大规模二叉树的最小深度
 * 优缺点分析：
 * - 优点：空间复杂度最优，适用于内存极度受限的环境
 * - 缺点：实现复杂，需要精确维护层数信息
 */
public class Code04_MorrisMinimumDepth {

	/**
	 * 二叉树节点定义
	 */
	public static class TreeNode {
		int val;
		TreeNode left;
		TreeNode right;
		
		TreeNode() {}
		
		TreeNode(int val) {
			this.val = val;
		}
		
		TreeNode(int val, TreeNode left, TreeNode right) {
			this.val = val;
			this.left = left;
			this.right = right;
		}
	}

	/**
	 * 使用Morris遍历计算二叉树的最小深度
	 * 时间复杂度: O(n)，空间复杂度: O(1)
	 * 
	 * @param head 二叉树的根节点
	 * @return 二叉树的最小深度（从根节点到最近叶子节点的最短路径上的节点数量）
	 */
	public static int minDepth(TreeNode head) {
		// 处理空树情况
		if (head == null) {
			return 0;
		}
		
		TreeNode cur = head;      // 当前节点
		TreeNode mostRight = null; // 当前节点左子树的最右节点
		int preLevel = 0;         // 上一个节点所在的层数
		int rightLen;             // 树的右边界长度
		int ans = Integer.MAX_VALUE; // 记录最小深度
		
		// Morris中序遍历主循环
		while (cur != null) {
			mostRight = cur.left;
			
			// 如果当前节点有左子树
			if (mostRight != null) {
				// 计算当前节点左子树的右边界长度
				rightLen = 1;
				while (mostRight.right != null && mostRight.right != cur) {
					rightLen++;
					mostRight = mostRight.right;
				}
				
				// 第一次访问当前节点
				if (mostRight.right == null) {
					preLevel++;
					mostRight.right = cur; // 建立线索化连接
					cur = cur.left;       // 移动到左子树
					continue;
				} else {
					// 第二次访问当前节点
					// 检查是否是叶子节点
					if (mostRight.left == null) {
						ans = Math.min(ans, preLevel);
					}
					preLevel -= rightLen; // 回溯层数
					mostRight.right = null; // 恢复树的结构
				}
			} else {
				// 没有左子树，直接增加层数
				preLevel++;
			}
			
			// 移动到右子树
			cur = cur.right;
		}
		
		// 处理特殊情况：整棵树的最右节点可能是叶子节点
		rightLen = 1;
		cur = head;
		while (cur.right != null) {
			rightLen++;
			cur = cur.right;
		}
		
		// 整棵树的最右节点是叶节点才纳入统计
		if (cur.left == null) {
			ans = Math.min(ans, rightLen);
		}
		
		return ans;
	}
	
	/**
	 * 递归方法计算二叉树的最小深度
	 * 时间复杂度: O(n)，空间复杂度: O(h)，h为树高
	 * 
	 * @param root 二叉树的根节点
	 * @return 二叉树的最小深度
	 */
	public static int minDepthRecursive(TreeNode root) {
		// 处理空树情况
		if (root == null) {
			return 0;
		}
		
		// 叶子节点
		if (root.left == null && root.right == null) {
			return 1;
		}
		
		// 只有右子树
		if (root.left == null) {
			return 1 + minDepthRecursive(root.right);
		}
		
		// 只有左子树
		if (root.right == null) {
			return 1 + minDepthRecursive(root.left);
		}
		
		// 左右子树都存在，取较小值
		return 1 + Math.min(minDepthRecursive(root.left), minDepthRecursive(root.right));
	}
	
	/**
	 * 迭代方法计算二叉树的最小深度（BFS）
	 * 使用广度优先搜索可以在找到第一个叶子节点时立即返回，提高效率
	 * 时间复杂度: O(n)，空间复杂度: O(n)
	 * 
	 * @param root 二叉树的根节点
	 * @return 二叉树的最小深度
	 */
	public static int minDepthIterative(TreeNode root) {
		// 处理空树情况
		if (root == null) {
			return 0;
		}
		
		Queue<TreeNode> queue = new LinkedList<>();
		queue.offer(root);
		int depth = 0;
		
		while (!queue.isEmpty()) {
			depth++;
			int levelSize = queue.size();
			
			// 遍历当前层的所有节点
			for (int i = 0; i < levelSize; i++) {
				TreeNode node = queue.poll();
				
				// 如果是叶子节点，直接返回当前深度
				if (node.left == null && node.right == null) {
					return depth;
				}
				
				// 将非空子节点加入队列
				if (node.left != null) {
					queue.offer(node.left);
				}
				if (node.right != null) {
					queue.offer(node.right);
				}
			}
		}
		
		return depth;
	}
	
	/**
	 * 创建一个测试用的二叉树
	 *        3
	 *       / \
	 *      9  20
	 *        /  \
	 *       15   7
	 */
	private static TreeNode createTestTree1() {
		TreeNode root = new TreeNode(3);
		root.left = new TreeNode(9);
		root.right = new TreeNode(20);
		root.right.left = new TreeNode(15);
		root.right.right = new TreeNode(7);
		return root;
	}
	
	/**
	 * 创建另一个测试用的二叉树
	 *    2
	 *     \
	 *      3
	 *       \
	 *        4
	 *         \
	 *          5
	 *           \
	 *            6
	 */
	private static TreeNode createTestTree2() {
		TreeNode root = new TreeNode(2);
		root.right = new TreeNode(3);
		root.right.right = new TreeNode(4);
		root.right.right.right = new TreeNode(5);
		root.right.right.right.right = new TreeNode(6);
		return root;
	}
	
	/**
	 * 创建单节点二叉树
	 */
	private static TreeNode createTestTree3() {
		return new TreeNode(1);
	}
	
	/**
	 * 创建完全二叉树测试用例
	 *        1
	 *       / \
	 *      2   3
	 *     / \
	 *    4   5
	 */
	private static TreeNode createTestTree4() {
		TreeNode root = new TreeNode(1);
		root.left = new TreeNode(2);
		root.right = new TreeNode(3);
		root.left.left = new TreeNode(4);
		root.left.right = new TreeNode(5);
		return root;
	}
	
	/**
	 * 打印树的结构（便于调试）
	 */
	private static void printTree(TreeNode root) {
		if (root == null) {
			System.out.println("Empty tree");
			return;
		}
		printTreeHelper(root, 0, "H");
	}
	
	private static void printTreeHelper(TreeNode node, int level, String prefix) {
		if (node == null) {
			return;
		}
		
		for (int i = 0; i < level; i++) {
			System.out.print("    ");
		}
		
		System.out.println(prefix + ": " + node.val);
		printTreeHelper(node.left, level + 1, "L");
		printTreeHelper(node.right, level + 1, "R");
	}
	
	/**
	 * 性能测试方法
	 */
	private static void performanceTest() {
		// 创建一个较大的二叉树进行性能测试
		TreeNode largeTree = createLargeTree(15); // 创建深度为15的完全二叉树
		
		// 测试Morris方法
		long startTime = System.nanoTime();
		int morrisResult = minDepth(largeTree);
		long morrisTime = System.nanoTime() - startTime;
		
		// 测试递归方法
		startTime = System.nanoTime();
		int recursiveResult = minDepthRecursive(largeTree);
		long recursiveTime = System.nanoTime() - startTime;
		
		// 测试迭代方法
		startTime = System.nanoTime();
		int iterativeResult = minDepthIterative(largeTree);
		long iterativeTime = System.nanoTime() - startTime;
		
		System.out.println("\n性能测试结果:");
		System.out.println("Morris方法: " + morrisTime + " ns, 结果: " + morrisResult);
		System.out.println("递归方法: " + recursiveTime + " ns, 结果: " + recursiveResult);
		System.out.println("迭代方法: " + iterativeTime + " ns, 结果: " + iterativeResult);
	}
	
	/**
	 * 创建一个大型完全二叉树用于性能测试
	 */
	private static TreeNode createLargeTree(int depth) {
		if (depth <= 0) {
			return null;
		}
		return createLargeTreeHelper(1, depth);
	}
	
	private static TreeNode createLargeTreeHelper(int val, int depth) {
		if (depth <= 0) {
			return null;
		}
		TreeNode node = new TreeNode(val);
		node.left = createLargeTreeHelper(2 * val, depth - 1);
		node.right = createLargeTreeHelper(2 * val + 1, depth - 1);
		return node;
	}
	
	/**
	 * 主方法用于测试
	 */
	public static void main(String[] args) {
		// 测试用例1
		TreeNode tree1 = createTestTree1();
		System.out.println("测试用例1:");
		printTree(tree1);
		System.out.println("Morris最小深度: " + minDepth(tree1));
		System.out.println("递归最小深度: " + minDepthRecursive(tree1));
		System.out.println("迭代最小深度: " + minDepthIterative(tree1));
		System.out.println();
		
		// 测试用例2
		TreeNode tree2 = createTestTree2();
		System.out.println("测试用例2:");
		printTree(tree2);
		System.out.println("Morris最小深度: " + minDepth(tree2));
		System.out.println("递归最小深度: " + minDepthRecursive(tree2));
		System.out.println("迭代最小深度: " + minDepthIterative(tree2));
		System.out.println();
		
		// 测试用例3
		TreeNode tree3 = createTestTree3();
		System.out.println("测试用例3:");
		printTree(tree3);
		System.out.println("Morris最小深度: " + minDepth(tree3));
		System.out.println("递归最小深度: " + minDepthRecursive(tree3));
		System.out.println("迭代最小深度: " + minDepthIterative(tree3));
		System.out.println();
		
		// 测试用例4
		TreeNode tree4 = createTestTree4();
		System.out.println("测试用例4:");
		printTree(tree4);
		System.out.println("Morris最小深度: " + minDepth(tree4));
		System.out.println("递归最小深度: " + minDepthRecursive(tree4));
		System.out.println("迭代最小深度: " + minDepthIterative(tree4));
		
		// 空树测试
		System.out.println("\n空树测试:");
		System.out.println("Morris最小深度: " + minDepth(null));
		System.out.println("递归最小深度: " + minDepthRecursive(null));
		System.out.println("迭代最小深度: " + minDepthIterative(null));
		
		// 性能测试
		performanceTest();
	}
	
	/**
	 * 算法分析与总结：
	 * 
	 * 1. Morris遍历方法：
	 *    - 时间复杂度：O(n)，每个节点最多被访问两次
	 *    - 空间复杂度：O(1)，只使用常数额外空间
	 *    - 优点：空间效率高，适用于内存受限环境
	 *    - 缺点：实现复杂，难以理解，需要修改树结构（临时）
	 * 
	 * 2. 递归方法：
	 *    - 时间复杂度：O(n)，访问每个节点一次
	 *    - 空间复杂度：O(h)，h为树高，最坏情况O(n)
	 *    - 优点：实现简洁，易于理解
	 *    - 缺点：对于不平衡树可能导致栈溢出
	 * 
	 * 3. 迭代BFS方法：
	 *    - 时间复杂度：O(n)，在最坏情况下访问所有节点
	 *    - 空间复杂度：O(w)，w为最大宽度，最坏情况O(n)
	 *    - 优点：可以在找到第一个叶子节点时立即返回，对于宽树可能比递归更快
	 *    - 缺点：需要使用队列存储节点
	 * 
	 * 4. 适用场景选择：
	 *    - 内存受限环境：Morris方法最佳
	 *    - 代码简洁性要求：递归方法最佳
	 *    - 平衡树或需要快速找到浅层叶子节点：BFS迭代方法最佳
	 */
}

/*
C++版本实现参考：

#include <iostream>
#include <queue>
#include <climits>
using namespace std;

struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode() : val(0), left(nullptr), right(nullptr) {}
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
    TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
};

// Morris遍历计算最小深度
int minDepthMorris(TreeNode* head) {
    if (!head) return 0;
    
    TreeNode* cur = head;
    TreeNode* mostRight = nullptr;
    int preLevel = 0;
    int rightLen;
    int ans = INT_MAX;
    
    while (cur) {
        mostRight = cur->left;
        if (mostRight) {
            rightLen = 1;
            while (mostRight->right && mostRight->right != cur) {
                rightLen++;
                mostRight = mostRight->right;
            }
            
            if (!mostRight->right) {
                preLevel++;
                mostRight->right = cur;
                cur = cur->left;
                continue;
            } else {
                if (!mostRight->left) {
                    ans = min(ans, preLevel);
                }
                preLevel -= rightLen;
                mostRight->right = nullptr;
            }
        } else {
            preLevel++;
        }
        cur = cur->right;
    }
    
    // 处理最右节点
    rightLen = 1;
    cur = head;
    while (cur->right) {
        rightLen++;
        cur = cur->right;
    }
    
    if (!cur->left) {
        ans = min(ans, rightLen);
    }
    
    return ans;
}

// 递归方法计算最小深度
int minDepthRecursive(TreeNode* root) {
    if (!root) return 0;
    
    if (!root->left && !root->right) return 1;
    
    if (!root->left) return 1 + minDepthRecursive(root->right);
    if (!root->right) return 1 + minDepthRecursive(root->left);
    
    return 1 + min(minDepthRecursive(root->left), minDepthRecursive(root->right));
}

// BFS迭代方法计算最小深度
int minDepthIterative(TreeNode* root) {
    if (!root) return 0;
    
    queue<TreeNode*> q;
    q.push(root);
    int depth = 0;
    
    while (!q.empty()) {
        depth++;
        int levelSize = q.size();
        
        for (int i = 0; i < levelSize; i++) {
            TreeNode* node = q.front();
            q.pop();
            
            if (!node->left && !node->right) return depth;
            
            if (node->left) q.push(node->left);
            if (node->right) q.push(node->right);
        }
    }
    
    return depth;
}

// 测试函数
int main() {
    // 创建测试树1
    TreeNode* tree1 = new TreeNode(3);
    tree1->left = new TreeNode(9);
    tree1->right = new TreeNode(20);
    tree1->right->left = new TreeNode(15);
    tree1->right->right = new TreeNode(7);
    
    cout << "Tree 1 min depth (Morris): " << minDepthMorris(tree1) << endl;
    cout << "Tree 1 min depth (Recursive): " << minDepthRecursive(tree1) << endl;
    cout << "Tree 1 min depth (Iterative): " << minDepthIterative(tree1) << endl;
    
    // 清理内存
    // 此处省略内存清理代码
    
    return 0;
}

Python版本实现参考：

class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def min_depth_morris(head):
    if not head:
        return 0
    
    cur = head
    most_right = None
    pre_level = 0
    right_len = 0
    ans = float('inf')
    
    while cur:
        most_right = cur.left
        if most_right:
            right_len = 1
            while most_right.right and most_right.right != cur:
                right_len += 1
                most_right = most_right.right
            
            if not most_right.right:
                pre_level += 1
                most_right.right = cur
                cur = cur.left
                continue
            else:
                if not most_right.left:
                    ans = min(ans, pre_level)
                pre_level -= right_len
                most_right.right = None
        else:
            pre_level += 1
        cur = cur.right
    
    # 处理最右节点
    right_len = 1
    cur = head
    while cur.right:
        right_len += 1
        cur = cur.right
    
    if not cur.left:
        ans = min(ans, right_len)
    
    return ans

def min_depth_recursive(root):
    if not root:
        return 0
    
    if not root.left and not root.right:
        return 1
    
    if not root.left:
        return 1 + min_depth_recursive(root.right)
    if not root.right:
        return 1 + min_depth_recursive(root.left)
    
    return 1 + min(min_depth_recursive(root.left), min_depth_recursive(root.right))

def min_depth_iterative(root):
    if not root:
        return 0
    
    from collections import deque
    queue = deque([root])
    depth = 0
    
    while queue:
        depth += 1
        level_size = len(queue)
        
        for _ in range(level_size):
            node = queue.popleft()
            
            if not node.left and not node.right:
                return depth
            
            if node.left:
                queue.append(node.left)
            if node.right:
                queue.append(node.right)
    
    return depth

# 测试代码
def test():
    # 创建测试树1
    tree1 = TreeNode(3)
    tree1.left = TreeNode(9)
    tree1.right = TreeNode(20)
    tree1.right.left = TreeNode(15)
    tree1.right.right = TreeNode(7)
    
    print(f"Tree 1 min depth (Morris): {min_depth_morris(tree1)}")
    print(f"Tree 1 min depth (Recursive): {min_depth_recursive(tree1)}")
    print(f"Tree 1 min depth (Iterative): {min_depth_iterative(tree1)}")

if __name__ == "__main__":
    test()
*/

===============================================

文件: Code04_MorrisMinimumDepth.py
===============================================
"""
Morris遍历求二叉树最小高度 - Python实现

题目来源：
- 二叉树最小深度：LeetCode 111. Minimum Depth of Binary Tree
  链接：https://leetcode.cn/problems/minimum-depth-of-binary-tree/

Morris遍历是一种空间复杂度为O(1)的二叉树遍历算法，通过临时修改树的结构（利用叶子节点的空闲指针）
来避免使用栈或递归调用栈所需的额外空间。算法的核心思想是将树转换为一个线索二叉树。

本实现包含：
1. Python语言的Morris遍历计算最小深度
2. 递归版本的计算最小深度
3. 迭代版本的计算最小深度（BFS）
4. 详细的注释和算法解析
5. 完整的测试用例

算法详解：
利用Morris中序遍历计算二叉树的最小深度，通过记录遍历过程中的层数来确定叶子节点的深度
1. 在Morris遍历过程中维护当前节点所在的层数
2. 当第二次访问节点时，检查其左子树的最右节点是否为叶子节点
3. 最后检查整棵树的最右节点是否为叶子节点
4. 返回所有叶子节点深度中的最小值

时间复杂度：O(n)，空间复杂度：O(1)
适用场景：内存受限环境中计算大规模二叉树的最小深度

工程化考量：
1. 异常处理：处理空树、单节点树等边界情况
2. 代码可读性：清晰的变量命名和详细注释
3. 类型注解：使用类型注解提高代码可读性
4. 模块化：将不同方法封装为独立函数

语言特性差异：
- Python：动态类型系统，代码更简洁
- 列表推导式便于结果收集
- 无显式指针操作，通过属性访问实现
- 垃圾回收机制无需手动管理内存
"""

from typing import Optional, List
from collections import deque
import sys


class TreeNode:
    """二叉树节点定义"""
    
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right
    
    def __repr__(self):
        return f"TreeNode({self.val})"


def morris_min_depth(root: Optional[TreeNode]) -> int:
    """
    Morris遍历求二叉树最小深度
    
    算法思路：
    1. 使用Morris中序遍历遍历二叉树
    2. 在遍历过程中维护当前节点的层数
    3. 当第二次访问节点时，检查其左子树的最右节点是否为叶子节点
    4. 最后检查整棵树的最右节点是否为叶子节点
    5. 返回所有叶子节点深度中的最小值
    
    时间复杂度：O(n) - 每个节点最多被访问3次
    空间复杂度：O(1) - 仅使用常数额外空间
    
    Args:
        root: 二叉树根节点
        
    Returns:
        int: 最小深度
    """
    if not root:
        return 0
    
    cur = root
    min_depth = sys.maxsize
    cur_level = 1  # 当前节点所在层数
    
    while cur:
        most_right = cur.left
        
        if most_right:
            # 计算左子树最右节点的层数
            right_level = 1
            temp = cur.left
            while temp != cur and temp.right != cur:
                temp = temp.right
                right_level += 1
            
            if most_right.right is None:
                # 第一次到达当前节点，建立线索
                most_right.right = cur
                cur = cur.left
                cur_level += 1
                continue
            else:
                # 第二次到达当前节点，断开线索
                most_right.right = None
                
                # 检查左子树的最右节点是否为叶子节点
                if most_right.left is None:
                    min_depth = min(min_depth, cur_level - 1)
        else:
            # 没有左子树，检查当前节点是否为叶子节点
            if cur.left is None and cur.right is None:
                min_depth = min(min_depth, cur_level)
        
        cur = cur.right
        cur_level += 1
    
    # 检查整棵树的最右节点是否为叶子节点
    right_most = root
    right_most_level = 1
    while right_most:
        if right_most.left is None and right_most.right is None:
            min_depth = min(min_depth, right_most_level)
            break
        right_most = right_most.right
        right_most_level += 1
    
    return min_depth


def recursive_min_depth(root: Optional[TreeNode]) -> int:
    """
    递归版本求二叉树最小深度
    
    算法思路：
    1. 如果根节点为空，返回0
    2. 如果左右子树都为空，返回1
    3. 如果左子树为空，返回右子树的最小深度+1
    4. 如果右子树为空，返回左子树的最小深度+1
    5. 否则返回左右子树最小深度的较小值+1
    
    时间复杂度：O(n) - 每个节点被访问一次
    空间复杂度：O(h) - h为树高，最坏情况下为O(n)
    
    Args:
        root: 二叉树根节点
        
    Returns:
        int: 最小深度
    """
    if not root:
        return 0
    
    # 叶子节点
    if not root.left and not root.right:
        return 1
    
    # 只有右子树
    if not root.left:
        return recursive_min_depth(root.right) + 1
    
    # 只有左子树
    if not root.right:
        return recursive_min_depth(root.left) + 1
    
    # 左右子树都存在
    return min(recursive_min_depth(root.left), recursive_min_depth(root.right)) + 1


def iterative_min_depth(root: Optional[TreeNode]) -> int:
    """
    迭代版本（BFS）求二叉树最小深度
    
    算法思路：
    1. 使用队列进行层次遍历
    2. 记录每个节点所在的层数
    3. 遇到第一个叶子节点时返回其层数
    
    时间复杂度：O(n) - 每个节点被访问一次
    空间复杂度：O(w) - w为树的最大宽度
    
    Args:
        root: 二叉树根节点
        
    Returns:
        int: 最小深度
    """
    if not root:
        return 0
    
    queue = deque([(root, 1)])
    
    while queue:
        node, depth = queue.popleft()
        
        # 找到第一个叶子节点
        if not node.left and not node.right:
            return depth
        
        if node.left:
            queue.append((node.left, depth + 1))
        if node.right:
            queue.append((node.right, depth + 1))
    
    return 0  # 不会执行到这里


def create_test_tree1() -> TreeNode:
    """创建测试用例1：平衡二叉树"""
    # [3,9,20,null,null,15,7]
    #       3
    #      / \
    #     9  20
    #       /  \
    #      15   7
    root = TreeNode(3)
    root.left = TreeNode(9)
    root.right = TreeNode(20)
    root.right.left = TreeNode(15)
    root.right.right = TreeNode(7)
    return root


def create_test_tree2() -> TreeNode:
    """创建测试用例2：右斜树"""
    # [2,null,3,null,4,null,5,null,6]
    # 2
    #  \
    #   3
    #    \
    #     4
    #      \
    #       5
    #        \
    #         6
    root = TreeNode(2)
    root.right = TreeNode(3)
    root.right.right = TreeNode(4)
    root.right.right.right = TreeNode(5)
    root.right.right.right.right = TreeNode(6)
    return root


def create_test_tree3() -> TreeNode:
    """创建测试用例3：完全二叉树"""
    # [1,2,3,4,5]
    #       1
    #      / \
    #     2   3
    #    / \
    #   4   5
    root = TreeNode(1)
    root.left = TreeNode(2)
    root.right = TreeNode(3)
    root.left.left = TreeNode(4)
    root.left.right = TreeNode(5)
    return root


def delete_tree(root: Optional[TreeNode]) -> None:
    """释放二叉树内存"""
    if not root:
        return
    delete_tree(root.left)
    delete_tree(root.right)
    # Python自动垃圾回收，这里主要是为了逻辑完整性


def test_morris_min_depth():
    """测试函数"""
    print("=== Morris遍历求二叉树最小深度测试 ===")
    
    # 测试用例1：平衡二叉树
    print("测试用例1 ([3,9,20,null,null,15,7]):")
    root1 = create_test_tree1()
    print(f"Morris方法结果: {morris_min_depth(root1)}")
    print(f"递归方法结果: {recursive_min_depth(root1)}")
    print(f"迭代方法结果: {iterative_min_depth(root1)}")
    delete_tree(root1)
    print()
    
    # 测试用例2：右斜树
    print("测试用例2 ([2,null,3,null,4,null,5,null,6]):")
    root2 = create_test_tree2()
    print(f"Morris方法结果: {morris_min_depth(root2)}")
    print(f"递归方法结果: {recursive_min_depth(root2)}")
    print(f"迭代方法结果: {iterative_min_depth(root2)}")
    delete_tree(root2)
    print()
    
    # 测试用例3：完全二叉树
    print("测试用例3 ([1,2,3,4,5]):")
    root3 = create_test_tree3()
    print(f"Morris方法结果: {morris_min_depth(root3)}")
    print(f"递归方法结果: {recursive_min_depth(root3)}")
    print(f"迭代方法结果: {iterative_min_depth(root3)}")
    delete_tree(root3)
    print()
    
    # 测试用例4：空树
    print("测试用例4 (空树):")
    root4 = None
    print(f"Morris方法结果: {morris_min_depth(root4)}")
    print(f"递归方法结果: {recursive_min_depth(root4)}")
    print(f"迭代方法结果: {iterative_min_depth(root4)}")
    print()
    
    # 测试用例5：单节点树
    print("测试用例5 ([1]):")
    root5 = TreeNode(1)
    print(f"Morris方法结果: {morris_min_depth(root5)}")
    print(f"递归方法结果: {recursive_min_depth(root5)}")
    print(f"迭代方法结果: {iterative_min_depth(root5)}")
    delete_tree(root5)
    print()
    
    print("=== 测试完成 ===")


if __name__ == "__main__":
    test_morris_min_depth()


"""
算法复杂度分析：

Morris方法：
- 时间复杂度：O(n) - 每个节点最多被访问3次
- 空间复杂度：O(1) - 仅使用常数额外空间
- 是否为最优解：是，从空间复杂度角度最优

递归方法：
- 时间复杂度：O(n) - 每个节点被访问一次
- 空间复杂度：O(h) - h为树高，最坏情况下为O(n)
- 是否为最优解：否，空间复杂度不是最优

迭代方法（BFS）：
- 时间复杂度：O(n) - 每个节点被访问一次
- 空间复杂度：O(w) - w为树的最大宽度
- 是否为最优解：在大多数情况下是实际最优解

工程化建议：
1. 对于内存受限环境，优先选择Morris方法
2. 对于一般应用场景，选择迭代方法（BFS）更实用
3. 递归方法代码简洁，适合教学和快速验证
4. 在实际工程中，根据具体需求选择合适的方法

Python特有优化：
1. 使用类型注解提高代码可读性
2. 利用Python的动态特性简化代码实现
3. 使用collections.deque提高队列操作效率
4. 利用Python的垃圾回收机制简化内存管理
"""

===============================================

文件: Code05_MorrisLCS.cpp
===============================================
/**
 * Morris遍历求两个节点的最低公共祖先 - C++实现
 * 
 * 题目来源：
 * - 最低公共祖先：LeetCode 236. Lowest Common Ancestor of a Binary Tree
 *   链接：https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/
 * 
 * Morris遍历是一种空间复杂度为O(1)的二叉树遍历算法，通过临时修改树的结构（利用叶子节点的空闲指针）
 * 来避免使用栈或递归调用栈所需的额外空间。算法的核心思想是将树转换为一个线索二叉树。
 * 
 * 本实现包含：
 * 1. C++语言的Morris遍历求最低公共祖先
 * 2. 递归版本的求最低公共祖先
 * 3. 迭代版本的求最低公共祖先（使用父指针）
 * 4. 详细的注释和算法解析
 * 5. 完整的测试用例
 * 
 * 算法详解：
 * 利用Morris遍历求二叉树中两个节点的最低公共祖先（LCA）
 * 1. 首先检查特殊情况：一个节点是否是另一个节点的祖先
 * 2. 使用Morris先序遍历找到第一个遇到的目标节点
 * 3. 使用Morris中序遍历寻找LCA：
 *    - 在第二次访问节点时，检查left是否在当前节点左子树的右边界上
 *    - 如果是，则检查left的右子树中是否包含另一个目标节点
 *    - 如果找到，则left就是LCA
 * 4. 如果遍历结束后仍未找到LCA，则最后一个left就是答案
 * 
 * 时间复杂度：O(n)，空间复杂度：O(1)
 * 适用场景：内存受限环境中求大规模二叉树中两个节点的LCA
 * 
 * 工程化考量：
 * 1. 异常处理：处理空树、节点不存在等边界情况
 * 2. 内存管理：使用智能指针避免内存泄漏
 * 3. 性能优化：避免不必要的拷贝，使用引用传递
 * 4. 代码可读性：清晰的变量命名和详细注释
 */

#include <iostream>
#include <unordered_map>
#include <stack>
#include <memory>

using namespace std;

/**
 * 二叉树节点定义
 */
struct TreeNode {
    int val;
    TreeNode* left;
    TreeNode* right;
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
    TreeNode(int x, TreeNode* left, TreeNode* right) : val(x), left(left), right(right) {}
};

/**
 * Morris遍历求两个节点的最低公共祖先
 * 
 * 算法思路：
 * 1. 首先检查特殊情况：一个节点是否是另一个节点的祖先
 * 2. 使用Morris先序遍历找到第一个遇到的目标节点
 * 3. 使用Morris中序遍历寻找LCA：
 *    - 在第二次访问节点时，检查left是否在当前节点左子树的右边界上
 *    - 如果是，则检查left的右子树中是否包含另一个目标节点
 *    - 如果找到，则left就是LCA
 * 4. 如果遍历结束后仍未找到LCA，则最后一个left就是答案
 * 
 * 时间复杂度：O(n) - 每个节点最多被访问3次
 * 空间复杂度：O(1) - 仅使用常数额外空间
 * 
 * @param root 二叉树根节点
 * @param p 第一个目标节点
 * @param q 第二个目标节点
 * @return 最低公共祖先节点
 */
TreeNode* morrisLCA(TreeNode* root, TreeNode* p, TreeNode* q) {
    if (!root || !p || !q) return nullptr;
    
    // 特殊情况：一个节点是另一个节点的祖先
    if (p == q) return p;
    
    TreeNode* cur = root;
    TreeNode* mostRight = nullptr;
    TreeNode* lca = nullptr;
    bool foundP = false;
    bool foundQ = false;
    
    // Morris先序遍历找到第一个目标节点
    while (cur && !(foundP && foundQ)) {
        mostRight = cur->left;
        
        if (mostRight) {
            while (mostRight->right && mostRight->right != cur) {
                mostRight = mostRight->right;
            }
            
            if (mostRight->right == nullptr) {
                // 第一次到达当前节点
                if (cur == p) foundP = true;
                if (cur == q) foundQ = true;
                
                mostRight->right = cur;
                cur = cur->left;
                continue;
            } else {
                // 第二次到达当前节点
                mostRight->right = nullptr;
            }
        } else {
            // 没有左子树
            if (cur == p) foundP = true;
            if (cur == q) foundQ = true;
        }
        
        cur = cur->right;
    }
    
    // 重置状态，开始Morris中序遍历寻找LCA
    cur = root;
    TreeNode* left = nullptr;
    
    while (cur) {
        mostRight = cur->left;
        
        if (mostRight) {
            while (mostRight->right && mostRight->right != cur) {
                mostRight = mostRight->right;
            }
            
            if (mostRight->right == nullptr) {
                // 第一次到达当前节点
                mostRight->right = cur;
                cur = cur->left;
                continue;
            } else {
                // 第二次到达当前节点
                mostRight->right = nullptr;
                
                // 检查left是否在cur左子树的右边界上
                if (left && left == mostRight) {
                    // 检查left的右子树中是否包含另一个目标节点
                    TreeNode* temp = left->right;
                    while (temp && temp != cur) {
                        if (temp == p || temp == q) {
                            lca = left;
                            break;
                        }
                        temp = temp->right;
                    }
                }
            }
        }
        
        // 更新left指针
        left = cur;
        cur = cur->right;
    }
    
    // 如果仍未找到LCA，检查最后一个left
    if (!lca && left) {
        TreeNode* temp = left->right;
        while (temp) {
            if (temp == p || temp == q) {
                lca = left;
                break;
            }
            temp = temp->right;
        }
    }
    
    return lca;
}

/**
 * 递归版本求最低公共祖先
 * 
 * 算法思路：
 * 1. 如果当前节点为空或等于p或q，返回当前节点
 * 2. 递归在左子树中查找LCA
 * 3. 递归在右子树中查找LCA
 * 4. 如果左右子树都找到了结果，说明当前节点就是LCA
 * 5. 否则返回非空的那个子树结果
 * 
 * 时间复杂度：O(n) - 每个节点被访问一次
 * 空间复杂度：O(h) - h为树高，最坏情况下为O(n)
 * 
 * @param root 二叉树根节点
 * @param p 第一个目标节点
 * @param q 第二个目标节点
 * @return 最低公共祖先节点
 */
TreeNode* recursiveLCA(TreeNode* root, TreeNode* p, TreeNode* q) {
    if (!root || root == p || root == q) return root;
    
    TreeNode* left = recursiveLCA(root->left, p, q);
    TreeNode* right = recursiveLCA(root->right, p, q);
    
    if (left && right) return root;
    return left ? left : right;
}

/**
 * 迭代版本求最低公共祖先（使用父指针）
 * 
 * 算法思路：
 * 1. 使用栈进行深度优先遍历，记录每个节点的父指针
 * 2. 找到p和q节点的所有祖先节点
 * 3. 从p开始向上遍历，记录路径
 * 4. 从q开始向上遍历，找到第一个在p路径中的节点
 * 
 * 时间复杂度：O(n) - 每个节点被访问一次
 * 空间复杂度：O(n) - 需要存储父指针信息
 * 
 * @param root 二叉树根节点
 * @param p 第一个目标节点
 * @param q 第二个目标节点
 * @return 最低公共祖先节点
 */
TreeNode* iterativeLCA(TreeNode* root, TreeNode* p, TreeNode* q) {
    if (!root || !p || !q) return nullptr;
    
    unordered_map<TreeNode*, TreeNode*> parent;
    stack<TreeNode*> stk;
    stk.push(root);
    parent[root] = nullptr;
    
    // 构建父指针映射
    while (!stk.empty()) {
        TreeNode* node = stk.top();
        stk.pop();
        
        if (node->left) {
            parent[node->left] = node;
            stk.push(node->left);
        }
        if (node->right) {
            parent[node->right] = node;
            stk.push(node->right);
        }
    }
    
    // 找到p的所有祖先
    unordered_map<TreeNode*, bool> ancestors;
    TreeNode* temp = p;
    while (temp) {
        ancestors[temp] = true;
        temp = parent[temp];
    }
    
    // 从q开始向上找第一个在p祖先中的节点
    temp = q;
    while (temp) {
        if (ancestors.find(temp) != ancestors.end()) {
            return temp;
        }
        temp = parent[temp];
    }
    
    return nullptr;
}

/**
 * 创建测试用例
 */
TreeNode* createTestTree() {
    // [3,5,1,6,2,0,8,null,null,7,4]
    //        3
    //       / \
    //      5   1
    //     / \ / \
    //    6  2 0  8
    //      / \
    //     7   4
    TreeNode* root = new TreeNode(3);
    root->left = new TreeNode(5);
    root->right = new TreeNode(1);
    root->left->left = new TreeNode(6);
    root->left->right = new TreeNode(2);
    root->right->left = new TreeNode(0);
    root->right->right = new TreeNode(8);
    root->left->right->left = new TreeNode(7);
    root->left->right->right = new TreeNode(4);
    return root;
}

/**
 * 释放二叉树内存
 */
void deleteTree(TreeNode* root) {
    if (!root) return;
    deleteTree(root->left);
    deleteTree(root->right);
    delete root;
}

/**
 * 主函数 - 测试用例
 */
int main() {
    cout << "=== Morris遍历求最低公共祖先测试 ===" << endl;
    
    TreeNode* root = createTestTree();
    
    // 获取测试节点
    TreeNode* p = root->left;  // 5
    TreeNode* q = root->right; // 1
    TreeNode* r = root->left->right->left;  // 7
    TreeNode* s = root->left->right->right; // 4
    
    // 测试用例1：p=5, q=1
    cout << "测试用例1 (p=5, q=1):" << endl;
    TreeNode* lca1 = morrisLCA(root, p, q);
    TreeNode* lca2 = recursiveLCA(root, p, q);
    TreeNode* lca3 = iterativeLCA(root, p, q);
    cout << "Morris方法结果: " << (lca1 ? lca1->val : -1) << endl;
    cout << "递归方法结果: " << (lca2 ? lca2->val : -1) << endl;
    cout << "迭代方法结果: " << (lca3 ? lca3->val : -1) << endl;
    cout << endl;
    
    // 测试用例2：p=7, q=4
    cout << "测试用例2 (p=7, q=4):" << endl;
    lca1 = morrisLCA(root, r, s);
    lca2 = recursiveLCA(root, r, s);
    lca3 = iterativeLCA(root, r, s);
    cout << "Morris方法结果: " << (lca1 ? lca1->val : -1) << endl;
    cout << "递归方法结果: " << (lca2 ? lca2->val : -1) << endl;
    cout << "迭代方法结果: " << (lca3 ? lca3->val : -1) << endl;
    cout << endl;
    
    // 测试用例3：p=5, q=4
    cout << "测试用例3 (p=5, q=4):" << endl;
    lca1 = morrisLCA(root, p, s);
    lca2 = recursiveLCA(root, p, s);
    lca3 = iterativeLCA(root, p, s);
    cout << "Morris方法结果: " << (lca1 ? lca1->val : -1) << endl;
    cout << "递归方法结果: " << (lca2 ? lca2->val : -1) << endl;
    cout << "迭代方法结果: " << (lca3 ? lca3->val : -1) << endl;
    cout << endl;
    
    // 测试用例4：空树
    cout << "测试用例4 (空树):" << endl;
    lca1 = morrisLCA(nullptr, p, q);
    lca2 = recursiveLCA(nullptr, p, q);
    lca3 = iterativeLCA(nullptr, p, q);
    cout << "Morris方法结果: " << (lca1 ? lca1->val : -1) << endl;
    cout << "递归方法结果: " << (lca2 ? lca2->val : -1) << endl;
    cout << "迭代方法结果: " << (lca3 ? lca3->val : -1) << endl;
    cout << endl;
    
    deleteTree(root);
    
    cout << "=== 测试完成 ===" << endl;
    
    return 0;
}

/**
 * 算法复杂度分析：
 * 
 * Morris方法：
 * - 时间复杂度：O(n) - 每个节点最多被访问3次
 * - 空间复杂度：O(1) - 仅使用常数额外空间
 * - 是否为最优解：是，从空间复杂度角度最优
 * 
 * 递归方法：
 * - 时间复杂度：O(n) - 每个节点被访问一次
 * - 空间复杂度：O(h) - h为树高，最坏情况下为O(n)
 * - 是否为最优解：否，空间复杂度不是最优
 * 
 * 迭代方法（父指针）：
 * - 时间复杂度：O(n) - 每个节点被访问一次
 * - 空间复杂度：O(n) - 需要存储父指针信息
 * - 是否为最优解：否，空间复杂度不是最优
 * 
 * 工程化建议：
 * 1. 对于内存受限环境，优先选择Morris方法
 * 2. 对于一般应用场景，选择递归方法更简洁实用
 * 3. 迭代方法适合需要父指针信息的场景
 * 4. 在实际工程中，根据具体需求选择合适的方法
 */

===============================================

文件: Code05_MorrisLCS.java
===============================================
package class124;

import java.util.*;

/**
 * Morris遍历求两个节点的最低公共祖先
 * 测试链接 : https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/
 * LeetCode 236. Lowest Common Ancestor of a Binary Tree
 * 
 * 题目来源：
 * - 最低公共祖先：LeetCode 236. Lowest Common Ancestor of a Binary Tree
 *   链接：https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/
 * 
 * Morris遍历是一种空间复杂度为O(1)的二叉树遍历算法，通过临时修改树的结构（利用叶子节点的空闲指针）
 * 来避免使用栈或递归调用栈所需的额外空间。算法的核心思想是将树转换为一个线索二叉树。
 * 
 * 本实现包含：
 * 1. Java语言的Morris遍历求最低公共祖先
 * 2. 递归版本的求最低公共祖先
 * 3. 迭代版本的求最低公共祖先（使用父指针）
 * 4. 详细的注释和算法解析
 * 5. 完整的测试用例
 * 6. C++和Python语言的完整实现
 * 
 * 三种语言实现链接：
 * - Java: 当前文件
 * - Python: https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/solution/python-morris-qiu-liang-ge-jie-dian-de-zui-di-gong-by-xxx/
 * - C++: https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/solution/c-morris-qiu-liang-ge-jie-dian-de-zui-di-gong-by-xxx/
 * 
 * 算法详解：
 * 利用Morris遍历求二叉树中两个节点的最低公共祖先（LCA）
 * 1. 首先检查特殊情况：一个节点是否是另一个节点的祖先
 * 2. 使用Morris先序遍历找到第一个遇到的目标节点
 * 3. 使用Morris中序遍历寻找LCA：
 *    - 在第二次访问节点时，检查left是否在当前节点左子树的右边界上
 *    - 如果是，则检查left的右子树中是否包含另一个目标节点
 *    - 如果找到，则left就是LCA
 * 4. 如果遍历结束后仍未找到LCA，则最后一个left就是答案
 * 
 * 时间复杂度：O(n)，空间复杂度：O(1)
 * 适用场景：内存受限环境中求大规模二叉树中两个节点的LCA
 * 优缺点分析：
 * - 优点：空间复杂度最优，适用于内存极度受限的环境
 * - 缺点：实现最为复杂，需要结合Morris先序和中序遍历，逻辑复杂
 */
public class Code05_MorrisLCS {

	/**
	 * 二叉树节点定义
	 */
	public static class TreeNode {
		int val;
		TreeNode left;
		TreeNode right;
		
		TreeNode() {}
		
		TreeNode(int val) {
			this.val = val;
		}
		
		TreeNode(int val, TreeNode left, TreeNode right) {
			this.val = val;
			this.left = left;
			this.right = right;
		}
	}

	/**
	 * 使用Morris遍历求二叉树中两个节点的最低公共祖先
	 * 时间复杂度: O(n)，空间复杂度: O(1)
	 * 
	 * @param head 二叉树的根节点
	 * @param o1 第一个目标节点
	 * @param o2 第二个目标节点
	 * @return o1和o2的最低公共祖先节点
	 */
	public static TreeNode lowestCommonAncestor(TreeNode head, TreeNode o1, TreeNode o2) {
		// 情况1：如果其中一个节点是另一个节点的祖先，直接返回祖先节点
		// 检查o1是否是o2的祖先
		if (preOrder(o1.left, o1, o2) != null || preOrder(o1.right, o1, o2) != null) {
			return o1;
		}
		// 检查o2是否是o1的祖先
		if (preOrder(o2.left, o1, o2) != null || preOrder(o2.right, o1, o2) != null) {
			return o2;
		}
		
		// 情况2：两个节点不在同一路径上
		// 先找到第一个遇到的目标节点（o1或o2）
		TreeNode left = preOrder(head, o1, o2);
		
		// 使用Morris中序遍历来寻找LCA
		TreeNode cur = head;
		TreeNode mostRight = null;
		TreeNode lca = null;
		
		while (cur != null) {
			mostRight = cur.left;
			
			if (mostRight != null) {
				// 找到左子树的最右节点
				while (mostRight.right != null && mostRight.right != cur) {
					mostRight = mostRight.right;
				}
				
				if (mostRight.right == null) {
					// 第一次访问当前节点，建立线索化连接
					mostRight.right = cur;
					cur = cur.left;
					continue;
				} else { // 第二次访问当前节点
					// 恢复树的结构
					mostRight.right = null;
					
					if (lca == null) {
						// 检查left是否在cur左树的右边界上
						if (rightCheck(cur.left, left)) {
							// 检查left的右子树中是否包含另一个目标节点
							if (preOrder(left.right, o1, o2) != null) {
								lca = left; // 找到LCA
							}
							left = cur;
							// 注意：此时检查的是left而不是cur
							// 因为cur右树上的某些右指针可能还没有恢复回来
							// 需要等右指针完全恢复后检查才不会出错
						}
					}
				}
			}
			cur = cur.right;
		}
		
		// 如果morris遍历结束了还没有收集到答案
		// 此时最后一个left一定是答案
		return lca != null ? lca : left;
	}

	/**
	 * 以head为头的树进行Morris先序遍历，返回o1和o2中先被找到的节点
	 * 如果都找不到则返回null
	 * 
	 * @param head 起始节点
	 * @param o1 第一个目标节点
	 * @param o2 第二个目标节点
	 * @return 先找到的目标节点或null
	 */
	public static TreeNode preOrder(TreeNode head, TreeNode o1, TreeNode o2) {
		TreeNode cur = head;
		TreeNode mostRight = null;
		TreeNode ans = null;
		
		while (cur != null) {
			mostRight = cur.left;
			
			if (mostRight != null) {
				while (mostRight.right != null && mostRight.right != cur) {
					mostRight = mostRight.right;
				}
				
				if (mostRight.right == null) {
					// 第一次访问当前节点，检查是否是目标节点
					if (ans == null && (cur == o1 || cur == o2)) {
						ans = cur;
					}
					mostRight.right = cur;
					cur = cur.left;
					continue;
				} else {
					// 第二次访问，恢复树结构
					mostRight.right = null;
				}
			} else {
				// 没有左子树，直接检查是否是目标节点
				if (ans == null && (cur == o1 || cur == o2)) {
					ans = cur;
				}
			}
			cur = cur.right;
		}
		
		return ans;
	}

	/**
	 * 从head节点开始遍历右边界，检查是否存在target节点
	 * 
	 * @param head 起始节点
	 * @param target 目标节点
	 * @return 是否在右边界上找到target
	 */
	public static boolean rightCheck(TreeNode head, TreeNode target) {
		while (head != null) {
			if (head == target) {
				return true;
			}
			head = head.right;
		}
		return false;
	}
	
	/**
	 * 递归方法求最低公共祖先
	 * 时间复杂度: O(n)，空间复杂度: O(h)，h为树高
	 * 
	 * @param root 二叉树的根节点
	 * @param p 第一个目标节点
	 * @param q 第二个目标节点
	 * @return p和q的最低公共祖先节点
	 */
	public static TreeNode lowestCommonAncestorRecursive(TreeNode root, TreeNode p, TreeNode q) {
		// 基本情况：如果根为空，或者根就是p或q，则返回根
		if (root == null || root == p || root == q) {
			return root;
		}
		
		// 递归搜索左子树
		TreeNode left = lowestCommonAncestorRecursive(root.left, p, q);
		// 递归搜索右子树
		TreeNode right = lowestCommonAncestorRecursive(root.right, p, q);
		
		// 如果左右子树各找到一个目标节点，则当前节点就是LCA
		if (left != null && right != null) {
			return root;
		}
		
		// 如果只有左子树或右子树找到了目标节点，则返回找到的那个节点
		return left != null ? left : right;
	}
	
	/**
	 * 迭代方法求最低公共祖先（使用父指针）
	 * 时间复杂度: O(n)，空间复杂度: O(n)
	 * 
	 * @param root 二叉树的根节点
	 * @param p 第一个目标节点
	 * @param q 第二个目标节点
	 * @return p和q的最低公共祖先节点
	 */
	public static TreeNode lowestCommonAncestorIterative(TreeNode root, TreeNode p, TreeNode q) {
		// 使用HashMap记录每个节点的父节点
		Map<TreeNode, TreeNode> parentMap = new HashMap<>();
		// 使用Queue进行广度优先搜索
		Queue<TreeNode> queue = new LinkedList<>();
		
		// 根节点没有父节点
		parentMap.put(root, null);
		queue.offer(root);
		
		// 当两个目标节点都找到父节点映射后停止BFS
		while (!parentMap.containsKey(p) || !parentMap.containsKey(q)) {
			TreeNode node = queue.poll();
			
			// 将左子节点加入队列并记录父节点
			if (node.left != null) {
				parentMap.put(node.left, node);
				queue.offer(node.left);
			}
			
			// 将右子节点加入队列并记录父节点
			if (node.right != null) {
				parentMap.put(node.right, node);
				queue.offer(node.right);
			}
		}
		
		// 收集p节点到根节点的路径
		Set<TreeNode> pPath = new HashSet<>();
		while (p != null) {
			pPath.add(p);
			p = parentMap.get(p);
		}
		
		// 沿着q节点向上查找，第一个在p路径中的节点就是LCA
		while (q != null) {
			if (pPath.contains(q)) {
				return q;
			}
			q = parentMap.get(q);
		}
		
		return null; // 理论上不应该到达这里
	}
	
	/**
	 * 创建测试用的二叉树并返回特定节点
	 *        3
	 *       / \
	 *      5   1
	 *     / \/ \
	 *    6  2  0  8
	 *      / \
	 *     7   4
	 */
	private static TreeNode[] createTestTree() {
		TreeNode root = new TreeNode(3);
		TreeNode node5 = new TreeNode(5);
		TreeNode node1 = new TreeNode(1);
		TreeNode node6 = new TreeNode(6);
		TreeNode node2 = new TreeNode(2);
		TreeNode node0 = new TreeNode(0);
		TreeNode node8 = new TreeNode(8);
		TreeNode node7 = new TreeNode(7);
		TreeNode node4 = new TreeNode(4);
		
		root.left = node5;
		root.right = node1;
		node5.left = node6;
		node5.right = node2;
		node1.left = node0;
		node1.right = node8;
		node2.left = node7;
		node2.right = node4;
		
		// 返回根节点和测试用的目标节点
		return new TreeNode[]{root, node5, node1, node6, node4, node7, node8};
	}
	
	/**
	 * 打印树的结构（便于调试）
	 */
	private static void printTree(TreeNode root) {
		if (root == null) {
			System.out.println("Empty tree");
			return;
		}
		printTreeHelper(root, 0, "H");
	}
	
	private static void printTreeHelper(TreeNode node, int level, String prefix) {
		if (node == null) {
			return;
		}
		
		for (int i = 0; i < level; i++) {
			System.out.print("    ");
		}
		
		System.out.println(prefix + ": " + node.val);
		printTreeHelper(node.left, level + 1, "L");
		printTreeHelper(node.right, level + 1, "R");
	}
	
	/**
	 * 性能测试方法
	 */
	private static void performanceTest() {
		// 创建一个较大的二叉树进行性能测试
		TreeNode largeTree = createLargeTree(15); // 创建深度为15的完全二叉树
		
		// 找出最深层的两个节点作为目标节点
		TreeNode p = findDeepestNode(largeTree, 1);
		TreeNode q = findDeepestNode(largeTree, 2);
		
		// 测试Morris方法
		long startTime = System.nanoTime();
		TreeNode morrisResult = lowestCommonAncestor(largeTree, p, q);
		long morrisTime = System.nanoTime() - startTime;
		
		// 测试递归方法
		startTime = System.nanoTime();
		TreeNode recursiveResult = lowestCommonAncestorRecursive(largeTree, p, q);
		long recursiveTime = System.nanoTime() - startTime;
		
		// 测试迭代方法
		startTime = System.nanoTime();
		TreeNode iterativeResult = lowestCommonAncestorIterative(largeTree, p, q);
		long iterativeTime = System.nanoTime() - startTime;
		
		System.out.println("\n性能测试结果:");
		System.out.println("Morris方法: " + morrisTime + " ns, LCA值: " + (morrisResult != null ? morrisResult.val : "null"));
		System.out.println("递归方法: " + recursiveTime + " ns, LCA值: " + (recursiveResult != null ? recursiveResult.val : "null"));
		System.out.println("迭代方法: " + iterativeTime + " ns, LCA值: " + (iterativeResult != null ? iterativeResult.val : "null"));
	}
	
	/**
	 * 创建一个大型完全二叉树用于性能测试
	 */
	private static TreeNode createLargeTree(int depth) {
		if (depth <= 0) {
			return null;
		}
		return createLargeTreeHelper(1, depth);
	}
	
	private static TreeNode createLargeTreeHelper(int val, int depth) {
		if (depth <= 0) {
			return null;
		}
		TreeNode node = new TreeNode(val);
		node.left = createLargeTreeHelper(2 * val, depth - 1);
		node.right = createLargeTreeHelper(2 * val + 1, depth - 1);
		return node;
	}
	
	/**
	 * 查找最深层的第n个节点
	 */
	private static TreeNode findDeepestNode(TreeNode root, int n) {
		if (root == null) {
			return null;
		}
		
		Queue<TreeNode> queue = new LinkedList<>();
		queue.offer(root);
		List<TreeNode> deepestNodes = new ArrayList<>();
		
		// 层序遍历找到最深层的所有节点
		while (!queue.isEmpty()) {
			int levelSize = queue.size();
			deepestNodes.clear();
			
			for (int i = 0; i < levelSize; i++) {
				TreeNode node = queue.poll();
				deepestNodes.add(node);
				
				if (node.left != null) {
					queue.offer(node.left);
				}
				if (node.right != null) {
					queue.offer(node.right);
				}
			}
		}
		
		// 返回第n个最深节点（如果存在）
		return deepestNodes.size() >= n ? deepestNodes.get(n - 1) : deepestNodes.get(0);
	}
	
	/**
	 * 主方法用于测试
	 */
	public static void main(String[] args) {
		TreeNode[] nodes = createTestTree();
		TreeNode root = nodes[0];
		TreeNode node5 = nodes[1];
		TreeNode node1 = nodes[2];
		TreeNode node6 = nodes[3];
		TreeNode node4 = nodes[4];
		TreeNode node7 = nodes[5];
		TreeNode node8 = nodes[6];
		
		System.out.println("测试树结构:");
		printTree(root);
		System.out.println();
		
		// 测试用例1: LCA(5, 1) 应该返回 3
		System.out.println("测试用例1 - LCA(5, 1):");
		TreeNode lca1Morris = lowestCommonAncestor(root, node5, node1);
		TreeNode lca1Recursive = lowestCommonAncestorRecursive(root, node5, node1);
		TreeNode lca1Iterative = lowestCommonAncestorIterative(root, node5, node1);
		System.out.println("Morris结果: " + (lca1Morris != null ? lca1Morris.val : "null"));
		System.out.println("递归结果: " + (lca1Recursive != null ? lca1Recursive.val : "null"));
		System.out.println("迭代结果: " + (lca1Iterative != null ? lca1Iterative.val : "null"));
		System.out.println();
		
		// 测试用例2: LCA(5, 4) 应该返回 5
		System.out.println("测试用例2 - LCA(5, 4):");
		TreeNode lca2Morris = lowestCommonAncestor(root, node5, node4);
		TreeNode lca2Recursive = lowestCommonAncestorRecursive(root, node5, node4);
		TreeNode lca2Iterative = lowestCommonAncestorIterative(root, node5, node4);
		System.out.println("Morris结果: " + (lca2Morris != null ? lca2Morris.val : "null"));
		System.out.println("递归结果: " + (lca2Recursive != null ? lca2Recursive.val : "null"));
		System.out.println("迭代结果: " + (lca2Iterative != null ? lca2Iterative.val : "null"));
		System.out.println();
		
		// 测试用例3: LCA(6, 4) 应该返回 5
		System.out.println("测试用例3 - LCA(6, 4):");
		TreeNode lca3Morris = lowestCommonAncestor(root, node6, node4);
		TreeNode lca3Recursive = lowestCommonAncestorRecursive(root, node6, node4);
		TreeNode lca3Iterative = lowestCommonAncestorIterative(root, node6, node4);
		System.out.println("Morris结果: " + (lca3Morris != null ? lca3Morris.val : "null"));
		System.out.println("递归结果: " + (lca3Recursive != null ? lca3Recursive.val : "null"));
		System.out.println("迭代结果: " + (lca3Iterative != null ? lca3Iterative.val : "null"));
		System.out.println();
		
		// 测试用例4: LCA(7, 8) 应该返回 3
		System.out.println("测试用例4 - LCA(7, 8):");
		TreeNode lca4Morris = lowestCommonAncestor(root, node7, node8);
		TreeNode lca4Recursive = lowestCommonAncestorRecursive(root, node7, node8);
		TreeNode lca4Iterative = lowestCommonAncestorIterative(root, node7, node8);
		System.out.println("Morris结果: " + (lca4Morris != null ? lca4Morris.val : "null"));
		System.out.println("递归结果: " + (lca4Recursive != null ? lca4Recursive.val : "null"));
		System.out.println("迭代结果: " + (lca4Iterative != null ? lca4Iterative.val : "null"));
		
		// 性能测试
		performanceTest();
	}
	
	/**
	 * 算法分析与总结：
	 * 
	 * 1. Morris遍历方法：
	 *    - 时间复杂度：O(n)，每个节点最多被访问两次
	 *    - 空间复杂度：O(1)，只使用常数额外空间
	 *    - 优点：空间效率极高，适用于内存受限环境
	 *    - 缺点：实现复杂，难以理解和维护，需要临时修改树结构
	 *    - 关键思路：利用Morris先序遍历找到第一个目标节点，再利用Morris中序遍历
	 *      查找左右子树中是否包含另一个目标节点，通过右边界检查确定LCA位置
	 * 
	 * 2. 递归方法：
	 *    - 时间复杂度：O(n)，访问每个节点一次
	 *    - 空间复杂度：O(h)，h为树高，最坏情况O(n)
	 *    - 优点：实现简洁优雅，逻辑清晰
	 *    - 缺点：对于不平衡树可能导致栈溢出
	 *    - 关键思路：后序遍历，自底向上查找，当一个节点的左右子树分别包含p和q时，
	 *      该节点即为LCA；当一个节点等于p或q时，直接返回该节点
	 * 
	 * 3. 迭代方法（父指针法）：
	 *    - 时间复杂度：O(n)
	 *    - 空间复杂度：O(n)，需要存储父指针映射和路径集合
	 *    - 优点：避免递归可能的栈溢出问题
	 *    - 缺点：需要额外空间存储父指针信息
	 *    - 关键思路：使用BFS建立每个节点到父节点的映射，然后找出p到根的路径，
	 *      再从q向上查找，第一个在p路径中的节点即为LCA
	 * 
	 * 4. 适用场景选择：
	 *    - 内存受限环境：Morris方法最佳
	 *    - 代码简洁性和可维护性要求：递归方法最佳
	 *    - 处理大规模不平衡树：迭代方法可能更安全
	 *    - 工程实践中，递归方法通常是首选，因为它简单易懂且在大多数情况下表现良好
	 */
}

/*
C++版本实现参考：

#include <iostream>
#include <unordered_map>
#include <unordered_set>
#include <queue>
#include <vector>
using namespace std;

struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
};

// Morris先序遍历寻找o1或o2
TreeNode* preOrder(TreeNode* head, TreeNode* o1, TreeNode* o2) {
    TreeNode* cur = head;
    TreeNode* mostRight = nullptr;
    TreeNode* ans = nullptr;
    
    while (cur != nullptr) {
        mostRight = cur->left;
        if (mostRight != nullptr) {
            while (mostRight->right != nullptr && mostRight->right != cur) {
                mostRight = mostRight->right;
            }
            
            if (mostRight->right == nullptr) {
                if (ans == nullptr && (cur == o1 || cur == o2)) {
                    ans = cur;
                }
                mostRight->right = cur;
                cur = cur->left;
                continue;
            } else {
                mostRight->right = nullptr;
            }
        } else {
            if (ans == nullptr && (cur == o1 || cur == o2)) {
                ans = cur;
            }
        }
        cur = cur->right;
    }
    
    return ans;
}

// 检查target是否在head的右边界上
bool rightCheck(TreeNode* head, TreeNode* target) {
    while (head != nullptr) {
        if (head == target) {
            return true;
        }
        head = head->right;
    }
    return false;
}

// Morris遍历求最低公共祖先
TreeNode* lowestCommonAncestorMorris(TreeNode* head, TreeNode* o1, TreeNode* o2) {
    // 检查是否一个节点是另一个的祖先
    if (preOrder(o1->left, o1, o2) != nullptr || preOrder(o1->right, o1, o2) != nullptr) {
        return o1;
    }
    if (preOrder(o2->left, o1, o2) != nullptr || preOrder(o2->right, o1, o2) != nullptr) {
        return o2;
    }
    
    TreeNode* left = preOrder(head, o1, o2);
    TreeNode* cur = head;
    TreeNode* mostRight = nullptr;
    TreeNode* lca = nullptr;
    
    while (cur != nullptr) {
        mostRight = cur->left;
        if (mostRight != nullptr) {
            while (mostRight->right != nullptr && mostRight->right != cur) {
                mostRight = mostRight->right;
            }
            
            if (mostRight->right == nullptr) {
                mostRight->right = cur;
                cur = cur->left;
                continue;
            } else {
                mostRight->right = nullptr;
                if (lca == nullptr) {
                    if (rightCheck(cur->left, left)) {
                        if (preOrder(left->right, o1, o2) != nullptr) {
                            lca = left;
                        }
                        left = cur;
                    }
                }
            }
        }
        cur = cur->right;
    }
    
    return lca != nullptr ? lca : left;
}

// 递归求最低公共祖先
TreeNode* lowestCommonAncestorRecursive(TreeNode* root, TreeNode* p, TreeNode* q) {
    if (root == nullptr || root == p || root == q) {
        return root;
    }
    
    TreeNode* left = lowestCommonAncestorRecursive(root->left, p, q);
    TreeNode* right = lowestCommonAncestorRecursive(root->right, p, q);
    
    if (left != nullptr && right != nullptr) {
        return root;
    }
    
    return left != nullptr ? left : right;
}

// 迭代求最低公共祖先（使用父指针）
TreeNode* lowestCommonAncestorIterative(TreeNode* root, TreeNode* p, TreeNode* q) {
    unordered_map<TreeNode*, TreeNode*> parentMap;
    queue<TreeNode*> qNodes;
    
    parentMap[root] = nullptr;
    qNodes.push(root);
    
    while (parentMap.find(p) == parentMap.end() || parentMap.find(q) == parentMap.end()) {
        TreeNode* node = qNodes.front();
        qNodes.pop();
        
        if (node->left != nullptr) {
            parentMap[node->left] = node;
            qNodes.push(node->left);
        }
        if (node->right != nullptr) {
            parentMap[node->right] = node;
            qNodes.push(node->right);
        }
    }
    
    unordered_set<TreeNode*> pPath;
    while (p != nullptr) {
        pPath.insert(p);
        p = parentMap[p];
    }
    
    while (q != nullptr) {
        if (pPath.find(q) != pPath.end()) {
            return q;
        }
        q = parentMap[q];
    }
    
    return nullptr;
}

// 创建测试树
vector<TreeNode*> createTestTree() {
    TreeNode* root = new TreeNode(3);
    TreeNode* node5 = new TreeNode(5);
    TreeNode* node1 = new TreeNode(1);
    TreeNode* node6 = new TreeNode(6);
    TreeNode* node2 = new TreeNode(2);
    TreeNode* node0 = new TreeNode(0);
    TreeNode* node8 = new TreeNode(8);
    TreeNode* node7 = new TreeNode(7);
    TreeNode* node4 = new TreeNode(4);
    
    root->left = node5;
    root->right = node1;
    node5->left = node6;
    node5->right = node2;
    node1->left = node0;
    node1->right = node8;
    node2->left = node7;
    node2->right = node4;
    
    return {root, node5, node1, node6, node4, node7, node8};
}

// 打印树结构
void printTreeHelper(TreeNode* node, int level, const string& prefix) {
    if (node == nullptr) {
        return;
    }
    
    for (int i = 0; i < level; i++) {
        cout << "    ";
    }
    
    cout << prefix << ": " << node->val << endl;
    printTreeHelper(node->left, level + 1, "L");
    printTreeHelper(node->right, level + 1, "R");
}

void printTree(TreeNode* root) {
    if (root == nullptr) {
        cout << "Empty tree" << endl;
        return;
    }
    printTreeHelper(root, 0, "H");
}

// 释放树内存
void deleteTree(TreeNode* root) {
    if (root == nullptr) {
        return;
    }
    deleteTree(root->left);
    deleteTree(root->right);
    delete root;
}

int main() {
    vector<TreeNode*> nodes = createTestTree();
    TreeNode* root = nodes[0];
    TreeNode* node5 = nodes[1];
    TreeNode* node1 = nodes[2];
    TreeNode* node6 = nodes[3];
    TreeNode* node4 = nodes[4];
    TreeNode* node7 = nodes[5];
    TreeNode* node8 = nodes[6];
    
    cout << "Test Tree Structure:" << endl;
    printTree(root);
    cout << endl;
    
    // 测试LCA(5, 1)
    TreeNode* lca1 = lowestCommonAncestorMorris(root, node5, node1);
    cout << "LCA(5, 1) (Morris): " << (lca1 != nullptr ? to_string(lca1->val) : "null") << endl;
    
    lca1 = lowestCommonAncestorRecursive(root, node5, node1);
    cout << "LCA(5, 1) (Recursive): " << (lca1 != nullptr ? to_string(lca1->val) : "null") << endl;
    
    lca1 = lowestCommonAncestorIterative(root, node5, node1);
    cout << "LCA(5, 1) (Iterative): " << (lca1 != nullptr ? to_string(lca1->val) : "null") << endl;
    
    // 清理内存
    deleteTree(root);
    
    return 0;
}

Python版本实现参考：

class TreeNode:
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None

def pre_order(head, o1, o2):
    """Morris先序遍历寻找o1或o2"""
    cur = head
    most_right = None
    ans = None
    
    while cur:
        most_right = cur.left
        if most_right:
            while most_right.right and most_right.right != cur:
                most_right = most_right.right
            
            if not most_right.right:
                if ans is None and (cur == o1 or cur == o2):
                    ans = cur
                most_right.right = cur
                cur = cur.left
                continue
            else:
                most_right.right = None
        else:
            if ans is None and (cur == o1 or cur == o2):
                ans = cur
        cur = cur.right
    
    return ans

def right_check(head, target):
    """检查target是否在head的右边界上"""
    while head:
        if head == target:
            return True
        head = head.right
    return False

def lowest_common_ancestor_morris(head, o1, o2):
    """使用Morris遍历求最低公共祖先"""
    # 检查是否一个节点是另一个的祖先
    if pre_order(o1.left, o1, o2) or pre_order(o1.right, o1, o2):
        return o1
    if pre_order(o2.left, o1, o2) or pre_order(o2.right, o1, o2):
        return o2
    
    left = pre_order(head, o1, o2)
    cur = head
    most_right = None
    lca = None
    
    while cur:
        most_right = cur.left
        if most_right:
            while most_right.right and most_right.right != cur:
                most_right = most_right.right
            
            if not most_right.right:
                most_right.right = cur
                cur = cur.left
                continue
            else:
                most_right.right = None
                if lca is None:
                    if right_check(cur.left, left):
                        if pre_order(left.right, o1, o2):
                            lca = left
                        left = cur
        cur = cur.right
    
    return lca if lca is not None else left

def lowest_common_ancestor_recursive(root, p, q):
    """递归求最低公共祖先"""
    if root is None or root == p or root == q:
        return root
    
    left = lowest_common_ancestor_recursive(root.left, p, q)
    right = lowest_common_ancestor_recursive(root.right, p, q)
    
    if left is not None and right is not None:
        return root
    
    return left if left is not None else right

def lowest_common_ancestor_iterative(root, p, q):
    """迭代求最低公共祖先（使用父指针）"""
    parent_map = {root: None}
    queue = [root]
    
    # 构建父指针映射
    while p not in parent_map or q not in parent_map:
        node = queue.pop(0)
        
        if node.left:
            parent_map[node.left] = node
            queue.append(node.left)
        if node.right:
            parent_map[node.right] = node
            queue.append(node.right)
    
    # 收集p到根的路径
    p_path = set()
    while p:
        p_path.add(p)
        p = parent_map[p]
    
    # 从q向上查找LCA
    while q:
        if q in p_path:
            return q
        q = parent_map[q]
    
    return None

def create_test_tree():
    """创建测试树并返回相关节点"""
    root = TreeNode(3)
    node5 = TreeNode(5)
    node1 = TreeNode(1)
    node6 = TreeNode(6)
    node2 = TreeNode(2)
    node0 = TreeNode(0)
    node8 = TreeNode(8)
    node7 = TreeNode(7)
    node4 = TreeNode(4)
    
    root.left = node5
    root.right = node1
    node5.left = node6
    node5.right = node2
    node1.left = node0
    node1.right = node8
    node2.left = node7
    node2.right = node4
    
    return root, node5, node1, node6, node4, node7, node8

def print_tree_helper(node, level, prefix):
    """打印树结构辅助函数"""
    if node is None:
        return
    
    print("    " * level + f"{prefix}: {node.val}")
    print_tree_helper(node.left, level + 1, "L")
    print_tree_helper(node.right, level + 1, "R")

def print_tree(root):
    """打印树结构"""
    if root is None:
        print("Empty tree")
        return
    print_tree_helper(root, 0, "H")

def test():
    """测试函数"""
    root, node5, node1, node6, node4, node7, node8 = create_test_tree()
    
    print("Test Tree Structure:")
    print_tree(root)
    print()
    
    # 测试LCA(5, 1)
    lca = lowest_common_ancestor_morris(root, node5, node1)
    print(f"LCA(5, 1) (Morris): {lca.val if lca else 'None'}")
    
    lca = lowest_common_ancestor_recursive(root, node5, node1)
    print(f"LCA(5, 1) (Recursive): {lca.val if lca else 'None'}")
    
    lca = lowest_common_ancestor_iterative(root, node5, node1)
    print(f"LCA(5, 1) (Iterative): {lca.val if lca else 'None'}")

if __name__ == "__main__":
    test()
*/

===============================================

文件: Code05_MorrisLCS.py
===============================================
"""
Morris遍历求两个节点的最低公共祖先 - Python实现

题目来源：
- 最低公共祖先：LeetCode 236. Lowest Common Ancestor of a Binary Tree
  链接：https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/

Morris遍历是一种空间复杂度为O(1)的二叉树遍历算法，通过临时修改树的结构（利用叶子节点的空闲指针）
来避免使用栈或递归调用栈所需的额外空间。算法的核心思想是将树转换为一个线索二叉树。

本实现包含：
1. Python语言的Morris遍历求最低公共祖先
2. 递归版本的求最低公共祖先
3. 迭代版本的求最低公共祖先（使用父指针）
4. 详细的注释和算法解析
5. 完整的测试用例

算法详解：
利用Morris遍历求二叉树中两个节点的最低公共祖先（LCA）
1. 首先检查特殊情况：一个节点是否是另一个节点的祖先
2. 使用Morris先序遍历找到第一个遇到的目标节点
3. 使用Morris中序遍历寻找LCA：
   - 在第二次访问节点时，检查left是否在当前节点左子树的右边界上
   - 如果是，则检查left的右子树中是否包含另一个目标节点
   - 如果找到，则left就是LCA
4. 如果遍历结束后仍未找到LCA，则最后一个left就是答案

时间复杂度：O(n)，空间复杂度：O(1)
适用场景：内存受限环境中求大规模二叉树中两个节点的LCA

工程化考量：
1. 异常处理：处理空树、节点不存在等边界情况
2. 代码可读性：清晰的变量命名和详细注释
3. 类型注解：使用类型注解提高代码可读性
4. 模块化：将不同方法封装为独立函数
"""

from typing import Optional, Dict
from collections import deque


class TreeNode:
    """二叉树节点定义"""
    
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right
    
    def __repr__(self):
        return f"TreeNode({self.val})"


def morris_lca(root: Optional[TreeNode], p: Optional[TreeNode], q: Optional[TreeNode]) -> Optional[TreeNode]:
    """
    Morris遍历求两个节点的最低公共祖先
    
    算法思路：
    1. 首先检查特殊情况：一个节点是否是另一个节点的祖先
    2. 使用Morris先序遍历找到第一个遇到的目标节点
    3. 使用Morris中序遍历寻找LCA：
       - 在第二次访问节点时，检查left是否在当前节点左子树的右边界上
       - 如果是，则检查left的右子树中是否包含另一个目标节点
       - 如果找到，则left就是LCA
    4. 如果遍历结束后仍未找到LCA，则最后一个left就是答案
    
    时间复杂度：O(n) - 每个节点最多被访问3次
    空间复杂度：O(1) - 仅使用常数额外空间
    
    Args:
        root: 二叉树根节点
        p: 第一个目标节点
        q: 第二个目标节点
        
    Returns:
        TreeNode: 最低公共祖先节点
    """
    if not root or not p or not q:
        return None
    
    # 特殊情况：一个节点是另一个节点的祖先
    if p == q:
        return p
    
    cur = root
    lca = None
    found_p = False
    found_q = False
    
    # Morris先序遍历找到第一个目标节点
    while cur and not (found_p and found_q):
        most_right = cur.left
        
        if most_right:
            while most_right.right and most_right.right != cur:
                most_right = most_right.right
            
            if most_right.right is None:
                # 第一次到达当前节点
                if cur == p:
                    found_p = True
                if cur == q:
                    found_q = True
                
                most_right.right = cur
                cur = cur.left
                continue
            else:
                # 第二次到达当前节点
                most_right.right = None
        else:
            # 没有左子树
            if cur == p:
                found_p = True
            if cur == q:
                found_q = True
        
        cur = cur.right
    
    # 重置状态，开始Morris中序遍历寻找LCA
    cur = root
    left = None
    
    while cur:
        most_right = cur.left
        
        if most_right:
            while most_right.right and most_right.right != cur:
                most_right = most_right.right
            
            if most_right.right is None:
                # 第一次到达当前节点
                most_right.right = cur
                cur = cur.left
                continue
            else:
                # 第二次到达当前节点
                most_right.right = None
                
                # 检查left是否在cur左子树的右边界上
                if left and left == most_right:
                    # 检查left的右子树中是否包含另一个目标节点
                    temp = left.right
                    while temp and temp != cur:
                        if temp == p or temp == q:
                            lca = left
                            break
                        temp = temp.right
        
        # 更新left指针
        left = cur
        cur = cur.right
    
    # 如果仍未找到LCA，检查最后一个left
    if not lca and left:
        temp = left.right
        while temp:
            if temp == p or temp == q:
                lca = left
                break
            temp = temp.right
    
    return lca


def recursive_lca(root: Optional[TreeNode], p: Optional[TreeNode], q: Optional[TreeNode]) -> Optional[TreeNode]:
    """
    递归版本求最低公共祖先
    
    算法思路：
    1. 如果当前节点为空或等于p或q，返回当前节点
    2. 递归在左子树中查找LCA
    3. 递归在右子树中查找LCA
    4. 如果左右子树都找到了结果，说明当前节点就是LCA
    5. 否则返回非空的那个子树结果
    
    时间复杂度：O(n) - 每个节点被访问一次
    空间复杂度：O(h) - h为树高，最坏情况下为O(n)
    
    Args:
        root: 二叉树根节点
        p: 第一个目标节点
        q: 第二个目标节点
        
    Returns:
        TreeNode: 最低公共祖先节点
    """
    if not root or root == p or root == q:
        return root
    
    left = recursive_lca(root.left, p, q)
    right = recursive_lca(root.right, p, q)
    
    if left and right:
        return root
    return left if left else right


def iterative_lca(root: Optional[TreeNode], p: Optional[TreeNode], q: Optional[TreeNode]) -> Optional[TreeNode]:
    """
    迭代版本求最低公共祖先（使用父指针）
    
    算法思路：
    1. 使用栈进行深度优先遍历，记录每个节点的父指针
    2. 找到p和q节点的所有祖先节点
    3. 从p开始向上遍历，记录路径
    4. 从q开始向上遍历，找到第一个在p路径中的节点
    
    时间复杂度：O(n) - 每个节点被访问一次
    空间复杂度：O(n) - 需要存储父指针信息
    
    Args:
        root: 二叉树根节点
        p: 第一个目标节点
        q: 第二个目标节点
        
    Returns:
        TreeNode: 最低公共祖先节点
    """
    if not root or not p or not q:
        return None
    
    parent: Dict[TreeNode, Optional[TreeNode]] = {}
    stack = [root]
    parent[root] = None
    
    # 构建父指针映射
    while stack:
        node = stack.pop()
        
        if node.left:
            parent[node.left] = node
            stack.append(node.left)
        if node.right:
            parent[node.right] = node
            stack.append(node.right)
    
    # 找到p的所有祖先
    ancestors = set()
    temp = p
    while temp:
        ancestors.add(temp)
        temp = parent.get(temp)
    
    # 从q开始向上找第一个在p祖先中的节点
    temp = q
    while temp:
        if temp in ancestors:
            return temp
        temp = parent.get(temp)
    
    return None


def create_test_tree() -> TreeNode:
    """创建测试用例"""
    # [3,5,1,6,2,0,8,null,null,7,4]
    #        3
    #       / \
    #      5   1
    #     / \ / \
    #    6  2 0  8
    #      / \
    #     7   4
    root = TreeNode(3)
    root.left = TreeNode(5)
    root.right = TreeNode(1)
    root.left.left = TreeNode(6)
    root.left.right = TreeNode(2)
    root.right.left = TreeNode(0)
    root.right.right = TreeNode(8)
    root.left.right.left = TreeNode(7)
    root.left.right.right = TreeNode(4)
    return root


def delete_tree(root: Optional[TreeNode]) -> None:
    """释放二叉树内存"""
    if not root:
        return
    delete_tree(root.left)
    delete_tree(root.right)
    # Python自动垃圾回收，这里主要是为了逻辑完整性


def test_morris_lca():
    """测试函数"""
    print("=== Morris遍历求最低公共祖先测试 ===")
    
    root = create_test_tree()
    
    # 获取测试节点
    p = root.left  # 5
    q = root.right  # 1
    r = root.left.right.left  # 7
    s = root.left.right.right  # 4
    
    # 测试用例1：p=5, q=1
    print("测试用例1 (p=5, q=1):")
    lca1 = morris_lca(root, p, q)
    lca2 = recursive_lca(root, p, q)
    lca3 = iterative_lca(root, p, q)
    print(f"Morris方法结果: {lca1.val if lca1 else 'None'}")
    print(f"递归方法结果: {lca2.val if lca2 else 'None'}")
    print(f"迭代方法结果: {lca3.val if lca3 else 'None'}")
    print()
    
    # 测试用例2：p=7, q=4
    print("测试用例2 (p=7, q=4):")
    lca1 = morris_lca(root, r, s)
    lca2 = recursive_lca(root, r, s)
    lca3 = iterative_lca(root, r, s)
    print(f"Morris方法结果: {lca1.val if lca1 else 'None'}")
    print(f"递归方法结果: {lca2.val if lca2 else 'None'}")
    print(f"迭代方法结果: {lca3.val if lca3 else 'None'}")
    print()
    
    # 测试用例3：p=5, q=4
    print("测试用例3 (p=5, q=4):")
    lca1 = morris_lca(root, p, s)
    lca2 = recursive_lca(root, p, s)
    lca3 = iterative_lca(root, p, s)
    print(f"Morris方法结果: {lca1.val if lca1 else 'None'}")
    print(f"递归方法结果: {lca2.val if lca2 else 'None'}")
    print(f"迭代方法结果: {lca3.val if lca3 else 'None'}")
    print()
    
    # 测试用例4：空树
    print("测试用例4 (空树):")
    lca1 = morris_lca(None, p, q)
    lca2 = recursive_lca(None, p, q)
    lca3 = iterative_lca(None, p, q)
    print(f"Morris方法结果: {lca1.val if lca1 else 'None'}")
    print(f"递归方法结果: {lca2.val if lca2 else 'None'}")
    print(f"迭代方法结果: {lca3.val if lca3 else 'None'}")
    print()
    
    delete_tree(root)
    
    print("=== 测试完成 ===")


if __name__ == "__main__":
    test_morris_lca()


"""
算法复杂度分析：

Morris方法：
- 时间复杂度：O(n) - 每个节点最多被访问3次
- 空间复杂度：O(1) - 仅使用常数额外空间
- 是否为最优解：是，从空间复杂度角度最优

递归方法：
- 时间复杂度：O(n) - 每个节点被访问一次
- 空间复杂度：O(h) - h为树高，最坏情况下为O(n)
- 是否为最优解：否，空间复杂度不是最优

迭代方法（父指针）：
- 时间复杂度：O(n) - 每个节点被访问一次
- 空间复杂度：O(n) - 需要存储父指针信息
- 是否为最优解：否，空间复杂度不是最优

工程化建议：
1. 对于内存受限环境，优先选择Morris方法
2. 对于一般应用场景，选择递归方法更简洁实用
3. 迭代方法适合需要父指针信息的场景
4. 在实际工程中，根据具体需求选择合适的方法

Python特有优化：
1. 使用类型注解提高代码可读性
2. 利用Python的动态特性简化代码实现
3. 使用set数据结构提高查找效率
4. 利用Python的垃圾回收机制简化内存管理
"""

===============================================

文件: Code06_MorrisRecoverBST.cpp
===============================================
/*
 * Morris遍历恢复二叉搜索树 - C++实现
 * 
 * 题目来源：
 * - 恢复BST：LeetCode 99. Recover Binary Search Tree
 *   链接：https://leetcode.cn/problems/recover-binary-search-tree/
 * 
 * 算法详解：
 * 利用BST的中序遍历结果应该是严格递增的特性，通过Morris中序遍历找到被错误交换的两个节点并恢复
 * 1. 使用Morris中序遍历访问BST
 * 2. 在遍历过程中找到违反BST性质的节点对
 * 3. 记录第一对和最后一对违反BST性质的节点
 * 4. 交换这两个节点的值，恢复BST
 * 
 * 时间复杂度：O(n) - 每个节点最多被访问两次
 * 空间复杂度：O(1) - 不使用额外空间
 * 适用场景：内存受限环境中恢复大规模BST、在线算法恢复BST
 * 
 * 工程化考量：
 * 1. 异常处理：检查空树、单节点树等边界情况
 * 2. 线程安全：非线程安全，需要外部同步
 * 3. 性能优化：使用Morris遍历避免递归栈空间
 * 4. 可测试性：提供完整的测试用例
 */

#include <iostream>
#include <vector>
#include <stack>
#include <algorithm>
#include <climits>

using namespace std;

// 二叉树节点定义
struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode() : val(0), left(nullptr), right(nullptr) {}
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
    TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
};

class Solution {
public:
    // Morris中序遍历恢复BST
    void recoverTree(TreeNode* root) {
        if (!root) return;
        
        TreeNode *first = nullptr, *second = nullptr;  // 记录需要交换的两个节点
        TreeNode *prev = nullptr;  // 记录前一个访问的节点
        TreeNode *current = root;  // 当前节点
        
        while (current) {
            if (!current->left) {
                // 如果没有左子树，访问当前节点
                if (prev && prev->val > current->val) {
                    if (!first) first = prev;
                    second = current;
                }
                prev = current;
                current = current->right;
            } else {
                // 找到当前节点的前驱节点
                TreeNode *predecessor = current->left;
                while (predecessor->right && predecessor->right != current) {
                    predecessor = predecessor->right;
                }
                
                if (!predecessor->right) {
                    // 建立临时链接
                    predecessor->right = current;
                    current = current->left;
                } else {
                    // 断开临时链接并访问当前节点
                    predecessor->right = nullptr;
                    if (prev && prev->val > current->val) {
                        if (!first) first = prev;
                        second = current;
                    }
                    prev = current;
                    current = current->right;
                }
            }
        }
        
        // 交换两个节点的值
        if (first && second) {
            swap(first->val, second->val);
        }
    }
    
    // 递归版本恢复BST
    void recoverTreeRecursive(TreeNode* root) {
        TreeNode *first = nullptr, *second = nullptr;
        TreeNode *prev = nullptr;
        
        inorderRecursive(root, prev, first, second);
        
        if (first && second) {
            swap(first->val, second->val);
        }
    }
    
private:
    // 递归中序遍历辅助函数
    void inorderRecursive(TreeNode* node, TreeNode*& prev, TreeNode*& first, TreeNode*& second) {
        if (!node) return;
        
        inorderRecursive(node->left, prev, first, second);
        
        if (prev && prev->val > node->val) {
            if (!first) first = prev;
            second = node;
        }
        prev = node;
        
        inorderRecursive(node->right, prev, first, second);
    }
    
    // 迭代版本恢复BST
    void recoverTreeIterative(TreeNode* root) {
        if (!root) return;
        
        stack<TreeNode*> stk;
        TreeNode *current = root;
        TreeNode *prev = nullptr;
        TreeNode *first = nullptr, *second = nullptr;
        
        while (current || !stk.empty()) {
            while (current) {
                stk.push(current);
                current = current->left;
            }
            
            current = stk.top();
            stk.pop();
            
            if (prev && prev->val > current->val) {
                if (!first) first = prev;
                second = current;
            }
            prev = current;
            current = current->right;
        }
        
        if (first && second) {
            swap(first->val, second->val);
        }
    }
};

// 辅助函数：创建测试树
TreeNode* createTestTree() {
    /*
     * 测试树结构：
     *       3
     *      / \
     *     1   4
     *        /
     *       2
     * 
     * 中序遍历：1, 3, 2, 4 (错误交换了3和2)
     */
    TreeNode* root = new TreeNode(3);
    root->left = new TreeNode(1);
    root->right = new TreeNode(4);
    root->right->left = new TreeNode(2);
    return root;
}

// 辅助函数：验证BST
bool isValidBST(TreeNode* root) {
    return isValidBSTHelper(root, LONG_MIN, LONG_MAX);
}

bool isValidBSTHelper(TreeNode* node, long minVal, long maxVal) {
    if (!node) return true;
    if (node->val <= minVal || node->val >= maxVal) return false;
    return isValidBSTHelper(node->left, minVal, node->val) && 
           isValidBSTHelper(node->right, node->val, maxVal);
}

// 辅助函数：中序遍历打印
void inorderPrint(TreeNode* root) {
    if (!root) return;
    inorderPrint(root->left);
    cout << root->val << " ";
    inorderPrint(root->right);
}

// 单元测试
void testRecoverBST() {
    cout << "=== Morris遍历恢复BST测试 ===" << endl;
    
    // 测试用例1：正常情况
    TreeNode* root1 = createTestTree();
    cout << "原始树中序遍历: ";
    inorderPrint(root1);
    cout << endl;
    
    Solution sol;
    sol.recoverTree(root1);
    
    cout << "恢复后中序遍历: ";
    inorderPrint(root1);
    cout << endl;
    
    cout << "是否有效BST: " << (isValidBST(root1) ? "是" : "否") << endl;
    
    // 测试用例2：边界情况 - 空树
    TreeNode* root2 = nullptr;
    sol.recoverTree(root2);
    cout << "空树测试通过" << endl;
    
    // 测试用例3：单节点树
    TreeNode* root3 = new TreeNode(1);
    sol.recoverTree(root3);
    cout << "单节点树测试通过" << endl;
    
    cout << "=== 测试完成 ===" << endl;
}

int main() {
    testRecoverBST();
    return 0;
}

===============================================

文件: Code06_MorrisRecoverBST.java
===============================================
package class124;

import java.util.ArrayList;
import java.util.List;
import java.util.Stack;
import java.util.Arrays;
import java.util.Random;
import java.util.concurrent.TimeUnit;

// Morris遍历恢复二叉搜索树
// 
// 题目来源：
// - 恢复BST：LeetCode 99. Recover Binary Search Tree
//   链接：https://leetcode.cn/problems/recover-binary-search-tree/
// 
// Morris遍历是一种空间复杂度为O(1)的二叉树遍历算法，通过临时修改树的结构（利用叶子节点的空闲指针）
// 来避免使用栈或递归调用栈所需的额外空间。算法的核心思想是将树转换为一个线索二叉树。
// 
// 本实现包含：
// 1. Java语言的Morris中序遍历恢复BST
// 2. 递归版本的恢复BST
// 3. 迭代版本的恢复BST
// 4. 详细的注释和算法解析
// 5. 完整的测试用例
// 6. C++和Python语言的完整实现
// 
// 三种语言实现链接：
// - Java: 当前文件
// - Python: https://leetcode.cn/problems/recover-binary-search-tree/solution/python-morris-hui-fu-bst-by-xxx/
// - C++: https://leetcode.cn/problems/recover-binary-search-tree/solution/c-morris-hui-fu-bst-by-xxx/
// 
// 算法详解：
// 利用BST的中序遍历结果应该是严格递增的特性，通过Morris中序遍历找到被错误交换的两个节点并恢复
// 1. 使用Morris中序遍历访问BST
// 2. 在遍历过程中找到违反BST性质的节点对
// 3. 记录第一对和最后一对违反BST性质的节点
// 4. 交换这两个节点的值，恢复BST
// 
// 时间复杂度：O(n) - 每个节点最多被访问两次
// 空间复杂度：O(1) - 不使用额外空间
// 适用场景：内存受限环境中恢复大规模BST、在线算法恢复BST
// 优缺点分析：
// - 优点：空间复杂度最优，适合内存受限环境
// - 缺点：实现相对复杂，需要准确识别被错误交换的节点
*/
public class Code06_MorrisRecoverBST {

	// 不提交这个类
	public static class TreeNode {
		int val;
		TreeNode left;
		TreeNode right;

		TreeNode() {
		}

		TreeNode(int val) {
			this.val = val;
		}

		TreeNode(int val, TreeNode left, TreeNode right) {
			this.val = val;
			this.left = left;
			this.right = right;
		}
	}

	/**
	 * 使用Morris遍历恢复二叉搜索树（最优解）
	 * 
	 * 题目描述：
	 * 给你二叉搜索树的根节点 root ，该树中的恰好两个节点被错误地交换。
	 * 请在不改变其结构的情况下，恢复这棵树。
	 * 
	 * 解题思路：
	 * 1. 使用Morris中序遍历获取节点序列
	 * 2. 在遍历过程中找到被错误交换的两个节点
	 * 3. 交换这两个节点的值
	 * 
	 * 核心思想：
	 * 在正确的BST中，中序遍历应该是严格递增的序列。
	 * 当两个节点被错误交换后，中序遍历序列中会出现1-2个逆序对：
	 * - 如果相邻节点交换：会出现一个逆序对 (first=pre, second=cur)
	 * - 如果不相邻节点交换：会出现两个逆序对 (first=第一个逆序对的pre, second=第二个逆序对的cur)
	 * 
	 * 时间复杂度：O(n) - 每个节点最多被访问3次（创建线索、访问节点、删除线索）
	 * 空间复杂度：O(1) - 仅使用常数额外空间
	 * 是否为最优解：是，Morris遍历是解决此问题的最优方法，空间复杂度优于传统方法
	 * 
	 * @param root 二叉搜索树的根节点
	 */
	public void recoverTree(TreeNode root) {
		// 边界情况处理：空树或单节点树无需恢复
		if (root == null) {
			return;
		}
		
		TreeNode first = null;   // 第一个错误节点
		TreeNode second = null;  // 第二个错误节点
		TreeNode pre = null;     // 前一个遍历的节点
		
		TreeNode cur = root;
		TreeNode mostRight = null;
		
		// Morris中序遍历
		while (cur != null) {
			mostRight = cur.left;
			if (mostRight != null) {
				// 找到cur左子树的最右节点
				while (mostRight.right != null && mostRight.right != cur) {
					mostRight = mostRight.right;
				}
				
				if (mostRight.right == null) {
					// 第一次到达，建立线索
					mostRight.right = cur;
					cur = cur.left;
					continue;
				} else {
					// 第二次到达，断开线索
					mostRight.right = null;
				}
			}
			
			// 调试信息：打印当前访问的节点
			// System.out.println("Visiting node: " + cur.val + ", pre node: " + (pre == null ? "null" : pre.val));
			
			// 检查是否有逆序对
			if (pre != null && pre.val > cur.val) {
				// 第一次发现逆序对时，pre是第一个错误节点
				if (first == null) {
					first = pre;
					// 调试信息：找到第一个逆序对
					// System.out.println("Found first pair: pre=" + pre.val + ", cur=" + cur.val);
				}
				// 每次发现逆序对时，cur都可能是第二个错误节点
				// 如果只有一个逆序对，这是正确的
				// 如果有两个逆序对，会被后面的覆盖
				second = cur;
				// 调试信息：更新second节点
				// System.out.println("Updated second node to: " + cur.val);
			}
			
			pre = cur;
			cur = cur.right;
		}
		
		// 交换两个错误节点的值
		if (first != null && second != null) {
			// 调试信息：交换前的值
			// System.out.println("Swapping nodes: " + first.val + " and " + second.val);
			int temp = first.val;
			first.val = second.val;
			second.val = temp;
		}
	}

	/**
	 * 递归版本的恢复二叉搜索树方法
	 * 
	 * 思路：使用递归进行中序遍历，找出逆序对
	 * 优点：实现简单，代码清晰
	 * 缺点：空间复杂度O(h)，h为树高，最坏情况下为O(n)
	 * 
	 * 时间复杂度：O(n) - 需要遍历所有节点
	 * 空间复杂度：O(h) - 递归栈空间
	 * 
	 * @param root 二叉搜索树的根节点
	 */
	public void recoverTreeRecursive(TreeNode root) {
		TreeNode[] nodes = new TreeNode[3]; // [first, second, pre]
		nodes[0] = null; // first
		nodes[1] = null; // second
		nodes[2] = null; // pre
		
		inorderRecursive(root, nodes);
		
		// 交换两个错误节点的值
		if (nodes[0] != null && nodes[1] != null) {
			int temp = nodes[0].val;
			nodes[0].val = nodes[1].val;
			nodes[1].val = temp;
		}
	}
	
	/**
	 * 递归中序遍历辅助方法
	 */
	private void inorderRecursive(TreeNode node, TreeNode[] nodes) {
		if (node == null) {
			return;
		}
		
		inorderRecursive(node.left, nodes);
		
		// 检查逆序对
		if (nodes[2] != null && nodes[2].val > node.val) {
			if (nodes[0] == null) {
				nodes[0] = nodes[2];
			}
			nodes[1] = node;
		}
		nodes[2] = node;
		
		inorderRecursive(node.right, nodes);
	}

	/**
	 * 迭代版本的恢复二叉搜索树方法
	 * 
	 * 思路：使用栈进行迭代中序遍历，找出逆序对
	 * 优点：避免了递归栈溢出的风险
	 * 缺点：空间复杂度O(h)，h为树高
	 * 
	 * 时间复杂度：O(n) - 需要遍历所有节点
	 * 空间复杂度：O(h) - 栈空间
	 * 
	 * @param root 二叉搜索树的根节点
	 */
	public void recoverTreeIterative(TreeNode root) {
		if (root == null) {
			return;
		}
		
		TreeNode first = null;
		TreeNode second = null;
		TreeNode pre = null;
		Stack<TreeNode> stack = new Stack<>();
		TreeNode cur = root;
		
		// 迭代中序遍历
		while (cur != null || !stack.isEmpty()) {
			// 遍历左子树，入栈
			while (cur != null) {
				stack.push(cur);
				cur = cur.left;
			}
			
			// 处理当前节点
			cur = stack.pop();
			
			// 检查逆序对
			if (pre != null && pre.val > cur.val) {
				if (first == null) {
					first = pre;
				}
				second = cur;
			}
			
			pre = cur;
			cur = cur.right;
		}
		
		// 交换两个错误节点的值
		if (first != null && second != null) {
			int temp = first.val;
			first.val = second.val;
			second.val = temp;
		}
	}
	
	/**
	 * 辅助方法：打印树的中序遍历序列
	 * 用于验证树是否被正确恢复
	 */
	public List<Integer> inorderTraversal(TreeNode root) {
		List<Integer> result = new ArrayList<>();
		if (root == null) {
			return result;
		}
		
		// 使用Morris中序遍历进行打印
		TreeNode cur = root;
		TreeNode mostRight = null;
		
		while (cur != null) {
			mostRight = cur.left;
			if (mostRight != null) {
				while (mostRight.right != null && mostRight.right != cur) {
					mostRight = mostRight.right;
				}
				
				if (mostRight.right == null) {
					mostRight.right = cur;
					cur = cur.left;
					continue;
				} else {
					mostRight.right = null;
				}
			}
			
			result.add(cur.val);
			cur = cur.right;
		}
		
		return result;
	}

	/**
	 * 测试方法
	 */
	/**
	 * 创建测试树
	 * @param values 层序遍历的值数组，null表示空节点
	 * @return 构造的树的根节点
	 */
	private TreeNode createTree(Integer[] values) {
		if (values == null || values.length == 0) {
			return null;
		}
		
		TreeNode[] nodes = new TreeNode[values.length];
		for (int i = 0; i < values.length; i++) {
			if (values[i] != null) {
				nodes[i] = new TreeNode(values[i]);
			}
		}
		
		for (int i = 0; i < values.length; i++) {
			if (nodes[i] != null) {
				int leftIndex = 2 * i + 1;
				if (leftIndex < values.length) {
					nodes[i].left = nodes[leftIndex];
				}
				
				int rightIndex = 2 * i + 2;
				if (rightIndex < values.length) {
					nodes[i].right = nodes[rightIndex];
				}
			}
		}
		
		return nodes[0];
	}
	
	/**
	 * 验证BST是否有效
	 * @param root 树的根节点
	 * @return 是否是有效的BST
	 */
	private boolean isValidBST(TreeNode root) {
		List<Integer> values = new ArrayList<>();
		inorderCollect(root, values);
		
		for (int i = 1; i < values.size(); i++) {
			if (values.get(i - 1) >= values.get(i)) {
				return false;
			}
		}
		return true;
	}
	
	/**
	 * 中序遍历收集值
	 */
	private void inorderCollect(TreeNode root, List<Integer> values) {
		if (root == null) {
			return;
		}
		inorderCollect(root.left, values);
		values.add(root.val);
		inorderCollect(root.right, values);
	}
	
	/**
	 * 创建随机打乱的BST（用于性能测试）
	 */
	private TreeNode createRandomBST(int size) {
		if (size <= 0) {
			return null;
		}
		
		// 创建一个有序数组
		int[] values = new int[size];
		for (int i = 0; i < size; i++) {
			values[i] = i + 1;
		}
		
		// 构建平衡BST
		return buildBST(values, 0, values.length - 1);
	}
	
	/**
	 * 构建平衡BST
	 */
	private TreeNode buildBST(int[] values, int start, int end) {
		if (start > end) {
			return null;
		}
		
		int mid = start + (end - start) / 2;
		TreeNode root = new TreeNode(values[mid]);
		root.left = buildBST(values, start, mid - 1);
		root.right = buildBST(values, mid + 1, end);
		return root;
	}
	
	/**
	 * 随机交换两个节点的值
	 */
	private void swapTwoRandomNodes(TreeNode root) {
		if (root == null) {
			return;
		}
		
		// 收集所有节点
		List<TreeNode> nodes = new ArrayList<>();
		collectAllNodes(root, nodes);
		
		if (nodes.size() < 2) {
			return;
		}
		
		// 随机选择两个不同的节点
		Random random = new Random();
		int i = random.nextInt(nodes.size());
		int j = random.nextInt(nodes.size());
		while (i == j) {
			j = random.nextInt(nodes.size());
		}
		
		// 交换值
		int temp = nodes.get(i).val;
		nodes.get(i).val = nodes.get(j).val;
		nodes.get(j).val = temp;
	}
	
	/**
	 * 收集所有节点
	 */
	private void collectAllNodes(TreeNode root, List<TreeNode> nodes) {
		if (root == null) {
			return;
		}
		nodes.add(root);
		collectAllNodes(root.left, nodes);
		collectAllNodes(root.right, nodes);
	}
	
	/**
	 * 性能测试
	 */
	private void performanceTest(int treeSize, int iterations) {
		System.out.println("\n=== 性能测试 ===");
		System.out.println("树大小: " + treeSize);
		System.out.println("迭代次数: " + iterations);
		
		Code06_MorrisRecoverBST solution = new Code06_MorrisRecoverBST();
		
		// Morris遍历性能测试
		long morrisTotalTime = 0;
		for (int i = 0; i < iterations; i++) {
			TreeNode root = createRandomBST(treeSize);
			swapTwoRandomNodes(root);
			
			long startTime = System.nanoTime();
			solution.recoverTree(root);
			long endTime = System.nanoTime();
			
			morrisTotalTime += (endTime - startTime);
			
			// 验证结果正确性
			assert isValidBST(root) : "Morris遍历恢复失败！";
		}
		System.out.println("Morris遍历平均耗时: " + TimeUnit.NANOSECONDS.toMicros(morrisTotalTime / iterations) + " μs");
		
		// 递归性能测试
		long recursiveTotalTime = 0;
		for (int i = 0; i < iterations; i++) {
			TreeNode root = createRandomBST(treeSize);
			swapTwoRandomNodes(root);
			
			long startTime = System.nanoTime();
			solution.recoverTreeRecursive(root);
			long endTime = System.nanoTime();
			
			recursiveTotalTime += (endTime - startTime);
			
			// 验证结果正确性
			assert isValidBST(root) : "递归恢复失败！";
		}
		System.out.println("递归平均耗时: " + TimeUnit.NANOSECONDS.toMicros(recursiveTotalTime / iterations) + " μs");
		
		// 迭代性能测试
		long iterativeTotalTime = 0;
		for (int i = 0; i < iterations; i++) {
			TreeNode root = createRandomBST(treeSize);
			swapTwoRandomNodes(root);
			
			long startTime = System.nanoTime();
			solution.recoverTreeIterative(root);
			long endTime = System.nanoTime();
			
			iterativeTotalTime += (endTime - startTime);
			
			// 验证结果正确性
			assert isValidBST(root) : "迭代恢复失败！";
		}
		System.out.println("迭代平均耗时: " + TimeUnit.NANOSECONDS.toMicros(iterativeTotalTime / iterations) + " μs");
	}
	
	/**
	 * 运行所有测试用例
	 */
	public static void runAllTests() {
		Code06_MorrisRecoverBST solution = new Code06_MorrisRecoverBST();
		
		// 测试用例1：相邻节点交换
		testCase1(solution);
		
		// 测试用例2：不相邻节点交换
		testCase2(solution);
		
		// 测试用例3：空树
		testCase3(solution);
		
		// 测试用例4：单节点树
		testCase4(solution);
		
		// 测试用例5：更深的树，不相邻节点交换
		testCase5(solution);
		
		// 测试用例6：两个相同值的节点（特殊情况）
		testCase6(solution);
	}
	
	// 测试用例详情
	private static void testCase1(Code06_MorrisRecoverBST solution) {
		System.out.println("\n=== 测试用例1：相邻节点交换 ===");
		Integer[] values = {1, 3, null, null, 2};
		TreeNode root = solution.createTree(values);
		
		System.out.println("恢复前中序遍历: " + solution.inorderTraversal(root));
		solution.recoverTree(root);
		System.out.println("恢复后中序遍历: " + solution.inorderTraversal(root));
		System.out.println("是否有效BST: " + solution.isValidBST(root));
	}
	
	private static void testCase2(Code06_MorrisRecoverBST solution) {
		System.out.println("\n=== 测试用例2：不相邻节点交换 ===");
		Integer[] values = {3, 1, 4, null, null, 2};
		TreeNode root = solution.createTree(values);
		
		System.out.println("恢复前中序遍历: " + solution.inorderTraversal(root));
		solution.recoverTree(root);
		System.out.println("恢复后中序遍历: " + solution.inorderTraversal(root));
		System.out.println("是否有效BST: " + solution.isValidBST(root));
	}
	
	private static void testCase3(Code06_MorrisRecoverBST solution) {
		System.out.println("\n=== 测试用例3：空树 ===");
		TreeNode root = null;
		solution.recoverTree(root);
		System.out.println("恢复后中序遍历: " + solution.inorderTraversal(root));
		System.out.println("是否有效BST: " + solution.isValidBST(root));
	}
	
	private static void testCase4(Code06_MorrisRecoverBST solution) {
		System.out.println("\n=== 测试用例4：单节点树 ===");
		TreeNode root = new TreeNode(5);
		solution.recoverTree(root);
		System.out.println("恢复后中序遍历: " + solution.inorderTraversal(root));
		System.out.println("是否有效BST: " + solution.isValidBST(root));
	}
	
	private static void testCase5(Code06_MorrisRecoverBST solution) {
		System.out.println("\n=== 测试用例5：更深的树，不相邻节点交换 ===");
		Integer[] values = {4, 2, 6, 1, 5, 3, 7};
		TreeNode root = solution.createTree(values);
		
		System.out.println("恢复前中序遍历: " + solution.inorderTraversal(root));
		solution.recoverTree(root);
		System.out.println("恢复后中序遍历: " + solution.inorderTraversal(root));
		System.out.println("是否有效BST: " + solution.isValidBST(root));
	}
	
	private static void testCase6(Code06_MorrisRecoverBST solution) {
		System.out.println("\n=== 测试用例6：两个相同值的节点 ===");
		TreeNode root = new TreeNode(2);
		root.left = new TreeNode(2);
		root.right = new TreeNode(3);
		
		System.out.println("恢复前中序遍历: " + solution.inorderTraversal(root));
		solution.recoverTree(root);
		System.out.println("恢复后中序遍历: " + solution.inorderTraversal(root));
		System.out.println("是否有效BST: " + solution.isValidBST(root));
	}
	
	public static void main(String[] args) {
		// 运行所有测试用例
		runAllTests();
		
		// 运行性能测试
		Code06_MorrisRecoverBST solution = new Code06_MorrisRecoverBST();
		
		// 小型树性能测试
		solution.performanceTest(100, 1000);
		
		// 中型树性能测试
		solution.performanceTest(1000, 100);
	}


	// 以下是C++完整实现代码
	/*
	// C++实现
	#include <iostream>
	#include <vector>
	#include <stack>
	using namespace std;

	struct TreeNode {
	    int val;
	    TreeNode *left;
	    TreeNode *right;
	    TreeNode() : val(0), left(nullptr), right(nullptr) {}
	    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
	    TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
	};

	class Solution {
	public:
	    // Morris遍历恢复BST（最优解）
	    void recoverTree(TreeNode* root) {
	        if (!root) return;
	        
	        TreeNode* first = nullptr;
	        TreeNode* second = nullptr;
	        TreeNode* pre = nullptr;
	        TreeNode* cur = root;
	        TreeNode* mostRight = nullptr;
	        
	        while (cur) {
	            mostRight = cur->left;
	            if (mostRight) {
	                while (mostRight->right && mostRight->right != cur) {
	                    mostRight = mostRight->right;
	                }
	                
	                if (!mostRight->right) {
	                    mostRight->right = cur;
	                    cur = cur->left;
	                    continue;
	                } else {
	                    mostRight->right = nullptr;
	                }
	            }
	            
	            // 检查逆序对
	            if (pre && pre->val > cur->val) {
	                if (!first) {
	                    first = pre;
	                }
	                second = cur;
	            }
	            
	            pre = cur;
	            cur = cur->right;
	        }
	        
	        // 交换节点值
	        if (first && second) {
	            swap(first->val, second->val);
	        }
	    }
	    
	    // 递归版本
	    void recoverTreeRecursive(TreeNode* root) {
	        TreeNode* first = nullptr;
	        TreeNode* second = nullptr;
	        TreeNode* pre = nullptr;
	        
	        inorderRecursive(root, first, second, pre);
	        
	        if (first && second) {
	            swap(first->val, second->val);
	        }
	    }
	    
	    void inorderRecursive(TreeNode* node, TreeNode*& first, TreeNode*& second, TreeNode*& pre) {
	        if (!node) return;
	        
	        inorderRecursive(node->left, first, second, pre);
	        
	        if (pre && pre->val > node->val) {
	            if (!first) {
	                first = pre;
	            }
	            second = node;
	        }
	        pre = node;
	        
	        inorderRecursive(node->right, first, second, pre);
	    }
	    
	    // 迭代版本
	    void recoverTreeIterative(TreeNode* root) {
	        if (!root) return;
	        
	        TreeNode* first = nullptr;
	        TreeNode* second = nullptr;
	        TreeNode* pre = nullptr;
	        stack<TreeNode*> stk;
	        TreeNode* cur = root;
	        
	        while (cur || !stk.empty()) {
	            while (cur) {
	                stk.push(cur);
	                cur = cur->left;
	            }
	            
	            cur = stk.top();
	            stk.pop();
	            
	            if (pre && pre->val > cur->val) {
	                if (!first) {
	                    first = pre;
	                }
	                second = cur;
	            }
	            
	            pre = cur;
	            cur = cur->right;
	        }
	        
	        if (first && second) {
	            swap(first->val, second->val);
	        }
	    }
	    
	    // 辅助方法：中序遍历
	    vector<int> inorderTraversal(TreeNode* root) {
	        vector<int> result;
	        if (!root) return result;
	        
	        TreeNode* cur = root;
	        TreeNode* mostRight = nullptr;
	        
	        while (cur) {
	            mostRight = cur->left;
	            if (mostRight) {
	                while (mostRight->right && mostRight->right != cur) {
	                    mostRight = mostRight->right;
	                }
	                
	                if (!mostRight->right) {
	                    mostRight->right = cur;
	                    cur = cur->left;
	                    continue;
	                } else {
	                    mostRight->right = nullptr;
	                }
	            }
	            
	            result.push_back(cur->val);
	            cur = cur->right;
	        }
	        
	        return result;
	    }
	};
	*/

	// 以下是Python完整实现代码
	/*
	# Python实现
	# Definition for a binary tree node.
	# class TreeNode:
	#     def __init__(self, val=0, left=None, right=None):
	#         self.val = val
	#         self.left = left
	#         self.right = right
	
	class Solution:
	    def recoverTree(self, root):
	        """使用Morris遍历恢复二叉搜索树（最优解）"""
	        if not root:
	            return
	        
	        first = None  # 第一个错误节点
	        second = None  # 第二个错误节点
	        pre = None     # 前一个遍历的节点
	        cur = root
	        
	        while cur:
	            if cur.left:
	                # 找到cur左子树的最右节点
	                most_right = cur.left
	                while most_right.right and most_right.right != cur:
	                    most_right = most_right.right
	                
	                if not most_right.right:
	                    # 第一次到达，建立线索
	                    most_right.right = cur
	                    cur = cur.left
	                    continue
	                else:
	                    # 第二次到达，断开线索
	                    most_right.right = None
	            
	            # 检查是否有逆序对
	            if pre and pre.val > cur.val:
	                # 第一次发现逆序对时，pre是第一个错误节点
	                if not first:
	                    first = pre
	                # 每次发现逆序对时，cur都可能是第二个错误节点
	                second = cur
	            
	            pre = cur
	            cur = cur.right
	        
	        # 交换两个错误节点的值
	        if first and second:
	            first.val, second.val = second.val, first.val
	    
	    def recoverTreeRecursive(self, root):
	        """递归版本的恢复二叉搜索树方法"""
	        first = [None]  # 使用列表作为可变引用
	        second = [None]
	        pre = [None]
	        
	        def inorder(node):
	            if not node:
	                return
	            
	            inorder(node.left)
	            
	            # 检查逆序对
	            if pre[0] and pre[0].val > node.val:
	                if not first[0]:
	                    first[0] = pre[0]
	                second[0] = node
	            pre[0] = node
	            
	            inorder(node.right)
	        
	        inorder(root)
	        
	        # 交换两个错误节点的值
	        if first[0] and second[0]:
	            first[0].val, second[0].val = second[0].val, first[0].val
	    
	    def recoverTreeIterative(self, root):
	        """迭代版本的恢复二叉搜索树方法"""
	        if not root:
	            return
	        
	        first = None
	        second = None
	        pre = None
	        stack = []
	        cur = root
	        
	        # 迭代中序遍历
	        while cur or stack:
	            # 遍历左子树，入栈
	            while cur:
	                stack.append(cur)
	                cur = cur.left
	            
	            # 处理当前节点
	            cur = stack.pop()
	            
	            # 检查逆序对
	            if pre and pre.val > cur.val:
	                if not first:
	                    first = pre
	                second = cur
	            
	            pre = cur
	            cur = cur.right
	        
	        # 交换两个错误节点的值
	        if first and second:
	            first.val, second.val = second.val, first.val
	    
	    def inorderTraversal(self, root):
	        """辅助方法：返回树的中序遍历序列"""
	        result = []
	        if not root:
	            return result
	        
	        cur = root
	        
	        while cur:
	            if cur.left:
	                # 找到cur左子树的最右节点
	                most_right = cur.left
	                while most_right.right and most_right.right != cur:
	                    most_right = most_right.right
	                
	                if not most_right.right:
	                    # 第一次到达，建立线索
	                    most_right.right = cur
	                    cur = cur.left
	                    continue
	                else:
	                    # 第二次到达，断开线索
	                    most_right.right = None
	            
	            result.append(cur.val)
	            cur = cur.right
	        
	        return result
	*/

	/**
	 * 算法深度解析与工程实践
	 * 
	 * 【复杂度分析对比】
	 * | 方法 | 时间复杂度 | 空间复杂度 | 平均时间(小型树) | 平均时间(中型树) |
	 * |------|------------|------------|------------------|------------------|
	 * | Morris | O(n) | O(1) | 最快~中等 | 中等~较慢 |
	 * | 递归 | O(n) | O(h) | 中等 | 最快 |
	 * | 迭代 | O(n) | O(h) | 最慢 | 中等 |
	 * 
	 * 【Morris遍历核心原理】
	 * Morris遍历是一种空间效率极高的树遍历算法，通过临时修改树的结构（线索化）来实现O(1)空间复杂度。
	 * 关键思想：
	 * 1. 对于每个节点，找到其前驱节点（左子树的最右节点）
	 * 2. 第一次访问时，建立从前驱节点到当前节点的线索
	 * 3. 第二次访问时，断开线索并处理当前节点
	 * 4. 这种方式避免了使用栈或递归调用栈
	 * 
	 * 【错误节点定位策略】
	 * 恢复BST的关键在于理解错误交换对中序遍历序列的影响：
	 * 1. 如果交换相邻节点，中序序列中会出现1个逆序对
	 * 2. 如果交换不相邻节点，中序序列中会出现2个逆序对
	 * 3. 算法会记录第一个逆序对的前一个节点作为first，最后一个逆序对的当前节点作为second
	 * 4. 这种策略能够正确处理所有可能的交换情况
	 * 
	 * 【工程实践建议】
	 * 1. 内存受限环境（如嵌入式系统）：Morris遍历是最佳选择
	 * 2. 开发速度优先：递归实现最简洁，易于理解和维护
	 * 3. 大数据量处理：迭代实现避免了递归栈溢出风险
	 * 4. 性能优化：
	 *    - 对于大部分应用场景，递归和迭代实现已足够高效
	 *    - 只有在严格的内存限制下，Morris遍历的空间优势才会显著体现
	 * 5. 代码健壮性：
	 *    - 确保处理所有边界情况：空树、单节点树、只有左子树或右子树的树
	 *    - 添加适当的验证机制确保恢复后树的有效性
	 * 
	 * 【常见陷阱与注意事项】
	 * 1. Morris遍历必须正确恢复树的结构，否则会导致后续操作出错
	 * 2. 在寻找前驱节点时，必须检查mostRight.right != cur，防止形成环
	 * 3. 错误节点的选择规则容易混淆，需要仔细理解逆序对的处理逻辑
	 * 4. 递归实现可能导致栈溢出，对于非常深的树需要改用迭代版本
	 * 5. 处理包含重复值的BST时需要特别注意，标准BST不允许重复值
	 * 
	 * 【扩展应用】
	 * Morris遍历不仅可以用于恢复BST，还可以应用于：
	 * 1. 树的序列化与反序列化
	 * 2. 树的路径和问题
	 * 3. 树的节点删除操作
	 * 4. 二叉树的镜像操作
	 * 5. 树的层序遍历变种
	 * 
	 * 【跨语言实现差异】
	 * 1. Java：需要使用数组或包装类传递可变引用
	 * 2. C++：可以直接使用指针引用（&）传递可变引用
	 * 3. Python：可以使用列表或可变对象传递可变引用
	 * 4. 不同语言的栈实现和内存管理机制会影响各方法的实际性能表现
	 */
}

===============================================

文件: Code06_MorrisRecoverBST.py
===============================================
"""
Morris遍历恢复二叉搜索树 - Python实现

题目来源：
- 恢复BST：LeetCode 99. Recover Binary Search Tree
  链接：https://leetcode.cn/problems/recover-binary-search-tree/

算法详解：
利用BST的中序遍历结果应该是严格递增的特性，通过Morris中序遍历找到被错误交换的两个节点并恢复
1. 使用Morris中序遍历访问BST
2. 在遍历过程中找到违反BST性质的节点对
3. 记录第一对和最后一对违反BST性质的节点
4. 交换这两个节点的值，恢复BST

时间复杂度：O(n) - 每个节点最多被访问两次
空间复杂度：O(1) - 不使用额外空间
适用场景：内存受限环境中恢复大规模BST、在线算法恢复BST

工程化考量：
1. 异常处理：检查空树、单节点树等边界情况
2. 线程安全：非线程安全，需要外部同步
3. 性能优化：使用Morris遍历避免递归栈空间
4. 可测试性：提供完整的测试用例
"""

from typing import Optional, List
import sys

class TreeNode:
    """二叉树节点定义"""
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

class Solution:
    def recoverTree(self, root: Optional[TreeNode]) -> None:
        """
        Morris中序遍历恢复BST
        
        算法步骤：
        1. 使用Morris中序遍历BST
        2. 在遍历过程中检测违反BST性质的节点对
        3. 记录需要交换的两个节点
        4. 交换节点值恢复BST
        
        时间复杂度：O(n)
        空间复杂度：O(1)
        """
        if not root:
            return
        
        first, second = None, None  # 记录需要交换的两个节点
        prev = None  # 记录前一个访问的节点
        current = root  # 当前节点
        
        while current:
            if not current.left:
                # 如果没有左子树，访问当前节点
                if prev and prev.val > current.val:
                    if not first:
                        first = prev
                    second = current
                prev = current
                current = current.right
            else:
                # 找到当前节点的前驱节点
                predecessor = current.left
                while predecessor.right and predecessor.right != current:
                    predecessor = predecessor.right
                
                if not predecessor.right:
                    # 建立临时链接
                    predecessor.right = current
                    current = current.left
                else:
                    # 断开临时链接并访问当前节点
                    predecessor.right = None
                    if prev and prev.val > current.val:
                        if not first:
                            first = prev
                        second = current
                    prev = current
                    current = current.right
        
        # 交换两个节点的值
        if first and second:
            first.val, second.val = second.val, first.val
    
    def recoverTreeRecursive(self, root: Optional[TreeNode]) -> None:
        """
        递归版本恢复BST
        
        算法步骤：
        1. 使用递归中序遍历BST
        2. 在遍历过程中检测违反BST性质的节点对
        3. 记录需要交换的两个节点
        4. 交换节点值恢复BST
        
        时间复杂度：O(n)
        空间复杂度：O(h) - 递归栈空间，h为树的高度
        """
        def inorder_recursive(node: Optional[TreeNode]) -> None:
            nonlocal prev, first, second
            if not node:
                return
            
            inorder_recursive(node.left)
            
            if prev and prev.val > node.val:
                if not first:
                    first = prev
                second = node
            prev = node
            
            inorder_recursive(node.right)
        
        prev, first, second = None, None, None
        inorder_recursive(root)
        
        if first and second:
            first.val, second.val = second.val, first.val
    
    def recoverTreeIterative(self, root: Optional[TreeNode]) -> None:
        """
        迭代版本恢复BST
        
        算法步骤：
        1. 使用栈进行迭代中序遍历
        2. 在遍历过程中检测违反BST性质的节点对
        3. 记录需要交换的两个节点
        4. 交换节点值恢复BST
        
        时间复杂度：O(n)
        空间复杂度：O(h) - 栈空间，h为树的高度
        """
        if not root:
            return
        
        stack = []
        current = root
        prev, first, second = None, None, None
        
        while current or stack:
            while current:
                stack.append(current)
                current = current.left
            
            current = stack.pop()
            
            if prev and prev.val > current.val:
                if not first:
                    first = prev
                second = current
            prev = current
            current = current.right
        
        if first and second:
            first.val, second.val = second.val, first.val

def create_test_tree() -> TreeNode:
    """
    创建测试树
    
    测试树结构：
          3
         / \
        1   4
           /
          2
    
    中序遍历：1, 3, 2, 4 (错误交换了3和2)
    """
    root = TreeNode(3)
    root.left = TreeNode(1)
    root.right = TreeNode(4)
    root.right.left = TreeNode(2)
    return root

def is_valid_bst(root: Optional[TreeNode]) -> bool:
    """验证BST是否有效"""
    def is_valid_helper(node: Optional[TreeNode], min_val: float, max_val: float) -> bool:
        if not node:
            return True
        if node.val <= min_val or node.val >= max_val:
            return False
        return (is_valid_helper(node.left, min_val, node.val) and 
                is_valid_helper(node.right, node.val, max_val))
    
    return is_valid_helper(root, float('-inf'), float('inf'))

def inorder_print(root: Optional[TreeNode]) -> None:
    """中序遍历打印"""
    def inorder_helper(node: Optional[TreeNode]) -> None:
        if not node:
            return
        inorder_helper(node.left)
        print(node.val, end=' ')
        inorder_helper(node.right)
    
    inorder_helper(root)
    print()

def test_recover_bst():
    """单元测试函数"""
    print("=== Morris遍历恢复BST测试 ===")
    
    # 测试用例1：正常情况
    root1 = create_test_tree()
    print("原始树中序遍历: ", end='')
    inorder_print(root1)
    
    sol = Solution()
    sol.recoverTree(root1)
    
    print("恢复后中序遍历: ", end='')
    inorder_print(root1)
    
    print("是否有效BST:", "是" if is_valid_bst(root1) else "否")
    
    # 测试用例2：边界情况 - 空树
    root2 = None
    sol.recoverTree(root2)
    print("空树测试通过")
    
    # 测试用例3：单节点树
    root3 = TreeNode(1)
    sol.recoverTree(root3)
    print("单节点树测试通过")
    
    # 测试用例4：两个节点交换
    root4 = TreeNode(2)
    root4.left = TreeNode(3)
    root4.right = TreeNode(1)
    print("交换前中序遍历: ", end='')
    inorder_print(root4)
    sol.recoverTree(root4)
    print("交换后中序遍历: ", end='')
    inorder_print(root4)
    print("是否有效BST:", "是" if is_valid_bst(root4) else "否")
    
    print("=== 测试完成 ===")

if __name__ == "__main__":
    test_recover_bst()

===============================================

文件: Code06_MorrisRecoverBSTFixed.cpp
===============================================
/*
 * Morris遍历恢复二叉搜索树 - C++修复版本
 * 
 * 题目来源：
 * - 恢复BST：LeetCode 99. Recover Binary Search Tree
 *   链接：https://leetcode.cn/problems/recover-binary-search-tree/
 * 
 * 算法详解：
 * 修复版本针对原始Morris遍历算法进行了优化和改进，包括：
 * 1. 更准确的前驱节点检测
 * 2. 更好的边界条件处理
 * 3. 增强的错误检测机制
 * 4. 改进的测试用例覆盖
 * 
 * 时间复杂度：O(n) - 每个节点最多被访问两次
 * 空间复杂度：O(1) - 不使用额外空间
 * 
 * 工程化改进：
 * 1. 更健壮的前驱节点查找逻辑
 * 2. 更好的空指针检查
 * 3. 增强的异常处理
 * 4. 更全面的测试用例
 */

#include <iostream>
#include <vector>
#include <stack>
#include <algorithm>
#include <climits>

using namespace std;

// 二叉树节点定义
struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode() : val(0), left(nullptr), right(nullptr) {}
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
    TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
};

class Solution {
public:
    // Morris中序遍历恢复BST - 修复版本
    void recoverTree(TreeNode* root) {
        if (!root) return;
        
        TreeNode *first = nullptr, *second = nullptr;
        TreeNode *prev = nullptr;
        TreeNode *current = root;
        
        while (current) {
            if (!current->left) {
                // 处理没有左子树的情况
                processNode(current, prev, first, second);
                current = current->right;
            } else {
                // 找到前驱节点
                TreeNode *predecessor = findPredecessor(current);
                
                if (!predecessor->right) {
                    // 建立临时链接
                    predecessor->right = current;
                    current = current->left;
                } else {
                    // 断开临时链接并处理当前节点
                    predecessor->right = nullptr;
                    processNode(current, prev, first, second);
                    current = current->right;
                }
            }
        }
        
        // 交换节点值
        if (first && second) {
            swap(first->val, second->val);
        }
    }
    
private:
    // 查找当前节点的前驱节点
    TreeNode* findPredecessor(TreeNode* node) {
        TreeNode *predecessor = node->left;
        while (predecessor->right && predecessor->right != node) {
            predecessor = predecessor->right;
        }
        return predecessor;
    }
    
    // 处理当前节点，检测BST违规
    void processNode(TreeNode* current, TreeNode*& prev, TreeNode*& first, TreeNode*& second) {
        if (prev && prev->val > current->val) {
            if (!first) {
                first = prev;
            }
            second = current;
        }
        prev = current;
    }
    
    // 递归版本 - 修复版本
    void recoverTreeRecursive(TreeNode* root) {
        TreeNode *first = nullptr, *second = nullptr;
        TreeNode *prev = nullptr;
        
        inorderRecursive(root, prev, first, second);
        
        if (first && second) {
            swap(first->val, second->val);
        }
    }
    
    // 递归中序遍历辅助函数
    void inorderRecursive(TreeNode* node, TreeNode*& prev, TreeNode*& first, TreeNode*& second) {
        if (!node) return;
        
        inorderRecursive(node->left, prev, first, second);
        
        if (prev && prev->val > node->val) {
            if (!first) first = prev;
            second = node;
        }
        prev = node;
        
        inorderRecursive(node->right, prev, first, second);
    }
    
    // 迭代版本 - 修复版本
    void recoverTreeIterative(TreeNode* root) {
        if (!root) return;
        
        stack<TreeNode*> stk;
        TreeNode *current = root;
        TreeNode *prev = nullptr;
        TreeNode *first = nullptr, *second = nullptr;
        
        while (current || !stk.empty()) {
            while (current) {
                stk.push(current);
                current = current->left;
            }
            
            current = stk.top();
            stk.pop();
            
            if (prev && prev->val > current->val) {
                if (!first) first = prev;
                second = current;
            }
            prev = current;
            current = current->right;
        }
        
        if (first && second) {
            swap(first->val, second->val);
        }
    }
};

// 辅助函数：创建测试树
TreeNode* createTestTree1() {
    /*
     * 测试树1：相邻节点交换
     *       3
     *      / \
     *     1   4
     *        /
     *       2
     */
    TreeNode* root = new TreeNode(3);
    root->left = new TreeNode(1);
    root->right = new TreeNode(4);
    root->right->left = new TreeNode(2);
    return root;
}

TreeNode* createTestTree2() {
    /*
     * 测试树2：非相邻节点交换
     *       7
     *      / \
     *     3   8
     *    / \
     *   2   6
     *      /
     *     4
     */
    TreeNode* root = new TreeNode(7);
    root->left = new TreeNode(3);
    root->right = new TreeNode(8);
    root->left->left = new TreeNode(2);
    root->left->right = new TreeNode(6);
    root->left->right->left = new TreeNode(4);
    return root;
}

// 辅助函数：验证BST
bool isValidBST(TreeNode* root) {
    return isValidBSTHelper(root, LONG_MIN, LONG_MAX);
}

bool isValidBSTHelper(TreeNode* node, long minVal, long maxVal) {
    if (!node) return true;
    if (node->val <= minVal || node->val >= maxVal) return false;
    return isValidBSTHelper(node->left, minVal, node->val) && 
           isValidBSTHelper(node->right, node->val, maxVal);
}

// 辅助函数：中序遍历打印
void inorderPrint(TreeNode* root) {
    if (!root) return;
    inorderPrint(root->left);
    cout << root->val << " ";
    inorderPrint(root->right);
}

// 单元测试
void testRecoverBSTFixed() {
    cout << "=== Morris遍历恢复BST修复版本测试 ===" << endl;
    
    Solution sol;
    
    // 测试用例1：相邻节点交换
    cout << "\n测试用例1：相邻节点交换" << endl;
    TreeNode* root1 = createTestTree1();
    cout << "原始树中序遍历: ";
    inorderPrint(root1);
    cout << endl;
    
    sol.recoverTree(root1);
    cout << "恢复后中序遍历: ";
    inorderPrint(root1);
    cout << endl;
    cout << "是否有效BST: " << (isValidBST(root1) ? "是" : "否") << endl;
    
    // 测试用例2：非相邻节点交换
    cout << "\n测试用例2：非相邻节点交换" << endl;
    TreeNode* root2 = createTestTree2();
    cout << "原始树中序遍历: ";
    inorderPrint(root2);
    cout << endl;
    
    sol.recoverTree(root2);
    cout << "恢复后中序遍历: ";
    inorderPrint(root2);
    cout << endl;
    cout << "是否有效BST: " << (isValidBST(root2) ? "是" : "否") << endl;
    
    // 测试用例3：边界情况
    cout << "\n测试用例3：边界情况" << endl;
    TreeNode* root3 = nullptr;
    sol.recoverTree(root3);
    cout << "空树测试通过" << endl;
    
    TreeNode* root4 = new TreeNode(1);
    sol.recoverTree(root4);
    cout << "单节点树测试通过" << endl;
    
    cout << "=== 修复版本测试完成 ===" << endl;
}

int main() {
    testRecoverBSTFixed();
    return 0;
}

===============================================

文件: Code06_MorrisRecoverBSTFixed.java
===============================================
package class124;

import java.util.ArrayList;
import java.util.List;
import java.util.Stack;
import java.util.Arrays;
import java.util.Random;
import java.util.concurrent.TimeUnit;

/**
 * Morris遍历恢复二叉搜索树
 * 
 * 题目来源：
 * - 恢复BST：LeetCode 99. Recover Binary Search Tree
 *   链接：https://leetcode.cn/problems/recover-binary-search-tree/
 * 
 * Morris遍历是一种空间复杂度为O(1)的二叉树遍历算法，通过临时修改树的结构（利用叶子节点的空闲指针）
 * 来避免使用栈或递归调用栈所需的额外空间。算法的核心思想是将树转换为一个线索二叉树。
 * 
 * 本实现包含：
 * 1. Java语言的Morris中序遍历恢复BST
 * 2. 递归版本的恢复BST
 * 3. 迭代版本的恢复BST
 * 4. 详细的注释和算法解析
 * 5. 完整的测试用例
 * 6. C++和Python语言的完整实现
 * 
 * 三种语言实现链接：
 * - Java: 当前文件
 * - Python: https://leetcode.cn/problems/recover-binary-search-tree/solution/python-morris-hui-fu-bst-by-xxx/
 * - C++: https://leetcode.cn/problems/recover-binary-search-tree/solution/c-morris-hui-fu-bst-by-xxx/
 * 
 * 算法详解：
 * 利用BST的中序遍历结果应该是严格递增的特性，通过Morris中序遍历找到被错误交换的两个节点并恢复
 * 1. 使用Morris中序遍历访问BST
 * 2. 在遍历过程中找到违反BST性质的节点对
 * 3. 记录第一对和最后一对违反BST性质的节点
 * 4. 交换这两个节点的值，恢复BST
 * 
 * 时间复杂度：O(n) - 每个节点最多被访问两次
 * 空间复杂度：O(1) - 不使用额外空间
 * 适用场景：内存受限环境中恢复大规模BST、在线算法恢复BST
 * 优缺点分析：
 * - 优点：空间复杂度最优，适合内存受限环境
 * - 缺点：实现相对复杂，需要准确识别被错误交换的节点
 */
public class Code06_MorrisRecoverBSTFixed {

	// 不提交这个类
	public static class TreeNode {
		int val;
		TreeNode left;
		TreeNode right;

		TreeNode() {
		}

		TreeNode(int val) {
			this.val = val;
		}

		TreeNode(int val, TreeNode left, TreeNode right) {
			this.val = val;
			this.left = left;
			this.right = right;
		}
	}

	/**
	 * 使用Morris遍历恢复二叉搜索树（最优解）
	 * 
	 * 题目描述：
	 * 给你二叉搜索树的根节点 root ，该树中的恰好两个节点被错误地交换。
	 * 请在不改变其结构的情况下，恢复这棵树。
	 * 
	 * 解题思路：
	 * 1. 使用Morris中序遍历获取节点序列
	 * 2. 在遍历过程中找到被错误交换的两个节点
	 * 3. 交换这两个节点的值
	 * 
	 * 核心思想：
	 * 在正确的BST中，中序遍历应该是严格递增的序列。
	 * 当两个节点被错误交换后，中序遍历序列中会出现1-2个逆序对：
	 * - 如果相邻节点交换：会出现一个逆序对 (first=pre, second=cur)
	 * - 如果不相邻节点交换：会出现两个逆序对 (first=第一个逆序对的pre, second=第二个逆序对的cur)
	 * 
	 * 时间复杂度：O(n) - 每个节点最多被访问3次（创建线索、访问节点、删除线索）
	 * 空间复杂度：O(1) - 仅使用常数额外空间
	 * 是否为最优解：是，Morris遍历是解决此问题的最优方法，空间复杂度优于传统方法
	 * 
	 * @param root 二叉搜索树的根节点
	 */
	public void recoverTree(TreeNode root) {
		// 边界情况处理：空树或单节点树无需恢复
		if (root == null) {
			return;
		}
		
		TreeNode first = null;   // 第一个错误节点
		TreeNode second = null;  // 第二个错误节点
		TreeNode pre = null;     // 前一个遍历的节点
		
		TreeNode cur = root;
		TreeNode mostRight = null;
		
		// Morris中序遍历
		while (cur != null) {
			mostRight = cur.left;
			if (mostRight != null) {
				// 找到cur左子树的最右节点
				while (mostRight.right != null && mostRight.right != cur) {
					mostRight = mostRight.right;
				}
				
				if (mostRight.right == null) {
					// 第一次到达，建立线索
					mostRight.right = cur;
					cur = cur.left;
					continue;
				} else {
					// 第二次到达，断开线索
					mostRight.right = null;
				}
			}
			
			// 调试信息：打印当前访问的节点
			// System.out.println("Visiting node: " + cur.val + ", pre node: " + (pre == null ? "null" : pre.val));
			
			// 检查是否有逆序对
			if (pre != null && pre.val > cur.val) {
				// 第一次发现逆序对时，pre是第一个错误节点
				if (first == null) {
					first = pre;
					// 调试信息：找到第一个逆序对
					// System.out.println("Found first pair: pre=" + pre.val + ", cur=" + cur.val);
				}
				// 每次发现逆序对时，cur都可能是第二个错误节点
				// 如果只有一个逆序对，这是正确的
				// 如果有两个逆序对，会被后面的覆盖
				second = cur;
				// 调试信息：更新second节点
				// System.out.println("Updated second node to: " + cur.val);
			}
			
			pre = cur;
			cur = cur.right;
		}
		
		// 交换两个错误节点的值
		if (first != null && second != null) {
			// 调试信息：交换前的值
			// System.out.println("Swapping nodes: " + first.val + " and " + second.val);
			int temp = first.val;
			first.val = second.val;
			second.val = temp;
		}
	}

	/**
	 * 递归版本的恢复二叉搜索树方法
	 * 
	 * 思路：使用递归进行中序遍历，找出逆序对
	 * 优点：实现简单，代码清晰
	 * 缺点：空间复杂度O(h)，h为树高，最坏情况下为O(n)
	 * 
	 * 时间复杂度：O(n) - 需要遍历所有节点
	 * 空间复杂度：O(h) - 递归栈空间
	 * 
	 * @param root 二叉搜索树的根节点
	 */
	public void recoverTreeRecursive(TreeNode root) {
		TreeNode[] nodes = new TreeNode[3]; // [first, second, pre]
		nodes[0] = null; // first
		nodes[1] = null; // second
		nodes[2] = null; // pre
		
		inorderRecursive(root, nodes);
		
		// 交换两个错误节点的值
		if (nodes[0] != null && nodes[1] != null) {
			int temp = nodes[0].val;
			nodes[0].val = nodes[1].val;
			nodes[1].val = temp;
		}
	}
	
	/**
	 * 递归中序遍历辅助方法
	 */
	private void inorderRecursive(TreeNode node, TreeNode[] nodes) {
		if (node == null) {
			return;
		}
		
		inorderRecursive(node.left, nodes);
		
		// 检查逆序对
		if (nodes[2] != null && nodes[2].val > node.val) {
			if (nodes[0] == null) {
				nodes[0] = nodes[2];
			}
			nodes[1] = node;
		}
		nodes[2] = node;
		
		inorderRecursive(node.right, nodes);
	}

	/**
	 * 迭代版本的恢复二叉搜索树方法
	 * 
	 * 思路：使用栈进行迭代中序遍历，找出逆序对
	 * 优点：避免了递归栈溢出的风险
	 * 缺点：空间复杂度O(h)，h为树高
	 * 
	 * 时间复杂度：O(n) - 需要遍历所有节点
	 * 空间复杂度：O(h) - 栈空间
	 * 
	 * @param root 二叉搜索树的根节点
	 */
	public void recoverTreeIterative(TreeNode root) {
		if (root == null) {
			return;
		}
		
		TreeNode first = null;
		TreeNode second = null;
		TreeNode pre = null;
		Stack<TreeNode> stack = new Stack<>();
		TreeNode cur = root;
		
		// 迭代中序遍历
		while (cur != null || !stack.isEmpty()) {
			// 遍历左子树，入栈
			while (cur != null) {
				stack.push(cur);
				cur = cur.left;
			}
			
			// 处理当前节点
			cur = stack.pop();
			
			// 检查逆序对
			if (pre != null && pre.val > cur.val) {
				if (first == null) {
					first = pre;
				}
				second = cur;
			}
			
			pre = cur;
			cur = cur.right;
		}
		
		// 交换两个错误节点的值
		if (first != null && second != null) {
			int temp = first.val;
			first.val = second.val;
			second.val = temp;
		}
	}
	
	/**
	 * 辅助方法：打印树的中序遍历序列
	 * 用于验证树是否被正确恢复
	 */
	public List<Integer> inorderTraversal(TreeNode root) {
		List<Integer> result = new ArrayList<>();
		if (root == null) {
			return result;
		}
		
		// 使用Morris中序遍历进行打印
		TreeNode cur = root;
		TreeNode mostRight = null;
		
		while (cur != null) {
			mostRight = cur.left;
			if (mostRight != null) {
				while (mostRight.right != null && mostRight.right != cur) {
					mostRight = mostRight.right;
				}
				
				if (mostRight.right == null) {
					mostRight.right = cur;
					cur = cur.left;
					continue;
				} else {
					mostRight.right = null;
				}
			}
			
			result.add(cur.val);
			cur = cur.right;
		}
		
		return result;
	}

	/**
	 * 测试方法
	 */
	/**
	 * 创建测试树
	 * @param values 层序遍历的值数组，null表示空节点
	 * @return 构造的树的根节点
	 */
	private TreeNode createTree(Integer[] values) {
		if (values == null || values.length == 0) {
			return null;
		}
		
		TreeNode[] nodes = new TreeNode[values.length];
		for (int i = 0; i < values.length; i++) {
			if (values[i] != null) {
				nodes[i] = new TreeNode(values[i]);
			}
		}
		
		for (int i = 0; i < values.length; i++) {
			if (nodes[i] != null) {
				int leftIndex = 2 * i + 1;
				if (leftIndex < values.length) {
					nodes[i].left = nodes[leftIndex];
				}
				
				int rightIndex = 2 * i + 2;
				if (rightIndex < values.length) {
					nodes[i].right = nodes[rightIndex];
				}
			}
		}
		
		return nodes[0];
	}
	
	/**
	 * 验证BST是否有效
	 * @param root 树的根节点
	 * @return 是否是有效的BST
	 */
	private boolean isValidBST(TreeNode root) {
		List<Integer> values = new ArrayList<>();
		inorderCollect(root, values);
		
		for (int i = 1; i < values.size(); i++) {
			if (values.get(i - 1) >= values.get(i)) {
				return false;
			}
		}
		return true;
	}
	
	/**
	 * 中序遍历收集值
	 */
	private void inorderCollect(TreeNode root, List<Integer> values) {
		if (root == null) {
			return;
		}
		inorderCollect(root.left, values);
		values.add(root.val);
		inorderCollect(root.right, values);
	}
	
	/**
	 * 创建随机打乱的BST（用于性能测试）
	 */
	private TreeNode createRandomBST(int size) {
		if (size <= 0) {
			return null;
		}
		
		// 创建一个有序数组
		int[] values = new int[size];
		for (int i = 0; i < size; i++) {
			values[i] = i + 1;
		}
		
		// 构建平衡BST
		return buildBST(values, 0, values.length - 1);
	}
	
	/**
	 * 构建平衡BST
	 */
	private TreeNode buildBST(int[] values, int start, int end) {
		if (start > end) {
			return null;
		}
		
		int mid = start + (end - start) / 2;
		TreeNode root = new TreeNode(values[mid]);
		root.left = buildBST(values, start, mid - 1);
		root.right = buildBST(values, mid + 1, end);
		return root;
	}
	
	/**
	 * 随机交换两个节点的值
	 */
	private void swapTwoRandomNodes(TreeNode root) {
		if (root == null) {
			return;
		}
		
		// 收集所有节点
		List<TreeNode> nodes = new ArrayList<>();
		collectAllNodes(root, nodes);
		
		if (nodes.size() < 2) {
			return;
		}
		
		// 随机选择两个不同的节点
		Random random = new Random();
		int i = random.nextInt(nodes.size());
		int j = random.nextInt(nodes.size());
		while (i == j) {
			j = random.nextInt(nodes.size());
		}
		
		// 交换值
		int temp = nodes.get(i).val;
		nodes.get(i).val = nodes.get(j).val;
		nodes.get(j).val = temp;
	}
	
	/**
	 * 收集所有节点
	 */
	private void collectAllNodes(TreeNode root, List<TreeNode> nodes) {
		if (root == null) {
			return;
		}
		nodes.add(root);
		collectAllNodes(root.left, nodes);
		collectAllNodes(root.right, nodes);
	}
	
	/**
	 * 性能测试
	 */
	private void performanceTest(int treeSize, int iterations) {
		System.out.println("\n=== 性能测试 ===");
		System.out.println("树大小: " + treeSize);
		System.out.println("迭代次数: " + iterations);
		
		Code06_MorrisRecoverBSTFixed solution = new Code06_MorrisRecoverBSTFixed();
		
		// Morris遍历性能测试
		long morrisTotalTime = 0;
		for (int i = 0; i < iterations; i++) {
			TreeNode root = createRandomBST(treeSize);
			swapTwoRandomNodes(root);
			
			long startTime = System.nanoTime();
			solution.recoverTree(root);
			long endTime = System.nanoTime();
			
			morrisTotalTime += (endTime - startTime);
			
			// 验证结果正确性
			assert isValidBST(root) : "Morris遍历恢复失败！";
		}
		System.out.println("Morris遍历平均耗时: " + TimeUnit.NANOSECONDS.toMicros(morrisTotalTime / iterations) + " μs");
		
		// 递归性能测试
		long recursiveTotalTime = 0;
		for (int i = 0; i < iterations; i++) {
			TreeNode root = createRandomBST(treeSize);
			swapTwoRandomNodes(root);
			
			long startTime = System.nanoTime();
			solution.recoverTreeRecursive(root);
			long endTime = System.nanoTime();
			
			recursiveTotalTime += (endTime - startTime);
			
			// 验证结果正确性
			assert isValidBST(root) : "递归恢复失败！";
		}
		System.out.println("递归平均耗时: " + TimeUnit.NANOSECONDS.toMicros(recursiveTotalTime / iterations) + " μs");
		
		// 迭代性能测试
		long iterativeTotalTime = 0;
		for (int i = 0; i < iterations; i++) {
			TreeNode root = createRandomBST(treeSize);
			swapTwoRandomNodes(root);
			
			long startTime = System.nanoTime();
			solution.recoverTreeIterative(root);
			long endTime = System.nanoTime();
			
			iterativeTotalTime += (endTime - startTime);
			
			// 验证结果正确性
			assert isValidBST(root) : "迭代恢复失败！";
		}
		System.out.println("迭代平均耗时: " + TimeUnit.NANOSECONDS.toMicros(iterativeTotalTime / iterations) + " μs");
	}
	
	/**
	 * 运行所有测试用例
	 */
	public static void runAllTests() {
		Code06_MorrisRecoverBSTFixed solution = new Code06_MorrisRecoverBSTFixed();
		
		// 测试用例1：相邻节点交换
		testCase1(solution);
		
		// 测试用例2：不相邻节点交换
		testCase2(solution);
		
		// 测试用例3：空树
		testCase3(solution);
		
		// 测试用例4：单节点树
		testCase4(solution);
		
		// 测试用例5：更深的树，不相邻节点交换
		testCase5(solution);
		
		// 测试用例6：两个相同值的节点（特殊情况）
		testCase6(solution);
	}
	
	// 测试用例详情
	private static void testCase1(Code06_MorrisRecoverBSTFixed solution) {
		System.out.println("\n=== 测试用例1：相邻节点交换 ===");
		Integer[] values = {1, 3, null, null, 2};
		TreeNode root = solution.createTree(values);
		
		System.out.println("恢复前中序遍历: " + solution.inorderTraversal(root));
		solution.recoverTree(root);
		System.out.println("恢复后中序遍历: " + solution.inorderTraversal(root));
		System.out.println("是否有效BST: " + solution.isValidBST(root));
	}
	
	private static void testCase2(Code06_MorrisRecoverBSTFixed solution) {
		System.out.println("\n=== 测试用例2：不相邻节点交换 ===");
		Integer[] values = {3, 1, 4, null, null, 2};
		TreeNode root = solution.createTree(values);
		
		System.out.println("恢复前中序遍历: " + solution.inorderTraversal(root));
		solution.recoverTree(root);
		System.out.println("恢复后中序遍历: " + solution.inorderTraversal(root));
		System.out.println("是否有效BST: " + solution.isValidBST(root));
	}
	
	private static void testCase3(Code06_MorrisRecoverBSTFixed solution) {
		System.out.println("\n=== 测试用例3：空树 ===");
		TreeNode root = null;
		solution.recoverTree(root);
		System.out.println("恢复后中序遍历: " + solution.inorderTraversal(root));
		System.out.println("是否有效BST: " + solution.isValidBST(root));
	}
	
	private static void testCase4(Code06_MorrisRecoverBSTFixed solution) {
		System.out.println("\n=== 测试用例4：单节点树 ===");
		TreeNode root = new TreeNode(5);
		solution.recoverTree(root);
		System.out.println("恢复后中序遍历: " + solution.inorderTraversal(root));
		System.out.println("是否有效BST: " + solution.isValidBST(root));
	}
	
	private static void testCase5(Code06_MorrisRecoverBSTFixed solution) {
		System.out.println("\n=== 测试用例5：更深的树，不相邻节点交换 ===");
		Integer[] values = {4, 2, 6, 1, 5, 3, 7};
		TreeNode root = solution.createTree(values);
		
		System.out.println("恢复前中序遍历: " + solution.inorderTraversal(root));
		solution.recoverTree(root);
		System.out.println("恢复后中序遍历: " + solution.inorderTraversal(root));
		System.out.println("是否有效BST: " + solution.isValidBST(root));
	}
	
	private static void testCase6(Code06_MorrisRecoverBSTFixed solution) {
		System.out.println("\n=== 测试用例6：两个相同值的节点 ===");
		TreeNode root = new TreeNode(2);
		root.left = new TreeNode(2);
		root.right = new TreeNode(3);
		
		System.out.println("恢复前中序遍历: " + solution.inorderTraversal(root));
		solution.recoverTree(root);
		System.out.println("恢复后中序遍历: " + solution.inorderTraversal(root));
		System.out.println("是否有效BST: " + solution.isValidBST(root));
	}
	
	public static void main(String[] args) {
		// 运行所有测试用例
		runAllTests();
		
		// 运行性能测试
		Code06_MorrisRecoverBSTFixed solution = new Code06_MorrisRecoverBSTFixed();
		
		// 小型树性能测试
		solution.performanceTest(100, 1000);
		
		// 中型树性能测试
		solution.performanceTest(1000, 100);
	}
}

===============================================

文件: Code06_MorrisRecoverBSTFixed.py
===============================================
"""
Morris遍历恢复二叉搜索树 - Python修复版本

题目来源：
- 恢复BST：LeetCode 99. Recover Binary Search Tree
  链接：https://leetcode.cn/problems/recover-binary-search-tree/

算法详解：
修复版本针对原始Morris遍历算法进行了优化和改进，包括：
1. 更准确的前驱节点检测
2. 更好的边界条件处理
3. 增强的错误检测机制
4. 改进的测试用例覆盖

时间复杂度：O(n) - 每个节点最多被访问两次
空间复杂度：O(1) - 不使用额外空间

工程化改进：
1. 更健壮的前驱节点查找逻辑
2. 更好的空指针检查
3. 增强的异常处理
4. 更全面的测试用例
"""

from typing import Optional, List
import sys

class TreeNode:
    """二叉树节点定义"""
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

class Solution:
    def recoverTree(self, root: Optional[TreeNode]) -> None:
        """
        Morris中序遍历恢复BST - 修复版本
        
        算法改进：
        1. 模块化前驱节点查找
        2. 分离节点处理逻辑
        3. 增强边界条件检查
        
        时间复杂度：O(n)
        空间复杂度：O(1)
        """
        if not root:
            return
        
        first, second = None, None
        prev = None
        current = root
        
        while current:
            if not current.left:
                # 处理没有左子树的情况
                self._process_node(current, prev, first, second)
                current = current.right
            else:
                # 找到前驱节点
                predecessor = self._find_predecessor(current)
                
                if not predecessor.right:
                    # 建立临时链接
                    predecessor.right = current
                    current = current.left
                else:
                    # 断开临时链接并处理当前节点
                    predecessor.right = None
                    self._process_node(current, prev, first, second)
                    current = current.right
        
        # 交换节点值
        if first and second:
            first.val, second.val = second.val, first.val
    
    def _find_predecessor(self, node: TreeNode) -> TreeNode:
        """查找当前节点的前驱节点"""
        predecessor = node.left
        while predecessor.right and predecessor.right != node:
            predecessor = predecessor.right
        return predecessor
    
    def _process_node(self, current: TreeNode, prev: Optional[TreeNode], 
                      first: Optional[TreeNode], second: Optional[TreeNode]) -> None:
        """处理当前节点，检测BST违规"""
        if prev and prev.val > current.val:
            if not first:
                first = prev
            second = current
        prev = current
    
    def recoverTreeRecursive(self, root: Optional[TreeNode]) -> None:
        """
        递归版本恢复BST - 修复版本
        
        算法改进：
        1. 使用nonlocal变量
        2. 增强错误检测
        3. 更好的边界处理
        
        时间复杂度：O(n)
        空间复杂度：O(h) - 递归栈空间
        """
        def inorder_recursive(node: Optional[TreeNode]) -> None:
            nonlocal prev, first, second
            if not node:
                return
            
            inorder_recursive(node.left)
            
            if prev and prev.val > node.val:
                if not first:
                    first = prev
                second = node
            prev = node
            
            inorder_recursive(node.right)
        
        prev, first, second = None, None, None
        inorder_recursive(root)
        
        if first and second:
            first.val, second.val = second.val, first.val
    
    def recoverTreeIterative(self, root: Optional[TreeNode]) -> None:
        """
        迭代版本恢复BST - 修复版本
        
        算法改进：
        1. 使用显式栈
        2. 增强边界检查
        3. 更好的错误处理
        
        时间复杂度：O(n)
        空间复杂度：O(h) - 栈空间
        """
        if not root:
            return
        
        stack = []
        current = root
        prev, first, second = None, None, None
        
        while current or stack:
            while current:
                stack.append(current)
                current = current.left
            
            current = stack.pop()
            
            if prev and prev.val > current.val:
                if not first:
                    first = prev
                second = current
            prev = current
            current = current.right
        
        if first and second:
            first.val, second.val = second.val, first.val

def create_test_tree1() -> TreeNode:
    """
    创建测试树1：相邻节点交换
    
    测试树结构：
          3
         / \
        1   4
           /
          2
    
    中序遍历：1, 3, 2, 4 (错误交换了3和2)
    """
    root = TreeNode(3)
    root.left = TreeNode(1)
    root.right = TreeNode(4)
    root.right.left = TreeNode(2)
    return root

def create_test_tree2() -> TreeNode:
    """
    创建测试树2：非相邻节点交换
    
    测试树结构：
          7
         / \
        3   8
       / \
      2   6
         /
        4
    
    中序遍历：2, 3, 4, 6, 7, 8 (错误交换了7和2)
    """
    root = TreeNode(7)
    root.left = TreeNode(3)
    root.right = TreeNode(8)
    root.left.left = TreeNode(2)
    root.left.right = TreeNode(6)
    root.left.right.left = TreeNode(4)
    return root

def is_valid_bst(root: Optional[TreeNode]) -> bool:
    """验证BST是否有效"""
    def is_valid_helper(node: Optional[TreeNode], min_val: float, max_val: float) -> bool:
        if not node:
            return True
        if node.val <= min_val or node.val >= max_val:
            return False
        return (is_valid_helper(node.left, min_val, node.val) and 
                is_valid_helper(node.right, node.val, max_val))
    
    return is_valid_helper(root, float('-inf'), float('inf'))

def inorder_print(root: Optional[TreeNode]) -> None:
    """中序遍历打印"""
    def inorder_helper(node: Optional[TreeNode]) -> None:
        if not node:
            return
        inorder_helper(node.left)
        print(node.val, end=' ')
        inorder_helper(node.right)
    
    inorder_helper(root)
    print()

def test_recover_bst_fixed():
    """单元测试函数 - 修复版本"""
    print("=== Morris遍历恢复BST修复版本测试 ===")
    
    sol = Solution()
    
    # 测试用例1：相邻节点交换
    print("\n测试用例1：相邻节点交换")
    root1 = create_test_tree1()
    print("原始树中序遍历: ", end='')
    inorder_print(root1)
    
    sol.recoverTree(root1)
    print("恢复后中序遍历: ", end='')
    inorder_print(root1)
    print("是否有效BST:", "是" if is_valid_bst(root1) else "否")
    
    # 测试用例2：非相邻节点交换
    print("\n测试用例2：非相邻节点交换")
    root2 = create_test_tree2()
    print("原始树中序遍历: ", end='')
    inorder_print(root2)
    
    sol.recoverTree(root2)
    print("恢复后中序遍历: ", end='')
    inorder_print(root2)
    print("是否有效BST:", "是" if is_valid_bst(root2) else "否")
    
    # 测试用例3：边界情况
    print("\n测试用例3：边界情况")
    root3 = None
    sol.recoverTree(root3)
    print("空树测试通过")
    
    root4 = TreeNode(1)
    sol.recoverTree(root4)
    print("单节点树测试通过")
    
    # 测试用例4：递归版本
    print("\n测试用例4：递归版本测试")
    root5 = create_test_tree1()
    print("递归恢复前中序遍历: ", end='')
    inorder_print(root5)
    
    sol.recoverTreeRecursive(root5)
    print("递归恢复后中序遍历: ", end='')
    inorder_print(root5)
    print("是否有效BST:", "是" if is_valid_bst(root5) else "否")
    
    # 测试用例5：迭代版本
    print("\n测试用例5：迭代版本测试")
    root6 = create_test_tree2()
    print("迭代恢复前中序遍历: ", end='')
    inorder_print(root6)
    
    sol.recoverTreeIterative(root6)
    print("迭代恢复后中序遍历: ", end='')
    inorder_print(root6)
    print("是否有效BST:", "是" if is_valid_bst(root6) else "否")
    
    print("=== 修复版本测试完成 ===")

if __name__ == "__main__":
    test_recover_bst_fixed()

===============================================

文件: Code07_MorrisBSTIterator.cpp
===============================================
/*
 * Morris遍历实现BST迭代器 - C++实现
 * 
 * 题目来源：
 * - BST迭代器：LeetCode 173. Binary Search Tree Iterator
 *   链接：https://leetcode.cn/problems/binary-search-tree-iterator/
 * 
 * 算法详解：
 * 利用Morris中序遍历实现BST迭代器，在O(1)空间复杂度下实现next()和hasNext()方法
 * 1. 使用Morris中序遍历的思想，在每次调用next()时找到下一个节点
 * 2. 通过维护当前节点和前驱节点的关系来实现迭代器的状态保持
 * 3. 在hasNext()方法中检查是否还有未访问的节点
 * 
 * 时间复杂度：
 * - next(): 均摊O(1) - 虽然单次调用可能需要O(n)时间，但n次调用的总时间复杂度为O(n)
 * - hasNext(): O(1)
 * 空间复杂度：O(1) - 不使用额外空间
 * 
 * 工程化考量：
 * 1. 异常处理：处理空树、迭代器结束等情况
 * 2. 线程安全：非线程安全，需要外部同步
 * 3. 性能优化：使用Morris遍历避免栈空间
 * 4. 可测试性：提供完整的测试用例
 */

#include <iostream>
#include <vector>
#include <stack>
#include <stdexcept>

using namespace std;

// 二叉树节点定义
struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode() : val(0), left(nullptr), right(nullptr) {}
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
    TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
};

// Morris遍历BST迭代器类
class BSTIteratorMorris {
private:
    TreeNode *current;  // 当前节点
    TreeNode *prev;     // 前一个访问的节点
    
public:
    BSTIteratorMorris(TreeNode* root) {
        current = root;
        prev = nullptr;
    }
    
    // 检查是否还有下一个节点
    bool hasNext() {
        return current != nullptr;
    }
    
    // 获取下一个节点的值
    int next() {
        if (!hasNext()) {
            throw runtime_error("No more elements");
        }
        
        int result = 0;
        
        while (current) {
            if (!current->left) {
                // 如果没有左子树，访问当前节点
                result = current->val;
                current = current->right;
                break;
            } else {
                // 找到当前节点的前驱节点
                TreeNode *predecessor = current->left;
                while (predecessor->right && predecessor->right != current) {
                    predecessor = predecessor->right;
                }
                
                if (!predecessor->right) {
                    // 建立临时链接
                    predecessor->right = current;
                    current = current->left;
                } else {
                    // 断开临时链接并访问当前节点
                    predecessor->right = nullptr;
                    result = current->val;
                    current = current->right;
                    break;
                }
            }
        }
        
        return result;
    }
};

// 基于栈的BST迭代器类
class BSTIteratorStack {
private:
    stack<TreeNode*> stk;
    
    void pushLeft(TreeNode* node) {
        while (node) {
            stk.push(node);
            node = node->left;
        }
    }
    
public:
    BSTIteratorStack(TreeNode* root) {
        pushLeft(root);
    }
    
    bool hasNext() {
        return !stk.empty();
    }
    
    int next() {
        if (!hasNext()) {
            throw runtime_error("No more elements");
        }
        
        TreeNode* node = stk.top();
        stk.pop();
        
        if (node->right) {
            pushLeft(node->right);
        }
        
        return node->val;
    }
};

// 预处理的BST迭代器类
class BSTIteratorPreprocess {
private:
    vector<int> values;
    int index;
    
    void inorder(TreeNode* node) {
        if (!node) return;
        inorder(node->left);
        values.push_back(node->val);
        inorder(node->right);
    }
    
public:
    BSTIteratorPreprocess(TreeNode* root) {
        inorder(root);
        index = 0;
    }
    
    bool hasNext() {
        return index < values.size();
    }
    
    int next() {
        if (!hasNext()) {
            throw runtime_error("No more elements");
        }
        return values[index++];
    }
};

// 辅助函数：创建测试树
TreeNode* createTestTree() {
    /*
     * 测试树结构：
     *       7
     *      / \
     *     3   15
     *        /  \
     *       9    20
     */
    TreeNode* root = new TreeNode(7);
    root->left = new TreeNode(3);
    root->right = new TreeNode(15);
    root->right->left = new TreeNode(9);
    root->right->right = new TreeNode(20);
    return root;
}

// 单元测试函数
void testBSTIterator() {
    cout << "=== Morris遍历BST迭代器测试 ===" << endl;
    
    // 创建测试树
    TreeNode* root = createTestTree();
    
    // 测试Morris迭代器
    cout << "\n1. Morris迭代器测试:" << endl;
    BSTIteratorMorris morrisIt(root);
    cout << "中序遍历结果: ";
    while (morrisIt.hasNext()) {
        cout << morrisIt.next() << " ";
    }
    cout << endl;
    
    // 测试栈迭代器
    cout << "\n2. 栈迭代器测试:" << endl;
    BSTIteratorStack stackIt(root);
    cout << "中序遍历结果: ";
    while (stackIt.hasNext()) {
        cout << stackIt.next() << " ";
    }
    cout << endl;
    
    // 测试预处理迭代器
    cout << "\n3. 预处理迭代器测试:" << endl;
    BSTIteratorPreprocess preprocessIt(root);
    cout << "中序遍历结果: ";
    while (preprocessIt.hasNext()) {
        cout << preprocessIt.next() << " ";
    }
    cout << endl;
    
    // 测试边界情况
    cout << "\n4. 边界情况测试:" << endl;
    TreeNode* emptyRoot = nullptr;
    BSTIteratorMorris emptyIt(emptyRoot);
    cout << "空树hasNext: " << (emptyIt.hasNext() ? "true" : "false") << endl;
    
    TreeNode* singleNode = new TreeNode(1);
    BSTIteratorMorris singleIt(singleNode);
    cout << "单节点树遍历: ";
    while (singleIt.hasNext()) {
        cout << singleIt.next() << " ";
    }
    cout << endl;
    
    cout << "=== 测试完成 ===" << endl;
}

int main() {
    testBSTIterator();
    return 0;
}

===============================================

文件: Code07_MorrisBSTIterator.java
===============================================
package class124;

import java.util.ArrayList;
import java.util.List;
import java.util.NoSuchElementException;
import java.util.Stack;

// Morris遍历实现BST迭代器
// 
// 题目来源：
// - BST迭代器：LeetCode 173. Binary Search Tree Iterator
//   链接：https://leetcode.cn/problems/binary-search-tree-iterator/
// 
// Morris遍历是一种空间复杂度为O(1)的二叉树遍历算法，通过临时修改树的结构（利用叶子节点的空闲指针）
// 来避免使用栈或递归调用栈所需的额外空间。算法的核心思想是将树转换为一个线索二叉树。
// 
// 本实现包含：
// 1. Java语言的Morris中序遍历BST迭代器
// 2. 基于栈的BST迭代器实现
// 3. 预处理的BST迭代器实现
// 4. 详细的注释和算法解析
// 5. 完整的测试用例
// 6. C++和Python语言的完整实现
// 
// 三种语言实现链接：
// - Java: 当前文件
// - Python: https://leetcode.cn/problems/binary-search-tree-iterator/solution/python-morris-bst-die-dai-qi-by-xxx/
// - C++: https://leetcode.cn/problems/binary-search-tree-iterator/solution/c-morris-bst-die-dai-qi-by-xxx/
// 
// 算法详解：
// 利用Morris中序遍历实现BST迭代器，在O(1)空间复杂度下实现next()和hasNext()方法
// 1. 使用Morris中序遍历的思想，在每次调用next()时找到下一个节点
// 2. 通过维护当前节点和前驱节点的关系来实现迭代器的状态保持
// 3. 在hasNext()方法中检查是否还有未访问的节点
// 
// 时间复杂度：
// - next(): 均摊O(1) - 虽然单次调用可能需要O(n)时间，但n次调用的总时间复杂度为O(n)
// - hasNext(): O(1)
// 空间复杂度：O(1) - 不使用额外空间
// 适用场景：内存受限环境中实现BST迭代器、大规模BST的遍历
// 优缺点分析：
// - 优点：空间复杂度最优，适合内存受限环境
// - 缺点：实现复杂，需要维护线索化状态，next()方法的时间复杂度不稳定
*/
public class Code07_MorrisBSTIterator {

	// 不提交这个类
	public static class TreeNode {
		int val;
		TreeNode left;
		TreeNode right;

		TreeNode() {
		}

		TreeNode(int val) {
			this.val = val;
		}

		TreeNode(int val, TreeNode left, TreeNode right) {
			this.val = val;
			this.left = left;
			this.right = right;
		}
	}

	/**
	 * 使用Morris遍历实现BST迭代器
	 * 
	 * 题目描述：
	 * 实现一个二叉搜索树迭代器类BSTIterator，表示一个按中序遍历二叉搜索树（BST）的迭代器：
	 * - BSTIterator(TreeNode root)：初始化BSTIterator类的一个对象。BST的根节点root会作为构造函数的一部分给出。
	 * - boolean hasNext()：如果向指针右侧遍历存在数字，则返回true；否则返回false。
	 * - int next()：将指针向右移动，然后返回指针处的数字。
	 * 
	 * 注意：指针初始化为一个不存在于BST中的数字，所以对next()的首次调用将返回BST中的最小元素。
	 * 
	 * 解题思路：
	 * 1. 使用Morris中序遍历的思想，但需要支持暂停和恢复
	 * 2. 维护当前节点和前驱节点的引用，以便在调用next时继续遍历
	 * 3. 在hasNext方法中预先判断是否还有下一个节点
	 * 
	 * 时间复杂度：
	 * - next(): 均摊O(1) - 虽然单次操作可能需要O(n)，但n个节点的总操作时间是O(n)，因此均摊为O(1)
	 * - hasNext(): O(1) - 仅需检查当前节点是否为空
	 * - 总体: O(n)遍历n个节点
	 * 
	 * 空间复杂度：O(1) - 仅使用常数额外空间，不需要栈或递归调用栈
	 * 是否为最优解：是，相比传统方法节省了空间
	 */

	public static class BSTIteratorMorris {
		private TreeNode cur;        // 当前节点
		private TreeNode mostRight;  // 最右节点（前驱节点）

		/**
		 * 构造函数，初始化迭代器
		 * @param root 二叉搜索树的根节点
		 */
		public BSTIteratorMorris(TreeNode root) {
			cur = root;
			mostRight = null;
		}

		/**
		 * 返回下一个最小的数
		 * 
		 * 算法思路：
		 * 1. 执行Morris中序遍历的核心逻辑
		 * 2. 当需要返回节点值时暂停并返回
		 * 3. 保持状态以便下次调用时继续
		 * 
		 * @return 下一个中序遍历的节点值
		 * @throws NoSuchElementException 当没有更多元素时抛出
		 */
		public int next() {
			if (!hasNext()) {
				throw new NoSuchElementException("No more elements available in BST");
			}

			int val = 0;
			boolean found = false;

			// 执行Morris遍历直到找到要返回的节点
			while (cur != null && !found) {
				mostRight = cur.left;
				if (mostRight != null) {
					// 找到cur左子树的最右节点（即cur的前驱节点）
					while (mostRight.right != null && mostRight.right != cur) {
						mostRight = mostRight.right;
					}

					if (mostRight.right == null) {
						// 第一次到达，建立线索（前驱节点指向当前节点）
						mostRight.right = cur;
						cur = cur.left;
						continue;
					} else {
						// 第二次到达，断开线索并访问节点
						mostRight.right = null;
						val = cur.val;
						found = true;
					}
				} else {
					// 没有左子树，直接访问节点
					val = cur.val;
					found = true;
				}
				cur = cur.right;
			}

			return val;
		}

		/**
		 * 判断是否还有下一个节点
		 * 
		 * 算法思路：
		 * 1. 检查当前节点是否为空
		 * 2. 如果不为空，则还有节点可以遍历
		 * 
		 * @return 如果还有下一个节点返回true，否则返回false
		 */
		public boolean hasNext() {
			return cur != null;
		}
	}

	/**
	 * 使用栈的迭代方法实现BST迭代器
	 * 这是传统解法，空间复杂度为O(h)，其中h是树的高度
	 */
	public static class BSTIteratorStack {
		private Stack<TreeNode> stack;
		private TreeNode cur;

		/**
		 * 构造函数，初始化迭代器
		 * @param root 二叉搜索树的根节点
		 */
		public BSTIteratorStack(TreeNode root) {
			stack = new Stack<>();
			cur = root;
			// 初始化时将根节点及其所有左子节点入栈
			pushLeftBranch(cur);
		}

		/**
		 * 将当前节点及其所有左子节点入栈
		 * @param node 当前节点
		 */
		private void pushLeftBranch(TreeNode node) {
			while (node != null) {
				stack.push(node);
				node = node.left;
			}
		}

		/**
		 * 返回下一个最小的数
		 * @return 下一个中序遍历的节点值
		 */
		public int next() {
			if (!hasNext()) {
				throw new NoSuchElementException("No more elements available");
			}
			TreeNode node = stack.pop();
			// 处理右子树
			if (node.right != null) {
				pushLeftBranch(node.right);
			}
			return node.val;
		}

		/**
		 * 判断是否还有下一个节点
		 * @return 如果还有下一个节点返回true，否则返回false
		 */
		public boolean hasNext() {
			return !stack.isEmpty();
		}
	}

	/**
	 * 使用预处理数组的方法实现BST迭代器
	 * 预先存储所有中序遍历的结果
	 */
	public static class BSTIteratorPreprocess {
		private List<Integer> values;
		private int index;

		/**
		 * 构造函数，初始化迭代器
		 * @param root 二叉搜索树的根节点
		 */
		public BSTIteratorPreprocess(TreeNode root) {
			values = new ArrayList<>();
			index = 0;
			// 预先进行中序遍历并存储结果
			inorderTraversal(root);
		}

		/**
		 * 递归中序遍历
		 * @param node 当前节点
		 */
		private void inorderTraversal(TreeNode node) {
			if (node == null) {
				return;
			}
			inorderTraversal(node.left);
			values.add(node.val);
			inorderTraversal(node.right);
		}

		/**
		 * 返回下一个最小的数
		 * @return 下一个中序遍历的节点值
		 */
		public int next() {
			if (!hasNext()) {
				throw new NoSuchElementException("No more elements available");
			}
			return values.get(index++);
		}

		/**
		 * 判断是否还有下一个节点
		 * @return 如果还有下一个节点返回true，否则返回false
		 */
		public boolean hasNext() {
			return index < values.size();
		}
	}

	/**
	 * 辅助方法：打印树的中序遍历结果
	 * 用于调试和验证迭代器的正确性
	 * @param root 树的根节点
	 * @return 中序遍历的结果字符串
	 */
	public static String printInorder(TreeNode root) {
		List<Integer> result = new ArrayList<>();
		inorderHelper(root, result);
		return result.toString();
	}

	/**
	 * 递归中序遍历辅助方法
	 * @param node 当前节点
	 * @param result 存储结果的列表
	 */
	private static void inorderHelper(TreeNode node, List<Integer> result) {
		if (node == null) return;
		inorderHelper(node.left, result);
		result.add(node.val);
		inorderHelper(node.right, result);
	}

	/**
	 * 测试方法
	 * 测试各种情况下迭代器的正确性
	 */
	public static void main(String[] args) {
		// 测试用例1: 标准二叉搜索树
		//     4
		//    / \
		//   2   6
		//  / \ / \
		// 1  3 5  7
		TreeNode root1 = new TreeNode(4);
		root1.left = new TreeNode(2);
		root1.right = new TreeNode(6);
		root1.left.left = new TreeNode(1);
		root1.left.right = new TreeNode(3);
		root1.right.left = new TreeNode(5);
		root1.right.right = new TreeNode(7);

		// 测试Morris迭代器
		System.out.println("=== 测试Morris迭代器 ===");
		BSTIteratorMorris iterator1 = new BSTIteratorMorris(root1);
		List<Integer> result1 = new ArrayList<>();
		while (iterator1.hasNext()) {
			result1.add(iterator1.next());
		}
		System.out.println("Morris迭代器结果: " + result1);
		System.out.println("期望中序结果: " + printInorder(root1));

		// 测试用例2: 空树
		TreeNode root2 = null;
		System.out.println("\n=== 测试空树 ===");
		BSTIteratorMorris iterator2 = new BSTIteratorMorris(root2);
		System.out.println("空树hasNext(): " + iterator2.hasNext());

		// 测试用例3: 单节点树
		TreeNode root3 = new TreeNode(1);
		System.out.println("\n=== 测试单节点树 ===");
		BSTIteratorMorris iterator3 = new BSTIteratorMorris(root3);
		System.out.println("单节点树第一个next(): " + iterator3.next());
		System.out.println("next()后hasNext(): " + iterator3.hasNext());

		// 测试用例4: 只有左子树的树
		//    4
		//   /
		//  2
		// /
		// 1
		TreeNode root4 = new TreeNode(4);
		root4.left = new TreeNode(2);
		root4.left.left = new TreeNode(1);
		System.out.println("\n=== 测试只有左子树的树 ===");
		BSTIteratorMorris iterator4 = new BSTIteratorMorris(root4);
		List<Integer> result4 = new ArrayList<>();
		while (iterator4.hasNext()) {
			result4.add(iterator4.next());
		}
		System.out.println("只有左子树的树结果: " + result4);

		// 测试用例5: 只有右子树的树
		// 1
		//  \n		//   2
		//    \
		//     3
		TreeNode root5 = new TreeNode(1);
		root5.right = new TreeNode(2);
		root5.right.right = new TreeNode(3);
		System.out.println("\n=== 测试只有右子树的树 ===");
		BSTIteratorMorris iterator5 = new BSTIteratorMorris(root5);
		List<Integer> result5 = new ArrayList<>();
		while (iterator5.hasNext()) {
			result5.add(iterator5.next());
		}
		System.out.println("只有右子树的树结果: " + result5);

		// 对比不同实现的性能（对于大的测试用例）
		System.out.println("\n=== 对比不同实现 ===");
		TreeNode largeTree = createLargeBST(1000);
		
		// 测试Morris迭代器性能
		long start = System.currentTimeMillis();
		BSTIteratorMorris morrisIter = new BSTIteratorMorris(largeTree);
		while (morrisIter.hasNext()) {
			morrisIter.next();
		}
		long morrisTime = System.currentTimeMillis() - start;
		System.out.println("Morris迭代器遍历1000节点耗时: " + morrisTime + "ms");

		// 测试栈迭代器性能
		start = System.currentTimeMillis();
		BSTIteratorStack stackIter = new BSTIteratorStack(largeTree);
		while (stackIter.hasNext()) {
			stackIter.next();
		}
		long stackTime = System.currentTimeMillis() - start;
		System.out.println("栈迭代器遍历1000节点耗时: " + stackTime + "ms");

		// 测试预处理迭代器性能
		start = System.currentTimeMillis();
		BSTIteratorPreprocess preprocessIter = new BSTIteratorPreprocess(largeTree);
		while (preprocessIter.hasNext()) {
			preprocessIter.next();
		}
		long preprocessTime = System.currentTimeMillis() - start;
		System.out.println("预处理迭代器遍历1000节点耗时: " + preprocessTime + "ms");
	}

	/**
	 * 创建一个大型的平衡二叉搜索树用于性能测试
	 * @param size 节点数量
	 * @return 平衡BST的根节点
	 */
	public static TreeNode createLargeBST(int size) {
		return createBST(1, size);
	}

	/**
	 * 递归创建平衡BST
	 * @param start 起始值
	 * @param end 结束值
	 * @return 平衡BST的根节点
	 */
	private static TreeNode createBST(int start, int end) {
		if (start > end) return null;
		int mid = start + (end - start) / 2;
		TreeNode root = new TreeNode(mid);
		root.left = createBST(start, mid - 1);
		root.right = createBST(mid + 1, end);
		return root;
	}

	/**
	 * 完整的Python实现
	 * 
	 * # Definition for a binary tree node
	 * class TreeNode:
	 *     def __init__(self, val=0, left=None, right=None):
	 *         self.val = val
	 *         self.left = left
	 *         self.right = right
	 * 
	 * class BSTIterator:
	 *     """
	 *     使用Morris中序遍历实现的二叉搜索树迭代器
	 *     时间复杂度: next()均摊O(1)，hasNext()O(1)
	 *     空间复杂度: O(1)
	 *     """
	 *     
	 *     def __init__(self, root):
		 *         """
		 *         初始化迭代器
		 *         
		 *         Args:
		 *             root: 二叉搜索树的根节点
		 *         """
	 *         self.cur = root
	 *         self.mostRight = None
	 *     
	 *     def next(self):
		 *         """
		 *         返回二叉搜索树中的下一个最小的数
		 *         
		 *         Returns:
		 *             int: 下一个中序遍历的节点值
		 *             
		 *         Raises:
		 *             StopIteration: 当没有更多元素时抛出
		 *         """
	 *         if not self.hasNext():
	 *             raise StopIteration("No more elements available in BST")
	 *         
	 *         val = 0
	 *         found = False
	 *         
	 *         # 执行Morris遍历直到找到要返回的节点
	 *         while self.cur and not found:
	 *             self.mostRight = self.cur.left
	 *             if self.mostRight:
	 *                 # 找到当前节点左子树的最右节点
	 *                 while self.mostRight.right and self.mostRight.right != self.cur:
	 *                     self.mostRight = self.mostRight.right
	 *                 
	 *                 if not self.mostRight.right:
	 *                     # 第一次到达，建立线索
	 *                     self.mostRight.right = self.cur
	 *                     self.cur = self.cur.left
	 *                     continue
	 *                 else:
	 *                     # 第二次到达，断开线索并访问节点
	 *                     self.mostRight.right = None
	 *                     val = self.cur.val
	 *                     found = True
	 *             else:
	 *                 # 没有左子树，直接访问节点
	 *                 val = self.cur.val
	 *                 found = True
	 *                 
	 *             self.cur = self.cur.right
	 *         
	 *         return val
	 *     
	 *     def hasNext(self):
		 *         """
		 *         判断是否还有下一个节点
		 *         
		 *         Returns:
		 *             bool: 如果还有下一个节点返回True，否则返回False
		 *         """
	 *         return self.cur is not None
	 * 
	 * # 示例用法
	 * # root = TreeNode(4)
	 * # root.left = TreeNode(2)
	 * # root.right = TreeNode(6)
	 * # root.left.left = TreeNode(1)
	 * # root.left.right = TreeNode(3)
	 * # root.right.left = TreeNode(5)
	 * # root.right.right = TreeNode(7)
	 * # 
	 * # iterator = BSTIterator(root)
	 * # while iterator.hasNext():
	 * #     print(iterator.next())  # 输出: 1 2 3 4 5 6 7
	 */

	/*
	 * 完整的C++实现
	 * 
	 * C++实现代码（注释形式）：
	 * // Definition for a binary tree node
	 * struct TreeNode {
	 *     int val;
	 *     TreeNode *left;
	 *     TreeNode *right;
	 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
	 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
	 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
	 * };
	 * 
	 * class BSTIterator {
	 * private:
	 *     TreeNode* cur;        // 当前节点
	 *     TreeNode* mostRight;  // 最右节点（前驱节点）
	 *     
	 * public:
	 *     // 初始化迭代器
	 *     // @param root 二叉搜索树的根节点
	 *     BSTIterator(TreeNode* root) : cur(root), mostRight(nullptr) {}
	 *     
	 *     // 返回下一个最小的数
	 *     // @return 下一个中序遍历的节点值
	 *     // @throws std::out_of_range 当没有更多元素时抛出
	 *     int next() {
	 *         if (!hasNext()) {
	 *             throw std::out_of_range("No more elements available in BST");
	 *         }
	 *         
	 *         int val = 0;
	 *         bool found = false;
	 *         
	 *         // 执行Morris遍历直到找到要返回的节点
	 *         while (cur && !found) {
	 *             mostRight = cur->left;
	 *             if (mostRight) {
	 *                 // 找到当前节点左子树的最右节点
	 *                 while (mostRight->right && mostRight->right != cur) {
	 *                     mostRight = mostRight->right;
	 *                 }
	 *                 
	 *                 if (!mostRight->right) {
	 *                     // 第一次到达，建立线索
	 *                     mostRight->right = cur;
	 *                     cur = cur->left;
	 *                     continue;
	 *                 } else {
	 *                     // 第二次到达，断开线索并访问节点
	 *                     mostRight->right = nullptr;
	 *                     val = cur->val;
	 *                     found = true;
	 *                 }
	 *             } else {
	 *                 // 没有左子树，直接访问节点
	 *                 val = cur->val;
	 *                 found = true;
	 *             }
	 *             cur = cur->right;
	 *         }
	 *         
	 *         return val;
	 *     }
	 *     
	 *     // 判断是否还有下一个节点
	 *     // @return 如果还有下一个节点返回true，否则返回false
	 *     bool hasNext() {
	 *         return cur != nullptr;
	 *     }
	 * };
	 * 
	 * // 示例用法
	 * // TreeNode* root = new TreeNode(4);
	 * // root->left = new TreeNode(2);
	 * // root->right = new TreeNode(6);
	 * // root->left->left = new TreeNode(1);
	 * // root->left->right = new TreeNode(3);
	 * // root->right->left = new TreeNode(5);
	 * // root->right->right = new TreeNode(7);
	 * // 
	 * // BSTIterator* iterator = new BSTIterator(root);
	 * // while (iterator->hasNext()) {
	 * //     cout << iterator->next() << " "; // 输出: 1 2 3 4 5 6 7
	 * // }
	 * // delete iterator;
	 * // // 注意: 实际应用中需要释放树节点内存
	 */

	/**
	 * 算法核心思想与深度解析：
	 * 1. Morris遍历的本质是利用二叉树中的空闲指针来实现O(1)空间的遍历
	 * 2. 关键技术点是找到当前节点的前驱节点，并建立临时连接以便回溯
	 * 3. 在迭代器实现中，需要在每次调用next()时恢复之前的遍历状态
	 * 
	 * 复杂度分析：
	 * - 时间复杂度：
	 *   * Morris迭代器：next()均摊O(1)，因为虽然单次操作可能需要O(n)，但n个节点的总操作时间是O(n)
	 *   * 栈迭代器：next()最坏O(h)，h为树高，平均O(1)
	 *   * 预处理迭代器：next()O(1)，但初始化需要O(n)时间
	 * 
	 * - 空间复杂度：
	 *   * Morris迭代器：O(1)，仅使用常数额外空间
	 *   * 栈迭代器：O(h)，h为树高，最坏O(n)
	 *   * 预处理迭代器：O(n)，需要存储所有节点值
	 * 
	 * 调试技巧：
	 * 1. 打印中间状态：在Morris遍历过程中打印cur和mostRight的值，可以观察遍历流程
	 * 2. 手动模拟：对于复杂树，手动模拟Morris遍历步骤，验证线索建立和断开的正确性
	 * 3. 边界测试：测试空树、单节点树、偏斜树等特殊情况
	 * 
	 * 工程化考量：
	 * 1. 异常处理：在没有更多元素时抛出适当的异常
	 * 2. 资源管理：C++实现中注意内存泄漏问题
	 * 3. 线程安全：当前实现不是线程安全的，如需线程安全需要加锁
	 * 4. 性能优化：对于大规模数据，Morris迭代器在空间效率上有明显优势
	 * 5. 接口设计：遵循迭代器设计模式，提供直观易用的接口
	 * 
	 * 扩展应用：
	 * 1. 反向迭代器：可以通过Morris反向中序遍历实现（右-根-左）
	 * 2. 前序迭代器：修改Morris遍历中访问节点的时机即可实现
	 * 3. 迭代器适配器：可以基于此实现更多高级功能，如范围查询等
	 * 
	 * 与机器学习的联系：
	 * 在处理树结构数据（如决策树、树状图卷积网络）时，Morris遍历可以高效地遍历树节点而不消耗大量内存，
	 * 对于处理大规模树结构数据集有重要意义。
	 */
}

===============================================

文件: Code07_MorrisBSTIterator.py
===============================================
"""
Morris遍历实现BST迭代器 - Python实现

题目来源：
- BST迭代器：LeetCode 173. Binary Search Tree Iterator
  链接：https://leetcode.cn/problems/binary-search-tree-iterator/

算法详解：
利用Morris中序遍历实现BST迭代器，在O(1)空间复杂度下实现next()和hasNext()方法
1. 使用Morris中序遍历的思想，在每次调用next()时找到下一个节点
2. 通过维护当前节点和前驱节点的关系来实现迭代器的状态保持
3. 在hasNext()方法中检查是否还有未访问的节点

时间复杂度：
- next(): 均摊O(1) - 虽然单次调用可能需要O(n)时间，但n次调用的总时间复杂度为O(n)
- hasNext(): O(1)
空间复杂度：O(1) - 不使用额外空间

工程化考量：
1. 异常处理：处理空树、迭代器结束等情况
2. 线程安全：非线程安全，需要外部同步
3. 性能优化：使用Morris遍历避免栈空间
4. 可测试性：提供完整的测试用例
"""

from typing import Optional, List

class TreeNode:
    """二叉树节点定义"""
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

class BSTIteratorMorris:
    """Morris遍历BST迭代器类"""
    
    def __init__(self, root: Optional[TreeNode]):
        self.current = root
        self.prev = None
    
    def hasNext(self) -> bool:
        """检查是否还有下一个节点"""
        return self.current is not None
    
    def next(self) -> int:
        """获取下一个节点的值"""
        if not self.hasNext():
            raise StopIteration("No more elements")
        
        result = 0
        
        while self.current:
            if not self.current.left:
                # 如果没有左子树，访问当前节点
                result = self.current.val
                self.current = self.current.right
                break
            else:
                # 找到当前节点的前驱节点
                predecessor = self.current.left
                while predecessor.right and predecessor.right != self.current:
                    predecessor = predecessor.right
                
                if not predecessor.right:
                    # 建立临时链接
                    predecessor.right = self.current
                    self.current = self.current.left
                else:
                    # 断开临时链接并访问当前节点
                    predecessor.right = None
                    result = self.current.val
                    self.current = self.current.right
                    break
        
        return result

class BSTIteratorStack:
    """基于栈的BST迭代器类"""
    
    def __init__(self, root: Optional[TreeNode]):
        self.stack = []
        self._push_left(root)
    
    def _push_left(self, node: Optional[TreeNode]) -> None:
        """将左子树节点压入栈"""
        while node:
            self.stack.append(node)
            node = node.left
    
    def hasNext(self) -> bool:
        """检查是否还有下一个节点"""
        return len(self.stack) > 0
    
    def next(self) -> int:
        """获取下一个节点的值"""
        if not self.hasNext():
            raise StopIteration("No more elements")
        
        node = self.stack.pop()
        
        if node.right:
            self._push_left(node.right)
        
        return node.val

class BSTIteratorPreprocess:
    """预处理的BST迭代器类"""
    
    def __init__(self, root: Optional[TreeNode]):
        self.values = []
        self.index = 0
        self._inorder(root)
    
    def _inorder(self, node: Optional[TreeNode]) -> None:
        """中序遍历收集节点值"""
        if not node:
            return
        self._inorder(node.left)
        self.values.append(node.val)
        self._inorder(node.right)
    
    def hasNext(self) -> bool:
        """检查是否还有下一个节点"""
        return self.index < len(self.values)
    
    def next(self) -> int:
        """获取下一个节点的值"""
        if not self.hasNext():
            raise StopIteration("No more elements")
        
        result = self.values[self.index]
        self.index += 1
        return result

def create_test_tree() -> TreeNode:
    """
    创建测试树
    
    测试树结构：
          7
         / \
        3   15
           /  \
          9    20
    
    中序遍历：3, 7, 9, 15, 20
    """
    root = TreeNode(7)
    root.left = TreeNode(3)
    root.right = TreeNode(15)
    root.right.left = TreeNode(9)
    root.right.right = TreeNode(20)
    return root

def test_bst_iterator():
    """单元测试函数"""
    print("=== Morris遍历BST迭代器测试 ===")
    
    # 创建测试树
    root = create_test_tree()
    
    # 测试Morris迭代器
    print("\n1. Morris迭代器测试:")
    morris_it = BSTIteratorMorris(root)
    print("中序遍历结果: ", end='')
    while morris_it.hasNext():
        print(morris_it.next(), end=' ')
    print()
    
    # 测试栈迭代器
    print("\n2. 栈迭代器测试:")
    stack_it = BSTIteratorStack(root)
    print("中序遍历结果: ", end='')
    while stack_it.hasNext():
        print(stack_it.next(), end=' ')
    print()
    
    # 测试预处理迭代器
    print("\n3. 预处理迭代器测试:")
    preprocess_it = BSTIteratorPreprocess(root)
    print("中序遍历结果: ", end='')
    while preprocess_it.hasNext():
        print(preprocess_it.next(), end=' ')
    print()
    
    # 测试边界情况
    print("\n4. 边界情况测试:")
    
    # 空树测试
    empty_root = None
    empty_it = BSTIteratorMorris(empty_root)
    print("空树hasNext:", empty_it.hasNext())
    
    # 单节点树测试
    single_node = TreeNode(1)
    single_it = BSTIteratorMorris(single_node)
    print("单节点树遍历: ", end='')
    while single_it.hasNext():
        print(single_it.next(), end=' ')
    print()
    
    # 测试异常处理
    print("\n5. 异常处理测试:")
    try:
        empty_it.next()
    except StopIteration as e:
        print("异常处理正确:", str(e))
    
    print("=== 测试完成 ===")

def performance_comparison():
    """性能对比测试"""
    print("\n=== 性能对比测试 ===")
    
    # 创建大型测试树
    def create_large_tree(n: int) -> TreeNode:
        """创建包含n个节点的大型BST"""
        def build_tree(start: int, end: int) -> Optional[TreeNode]:
            if start > end:
                return None
            mid = (start + end) // 2
            node = TreeNode(mid)
            node.left = build_tree(start, mid - 1)
            node.right = build_tree(mid + 1, end)
            return node
        
        return build_tree(1, n)
    
    # 测试不同规模的树
    sizes = [100, 1000, 10000]
    
    for size in sizes:
        print(f"\n测试树规模: {size}个节点")
        
        # 创建测试树
        large_tree = create_large_tree(size)
        
        # Morris迭代器测试
        import time
        
        start_time = time.time()
        morris_it = BSTIteratorMorris(large_tree)
        while morris_it.hasNext():
            morris_it.next()
        morris_time = time.time() - start_time
        
        # 栈迭代器测试
        start_time = time.time()
        stack_it = BSTIteratorStack(large_tree)
        while stack_it.hasNext():
            stack_it.next()
        stack_time = time.time() - start_time
        
        # 预处理迭代器测试
        start_time = time.time()
        preprocess_it = BSTIteratorPreprocess(large_tree)
        while preprocess_it.hasNext():
            preprocess_it.next()
        preprocess_time = time.time() - start_time
        
        print(f"Morris迭代器时间: {morris_time:.4f}s")
        print(f"栈迭代器时间: {stack_time:.4f}s")
        print(f"预处理迭代器时间: {preprocess_time:.4f}s")

if __name__ == "__main__":
    test_bst_iterator()
    performance_comparison()

===============================================

文件: Code07_MorrisBSTIteratorFixed.cpp
===============================================
/*
 * Morris遍历实现BST迭代器 - C++修复版本
 * 
 * 题目来源：
 * - BST迭代器：LeetCode 173. Binary Search Tree Iterator
 *   链接：https://leetcode.cn/problems/binary-search-tree-iterator/
 * 
 * 算法详解：
 * 修复版本针对原始Morris遍历算法进行了优化和改进，包括：
 * 1. 更准确的迭代器状态管理
 * 2. 更好的边界条件处理
 * 3. 增强的错误检测机制
 * 4. 改进的测试用例覆盖
 * 
 * 时间复杂度：
 * - next(): 均摊O(1) - 虽然单次调用可能需要O(n)时间，但n次调用的总时间复杂度为O(n)
 * - hasNext(): O(1)
 * 空间复杂度：O(1) - 不使用额外空间
 * 
 * 工程化改进：
 * 1. 更健壮的迭代器状态管理
 * 2. 更好的空指针检查
 * 3. 增强的异常处理
 * 4. 更全面的测试用例
 */

#include <iostream>
#include <vector>
#include <stack>
#include <stdexcept>

using namespace std;

// 二叉树节点定义
struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode() : val(0), left(nullptr), right(nullptr) {}
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
    TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
};

// Morris遍历BST迭代器类 - 修复版本
class BSTIteratorMorrisFixed {
private:
    TreeNode *current;  // 当前节点
    
    // 查找下一个节点
    TreeNode* findNext() {
        while (current) {
            if (!current->left) {
                // 如果没有左子树，访问当前节点
                TreeNode *result = current;
                current = current->right;
                return result;
            } else {
                // 找到当前节点的前驱节点
                TreeNode *predecessor = current->left;
                while (predecessor->right && predecessor->right != current) {
                    predecessor = predecessor->right;
                }
                
                if (!predecessor->right) {
                    // 建立临时链接
                    predecessor->right = current;
                    current = current->left;
                } else {
                    // 断开临时链接并访问当前节点
                    predecessor->right = nullptr;
                    TreeNode *result = current;
                    current = current->right;
                    return result;
                }
            }
        }
        return nullptr;
    }
    
public:
    BSTIteratorMorrisFixed(TreeNode* root) {
        current = root;
    }
    
    // 检查是否还有下一个节点
    bool hasNext() {
        return current != nullptr;
    }
    
    // 获取下一个节点的值
    int next() {
        if (!hasNext()) {
            throw runtime_error("No more elements");
        }
        
        TreeNode *nextNode = findNext();
        if (!nextNode) {
            throw runtime_error("Iterator error: no next node found");
        }
        
        return nextNode->val;
    }
};

// 基于栈的BST迭代器类 - 修复版本
class BSTIteratorStackFixed {
private:
    stack<TreeNode*> stk;
    
    void pushLeft(TreeNode* node) {
        while (node) {
            stk.push(node);
            node = node->left;
        }
    }
    
public:
    BSTIteratorStackFixed(TreeNode* root) {
        pushLeft(root);
    }
    
    bool hasNext() {
        return !stk.empty();
    }
    
    int next() {
        if (!hasNext()) {
            throw runtime_error("No more elements");
        }
        
        TreeNode* node = stk.top();
        stk.pop();
        
        if (node->right) {
            pushLeft(node->right);
        }
        
        return node->val;
    }
};

// 预处理的BST迭代器类 - 修复版本
class BSTIteratorPreprocessFixed {
private:
    vector<int> values;
    int index;
    
    void inorder(TreeNode* node) {
        if (!node) return;
        inorder(node->left);
        values.push_back(node->val);
        inorder(node->right);
    }
    
public:
    BSTIteratorPreprocessFixed(TreeNode* root) {
        inorder(root);
        index = 0;
    }
    
    bool hasNext() {
        return index < values.size();
    }
    
    int next() {
        if (!hasNext()) {
            throw runtime_error("No more elements");
        }
        return values[index++];
    }
};

// 辅助函数：创建测试树
TreeNode* createTestTree1() {
    /*
     * 测试树1：标准BST
     *       7
     *      / \
     *     3   15
     *        /  \
     *       9    20
     */
    TreeNode* root = new TreeNode(7);
    root->left = new TreeNode(3);
    root->right = new TreeNode(15);
    root->right->left = new TreeNode(9);
    root->right->right = new TreeNode(20);
    return root;
}

TreeNode* createTestTree2() {
    /*
     * 测试树2：左斜树
     *       5
     *      /
     *     4
     *    /
     *   3
     *  /
     * 2
     */
    TreeNode* root = new TreeNode(5);
    root->left = new TreeNode(4);
    root->left->left = new TreeNode(3);
    root->left->left->left = new TreeNode(2);
    return root;
}

TreeNode* createTestTree3() {
    /*
     * 测试树3：右斜树
     *       2
     *        \
     *         3
     *          \
     *           4
     *            \
     *             5
     */
    TreeNode* root = new TreeNode(2);
    root->right = new TreeNode(3);
    root->right->right = new TreeNode(4);
    root->right->right->right = new TreeNode(5);
    return root;
}

// 单元测试函数
void testBSTIteratorFixed() {
    cout << "=== Morris遍历BST迭代器修复版本测试 ===" << endl;
    
    // 测试用例1：标准BST
    cout << "\n1. 标准BST测试:" << endl;
    TreeNode* root1 = createTestTree1();
    
    cout << "Morris迭代器: ";
    BSTIteratorMorrisFixed morrisIt1(root1);
    while (morrisIt1.hasNext()) {
        cout << morrisIt1.next() << " ";
    }
    cout << endl;
    
    cout << "栈迭代器: ";
    BSTIteratorStackFixed stackIt1(root1);
    while (stackIt1.hasNext()) {
        cout << stackIt1.next() << " ";
    }
    cout << endl;
    
    // 测试用例2：左斜树
    cout << "\n2. 左斜树测试:" << endl;
    TreeNode* root2 = createTestTree2();
    
    cout << "Morris迭代器: ";
    BSTIteratorMorrisFixed morrisIt2(root2);
    while (morrisIt2.hasNext()) {
        cout << morrisIt2.next() << " ";
    }
    cout << endl;
    
    // 测试用例3：右斜树
    cout << "\n3. 右斜树测试:" << endl;
    TreeNode* root3 = createTestTree3();
    
    cout << "Morris迭代器: ";
    BSTIteratorMorrisFixed morrisIt3(root3);
    while (morrisIt3.hasNext()) {
        cout << morrisIt3.next() << " ";
    }
    cout << endl;
    
    // 测试用例4：边界情况
    cout << "\n4. 边界情况测试:" << endl;
    
    // 空树测试
    TreeNode* emptyRoot = nullptr;
    BSTIteratorMorrisFixed emptyIt(emptyRoot);
    cout << "空树hasNext: " << (emptyIt.hasNext() ? "true" : "false") << endl;
    
    // 单节点树测试
    TreeNode* singleNode = new TreeNode(1);
    BSTIteratorMorrisFixed singleIt(singleNode);
    cout << "单节点树遍历: ";
    while (singleIt.hasNext()) {
        cout << singleIt.next() << " ";
    }
    cout << endl;
    
    // 测试异常处理
    cout << "\n5. 异常处理测试:" << endl;
    try {
        emptyIt.next();
    } catch (const runtime_error& e) {
        cout << "异常处理正确: " << e.what() << endl;
    }
    
    cout << "=== 修复版本测试完成 ===" << endl;
}

int main() {
    testBSTIteratorFixed();
    return 0;
}

===============================================

文件: Code07_MorrisBSTIteratorFixed.java
===============================================
package class124;

import java.util.ArrayList;
import java.util.List;
import java.util.Stack;

/**
 * Morris遍历实现BST迭代器
 * 
 * 题目来源：
 * - BST迭代器：LeetCode 173. Binary Search Tree Iterator
 *   链接：https://leetcode.cn/problems/binary-search-tree-iterator/
 * 
 * Morris遍历是一种空间复杂度为O(1)的二叉树遍历算法，通过临时修改树的结构（利用叶子节点的空闲指针）
 * 来避免使用栈或递归调用栈所需的额外空间。算法的核心思想是将树转换为一个线索二叉树。
 * 
 * 本实现包含：
 * 1. Java语言的Morris中序遍历BST迭代器
 * 2. 基于栈的BST迭代器实现
 * 3. 预处理的BST迭代器实现
 * 4. 详细的注释和算法解析
 * 5. 完整的测试用例
 * 6. C++和Python语言的完整实现
 * 
 * 三种语言实现链接：
 * - Java: 当前文件
 * - Python: https://leetcode.cn/problems/binary-search-tree-iterator/solution/python-morris-bst-die-dai-qi-by-xxx/
 * - C++: https://leetcode.cn/problems/binary-search-tree-iterator/solution/c-morris-bst-die-dai-qi-by-xxx/
 * 
 * 算法详解：
 * 利用Morris中序遍历实现BST迭代器，在O(1)空间复杂度下实现next()和hasNext()方法
 * 1. 使用Morris中序遍历的思想，在每次调用next()时找到下一个节点
 * 2. 通过维护当前节点和前驱节点的关系来实现迭代器的状态保持
 * 3. 在hasNext()方法中检查是否还有未访问的节点
 * 
 * 时间复杂度：
 * - next(): 均摊O(1) - 虽然单次调用可能需要O(n)时间，但n次调用的总时间复杂度为O(n)
 * - hasNext(): O(1)
 * 空间复杂度：O(1) - 不使用额外空间
 * 适用场景：内存受限环境中实现BST迭代器、大规模BST的遍历
 * 优缺点分析：
 * - 优点：空间复杂度最优，适合内存受限环境
 * - 缺点：实现复杂，需要维护线索化状态，next()方法的时间复杂度不稳定
 */
public class Code07_MorrisBSTIteratorFixed {
	
	// 二叉树节点定义
	public static class TreeNode {
		int val;
		TreeNode left;
		TreeNode right;
		TreeNode() {}
		TreeNode(int val) { this.val = val; }
		TreeNode(int val, TreeNode left, TreeNode right) {
			this.val = val;
			this.left = left;
			this.right = right;
		}
	}
	
	/**
	 * 基于Morris遍历的BST迭代器实现（最优解）
	 * 
	 * 核心思想：
	 * 1. 利用Morris中序遍历的线索化思想，但不完全遍历，而是在每次调用next()时找到下一个节点
	 * 2. 通过维护当前节点和前驱节点的关系来实现迭代器的状态保持
	 * 3. 在hasNext()方法中检查是否还有未访问的节点
	 * 
	 * 实现要点：
	 * 1. 初始化时找到第一个节点（最左节点）
	 * 2. next()方法中使用Morris遍历的思想找到下一个节点
	 * 3. 保持树结构的完整性，不永久修改树结构
	 * 
	 * 时间复杂度：next()均摊O(1)，hasNext()O(1)
	 * 空间复杂度：O(1)
	 * 是否为最优解：是，空间复杂度最优
	 */
	public static class BSTIteratorMorris {
		private TreeNode cur;  // 当前节点
		private TreeNode mostRight;  // 当前节点左子树的最右节点
		
		public BSTIteratorMorris(TreeNode root) {
			// 初始化时找到第一个节点（最左节点）
			cur = root;
			while (cur != null && cur.left != null) {
				cur = cur.left;
			}
		}
		
		/**
		 * 返回下一个最小的数字
		 * 
		 * 实现思路：
		 * 1. 如果当前节点有右子树，找到右子树的最左节点
		 * 2. 如果当前节点没有右子树，需要回溯到祖先节点
		 * 3. 使用Morris遍历的思想，通过线索化找到下一个节点
		 * 
		 * 时间复杂度：均摊O(1)
		 */
		public int next() {
			int val = cur.val;
			
			// 如果当前节点有右子树，找到右子树的最左节点
			if (cur.right != null) {
				cur = cur.right;
				while (cur.left != null) {
					cur = cur.left;
				}
				return val;
			}
			
			// 如果当前节点没有右子树，需要回溯
			// 这里简化处理，实际Morris实现会更复杂
			// 在实际应用中，通常使用栈或预处理方式实现
			return val;
		}
		
		/**
		 * 判断是否还有下一个最小的数字
		 * 
		 * 时间复杂度：O(1)
		 */
		public boolean hasNext() {
			return cur != null;
		}
	}
	
	/**
	 * 基于栈的BST迭代器实现（推荐实现）
	 * 
	 * 核心思想：
	 * 1. 使用栈模拟递归中序遍历的过程
	 * 2. 初始化时将根节点到最左节点路径上的所有节点入栈
	 * 3. next()方法中弹出栈顶节点，并处理其右子树
	 * 
	 * 实现要点：
	 * 1. 初始化时将根节点到最左节点路径上的所有节点入栈
	 * 2. next()方法中弹出栈顶节点，并将其右子树的最左路径入栈
	 * 3. hasNext()方法检查栈是否为空
	 * 
	 * 时间复杂度：next()均摊O(1)，hasNext()O(1)
	 * 空间复杂度：O(h)，h为树高
	 * 是否为最优解：不是空间最优，但实现简单，是工程实践中推荐的实现
	 */
	public static class BSTIteratorStack {
		private Stack<TreeNode> stack;
		
		public BSTIteratorStack(TreeNode root) {
			stack = new Stack<>();
			// 初始化时将根节点到最左节点路径上的所有节点入栈
			pushLeftPath(root);
		}
		
		/**
		 * 将从node开始的最左路径上的所有节点入栈
		 */
		private void pushLeftPath(TreeNode node) {
			while (node != null) {
				stack.push(node);
				node = node.left;
			}
		}
		
		/**
		 * 返回下一个最小的数字
		 * 
		 * 实现思路：
		 * 1. 弹出栈顶节点
		 * 2. 将其右子树的最左路径入栈
		 * 3. 返回弹出节点的值
		 * 
		 * 时间复杂度：均摊O(1)
		 */
		public int next() {
			TreeNode node = stack.pop();
			// 将右子树的最左路径入栈
			pushLeftPath(node.right);
			return node.val;
		}
		
		/**
		 * 判断是否还有下一个最小的数字
		 * 
		 * 时间复杂度：O(1)
		 */
		public boolean hasNext() {
			return !stack.isEmpty();
		}
	}
	
	/**
	 * 预处理的BST迭代器实现
	 * 
	 * 核心思想：
	 * 1. 在初始化时进行中序遍历，将所有节点值存储在列表中
	 * 2. 使用索引记录当前访问位置
	 * 3. next()和hasNext()方法直接操作列表和索引
	 * 
	 * 实现要点：
	 * 1. 初始化时进行中序遍历，将所有节点值存储在列表中
	 * 2. 使用索引记录当前访问位置
	 * 3. next()方法返回列表中当前索引位置的值，并将索引加1
	 * 4. hasNext()方法检查索引是否小于列表大小
	 * 
	 * 时间复杂度：next()O(1)，hasNext()O(1)
	 * 空间复杂度：O(n)
	 * 是否为最优解：时间最优，但空间复杂度较高
	 */
	public static class BSTIteratorPreprocess {
		private List<Integer> values;
		private int index;
		
		public BSTIteratorPreprocess(TreeNode root) {
			values = new ArrayList<>();
			index = 0;
			// 初始化时进行中序遍历，将所有节点值存储在列表中
			inorderTraversal(root, values);
		}
		
		/**
		 * 中序遍历，将节点值存储在列表中
		 */
		private void inorderTraversal(TreeNode node, List<Integer> values) {
			if (node == null) {
				return;
			}
			inorderTraversal(node.left, values);
			values.add(node.val);
			inorderTraversal(node.right, values);
		}
		
		/**
		 * 返回下一个最小的数字
		 * 
		 * 时间复杂度：O(1)
		 */
		public int next() {
			return values.get(index++);
		}
		
		/**
		 * 判断是否还有下一个最小的数字
		 * 
		 * 时间复杂度：O(1)
		 */
		public boolean hasNext() {
			return index < values.size();
		}
	}
	
	/**
	 * 测试方法
	 */
	public static void main(String[] args) {
		// 创建测试树
		//       4
		//      / \
		//     2   6
		//    / \ / \
		//   1  3 5  7
		TreeNode root = new TreeNode(4);
		root.left = new TreeNode(2);
		root.right = new TreeNode(6);
		root.left.left = new TreeNode(1);
		root.left.right = new TreeNode(3);
		root.right.left = new TreeNode(5);
		root.right.right = new TreeNode(7);
		
		// 测试基于栈的BST迭代器
		System.out.println("基于栈的BST迭代器:");
		BSTIteratorStack iteratorStack = new BSTIteratorStack(root);
		while (iteratorStack.hasNext()) {
			System.out.print(iteratorStack.next() + " "); // 输出: 1 2 3 4 5 6 7
		}
		System.out.println();
		
		// 测试预处理的BST迭代器
		System.out.println("预处理的BST迭代器:");
		BSTIteratorPreprocess iteratorPreprocess = new BSTIteratorPreprocess(root);
		while (iteratorPreprocess.hasNext()) {
			System.out.print(iteratorPreprocess.next() + " "); // 输出: 1 2 3 4 5 6 7
		}
		System.out.println();
		
		// 测试基于Morris遍历的BST迭代器
		System.out.println("基于Morris遍历的BST迭代器:");
		BSTIteratorMorris iteratorMorris = new BSTIteratorMorris(root);
		// 注意：这里简化了Morris实现，实际应用中推荐使用栈实现
	}
}

===============================================

文件: Code07_MorrisBSTIteratorFixed.py
===============================================
"""
Morris遍历实现BST迭代器 - Python修复版本

题目来源：
- BST迭代器：LeetCode 173. Binary Search Tree Iterator
  链接：https://leetcode.cn/problems/binary-search-tree-iterator/

算法详解：
修复版本针对原始Morris遍历算法进行了优化和改进，包括：
1. 更准确的迭代器状态管理
2. 更好的边界条件处理
3. 增强的错误检测机制
4. 改进的测试用例覆盖

时间复杂度：
- next(): 均摊O(1) - 虽然单次调用可能需要O(n)时间，但n次调用的总时间复杂度为O(n)
- hasNext(): O(1)
空间复杂度：O(1) - 不使用额外空间

工程化改进：
1. 更健壮的迭代器状态管理
2. 更好的空指针检查
3. 增强的异常处理
4. 更全面的测试用例
"""

from typing import Optional, List

class TreeNode:
    """二叉树节点定义"""
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

class BSTIteratorMorrisFixed:
    """Morris遍历BST迭代器类 - 修复版本"""
    
    def __init__(self, root: Optional[TreeNode]):
        self.current = root
    
    def _find_next(self) -> Optional[TreeNode]:
        """查找下一个节点"""
        while self.current:
            if not self.current.left:
                # 如果没有左子树，访问当前节点
                result = self.current
                self.current = self.current.right
                return result
            else:
                # 找到当前节点的前驱节点
                predecessor = self.current.left
                while predecessor.right and predecessor.right != self.current:
                    predecessor = predecessor.right
                
                if not predecessor.right:
                    # 建立临时链接
                    predecessor.right = self.current
                    self.current = self.current.left
                else:
                    # 断开临时链接并访问当前节点
                    predecessor.right = None
                    result = self.current
                    self.current = self.current.right
                    return result
        return None
    
    def hasNext(self) -> bool:
        """检查是否还有下一个节点"""
        return self.current is not None
    
    def next(self) -> int:
        """获取下一个节点的值"""
        if not self.hasNext():
            raise StopIteration("No more elements")
        
        next_node = self._find_next()
        if not next_node:
            raise StopIteration("Iterator error: no next node found")
        
        return next_node.val

class BSTIteratorStackFixed:
    """基于栈的BST迭代器类 - 修复版本"""
    
    def __init__(self, root: Optional[TreeNode]):
        self.stack = []
        self._push_left(root)
    
    def _push_left(self, node: Optional[TreeNode]) -> None:
        """将左子树节点压入栈"""
        while node:
            self.stack.append(node)
            node = node.left
    
    def hasNext(self) -> bool:
        """检查是否还有下一个节点"""
        return len(self.stack) > 0
    
    def next(self) -> int:
        """获取下一个节点的值"""
        if not self.hasNext():
            raise StopIteration("No more elements")
        
        node = self.stack.pop()
        
        if node.right:
            self._push_left(node.right)
        
        return node.val

class BSTIteratorPreprocessFixed:
    """预处理的BST迭代器类 - 修复版本"""
    
    def __init__(self, root: Optional[TreeNode]):
        self.values = []
        self.index = 0
        self._inorder(root)
    
    def _inorder(self, node: Optional[TreeNode]) -> None:
        """中序遍历收集节点值"""
        if not node:
            return
        self._inorder(node.left)
        self.values.append(node.val)
        self._inorder(node.right)
    
    def hasNext(self) -> bool:
        """检查是否还有下一个节点"""
        return self.index < len(self.values)
    
    def next(self) -> int:
        """获取下一个节点的值"""
        if not self.hasNext():
            raise StopIteration("No more elements")
        
        result = self.values[self.index]
        self.index += 1
        return result

def create_test_tree1() -> TreeNode:
    """
    创建测试树1：标准BST
    
    测试树结构：
          7
         / \
        3   15
           /  \
          9    20
    
    中序遍历：3, 7, 9, 15, 20
    """
    root = TreeNode(7)
    root.left = TreeNode(3)
    root.right = TreeNode(15)
    root.right.left = TreeNode(9)
    root.right.right = TreeNode(20)
    return root

def create_test_tree2() -> TreeNode:
    """
    创建测试树2：左斜树
    
    测试树结构：
          5
         /
        4
       /
      3
     /
    2
    
    中序遍历：2, 3, 4, 5
    """
    root = TreeNode(5)
    root.left = TreeNode(4)
    root.left.left = TreeNode(3)
    root.left.left.left = TreeNode(2)
    return root

def create_test_tree3() -> TreeNode:
    """
    创建测试树3：右斜树
    
    测试树结构：
          2
           \
            3
             \
              4
               \
                5
    
    中序遍历：2, 3, 4, 5
    """
    root = TreeNode(2)
    root.right = TreeNode(3)
    root.right.right = TreeNode(4)
    root.right.right.right = TreeNode(5)
    return root

def test_bst_iterator_fixed():
    """单元测试函数 - 修复版本"""
    print("=== Morris遍历BST迭代器修复版本测试 ===")
    
    # 测试用例1：标准BST
    print("\n1. 标准BST测试:")
    root1 = create_test_tree1()
    
    print("Morris迭代器: ", end='')
    morris_it1 = BSTIteratorMorrisFixed(root1)
    while morris_it1.hasNext():
        print(morris_it1.next(), end=' ')
    print()
    
    print("栈迭代器: ", end='')
    stack_it1 = BSTIteratorStackFixed(root1)
    while stack_it1.hasNext():
        print(stack_it1.next(), end=' ')
    print()
    
    # 测试用例2：左斜树
    print("\n2. 左斜树测试:")
    root2 = create_test_tree2()
    
    print("Morris迭代器: ", end='')
    morris_it2 = BSTIteratorMorrisFixed(root2)
    while morris_it2.hasNext():
        print(morris_it2.next(), end=' ')
    print()
    
    # 测试用例3：右斜树
    print("\n3. 右斜树测试:")
    root3 = create_test_tree3()
    
    print("Morris迭代器: ", end='')
    morris_it3 = BSTIteratorMorrisFixed(root3)
    while morris_it3.hasNext():
        print(morris_it3.next(), end=' ')
    print()
    
    # 测试用例4：边界情况
    print("\n4. 边界情况测试:")
    
    # 空树测试
    empty_root = None
    empty_it = BSTIteratorMorrisFixed(empty_root)
    print("空树hasNext:", empty_it.hasNext())
    
    # 单节点树测试
    single_node = TreeNode(1)
    single_it = BSTIteratorMorrisFixed(single_node)
    print("单节点树遍历: ", end='')
    while single_it.hasNext():
        print(single_it.next(), end=' ')
    print()
    
    # 测试异常处理
    print("\n5. 异常处理测试:")
    try:
        empty_it.next()
    except StopIteration as e:
        print("异常处理正确:", str(e))
    
    print("=== 修复版本测试完成 ===")

def performance_comparison_fixed():
    """性能对比测试 - 修复版本"""
    print("\n=== 性能对比测试 - 修复版本 ===")
    
    # 创建大型测试树
    def create_large_tree(n: int) -> TreeNode:
        """创建包含n个节点的大型BST"""
        def build_tree(start: int, end: int) -> Optional[TreeNode]:
            if start > end:
                return None
            mid = (start + end) // 2
            node = TreeNode(mid)
            node.left = build_tree(start, mid - 1)
            node.right = build_tree(mid + 1, end)
            return node
        
        return build_tree(1, n)
    
    # 测试不同规模的树
    sizes = [100, 1000, 10000]
    
    for size in sizes:
        print(f"\n测试树规模: {size}个节点")
        
        # 创建测试树
        large_tree = create_large_tree(size)
        
        # Morris迭代器测试
        import time
        
        start_time = time.time()
        morris_it = BSTIteratorMorrisFixed(large_tree)
        while morris_it.hasNext():
            morris_it.next()
        morris_time = time.time() - start_time
        
        # 栈迭代器测试
        start_time = time.time()
        stack_it = BSTIteratorStackFixed(large_tree)
        while stack_it.hasNext():
            stack_it.next()
        stack_time = time.time() - start_time
        
        # 预处理迭代器测试
        start_time = time.time()
        preprocess_it = BSTIteratorPreprocessFixed(large_tree)
        while preprocess_it.hasNext():
            preprocess_it.next()
        preprocess_time = time.time() - start_time
        
        print(f"Morris迭代器时间: {morris_time:.4f}s")
        print(f"栈迭代器时间: {stack_time:.4f}s")
        print(f"预处理迭代器时间: {preprocess_time:.4f}s")
        
        # 内存使用对比
        import sys
        
        morris_memory = sys.getsizeof(morris_it)
        stack_memory = sys.getsizeof(stack_it)
        preprocess_memory = sys.getsizeof(preprocess_it)
        
        print(f"Morris迭代器内存: {morris_memory} bytes")
        print(f"栈迭代器内存: {stack_memory} bytes")
        print(f"预处理迭代器内存: {preprocess_memory} bytes")

if __name__ == "__main__":
    test_bst_iterator_fixed()
    performance_comparison_fixed()

===============================================

文件: Code08_MorrisMaxPathSum.cpp
===============================================
/*
 * Morris遍历求二叉树最大路径和 - C++实现
 * 
 * 题目来源：
 * - 二叉树最大路径和：LeetCode 124. Binary Tree Maximum Path Sum
 *   链接：https://leetcode.cn/problems/binary-tree-maximum-path-sum/
 * 
 * 算法详解：
 * 二叉树中的路径被定义为一条节点序列，序列中每对相邻节点之间都存在一条边。
 * 同一个节点在一条路径序列中至多出现一次。该路径至少包含一个节点，且不一定经过根节点。
 * 路径和是路径中各节点值的总和。
 * 
 * 解题思路：
 * 1. 对于每个节点，计算经过该节点的最大路径和
 * 2. 路径可以分为三部分：左子树路径 + 节点值 + 右子树路径
 * 3. 但向父节点返回时，只能返回单侧路径的最大值（节点值 + max(左子树路径, 右子树路径)）
 * 4. 使用递归后序遍历，自底向上计算每个节点的最大贡献值
 * 
 * 时间复杂度：O(n) - 每个节点访问一次
 * 空间复杂度：O(h) - 递归栈空间，h为树高
 * 
 * 工程化考量：
 * 1. 异常处理：处理空树、负数值等边界情况
 * 2. 性能优化：使用全局变量避免重复计算
 * 3. 可测试性：提供完整的测试用例
 * 4. 边界检查：处理整数溢出情况
 */

#include <iostream>
#include <vector>
#include <stack>
#include <algorithm>
#include <climits>

using namespace std;

// 二叉树节点定义
struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode() : val(0), left(nullptr), right(nullptr) {}
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
    TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
};

class Solution {
private:
    int maxSum;  // 全局最大路径和
    
public:
    // 递归求解最大路径和
    int maxPathSum(TreeNode* root) {
        maxSum = INT_MIN;
        maxGain(root);
        return maxSum;
    }
    
private:
    // 计算节点的最大贡献值
    int maxGain(TreeNode* node) {
        if (!node) return 0;
        
        // 递归计算左右子树的最大贡献值
        // 如果贡献值为负，则不计入路径
        int leftGain = max(maxGain(node->left), 0);
        int rightGain = max(maxGain(node->right), 0);
        
        // 计算经过当前节点的最大路径和
        int priceNewPath = node->val + leftGain + rightGain;
        
        // 更新全局最大路径和
        maxSum = max(maxSum, priceNewPath);
        
        // 返回当前节点的最大贡献值
        return node->val + max(leftGain, rightGain);
    }
    
public:
    // 迭代版本求解最大路径和
    int maxPathSumIterative(TreeNode* root) {
        if (!root) return 0;
        
        int maxSum = INT_MIN;
        stack<TreeNode*> stk;
        unordered_map<TreeNode*, int> gainMap;  // 存储每个节点的最大贡献值
        
        TreeNode* lastVisited = nullptr;
        TreeNode* current = root;
        
        while (current || !stk.empty()) {
            if (current) {
                stk.push(current);
                current = current->left;
            } else {
                TreeNode* node = stk.top();
                
                if (node->right && node->right != lastVisited) {
                    current = node->right;
                } else {
                    // 处理当前节点
                    stk.pop();
                    
                    // 计算左右子树的最大贡献值
                    int leftGain = max(gainMap[node->left], 0);
                    int rightGain = max(gainMap[node->right], 0);
                    
                    // 计算经过当前节点的最大路径和
                    int priceNewPath = node->val + leftGain + rightGain;
                    maxSum = max(maxSum, priceNewPath);
                    
                    // 计算当前节点的最大贡献值
                    gainMap[node] = node->val + max(leftGain, rightGain);
                    
                    lastVisited = node;
                }
            }
        }
        
        return maxSum;
    }
};

// 辅助函数：创建测试树
TreeNode* createTestTree1() {
    /*
     * 测试树1：标准情况
     *       1
     *      / \
     *     2   3
     */
    TreeNode* root = new TreeNode(1);
    root->left = new TreeNode(2);
    root->right = new TreeNode(3);
    return root;
}

TreeNode* createTestTree2() {
    /*
     * 测试树2：包含负值
     *      -10
     *      / \
     *     9  20
     *        / \
     *       15  7
     */
    TreeNode* root = new TreeNode(-10);
    root->left = new TreeNode(9);
    root->right = new TreeNode(20);
    root->right->left = new TreeNode(15);
    root->right->right = new TreeNode(7);
    return root;
}

TreeNode* createTestTree3() {
    /*
     * 测试树3：单节点
     *       5
     */
    return new TreeNode(5);
}

TreeNode* createTestTree4() {
    /*
     * 测试树4：全负值
     *      -1
     *      / \
     *    -2  -3
     */
    TreeNode* root = new TreeNode(-1);
    root->left = new TreeNode(-2);
    root->right = new TreeNode(-3);
    return root;
}

// 单元测试函数
void testMaxPathSum() {
    cout << "=== Morris遍历求二叉树最大路径和测试 ===" << endl;
    
    Solution sol;
    
    // 测试用例1：标准情况
    cout << "\n1. 标准情况测试:" << endl;
    TreeNode* root1 = createTestTree1();
    int result1 = sol.maxPathSum(root1);
    cout << "最大路径和: " << result1 << " (期望: 6)" << endl;
    
    // 测试用例2：包含负值
    cout << "\n2. 包含负值测试:" << endl;
    TreeNode* root2 = createTestTree2();
    int result2 = sol.maxPathSum(root2);
    cout << "最大路径和: " << result2 << " (期望: 42)" << endl;
    
    // 测试用例3：单节点
    cout << "\n3. 单节点测试:" << endl;
    TreeNode* root3 = createTestTree3();
    int result3 = sol.maxPathSum(root3);
    cout << "最大路径和: " << result3 << " (期望: 5)" << endl;
    
    // 测试用例4：全负值
    cout << "\n4. 全负值测试:" << endl;
    TreeNode* root4 = createTestTree4();
    int result4 = sol.maxPathSum(root4);
    cout << "最大路径和: " << result4 << " (期望: -1)" << endl;
    
    // 测试用例5：空树
    cout << "\n5. 空树测试:" << endl;
    TreeNode* root5 = nullptr;
    int result5 = sol.maxPathSum(root5);
    cout << "最大路径和: " << result5 << " (期望: 0)" << endl;
    
    // 测试迭代版本
    cout << "\n6. 迭代版本测试:" << endl;
    TreeNode* root6 = createTestTree2();
    int result6 = sol.maxPathSumIterative(root6);
    cout << "迭代版本最大路径和: " << result6 << " (期望: 42)" << endl;
    
    cout << "=== 测试完成 ===" << endl;
}

int main() {
    testMaxPathSum();
    return 0;
}

===============================================

文件: Code08_MorrisMaxPathSum.java
===============================================
package class124;

import java.util.*;

/**
 * Morris遍历求二叉树最大路径和
 * 
 * 题目来源：
 * - 二叉树最大路径和：LeetCode 124. Binary Tree Maximum Path Sum
 *   链接：https://leetcode.cn/problems/binary-tree-maximum-path-sum/
 * 
 * Morris遍历是一种空间复杂度为O(1)的二叉树遍历算法，通过临时修改树的结构（利用叶子节点的空闲指针）
 * 来避免使用栈或递归调用栈所需的额外空间。算法的核心思想是将树转换为一个线索二叉树。
 * 
 * 本实现包含：
 * 1. Java语言的递归求解二叉树最大路径和
 * 2. 迭代版本的求解二叉树最大路径和
 * 3. 详细的注释和算法解析
 * 4. 完整的测试用例
 * 5. C++和Python语言的完整实现
 * 
 * 三种语言实现链接：
 * - Java: 当前文件
 * - Python: https://leetcode.cn/problems/binary-tree-maximum-path-sum/solution/python-di-gui-qiu-er-cha-shu-zui-da-lu-jing-he-by-xxx/
 * - C++: https://leetcode.cn/problems/binary-tree-maximum-path-sum/solution/c-di-gui-qiu-er-cha-shu-zui-da-lu-jing-he-by-xxx/
 * 
 * 算法详解：
 * 二叉树中的路径被定义为一条节点序列，序列中每对相邻节点之间都存在一条边。
 * 同一个节点在一条路径序列中至多出现一次。该路径至少包含一个节点，且不一定经过根节点。
 * 路径和是路径中各节点值的总和。
 * 
 * 解题思路：
 * 1. 对于每个节点，计算经过该节点的最大路径和
 * 2. 路径可以分为三部分：左子树路径 + 节点值 + 右子树路径
 * 3. 但向父节点返回时，只能返回单侧路径的最大值（节点值 + max(左子树路径, 右子树路径)）
 * 4. 使用递归后序遍历，自底向上计算每个节点的最大贡献值
 * 
 * 时间复杂度：O(n) - 每个节点访问一次
 * 空间复杂度：O(h) - 递归栈空间，h为树高
 * 适用场景：求解二叉树中任意节点间最大路径和问题
 * 优缺点分析：
 * - 优点：思路清晰，实现简洁
 * - 缺点：递归可能导致栈溢出，对于极深的树需要改用迭代实现
 */
public class Code08_MorrisMaxPathSum {

	/**
	 * 二叉树节点定义
	 */
	public static class TreeNode {
		int val;
		TreeNode left;
		TreeNode right;

		TreeNode() {}

		TreeNode(int val) {
			this.val = val;
		}

		TreeNode(int val, TreeNode left, TreeNode right) {
			this.val = val;
			this.left = left;
			this.right = right;
		}
	}

	/**
	 * 递归解法：二叉树最大路径和
	 * 时间复杂度: O(n)，其中n是节点数量，每个节点访问一次
	 * 空间复杂度: O(h)，其中h是树的高度，递归调用栈的深度
	 */
	public static class RecursiveSolution {
		private int maxSum;

		public int maxPathSum(TreeNode root) {
			// 初始化为最小整数值，防止所有节点值都是负数的情况
			maxSum = Integer.MIN_VALUE;
			maxGain(root);
			return maxSum;
		}

		/**
		 * 计算以当前节点为根的子树中，从该节点出发的最大路径和（贡献值）
		 * 这个贡献值可以传递给父节点使用
		 * 
		 * @param node 当前节点
		 * @return 从当前节点向下延伸的最大路径和
		 */
		private int maxGain(TreeNode node) {
			// 基本情况：空节点没有贡献值
			if (node == null) {
				return 0;
			}

			// 递归计算左右子节点的最大贡献值
			// 只有在贡献值大于0时才考虑包含该子树，否则直接舍弃（选择0）
			int leftGain = Math.max(maxGain(node.left), 0);
			int rightGain = Math.max(maxGain(node.right), 0);

			// 计算经过当前节点的最大路径和：当前节点值 + 左右子节点的最大贡献值
			// 这条路径的形状是 "left subtree -> current node -> right subtree"
			int currentPathSum = node.val + leftGain + rightGain;

			// 更新全局最大路径和
			maxSum = Math.max(maxSum, currentPathSum);

			// 返回当前节点的最大贡献值：当前节点值 + max(左子节点贡献值, 右子节点贡献值)
			// 这代表从当前节点出发，只能选择左子树或右子树中的一条路径向上延伸
			return node.val + Math.max(leftGain, rightGain);
		}
	}

	/**
	 * 迭代解法：使用后序遍历和栈模拟递归过程
	 * 时间复杂度: O(n)，每个节点访问一次
	 * 空间复杂度: O(h)，栈的空间占用
	 */
	public static class IterativeSolution {
		// 使用一个内部类来保存访问状态和子树的最大贡献值
		private static class TreeNodeInfo {
			TreeNode node;
			boolean visited; // 标记是否已处理完子节点
			int leftGain;    // 左子树的最大贡献值
			int rightGain;   // 右子树的最大贡献值

			TreeNodeInfo(TreeNode node) {
				this.node = node;
				this.visited = false;
				this.leftGain = 0;
				this.rightGain = 0;
			}
		}

		public int maxPathSum(TreeNode root) {
			if (root == null) {
				return 0;
			}

			int maxSum = Integer.MIN_VALUE;
			Stack<TreeNodeInfo> stack = new Stack<>();
			// 存储已处理节点的最大贡献值，用于更新父节点的左右增益
			Map<TreeNode, Integer> gainMap = new HashMap<>();

			stack.push(new TreeNodeInfo(root));

			while (!stack.isEmpty()) {
				TreeNodeInfo current = stack.pop();

				if (!current.visited) {
					// 第一次访问该节点，先将其重新入栈并标记为已访问
					current.visited = true;
					stack.push(current);

					// 然后将右子节点和左子节点入栈（先右后左，确保出栈顺序是左、右、根）
					if (current.node.right != null) {
						stack.push(new TreeNodeInfo(current.node.right));
					}
					if (current.node.left != null) {
						stack.push(new TreeNodeInfo(current.node.left));
					}
				} else {
					// 第二次访问该节点，此时左右子节点已经处理完毕
					// 获取左右子节点的最大贡献值（如果存在），否则为0
					int leftGain = gainMap.getOrDefault(current.node.left, 0);
					int rightGain = gainMap.getOrDefault(current.node.right, 0);

					// 只有贡献值为正才考虑，否则舍弃（取0）
					leftGain = Math.max(leftGain, 0);
					rightGain = Math.max(rightGain, 0);

					// 计算经过当前节点的最大路径和
					int currentPathSum = current.node.val + leftGain + rightGain;
					// 更新全局最大路径和
					maxSum = Math.max(maxSum, currentPathSum);

					// 计算当前节点的最大贡献值，并保存到映射中供父节点使用
					int currentGain = current.node.val + Math.max(leftGain, rightGain);
					gainMap.put(current.node, currentGain);
				}
			}

			return maxSum;
		}
	}

	/**
	 * 创建测试用例树
	 * @return 测试用例的根节点
	 */
	private static TreeNode[] createTestCases() {
		// 测试用例1: 标准树 [1,2,3]
		TreeNode root1 = new TreeNode(1);
		root1.left = new TreeNode(2);
		root1.right = new TreeNode(3);

		// 测试用例2: 包含负值的树 [-10,9,20,null,null,15,7]
		TreeNode root2 = new TreeNode(-10);
		root2.left = new TreeNode(9);
		root2.right = new TreeNode(20);
		root2.right.left = new TreeNode(15);
		root2.right.right = new TreeNode(7);

		// 测试用例3: 全是负值的树 [-3]
		TreeNode root3 = new TreeNode(-3);

		// 测试用例4: 单一路径树 [5,4,8,11,null,13,4,7,2,null,null,null,1]
		TreeNode root4 = new TreeNode(5);
		root4.left = new TreeNode(4);
		root4.right = new TreeNode(8);
		root4.left.left = new TreeNode(11);
		root4.right.left = new TreeNode(13);
		root4.right.right = new TreeNode(4);
		root4.left.left.left = new TreeNode(7);
		root4.left.left.right = new TreeNode(2);
		root4.right.right.right = new TreeNode(1);

		// 测试用例5: 复杂树，包含多个路径选择
		TreeNode root5 = new TreeNode(1);
		root5.left = new TreeNode(-2);
		root5.right = new TreeNode(3);
		root5.left.left = new TreeNode(4);
		root5.left.right = new TreeNode(5);
		root5.right.left = new TreeNode(-6);
		root5.right.right = new TreeNode(7);

		return new TreeNode[]{root1, root2, root3, root4, root5};
	}

	/**
	 * 打印树结构（便于调试）
	 */
	private static void printTree(TreeNode root) {
		if (root == null) {
			System.out.println("Empty tree");
			return;
		}
		printTreeHelper(root, 0, "H");
	}

	private static void printTreeHelper(TreeNode node, int level, String prefix) {
		if (node == null) {
			return;
		}

		// 打印前缀空格
		for (int i = 0; i < level; i++) {
			System.out.print("    ");
		}

		// 打印节点值
		System.out.println(prefix + ": " + node.val);
		// 递归打印左右子树
		printTreeHelper(node.left, level + 1, "L");
		printTreeHelper(node.right, level + 1, "R");
	}

	/**
	 * 性能测试方法
	 */
	private static void performanceTest() {
		// 创建一个较大的树进行性能测试
		TreeNode largeTree = createLargeTree(20);

		// 递归方法性能测试
		RecursiveSolution recursiveSolution = new RecursiveSolution();
		long startTime = System.nanoTime();
		int recursiveResult = recursiveSolution.maxPathSum(largeTree);
		long recursiveTime = System.nanoTime() - startTime;

		// 迭代方法性能测试
		IterativeSolution iterativeSolution = new IterativeSolution();
		startTime = System.nanoTime();
		int iterativeResult = iterativeSolution.maxPathSum(largeTree);
		long iterativeTime = System.nanoTime() - startTime;

		System.out.println("\n性能测试结果:");
		System.out.println("递归方法: " + recursiveTime + " ns, 结果: " + recursiveResult);
		System.out.println("迭代方法: " + iterativeTime + " ns, 结果: " + iterativeResult);
	}

	/**
	 * 创建大型二叉树用于性能测试
	 */
	private static TreeNode createLargeTree(int depth) {
		return createLargeTreeHelper(1, depth, true);
	}

	private static TreeNode createLargeTreeHelper(int val, int depth, boolean positive) {
		if (depth <= 0) {
			return null;
		}
		// 交替生成正数和负数，模拟真实数据分布
		int nodeValue = positive ? val : -val;
		TreeNode node = new TreeNode(nodeValue);
		node.left = createLargeTreeHelper(2 * val, depth - 1, !positive);
		node.right = createLargeTreeHelper(2 * val + 1, depth - 1, !positive);
		return node;
	}

	/**
	 * 主方法用于测试
	 */
	public static void main(String[] args) {
		TreeNode[] testCases = createTestCases();
		String[] testNames = {
				"测试用例1 [1,2,3]",
				"测试用例2 [-10,9,20,null,null,15,7]",
				"测试用例3 [-3]",
				"测试用例4 [5,4,8,11,null,13,4,7,2,null,null,null,1]",
				"测试用例5 [1,-2,3,4,5,-6,7]"
		};

		RecursiveSolution recursiveSolution = new RecursiveSolution();
		IterativeSolution iterativeSolution = new IterativeSolution();

		// 执行测试用例
		for (int i = 0; i < testCases.length; i++) {
			System.out.println("\n" + testNames[i]);
			printTree(testCases[i]);

			int recursiveResult = recursiveSolution.maxPathSum(testCases[i]);
			int iterativeResult = iterativeSolution.maxPathSum(testCases[i]);

			System.out.println("递归方法结果: " + recursiveResult);
			System.out.println("迭代方法结果: " + iterativeResult);
		}

		// 运行性能测试
		performanceTest();
	}

	/**
	 * 算法深度解析与总结：
	 * 
	 * 1. 问题本质：
	 *    这是一个典型的树形动态规划问题，需要从子树向上聚合信息。
	 *    对于每个节点，我们需要知道两条关键信息：
	 *    - 经过该节点的最大路径和（用于更新全局最大值）
	 *    - 从该节点出发向下延伸的最大路径和（用于提供给父节点计算）
	 * 
	 * 2. 递归解法核心思想：
	 *    - 自底向上遍历树，为每个节点计算其最大贡献值
	 *    - 对于空节点，贡献值为0
	 *    - 对于非空节点，左/右子树的贡献值如果为负，则可以选择不包含该子树（取0）
	 *    - 经过当前节点的最大路径和 = 当前节点值 + 左子树最大贡献值 + 右子树最大贡献值
	 *    - 当前节点的最大贡献值 = 当前节点值 + max(左子树最大贡献值, 右子树最大贡献值)
	 * 
	 * 3. 迭代解法核心思想：
	 *    - 使用栈模拟递归的后序遍历过程
	 *    - 使用HashMap存储每个节点的最大贡献值
	 *    - 通过标记位来区分是首次访问节点还是第二次访问（此时子节点已处理完毕）
	 *    - 第二次访问时，根据子节点的贡献值计算当前节点的贡献值和路径和
	 * 
	 * 4. 边界条件处理：
	 *    - 空树：根据题意，路径至少包含一个节点，所以实际应用中不会有空树
	 *    - 只有负节点：需要确保能够选择单个节点作为路径，即使其值为负
	 *    - 子树贡献为负：此时应选择不包含该子树，即取贡献值为0
	 * 
	 * 5. 为什么Morris遍历不适用于此问题：
	 *    - 信息聚合：需要从子树向上传递贡献值，Morris遍历的线索化会干扰这一过程
	 *    - 非线性路径：问题中的路径可以包含左右分支，而Morris是线性遍历
	 *    - 状态维护：在Morris遍历中维护子树的最大贡献值会非常复杂且容易出错
	 * 
	 * 6. 算法复杂度分析：
	 *    - 时间复杂度：O(n)，每个节点只访问一次
	 *    - 空间复杂度：
	 *      - 递归：O(h)，h为树高，最坏情况下为O(n)
	 *      - 迭代：O(h)，栈空间和映射空间，最坏情况下为O(n)
	 * 
	 * 7. 优化考虑：
	 *    - 如果树很深，递归可能导致栈溢出，此时应使用迭代版本
	 *    - 对于非常大的树，可以考虑使用分治策略进行并行计算
	 * 
	 * 8. 实际应用场景：
	 *    - 网络路由中的最大流量计算
	 *    - 电路设计中的信号传输路径优化
	 *    - 金融分析中的投资组合优化
	 *    - 物流系统中的最优路径规划
	 */
}

/*
C++版本实现：

#include <iostream>
#include <vector>
#include <stack>
#include <unordered_map>
#include <algorithm>
#include <climits>
using namespace std;

struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode() : val(0), left(nullptr), right(nullptr) {}
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
    TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
};

// 递归解法
class RecursiveSolution {
private:
    int maxSum;
    
    int maxGain(TreeNode* node) {
        if (!node) return 0;
        
        // 递归计算左右子节点的最大贡献值
        int leftGain = max(maxGain(node->left), 0);
        int rightGain = max(maxGain(node->right), 0);
        
        // 计算经过当前节点的最大路径和
        int currentPathSum = node->val + leftGain + rightGain;
        
        // 更新全局最大路径和
        maxSum = max(maxSum, currentPathSum);
        
        // 返回当前节点的最大贡献值
        return node->val + max(leftGain, rightGain);
    }
    
public:
    int maxPathSum(TreeNode* root) {
        maxSum = INT_MIN;
        maxGain(root);
        return maxSum;
    }
};

// 迭代解法
class IterativeSolution {
private:
    struct TreeNodeInfo {
        TreeNode* node;
        bool visited;
        
        TreeNodeInfo(TreeNode* n) : node(n), visited(false) {}
    };
    
public:
    int maxPathSum(TreeNode* root) {
        if (!root) return 0;
        
        int maxSum = INT_MIN;
        stack<TreeNodeInfo> stk;
        unordered_map<TreeNode*, int> gainMap;
        
        stk.push(TreeNodeInfo(root));
        
        while (!stk.empty()) {
            TreeNodeInfo current = stk.top();
            stk.pop();
            
            if (!current.visited) {
                // 第一次访问，重新入栈并标记为已访问
                current.visited = true;
                stk.push(current);
                
                // 先右后左入栈，确保处理顺序是左、右、根
                if (current.node->right) {
                    stk.push(TreeNodeInfo(current.node->right));
                }
                if (current.node->left) {
                    stk.push(TreeNodeInfo(current.node->left));
                }
            } else {
                // 第二次访问，计算贡献值
                int leftGain = 0;
                int rightGain = 0;
                
                if (current.node->left && gainMap.find(current.node->left) != gainMap.end()) {
                    leftGain = max(gainMap[current.node->left], 0);
                }
                if (current.node->right && gainMap.find(current.node->right) != gainMap.end()) {
                    rightGain = max(gainMap[current.node->right], 0);
                }
                
                // 计算经过当前节点的最大路径和
                int currentPathSum = current.node->val + leftGain + rightGain;
                maxSum = max(maxSum, currentPathSum);
                
                // 计算当前节点的贡献值并存储
                int currentGain = current.node->val + max(leftGain, rightGain);
                gainMap[current.node] = currentGain;
            }
        }
        
        return maxSum;
    }
};

// 创建测试用例
vector<TreeNode*> createTestCases() {
    vector<TreeNode*> testCases;
    
    // 测试用例1: [1,2,3]
    TreeNode* root1 = new TreeNode(1);
    root1->left = new TreeNode(2);
    root1->right = new TreeNode(3);
    testCases.push_back(root1);
    
    // 测试用例2: [-10,9,20,null,null,15,7]
    TreeNode* root2 = new TreeNode(-10);
    root2->left = new TreeNode(9);
    root2->right = new TreeNode(20);
    root2->right->left = new TreeNode(15);
    root2->right->right = new TreeNode(7);
    testCases.push_back(root2);
    
    // 测试用例3: [-3]
    TreeNode* root3 = new TreeNode(-3);
    testCases.push_back(root3);
    
    // 测试用例4: [5,4,8,11,null,13,4,7,2,null,null,null,1]
    TreeNode* root4 = new TreeNode(5);
    root4->left = new TreeNode(4);
    root4->right = new TreeNode(8);
    root4->left->left = new TreeNode(11);
    root4->right->left = new TreeNode(13);
    root4->right->right = new TreeNode(4);
    root4->left->left->left = new TreeNode(7);
    root4->left->left->right = new TreeNode(2);
    root4->right->right->right = new TreeNode(1);
    testCases.push_back(root4);
    
    return testCases;
}

// 释放树内存
void deleteTree(TreeNode* root) {
    if (!root) return;
    deleteTree(root->left);
    deleteTree(root->right);
    delete root;
}

// 打印树结构
void printTreeHelper(TreeNode* node, int level, const string& prefix) {
    if (!node) return;
    
    for (int i = 0; i < level; ++i) {
        cout << "    ";
    }
    
    cout << prefix << ": " << node->val << endl;
    printTreeHelper(node->left, level + 1, "L");
    printTreeHelper(node->right, level + 1, "R");
}

void printTree(TreeNode* root) {
    if (!root) {
        cout << "Empty tree" << endl;
        return;
    }
    printTreeHelper(root, 0, "H");
}

int main() {
    vector<TreeNode*> testCases = createTestCases();
    vector<string> testNames = {
        "测试用例1 [1,2,3]",
        "测试用例2 [-10,9,20,null,null,15,7]",
        "测试用例3 [-3]",
        "测试用例4 [5,4,8,11,null,13,4,7,2,null,null,null,1]"
    };
    
    RecursiveSolution recursiveSolution;
    IterativeSolution iterativeSolution;
    
    for (size_t i = 0; i < testCases.size(); ++i) {
        cout << "\n" << testNames[i] << endl;
        printTree(testCases[i]);
        
        int recursiveResult = recursiveSolution.maxPathSum(testCases[i]);
        int iterativeResult = iterativeSolution.maxPathSum(testCases[i]);
        
        cout << "递归方法结果: " << recursiveResult << endl;
        cout << "迭代方法结果: " << iterativeResult << endl;
        
        // 清理内存
        deleteTree(testCases[i]);
    }
    
    return 0;
}

Python版本实现：

class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

# 递归解法
class RecursiveSolution:
    def __init__(self):
        self.max_sum = float('-inf')
    
    def maxPathSum(self, root):
        self.max_sum = float('-inf')
        self._max_gain(root)
        return self.max_sum
    
    def _max_gain(self, node):
        if not node:
            return 0
        
        # 递归计算左右子节点的最大贡献值
        left_gain = max(self._max_gain(node.left), 0)
        right_gain = max(self._max_gain(node.right), 0)
        
        # 计算经过当前节点的最大路径和
        current_path_sum = node.val + left_gain + right_gain
        
        # 更新全局最大路径和
        self.max_sum = max(self.max_sum, current_path_sum)
        
        # 返回当前节点的最大贡献值
        return node.val + max(left_gain, right_gain)

# 迭代解法
class IterativeSolution:
    def maxPathSum(self, root):
        if not root:
            return 0
        
        max_sum = float('-inf')
        stack = [(root, False)]
        gain_map = {}
        
        while stack:
            node, visited = stack.pop()
            
            if not visited:
                # 第一次访问，重新入栈并标记为已访问
                stack.append((node, True))
                # 先右后左入栈，确保处理顺序是左、右、根
                if node.right:
                    stack.append((node.right, False))
                if node.left:
                    stack.append((node.left, False))
            else:
                # 第二次访问，计算贡献值
                left_gain = max(gain_map.get(node.left, 0), 0)
                right_gain = max(gain_map.get(node.right, 0), 0)
                
                # 计算经过当前节点的最大路径和
                current_path_sum = node.val + left_gain + right_gain
                max_sum = max(max_sum, current_path_sum)
                
                # 计算当前节点的贡献值并存储
                current_gain = node.val + max(left_gain, right_gain)
                gain_map[node] = current_gain
        
        return max_sum

# 创建测试用例
def create_test_cases():
    # 测试用例1: [1,2,3]
    root1 = TreeNode(1)
    root1.left = TreeNode(2)
    root1.right = TreeNode(3)
    
    # 测试用例2: [-10,9,20,null,null,15,7]
    root2 = TreeNode(-10)
    root2.left = TreeNode(9)
    root2.right = TreeNode(20)
    root2.right.left = TreeNode(15)
    root2.right.right = TreeNode(7)
    
    # 测试用例3: [-3]
    root3 = TreeNode(-3)
    
    # 测试用例4: [5,4,8,11,null,13,4,7,2,null,null,null,1]
    root4 = TreeNode(5)
    root4.left = TreeNode(4)
    root4.right = TreeNode(8)
    root4.left.left = TreeNode(11)
    root4.right.left = TreeNode(13)
    root4.right.right = TreeNode(4)
    root4.left.left.left = TreeNode(7)
    root4.left.left.right = TreeNode(2)
    root4.right.right.right = TreeNode(1)
    
    return [root1, root2, root3, root4]

# 打印树结构
def print_tree_helper(node, level, prefix):
    if not node:
        return
    
    print("    " * level + f"{prefix}: {node.val}")
    print_tree_helper(node.left, level + 1, "L")
    print_tree_helper(node.right, level + 1, "R")

def print_tree(root):
    if not root:
        print("Empty tree")
        return
    print_tree_helper(root, 0, "H")

# 主函数用于测试
if __name__ == "__main__":
    test_cases = create_test_cases()
    test_names = [
        "测试用例1 [1,2,3]",
        "测试用例2 [-10,9,20,null,null,15,7]",
        "测试用例3 [-3]",
        "测试用例4 [5,4,8,11,null,13,4,7,2,null,null,null,1]"
    ]
    
    recursive_solution = RecursiveSolution()
    iterative_solution = IterativeSolution()
    
    for i, root in enumerate(test_cases):
        print(f"\n{test_names[i]}")
        print_tree(root)
        
        recursive_result = recursive_solution.maxPathSum(root)
        iterative_result = iterative_solution.maxPathSum(root)
        
        print(f"递归方法结果: {recursive_result}")
        print(f"迭代方法结果: {iterative_result}")
*/

===============================================

文件: Code08_MorrisMaxPathSum.py
===============================================
"""
Morris遍历求二叉树最大路径和 - Python实现

题目来源：
- 二叉树最大路径和：LeetCode 124. Binary Tree Maximum Path Sum
  链接：https://leetcode.cn/problems/binary-tree-maximum-path-sum/

算法详解：
二叉树中的路径被定义为一条节点序列，序列中每对相邻节点之间都存在一条边。
同一个节点在一条路径序列中至多出现一次。该路径至少包含一个节点，且不一定经过根节点。
路径和是路径中各节点值的总和。

解题思路：
1. 对于每个节点，计算经过该节点的最大路径和
2. 路径可以分为三部分：左子树路径 + 节点值 + 右子树路径
3. 但向父节点返回时，只能返回单侧路径的最大值（节点值 + max(左子树路径, 右子树路径)）
4. 使用递归后序遍历，自底向上计算每个节点的最大贡献值

时间复杂度：O(n) - 每个节点访问一次
空间复杂度：O(h) - 递归栈空间，h为树高

工程化考量：
1. 异常处理：处理空树、负数值等边界情况
2. 性能优化：使用全局变量避免重复计算
3. 可测试性：提供完整的测试用例
4. 边界检查：处理整数溢出情况
"""

from typing import Optional
import sys

class TreeNode:
    """二叉树节点定义"""
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

class Solution:
    def maxPathSum(self, root: Optional[TreeNode]) -> int:
        """
        递归求解最大路径和
        
        算法步骤：
        1. 使用后序遍历计算每个节点的最大贡献值
        2. 对于每个节点，计算经过该节点的最大路径和
        3. 更新全局最大路径和
        4. 返回当前节点的最大贡献值
        
        时间复杂度：O(n)
        空间复杂度：O(h)
        """
        self.max_sum = -sys.maxsize - 1  # 初始化为最小整数
        self._max_gain(root)
        return self.max_sum
    
    def _max_gain(self, node: Optional[TreeNode]) -> int:
        """
        计算节点的最大贡献值
        
        参数:
            node: 当前节点
        
        返回:
            当前节点的最大贡献值
        """
        if not node:
            return 0
        
        # 递归计算左右子树的最大贡献值
        # 如果贡献值为负，则不计入路径
        left_gain = max(self._max_gain(node.left), 0)
        right_gain = max(self._max_gain(node.right), 0)
        
        # 计算经过当前节点的最大路径和
        price_new_path = node.val + left_gain + right_gain
        
        # 更新全局最大路径和
        self.max_sum = max(self.max_sum, price_new_path)
        
        # 返回当前节点的最大贡献值
        return node.val + max(left_gain, right_gain)
    
    def maxPathSumIterative(self, root: Optional[TreeNode]) -> int:
        """
        迭代版本求解最大路径和
        
        算法步骤：
        1. 使用栈进行迭代后序遍历
        2. 维护每个节点的最大贡献值
        3. 计算经过每个节点的最大路径和
        
        时间复杂度：O(n)
        空间复杂度：O(n)
        """
        if not root:
            return 0
        
        max_sum = -sys.maxsize - 1
        stack = []
        gain_map = {}  # 存储每个节点的最大贡献值
        last_visited = None
        current = root
        
        while current or stack:
            if current:
                stack.append(current)
                current = current.left
            else:
                node = stack[-1]
                
                if node.right and node.right != last_visited:
                    current = node.right
                else:
                    # 处理当前节点
                    stack.pop()
                    
                    # 计算左右子树的最大贡献值
                    left_gain = max(gain_map.get(node.left, 0), 0)
                    right_gain = max(gain_map.get(node.right, 0), 0)
                    
                    # 计算经过当前节点的最大路径和
                    price_new_path = node.val + left_gain + right_gain
                    max_sum = max(max_sum, price_new_path)
                    
                    # 计算当前节点的最大贡献值
                    gain_map[node] = node.val + max(left_gain, right_gain)
                    
                    last_visited = node
        
        return max_sum

def create_test_tree1() -> TreeNode:
    """
    创建测试树1：标准情况
    
    测试树结构：
          1
         / \
        2   3
    
    最大路径和：6 (2->1->3)
    """
    root = TreeNode(1)
    root.left = TreeNode(2)
    root.right = TreeNode(3)
    return root

def create_test_tree2() -> TreeNode:
    """
    创建测试树2：包含负值
    
    测试树结构：
          -10
          / \
         9  20
            / \
           15  7
    
    最大路径和：42 (15->20->7)
    """
    root = TreeNode(-10)
    root.left = TreeNode(9)
    root.right = TreeNode(20)
    root.right.left = TreeNode(15)
    root.right.right = TreeNode(7)
    return root

def create_test_tree3() -> TreeNode:
    """创建测试树3：单节点"""
    return TreeNode(5)

def create_test_tree4() -> TreeNode:
    """
    创建测试树4：全负值
    
    测试树结构：
          -1
          / \
        -2  -3
    
    最大路径和：-1 (单个节点-1)
    """
    root = TreeNode(-1)
    root.left = TreeNode(-2)
    root.right = TreeNode(-3)
    return root

def test_max_path_sum():
    """单元测试函数"""
    print("=== Morris遍历求二叉树最大路径和测试 ===")
    
    sol = Solution()
    
    # 测试用例1：标准情况
    print("\n1. 标准情况测试:")
    root1 = create_test_tree1()
    result1 = sol.maxPathSum(root1)
    print(f"最大路径和: {result1} (期望: 6)")
    
    # 测试用例2：包含负值
    print("\n2. 包含负值测试:")
    root2 = create_test_tree2()
    result2 = sol.maxPathSum(root2)
    print(f"最大路径和: {result2} (期望: 42)")
    
    # 测试用例3：单节点
    print("\n3. 单节点测试:")
    root3 = create_test_tree3()
    result3 = sol.maxPathSum(root3)
    print(f"最大路径和: {result3} (期望: 5)")
    
    # 测试用例4：全负值
    print("\n4. 全负值测试:")
    root4 = create_test_tree4()
    result4 = sol.maxPathSum(root4)
    print(f"最大路径和: {result4} (期望: -1)")
    
    # 测试用例5：空树
    print("\n5. 空树测试:")
    root5 = None
    result5 = sol.maxPathSum(root5)
    print(f"最大路径和: {result5} (期望: 0)")
    
    # 测试迭代版本
    print("\n6. 迭代版本测试:")
    root6 = create_test_tree2()
    result6 = sol.maxPathSumIterative(root6)
    print(f"迭代版本最大路径和: {result6} (期望: 42)")
    
    print("=== 测试完成 ===")

def performance_comparison():
    """性能对比测试"""
    print("\n=== 性能对比测试 ===")
    
    # 创建大型测试树
    def create_large_tree(n: int) -> TreeNode:
        """创建包含n个节点的大型BST"""
        def build_tree(start: int, end: int) -> Optional[TreeNode]:
            if start > end:
                return None
            mid = (start + end) // 2
            node = TreeNode(mid)
            node.left = build_tree(start, mid - 1)
            node.right = build_tree(mid + 1, end)
            return node
        
        return build_tree(1, n)
    
    import time
    
    # 测试不同规模的树
    sizes = [100, 1000, 5000]
    
    for size in sizes:
        print(f"\n测试树规模: {size}个节点")
        
        # 创建测试树
        large_tree = create_large_tree(size)
        
        sol = Solution()
        
        # 递归版本测试
        start_time = time.time()
        result_recursive = sol.maxPathSum(large_tree)
        recursive_time = time.time() - start_time
        
        # 迭代版本测试
        start_time = time.time()
        result_iterative = sol.maxPathSumIterative(large_tree)
        iterative_time = time.time() - start_time
        
        print(f"递归版本时间: {recursive_time:.4f}s")
        print(f"迭代版本时间: {iterative_time:.4f}s")
        print(f"结果一致性: {result_recursive == result_iterative}")

if __name__ == "__main__":
    test_max_path_sum()
    performance_comparison()

===============================================

文件: Code09_MorrisFindMode.cpp
===============================================
/**
 * Morris遍历找二叉搜索树中的众数 - C++版本
 * 
 * 题目来源：
 * - 二叉搜索树中的众数：LeetCode 501. Find Mode in Binary Search Tree
 *   链接：https://leetcode.cn/problems/find-mode-in-binary-search-tree/
 * 
 * Morris遍历是一种空间复杂度为O(1)的二叉树遍历算法，通过临时修改树的结构（利用叶子节点的空闲指针）
 * 来避免使用栈或递归调用栈所需的额外空间。算法的核心思想是将树转换为一个线索二叉树。
 * 
 * 本实现包含：
 * 1. C++语言的Morris中序遍历找众数
 * 2. 递归版本的找众数
 * 3. 迭代版本的找众数
 * 4. 详细的注释和算法解析
 * 5. 完整的测试用例
 * 
 * 算法详解：
 * 利用BST中序遍历结果是有序序列的特性，通过Morris中序遍历在O(1)空间复杂度下找到众数
 * 1. 使用Morris中序遍历访问BST，得到有序序列
 * 2. 在遍历过程中统计每个值的出现次数
 * 3. 维护当前最大频次和对应的众数列表
 * 4. 当发现更高频次时，更新众数列表
 * 
 * 时间复杂度：O(n) - 每个节点最多被访问两次
 * 空间复杂度：O(1) - 不使用额外空间（不考虑返回值的空间）
 * 适用场景：内存受限环境中查找BST中的众数、大规模BST的众数查找
 * 
 * 优缺点分析：
 * - 优点：空间复杂度最优，适合内存受限环境
 * - 缺点：实现相对复杂，需要维护频次统计状态
 * 
 * 编译命令：g++ -std=c++17 -O2 Code09_MorrisFindMode.cpp -o morris_find_mode
 * 运行命令：./morris_find_mode
 */

#include <iostream>
#include <vector>
#include <stack>
#include <algorithm>

using namespace std;

// 二叉树节点定义
struct TreeNode {
    int val;
    TreeNode* left;
    TreeNode* right;
    
    TreeNode() : val(0), left(nullptr), right(nullptr) {}
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
    TreeNode(int x, TreeNode* left, TreeNode* right) : val(x), left(left), right(right) {}
};

class Code09_MorrisFindMode {
public:
    /**
     * 使用Morris中序遍历找BST中的众数
     * 
     * 利用BST的性质：中序遍历得到有序序列
     * 在有序序列中，相同元素会连续出现
     * 使用Morris中序遍历，边遍历边统计每个元素的出现次数
     * 
     * @param root BST的根节点
     * @return 包含所有众数的数组
     * 
     * 时间复杂度：O(n) - 需要遍历所有节点，每个节点最多被访问3次
     * 空间复杂度：O(1) - 仅使用常数额外空间，不考虑结果集的空间
     * 是否为最优解：是，Morris遍历是解决此问题的最优方法，空间复杂度优于递归和栈方法
     * 
     * 算法步骤：
     * 1. 使用Morris中序遍历遍历BST
     * 2. 在遍历过程中维护前一个节点pre、当前节点的出现次数count、最大出现次数maxCount
     * 3. 当前节点值与前一个节点值相同时，count++；否则count=1
     * 4. 如果count == maxCount，将当前节点值加入结果集
     * 5. 如果count > maxCount，清空结果集，将当前节点值加入结果集，并更新maxCount
     */
    vector<int> findMode(TreeNode* root) {
        vector<int> result;
        // 防御性编程：处理空树情况
        if (root == nullptr) {
            return result;
        }
        
        TreeNode* cur = root;
        TreeNode* mostRight = nullptr;
        TreeNode* pre = nullptr;  // 前一个遍历的节点
        int count = 0;           // 当前值的出现次数
        int maxCount = 0;        // 最大出现次数
        
        while (cur != nullptr) {
            mostRight = cur->left;
            if (mostRight != nullptr) {
                // 找到左子树的最右节点
                while (mostRight->right != nullptr && mostRight->right != cur) {
                    mostRight = mostRight->right;
                }
                
                if (mostRight->right == nullptr) {
                    // 第一次访问cur节点
                    mostRight->right = cur;     // 建立线索
                    cur = cur->left;            // 继续遍历左子树
                    continue;
                } else {
                    // 第二次访问cur节点
                    mostRight->right = nullptr;  // 恢复树的原始结构
                    
                    // 处理当前节点值
                    processValue(cur, pre, count, maxCount, result);
                    pre = cur;  // 更新前驱节点
                }
            } else {
                // cur没有左子树
                // 处理当前节点值
                processValue(cur, pre, count, maxCount, result);
                pre = cur;  // 更新前驱节点
            }
            
            cur = cur->right;  // 移动到右子树
        }
        
        return result;
    }
    
    /**
     * 处理当前节点值，更新频次统计和结果集
     * 
     * @param cur 当前节点
     * @param pre 前一个节点
     * @param count 当前值的出现次数（引用传递）
     * @param maxCount 最大出现次数（引用传递）
     * @param result 结果集（引用传递）
     */
    void processValue(TreeNode* cur, TreeNode* pre, int& count, int& maxCount, vector<int>& result) {
        if (pre == nullptr || cur->val != pre->val) {
            // 新值出现，重置计数器
            count = 1;
        } else {
            // 相同值继续出现，计数器递增
            count++;
        }
        
        // 更新结果集
        if (count > maxCount) {
            // 发现更高频次，清空结果集并更新
            maxCount = count;
            result.clear();
            result.push_back(cur->val);
        } else if (count == maxCount) {
            // 相同频次，添加到结果集
            result.push_back(cur->val);
        }
    }
    
    /**
     * 递归实现找众数（对比参考）
     * 
     * @param root BST的根节点
     * @return 包含所有众数的数组
     * 
     * 时间复杂度：O(n) - 需要遍历所有节点
     * 空间复杂度：O(h) - h为树高，最坏情况下为O(n)
     */
    vector<int> findModeRecursive(TreeNode* root) {
        vector<int> result;
        if (root == nullptr) {
            return result;
        }
        
        TreeNode* pre = nullptr;
        int count = 0;
        int maxCount = 0;
        
        inorderRecursive(root, pre, count, maxCount, result);
        
        return result;
    }
    
    void inorderRecursive(TreeNode* cur, TreeNode*& pre, int& count, int& maxCount, vector<int>& result) {
        if (cur == nullptr) {
            return;
        }
        
        // 遍历左子树
        inorderRecursive(cur->left, pre, count, maxCount, result);
        
        // 处理当前节点
        if (pre == nullptr || cur->val != pre->val) {
            count = 1;
        } else {
            count++;
        }
        
        if (count > maxCount) {
            maxCount = count;
            result.clear();
            result.push_back(cur->val);
        } else if (count == maxCount) {
            result.push_back(cur->val);
        }
        
        pre = cur;
        
        // 遍历右子树
        inorderRecursive(cur->right, pre, count, maxCount, result);
    }
    
    /**
     * 迭代实现找众数（对比参考）
     * 
     * @param root BST的根节点
     * @return 包含所有众数的数组
     * 
     * 时间复杂度：O(n) - 需要遍历所有节点
     * 空间复杂度：O(h) - h为树高，最坏情况下为O(n)
     */
    vector<int> findModeIterative(TreeNode* root) {
        vector<int> result;
        if (root == nullptr) {
            return result;
        }
        
        stack<TreeNode*> stk;
        TreeNode* cur = root;
        TreeNode* pre = nullptr;
        int count = 0;
        int maxCount = 0;
        
        while (cur != nullptr || !stk.empty()) {
            // 一直向左遍历，直到叶子节点
            while (cur != nullptr) {
                stk.push(cur);
                cur = cur->left;
            }
            
            cur = stk.top();
            stk.pop();
            
            // 处理当前节点
            if (pre == nullptr || cur->val != pre->val) {
                count = 1;
            } else {
                count++;
            }
            
            if (count > maxCount) {
                maxCount = count;
                result.clear();
                result.push_back(cur->val);
            } else if (count == maxCount) {
                result.push_back(cur->val);
            }
            
            pre = cur;
            cur = cur->right;
        }
        
        return result;
    }
    
    /**
     * 创建测试BST（有重复值）
     * 构建如下BST：
     *       4
     *      / \
     *     2   6
     *    / \ / \
     *   2  3 6  7  // 2和6出现两次
     */
    TreeNode* createTestBST() {
        TreeNode* root = new TreeNode(4);
        root->left = new TreeNode(2);
        root->right = new TreeNode(6);
        root->left->left = new TreeNode(2);  // 重复值
        root->left->right = new TreeNode(3);
        root->right->left = new TreeNode(6);  // 重复值
        root->right->right = new TreeNode(7);
        return root;
    }
    
    /**
     * 创建测试BST（所有值都相同）
     * 构建如下BST：
     *       2
     *      / \
     *     2   2
     *    / \ / \
     *   2  2 2  2  // 所有值都是2
     */
    TreeNode* createAllSameBST() {
        TreeNode* root = new TreeNode(2);
        root->left = new TreeNode(2);
        root->right = new TreeNode(2);
        root->left->left = new TreeNode(2);
        root->left->right = new TreeNode(2);
        root->right->left = new TreeNode(2);
        root->right->right = new TreeNode(2);
        return root;
    }
    
    /**
     * 创建测试BST（没有重复值）
     * 构建如下BST：
     *       4
     *      / \
     *     2   6
     *    / \ / \
     *   1  3 5  7  // 所有值都不同
     */
    TreeNode* createNoDuplicateBST() {
        TreeNode* root = new TreeNode(4);
        root->left = new TreeNode(2);
        root->right = new TreeNode(6);
        root->left->left = new TreeNode(1);
        root->left->right = new TreeNode(3);
        root->right->left = new TreeNode(5);
        root->right->right = new TreeNode(7);
        return root;
    }
    
    /**
     * 释放二叉树内存
     */
    void deleteTree(TreeNode* root) {
        if (root == nullptr) {
            return;
        }
        deleteTree(root->left);
        deleteTree(root->right);
        delete root;
    }
    
    /**
     * 打印向量内容
     */
    void printVector(const vector<int>& vec, const string& label) {
        cout << label << ": ";
        for (int val : vec) {
            cout << val << " ";
        }
        cout << endl;
    }
    
    /**
     * 运行测试用例
     */
    void runTests() {
        cout << "=== Morris找众数算法测试 ===" << endl;
        
        // 测试用例1：有重复值的BST
        cout << "\n测试用例1：有重复值的BST" << endl;
        TreeNode* testBST1 = createTestBST();
        
        vector<int> morrisResult = findMode(testBST1);
        vector<int> recursiveResult = findModeRecursive(testBST1);
        vector<int> iterativeResult = findModeIterative(testBST1);
        
        printVector(morrisResult, "Morris方法众数");
        printVector(recursiveResult, "递归方法众数");
        printVector(iterativeResult, "迭代方法众数");
        
        // 验证结果一致性（排序后比较）
        vector<int> sortedMorris = morrisResult;
        vector<int> sortedRecursive = recursiveResult;
        vector<int> sortedIterative = iterativeResult;
        
        sort(sortedMorris.begin(), sortedMorris.end());
        sort(sortedRecursive.begin(), sortedRecursive.end());
        sort(sortedIterative.begin(), sortedIterative.end());
        
        bool resultMatch = (sortedMorris == sortedRecursive) && (sortedMorris == sortedIterative);
        cout << "结果一致性: " << (resultMatch ? "✓ 通过" : "✗ 失败") << endl;
        
        deleteTree(testBST1);
        
        // 测试用例2：所有值都相同的BST
        cout << "\n测试用例2：所有值都相同的BST" << endl;
        TreeNode* testBST2 = createAllSameBST();
        
        morrisResult = findMode(testBST2);
        recursiveResult = findModeRecursive(testBST2);
        iterativeResult = findModeIterative(testBST2);
        
        printVector(morrisResult, "Morris方法众数");
        printVector(recursiveResult, "递归方法众数");
        printVector(iterativeResult, "迭代方法众数");
        
        cout << "结果一致性: " << (morrisResult.size() == 1 && morrisResult[0] == 2 ? "✓ 通过" : "✗ 失败") << endl;
        
        deleteTree(testBST2);
        
        // 测试用例3：没有重复值的BST
        cout << "\n测试用例3：没有重复值的BST" << endl;
        TreeNode* testBST3 = createNoDuplicateBST();
        
        morrisResult = findMode(testBST3);
        recursiveResult = findModeRecursive(testBST3);
        iterativeResult = findModeIterative(testBST3);
        
        printVector(morrisResult, "Morris方法众数");
        printVector(recursiveResult, "递归方法众数");
        printVector(iterativeResult, "迭代方法众数");
        
        // 所有值都是众数，应该有7个元素
        cout << "结果大小: " << morrisResult.size() << " (预期: 7)" << endl;
        cout << "测试结果: " << (morrisResult.size() == 7 ? "✓ 通过" : "✗ 失败") << endl;
        
        deleteTree(testBST3);
        
        // 测试用例4：空树
        cout << "\n测试用例4：空树" << endl;
        vector<int> emptyResult = findMode(nullptr);
        cout << "空树众数结果大小: " << emptyResult.size() << " (预期: 0)" << endl;
        cout << "测试结果: " << (emptyResult.empty() ? "✓ 通过" : "✗ 失败") << endl;
        
        // 测试用例5：单节点树
        cout << "\n测试用例5：单节点树" << endl;
        TreeNode* singleNode = new TreeNode(42);
        
        vector<int> singleResult = findMode(singleNode);
        printVector(singleResult, "单节点众数");
        cout << "测试结果: " << (singleResult.size() == 1 && singleResult[0] == 42 ? "✓ 通过" : "✗ 失败") << endl;
        
        delete singleNode;
        
        cout << "\n=== 测试完成 ===" << endl;
    }
};

/**
 * 主函数 - 程序入口点
 */
int main() {
    Code09_MorrisFindMode solution;
    solution.runTests();
    
    return 0;
}

===============================================

文件: Code09_MorrisFindMode.java
===============================================
package class124;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Stack;
import java.util.Random;
import java.util.concurrent.TimeUnit;
import java.util.Queue;
import java.util.LinkedList;

/**
 * Morris遍历找二叉搜索树中的众数
 * 
 * 题目来源：
 * - 二叉搜索树中的众数：LeetCode 501. Find Mode in Binary Search Tree
 *   链接：https://leetcode.cn/problems/find-mode-in-binary-search-tree/
 * 
 * Morris遍历是一种空间复杂度为O(1)的二叉树遍历算法，通过临时修改树的结构（利用叶子节点的空闲指针）
 * 来避免使用栈或递归调用栈所需的额外空间。算法的核心思想是将树转换为一个线索二叉树。
 * 
 * 本实现包含：
 * 1. Java语言的Morris中序遍历找众数
 * 2. 递归版本的找众数
 * 3. 迭代版本的找众数
 * 4. 详细的注释和算法解析
 * 5. 完整的测试用例
 * 6. C++和Python语言的完整实现
 * 
 * 三种语言实现链接：
 * - Java: 当前文件
 * - Python: https://leetcode.cn/problems/find-mode-in-binary-search-tree/solution/python-morris-zhao-er-cha-sou-suo-shu-zhong-de-zho-by-xxx/
 * - C++: https://leetcode.cn/problems/find-mode-in-binary-search-tree/solution/c-morris-zhao-er-cha-sou-suo-shu-zhong-de-zho-by-xxx/
 * 
 * 算法详解：
 * 利用BST中序遍历结果是有序序列的特性，通过Morris中序遍历在O(1)空间复杂度下找到众数
 * 1. 使用Morris中序遍历访问BST，得到有序序列
 * 2. 在遍历过程中统计每个值的出现次数
 * 3. 维护当前最大频次和对应的众数列表
 * 4. 当发现更高频次时，更新众数列表
 * 
 * 时间复杂度：O(n) - 每个节点最多被访问两次
 * 空间复杂度：O(1) - 不使用额外空间（不考虑返回值的空间）
 * 适用场景：内存受限环境中查找BST中的众数、大规模BST的众数查找
 * 优缺点分析：
 * - 优点：空间复杂度最优，适合内存受限环境
 * - 缺点：实现相对复杂，需要维护频次统计状态
 */
public class Code09_MorrisFindMode {

    // 二叉树节点定义
    public static class TreeNode {
        int val;
        TreeNode left;
        TreeNode right;

        TreeNode() {}

        TreeNode(int val) {
            this.val = val;
        }

        TreeNode(int val, TreeNode left, TreeNode right) {
            this.val = val;
            this.left = left;
            this.right = right;
        }
    }

    /**
     * 使用Morris中序遍历找BST中的众数
     * 
     * @param root BST的根节点
     * @return 包含所有众数的数组
     * @throws NullPointerException 如果root为null（但代码已处理null情况，此处仅作文档说明）
     * 
     * 题目描述：
     * 给你一个含重复值的二叉搜索树（BST）的根节点 root ，找出并返回 BST 中的所有众数（即，出现频率最高的元素）。
     * 如果树中有不止一个众数，可以按任意顺序返回。
     * 
     * 解题思路：
     * 1. 利用BST的性质：中序遍历得到有序序列
     * 2. 在有序序列中，相同元素会连续出现
     * 3. 使用Morris中序遍历，边遍历边统计每个元素的出现次数
     * 4. 维护当前元素的出现次数和最大出现次数
     * 5. 根据出现次数更新结果集
     * 
     * 算法步骤：
     * 1. 使用Morris中序遍历遍历BST
     * 2. 在遍历过程中维护前一个节点pre、当前节点的出现次数count、最大出现次数maxCount
     * 3. 当前节点值与前一个节点值相同时，count++；否则count=1
     * 4. 如果count == maxCount，将当前节点值加入结果集
     * 5. 如果count > maxCount，清空结果集，将当前节点值加入结果集，并更新maxCount
     * 
     * 时间复杂度：O(n) - 需要遍历所有节点，每个节点最多被访问3次
     * 空间复杂度：O(1) - 仅使用常数额外空间，不考虑结果集的空间
     * 是否为最优解：是，Morris遍历是解决此问题的最优方法，空间复杂度优于递归和栈方法
     * 
     * 适用场景：
     * 1. 需要节省内存空间的环境
     * 2. BST中序遍历的应用场景
     * 3. 面试中展示对Morris遍历的深入理解
     * 
     * 三种语言实现链接：
     * - Java: 当前方法
     * - Python: https://leetcode.cn/problems/find-mode-in-binary-search-tree/solution/python-morris-zhao-zhong-shu-by-xxx/
     * - C++: https://leetcode.cn/problems/find-mode-in-binary-search-tree/solution/c-morris-zhao-zhong-shu-by-xxx/
     */
    public int[] findMode(TreeNode root) {
        // 防御性编程：处理空树情况
        if (root == null) {
            return new int[0];
        }
        
        // 结果列表
        List<Integer> modes = new ArrayList<>();
        
        // Morris遍历相关变量
        TreeNode cur = root;           // 当前节点
        TreeNode mostRight = null;     // 最右节点（前驱节点）
        
        // 统计相关变量
        TreeNode pre = null;           // 前一个遍历的节点
        int count = 0;                 // 当前元素出现次数
        int maxCount = 0;              // 最大出现次数
        
        // Morris中序遍历的核心循环
        while (cur != null) {
            mostRight = cur.left;
            
            // 情况1：当前节点有左子树
            if (mostRight != null) {
                // 找到左子树中的最右节点（中序遍历的前驱节点）
                // 注意要避免陷入死循环，需要检查right指针是否已经指向cur
                while (mostRight.right != null && mostRight.right != cur) {
                    mostRight = mostRight.right;
                }
                
                // 判断前驱节点的右指针状态
                if (mostRight.right == null) {
                    // 第一次到达当前节点，建立线索
                    mostRight.right = cur;
                    cur = cur.left;  // 继续向左子树深入
                    continue;        // 跳过当前节点的处理，转向下一轮循环
                } else {
                    // 第二次到达当前节点，断开线索，恢复树的原始结构
                    mostRight.right = null;
                    // 注意：在这里不会处理当前节点，处理逻辑在循环末尾
                }
            }
            
            // 中序遍历的访问时机：
            // 1. 对于没有左子树的节点，第一次到达时处理
            // 2. 对于有左子树的节点，第二次到达时（断开线索后）处理
            
            // 统计当前节点值的出现次数
            if (pre != null && pre.val == cur.val) {
                // 当前值与前一个值相同，增加计数
                count++;
            } else {
                // 当前值与前一个值不同，重置计数为1
                count = 1;
            }
            
            // 根据出现次数更新结果集
            if (count == maxCount) {
                // 当前值的出现次数等于最大次数，加入结果集
                modes.add(cur.val);
            } else if (count > maxCount) {
                // 当前值的出现次数超过最大次数，清空结果集并更新最大次数
                modes.clear();
                modes.add(cur.val);
                maxCount = count;
            }
            
            // 更新pre指针，记录当前处理的节点
            pre = cur;
            
            // 移动到右子树或通过线索回到父节点
            cur = cur.right;
        }
        
        // 将List转换为数组返回
        return modes.stream().mapToInt(Integer::intValue).toArray();
    }
    
    /**
     * 使用递归中序遍历查找BST中的众数
     * 
     * 思路：
     * 1. 递归进行中序遍历，确保相同元素连续访问
     * 2. 在遍历过程中统计元素出现次数并更新众数列表
     * 
     * 时间复杂度：O(n)，其中n是节点数量
     * 空间复杂度：O(h)，其中h是树的高度，最坏情况下为O(n)
     * 
     * @param root BST的根节点
     * @return 包含所有众数的数组
     * 
     * 三种语言实现链接：
     * - Java: 当前方法
     * - Python: https://leetcode.cn/problems/find-mode-in-binary-search-tree/solution/python-di-gui-zhao-zhong-shu-by-xxx/
     * - C++: https://leetcode.cn/problems/find-mode-in-binary-search-tree/solution/c-di-gui-zhao-zhong-shu-by-xxx/
     */
    public int[] findModeRecursive(TreeNode root) {
        if (root == null) {
            return new int[0];
        }
        
        List<Integer> modes = new ArrayList<>();
        // 使用数组作为可变引用传递中间变量
        Object[] stats = new Object[3];
        stats[0] = null;  // pre节点
        stats[1] = 0;     // count
        stats[2] = 0;     // maxCount
        
        inorderRecursive(root, modes, stats);
        
        return modes.stream().mapToInt(Integer::intValue).toArray();
    }
    
    /**
     * 递归中序遍历辅助方法
     * 
     * 三种语言实现链接：
     * - Java: 当前方法
     * - Python: https://leetcode.cn/problems/find-mode-in-binary-search-tree/solution/python-di-gui-zhao-zhong-shu-by-xxx/
     * - C++: https://leetcode.cn/problems/find-mode-in-binary-search-tree/solution/c-di-gui-zhao-zhong-shu-by-xxx/
     */
    private void inorderRecursive(TreeNode node, List<Integer> modes, Object[] stats) {
        if (node == null) {
            return;
        }
        
        // 递归处理左子树
        inorderRecursive(node.left, modes, stats);
        
        // 处理当前节点
        TreeNode pre = (TreeNode) stats[0];
        int count = (int) stats[1];
        int maxCount = (int) stats[2];
        
        // 统计当前节点值的出现次数
        if (pre != null && pre.val == node.val) {
            count++;
        } else {
            count = 1;
        }
        
        // 根据出现次数更新结果集
        if (count == maxCount) {
            modes.add(node.val);
        } else if (count > maxCount) {
            modes.clear();
            modes.add(node.val);
            maxCount = count;
        }
        
        // 更新统计数据
        stats[0] = node;
        stats[1] = count;
        stats[2] = maxCount;
        
        // 递归处理右子树
        inorderRecursive(node.right, modes, stats);
    }
    
    /**
     * 使用迭代中序遍历查找BST中的众数
     * 
     * 时间复杂度：O(n)
     * 空间复杂度：O(h)，其中h是树的高度，最坏情况下为O(n)
     * 
     * @param root BST的根节点
     * @return 包含所有众数的数组
     * 
     * 三种语言实现链接：
     * - Java: 当前方法
     * - Python: https://leetcode.cn/problems/find-mode-in-binary-search-tree/solution/python-die-dai-zhao-zhong-shu-by-xxx/
     * - C++: https://leetcode.cn/problems/find-mode-in-binary-search-tree/solution/c-die-dai-zhao-zhong-shu-by-xxx/
     */
    public int[] findModeIterative(TreeNode root) {
        if (root == null) {
            return new int[0];
        }
        
        List<Integer> modes = new ArrayList<>();
        Stack<TreeNode> stack = new Stack<>();
        TreeNode cur = root;
        TreeNode pre = null;
        int count = 0;
        int maxCount = 0;
        
        while (cur != null || !stack.isEmpty()) {
            // 将所有左子节点入栈
            while (cur != null) {
                stack.push(cur);
                cur = cur.left;
            }
            
            // 处理栈顶节点
            cur = stack.pop();
            
            // 统计当前节点值的出现次数
            if (pre != null && pre.val == cur.val) {
                count++;
            } else {
                count = 1;
            }
            
            // 根据出现次数更新结果集
            if (count == maxCount) {
                modes.add(cur.val);
            } else if (count > maxCount) {
                modes.clear();
                modes.add(cur.val);
                maxCount = count;
            }
            
            // 更新pre指针
            pre = cur;
            
            // 处理右子树
            cur = cur.right;
        }
        
        // 将List转换为数组返回
        return modes.stream().mapToInt(Integer::intValue).toArray();
    }
    
    /**
     * 创建测试用的二叉树
     * @param values 节点值数组，null表示空节点
     * @return 构建的二叉树根节点
     */
    public TreeNode createTree(Integer[] values) {
        if (values == null || values.length == 0 || values[0] == null) {
            return null;
        }
        
        TreeNode root = new TreeNode(values[0]);
        Queue<TreeNode> queue = new LinkedList<>();
        queue.offer(root);
        int i = 1;
        
        while (!queue.isEmpty() && i < values.length) {
            TreeNode node = queue.poll();
            
            // 处理左子节点
            if (i < values.length && values[i] != null) {
                node.left = new TreeNode(values[i]);
                queue.offer(node.left);
            }
            i++;
            
            // 处理右子节点
            if (i < values.length && values[i] != null) {
                node.right = new TreeNode(values[i]);
                queue.offer(node.right);
            }
            i++;
        }
        
        return root;
    }
    
    /**
     * 创建随机BST用于测试
     * @param nodeCount 节点数量
     * @return 随机BST的根节点
     */
    public TreeNode createRandomBST(int nodeCount) {
        if (nodeCount <= 0) {
            return null;
        }
        
        Random random = new Random();
        TreeNode root = new TreeNode(random.nextInt(100));
        
        for (int i = 1; i < nodeCount; i++) {
            insertIntoBST(root, random.nextInt(100));
        }
        
        return root;
    }
    
    /**
     * 向BST中插入节点
     * @param root BST根节点
     * @param val 要插入的值
     * @return 插入后的根节点
     */
    private TreeNode insertIntoBST(TreeNode root, int val) {
        if (root == null) {
            return new TreeNode(val);
        }
        
        if (val < root.val) {
            root.left = insertIntoBST(root.left, val);
        } else if (val > root.val) {
            root.right = insertIntoBST(root.right, val);
        }
        // 如果val == root.val，不插入重复值
        
        return root;
    }
    
    /**
     * 性能测试方法
     * @param nodeCount 节点数量
     * @param iterations 迭代次数
     */
    public void performanceTest(int nodeCount, int iterations) {
        System.out.println("\n=== 性能测试 (" + nodeCount + " 节点, " + iterations + " 次迭代) ===");
        
        // 创建测试树
        TreeNode root = createRandomBST(nodeCount);
        
        // 测试Morris方法
        long startTime = System.nanoTime();
        for (int i = 0; i < iterations; i++) {
            findMode(root);
        }
        long endTime = System.nanoTime();
        System.out.println("Morris方法耗时: " + TimeUnit.NANOSECONDS.toMillis(endTime - startTime) + " ms");
        
        // 测试递归方法
        startTime = System.nanoTime();
        for (int i = 0; i < iterations; i++) {
            findModeRecursive(root);
        }
        endTime = System.nanoTime();
        System.out.println("递归方法耗时: " + TimeUnit.NANOSECONDS.toMillis(endTime - startTime) + " ms");
        
        // 测试迭代方法
        startTime = System.nanoTime();
        for (int i = 0; i < iterations; i++) {
            findModeIterative(root);
        }
        endTime = System.nanoTime();
        System.out.println("迭代方法耗时: " + TimeUnit.NANOSECONDS.toMillis(endTime - startTime) + " ms");
    }
    
    private static void testCase1(Code09_MorrisFindMode solution) {
        System.out.println("\n=== 测试用例1: 基本BST ===");
        Integer[] values = {1, null, 2, null, null, 2};
        TreeNode root = solution.createTree(values);
        
        System.out.print("Morris结果: ");
        printArray(solution.findMode(root));
        System.out.print("\n递归结果: ");
        printArray(solution.findModeRecursive(root));
        System.out.print("\n迭代结果: ");
        printArray(solution.findModeIterative(root));
        System.out.println();
    }
    
    private static void testCase2(Code09_MorrisFindMode solution) {
        System.out.println("\n=== 测试用例2: 空树 ===");
        TreeNode root = null;
        
        System.out.print("Morris结果: ");
        printArray(solution.findMode(root));
        System.out.print("\n递归结果: ");
        printArray(solution.findModeRecursive(root));
        System.out.print("\n迭代结果: ");
        printArray(solution.findModeIterative(root));
        System.out.println();
    }
    
    private static void testCase3(Code09_MorrisFindMode solution) {
        System.out.println("\n=== 测试用例3: 单节点树 ===");
        TreeNode root = new TreeNode(1);
        
        System.out.print("Morris结果: ");
        printArray(solution.findMode(root));
        System.out.print("\n递归结果: ");
        printArray(solution.findModeRecursive(root));
        System.out.print("\n迭代结果: ");
        printArray(solution.findModeIterative(root));
        System.out.println();
    }
    
    private static void testCase4(Code09_MorrisFindMode solution) {
        System.out.println("\n=== 测试用例4: 所有节点值相同 ===");
        Integer[] values = {2, 2, 2, 2, 2, 2, 2};
        TreeNode root = solution.createTree(values);
        
        System.out.print("Morris结果: ");
        printArray(solution.findMode(root));
        System.out.print("\n递归结果: ");
        printArray(solution.findModeRecursive(root));
        System.out.print("\n迭代结果: ");
        printArray(solution.findModeIterative(root));
        System.out.println();
    }
    
    private static void testCase5(Code09_MorrisFindMode solution) {
        System.out.println("\n=== 测试用例5: 多个众数 ===");
        Integer[] values = {1, 1, 2, 2, 3, 3, 4};
        TreeNode root = solution.createTree(values);
        
        System.out.print("Morris结果: ");
        printArray(solution.findMode(root));
        System.out.print("\n递归结果: ");
        printArray(solution.findModeRecursive(root));
        System.out.print("\n迭代结果: ");
        printArray(solution.findModeIterative(root));
        System.out.println();
    }
    
    private static void testCase6(Code09_MorrisFindMode solution) {
        System.out.println("\n=== 测试用例6: 具有负数节点值 ===");
        Integer[] values = {-1, -1, -2, null, null, null, -2, null, null, null, null, null, null, -2};
        TreeNode root = solution.createTree(values);
        
        System.out.print("Morris结果: ");
        printArray(solution.findMode(root));
        System.out.print("\n递归结果: ");
        printArray(solution.findModeRecursive(root));
        System.out.print("\n迭代结果: ");
        printArray(solution.findModeIterative(root));
        System.out.println();
    }
    
    private static void testCase7(Code09_MorrisFindMode solution) {
        System.out.println("\n=== 测试用例7: 大型树，复杂重复模式 ===");
        TreeNode root = solution.createRandomBST(100);
        
        System.out.print("Morris结果: ");
        printArray(solution.findMode(root));
        System.out.print("\n递归结果: ");
        printArray(solution.findModeRecursive(root));
        System.out.print("\n迭代结果: ");
        printArray(solution.findModeIterative(root));
        System.out.println();
    }
    
    /**
     * 主方法
     */
    public static void main(String[] args) {
        // 运行所有测试用例
        runAllTests();
        
        // 运行性能测试
        Code09_MorrisFindMode solution = new Code09_MorrisFindMode();
        
        // 小型树性能测试
        solution.performanceTest(100, 1000);
        
        // 中型树性能测试
        solution.performanceTest(1000, 100);
    }
    
    /**
     * 运行所有测试用例
     */
    public static void runAllTests() {
        Code09_MorrisFindMode solution = new Code09_MorrisFindMode();
        
        testCase1(solution);
        testCase2(solution);
        testCase3(solution);
        testCase4(solution);
        testCase5(solution);
        testCase6(solution);
        testCase7(solution);
    }
    
    /**
     * 辅助方法：打印数组内容
     * @param arr 要打印的数组
     */
    private static void printArray(int[] arr) {
        if (arr == null || arr.length == 0) {
            System.out.print("[]");
            return;
        }
        
        System.out.print("[" + arr[0]);
        for (int i = 1; i < arr.length; i++) {
            System.out.print(", " + arr[i]);
        }
        System.out.print("]");
    }
}

===============================================

文件: Code09_MorrisFindMode.py
===============================================
"""
使用Morris遍历解决二叉搜索树中的众数问题

题目来源：LeetCode 501. Find Mode in Binary Search Tree
题目链接：https://leetcode.cn/problems/find-mode-in-binary-search-tree/

题目描述：
给你一个含重复值的二叉搜索树（BST）的根节点 root ，找出并返回 BST 中的所有众数（即，出现频率最高的元素）。
如果树中有不止一个众数，可以按任意顺序返回。

解题思路：
1. 利用BST的性质：中序遍历得到有序序列
2. 在有序序列中，相同元素会连续出现
3. 使用Morris中序遍历，边遍历边统计每个元素的出现次数
4. 维护当前元素的出现次数和最大出现次数
5. 根据出现次数更新结果集

算法步骤：
1. 使用Morris中序遍历遍历BST
2. 在遍历过程中维护前一个节点pre、当前节点的出现次数count、最大出现次数maxCount
3. 当前节点值与前一个节点值相同时，count++；否则count=1
4. 如果count == maxCount，将当前节点值加入结果集
5. 如果count > maxCount，清空结果集，将当前节点值加入结果集，并更新maxCount

时间复杂度：O(n) - 需要遍历所有节点
空间复杂度：O(1) - 仅使用常数额外空间，不考虑结果集的空间
是否为最优解：是，Morris遍历是解决此问题的最优方法

适用场景：
1. 需要节省内存空间的环境
2. BST中序遍历的应用场景
3. 面试中展示对Morris遍历的深入理解

扩展思考：
1. 如果不是BST而是普通二叉树，如何找众数？
2. 如何处理节点值为负数的情况？
3. 如何在并发环境下保证线程安全？
"""


# 二叉树节点定义
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right


class Solution:
    def __init__(self):
        # 初始化全局变量
        self.pre = None      # 前一个遍历的节点
        self.count = 0       # 当前元素出现次数
        self.maxCount = 0    # 最大出现次数
        self.modes = []      # 结果集

    def findMode(self, root):
        """
        使用Morris中序遍历找BST中的众数
        
        :param root: BST的根节点
        :return: 包含所有众数的列表
        """
        # 重置全局变量
        self.pre = None
        self.count = 0
        self.maxCount = 0
        self.modes = []
        
        # Morris遍历相关变量
        cur = root           # 当前节点
        mostRight = None     # 最右节点（前驱节点）
        
        # Morris中序遍历
        while cur:
            mostRight = cur.left
            
            # 如果当前节点有左子树
            if mostRight:
                # 找到左子树中的最右节点（前驱节点）
                while mostRight.right and mostRight.right != cur:
                    mostRight = mostRight.right
                
                # 判断前驱节点的右指针状态
                if mostRight.right is None:
                    # 第一次到达，建立线索
                    mostRight.right = cur
                    cur = cur.left
                    continue
                else:
                    # 第二次到达，断开线索
                    mostRight.right = None
            
            # 处理当前节点（中序遍历的核心处理逻辑）
            # 统计当前节点值的出现次数
            if self.pre and self.pre.val == cur.val:
                self.count += 1
            else:
                self.count = 1
            
            # 根据出现次数更新结果集
            if self.count == self.maxCount:
                self.modes.append(cur.val)
            elif self.count > self.maxCount:
                self.modes = [cur.val]  # 清空结果集
                self.maxCount = self.count
            
            self.pre = cur
            cur = cur.right
        
        return self.modes


# 测试代码
def main():
    solution = Solution()
    
    # 测试用例1: [1,null,2,2]
    root1 = TreeNode(1)
    root1.right = TreeNode(2)
    root1.right.left = TreeNode(2)
    
    result1 = solution.findMode(root1)
    print("测试用例1结果:", result1)
    
    # 测试用例2: [0]
    root2 = TreeNode(0)
    
    result2 = solution.findMode(root2)
    print("测试用例2结果:", result2)


if __name__ == "__main__":
    main()

===============================================

文件: Code10_MorrisSumRootToLeaf.cpp
===============================================
/**
 * 使用Morris遍历解决求根到叶子节点数字之和问题
 * 
 * 题目来源：LeetCode 129. Sum Root to Leaf Numbers
 * 题目链接：https://leetcode.cn/problems/sum-root-to-leaf-numbers/
 * 
 * 题目描述：
 * 给你一个二叉树的根节点 root ，树中每个节点都存放有一个 0 到 9 之间的数字。
 * 每条从根节点到叶节点的路径都代表一个数字：
 * 例如，从根节点到叶节点的路径 1 -> 2 -> 3 表示数字 123 。
 * 计算从根节点到叶节点生成的所有数字之和。
 * 叶节点是指没有子节点的节点。
 * 
 * 解题思路：
 * 1. 需要遍历所有从根到叶的路径
 * 2. 在遍历过程中维护当前路径表示的数字
 * 3. 当到达叶节点时，将当前数字加到结果中
 * 4. 使用Morris遍历的前序遍历方式实现
 * 
 * 算法步骤：
 * 1. 使用Morris前序遍历遍历二叉树
 * 2. 在遍历过程中维护从根到当前节点的数字路径
 * 3. 当到达叶节点时，累加路径数字到结果中
 * 4. 需要特别处理回溯过程，因为Morris遍历会修改树结构
 * 
 * 注意：这个问题实际上不适合用标准的Morris遍历来解决，因为：
 * 1. 需要准确知道何时到达叶节点
 * 2. 需要维护从根到当前节点的路径信息
 * 3. Morris遍历的线索机制会干扰路径信息的正确维护
 * 
 * 但我们可以借鉴Morris遍历的思想，实现一种变种方法：
 * 1. 使用前序遍历的方式
 * 2. 在建立线索时记录路径信息
 * 3. 在断开线索时进行回溯
 * 
 * 时间复杂度：O(n) - 需要遍历所有节点
 * 空间复杂度：O(1) - 仅使用常数额外空间
 * 是否为最优解：不是，此问题更适合用递归或迭代方法解决
 * 
 * 适用场景：
 * 1. 理解Morris遍历思想的扩展应用
 * 2. 面试中展示对算法的深入理解
 * 
 * 扩展思考：
 * 1. 如何处理节点值不是0-9的情况？
 * 2. 如何处理路径数字可能溢出的情况？
 * 3. 如何在并发环境下保证线程安全？
 */

// 由于编译环境限制，不使用STL容器

// 二叉树节点定义
struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode() : val(0), left(nullptr), right(nullptr) {}
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
    TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
};

class Solution {
public:
    /**
     * 使用Morris前序遍历计算根到叶节点数字之和
     * 
     * @param root 二叉树的根节点
     * @return 所有根到叶路径数字之和
     */
    int sumNumbers(TreeNode* root) {
        if (root == nullptr) {
            return 0;
        }
        
        int totalSum = 0;              // 结果总和
        int currentNum = 0;            // 当前路径表示的数字
        TreeNode* cur = root;          // 当前节点
        TreeNode* mostRight = nullptr; // 最右节点（前驱节点）
        
        // Morris前序遍历
        while (cur != nullptr) {
            mostRight = cur->left;
            
            // 如果当前节点有左子树
            if (mostRight != nullptr) {
                // 找到左子树中的最右节点（前驱节点）
                while (mostRight->right != nullptr && mostRight->right != cur) {
                    mostRight = mostRight->right;
                }
                
                // 判断前驱节点的右指针状态
                if (mostRight->right == nullptr) {
                    // 第一次到达，建立线索
                    // 更新当前路径数字
                    currentNum = currentNum * 10 + cur->val;
                    
                    // 如果是叶节点，累加到结果中
                    if (cur->left == nullptr && cur->right == nullptr) {
                        totalSum += currentNum;
                    }
                    
                    mostRight->right = cur;
                    cur = cur->left;
                    continue;
                } else {
                    // 第二次到达，断开线索
                    mostRight->right = nullptr;
                }
            } else {
                // 没有左子树，直接处理当前节点
                currentNum = currentNum * 10 + cur->val;
                
                // 如果是叶节点，累加到结果中
                if (cur->left == nullptr && cur->right == nullptr) {
                    totalSum += currentNum;
                }
            }
            
            cur = cur->right;
        }
        
        return totalSum;
    }
};/**
 * 使用Morris遍历解决求根到叶子节点数字之和问题
 * 
 * 题目来源：LeetCode 129. Sum Root to Leaf Numbers
 * 题目链接：https://leetcode.cn/problems/sum-root-to-leaf-numbers/
 * 
 * 题目描述：
 * 给你一个二叉树的根节点 root ，树中每个节点都存放有一个 0 到 9 之间的数字。
 * 每条从根节点到叶节点的路径都代表一个数字：
 * 例如，从根节点到叶节点的路径 1 -> 2 -> 3 表示数字 123 。
 * 计算从根节点到叶节点生成的所有数字之和。
 * 叶节点是指没有子节点的节点。
 * 
 * 解题思路：
 * 1. 需要遍历所有从根到叶的路径
 * 2. 在遍历过程中维护当前路径表示的数字
 * 3. 当到达叶节点时，将当前数字加到结果中
 * 4. 使用Morris遍历的前序遍历方式实现
 * 
 * 算法步骤：
 * 1. 使用Morris前序遍历遍历二叉树
 * 2. 在遍历过程中维护从根到当前节点的数字路径
 * 3. 当到达叶节点时，累加路径数字到结果中
 * 4. 需要特别处理回溯过程，因为Morris遍历会修改树结构
 * 
 * 注意：这个问题实际上不适合用标准的Morris遍历来解决，因为：
 * 1. 需要准确知道何时到达叶节点
 * 2. 需要维护从根到当前节点的路径信息
 * 3. Morris遍历的线索机制会干扰路径信息的正确维护
 * 
 * 但我们可以借鉴Morris遍历的思想，实现一种变种方法：
 * 1. 使用前序遍历的方式
 * 2. 在建立线索时记录路径信息
 * 3. 在断开线索时进行回溯
 * 
 * 时间复杂度：O(n) - 需要遍历所有节点
 * 空间复杂度：O(1) - 仅使用常数额外空间
 * 是否为最优解：不是，此问题更适合用递归或迭代方法解决
 * 
 * 适用场景：
 * 1. 理解Morris遍历思想的扩展应用
 * 2. 面试中展示对算法的深入理解
 * 
 * 扩展思考：
 * 1. 如何处理节点值不是0-9的情况？
 * 2. 如何处理路径数字可能溢出的情况？
 * 3. 如何在并发环境下保证线程安全？
 */

// 由于编译环境限制，不使用STL容器

// 二叉树节点定义
struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode() : val(0), left(nullptr), right(nullptr) {}
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
    TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
};

class Solution {
public:
    /**
     * 使用Morris前序遍历计算根到叶节点数字之和
     * 
     * @param root 二叉树的根节点
     * @return 所有根到叶路径数字之和
     */
    int sumNumbers(TreeNode* root) {
        if (root == nullptr) {
            return 0;
        }
        
        int totalSum = 0;              // 结果总和
        int currentNum = 0;            // 当前路径表示的数字
        TreeNode* cur = root;          // 当前节点
        TreeNode* mostRight = nullptr; // 最右节点（前驱节点）
        
        // Morris前序遍历
        while (cur != nullptr) {
            mostRight = cur->left;
            
            // 如果当前节点有左子树
            if (mostRight != nullptr) {
                // 找到左子树中的最右节点（前驱节点）
                while (mostRight->right != nullptr && mostRight->right != cur) {
                    mostRight = mostRight->right;
                }
                
                // 判断前驱节点的右指针状态
                if (mostRight->right == nullptr) {
                    // 第一次到达，建立线索
                    // 更新当前路径数字
                    currentNum = currentNum * 10 + cur->val;
                    
                    // 如果是叶节点，累加到结果中
                    if (cur->left == nullptr && cur->right == nullptr) {
                        totalSum += currentNum;
                    }
                    
                    mostRight->right = cur;
                    cur = cur->left;
                    continue;
                } else {
                    // 第二次到达，断开线索
                    mostRight->right = nullptr;
                }
            } else {
                // 没有左子树，直接处理当前节点
                currentNum = currentNum * 10 + cur->val;
                
                // 如果是叶节点，累加到结果中
                if (cur->left == nullptr && cur->right == nullptr) {
                    totalSum += currentNum;
                }
            }
            
            cur = cur->right;
        }
        
        return totalSum;
    }
};

===============================================

文件: Code10_MorrisSumRootToLeaf.java
===============================================
package class124;

import java.util.Stack;

/**
 * 使用Morris遍历解决求根到叶子节点数字之和问题
 * 
 * 题目来源：
 * - 求根到叶子节点数字之和：LeetCode 129. Sum Root to Leaf Numbers
 *   链接：https://leetcode.cn/problems/sum-root-to-leaf-numbers/
 * 
 * Morris遍历是一种空间复杂度为O(1)的二叉树遍历算法，通过临时修改树的结构（利用叶子节点的空闲指针）
 * 来避免使用栈或递归调用栈所需的额外空间。算法的核心思想是将树转换为一个线索二叉树。
 * 
 * 本实现包含：
 * 1. Java语言的Morris前序遍历求路径和
 * 2. 递归版本的求路径和
 * 3. 迭代版本的求路径和
 * 4. 详细的注释和算法解析
 * 5. 完整的测试用例
 * 6. C++和Python语言的完整实现
 * 
 * 三种语言实现链接：
 * - Java: 当前文件
 * - Python: https://leetcode.cn/problems/sum-root-to-leaf-numbers/solution/python-morris-qiu-lu-jing-he-by-xxx/
 * - C++: https://leetcode.cn/problems/sum-root-to-leaf-numbers/solution/c-morris-qiu-lu-jing-he-by-xxx/
 */
public class Code10_MorrisSumRootToLeaf {

    // 二叉树节点定义
    public static class TreeNode {
        int val;
        TreeNode left;
        TreeNode right;

        TreeNode() {}

        TreeNode(int val) {
            this.val = val;
        }

        TreeNode(int val, TreeNode left, TreeNode right) {
            this.val = val;
            this.left = left;
            this.right = right;
        }
    }

    /**
     * 使用Morris前序遍历计算根到叶节点数字之和
     * 注意：这是一个特殊的实现，因为标准Morris遍历不适合路径回溯问题
     * 
     * @param root 二叉树的根节点
     * @return 所有根到叶路径数字之和
     * @throws NullPointerException 如果root为null（但代码已处理null情况，此处仅作文档说明）
     * 
     * 题目描述：
     * 给你一个二叉树的根节点 root ，树中每个节点都存放有一个 0 到 9 之间的数字。
     * 每条从根节点到叶节点的路径都代表一个数字：
     * 例如，从根节点到叶节点的路径 1 -> 2 -> 3 表示数字 123 。
     * 计算从根节点到叶节点生成的所有数字之和。
     * 叶节点是指没有子节点的节点。
     * 
     * 解题思路：
     * 1. 需要遍历所有从根到叶的路径
     * 2. 在遍历过程中维护当前路径表示的数字
     * 3. 当到达叶节点时，将当前数字加到结果中
     * 4. 本实现提供三种方法：Morris前序遍历、递归DFS、迭代DFS
     * 
     * 算法步骤（Morris前序遍历）：
     * 1. 使用Morris前序遍历遍历二叉树
     * 2. 在遍历过程中维护从根到当前节点的数字路径
     * 3. 当到达叶节点时，累加路径数字到结果中
     * 4. 需要特别处理回溯过程，因为Morris遍历会修改树结构
     * 
     * 时间复杂度：
     * - Morris方法：O(n) - 需要遍历所有节点，每个节点最多被访问3次
     * - 递归方法：O(n) - 每个节点被访问一次
     * - 迭代方法：O(n) - 每个节点被访问一次
     * 
     * 空间复杂度：
     * - Morris方法：O(1) - 仅使用常数额外空间
     * - 递归方法：O(h) - h为树高，最坏情况下为O(n)
     * - 迭代方法：O(h) - 栈的空间复杂度，最坏情况下为O(n)
     * 
     * 是否为最优解：
     * - 从空间复杂度角度，Morris方法最优
     * - 从实现复杂度和代码可读性角度，递归方法最优
     * - 对于此问题，推荐使用递归或迭代方法
     * 
     * 适用场景：
     * 1. 理解Morris遍历思想的扩展应用
     * 2. 面试中展示对算法的深入理解
     * 3. 空间受限环境下的路径求和问题
     * 
     * 三种语言实现链接：
     * - Java: 当前方法
     * - Python: https://leetcode.cn/problems/sum-root-to-leaf-numbers/solution/python-morris-qiu-lu-jing-he-by-xxx/
     * - C++: https://leetcode.cn/problems/sum-root-to-leaf-numbers/solution/c-morris-qiu-lu-jing-he-by-xxx/
     */
    public int sumNumbers(TreeNode root) {
        // 防御性编程：处理空树情况
        if (root == null) {
            return 0;
        }
        
        int totalSum = 0;              // 结果总和
        int currentNum = 0;            // 当前路径表示的数字
        TreeNode cur = root;           // 当前节点
        TreeNode mostRight = null;     // 最右节点（前驱节点）
        
        // 记录节点深度，用于正确回溯路径
        int depth = 0;
        
        // Morris前序遍历的核心循环
        while (cur != null) {
            mostRight = cur.left;
            
            // 如果当前节点有左子树
            if (mostRight != null) {
                // 计算到前驱节点的距离（用于正确回溯）
                int steps = 0;
                // 找到左子树中的最右节点（前驱节点）
                while (mostRight.right != null && mostRight.right != cur) {
                    mostRight = mostRight.right;
                    steps++;
                }
                
                // 判断前驱节点的右指针状态
                if (mostRight.right == null) {
                    // 第一次到达，建立线索
                    // 更新当前路径数字
                    currentNum = currentNum * 10 + cur.val;
                    depth++;
                    
                    // 如果是叶节点，累加到结果中
                    if (cur.left == null && cur.right == null) {
                        totalSum += currentNum;
                    }
                    
                    mostRight.right = cur;  // 建立线索
                    cur = cur.left;         // 继续向左子树深入
                    continue;               // 跳过当前迭代的剩余部分
                } else {
                    // 第二次到达，断开线索
                    mostRight.right = null; // 断开线索，恢复树的原始结构
                    
                    // 恢复currentNum，回溯路径
                    // 这里需要根据到前驱节点的距离正确恢复路径值
                    for (int i = 0; i <= steps; i++) {
                        currentNum /= 10;
                        depth--;
                    }
                }
            } else {
                // 没有左子树，直接处理当前节点
                currentNum = currentNum * 10 + cur.val;
                depth++;
                
                // 如果是叶节点，累加到结果中
                if (cur.right == null) { // 因为没有左子树，所以只需要检查右子树
                    totalSum += currentNum;
                    // 回溯路径（如果有父节点）
                    currentNum /= 10;
                    depth--;
                }
            }
            
            cur = cur.right; // 移动到右子树或通过线索回到父节点
        }
        
        return totalSum;
    }
    
    /**
     * 使用递归DFS方法计算根到叶节点数字之和（推荐方法）
     * 
     * @param root 二叉树的根节点
     * @return 所有根到叶路径数字之和
     * 
     * 算法步骤（递归DFS）：
     * 1. 递归遍历二叉树
     * 2. 在递归过程中维护当前路径表示的数字
     * 3. 当到达叶节点时，返回当前路径数字作为贡献值
     * 4. 非叶节点返回左右子树贡献值之和
     * 
     * 时间复杂度：O(n)
     * 空间复杂度：O(h)
     * 
     * 三种语言实现链接：
     * - Java: 当前方法
     * - Python: https://leetcode.cn/problems/sum-root-to-leaf-numbers/solution/python-di-gui-qiu-lu-jing-he-by-xxx/
     * - C++: https://leetcode.cn/problems/sum-root-to-leaf-numbers/solution/c-di-gui-qiu-lu-jing-he-by-xxx/
     */
    public int sumNumbersRecursive(TreeNode root) {
        // 防御性编程：处理空树情况
        if (root == null) {
            return 0;
        }
        
        // 调用递归辅助函数，初始路径和为0
        return dfs(root, 0);
    }
    
    /**
     * 递归DFS辅助函数
     * 
     * @param node 当前节点
     * @param currentSum 到当前节点的路径数字
     * @return 以当前节点为根的子树的所有路径数字之和
     * 
     * 三种语言实现链接：
     * - Java: 当前方法
     * - Python: https://leetcode.cn/problems/sum-root-to-leaf-numbers/solution/python-di-gui-qiu-lu-jing-he-by-xxx/
     * - C++: https://leetcode.cn/problems/sum-root-to-leaf-numbers/solution/c-di-gui-qiu-lu-jing-he-by-xxx/
     */
    private int dfs(TreeNode node, int currentSum) {
        // 基本情况：空节点贡献0
        if (node == null) {
            return 0;
        }
        
        // 更新当前路径数字
        currentSum = currentSum * 10 + node.val;
        
        // 如果是叶节点，返回当前路径数字
        if (node.left == null && node.right == null) {
            return currentSum;
        }
        
        // 非叶节点：返回左右子树的贡献值之和
        return dfs(node.left, currentSum) + dfs(node.right, currentSum);
    }
    
    /**
     * 使用迭代DFS方法计算根到叶节点数字之和
     * 
     * @param root 二叉树的根节点
     * @return 所有根到叶路径数字之和
     * 
     * 算法步骤（迭代DFS）：
     * 1. 使用栈模拟递归过程
     * 2. 每个栈元素包含节点和到该节点的路径数字
     * 3. 当遇到叶节点时，将路径数字加到结果中
     * 
     * 时间复杂度：O(n)
     * 空间复杂度：O(h)
     * 
     * 三种语言实现链接：
     * - Java: 当前方法
     * - Python: https://leetcode.cn/problems/sum-root-to-leaf-numbers/solution/python-die-dai-qiu-lu-jing-he-by-xxx/
     * - C++: https://leetcode.cn/problems/sum-root-to-leaf-numbers/solution/c-die-dai-qiu-lu-jing-he-by-xxx/
     */
    public int sumNumbersIterative(TreeNode root) {
        // 防御性编程：处理空树情况
        if (root == null) {
            return 0;
        }
        
        // 定义节点和路径和的结构体
        class NodeSum {
            TreeNode node;
            int sum;
            
            NodeSum(TreeNode node, int sum) {
                this.node = node;
                this.sum = sum;
            }
        }
        
        Stack<NodeSum> stack = new Stack<>();
        stack.push(new NodeSum(root, 0));
        
        int totalSum = 0;
        
        while (!stack.isEmpty()) {
            NodeSum ns = stack.pop();
            
            TreeNode node = ns.node;
            int currentSum = ns.sum;
            
            currentSum = currentSum * 10 + node.val;
            
            // 如果是叶节点，累加到结果中
            if (node.left == null && node.right == null) {
                totalSum += currentSum;
            } else {
                // 非叶节点，继续处理子节点
                // 先压入右子树，再压入左子树，保证左子树先被处理
                if (node.right != null) {
                    stack.push(new NodeSum(node.right, currentSum));
                }
                if (node.left != null) {
                    stack.push(new NodeSum(node.left, currentSum));
                }
            }
        }
        
        return totalSum;
    }
    
    /**
     * 测试方法
     */
    public static void main(String[] args) {
        // 创建测试树: [1,2,3]
        //     1
        //    / \
        //   2   3
        // 路径1->2表示数字12，路径1->3表示数字13
        // 总和 = 12 + 13 = 25
        TreeNode root1 = new TreeNode(1);
        root1.left = new TreeNode(2);
        root1.right = new TreeNode(3);
        
        Code10_MorrisSumRootToLeaf solution = new Code10_MorrisSumRootToLeaf();
        
        System.out.println("测试用例1: [1,2,3]");
        System.out.println("Morris方法结果: " + solution.sumNumbers(root1));
        System.out.println("递归方法结果: " + solution.sumNumbersRecursive(root1));
        System.out.println("迭代方法结果: " + solution.sumNumbersIterative(root1));
        
        // 创建测试树: [4,9,0,5,1]
        //       4
        //      / \
        //     9   0
        //    / \
        //   5   1
        // 路径4->9->5表示数字495，路径4->9->1表示数字491，路径4->0表示数字40
        // 总和 = 495 + 491 + 40 = 1026
        TreeNode root2 = new TreeNode(4);
        root2.left = new TreeNode(9);
        root2.right = new TreeNode(0);
        root2.left.left = new TreeNode(5);
        root2.left.right = new TreeNode(1);
        
        System.out.println("\n测试用例2: [4,9,0,5,1]");
        System.out.println("Morris方法结果: " + solution.sumNumbers(root2));
        System.out.println("递归方法结果: " + solution.sumNumbersRecursive(root2));
        System.out.println("迭代方法结果: " + solution.sumNumbersIterative(root2));
    }
}

// C++版本实现（注释版）
/*
#include <iostream>
#include <stack>
using namespace std;

// 二叉树节点定义
struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode() : val(0), left(nullptr), right(nullptr) {}
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
    TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
};

class Solution {
public:
    // Morris前序遍历方法
    int sumNumbers(TreeNode* root) {
        if (!root) return 0;
        
        int totalSum = 0;
        int currentNum = 0;
        TreeNode* cur = root;
        TreeNode* mostRight = nullptr;
        int depth = 0;
        
        while (cur) {
            mostRight = cur->left;
            if (mostRight) {
                int steps = 0;
                while (mostRight->right && mostRight->right != cur) {
                    mostRight = mostRight->right;
                    steps++;
                }
                
                if (!mostRight->right) {
                    // 第一次到达
                    currentNum = currentNum * 10 + cur->val;
                    depth++;
                    
                    if (!cur->left && !cur->right) {
                        totalSum += currentNum;
                    }
                    
                    mostRight->right = cur;
                    cur = cur->left;
                    continue;
                } else {
                    // 第二次到达，断开线索
                    mostRight->right = nullptr;
                    
                    // 恢复路径值
                    for (int i = 0; i <= steps; i++) {
                        currentNum /= 10;
                        depth--;
                    }
                }
            } else {
                currentNum = currentNum * 10 + cur->val;
                depth++;
                
                if (!cur->right) {
                    totalSum += currentNum;
                    currentNum /= 10;
                    depth--;
                }
            }
            
            cur = cur->right;
        }
        
        return totalSum;
    }
    
    // 递归DFS方法
    int sumNumbersRecursive(TreeNode* root) {
        if (!root) return 0;
        return dfs(root, 0);
    }
    
private:
    int dfs(TreeNode* node, int currentSum) {
        if (!node) return 0;
        
        currentSum = currentSum * 10 + node->val;
        
        if (!node->left && !node->right) {
            return currentSum;
        }
        
        return dfs(node->left, currentSum) + dfs(node->right, currentSum);
    }
    
public:
    // 迭代DFS方法
    int sumNumbersIterative(TreeNode* root) {
        if (!root) return 0;
        
        // 定义节点和路径和的结构体
        struct NodeSum {
            TreeNode* node;
            int sum;
            NodeSum(TreeNode* n, int s) : node(n), sum(s) {}
        };
        
        stack<NodeSum> st;
        st.emplace(root, 0);
        
        int totalSum = 0;
        
        while (!st.empty()) {
            NodeSum ns = st.top();
            st.pop();
            
            TreeNode* node = ns.node;
            int currentSum = ns.sum;
            
            currentSum = currentSum * 10 + node->val;
            
            if (!node->left && !node->right) {
                totalSum += currentSum;
            } else {
                if (node->right) {
                    st.emplace(node->right, currentSum);
                }
                if (node->left) {
                    st.emplace(node->left, currentSum);
                }
            }
        }
        
        return totalSum;
    }
};

// 测试代码
int main() {
    Solution solution;
    
    // 测试用例1: [1,2,3]
    TreeNode* root1 = new TreeNode(1);
    root1->left = new TreeNode(2);
    root1->right = new TreeNode(3);
    
    cout << "测试用例1 Morris方法结果: " << solution.sumNumbers(root1) << endl;
    cout << "测试用例1 递归方法结果: " << solution.sumNumbersRecursive(root1) << endl;
    cout << "测试用例1 迭代方法结果: " << solution.sumNumbersIterative(root1) << endl;
    
    // 释放内存...
    
    return 0;
}
*/

// Python版本实现（注释版）
'''
# 二叉树节点定义
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

class Solution:
    # Morris前序遍历方法
    def sumNumbers(self, root):
        if not root:
            return 0
        
        total_sum = 0
        current_num = 0
        cur = root
        depth = 0
        
        while cur:
            most_right = cur.left
            if most_right:
                # 计算到前驱节点的步数
                steps = 0
                while most_right.right and most_right.right != cur:
                    most_right = most_right.right
                    steps += 1
                
                if not most_right.right:
                    # 第一次到达
                    current_num = current_num * 10 + cur.val
                    depth += 1
                    
                    # 检查是否是叶节点
                    if not cur.left and not cur.right:
                        total_sum += current_num
                    
                    most_right.right = cur
                    cur = cur.left
                    continue
                else:
                    # 第二次到达，断开线索
                    most_right.right = None
                    
                    # 恢复路径值
                    for _ in range(steps + 1):
                        current_num //= 10
                        depth -= 1
            else:
                # 没有左子树
                current_num = current_num * 10 + cur.val
                depth += 1
                
                # 检查是否是叶节点
                if not cur.right:
                    total_sum += current_num
                    current_num //= 10
                    depth -= 1
            
            cur = cur.right
        
        return total_sum
    
    # 递归DFS方法
    def sumNumbersRecursive(self, root):
        if not root:
            return 0
        
        def dfs(node, current_sum):
            if not node:
                return 0
            
            current_sum = current_sum * 10 + node.val
            
            # 叶节点
            if not node.left and not node.right:
                return current_sum
            
            return dfs(node.left, current_sum) + dfs(node.right, current_sum)
        
        return dfs(root, 0)
    
    # 迭代DFS方法
    def sumNumbersIterative(self, root):
        if not root:
            return 0
        
        stack = [(root, 0)]  # (节点, 当前路径和)
        total_sum = 0
        
        while stack:
            node, current_sum = stack.pop()
            
            current_sum = current_sum * 10 + node.val
            
            # 叶节点
            if not node.left and not node.right:
                total_sum += current_sum
            else:
                # 先压入右子树，再压入左子树，保证左子树先被处理
                if node.right:
                    stack.append((node.right, current_sum))
                if node.left:
                    stack.append((node.left, current_sum))
        
        return total_sum

# 测试代码
def test():
    solution = Solution()
    
    # 测试用例1: [1,2,3]
    root1 = TreeNode(1)
    root1.left = TreeNode(2)
    root1.right = TreeNode(3)
    
    print("测试用例1 Morris方法结果:", solution.sumNumbers(root1))
    print("测试用例1 递归方法结果:", solution.sumNumbersRecursive(root1))
    print("测试用例1 迭代方法结果:", solution.sumNumbersIterative(root1))

if __name__ == "__main__":
    test()
'''

===============================================

文件: Code10_MorrisSumRootToLeaf.py
===============================================
"""
使用Morris遍历解决求根到叶子节点数字之和问题

题目来源：LeetCode 129. Sum Root to Leaf Numbers
题目链接：https://leetcode.cn/problems/sum-root-to-leaf-numbers/

题目描述：
给你一个二叉树的根节点 root ，树中每个节点都存放有一个 0 到 9 之间的数字。
每条从根节点到叶节点的路径都代表一个数字：
例如，从根节点到叶节点的路径 1 -> 2 -> 3 表示数字 123 。
计算从根节点到叶节点生成的所有数字之和。
叶节点是指没有子节点的节点。

解题思路：
1. 需要遍历所有从根到叶的路径
2. 在遍历过程中维护当前路径表示的数字
3. 当到达叶节点时，将当前数字加到结果中
4. 使用Morris遍历的前序遍历方式实现

算法步骤：
1. 使用Morris前序遍历遍历二叉树
2. 在遍历过程中维护从根到当前节点的数字路径
3. 当到达叶节点时，累加路径数字到结果中
4. 需要特别处理回溯过程，因为Morris遍历会修改树结构

注意：这个问题实际上不适合用标准的Morris遍历来解决，因为：
1. 需要准确知道何时到达叶节点
2. 需要维护从根到当前节点的路径信息
3. Morris遍历的线索机制会干扰路径信息的正确维护

但我们可以借鉴Morris遍历的思想，实现一种变种方法：
1. 使用前序遍历的方式
2. 在建立线索时记录路径信息
3. 在断开线索时进行回溯

时间复杂度：O(n) - 需要遍历所有节点
空间复杂度：O(1) - 仅使用常数额外空间
是否为最优解：不是，此问题更适合用递归或迭代方法解决

适用场景：
1. 理解Morris遍历思想的扩展应用
2. 面试中展示对算法的深入理解

扩展思考：
1. 如何处理节点值不是0-9的情况？
2. 如何处理路径数字可能溢出的情况？
3. 如何在并发环境下保证线程安全？
"""


# 二叉树节点定义
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right


class Solution:
    def sumNumbers(self, root):
        """
        使用Morris前序遍历计算根到叶节点数字之和
        
        :param root: 二叉树的根节点
        :return: 所有根到叶路径数字之和
        """
        if not root:
            return 0
        
        total_sum = 0          # 结果总和
        current_num = 0        # 当前路径表示的数字
        cur = root             # 当前节点
        most_right = None      # 最右节点（前驱节点）
        
        # Morris前序遍历
        while cur:
            most_right = cur.left
            
            # 如果当前节点有左子树
            if most_right:
                # 找到左子树中的最右节点（前驱节点）
                while most_right.right and most_right.right != cur:
                    most_right = most_right.right
                
                # 判断前驱节点的右指针状态
                if most_right.right is None:
                    # 第一次到达，建立线索
                    # 更新当前路径数字
                    current_num = current_num * 10 + cur.val
                    
                    # 如果是叶节点，累加到结果中
                    if not cur.left and not cur.right:
                        total_sum += current_num
                    
                    most_right.right = cur
                    cur = cur.left
                    continue
                else:
                    # 第二次到达，断开线索
                    most_right.right = None
            else:
                # 没有左子树，直接处理当前节点
                current_num = current_num * 10 + cur.val
                
                # 如果是叶节点，累加到结果中
                if not cur.left and not cur.right:
                    total_sum += current_num
            
            cur = cur.right
        
        return total_sum


# 测试代码
def main():
    solution = Solution()
    
    # 测试用例1: [1,2,3]
    #     1
    #    / \
    #   2   3
    # 数字: 12, 13 -> 和为25
    root1 = TreeNode(1)
    root1.left = TreeNode(2)
    root1.right = TreeNode(3)
    
    result1 = solution.sumNumbers(root1)
    print("测试用例1结果:", result1)  # 期望输出: 25
    
    # 测试用例2: [4,9,0,5,1]
    #       4
    #      / \
    #     9   0
    #    / \
    #   5   1
    # 数字: 495, 491, 40 -> 和为1026
    root2 = TreeNode(4)
    root2.left = TreeNode(9)
    root2.right = TreeNode(0)
    root2.left.left = TreeNode(5)
    root2.left.right = TreeNode(1)
    
    result2 = solution.sumNumbers(root2)
    print("测试用例2结果:", result2)  # 期望输出: 1026


if __name__ == "__main__":
    main()

===============================================

文件: Code10_MorrisSumRootToLeafCorrect.java
===============================================
package class124;

import java.util.Stack;

/**
 * 使用Morris遍历解决求根到叶子节点数字之和问题
 * 
 * 题目来源：
 * - 求根到叶子节点数字之和：LeetCode 129. Sum Root to Leaf Numbers
 *   链接：https://leetcode.cn/problems/sum-root-to-leaf-numbers/
 * 
 * Morris遍历是一种空间复杂度为O(1)的二叉树遍历算法，通过临时修改树的结构（利用叶子节点的空闲指针）
 * 来避免使用栈或递归调用栈所需的额外空间。算法的核心思想是将树转换为一个线索二叉树。
 * 
 * 本实现包含：
 * 1. Java语言的Morris前序遍历求路径和
 * 2. 递归版本的求路径和
 * 3. 迭代版本的求路径和
 * 4. 详细的注释和算法解析
 * 5. 完整的测试用例
 * 6. C++和Python语言的完整实现
 * 
 * 三种语言实现链接：
 * - Java: 当前文件
 * - Python: https://leetcode.cn/problems/sum-root-to-leaf-numbers/solution/python-morris-qiu-lu-jing-he-by-xxx/
 * - C++: https://leetcode.cn/problems/sum-root-to-leaf-numbers/solution/c-morris-qiu-lu-jing-he-by-xxx/
 */
public class Code10_MorrisSumRootToLeafCorrect {

    // 二叉树节点定义
    public static class TreeNode {
        int val;
        TreeNode left;
        TreeNode right;

        TreeNode() {}

        TreeNode(int val) {
            this.val = val;
        }

        TreeNode(int val, TreeNode left, TreeNode right) {
            this.val = val;
            this.left = left;
            this.right = right;
        }
    }

    /**
     * 使用Morris前序遍历计算根到叶节点数字之和
     * 注意：这是一个特殊的实现，因为标准Morris遍历不适合路径回溯问题
     * 
     * @param root 二叉树的根节点
     * @return 所有根到叶路径数字之和
     * @throws NullPointerException 如果root为null（但代码已处理null情况，此处仅作文档说明）
     * 
     * 题目描述：
     * 给你一个二叉树的根节点 root ，树中每个节点都存放有一个 0 到 9 之间的数字。
     * 每条从根节点到叶节点的路径都代表一个数字：
     * 例如，从根节点到叶节点的路径 1 -> 2 -> 3 表示数字 123 。
     * 计算从根节点到叶节点生成的所有数字之和。
     * 叶节点是指没有子节点的节点。
     * 
     * 解题思路：
     * 1. 需要遍历所有从根到叶的路径
     * 2. 在遍历过程中维护当前路径表示的数字
     * 3. 当到达叶节点时，将当前数字加到结果中
     * 4. 本实现提供三种方法：Morris前序遍历、递归DFS、迭代DFS
     * 
     * 算法步骤（Morris前序遍历）：
     * 1. 使用Morris前序遍历遍历二叉树
     * 2. 在遍历过程中维护从根到当前节点的数字路径
     * 3. 当到达叶节点时，累加路径数字到结果中
     * 4. 需要特别处理回溯过程，因为Morris遍历会修改树结构
     * 
     * 时间复杂度：
     * - Morris方法：O(n) - 需要遍历所有节点，每个节点最多被访问3次
     * - 递归方法：O(n) - 每个节点被访问一次
     * - 迭代方法：O(n) - 每个节点被访问一次
     * 
     * 空间复杂度：
     * - Morris方法：O(1) - 仅使用常数额外空间
     * - 递归方法：O(h) - h为树高，最坏情况下为O(n)
     * - 迭代方法：O(h) - 栈的空间复杂度，最坏情况下为O(n)
     * 
     * 是否为最优解：
     * - 从空间复杂度角度，Morris方法最优
     * - 从实现复杂度和代码可读性角度，递归方法最优
     * - 对于此问题，推荐使用递归或迭代方法
     * 
     * 适用场景：
     * 1. 理解Morris遍历思想的扩展应用
     * 2. 面试中展示对算法的深入理解
     * 3. 空间受限环境下的路径求和问题
     * 
     * 三种语言实现链接：
     * - Java: 当前方法
     * - Python: https://leetcode.cn/problems/sum-root-to-leaf-numbers/solution/python-morris-qiu-lu-jing-he-by-xxx/
     * - C++: https://leetcode.cn/problems/sum-root-to-leaf-numbers/solution/c-morris-qiu-lu-jing-he-by-xxx/
     */
    public int sumNumbers(TreeNode root) {
        // 防御性编程：处理空树情况
        if (root == null) {
            return 0;
        }
        
        int totalSum = 0;              // 结果总和
        int currentNum = 0;            // 当前路径表示的数字
        TreeNode cur = root;           // 当前节点
        TreeNode mostRight = null;     // 最右节点（前驱节点）
        
        // 记录节点深度，用于正确回溯路径
        int depth = 0;
        
        // Morris前序遍历的核心循环
        while (cur != null) {
            mostRight = cur.left;
            
            // 如果当前节点有左子树
            if (mostRight != null) {
                // 计算到前驱节点的距离（用于正确回溯）
                int steps = 0;
                // 找到左子树中的最右节点（前驱节点）
                while (mostRight.right != null && mostRight.right != cur) {
                    mostRight = mostRight.right;
                    steps++;
                }
                
                // 判断前驱节点的右指针状态
                if (mostRight.right == null) {
                    // 第一次到达，建立线索
                    // 更新当前路径数字
                    currentNum = currentNum * 10 + cur.val;
                    depth++;
                    
                    // 如果是叶节点，累加到结果中
                    if (cur.left == null && cur.right == null) {
                        totalSum += currentNum;
                    }
                    
                    mostRight.right = cur;  // 建立线索
                    cur = cur.left;         // 继续向左子树深入
                    continue;               // 跳过当前迭代的剩余部分
                } else {
                    // 第二次到达，断开线索
                    mostRight.right = null; // 断开线索，恢复树的原始结构
                    
                    // 恢复currentNum，回溯路径
                    // 这里需要根据到前驱节点的距离正确恢复路径值
                    for (int i = 0; i <= steps; i++) {
                        currentNum /= 10;
                        depth--;
                    }
                }
            } else {
                // 没有左子树，直接处理当前节点
                currentNum = currentNum * 10 + cur.val;
                depth++;
                
                // 如果是叶节点，累加到结果中
                if (cur.right == null) { // 因为没有左子树，所以只需要检查右子树
                    totalSum += currentNum;
                    // 回溯路径（如果有父节点）
                    currentNum /= 10;
                    depth--;
                }
            }
            
            cur = cur.right; // 移动到右子树或通过线索回到父节点
        }
        
        return totalSum;
    }
    
    /**
     * 使用递归DFS方法计算根到叶节点数字之和（推荐方法）
     * 
     * @param root 二叉树的根节点
     * @return 所有根到叶路径数字之和
     * 
     * 算法步骤（递归DFS）：
     * 1. 递归遍历二叉树
     * 2. 在递归过程中维护当前路径表示的数字
     * 3. 当到达叶节点时，返回当前路径数字作为贡献值
     * 4. 非叶节点返回左右子树贡献值之和
     * 
     * 时间复杂度：O(n)
     * 空间复杂度：O(h)
     * 
     * 三种语言实现链接：
     * - Java: 当前方法
     * - Python: https://leetcode.cn/problems/sum-root-to-leaf-numbers/solution/python-di-gui-qiu-lu-jing-he-by-xxx/
     * - C++: https://leetcode.cn/problems/sum-root-to-leaf-numbers/solution/c-di-gui-qiu-lu-jing-he-by-xxx/
     */
    public int sumNumbersRecursive(TreeNode root) {
        // 防御性编程：处理空树情况
        if (root == null) {
            return 0;
        }
        
        // 调用递归辅助函数，初始路径和为0
        return dfs(root, 0);
    }
    
    /**
     * 递归DFS辅助函数
     * 
     * @param node 当前节点
     * @param currentSum 到当前节点的路径数字
     * @return 以当前节点为根的子树的所有路径数字之和
     * 
     * 三种语言实现链接：
     * - Java: 当前方法
     * - Python: https://leetcode.cn/problems/sum-root-to-leaf-numbers/solution/python-di-gui-qiu-lu-jing-he-by-xxx/
     * - C++: https://leetcode.cn/problems/sum-root-to-leaf-numbers/solution/c-di-gui-qiu-lu-jing-he-by-xxx/
     */
    private int dfs(TreeNode node, int currentSum) {
        // 基本情况：空节点贡献0
        if (node == null) {
            return 0;
        }
        
        // 更新当前路径数字
        currentSum = currentSum * 10 + node.val;
        
        // 如果是叶节点，返回当前路径数字
        if (node.left == null && node.right == null) {
            return currentSum;
        }
        
        // 非叶节点：返回左右子树的贡献值之和
        return dfs(node.left, currentSum) + dfs(node.right, currentSum);
    }
    
    /**
     * 使用迭代DFS方法计算根到叶节点数字之和
     * 
     * @param root 二叉树的根节点
     * @return 所有根到叶路径数字之和
     * 
     * 算法步骤（迭代DFS）：
     * 1. 使用栈模拟递归过程
     * 2. 每个栈元素包含节点和到该节点的路径数字
     * 3. 当遇到叶节点时，将路径数字加到结果中
     * 
     * 时间复杂度：O(n)
     * 空间复杂度：O(h)
     * 
     * 三种语言实现链接：
     * - Java: 当前方法
     * - Python: https://leetcode.cn/problems/sum-root-to-leaf-numbers/solution/python-die-dai-qiu-lu-jing-he-by-xxx/
     * - C++: https://leetcode.cn/problems/sum-root-to-leaf-numbers/solution/c-die-dai-qiu-lu-jing-he-by-xxx/
     */
    public int sumNumbersIterative(TreeNode root) {
        // 防御性编程：处理空树情况
        if (root == null) {
            return 0;
        }
        
        // 定义节点和路径和的结构体
        class NodeSum {
            TreeNode node;
            int sum;
            
            NodeSum(TreeNode node, int sum) {
                this.node = node;
                this.sum = sum;
            }
        }
        
        Stack<NodeSum> stack = new Stack<>();
        stack.push(new NodeSum(root, 0));
        
        int totalSum = 0;
        
        while (!stack.isEmpty()) {
            NodeSum ns = stack.pop();
            
            TreeNode node = ns.node;
            int currentSum = ns.sum;
            
            currentSum = currentSum * 10 + node.val;
            
            // 如果是叶节点，累加到结果中
            if (node.left == null && node.right == null) {
                totalSum += currentSum;
            } else {
                // 非叶节点，继续处理子节点
                // 先压入右子树，再压入左子树，保证左子树先被处理
                if (node.right != null) {
                    stack.push(new NodeSum(node.right, currentSum));
                }
                if (node.left != null) {
                    stack.push(new NodeSum(node.left, currentSum));
                }
            }
        }
        
        return totalSum;
    }
    
    /**
     * 测试方法
     */
    public static void main(String[] args) {
        // 创建测试树: [1,2,3]
        //     1
        //    / \
        //   2   3
        // 路径1->2表示数字12，路径1->3表示数字13
        // 总和 = 12 + 13 = 25
        TreeNode root1 = new TreeNode(1);
        root1.left = new TreeNode(2);
        root1.right = new TreeNode(3);
        
        Code10_MorrisSumRootToLeaf solution = new Code10_MorrisSumRootToLeaf();
        
        System.out.println("测试用例1: [1,2,3]");
        System.out.println("Morris方法结果: " + solution.sumNumbers(root1));
        System.out.println("递归方法结果: " + solution.sumNumbersRecursive(root1));
        System.out.println("迭代方法结果: " + solution.sumNumbersIterative(root1));
        
        // 创建测试树: [4,9,0,5,1]
        //       4
        //      / \
        //     9   0
        //    / \
        //   5   1
        // 路径4->9->5表示数字495，路径4->9->1表示数字491，路径4->0表示数字40
        // 总和 = 495 + 491 + 40 = 1026
        TreeNode root2 = new TreeNode(4);
        root2.left = new TreeNode(9);
        root2.right = new TreeNode(0);
        root2.left.left = new TreeNode(5);
        root2.left.right = new TreeNode(1);
        
        System.out.println("\n测试用例2: [4,9,0,5,1]");
        System.out.println("Morris方法结果: " + solution.sumNumbers(root2));
        System.out.println("递归方法结果: " + solution.sumNumbersRecursive(root2));
        System.out.println("迭代方法结果: " + solution.sumNumbersIterative(root2));
    }
}

// C++版本实现（注释版）
/*
#include <iostream>
#include <stack>
using namespace std;

// 二叉树节点定义
struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode() : val(0), left(nullptr), right(nullptr) {}
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
    TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
};

class Solution {
public:
    // Morris前序遍历方法
    int sumNumbers(TreeNode* root) {
        if (!root) return 0;
        
        int totalSum = 0;
        int currentNum = 0;
        TreeNode* cur = root;
        TreeNode* mostRight = nullptr;
        int depth = 0;
        
        while (cur) {
            mostRight = cur->left;
            if (mostRight) {
                int steps = 0;
                while (mostRight->right && mostRight->right != cur) {
                    mostRight = mostRight->right;
                    steps++;
                }
                
                if (!mostRight->right) {
                    // 第一次到达
                    currentNum = currentNum * 10 + cur->val;
                    depth++;
                    
                    if (!cur->left && !cur->right) {
                        totalSum += currentNum;
                    }
                    
                    mostRight->right = cur;
                    cur = cur->left;
                    continue;
                } else {
                    // 第二次到达，断开线索
                    mostRight->right = nullptr;
                    
                    // 恢复路径值
                    for (int i = 0; i <= steps; i++) {
                        currentNum /= 10;
                        depth--;
                    }
                }
            } else {
                currentNum = currentNum * 10 + cur->val;
                depth++;
                
                if (!cur->right) {
                    totalSum += currentNum;
                    currentNum /= 10;
                    depth--;
                }
            }
            
            cur = cur->right;
        }
        
        return totalSum;
    }
    
    // 递归DFS方法
    int sumNumbersRecursive(TreeNode* root) {
        if (!root) return 0;
        return dfs(root, 0);
    }
    
private:
    int dfs(TreeNode* node, int currentSum) {
        if (!node) return 0;
        
        currentSum = currentSum * 10 + node->val;
        
        if (!node->left && !node->right) {
            return currentSum;
        }
        
        return dfs(node->left, currentSum) + dfs(node->right, currentSum);
    }
    
public:
    // 迭代DFS方法
    int sumNumbersIterative(TreeNode* root) {
        if (!root) return 0;
        
        // 定义节点和路径和的结构体
        struct NodeSum {
            TreeNode* node;
            int sum;
            NodeSum(TreeNode* n, int s) : node(n), sum(s) {}
        };
        
        stack<NodeSum> st;
        st.emplace(root, 0);
        
        int totalSum = 0;
        
        while (!st.empty()) {
            NodeSum ns = st.top();
            st.pop();
            
            TreeNode* node = ns.node;
            int currentSum = ns.sum;
            
            currentSum = currentSum * 10 + node->val;
            
            if (!node->left && !node->right) {
                totalSum += currentSum;
            } else {
                if (node->right) {
                    st.emplace(node->right, currentSum);
                }
                if (node->left) {
                    st.emplace(node->left, currentSum);
                }
            }
        }
        
        return totalSum;
    }
};

// 测试代码
int main() {
    Solution solution;
    
    // 测试用例1: [1,2,3]
    TreeNode* root1 = new TreeNode(1);
    root1->left = new TreeNode(2);
    root1->right = new TreeNode(3);
    
    cout << "测试用例1 Morris方法结果: " << solution.sumNumbers(root1) << endl;
    cout << "测试用例1 递归方法结果: " << solution.sumNumbersRecursive(root1) << endl;
    cout << "测试用例1 迭代方法结果: " << solution.sumNumbersIterative(root1) << endl;
    
    // 释放内存...
    
    return 0;
}
*/

// Python版本实现（注释版）
/*
# 二叉树节点定义
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

class Solution:
    # Morris前序遍历方法
    def sumNumbers(self, root):
        if not root:
            return 0
        
        total_sum = 0
        current_num = 0
        cur = root
        depth = 0
        
        while cur:
            most_right = cur.left
            if most_right:
                # 计算到前驱节点的步数
                steps = 0
                while most_right.right and most_right.right != cur:
                    most_right = most_right.right
                    steps += 1
                
                if not most_right.right:
                    # 第一次到达
                    current_num = current_num * 10 + cur.val
                    depth += 1
                    
                    # 检查是否是叶节点
                    if not cur.left and not cur.right:
                        total_sum += current_num
                    
                    most_right.right = cur
                    cur = cur.left
                    continue
                else:
                    # 第二次到达，断开线索
                    most_right.right = None
                    
                    # 恢复路径值
                    for _ in range(steps + 1):
                        current_num //= 10
                        depth -= 1
            else:
                # 没有左子树
                current_num = current_num * 10 + cur.val
                depth += 1
                
                # 检查是否是叶节点
                if not cur.right:
                    total_sum += current_num
                    current_num //= 10
                    depth -= 1
            
            cur = cur.right
        
        return total_sum
    
    # 递归DFS方法
    def sumNumbersRecursive(self, root):
        if not root:
            return 0
        
        def dfs(node, current_sum):
            if not node:
                return 0
            
            current_sum = current_sum * 10 + node.val
            
            # 叶节点
            if not node.left and not node.right:
                return current_sum
            
            return dfs(node.left, current_sum) + dfs(node.right, current_sum)
        
        return dfs(root, 0)
    
    # 迭代DFS方法
    def sumNumbersIterative(self, root):
        if not root:
            return 0
        
        stack = [(root, 0)]  # (节点, 当前路径和)
        total_sum = 0
        
        while stack:
            node, current_sum = stack.pop()
            
            current_sum = current_sum * 10 + node.val
            
            # 叶节点
            if not node.left and not node.right:
                total_sum += current_sum
            else:
                # 先压入右子树，再压入左子树，保证左子树先被处理
                if node.right:
                    stack.append((node.right, current_sum))
                if node.left:
                    stack.append((node.left, current_sum))
        
        return total_sum

# 测试代码
def test():
    solution = Solution()
    
    # 测试用例1: [1,2,3]
    root1 = TreeNode(1)
    root1.left = TreeNode(2)
    root1.right = TreeNode(3)
    
    print("测试用例1 Morris方法结果:", solution.sumNumbers(root1))
    print("测试用例1 递归方法结果:", solution.sumNumbersRecursive(root1))
    print("测试用例1 迭代方法结果:", solution.sumNumbersIterative(root1))

if __name__ == "__main__":
    test()
*/
}

===============================================

文件: Code10_MorrisSumRootToLeafNew.java
===============================================
package class124;

import java.util.Stack;

/**
 * Morris遍历求根到叶数字之和
 * 
 * 题目来源：
 * - 求根到叶数字之和：LeetCode 129. Sum Root to Leaf Numbers
 *   链接：https://leetcode.cn/problems/sum-root-to-leaf-numbers/
 * 
 * Morris遍历是一种空间复杂度为O(1)的二叉树遍历算法，通过临时修改树的结构（利用叶子节点的空闲指针）
 * 来避免使用栈或递归调用栈所需的额外空间。算法的核心思想是将树转换为一个线索二叉树。
 * 
 * 本实现包含：
 * 1. Java语言的Morris前序遍历求根到叶数字之和
 * 2. 递归版本的求根到叶数字之和
 * 3. 迭代版本的求根到叶数字之和
 * 4. 详细的注释和算法解析
 * 5. 完整的测试用例
 * 6. C++和Python语言的完整实现
 * 
 * 三种语言实现链接：
 * - Java: 当前文件
 * - Python: https://leetcode.cn/problems/sum-root-to-leaf-numbers/solution/python-morris-qiu-gen-dao-xie-shu-zi-zhi-he-by-xxx/
 * - C++: https://leetcode.cn/problems/sum-root-to-leaf-numbers/solution/c-morris-qiu-gen-dao-xie-shu-zi-zhi-he-by-xxx/
 * 
 * 算法详解：
 * 给定一个二叉树，每个节点包含0-9的数字，每条从根到叶节点的路径表示一个数字。
 * 计算所有从根到叶节点生成的数字之和。
 * 
 * 解题思路：
 * 1. 使用Morris前序遍历访问树的每个节点
 * 2. 在遍历过程中维护从根到当前节点的数字
 * 3. 当到达叶节点时，将该数字加到总和中
 * 4. 利用Morris遍历的线索化特性，在回溯时正确恢复路径数字
 * 
 * 时间复杂度：O(n) - 每个节点最多被访问两次
 * 空间复杂度：O(1) - 不使用额外空间
 * 适用场景：内存受限环境中计算二叉树根到叶路径数字之和
 * 优缺点分析：
 * - 优点：空间复杂度最优，适合内存受限环境
 * - 缺点：实现复杂，需要维护路径数字和深度信息
 */
public class Code10_MorrisSumRootToLeafNew {

	// 二叉树节点定义
	public static class TreeNode {
		int val;
		TreeNode left;
		TreeNode right;
		TreeNode() {}
		TreeNode(int val) { this.val = val; }
		TreeNode(int val, TreeNode left, TreeNode right) {
			this.val = val;
			this.left = left;
			this.right = right;
		}
	}
	
	/**
	 * 使用Morris前序遍历计算根到叶节点数字之和
	 * 注意：这是一个特殊的实现，因为标准Morris遍历不适合路径回溯问题
	 * 
	 * @param root 二叉树的根节点
	 * @return 所有根到叶路径数字之和
	 * @throws NullPointerException 如果root为null（但代码已处理null情况，此处仅作文档说明）
	 * 
	 * 题目描述：
	 * 给你一个二叉树的根节点 root ，树中每个节点都存放有一个 0 到 9 之间的数字。
	 * 每条从根节点到叶节点的路径都代表一个数字：
	 * 例如，从根节点到叶节点的路径 1 -> 2 -> 3 表示数字 123 。
	 * 计算从根节点到叶节点生成的所有数字之和。
	 * 叶节点是指没有子节点的节点。
	 * 
	 * 解题思路：
	 * 1. 需要遍历所有从根到叶的路径
	 * 2. 在遍历过程中维护当前路径表示的数字
	 * 3. 当到达叶节点时，将当前数字加到结果中
	 * 4. 本实现提供三种方法：Morris前序遍历、递归DFS、迭代DFS
	 * 
	 * 算法步骤（Morris前序遍历）：
	 * 1. 使用Morris前序遍历遍历二叉树
	 * 2. 在遍历过程中维护从根到当前节点的数字路径
	 * 3. 当到达叶节点时，累加路径数字到结果中
	 * 4. 需要特别处理回溯过程，因为Morris遍历会修改树结构
	 * 
	 * 时间复杂度：
	 * - Morris方法：O(n) - 需要遍历所有节点，每个节点最多被访问3次
	 * - 递归方法：O(n) - 每个节点被访问一次
	 * - 迭代方法：O(n) - 每个节点被访问一次
	 * 
	 * 空间复杂度：
	 * - Morris方法：O(1) - 仅使用常数额外空间
	 * - 递归方法：O(h) - h为树高，最坏情况下为O(n)
	 * - 迭代方法：O(h) - 栈的空间复杂度，最坏情况下为O(n)
	 * 
	 * 是否为最优解：
	 * - 从空间复杂度角度，Morris方法最优
	 * - 从实现复杂度和代码可读性角度，递归方法最优
	 * - 对于此问题，推荐使用递归或迭代方法
	 * 
	 * 适用场景：
	 * 1. 理解Morris遍历思想的扩展应用
	 * 2. 面试中展示对算法的深入理解
	 * 3. 空间受限环境下的路径求和问题
	 * 
	 * 三种语言实现链接：
	 * - Java: 当前方法
	 * - Python: https://leetcode.cn/problems/sum-root-to-leaf-numbers/solution/python-morris-qiu-lu-jing-he-by-xxx/
	 * - C++: https://leetcode.cn/problems/sum-root-to-leaf-numbers/solution/c-morris-qiu-lu-jing-he-by-xxx/
	 */
	public int sumNumbers(TreeNode root) {
		// 防御性编程：处理空树情况
		if (root == null) {
			return 0;
		}
		
		int totalSum = 0;              // 结果总和
		int currentNum = 0;            // 当前路径表示的数字
		TreeNode cur = root;           // 当前节点
		TreeNode mostRight = null;     // 最右节点（前驱节点）
		
		// 记录节点深度，用于正确回溯路径
		int depth = 0;
		
		// Morris前序遍历的核心循环
		while (cur != null) {
			mostRight = cur.left;
			
			// 如果当前节点有左子树
			if (mostRight != null) {
				// 计算到前驱节点的距离（用于正确回溯）
				int steps = 0;
				// 找到左子树中的最右节点（前驱节点）
				while (mostRight.right != null && mostRight.right != cur) {
					mostRight = mostRight.right;
					steps++;
				}
				
				// 判断前驱节点的右指针状态
				if (mostRight.right == null) {
					// 第一次到达，建立线索
					// 更新当前路径数字
					currentNum = currentNum * 10 + cur.val;
					depth++;
					
					// 如果是叶节点，累加到结果中
					if (cur.left == null && cur.right == null) {
						totalSum += currentNum;
					}
					
					mostRight.right = cur;  // 建立线索
					cur = cur.left;         // 继续向左子树深入
					continue;               // 跳过当前迭代的剩余部分
				} else {
					// 第二次到达，断开线索
					mostRight.right = null; // 断开线索，恢复树的原始结构
					
					// 恢复currentNum，回溯路径
					// 这里需要根据到前驱节点的距离正确恢复路径值
					for (int i = 0; i <= steps; i++) {
						currentNum /= 10;
						depth--;
					}
				}
			} else {
				// 没有左子树，直接处理当前节点
				currentNum = currentNum * 10 + cur.val;
				depth++;
				
				// 如果是叶节点，累加到结果中
				if (cur.right == null) { // 因为没有左子树，所以只需要检查右子树
					totalSum += currentNum;
					// 回溯路径（如果有父节点）
					currentNum /= 10;
					depth--;
				}
			}
			
			cur = cur.right; // 移动到右子树或通过线索回到父节点
		}
		
		return totalSum;
	}
	
	/**
	 * 使用递归DFS方法计算根到叶节点数字之和（推荐方法）
	 * 
	 * @param root 二叉树的根节点
	 * @return 所有根到叶路径数字之和
	 * 
	 * 算法步骤（递归DFS）：
	 * 1. 递归遍历二叉树
	 * 2. 在递归过程中维护当前路径表示的数字
	 * 3. 当到达叶节点时，返回当前路径数字作为贡献值
	 * 4. 非叶节点返回左右子树贡献值之和
	 * 
	 * 时间复杂度：O(n)
	 * 空间复杂度：O(h)
	 * 
	 * 三种语言实现链接：
	 * - Java: 当前方法
	 * - Python: https://leetcode.cn/problems/sum-root-to-leaf-numbers/solution/python-di-gui-qiu-lu-jing-he-by-xxx/
	 * - C++: https://leetcode.cn/problems/sum-root-to-leaf-numbers/solution/c-di-gui-qiu-lu-jing-he-by-xxx/
	 */
	public int sumNumbersRecursive(TreeNode root) {
		// 防御性编程：处理空树情况
		if (root == null) {
			return 0;
		}
		
		// 调用递归辅助函数，初始路径和为0
		return dfs(root, 0);
	}
	
	/**
	 * 递归DFS辅助函数
	 * 
	 * @param node 当前节点
	 * @param currentSum 到当前节点的路径数字
	 * @return 以当前节点为根的子树的所有路径数字之和
	 * 
	 * 三种语言实现链接：
	 * - Java: 当前方法
	 * - Python: https://leetcode.cn/problems/sum-root-to-leaf-numbers/solution/python-di-gui-qiu-lu-jing-he-by-xxx/
	 * - C++: https://leetcode.cn/problems/sum-root-to-leaf-numbers/solution/c-di-gui-qiu-lu-jing-he-by-xxx/
	 */
	private int dfs(TreeNode node, int currentSum) {
		// 基本情况：空节点贡献0
		if (node == null) {
			return 0;
		}
		
		// 更新当前路径数字
		currentSum = currentSum * 10 + node.val;
		
		// 如果是叶节点，返回当前路径数字
		if (node.left == null && node.right == null) {
			return currentSum;
		}
		
		// 非叶节点：返回左右子树的贡献值之和
		return dfs(node.left, currentSum) + dfs(node.right, currentSum);
	}
	
	/**
	 * 使用迭代DFS方法计算根到叶节点数字之和
	 * 
	 * @param root 二叉树的根节点
	 * @return 所有根到叶路径数字之和
	 * 
	 * 算法步骤（迭代DFS）：
	 * 1. 使用栈模拟递归过程
	 * 2. 每个栈元素包含节点和到该节点的路径数字
	 * 3. 当遇到叶节点时，将路径数字加到结果中
	 * 
	 * 时间复杂度：O(n)
	 * 空间复杂度：O(h)
	 * 
	 * 三种语言实现链接：
	 * - Java: 当前方法
	 * - Python: https://leetcode.cn/problems/sum-root-to-leaf-numbers/solution/python-die-dai-qiu-lu-jing-he-by-xxx/
	 * - C++: https://leetcode.cn/problems/sum-root-to-leaf-numbers/solution/c-die-dai-qiu-lu-jing-he-by-xxx/
	 */
	public int sumNumbersIterative(TreeNode root) {
		// 防御性编程：处理空树情况
		if (root == null) {
			return 0;
		}
		
		// 定义节点和路径和的结构体
		class NodeSum {
			TreeNode node;
			int sum;
			
			NodeSum(TreeNode node, int sum) {
				this.node = node;
				this.sum = sum;
			}
		}
		
		Stack<NodeSum> stack = new Stack<>();
		stack.push(new NodeSum(root, 0));
		
		int totalSum = 0;
		
		while (!stack.isEmpty()) {
			NodeSum ns = stack.pop();
			
			TreeNode node = ns.node;
			int currentSum = ns.sum;
			
			currentSum = currentSum * 10 + node.val;
			
			// 如果是叶节点，累加到结果中
			if (node.left == null && node.right == null) {
				totalSum += currentSum;
			} else {
				// 非叶节点，继续处理子节点
				// 先压入右子树，再压入左子树，保证左子树先被处理
				if (node.right != null) {
					stack.push(new NodeSum(node.right, currentSum));
				}
				if (node.left != null) {
					stack.push(new NodeSum(node.left, currentSum));
				}
			}
		}
		
		return totalSum;
	}
	
	/**
	 * 测试方法
	 */
	public static void main(String[] args) {
		// 创建测试树: [1,2,3]
		//     1
		//    / \
		//   2   3
		// 路径1->2表示数字12，路径1->3表示数字13
		// 总和 = 12 + 13 = 25
		TreeNode root1 = new TreeNode(1);
		root1.left = new TreeNode(2);
		root1.right = new TreeNode(3);
		
		Code10_MorrisSumRootToLeafNew solution = new Code10_MorrisSumRootToLeafNew();
		
		System.out.println("测试用例1: [1,2,3]");
		System.out.println("Morris方法结果: " + solution.sumNumbers(root1));
		System.out.println("递归方法结果: " + solution.sumNumbersRecursive(root1));
		System.out.println("迭代方法结果: " + solution.sumNumbersIterative(root1));
		
		// 创建测试树: [4,9,0,5,1]
		//       4
		//      / \
		//     9   0
		//    / \
		//   5   1
		// 路径4->9->5表示数字495，路径4->9->1表示数字491，路径4->0表示数字40
		// 总和 = 495 + 491 + 40 = 1026
		TreeNode root2 = new TreeNode(4);
		root2.left = new TreeNode(9);
		root2.right = new TreeNode(0);
		root2.left.left = new TreeNode(5);
		root2.left.right = new TreeNode(1);
		
		System.out.println("\n测试用例2: [4,9,0,5,1]");
		System.out.println("Morris方法结果: " + solution.sumNumbers(root2));
		System.out.println("递归方法结果: " + solution.sumNumbersRecursive(root2));
		System.out.println("迭代方法结果: " + solution.sumNumbersIterative(root2));
	}
}

===============================================

文件: Code10_MorrisSumRootToLeaf_fixed.java
===============================================
package class124;

import java.util.Stack;

/**
 * 使用Morris遍历解决求根到叶子节点数字之和问题
 * 
 * 题目来源：
 * - 求根到叶子节点数字之和：LeetCode 129. Sum Root to Leaf Numbers
 *   链接：https://leetcode.cn/problems/sum-root-to-leaf-numbers/
 * 
 * Morris遍历是一种空间复杂度为O(1)的二叉树遍历算法，通过临时修改树的结构（利用叶子节点的空闲指针）
 * 来避免使用栈或递归调用栈所需的额外空间。算法的核心思想是将树转换为一个线索二叉树。
 * 
 * 本实现包含：
 * 1. Java语言的Morris前序遍历求路径和
 * 2. 递归版本的求路径和
 * 3. 迭代版本的求路径和
 * 4. 详细的注释和算法解析
 * 5. 完整的测试用例
 * 6. C++和Python语言的完整实现
 * 
 * 三种语言实现链接：
 * - Java: 当前文件
 * - Python: https://leetcode.cn/problems/sum-root-to-leaf-numbers/solution/python-morris-qiu-lu-jing-he-by-xxx/
 * - C++: https://leetcode.cn/problems/sum-root-to-leaf-numbers/solution/c-morris-qiu-lu-jing-he-by-xxx/
 */
public class Code10_MorrisSumRootToLeaf {

    // 二叉树节点定义
    public static class TreeNode {
        int val;
        TreeNode left;
        TreeNode right;

        TreeNode() {}

        TreeNode(int val) {
            this.val = val;
        }

        TreeNode(int val, TreeNode left, TreeNode right) {
            this.val = val;
            this.left = left;
            this.right = right;
        }
    }

    /**
     * 使用Morris前序遍历计算根到叶节点数字之和
     * 注意：这是一个特殊的实现，因为标准Morris遍历不适合路径回溯问题
     * 
     * @param root 二叉树的根节点
     * @return 所有根到叶路径数字之和
     * @throws NullPointerException 如果root为null（但代码已处理null情况，此处仅作文档说明）
     * 
     * 题目描述：
     * 给你一个二叉树的根节点 root ，树中每个节点都存放有一个 0 到 9 之间的数字。
     * 每条从根节点到叶节点的路径都代表一个数字：
     * 例如，从根节点到叶节点的路径 1 -> 2 -> 3 表示数字 123 。
     * 计算从根节点到叶节点生成的所有数字之和。
     * 叶节点是指没有子节点的节点。
     * 
     * 解题思路：
     * 1. 需要遍历所有从根到叶的路径
     * 2. 在遍历过程中维护当前路径表示的数字
     * 3. 当到达叶节点时，将当前数字加到结果中
     * 4. 本实现提供三种方法：Morris前序遍历、递归DFS、迭代DFS
     * 
     * 算法步骤（Morris前序遍历）：
     * 1. 使用Morris前序遍历遍历二叉树
     * 2. 在遍历过程中维护从根到当前节点的数字路径
     * 3. 当到达叶节点时，累加路径数字到结果中
     * 4. 需要特别处理回溯过程，因为Morris遍历会修改树结构
     * 
     * 时间复杂度：
     * - Morris方法：O(n) - 需要遍历所有节点，每个节点最多被访问3次
     * - 递归方法：O(n) - 每个节点被访问一次
     * - 迭代方法：O(n) - 每个节点被访问一次
     * 
     * 空间复杂度：
     * - Morris方法：O(1) - 仅使用常数额外空间
     * - 递归方法：O(h) - h为树高，最坏情况下为O(n)
     * - 迭代方法：O(h) - 栈的空间复杂度，最坏情况下为O(n)
     * 
     * 是否为最优解：
     * - 从空间复杂度角度，Morris方法最优
     * - 从实现复杂度和代码可读性角度，递归方法最优
     * - 对于此问题，推荐使用递归或迭代方法
     * 
     * 适用场景：
     * 1. 理解Morris遍历思想的扩展应用
     * 2. 面试中展示对算法的深入理解
     * 3. 空间受限环境下的路径求和问题
     * 
     * 三种语言实现链接：
     * - Java: 当前方法
     * - Python: https://leetcode.cn/problems/sum-root-to-leaf-numbers/solution/python-morris-qiu-lu-jing-he-by-xxx/
     * - C++: https://leetcode.cn/problems/sum-root-to-leaf-numbers/solution/c-morris-qiu-lu-jing-he-by-xxx/
     */
    public int sumNumbers(TreeNode root) {
        // 防御性编程：处理空树情况
        if (root == null) {
            return 0;
        }
        
        int totalSum = 0;              // 结果总和
        int currentNum = 0;            // 当前路径表示的数字
        TreeNode cur = root;           // 当前节点
        TreeNode mostRight = null;     // 最右节点（前驱节点）
        
        // 记录节点深度，用于正确回溯路径
        int depth = 0;
        
        // Morris前序遍历的核心循环
        while (cur != null) {
            mostRight = cur.left;
            
            // 如果当前节点有左子树
            if (mostRight != null) {
                // 计算到前驱节点的距离（用于正确回溯）
                int steps = 0;
                // 找到左子树中的最右节点（前驱节点）
                while (mostRight.right != null && mostRight.right != cur) {
                    mostRight = mostRight.right;
                    steps++;
                }
                
                // 判断前驱节点的右指针状态
                if (mostRight.right == null) {
                    // 第一次到达，建立线索
                    // 更新当前路径数字
                    currentNum = currentNum * 10 + cur.val;
                    depth++;
                    
                    // 如果是叶节点，累加到结果中
                    if (cur.left == null && cur.right == null) {
                        totalSum += currentNum;
                    }
                    
                    mostRight.right = cur;  // 建立线索
                    cur = cur.left;         // 继续向左子树深入
                    continue;               // 跳过当前迭代的剩余部分
                } else {
                    // 第二次到达，断开线索
                    mostRight.right = null; // 断开线索，恢复树的原始结构
                    
                    // 恢复currentNum，回溯路径
                    // 这里需要根据到前驱节点的距离正确恢复路径值
                    for (int i = 0; i <= steps; i++) {
                        currentNum /= 10;
                        depth--;
                    }
                }
            } else {
                // 没有左子树，直接处理当前节点
                currentNum = currentNum * 10 + cur.val;
                depth++;
                
                // 如果是叶节点，累加到结果中
                if (cur.right == null) { // 因为没有左子树，所以只需要检查右子树
                    totalSum += currentNum;
                    // 回溯路径（如果有父节点）
                    currentNum /= 10;
                    depth--;
                }
            }
            
            cur = cur.right; // 移动到右子树或通过线索回到父节点
        }
        
        return totalSum;
    }
    
    /**
     * 使用递归DFS方法计算根到叶节点数字之和（推荐方法）
     * 
     * @param root 二叉树的根节点
     * @return 所有根到叶路径数字之和
     * 
     * 算法步骤（递归DFS）：
     * 1. 递归遍历二叉树
     * 2. 在递归过程中维护当前路径表示的数字
     * 3. 当到达叶节点时，返回当前路径数字作为贡献值
     * 4. 非叶节点返回左右子树贡献值之和
     * 
     * 时间复杂度：O(n)
     * 空间复杂度：O(h)
     * 
     * 三种语言实现链接：
     * - Java: 当前方法
     * - Python: https://leetcode.cn/problems/sum-root-to-leaf-numbers/solution/python-di-gui-qiu-lu-jing-he-by-xxx/
     * - C++: https://leetcode.cn/problems/sum-root-to-leaf-numbers/solution/c-di-gui-qiu-lu-jing-he-by-xxx/
     */
    public int sumNumbersRecursive(TreeNode root) {
        // 防御性编程：处理空树情况
        if (root == null) {
            return 0;
        }
        
        // 调用递归辅助函数，初始路径和为0
        return dfs(root, 0);
    }
    
    /**
     * 递归DFS辅助函数
     * 
     * @param node 当前节点
     * @param currentSum 到当前节点的路径数字
     * @return 以当前节点为根的子树的所有路径数字之和
     * 
     * 三种语言实现链接：
     * - Java: 当前方法
     * - Python: https://leetcode.cn/problems/sum-root-to-leaf-numbers/solution/python-di-gui-qiu-lu-jing-he-by-xxx/
     * - C++: https://leetcode.cn/problems/sum-root-to-leaf-numbers/solution/c-di-gui-qiu-lu-jing-he-by-xxx/
     */
    private int dfs(TreeNode node, int currentSum) {
        // 基本情况：空节点贡献0
        if (node == null) {
            return 0;
        }
        
        // 更新当前路径数字
        currentSum = currentSum * 10 + node.val;
        
        // 如果是叶节点，返回当前路径数字
        if (node.left == null && node.right == null) {
            return currentSum;
        }
        
        // 非叶节点：返回左右子树的贡献值之和
        return dfs(node.left, currentSum) + dfs(node.right, currentSum);
    }
    
    /**
     * 使用迭代DFS方法计算根到叶节点数字之和
     * 
     * @param root 二叉树的根节点
     * @return 所有根到叶路径数字之和
     * 
     * 算法步骤（迭代DFS）：
     * 1. 使用栈模拟递归过程
     * 2. 每个栈元素包含节点和到该节点的路径数字
     * 3. 当遇到叶节点时，将路径数字加到结果中
     * 
     * 时间复杂度：O(n)
     * 空间复杂度：O(h)
     * 
     * 三种语言实现链接：
     * - Java: 当前方法
     * - Python: https://leetcode.cn/problems/sum-root-to-leaf-numbers/solution/python-die-dai-qiu-lu-jing-he-by-xxx/
     * - C++: https://leetcode.cn/problems/sum-root-to-leaf-numbers/solution/c-die-dai-qiu-lu-jing-he-by-xxx/
     */
    public int sumNumbersIterative(TreeNode root) {
        // 防御性编程：处理空树情况
        if (root == null) {
            return 0;
        }
        
        // 定义节点和路径和的结构体
        class NodeSum {
            TreeNode node;
            int sum;
            
            NodeSum(TreeNode node, int sum) {
                this.node = node;
                this.sum = sum;
            }
        }
        
        Stack<NodeSum> stack = new Stack<>();
        stack.push(new NodeSum(root, 0));
        
        int totalSum = 0;
        
        while (!stack.isEmpty()) {
            NodeSum ns = stack.pop();
            
            TreeNode node = ns.node;
            int currentSum = ns.sum;
            
            currentSum = currentSum * 10 + node.val;
            
            // 如果是叶节点，累加到结果中
            if (node.left == null && node.right == null) {
                totalSum += currentSum;
            } else {
                // 非叶节点，继续处理子节点
                // 先压入右子树，再压入左子树，保证左子树先被处理
                if (node.right != null) {
                    stack.push(new NodeSum(node.right, currentSum));
                }
                if (node.left != null) {
                    stack.push(new NodeSum(node.left, currentSum));
                }
            }
        }
        
        return totalSum;
    }
    
    /**
     * 测试方法
     */
    public static void main(String[] args) {
        // 创建测试树: [1,2,3]
        //     1
        //    / \
        //   2   3
        // 路径1->2表示数字12，路径1->3表示数字13
        // 总和 = 12 + 13 = 25
        TreeNode root1 = new TreeNode(1);
        root1.left = new TreeNode(2);
        root1.right = new TreeNode(3);
        
        Code10_MorrisSumRootToLeaf solution = new Code10_MorrisSumRootToLeaf();
        
        System.out.println("测试用例1: [1,2,3]");
        System.out.println("Morris方法结果: " + solution.sumNumbers(root1));
        System.out.println("递归方法结果: " + solution.sumNumbersRecursive(root1));
        System.out.println("迭代方法结果: " + solution.sumNumbersIterative(root1));
        
        // 创建测试树: [4,9,0,5,1]
        //       4
        //      / \
        //     9   0
        //    / \
        //   5   1
        // 路径4->9->5表示数字495，路径4->9->1表示数字491，路径4->0表示数字40
        // 总和 = 495 + 491 + 40 = 1026
        TreeNode root2 = new TreeNode(4);
        root2.left = new TreeNode(9);
        root2.right = new TreeNode(0);
        root2.left.left = new TreeNode(5);
        root2.left.right = new TreeNode(1);
        
        System.out.println("\n测试用例2: [4,9,0,5,1]");
        System.out.println("Morris方法结果: " + solution.sumNumbers(root2));
        System.out.println("递归方法结果: " + solution.sumNumbersRecursive(root2));
        System.out.println("迭代方法结果: " + solution.sumNumbersIterative(root2));
    }
}

// C++版本实现（注释版）
/*
#include <iostream>
#include <stack>
using namespace std;

// 二叉树节点定义
struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode() : val(0), left(nullptr), right(nullptr) {}
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
    TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
};

class Solution {
public:
    // Morris前序遍历方法
    int sumNumbers(TreeNode* root) {
        if (!root) return 0;
        
        int totalSum = 0;
        int currentNum = 0;
        TreeNode* cur = root;
        TreeNode* mostRight = nullptr;
        int depth = 0;
        
        while (cur) {
            mostRight = cur->left;
            if (mostRight) {
                int steps = 0;
                while (mostRight->right && mostRight->right != cur) {
                    mostRight = mostRight->right;
                    steps++;
                }
                
                if (!mostRight->right) {
                    // 第一次到达
                    currentNum = currentNum * 10 + cur->val;
                    depth++;
                    
                    if (!cur->left && !cur->right) {
                        totalSum += currentNum;
                    }
                    
                    mostRight->right = cur;
                    cur = cur->left;
                    continue;
                } else {
                    // 第二次到达，断开线索
                    mostRight->right = nullptr;
                    
                    // 恢复路径值
                    for (int i = 0; i <= steps; i++) {
                        currentNum /= 10;
                        depth--;
                    }
                }
            } else {
                currentNum = currentNum * 10 + cur->val;
                depth++;
                
                if (!cur->right) {
                    totalSum += currentNum;
                    currentNum /= 10;
                    depth--;
                }
            }
            
            cur = cur->right;
        }
        
        return totalSum;
    }
    
    // 递归DFS方法
    int sumNumbersRecursive(TreeNode* root) {
        if (!root) return 0;
        return dfs(root, 0);
    }
    
private:
    int dfs(TreeNode* node, int currentSum) {
        if (!node) return 0;
        
        currentSum = currentSum * 10 + node->val;
        
        if (!node->left && !node->right) {
            return currentSum;
        }
        
        return dfs(node->left, currentSum) + dfs(node->right, currentSum);
    }
    
public:
    // 迭代DFS方法
    int sumNumbersIterative(TreeNode* root) {
        if (!root) return 0;
        
        // 定义节点和路径和的结构体
        struct NodeSum {
            TreeNode* node;
            int sum;
            NodeSum(TreeNode* n, int s) : node(n), sum(s) {}
        };
        
        stack<NodeSum> st;
        st.emplace(root, 0);
        
        int totalSum = 0;
        
        while (!st.empty()) {
            NodeSum ns = st.top();
            st.pop();
            
            TreeNode* node = ns.node;
            int currentSum = ns.sum;
            
            currentSum = currentSum * 10 + node->val;
            
            if (!node->left && !node->right) {
                totalSum += currentSum;
            } else {
                if (node->right) {
                    st.emplace(node->right, currentSum);
                }
                if (node->left) {
                    st.emplace(node->left, currentSum);
                }
            }
        }
        
        return totalSum;
    }
};

// 测试代码
int main() {
    Solution solution;
    
    // 测试用例1: [1,2,3]
    TreeNode* root1 = new TreeNode(1);
    root1->left = new TreeNode(2);
    root1->right = new TreeNode(3);
    
    cout << "测试用例1 Morris方法结果: " << solution.sumNumbers(root1) << endl;
    cout << "测试用例1 递归方法结果: " << solution.sumNumbersRecursive(root1) << endl;
    cout << "测试用例1 迭代方法结果: " << solution.sumNumbersIterative(root1) << endl;
    
    // 释放内存...
    
    return 0;
}
*/

// Python版本实现（注释版）
/*
# 二叉树节点定义
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

class Solution:
    # Morris前序遍历方法
    def sumNumbers(self, root):
        if not root:
            return 0
        
        total_sum = 0
        current_num = 0
        cur = root
        depth = 0
        
        while cur:
            most_right = cur.left
            if most_right:
                # 计算到前驱节点的步数
                steps = 0
                while most_right.right and most_right.right != cur:
                    most_right = most_right.right
                    steps += 1
                
                if not most_right.right:
                    # 第一次到达
                    current_num = current_num * 10 + cur.val
                    depth += 1
                    
                    # 检查是否是叶节点
                    if not cur.left and not cur.right:
                        total_sum += current_num
                    
                    most_right.right = cur
                    cur = cur.left
                    continue
                else:
                    # 第二次到达，断开线索
                    most_right.right = None
                    
                    # 恢复路径值
                    for _ in range(steps + 1):
                        current_num //= 10
                        depth -= 1
            else:
                # 没有左子树
                current_num = current_num * 10 + cur.val
                depth += 1
                
                # 检查是否是叶节点
                if not cur.right:
                    total_sum += current_num
                    current_num //= 10
                    depth -= 1
            
            cur = cur.right
        
        return total_sum
    
    # 递归DFS方法
    def sumNumbersRecursive(self, root):
        if not root:
            return 0
        
        def dfs(node, current_sum):
            if not node:
                return 0
            
            current_sum = current_sum * 10 + node.val
            
            # 叶节点
            if not node.left and not node.right:
                return current_sum
            
            return dfs(node.left, current_sum) + dfs(node.right, current_sum)
        
        return dfs(root, 0)
    
    # 迭代DFS方法
    def sumNumbersIterative(self, root):
        if not root:
            return 0
        
        stack = [(root, 0)]  # (节点, 当前路径和)
        total_sum = 0
        
        while stack:
            node, current_sum = stack.pop()
            
            current_sum = current_sum * 10 + node.val
            
            # 叶节点
            if not node.left and not node.right:
                total_sum += current_sum
            else:
                # 先压入右子树，再压入左子树，保证左子树先被处理
                if node.right:
                    stack.append((node.right, current_sum))
                if node.left:
                    stack.append((node.left, current_sum))
        
        return total_sum

# 测试代码
def test():
    solution = Solution()
    
    # 测试用例1: [1,2,3]
    root1 = TreeNode(1)
    root1.left = TreeNode(2)
    root1.right = TreeNode(3)
    
    print("测试用例1 Morris方法结果:", solution.sumNumbers(root1))
    print("测试用例1 递归方法结果:", solution.sumNumbersRecursive(root1))
    print("测试用例1 迭代方法结果:", solution.sumNumbersIterative(root1))

if __name__ == "__main__":
    test()
*/
}

===============================================

文件: Code11_MorrisConvertBST.cpp
===============================================
/**
 * 使用Morris遍历解决把二叉搜索树转换为累加树问题
 * 
 * 题目来源：LeetCode 538. Convert BST to Greater Tree
 * 题目链接：https://leetcode.cn/problems/convert-bst-to-greater-tree/
 * 
 * 题目描述：
 * 给出二叉搜索树的根节点，该树的节点值各不相同，请你将其转换为累加树（Greater Sum Tree），
 * 使每个节点 node 的新值等于原树中大于或等于 node.val 的值之和。
 * 
 * 解题思路：
 * 1. 利用BST的性质：中序遍历得到递增序列
 * 2. 累加树需要的是大于等于当前节点值的所有节点值之和
 * 3. 可以通过反向中序遍历（右-根-左）来实现
 * 4. 在反向中序遍历过程中维护累加和
 * 5. 使用Morris反向中序遍历实现
 * 
 * 算法步骤：
 * 1. 使用Morris反向中序遍历遍历BST（右-根-左）
 * 2. 在遍历过程中维护累加和sum
 * 3. 每个节点的值更新为累加和
 * 
 * Morris反向中序遍历的实现要点：
 * 1. 与标准中序遍历相反，先处理右子树
 * 2. 找前驱节点时，是在右子树中找最左节点
 * 3. 线索建立和断开的逻辑与标准中序遍历对称
 * 
 * 时间复杂度：O(n) - 需要遍历所有节点
 * 空间复杂度：O(1) - 仅使用常数额外空间
 * 是否为最优解：是，Morris遍历是解决此问题的最优方法
 * 
 * 适用场景：
 * 1. 需要节省内存空间的环境
 * 2. BST反向遍历的应用场景
 * 3. 面试中展示对Morris遍历的深入理解
 * 
 * 扩展思考：
 * 1. 如何处理节点值重复的情况？
 * 2. 如何在并发环境下保证线程安全？
 * 3. 如何处理节点值为负数的情况？
 */

// 由于编译环境限制，不使用STL容器

// 二叉树节点定义
struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode() : val(0), left(nullptr), right(nullptr) {}
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
    TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
};

class Solution {
public:
    /**
     * 使用Morris反向中序遍历将BST转换为累加树
     * 
     * @param root BST的根节点
     * @return 转换后的累加树的根节点
     */
    TreeNode* convertBST(TreeNode* root) {
        int sum = 0;                   // 累加和
        TreeNode* cur = root;          // 当前节点
        TreeNode* mostLeft = nullptr;  // 最左节点（前驱节点）
        
        // Morris反向中序遍历（右-根-左）
        while (cur != nullptr) {
            mostLeft = cur->right;
            
            // 如果当前节点有右子树
            if (mostLeft != nullptr) {
                // 找到右子树中的最左节点（前驱节点）
                while (mostLeft->left != nullptr && mostLeft->left != cur) {
                    mostLeft = mostLeft->left;
                }
                
                // 判断前驱节点的左指针状态
                if (mostLeft->left == nullptr) {
                    // 第一次到达，建立线索
                    mostLeft->left = cur;
                    cur = cur->right;
                    continue;
                } else {
                    // 第二次到达，断开线索
                    mostLeft->left = nullptr;
                }
            }
            
            // 处理当前节点（反向中序遍历的核心处理逻辑）
            sum += cur->val;
            cur->val = sum;
            
            cur = cur->left;
        }
        
        return root;
    }
};

===============================================

文件: Code11_MorrisConvertBST.java
===============================================
package class124;

import java.util.Stack;

/**
 * 使用Morris遍历解决把二叉搜索树转换为累加树问题
 * 
 * 题目来源：
 * - 把二叉搜索树转换为累加树：LeetCode 538. Convert BST to Greater Tree
 *   链接：https://leetcode.cn/problems/convert-bst-to-greater-tree/
 * 
 * Morris遍历是一种空间复杂度为O(1)的二叉树遍历算法，通过临时修改树的结构（利用叶子节点的空闲指针）
 * 来避免使用栈或递归调用栈所需的额外空间。算法的核心思想是将树转换为一个线索二叉树。
 * 
 * 本实现包含：
 * 1. Java语言的Morris反向中序遍历转换BST
 * 2. 递归版本的转换BST
 * 3. 迭代版本的转换BST
 * 4. 详细的注释和算法解析
 * 5. 完整的测试用例
 * 6. C++和Python语言的完整实现
 * 
 * 三种语言实现链接：
 * - Java: 当前文件
 * - Python: https://leetcode.cn/problems/convert-bst-to-greater-tree/solution/python-morris-fan-xiang-zhong-xu-bian-li-zhuan-huan-by-xxx/
 * - C++: https://leetcode.cn/problems/convert-bst-to-greater-tree/solution/c-morris-fan-xiang-zhong-xu-bian-li-zhuan-huan-by-xxx/
 */
public class Code11_MorrisConvertBST {

    // 二叉树节点定义
    public static class TreeNode {
        int val;
        TreeNode left;
        TreeNode right;

        TreeNode() {}

        TreeNode(int val) {
            this.val = val;
        }

        TreeNode(int val, TreeNode left, TreeNode right) {
            this.val = val;
            this.left = left;
            this.right = right;
        }
    }

    /**
     * 使用Morris反向中序遍历将BST转换为累加树
     * 这是空间最优的实现，仅使用O(1)的额外空间
     * 
     * @param root BST的根节点
     * @return 转换后的累加树的根节点
     * @throws NullPointerException 如果root为null（但代码已处理null情况，此处仅作文档说明）
     * 
     * 题目描述：
     * 给出二叉搜索树的根节点，该树的节点值各不相同，请你将其转换为累加树（Greater Sum Tree），
     * 使每个节点 node 的新值等于原树中大于或等于 node.val 的值之和。
     * 
     * 解题思路：
     * 1. 利用BST的性质：中序遍历得到递增序列
     * 2. 累加树需要的是大于等于当前节点值的所有节点值之和
     * 3. 可以通过反向中序遍历（右-根-左）来实现
     * 4. 在反向中序遍历过程中维护累加和
     * 5. 本实现提供三种方法：Morris反向中序遍历、递归DFS、迭代DFS
     * 
     * 算法步骤（Morris反向中序遍历）：
     * 1. 使用Morris反向中序遍历遍历BST（右-根-左）
     * 2. 在遍历过程中维护累加和sum
     * 3. 每个节点的值更新为累加和
     * 
     * Morris反向中序遍历的实现要点：
     * 1. 与标准中序遍历相反，先处理右子树
     * 2. 找前驱节点时，是在右子树中找最左节点
     * 3. 线索建立和断开的逻辑与标准中序遍历对称
     * 
     * 时间复杂度：
     * - Morris方法：O(n) - 需要遍历所有节点，每个节点最多被访问3次
     * - 递归方法：O(n) - 每个节点被访问一次
     * - 迭代方法：O(n) - 每个节点被访问一次
     * 
     * 空间复杂度：
     * - Morris方法：O(1) - 仅使用常数额外空间
     * - 递归方法：O(h) - h为树高，最坏情况下为O(n)
     * - 迭代方法：O(h) - 栈的空间复杂度，最坏情况下为O(n)
     * 
     * 是否为最优解：
     * - 从空间复杂度角度，Morris方法最优
     * - 从代码简洁性角度，递归方法更直观
     * - 实际应用中可根据空间限制选择合适的方法
     * 
     * 适用场景：
     * 1. 需要节省内存空间的环境
     * 2. BST反向遍历的应用场景
     * 3. 面试中展示对Morris遍历的深入理解
     * 4. 大规模二叉搜索树的转换，内存受限场景
     * 
     * 三种语言实现链接：
     * - Java: 当前方法
     * - Python: https://leetcode.cn/problems/convert-bst-to-greater-tree/solution/python-morris-fan-xiang-zhong-xu-bian-li-zhuan-huan-by-xxx/
     * - C++: https://leetcode.cn/problems/convert-bst-to-greater-tree/solution/c-morris-fan-xiang-zhong-xu-bian-li-zhuan-huan-by-xxx/
     */
    public TreeNode convertBST(TreeNode root) {
        // 防御性编程：处理空树情况
        if (root == null) {
            return null;
        }
        
        int sum = 0;                   // 累加和
        TreeNode cur = root;           // 当前节点
        TreeNode mostLeft = null;      // 最左节点（前驱节点）
        
        // Morris反向中序遍历（右-根-左）的核心循环
        while (cur != null) {
            mostLeft = cur.right;
            
            // 如果当前节点有右子树
            if (mostLeft != null) {
                // 找到右子树中的最左节点（前驱节点）
                // 这是与标准中序遍历的关键区别之一
                while (mostLeft.left != null && mostLeft.left != cur) {
                    mostLeft = mostLeft.left;
                }
                
                // 判断前驱节点的左指针状态
                if (mostLeft.left == null) {
                    // 第一次到达，建立线索
                    // 线索指向当前节点，用于后续回溯
                    mostLeft.left = cur;
                    // 继续向右子树深入，保证先访问右子树
                    cur = cur.right;
                    continue;  // 跳过当前迭代的剩余部分
                } else {
                    // 第二次到达，断开线索
                    // 恢复树的原始结构
                    mostLeft.left = null;
                    // 此时需要处理当前节点（在第二次访问时）
                }
            }
            
            // 处理当前节点（反向中序遍历的核心处理逻辑）
            // 更新累加和并设置节点的新值
            sum += cur.val;
            cur.val = sum;
            
            // 处理完当前节点后，移动到左子树
            // 保证遍历顺序为：右-根-左
            cur = cur.left;
        }
        
        // 返回转换后的根节点
        return root;
    }
    
    /**
     * 使用递归DFS方法将BST转换为累加树
     * 递归实现更简洁直观，但空间复杂度为O(h)
     * 
     * @param root BST的根节点
     * @return 转换后的累加树的根节点
     * 
     * 算法步骤（递归DFS）：
     * 1. 递归进行反向中序遍历（右-根-左）
     * 2. 维护一个全局或引用类型的累加和
     * 3. 访问节点时更新其值为累加和，并更新累加和
     * 
     * 时间复杂度：O(n)
     * 空间复杂度：O(h)
     * 
     * 三种语言实现链接：
     * - Java: 当前方法
     * - Python: https://leetcode.cn/problems/convert-bst-to-greater-tree/solution/python-di-gui-zhuan-huan-bst-by-xxx/
     * - C++: https://leetcode.cn/problems/convert-bst-to-greater-tree/solution/c-di-gui-zhuan-huan-bst-by-xxx/
     */
    public TreeNode convertBSTRecursive(TreeNode root) {
        // 使用整型数组作为可变引用，存储累加和
        // 也可以使用成员变量，但为了保持方法的独立性，使用数组
        int[] sum = new int[1];  // sum[0]存储累加和
        dfs(root, sum);
        return root;
    }
    
    /**
     * 递归DFS辅助函数，执行反向中序遍历（右-根-左）
     * 
     * @param node 当前节点
     * @param sum 累加和（作为可变引用传递）
     * 
     * 三种语言实现链接：
     * - Java: 当前方法
     * - Python: https://leetcode.cn/problems/convert-bst-to-greater-tree/solution/python-di-gui-zhuan-huan-bst-by-xxx/
     * - C++: https://leetcode.cn/problems/convert-bst-to-greater-tree/solution/c-di-gui-zhuan-huan-bst-by-xxx/
     */
    private void dfs(TreeNode node, int[] sum) {
        // 基本情况：节点为空
        if (node == null) {
            return;
        }
        
        // 1. 递归处理右子树（先访问右子树）
        dfs(node.right, sum);
        
        // 2. 处理当前节点
        // 更新累加和并设置节点的新值
        sum[0] += node.val;
        node.val = sum[0];
        
        // 3. 递归处理左子树（最后访问左子树）
        dfs(node.left, sum);
    }
    
    /**
     * 使用迭代DFS方法将BST转换为累加树
     * 
     * @param root BST的根节点
     * @return 转换后的累加树的根节点
     * 
     * 算法步骤（迭代DFS）：
     * 1. 使用栈模拟递归的反向中序遍历
     * 2. 维护累加和变量
     * 3. 访问节点时更新其值和累加和
     * 
     * 时间复杂度：O(n)
     * 空间复杂度：O(h)
     * 
     * 三种语言实现链接：
     * - Java: 当前方法
     * - Python: https://leetcode.cn/problems/convert-bst-to-greater-tree/solution/python-die-dai-zhuan-huan-bst-by-xxx/
     * - C++: https://leetcode.cn/problems/convert-bst-to-greater-tree/solution/c-die-dai-zhuan-huan-bst-by-xxx/
     */
    public TreeNode convertBSTIterative(TreeNode root) {
        // 防御性编程：处理空树情况
        if (root == null) {
            return null;
        }
        
        int sum = 0;  // 累加和
        Stack<TreeNode> stack = new Stack<>();
        TreeNode cur = root;
        
        // 迭代反向中序遍历（右-根-左）
        while (cur != null || !stack.isEmpty()) {
            // 1. 一直向右遍历，将节点入栈
            while (cur != null) {
                stack.push(cur);
                cur = cur.right;
            }
            
            // 2. 处理栈顶节点
            cur = stack.pop();
            
            // 3. 更新累加和并设置节点的新值
            sum += cur.val;
            cur.val = sum;
            
            // 4. 处理左子树
            cur = cur.left;
        }
        
        return root;
    }
    
    /**
     * 测试方法
     */
    public static void main(String[] args) {
        // 创建测试树: [4,1,6,0,2,5,7,null,null,null,3,null,null,null,8]
        TreeNode root = new TreeNode(4);
        root.left = new TreeNode(1);
        root.right = new TreeNode(6);
        root.left.left = new TreeNode(0);
        root.left.right = new TreeNode(2);
        root.right.left = new TreeNode(5);
        root.right.right = new TreeNode(7);
        root.left.right.right = new TreeNode(3);
        root.right.right.right = new TreeNode(8);
        
        Code11_MorrisConvertBST solution = new Code11_MorrisConvertBST();
        
        System.out.println("测试用例: [4,1,6,0,2,5,7,null,null,null,3,null,null,null,8]");
        System.out.println("原始树中序遍历结果: ");
        printInOrder(root);
        
        // 使用Morris方法转换
        TreeNode convertedRoot = solution.convertBST(root);
        System.out.println("\nMorris方法转换后中序遍历结果: ");
        printInOrder(convertedRoot);
    }
    
    /**
     * 中序遍历打印树节点值
     * @param root 树的根节点
     */
    public static void printInOrder(TreeNode root) {
        if (root == null) {
            return;
        }
        
        printInOrder(root.left);
        System.out.print(root.val + " ");
        printInOrder(root.right);
    }
}

/*
#include <iostream>
#include <stack>
using namespace std;

// 二叉树节点定义
struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode() : val(0), left(nullptr), right(nullptr) {}
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
    TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
};

class Solution {
public:
    // Morris反向中序遍历方法
    TreeNode* convertBST(TreeNode* root) {
        if (!root) return nullptr;
        
        int sum = 0;
        TreeNode* cur = root;
        TreeNode* mostLeft = nullptr;
        
        while (cur) {
            mostLeft = cur->right;
            if (mostLeft) {
                // 找到右子树中的最左节点（前驱节点）
                while (mostLeft->left && mostLeft->left != cur) {
                    mostLeft = mostLeft->left;
                }
                
                if (!mostLeft->left) {
                    // 第一次到达，建立线索
                    mostLeft->left = cur;
                    cur = cur->right;
                    continue;
                } else {
                    // 第二次到达，断开线索
                    mostLeft->left = nullptr;
                }
            }
            
            // 处理当前节点
            sum += cur->val;
            cur->val = sum;
            
            cur = cur->left;
        }
        
        return root;
    }
    
    // 递归DFS方法
    TreeNode* convertBSTRecursive(TreeNode* root) {
        int sum = 0;
        dfs(root, sum);
        return root;
    }
    
private:
    void dfs(TreeNode* node, int& sum) {
        if (!node) return;
        
        // 先处理右子树
        dfs(node->right, sum);
        
        // 处理当前节点
        sum += node->val;
        node->val = sum;
        
        // 最后处理左子树
        dfs(node->left, sum);
    }
    
public:
    // 迭代DFS方法
    TreeNode* convertBSTIterative(TreeNode* root) {
        if (!root) return nullptr;
        
        int sum = 0;
        stack<TreeNode*> stk;
        TreeNode* cur = root;
        
        while (cur || !stk.empty()) {
            // 一直向右遍历
            while (cur) {
                stk.push(cur);
                cur = cur->right;
            }
            
            // 处理栈顶节点
            cur = stk.top();
            stk.pop();
            
            // 更新累加和和节点值
            sum += cur->val;
            cur->val = sum;
            
            // 处理左子树
            cur = cur->left;
        }
        
        return root;
    }
    
    // 深度克隆树的辅助方法
    TreeNode* deepClone(TreeNode* root) {
        if (!root) return nullptr;
        TreeNode* newRoot = new TreeNode(root->val);
        newRoot->left = deepClone(root->left);
        newRoot->right = deepClone(root->right);
        return newRoot;
    }
    
    // 打印树的辅助方法
    void printTreeInOrder(TreeNode* root) {
        if (!root) return;
        printTreeInOrder(root->left);
        cout << root->val << " ";
        printTreeInOrder(root->right);
    }
};

// 测试代码
int main() {
    Solution solution;
    
    // 测试用例1: [4,1,6,0,2,5,7,null,null,null,3,null,null,null,8]
    TreeNode* root1 = new TreeNode(4);
    root1->left = new TreeNode(1);
    root1->right = new TreeNode(6);
    root1->left->left = new TreeNode(0);
    root1->left->right = new TreeNode(2);
    root1->right->left = new TreeNode(5);
    root1->right->right = new TreeNode(7);
    root1->left->right->right = new TreeNode(3);
    root1->right->right->right = new TreeNode(8);
    
    // 克隆树用于不同方法的测试
    TreeNode* root1Clone1 = solution.deepClone(root1);
    TreeNode* root1Clone2 = solution.deepClone(root1);
    
    cout << "===== 测试用例1 =====" << endl;
    cout << "原始树中序遍历: " << endl;
    solution.printTreeInOrder(root1);
    cout << endl;
    
    TreeNode* result1Morris = solution.convertBST(root1Clone1);
    cout << "Morris方法转换后中序遍历: " << endl;
    solution.printTreeInOrder(result1Morris);
    cout << endl;
    
    // 释放内存...
    
    return 0;
}
*/

/*
 * Python版本实现（注释版）
 * 
 * # 二叉树节点定义
 * class TreeNode:
 *     def __init__(self, val=0, left=None, right=None):
 *         self.val = val
 *         self.left = left
 *         self.right = right
 * 
 * class Solution:
 *     # Morris反向中序遍历方法
 *     def convertBST(self, root):
 *         if not root:
 *             return None
 *         
 *         total_sum = 0
 *         cur = root
 *         
 *         while cur:
 *             most_left = cur.right
 *             if most_left:
 *                 # 找到右子树中的最左节点（前驱节点）
 *                 while most_left.left and most_left.left != cur:
 *                     most_left = most_left.left
 *                 
 *                 if not most_left.left:
 *                     # 第一次到达，建立线索
 *                     most_left.left = cur
 *                     cur = cur.right
 *                     continue
 *                 else:
 *                     # 第二次到达，断开线索
 *                     most_left.left = None
 *             
 *             # 处理当前节点
 *             total_sum += cur.val
 *             cur.val = total_sum
 *             
 *             cur = cur.left
 *         
 *         return root
 *     
 *     # 递归DFS方法
 *     def convertBSTRecursive(self, root):
 *         # 使用可变对象存储累加和
 *         total_sum = [0]
 *         
 *         def dfs(node):
 *             if not node:
 *                 return
 *             
 *             # 先处理右子树
 *             dfs(node.right)
 *             
 *             # 处理当前节点
 *             total_sum[0] += node.val
 *             node.val = total_sum[0]
 *             
 *             # 最后处理左子树
 *             dfs(node.left)
 *         
 *         dfs(root)
 *         return root
 *     
 *     # 迭代DFS方法
 *     def convertBSTIterative(self, root):
 *         if not root:
 *             return None
 *         
 *         total_sum = 0
 *         stack = []
 *         cur = root
 *         
 *         while cur or stack:
 *             # 一直向右遍历
 *             while cur:
 *                 stack.append(cur)
 *                 cur = cur.right
 *             
 *             # 处理栈顶节点
 *             cur = stack.pop()
 *             
 *             # 更新累加和和节点值
 *             total_sum += cur.val
 *             cur.val = total_sum
 *             
 *             # 处理左子树
 *             cur = cur.left
 *         
 *         return root
 *     
 *     # 深度克隆树的辅助方法
 *     def deepClone(self, root):
 *         if not root:
 *             return None
 *         new_root = TreeNode(root.val)
 *         new_root.left = self.deepClone(root.left)
 *         new_root.right = self.deepClone(root.right)
 *         return new_root
 *     
 *     # 打印树的辅助方法
 *     def printTreeInOrder(self, root):
 *         result = []
 *         
 *         def inOrder(node):
 *             if node:
 *                 inOrder(node.left)
 *                 result.append(str(node.val))
 *                 inOrder(node.right)
 *         
 *         inOrder(root)
 *         return " ".join(result)
 * 
 * # 测试代码
 * def test():
 *     solution = Solution()
 *     
 *     # 测试用例1: [4,1,6,0,2,5,7,null,null,null,3,null,null,null,8]
 *     root1 = TreeNode(4)
 *     root1.left = TreeNode(1)
 *     root1.right = TreeNode(6)
 *     root1.left.left = TreeNode(0)
 *     root1.left.right = TreeNode(2)
 *     root1.right.left = TreeNode(5)
 *     root1.right.right = TreeNode(7)
 *     root1.left.right.right = TreeNode(3)
 *     root1.right.right.right = TreeNode(8)
 *     
 *     # 克隆树用于不同方法的测试
 *     root1_clone1 = solution.deepClone(root1)
 *     root1_clone2 = solution.deepClone(root1)
 *     
 *     print("===== 测试用例1 =====")
 *     print("原始树中序遍历:")
 *     print(solution.printTreeInOrder(root1))
 *     
 *     result1_morris = solution.convertBST(root1_clone1)
 *     print("Morris方法转换后中序遍历:")
 *     print(solution.printTreeInOrder(result1_morris))
 *     
 *     result1_recursive = solution.convertBSTRecursive(root1_clone2)
 *     print("递归方法转换后中序遍历:")
 *     print(solution.printTreeInOrder(result1_recursive))
 *     
 *     result1_iterative = solution.convertBSTIterative(root1)
 *     print("迭代方法转换后中序遍历:")
 *     print(solution.printTreeInOrder(result1_iterative))
 * 
 * if __name__ == "__main__":
 *     test()
 */
}

===============================================

文件: Code11_MorrisConvertBST.py
===============================================
"""
使用Morris遍历解决把二叉搜索树转换为累加树问题

题目来源：LeetCode 538. Convert BST to Greater Tree
题目链接：https://leetcode.cn/problems/convert-bst-to-greater-tree/

题目描述：
给出二叉搜索树的根节点，该树的节点值各不相同，请你将其转换为累加树（Greater Sum Tree），
使每个节点 node 的新值等于原树中大于或等于 node.val 的值之和。

解题思路：
1. 利用BST的性质：中序遍历得到递增序列
2. 累加树需要的是大于等于当前节点值的所有节点值之和
3. 可以通过反向中序遍历（右-根-左）来实现
4. 在反向中序遍历过程中维护累加和
5. 使用Morris反向中序遍历实现

算法步骤：
1. 使用Morris反向中序遍历遍历BST（右-根-左）
2. 在遍历过程中维护累加和sum
3. 每个节点的值更新为累加和

Morris反向中序遍历的实现要点：
1. 与标准中序遍历相反，先处理右子树
2. 找前驱节点时，是在右子树中找最左节点
3. 线索建立和断开的逻辑与标准中序遍历对称

时间复杂度：O(n) - 需要遍历所有节点
空间复杂度：O(1) - 仅使用常数额外空间
是否为最优解：是，Morris遍历是解决此问题的最优方法

适用场景：
1. 需要节省内存空间的环境
2. BST反向遍历的应用场景
3. 面试中展示对Morris遍历的深入理解

扩展思考：
1. 如何处理节点值重复的情况？
2. 如何在并发环境下保证线程安全？
3. 如何处理节点值为负数的情况？
"""


# 二叉树节点定义
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right


class Solution:
    def convertBST(self, root):
        """
        使用Morris反向中序遍历将BST转换为累加树
        
        :param root: BST的根节点
        :return: 转换后的累加树的根节点
        """
        total_sum = 0          # 累加和
        cur = root             # 当前节点
        most_left = None       # 最左节点（前驱节点）
        
        # Morris反向中序遍历（右-根-左）
        while cur:
            most_left = cur.right
            
            # 如果当前节点有右子树
            if most_left:
                # 找到右子树中的最左节点（前驱节点）
                while most_left.left and most_left.left != cur:
                    most_left = most_left.left
                
                # 判断前驱节点的左指针状态
                if most_left.left is None:
                    # 第一次到达，建立线索
                    most_left.left = cur
                    cur = cur.right
                    continue
                else:
                    # 第二次到达，断开线索
                    most_left.left = None
            
            # 处理当前节点（反向中序遍历的核心处理逻辑）
            total_sum += cur.val
            cur.val = total_sum
            
            cur = cur.left
        
        return root


# 测试代码
def main():
    solution = Solution()
    
    # 测试用例1: [4,1,6,0,2,5,7,null,null,null,3,null,null,null,8]
    # 原始BST:
    #         4
    #       /   \
    #      1     6
    #     / \   / \
    #    0   2 5   7
    #         \     \
    #          3     8
    # 转换后的累加树:
    #         30
    #       /    \
    #      36     21
    #     /  \   /  \
    #    36  35 26  15
    #          \      \
    #          33      8
    root1 = TreeNode(4)
    root1.left = TreeNode(1)
    root1.right = TreeNode(6)
    root1.left.left = TreeNode(0)
    root1.left.right = TreeNode(2)
    root1.right.left = TreeNode(5)
    root1.right.right = TreeNode(7)
    root1.left.right.right = TreeNode(3)
    root1.right.right.right = TreeNode(8)
    
    result1 = solution.convertBST(root1)
    print("测试用例1完成，结果已存储在result1中")
    
    # 测试用例2: [0,null,1]
    root2 = TreeNode(0)
    root2.right = TreeNode(1)
    
    result2 = solution.convertBST(root2)
    print("测试用例2完成，结果已存储在result2中")


if __name__ == "__main__":
    main()

===============================================

文件: Code11_MorrisConvertBSTFixed.java
===============================================
package class124;

import java.util.Stack;

/**
 * Morris遍历将BST转换为累加树
 * 
 * 题目来源：
 * - 将BST转换为累加树：LeetCode 538. Convert BST to Greater Tree
 *   链接：https://leetcode.cn/problems/convert-bst-to-greater-tree/
 * 
 * Morris遍历是一种空间复杂度为O(1)的二叉树遍历算法，通过临时修改树的结构（利用叶子节点的空闲指针）
 * 来避免使用栈或递归调用栈所需的额外空间。算法的核心思想是将树转换为一个线索二叉树。
 * 
 * 本实现包含：
 * 1. Java语言的Morris反向中序遍历将BST转换为累加树
 * 2. 递归版本的将BST转换为累加树
 * 3. 迭代版本的将BST转换为累加树
 * 4. 详细的注释和算法解析
 * 5. 完整的测试用例
 * 6. C++和Python语言的完整实现
 * 
 * 三种语言实现链接：
 * - Java: 当前文件
 * - Python: https://leetcode.cn/problems/convert-bst-to-greater-tree/solution/python-morris-jiang-bst-zhuan-huan-wei-lei-jia-shu-by-xxx/
 * - C++: https://leetcode.cn/problems/convert-bst-to-greater-tree/solution/c-morris-jiang-bst-zhuan-huan-wei-lei-jia-shu-by-xxx/
 * 
 * 算法详解：
 * 给定一个二叉搜索树(BST)，将其转换为累加树(Greater Sum Tree)，
 * 使得每个节点node的新值等于原树中大于或等于node.val的值之和。
 * 
 * 解题思路：
 * 1. 利用BST的性质：反向中序遍历(右-根-左)得到递减序列
 * 2. 使用Morris反向中序遍历访问节点
 * 3. 在遍历过程中维护累加和
 * 4. 将每个节点的值更新为累加和
 * 
 * 时间复杂度：O(n) - 每个节点最多被访问两次
 * 空间复杂度：O(1) - 不使用额外空间
 * 适用场景：内存受限环境中将BST转换为累加树
 * 优缺点分析：
 * - 优点：空间复杂度最优，适合内存受限环境
 * - 缺点：实现复杂，需要维护累加和状态
 */
public class Code11_MorrisConvertBSTFixed {

	// 二叉树节点定义
	public static class TreeNode {
		int val;
		TreeNode left;
		TreeNode right;
		TreeNode() {}
		TreeNode(int val) { this.val = val; }
		TreeNode(int val, TreeNode left, TreeNode right) {
			this.val = val;
			this.left = left;
			this.right = right;
		}
	}
	
	/**
	 * 使用Morris反向中序遍历将BST转换为累加树
	 * 这是空间最优的实现，仅使用O(1)的额外空间
	 * 
	 * @param root BST的根节点
	 * @return 转换后的累加树的根节点
	 * @throws NullPointerException 如果root为null（但代码已处理null情况，此处仅作文档说明）
	 * 
	 * 题目描述：
	 * 给出二叉搜索树的根节点，该树的节点值各不相同，请你将其转换为累加树（Greater Sum Tree），
	 * 使每个节点 node 的新值等于原树中大于或等于 node.val 的值之和。
	 * 
	 * 解题思路：
	 * 1. 利用BST的性质：中序遍历得到递增序列
	 * 2. 累加树需要的是大于等于当前节点值的所有节点值之和
	 * 3. 可以通过反向中序遍历（右-根-左）来实现
	 * 4. 在反向中序遍历过程中维护累加和
	 * 5. 本实现提供三种方法：Morris反向中序遍历、递归DFS、迭代DFS
	 * 
	 * 算法步骤（Morris反向中序遍历）：
	 * 1. 使用Morris反向中序遍历遍历BST（右-根-左）
	 * 2. 在遍历过程中维护累加和sum
	 * 3. 每个节点的值更新为累加和
	 * 
	 * Morris反向中序遍历的实现要点：
	 * 1. 与标准中序遍历相反，先处理右子树
	 * 2. 找前驱节点时，是在右子树中找最左节点
	 * 3. 线索建立和断开的逻辑与标准中序遍历对称
	 * 
	 * 时间复杂度：
	 * - Morris方法：O(n) - 需要遍历所有节点，每个节点最多被访问3次
	 * - 递归方法：O(n) - 每个节点被访问一次
	 * - 迭代方法：O(n) - 每个节点被访问一次
	 * 
	 * 空间复杂度：
	 * - Morris方法：O(1) - 仅使用常数额外空间
	 * - 递归方法：O(h) - h为树高，最坏情况下为O(n)
	 * - 迭代方法：O(h) - 栈的空间复杂度，最坏情况下为O(n)
	 * 
	 * 是否为最优解：
	 * - 从空间复杂度角度，Morris方法最优
	 * - 从代码简洁性角度，递归方法更直观
	 * - 实际应用中可根据空间限制选择合适的方法
	 * 
	 * 适用场景：
	 * 1. 需要节省内存空间的环境
	 * 2. BST反向遍历的应用场景
	 * 3. 面试中展示对Morris遍历的深入理解
	 * 4. 大规模二叉搜索树的转换，内存受限场景
	 * 
	 * 三种语言实现链接：
	 * - Java: 当前方法
	 * - Python: https://leetcode.cn/problems/convert-bst-to-greater-tree/solution/python-morris-fan-xiang-zhong-xu-bian-li-zhuan-huan-by-xxx/
	 * - C++: https://leetcode.cn/problems/convert-bst-to-greater-tree/solution/c-morris-fan-xiang-zhong-xu-bian-li-zhuan-huan-by-xxx/
	 */
	public TreeNode convertBST(TreeNode root) {
		// 防御性编程：处理空树情况
		if (root == null) {
			return null;
		}
		
		int sum = 0;                   // 累加和
		TreeNode cur = root;           // 当前节点
		TreeNode mostLeft = null;      // 最左节点（前驱节点）
		
		// Morris反向中序遍历（右-根-左）的核心循环
		while (cur != null) {
			mostLeft = cur.right;
			
			// 如果当前节点有右子树
			if (mostLeft != null) {
				// 找到右子树中的最左节点（前驱节点）
				// 这是与标准中序遍历的关键区别之一
				while (mostLeft.left != null && mostLeft.left != cur) {
					mostLeft = mostLeft.left;
				}
				
				// 判断前驱节点的左指针状态
				if (mostLeft.left == null) {
					// 第一次到达，建立线索
					// 线索指向当前节点，用于后续回溯
					mostLeft.left = cur;
					// 继续向右子树深入，保证先访问右子树
					cur = cur.right;
					continue;  // 跳过当前迭代的剩余部分
				} else {
					// 第二次到达，断开线索
					// 恢复树的原始结构
					mostLeft.left = null;
					// 此时需要处理当前节点（在第二次访问时）
				}
			}
			
			// 处理当前节点（反向中序遍历的核心处理逻辑）
			// 更新累加和并设置节点的新值
			sum += cur.val;
			cur.val = sum;
			
			// 处理完当前节点后，移动到左子树
			// 保证遍历顺序为：右-根-左
			cur = cur.left;
		}
		
		// 返回转换后的根节点
		return root;
	}
	
	/**
	 * 使用递归DFS方法将BST转换为累加树
	 * 递归实现更简洁直观，但空间复杂度为O(h)
	 * 
	 * @param root BST的根节点
	 * @return 转换后的累加树的根节点
	 * 
	 * 算法步骤（递归DFS）：
	 * 1. 递归进行反向中序遍历（右-根-左）
	 * 2. 维护一个全局或引用类型的累加和
	 * 3. 访问节点时更新其值为累加和，并更新累加和
	 * 
	 * 时间复杂度：O(n)
	 * 空间复杂度：O(h)
	 * 
	 * 三种语言实现链接：
	 * - Java: 当前方法
	 * - Python: https://leetcode.cn/problems/convert-bst-to-greater-tree/solution/python-di-gui-zhuan-huan-bst-by-xxx/
	 * - C++: https://leetcode.cn/problems/convert-bst-to-greater-tree/solution/c-di-gui-zhuan-huan-bst-by-xxx/
	 */
	public TreeNode convertBSTRecursive(TreeNode root) {
		// 使用整型数组作为可变引用，存储累加和
		// 也可以使用成员变量，但为了保持方法的独立性，使用数组
		int[] sum = new int[1];  // sum[0]存储累加和
		dfs(root, sum);
		return root;
	}
	
	/**
	 * 递归DFS辅助函数，执行反向中序遍历（右-根-左）
	 * 
	 * @param node 当前节点
	 * @param sum 累加和（作为可变引用传递）
	 * 
	 * 三种语言实现链接：
	 * - Java: 当前方法
	 * - Python: https://leetcode.cn/problems/convert-bst-to-greater-tree/solution/python-di-gui-zhuan-huan-bst-by-xxx/
	 * - C++: https://leetcode.cn/problems/convert-bst-to-greater-tree/solution/c-di-gui-zhuan-huan-bst-by-xxx/
	 */
	private void dfs(TreeNode node, int[] sum) {
		// 基本情况：节点为空
		if (node == null) {
			return;
		}
		
		// 1. 递归处理右子树（先访问右子树）
		dfs(node.right, sum);
		
		// 2. 处理当前节点
		// 更新累加和并设置节点的新值
		sum[0] += node.val;
		node.val = sum[0];
		
		// 3. 递归处理左子树（最后访问左子树）
		dfs(node.left, sum);
	}
	
	/**
	 * 使用迭代DFS方法将BST转换为累加树
	 * 
	 * @param root BST的根节点
	 * @return 转换后的累加树的根节点
	 * 
	 * 算法步骤（迭代DFS）：
	 * 1. 使用栈模拟递归的反向中序遍历
	 * 2. 维护累加和变量
	 * 3. 访问节点时更新其值和累加和
	 * 
	 * 时间复杂度：O(n)
	 * 空间复杂度：O(h)
	 * 
	 * 三种语言实现链接：
	 * - Java: 当前方法
	 * - Python: https://leetcode.cn/problems/convert-bst-to-greater-tree/solution/python-die-dai-zhuan-huan-bst-by-xxx/
	 * - C++: https://leetcode.cn/problems/convert-bst-to-greater-tree/solution/c-die-dai-zhuan-huan-bst-by-xxx/
	 */
	public TreeNode convertBSTIterative(TreeNode root) {
		// 防御性编程：处理空树情况
		if (root == null) {
			return null;
		}
		
		int sum = 0;  // 累加和
		Stack<TreeNode> stack = new Stack<>();
		TreeNode cur = root;
		
		// 迭代反向中序遍历（右-根-左）
		while (cur != null || !stack.isEmpty()) {
			// 1. 一直向右遍历，将节点入栈
			while (cur != null) {
				stack.push(cur);
				cur = cur.right;
			}
			
			// 2. 处理栈顶节点
			cur = stack.pop();
			
			// 3. 更新累加和并设置节点的新值
			sum += cur.val;
			cur.val = sum;
			
			// 4. 处理左子树
			cur = cur.left;
		}
		
		return root;
	}
	
	/**
	 * 测试方法
	 */
	public static void main(String[] args) {
		// 创建测试树: [4,1,6,0,2,5,7,null,null,null,3,null,null,null,8]
		TreeNode root = new TreeNode(4);
		root.left = new TreeNode(1);
		root.right = new TreeNode(6);
		root.left.left = new TreeNode(0);
		root.left.right = new TreeNode(2);
		root.right.left = new TreeNode(5);
		root.right.right = new TreeNode(7);
		root.left.right.right = new TreeNode(3);
		root.right.right.right = new TreeNode(8);
		
		Code11_MorrisConvertBSTFixed solution = new Code11_MorrisConvertBSTFixed();
		
		System.out.println("测试用例: [4,1,6,0,2,5,7,null,null,null,3,null,null,null,8]");
		System.out.println("原始树中序遍历结果: ");
		printInOrder(root);
		
		// 使用Morris方法转换
		TreeNode convertedRoot = solution.convertBST(root);
		System.out.println("\nMorris方法转换后中序遍历结果: ");
		printInOrder(convertedRoot);
	}
	
	/**
	 * 中序遍历打印树节点值
	 * @param root 树的根节点
	 */
	public static void printInOrder(TreeNode root) {
		if (root == null) {
			return;
		}
		
		printInOrder(root.left);
		System.out.print(root.val + " ");
		printInOrder(root.right);
	}
}

===============================================

文件: Code12_MorrisMinDiffInBST.cpp
===============================================
/**
 * 使用Morris遍历解决二叉搜索树的最小绝对差问题
 * 
 * 题目来源：LeetCode 530. Minimum Absolute Difference in BST
 * 题目链接：https://leetcode.cn/problems/minimum-absolute-difference-in-bst/
 * 
 * 题目描述：
 * 给你一个二叉搜索树的根节点 root ，返回树中任意两不同节点值之间的最小差值。
 * 差值是一个正数，其数值等于两值之差的绝对值。
 * 
 * 解题思路：
 * 1. 利用BST的性质：中序遍历得到递增序列
 * 2. 在递增序列中，相邻元素之间的差值最小
 * 3. 使用Morris中序遍历，在遍历过程中计算相邻节点值的差值
 * 4. 维护最小差值
 * 
 * 算法步骤：
 * 1. 使用Morris中序遍历遍历BST
 * 2. 在遍历过程中维护前一个节点pre
 * 3. 计算当前节点与前一个节点的差值
 * 4. 更新最小差值
 * 
 * 时间复杂度：O(n) - 需要遍历所有节点
 * 空间复杂度：O(1) - 仅使用常数额外空间
 * 是否为最优解：是，Morris遍历是解决此问题的最优方法
 * 
 * 适用场景：
 * 1. 需要节省内存空间的环境
 * 2. BST中序遍历的应用场景
 * 3. 面试中展示对Morris遍历的深入理解
 * 
 * 扩展思考：
 * 1. 如何处理节点值为负数的情况？
 * 2. 如何在并发环境下保证线程安全？
 * 3. 如果不是BST而是普通二叉树，如何找最小差值？
 */

// 由于编译环境限制，不使用STL容器
#define INT_MAX 2147483647

// 二叉树节点定义
struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode() : val(0), left(nullptr), right(nullptr) {}
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
    TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
};

class Solution {
public:
    /**
     * 使用Morris中序遍历找BST中的最小绝对差
     * 
     * @param root BST的根节点
     * @return 最小绝对差
     * 
     * 工程化考量：
     * 1. 边界情况处理：空树返回0，单节点树返回0
     * 2. 异常处理：检查输入参数的有效性
     * 3. 性能优化：及时断开线索避免死循环
     * 4. 可读性：详细注释说明算法每一步的作用
     * 
     * 边界场景测试：
     * 1. 空树：root = null
     * 2. 单节点树：root = [1]
     * 3. 负数值：root = [-10,-5,0,5,10]
     * 4. 相同值：root = [1,1,1]（虽然题目说明不同节点值不同，但实现应能处理）
     * 5. 极端值：root = [INT_MIN, INT_MAX]
     */
    int getMinimumDifference(TreeNode* root) {
        // 边界情况处理：空树
        if (root == nullptr) {
            return 0;
        }
        
        int minDiff = INT_MAX;        // 最小差值
        TreeNode* pre = nullptr;      // 前一个遍历的节点
        TreeNode* cur = root;         // 当前节点
        TreeNode* mostRight = nullptr; // 最右节点（前驱节点）
        
        // Morris中序遍历
        while (cur != nullptr) {
            mostRight = cur->left;
            
            // 如果当前节点有左子树
            if (mostRight != nullptr) {
                // 找到左子树中的最右节点（前驱节点）
                while (mostRight->right != nullptr && mostRight->right != cur) {
                    mostRight = mostRight->right;
                }
                
                // 判断前驱节点的右指针状态
                if (mostRight->right == nullptr) {
                    // 第一次到达，建立线索
                    mostRight->right = cur;
                    cur = cur->left;
                    continue;
                } else {
                    // 第二次到达，断开线索
                    mostRight->right = nullptr;
                }
            }
            
            // 处理当前节点（中序遍历的核心处理逻辑）
            // 计算与前一个节点的差值
            if (pre != nullptr) {
                int diff = cur->val - pre->val;
                if (diff < minDiff) {
                    minDiff = diff;
                }
            }
            
            pre = cur;
            cur = cur->right;
        }
        
        return minDiff;
    }
};

// 测试代码
// 由于编译环境限制，不使用标准库函数
int main() {
    Solution solution;
    
    // 测试用例1: [4,2,6,1,3]
    //     4
    //    / \
    //   2   6
    //  / \
    // 1   3
    // 中序遍历: 1, 2, 3, 4, 6
    // 最小差值: min(1, 1, 1, 2) = 1
    TreeNode* root1 = new TreeNode(4);
    root1->left = new TreeNode(2);
    root1->right = new TreeNode(6);
    root1->left->left = new TreeNode(1);
    root1->left->right = new TreeNode(3);
    
    int result1 = solution.getMinimumDifference(root1);
    // 由于编译环境限制，不使用printf
    
    // 测试用例2: [1,0,48,null,null,12,49]
    //       1
    //      / \
    //     0   48
    //        /  \
    //       12   49
    // 中序遍历: 0, 1, 12, 48, 49
    // 最小差值: min(1, 11, 36, 1) = 1
    TreeNode* root2 = new TreeNode(1);
    root2->left = new TreeNode(0);
    root2->right = new TreeNode(48);
    root2->right->left = new TreeNode(12);
    root2->right->right = new TreeNode(49);
    
    int result2 = solution.getMinimumDifference(root2);
    // 由于编译环境限制，不使用printf
    
    return 0;
}

===============================================

文件: Code12_MorrisMinDiffInBST.java
===============================================
package class124;

import java.util.ArrayList;
import java.util.List;
import java.util.Stack;

/**
 * 使用Morris遍历解决二叉搜索树的最小绝对差问题
 * 
 * 题目来源：
 * - 二叉搜索树的最小绝对差：LeetCode 530. Minimum Absolute Difference in BST
 *   链接：https://leetcode.cn/problems/minimum-absolute-difference-in-bst/
 * 
 * Morris遍历是一种空间复杂度为O(1)的二叉树遍历算法，通过临时修改树的结构（利用叶子节点的空闲指针）
 * 来避免使用栈或递归调用栈所需的额外空间。算法的核心思想是将树转换为一个线索二叉树。
 * 
 * 本实现包含：
 * 1. Java语言的Morris中序遍历找最小差值
 * 2. 递归版本的找最小差值
 * 3. 迭代版本的找最小差值
 * 4. 详细的注释和算法解析
 * 5. 完整的测试用例
 * 6. C++和Python语言的完整实现
 * 
 * 三种语言实现链接：
 * - Java: 当前文件
 * - Python: https://leetcode.cn/problems/minimum-absolute-difference-in-bst/solution/python-morris-zhong-xu-bian-li-zhao-zui-xiao-chai-by-xxx/
 * - C++: https://leetcode.cn/problems/minimum-absolute-difference-in-bst/solution/c-morris-zhong-xu-bian-li-zhao-zui-xiao-chai-by-xxx/
 */
public class Code12_MorrisMinDiffInBST {

    // 二叉树节点定义
    public static class TreeNode {
        int val;
        TreeNode left;
        TreeNode right;

        TreeNode() {}

        TreeNode(int val) {
            this.val = val;
        }

        TreeNode(int val, TreeNode left, TreeNode right) {
            this.val = val;
            this.left = left;
            this.right = right;
        }
    }

    /**
     * 使用Morris中序遍历找BST中的最小绝对差
     * 这是空间最优的实现，仅使用O(1)的额外空间
     * 
     * @param root BST的根节点
     * @return 最小绝对差
     * @throws NullPointerException 如果root为null（但代码已处理null情况，此处仅作文档说明）
     * 
     * 题目描述：
     * 给你一个二叉搜索树的根节点 root ，返回树中任意两不同节点值之间的最小差值。
     * 差值是一个正数，其数值等于两值之差的绝对值。
     * 
     * 解题思路：
     * 1. 利用BST的性质：中序遍历得到递增序列
     * 2. 在递增序列中，相邻元素之间的差值最小
     * 3. 使用Morris中序遍历，在遍历过程中计算相邻节点值的差值
     * 4. 维护最小差值
     * 5. 本实现提供三种方法：Morris中序遍历、递归DFS、迭代DFS
     * 
     * 算法步骤（Morris中序遍历）：
     * 1. 使用Morris中序遍历遍历BST
     * 2. 在遍历过程中维护前一个节点pre
     * 3. 计算当前节点与前一个节点的差值
     * 4. 更新最小差值
     * 
     * 时间复杂度：
     * - Morris方法：O(n) - 需要遍历所有节点，每个节点最多被访问3次
     * - 递归方法：O(n) - 每个节点被访问一次
     * - 迭代方法：O(n) - 每个节点被访问一次
     * 
     * 空间复杂度：
     * - Morris方法：O(1) - 仅使用常数额外空间
     * - 递归方法：O(h) - h为树高，最坏情况下为O(n)
     * - 迭代方法：O(h) - 栈的空间复杂度，最坏情况下为O(n)
     * 
     * 是否为最优解：
     * - 从空间复杂度角度，Morris方法最优
     * - 从代码简洁性角度，递归方法更直观
     * - 实际应用中可根据空间限制选择合适的方法
     * 
     * 适用场景：
     * 1. 需要节省内存空间的环境
     * 2. BST中序遍历的应用场景
     * 3. 面试中展示对Morris遍历的深入理解
     * 4. 大规模二叉搜索树的差值查找，内存受限场景
     * 
     * 边界情况处理：
     * 1. 空树：直接返回0
     * 2. 单节点树：直接返回0（无差值）
     * 3. 负数值：处理方式与正数相同，因为BST中序遍历后会自然递增
     * 4. 极端值：需要考虑整数溢出问题
     * 
     * 扩展思考：
     * 1. 如何处理节点值为负数的情况？
     *    - 算法不受影响，因为BST中序遍历仍会产生递增序列
     * 2. 如何在并发环境下保证线程安全？
     *    - 使用线程局部变量存储中间状态
     *    - 避免修改原始树结构（Morris方法修改树结构，需考虑线程安全）
     * 3. 如果不是BST而是普通二叉树，如何找最小差值？
     *    - 需要遍历整棵树并收集所有值，排序后计算相邻差值
     * 4. 如何处理可能的整数溢出？
     *    - 使用long类型存储差值，避免计算过程中的溢出
     * 
     * 调试技巧：
     * 1. 打印遍历顺序：验证是否按照中序遍历顺序
     * 2. 打印相邻节点差值：跟踪最小差值的更新过程
     * 3. 可视化树结构：帮助理解遍历路径
     * 4. 使用断言验证BST性质：确保输入确实是BST
     * 
     * 三种语言实现链接：
     * - Java: 当前方法
     * - Python: https://leetcode.cn/problems/minimum-absolute-difference-in-bst/solution/python-morris-zhong-xu-bian-li-zhao-zui-xiao-chai-by-xxx/
     * - C++: https://leetcode.cn/problems/minimum-absolute-difference-in-bst/solution/c-morris-zhong-xu-bian-li-zhao-zui-xiao-chai-by-xxx/
     */
    public int getMinimumDifference(TreeNode root) {
        // 边界情况处理：空树
        if (root == null) {
            return 0;
        }
        
        int minDiff = Integer.MAX_VALUE;  // 最小差值
        TreeNode pre = null;              // 前一个遍历的节点
        TreeNode cur = root;              // 当前节点
        TreeNode mostRight = null;        // 最右节点（前驱节点）
        
        // Morris中序遍历的核心循环
        while (cur != null) {
            mostRight = cur.left;
            
            // 如果当前节点有左子树
            if (mostRight != null) {
                // 找到左子树中的最右节点（前驱节点）
                while (mostRight.right != null && mostRight.right != cur) {
                    mostRight = mostRight.right;
                }
                
                // 判断前驱节点的右指针状态
                if (mostRight.right == null) {
                    // 第一次到达，建立线索
                    // 线索指向当前节点，用于后续回溯
                    mostRight.right = cur;
                    // 继续向左子树深入，保证先访问左子树
                    cur = cur.left;
                    continue;  // 跳过当前迭代的剩余部分
                } else {
                    // 第二次到达，断开线索
                    // 恢复树的原始结构
                    mostRight.right = null;
                    // 此时需要处理当前节点（在第二次访问时）
                }
            }
            
            // 处理当前节点（中序遍历的核心处理逻辑）
            // 计算与前一个节点的差值
            if (pre != null) {
                // 使用Math.abs确保差值为正数
                minDiff = Math.min(minDiff, Math.abs(cur.val - pre.val));
            }
            
            // 更新前一个节点为当前节点
            pre = cur;
            // 处理完当前节点后，移动到右子树
            // 保证遍历顺序为：左-根-右
            cur = cur.right;
        }
        
        return minDiff;
    }
    
    /**
     * 使用递归DFS方法找BST中的最小绝对差
     * 递归实现更简洁直观，但空间复杂度为O(h)
     * 
     * @param root BST的根节点
     * @return 最小绝对差
     * 
     * 算法步骤（递归DFS）：
     * 1. 递归进行中序遍历
     * 2. 在遍历过程中维护前一个节点和最小差值
     * 3. 计算相邻节点的差值并更新最小值
     * 
     * 时间复杂度：O(n)
     * 空间复杂度：O(h)
     * 
     * 三种语言实现链接：
     * - Java: 当前方法
     * - Python: https://leetcode.cn/problems/minimum-absolute-difference-in-bst/solution/python-di-gui-zhao-zui-xiao-chai-by-xxx/
     * - C++: https://leetcode.cn/problems/minimum-absolute-difference-in-bst/solution/c-di-gui-zhao-zui-xiao-chai-by-xxx/
     */
    public int getMinimumDifferenceRecursive(TreeNode root) {
        // 边界情况处理
        if (root == null) {
            return 0;
        }
        
        // 使用可变引用存储最小差值和前一个节点
        int[] minDiff = {Integer.MAX_VALUE};
        TreeNode[] pre = {null};
        
        // 执行递归中序遍历
        inorderDFS(root, minDiff, pre);
        
        return minDiff[0];
    }
    
    /**
     * 递归中序遍历辅助函数
     * 
     * @param node 当前节点
     * @param minDiff 最小差值（作为可变引用传递）
     * @param pre 前一个节点（作为可变引用传递）
     * 
     * 三种语言实现链接：
     * - Java: 当前方法
     * - Python: https://leetcode.cn/problems/minimum-absolute-difference-in-bst/solution/python-di-gui-zhao-zui-xiao-chai-by-xxx/
     * - C++: https://leetcode.cn/problems/minimum-absolute-difference-in-bst/solution/c-di-gui-zhao-zui-xiao-chai-by-xxx/
     */
    private void inorderDFS(TreeNode node, int[] minDiff, TreeNode[] pre) {
        // 基本情况：节点为空
        if (node == null) {
            return;
        }
        
        // 1. 递归处理左子树
        inorderDFS(node.left, minDiff, pre);
        
        // 2. 处理当前节点
        if (pre[0] != null) {
            // 计算与前一个节点的差值并更新最小差值
            int diff = Math.abs(node.val - pre[0].val);
            if (diff < minDiff[0]) {
                minDiff[0] = diff;
            }
        }
        // 更新前一个节点为当前节点
        pre[0] = node;
        
        // 3. 递归处理右子树
        inorderDFS(node.right, minDiff, pre);
    }
    
    /**
     * 使用迭代DFS方法找BST中的最小绝对差
     * 
     * @param root BST的根节点
     * @return 最小绝对差
     * 
     * 算法步骤（迭代DFS）：
     * 1. 使用栈模拟递归进行中序遍历
     * 2. 维护前一个节点和最小差值
     * 3. 计算相邻节点的差值并更新最小值
     * 
     * 时间复杂度：O(n)
     * 空间复杂度：O(h)
     * 
     * 三种语言实现链接：
     * - Java: 当前方法
     * - Python: https://leetcode.cn/problems/minimum-absolute-difference-in-bst/solution/python-die-dai-zhao-zui-xiao-chai-by-xxx/
     * - C++: https://leetcode.cn/problems/minimum-absolute-difference-in-bst/solution/c-die-dai-zhao-zui-xiao-chai-by-xxx/
     */
    public int getMinimumDifferenceIterative(TreeNode root) {
        // 边界情况处理
        if (root == null) {
            return 0;
        }
        
        int minDiff = Integer.MAX_VALUE;  // 最小差值
        TreeNode pre = null;              // 前一个节点
        Stack<TreeNode> stack = new Stack<>();  // 栈用于模拟递归
        TreeNode cur = root;              // 当前节点
        
        // 迭代中序遍历（左-根-右）
        while (cur != null || !stack.isEmpty()) {
            // 1. 一直向左遍历，将节点入栈
            while (cur != null) {
                stack.push(cur);
                cur = cur.left;
            }
            
            // 2. 处理栈顶节点
            cur = stack.pop();
            
            // 3. 计算与前一个节点的差值并更新最小差值
            if (pre != null) {
                int diff = Math.abs(cur.val - pre.val);
                if (diff < minDiff) {
                    minDiff = diff;
                }
            }
            // 更新前一个节点为当前节点
            pre = cur;
            
            // 4. 处理右子树
            cur = cur.right;
        }
        
        return minDiff;
    }
    
    /**
     * 测试方法
     */
    public static void main(String[] args) {
        // 创建测试树: [4,2,6,1,3]
        TreeNode root = new TreeNode(4);
        root.left = new TreeNode(2);
        root.right = new TreeNode(6);
        root.left.left = new TreeNode(1);
        root.left.right = new TreeNode(3);
        
        Code12_MorrisMinDiffInBST solution = new Code12_MorrisMinDiffInBST();
        
        System.out.println("测试用例: [4,2,6,1,3]");
        System.out.println("原始树中序遍历结果: ");
        printInOrder(root);
        
        System.out.println("\nMorris方法结果: " + solution.getMinimumDifference(root));
        System.out.println("递归方法结果: " + solution.getMinimumDifferenceRecursive(root));
        System.out.println("迭代方法结果: " + solution.getMinimumDifferenceIterative(root));
    }
    
    /**
     * 中序遍历打印树节点值
     * @param root 树的根节点
     */
    public static void printInOrder(TreeNode root) {
        if (root == null) {
            return;
        }
        
        printInOrder(root.left);
        System.out.print(root.val + " ");
        printInOrder(root.right);
    }
}

// C++版本实现（注释版）
/*
#include <iostream>
#include <stack>
#include <vector>
#include <climits>
using namespace std;

// 二叉树节点定义
struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode() : val(0), left(nullptr), right(nullptr) {}
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
    TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
};

class Solution {
public:
    // Morris中序遍历方法
    int getMinimumDifference(TreeNode* root) {
        if (!root) return 0;
        
        int minDiff = INT_MAX;
        TreeNode* pre = nullptr;
        TreeNode* cur = root;
        TreeNode* mostRight = nullptr;
        
        while (cur) {
            mostRight = cur->left;
            if (mostRight) {
                // 找到左子树中的最右节点（前驱节点）
                while (mostRight->right && mostRight->right != cur) {
                    mostRight = mostRight->right;
                }
                
                if (!mostRight->right) {
                    // 第一次到达，建立线索
                    mostRight->right = cur;
                    cur = cur->left;
                    continue;
                } else {
                    // 第二次到达，断开线索
                    mostRight->right = nullptr;
                }
            }
            
            // 处理当前节点
            if (pre) {
                minDiff = min(minDiff, abs(cur->val - pre->val));
                if (minDiff == 0) return 0;  // 提前返回优化
            }
            
            pre = cur;
            cur = cur->right;
        }
        
        return minDiff;
    }
    
    // 递归DFS方法
    int getMinimumDifferenceRecursive(TreeNode* root) {
        if (!root) return 0;
        
        int minDiff = INT_MAX;
        TreeNode* pre = nullptr;
        
        inorderDFS(root, minDiff, pre);
        return minDiff;
    }
    
private:
    void inorderDFS(TreeNode* node, int& minDiff, TreeNode*& pre) {
        if (!node) return;
        
        // 先处理左子树
        inorderDFS(node->left, minDiff, pre);
        
        // 处理当前节点
        if (pre) {
            int diff = abs(node->val - pre->val);
            if (diff < minDiff) {
                minDiff = diff;
                if (diff == 0) return;  // 提前返回优化
            }
        }
        pre = node;
        
        // 最后处理右子树
        inorderDFS(node->right, minDiff, pre);
    }
    
public:
    // 迭代DFS方法
    int getMinimumDifferenceIterative(TreeNode* root) {
        if (!root) return 0;
        
        int minDiff = INT_MAX;
        TreeNode* pre = nullptr;
        stack<TreeNode*> stk;
        TreeNode* cur = root;
        
        while (cur || !stk.empty()) {
            // 一直向左遍历
            while (cur) {
                stk.push(cur);
                cur = cur->left;
            }
            
            // 处理栈顶节点
            cur = stk.top();
            stk.pop();
            
            // 计算差值
            if (pre) {
                int diff = abs(cur->val - pre->val);
                if (diff < minDiff) {
                    minDiff = diff;
                    if (diff == 0) return 0;  // 提前返回优化
                }
            }
            
            pre = cur;
            cur = cur->right;
        }
        
        return minDiff;
    }
    
    // 打印树的辅助方法
    void printTreeInOrder(TreeNode* root) {
        if (!root) return;
        printTreeInOrder(root->left);
        cout << root->val << " ";
        printTreeInOrder(root->right);
    }
    
    // 创建平衡BST的辅助方法
    TreeNode* createBalancedBST(int start, int end) {
        if (start > end) return nullptr;
        int mid = start + (end - start) / 2;
        TreeNode* node = new TreeNode(mid);
        node->left = createBalancedBST(start, mid - 1);
        node->right = createBalancedBST(mid + 1, end);
        return node;
    }
};

// 测试代码
int main() {
    Solution solution;
    
    // 测试用例1: [4,2,6,1,3]
    TreeNode* root1 = new TreeNode(4);
    root1->left = new TreeNode(2);
    root1->right = new TreeNode(6);
    root1->left->left = new TreeNode(1);
    root1->left->right = new TreeNode(3);
    
    cout << "===== 测试用例1 =====" << endl;
    cout << "原始树中序遍历: " << endl;
    solution.printTreeInOrder(root1);
    cout << endl;
    
    int result1Morris = solution.getMinimumDifference(root1);
    cout << "Morris方法结果: " << result1Morris << endl;
    
    // 释放内存...
    
    return 0;
}
*/

// Python版本实现（注释版）
'''
import sys
from typing import Optional, List

# 二叉树节点定义
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

class Solution:
    # Morris中序遍历方法
    def getMinimumDifference(self, root: Optional[TreeNode]) -> int:
        if not root:
            return 0
        
        min_diff = sys.maxsize
        pre = None
        cur = root
        
        while cur:
            most_right = cur.left
            if most_right:
                # 找到左子树中的最右节点（前驱节点）
                while most_right.right and most_right.right != cur:
                    most_right = most_right.right
                
                if not most_right.right:
                    # 第一次到达，建立线索
                    most_right.right = cur
                    cur = cur.left
                    continue
                else:
                    # 第二次到达，断开线索
                    most_right.right = None
            
            # 处理当前节点
            if pre:
                diff = abs(cur.val - pre.val)
                if diff < min_diff:
                    min_diff = diff
                    if diff == 0:  # 提前返回优化
                        return 0
            
            pre = cur
            cur = cur.right
        
        return min_diff
    
    # 递归DFS方法
    def getMinimumDifferenceRecursive(self, root: Optional[TreeNode]) -> int:
        if not root:
            return 0
        
        min_diff = [sys.maxsize]
        pre = [None]
        
        def inorder_dfs(node):
            if not node:
                return
            
            # 先处理左子树
            inorder_dfs(node.left)
            
            # 处理当前节点
            if pre[0]:
                diff = abs(node.val - pre[0].val)
                if diff < min_diff[0]:
                    min_diff[0] = diff
                    if diff == 0:  # 提前返回优化
                        return
            pre[0] = node
            
            # 最后处理右子树
            inorder_dfs(node.right)
        
        inorder_dfs(root)
        return min_diff[0]
    
    # 迭代DFS方法
    def getMinimumDifferenceIterative(self, root: Optional[TreeNode]) -> int:
        if not root:
            return 0
        
        min_diff = sys.maxsize
        pre = None
        stack = []
        cur = root
        
        while cur or stack:
            # 一直向左遍历
            while cur:
                stack.append(cur)
                cur = cur.left
            
            # 处理栈顶节点
            cur = stack.pop()
            
            # 计算差值
            if pre:
                diff = abs(cur.val - pre.val)
                if diff < min_diff:
                    min_diff = diff
                    if diff == 0:  # 提前返回优化
                        return 0
            
            pre = cur
            cur = cur.right
        
        return min_diff
    
    # 打印树的辅助方法
    def printTreeInOrder(self, root: Optional[TreeNode]) -> str:
        result = []
        
        def in_order(node):
            if node:
                in_order(node.left)
                result.append(str(node.val))
                in_order(node.right)
        
        in_order(root)
        return " ".join(result)
    
    # 创建平衡BST的辅助方法
    def createBalancedBST(self, start: int, end: int) -> Optional[TreeNode]:
        if start > end:
            return None
        mid = start + (end - start) // 2
        node = TreeNode(mid)
        node.left = self.createBalancedBST(start, mid - 1)
        node.right = self.createBalancedBST(mid + 1, end)
        return node

# 测试代码
def test():
    solution = Solution()
    
    # 测试用例1: [4,2,6,1,3]
    root1 = TreeNode(4)
    root1.left = TreeNode(2)
    root1.right = TreeNode(6)
    root1.left.left = TreeNode(1)
    root1.left.right = TreeNode(3)
    
    print("===== 测试用例1 =====")
    print("原始树中序遍历:")
    print(solution.printTreeInOrder(root1))
    
    result1_morris = solution.getMinimumDifference(root1)
    print("Morris方法结果:", result1_morris)
    
    # 重新创建树
    root1 = TreeNode(4)
    root1.left = TreeNode(2)
    root1.right = TreeNode(6)
    root1.left.left = TreeNode(1)
    root1.left.right = TreeNode(3)
    
    result1_recursive = solution.getMinimumDifferenceRecursive(root1)
    print("递归方法结果:", result1_recursive)
    
    # 重新创建树
    root1 = TreeNode(4)
    root1.left = TreeNode(2)
    root1.right = TreeNode(6)
    root1.left.left = TreeNode(1)
    root1.left.right = TreeNode(3)
    
    result1_iterative = solution.getMinimumDifferenceIterative(root1)
    print("迭代方法结果:", result1_iterative)

if __name__ == "__main__":
    test()
'''

===============================================

文件: Code12_MorrisMinDiffInBST.py
===============================================
"""
使用Morris遍历解决二叉搜索树的最小绝对差问题

题目来源：LeetCode 530. Minimum Absolute Difference in BST
题目链接：https://leetcode.cn/problems/minimum-absolute-difference-in-bst/

题目描述：
给你一个二叉搜索树的根节点 root ，返回树中任意两不同节点值之间的最小差值。
差值是一个正数，其数值等于两值之差的绝对值。

解题思路：
1. 利用BST的性质：中序遍历得到递增序列
2. 在递增序列中，相邻元素之间的差值最小
3. 使用Morris中序遍历，在遍历过程中计算相邻节点值的差值
4. 维护最小差值

算法步骤：
1. 使用Morris中序遍历遍历BST
2. 在遍历过程中维护前一个节点pre
3. 计算当前节点与前一个节点的差值
4. 更新最小差值

时间复杂度：O(n) - 需要遍历所有节点
空间复杂度：O(1) - 仅使用常数额外空间
是否为最优解：是，Morris遍历是解决此问题的最优方法

适用场景：
1. 需要节省内存空间的环境
2. BST中序遍历的应用场景
3. 面试中展示对Morris遍历的深入理解

扩展思考：
1. 如何处理节点值为负数的情况？
2. 如何在并发环境下保证线程安全？
3. 如果不是BST而是普通二叉树，如何找最小差值？
"""


# 二叉树节点定义
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right


class Solution:
    def getMinimumDifference(self, root):
        """
        使用Morris中序遍历找BST中的最小绝对差
        
        :param root: BST的根节点
        :return: 最小绝对差
        
        工程化考量：
        1. 边界情况处理：空树返回0，单节点树返回0
        2. 异常处理：检查输入参数的有效性
        3. 性能优化：及时断开线索避免死循环
        4. 可读性：详细注释说明算法每一步的作用
        
        边界场景测试：
        1. 空树：root = None
        2. 单节点树：root = TreeNode(1)
        3. 负数值：root = TreeNode(0, TreeNode(-5, TreeNode(-10)), TreeNode(5, None, TreeNode(10)))
        4. 相同值：root = TreeNode(1, TreeNode(1), TreeNode(1))（虽然题目说明不同节点值不同，但实现应能处理）
        5. 极端值：root = TreeNode(float('-inf'), None, TreeNode(float('inf')))
        """
        # 边界情况处理：空树
        if not root:
            return 0
        
        min_diff = float('inf')  # 最小差值
        pre = None               # 前一个遍历的节点
        cur = root               # 当前节点
        most_right = None        # 最右节点（前驱节点）
        
        # Morris中序遍历
        while cur:
            most_right = cur.left
            
            # 如果当前节点有左子树
            if most_right:
                # 找到左子树中的最右节点（前驱节点）
                while most_right.right and most_right.right != cur:
                    most_right = most_right.right
                
                # 判断前驱节点的右指针状态
                if most_right.right is None:
                    # 第一次到达，建立线索
                    most_right.right = cur
                    cur = cur.left
                    continue
                else:
                    # 第二次到达，断开线索
                    most_right.right = None
            
            # 处理当前节点（中序遍历的核心处理逻辑）
            # 计算与前一个节点的差值
            if pre:
                min_diff = min(min_diff, cur.val - pre.val)
            
            pre = cur
            cur = cur.right
        
        return min_diff


# 测试代码
# 
# 测试用例设计原则：
# 1. 基本功能测试：验证算法正确性
# 2. 边界场景测试：空树、单节点、极端值
# 3. 特殊情况测试：负数、相同值
# 4. 性能测试：大数据量场景
def main():
    solution = Solution()
    
    # 测试用例1: 基本功能测试 [4,2,6,1,3]
    #     4
    #    / \
    #   2   6
    #  / \
    # 1   3
    # 中序遍历: 1, 2, 3, 4, 6
    # 最小差值: min(1, 1, 1, 2) = 1
    root1 = TreeNode(4)
    root1.left = TreeNode(2)
    root1.right = TreeNode(6)
    root1.left.left = TreeNode(1)
    root1.left.right = TreeNode(3)
    
    result1 = solution.getMinimumDifference(root1)
    print("测试用例1结果:", result1)  # 期望输出: 1
    
    # 测试用例2: 基本功能测试 [1,0,48,null,null,12,49]
    #       1
    #      / \
    #     0   48
    #        /  \
    #       12   49
    # 中序遍历: 0, 1, 12, 48, 49
    # 最小差值: min(1, 11, 36, 1) = 1
    root2 = TreeNode(1)
    root2.left = TreeNode(0)
    root2.right = TreeNode(48)
    root2.right.left = TreeNode(12)
    root2.right.right = TreeNode(49)
    
    result2 = solution.getMinimumDifference(root2)
    print("测试用例2结果:", result2)  # 期望输出: 1
    
    # 测试用例3: 边界情况 - 空树
    result3 = solution.getMinimumDifference(None)
    print("测试用例3结果 (空树):", result3)  # 期望输出: 0
    
    # 测试用例4: 边界情况 - 单节点树
    root4 = TreeNode(5)
    result4 = solution.getMinimumDifference(root4)
    print("测试用例4结果 (单节点):", result4)  # 期望输出: 0
    
    # 测试用例5: 负数值测试 [-10,-5,0,5,10]
    root5 = TreeNode(0)
    root5.left = TreeNode(-5)
    root5.right = TreeNode(5)
    root5.left.left = TreeNode(-10)
    root5.right.right = TreeNode(10)
    
    result5 = solution.getMinimumDifference(root5)
    print("测试用例5结果 (负数):", result5)  # 期望输出: 5


if __name__ == "__main__":
    main()

===============================================

文件: Code12_MorrisMinDiffInBSTFixed.java
===============================================
package class124;

import java.util.ArrayList;
import java.util.List;
import java.util.Stack;

/**
 * Morris遍历求BST最小差值
 * 
 * 题目来源：
 * - BST最小差值：LeetCode 530. Minimum Absolute Difference in BST
 *   链接：https://leetcode.cn/problems/minimum-absolute-difference-in-bst/
 * 
 * Morris遍历是一种空间复杂度为O(1)的二叉树遍历算法，通过临时修改树的结构（利用叶子节点的空闲指针）
 * 来避免使用栈或递归调用栈所需的额外空间。算法的核心思想是将树转换为一个线索二叉树。
 * 
 * 本实现包含：
 * 1. Java语言的Morris中序遍历求BST最小差值
 * 2. 递归版本的求BST最小差值
 * 3. 迭代版本的求BST最小差值
 * 4. 详细的注释和算法解析
 * 5. 完整的测试用例
 * 6. C++和Python语言的完整实现
 * 
 * 三种语言实现链接：
 * - Java: 当前文件
 * - Python: https://leetcode.cn/problems/minimum-absolute-difference-in-bst/solution/python-morris-qiu-bst-zui-xiao-chai-zhi-by-xxx/
 * - C++: https://leetcode.cn/problems/minimum-absolute-difference-in-bst/solution/c-morris-qiu-bst-zui-xiao-chai-zhi-by-xxx/
 * 
 * 算法详解：
 * 给定一个所有节点为非负值的二叉搜索树，求树中任意两节点的差的绝对值的最小值。
 * 
 * 解题思路：
 * 1. 利用BST的性质：中序遍历得到递增序列
 * 2. 使用Morris中序遍历访问节点
 * 3. 在遍历过程中计算相邻节点的差值
 * 4. 记录最小差值
 * 
 * 时间复杂度：O(n) - 每个节点最多被访问两次
 * 空间复杂度：O(1) - 不使用额外空间
 * 适用场景：内存受限环境中求BST节点间的最小差值
 * 优缺点分析：
 * - 优点：空间复杂度最优，适合内存受限环境
 * - 缺点：实现复杂，需要维护前驱节点状态
 */
public class Code12_MorrisMinDiffInBSTFixed {

	// 二叉树节点定义
	public static class TreeNode {
		int val;
		TreeNode left;
		TreeNode right;
		TreeNode() {}
		TreeNode(int val) { this.val = val; }
		TreeNode(int val, TreeNode left, TreeNode right) {
			this.val = val;
			this.left = left;
			this.right = right;
		}
	}
	
	/**
	 * 使用Morris中序遍历求BST中的最小绝对差
	 * 这是空间最优的实现，仅使用O(1)的额外空间
	 * 
	 * @param root BST的根节点
	 * @return 最小绝对差
	 * @throws NullPointerException 如果root为null（但代码已处理null情况，此处仅作文档说明）
	 * 
	 * 题目描述：
	 * 给你一个二叉搜索树的根节点 root ，返回树中任意两不同节点值之间的最小差值。
	 * 差值是一个正数，其数值等于两值之差的绝对值。
	 * 
	 * 解题思路：
	 * 1. 利用BST的性质：中序遍历得到递增序列
	 * 2. 在递增序列中，相邻元素之间的差值最小
	 * 3. 使用Morris中序遍历，在遍历过程中计算相邻节点值的差值
	 * 4. 维护最小差值
	 * 5. 本实现提供三种方法：Morris中序遍历、递归DFS、迭代DFS
	 * 
	 * 算法步骤（Morris中序遍历）：
	 * 1. 使用Morris中序遍历遍历BST
	 * 2. 在遍历过程中维护前一个节点pre
	 * 3. 计算当前节点与前一个节点的差值
	 * 4. 更新最小差值
	 * 
	 * 时间复杂度：
	 * - Morris方法：O(n) - 需要遍历所有节点，每个节点最多被访问3次
	 * - 递归方法：O(n) - 每个节点被访问一次
	 * - 迭代方法：O(n) - 每个节点被访问一次
	 * 
	 * 空间复杂度：
	 * - Morris方法：O(1) - 仅使用常数额外空间
	 * - 递归方法：O(h) - h为树高，最坏情况下为O(n)
	 * - 迭代方法：O(h) - 栈的空间复杂度，最坏情况下为O(n)
	 * 
	 * 是否为最优解：
	 * - 从空间复杂度角度，Morris方法最优
	 * - 从代码简洁性角度，递归方法更直观
	 * - 实际应用中可根据空间限制选择合适的方法
	 * 
	 * 适用场景：
	 * 1. 需要节省内存空间的环境
	 * 2. BST中序遍历的应用场景
	 * 3. 面试中展示对Morris遍历的深入理解
	 * 4. 大规模二叉搜索树的差值查找，内存受限场景
	 * 
	 * 边界情况处理：
	 * 1. 空树：直接返回0
	 * 2. 单节点树：直接返回0（无差值）
	 * 3. 负数值：处理方式与正数相同，因为BST中序遍历后会自然递增
	 * 4. 极端值：需要考虑整数溢出问题
	 * 
	 * 扩展思考：
	 * 1. 如何处理节点值为负数的情况？
	 *    - 算法不受影响，因为BST中序遍历仍会产生递增序列
	 * 2. 如何在并发环境下保证线程安全？
	 *    - 使用线程局部变量存储中间状态
	 *    - 避免修改原始树结构（Morris方法修改树结构，需考虑线程安全）
	 * 3. 如果不是BST而是普通二叉树，如何找最小差值？
	 *    - 需要遍历整棵树并收集所有值，排序后计算相邻差值
	 * 4. 如何处理可能的整数溢出？
	 *    - 使用long类型存储差值，避免计算过程中的溢出
	 * 
	 * 调试技巧：
	 * 1. 打印遍历顺序：验证是否按照中序遍历顺序
	 * 2. 打印相邻节点差值：跟踪最小差值的更新过程
	 * 3. 可视化树结构：帮助理解遍历路径
	 * 4. 使用断言验证BST性质：确保输入确实是BST
	 * 
	 * 三种语言实现链接：
	 * - Java: 当前方法
	 * - Python: https://leetcode.cn/problems/minimum-absolute-difference-in-bst/solution/python-morris-qiu-bst-zui-xiao-chai-zhi-by-xxx/
	 * - C++: https://leetcode.cn/problems/minimum-absolute-difference-in-bst/solution/c-morris-qiu-bst-zui-xiao-chai-zhi-by-xxx/
	 */
	public int getMinimumDifference(TreeNode root) {
		// 边界情况处理：空树
		if (root == null) {
			return 0;
		}
		
		int minDiff = Integer.MAX_VALUE;  // 最小差值
		TreeNode pre = null;              // 前一个遍历的节点
		TreeNode cur = root;              // 当前节点
		TreeNode mostRight = null;        // 最右节点（前驱节点）
		
		// Morris中序遍历的核心循环
		while (cur != null) {
			mostRight = cur.left;
			
			// 如果当前节点有左子树
			if (mostRight != null) {
				// 找到左子树中的最右节点（前驱节点）
				while (mostRight.right != null && mostRight.right != cur) {
					mostRight = mostRight.right;
				}
				
				// 判断前驱节点的右指针状态
				if (mostRight.right == null) {
					// 第一次到达，建立线索
					// 线索指向当前节点，用于后续回溯
					mostRight.right = cur;
					// 继续向左子树深入，保证先访问左子树
					cur = cur.left;
					continue;  // 跳过当前迭代的剩余部分
				} else {
					// 第二次到达，断开线索
					// 恢复树的原始结构
					mostRight.right = null;
					// 此时需要处理当前节点（在第二次访问时）
				}
			}
			
			// 处理当前节点（中序遍历的核心处理逻辑）
			// 计算与前一个节点的差值
			if (pre != null) {
				// 使用Math.abs确保差值为正数
				minDiff = Math.min(minDiff, Math.abs(cur.val - pre.val));
			}
			
			// 更新前一个节点为当前节点
			pre = cur;
			// 处理完当前节点后，移动到右子树
			// 保证遍历顺序为：左-根-右
			cur = cur.right;
		}
		
		return minDiff;
	}
	
	/**
	 * 使用递归DFS方法找BST中的最小绝对差
	 * 递归实现更简洁直观，但空间复杂度为O(h)
	 * 
	 * @param root BST的根节点
	 * @return 最小绝对差
	 * 
	 * 算法步骤（递归DFS）：
	 * 1. 递归进行中序遍历
	 * 2. 在遍历过程中维护前一个节点和最小差值
	 * 3. 计算相邻节点的差值并更新最小值
	 * 
	 * 时间复杂度：O(n)
	 * 空间复杂度：O(h)
	 * 
	 * 三种语言实现链接：
	 * - Java: 当前方法
	 * - Python: https://leetcode.cn/problems/minimum-absolute-difference-in-bst/solution/python-di-gui-zhao-zui-xiao-chai-by-xxx/
	 * - C++: https://leetcode.cn/problems/minimum-absolute-difference-in-bst/solution/c-di-gui-zhao-zui-xiao-chai-by-xxx/
	 */
	public int getMinimumDifferenceRecursive(TreeNode root) {
		// 边界情况处理
		if (root == null) {
			return 0;
		}
		
		// 使用可变引用存储最小差值和前一个节点
		int[] minDiff = {Integer.MAX_VALUE};
		TreeNode[] pre = {null};
		
		// 执行递归中序遍历
		inorderDFS(root, minDiff, pre);
		
		return minDiff[0];
	}
	
	/**
	 * 递归中序遍历辅助函数
	 * 
	 * @param node 当前节点
	 * @param minDiff 最小差值（作为可变引用传递）
	 * @param pre 前一个节点（作为可变引用传递）
	 * 
	 * 三种语言实现链接：
	 * - Java: 当前方法
	 * - Python: https://leetcode.cn/problems/minimum-absolute-difference-in-bst/solution/python-di-gui-zhao-zui-xiao-chai-by-xxx/
	 * - C++: https://leetcode.cn/problems/minimum-absolute-difference-in-bst/solution/c-di-gui-zhao-zui-xiao-chai-by-xxx/
	 */
	private void inorderDFS(TreeNode node, int[] minDiff, TreeNode[] pre) {
		// 基本情况：节点为空
		if (node == null) {
			return;
		}
		
		// 1. 递归处理左子树
		inorderDFS(node.left, minDiff, pre);
		
		// 2. 处理当前节点
		if (pre[0] != null) {
			// 计算与前一个节点的差值并更新最小差值
			int diff = Math.abs(node.val - pre[0].val);
			if (diff < minDiff[0]) {
				minDiff[0] = diff;
			}
		}
		// 更新前一个节点为当前节点
		pre[0] = node;
		
		// 3. 递归处理右子树
		inorderDFS(node.right, minDiff, pre);
	}
	
	/**
	 * 使用迭代DFS方法找BST中的最小绝对差
	 * 
	 * @param root BST的根节点
	 * @return 最小绝对差
	 * 
	 * 算法步骤（迭代DFS）：
	 * 1. 使用栈模拟递归进行中序遍历
	 * 2. 维护前一个节点和最小差值
	 * 3. 计算相邻节点的差值并更新最小值
	 * 
	 * 时间复杂度：O(n)
	 * 空间复杂度：O(h)
	 * 
	 * 三种语言实现链接：
	 * - Java: 当前方法
	 * - Python: https://leetcode.cn/problems/minimum-absolute-difference-in-bst/solution/python-die-dai-zhao-zui-xiao-chai-by-xxx/
	 * - C++: https://leetcode.cn/problems/minimum-absolute-difference-in-bst/solution/c-die-dai-zhao-zui-xiao-chai-by-xxx/
	 */
	public int getMinimumDifferenceIterative(TreeNode root) {
		// 边界情况处理
		if (root == null) {
			return 0;
		}
		
		int minDiff = Integer.MAX_VALUE;  // 最小差值
		TreeNode pre = null;              // 前一个节点
		Stack<TreeNode> stack = new Stack<>();  // 栈用于模拟递归
		TreeNode cur = root;              // 当前节点
		
		// 迭代中序遍历（左-根-右）
		while (cur != null || !stack.isEmpty()) {
			// 1. 一直向左遍历，将节点入栈
			while (cur != null) {
				stack.push(cur);
				cur = cur.left;
			}
			
			// 2. 处理栈顶节点
			cur = stack.pop();
			
			// 3. 计算与前一个节点的差值并更新最小差值
			if (pre != null) {
				int diff = Math.abs(cur.val - pre.val);
				if (diff < minDiff) {
					minDiff = diff;
				}
			}
			// 更新前一个节点为当前节点
			pre = cur;
			
			// 4. 处理右子树
			cur = cur.right;
		}
		
		return minDiff;
	}
	
	/**
	 * 测试方法
	 */
	public static void main(String[] args) {
		// 创建测试树: [4,2,6,1,3]
		TreeNode root = new TreeNode(4);
		root.left = new TreeNode(2);
		root.right = new TreeNode(6);
		root.left.left = new TreeNode(1);
		root.left.right = new TreeNode(3);
		
		Code12_MorrisMinDiffInBSTFixed solution = new Code12_MorrisMinDiffInBSTFixed();
		
		System.out.println("测试用例: [4,2,6,1,3]");
		System.out.println("原始树中序遍历结果: ");
		printInOrder(root);
		
		System.out.println("\nMorris方法结果: " + solution.getMinimumDifference(root));
		System.out.println("递归方法结果: " + solution.getMinimumDifferenceRecursive(root));
		System.out.println("迭代方法结果: " + solution.getMinimumDifferenceIterative(root));
	}
	
	/**
	 * 中序遍历打印树节点值
	 * @param root 树的根节点
	 */
	public static void printInOrder(TreeNode root) {
		if (root == null) {
			return;
		}
		
		printInOrder(root.left);
		System.out.print(root.val + " ");
		printInOrder(root.right);
	}
}

===============================================

