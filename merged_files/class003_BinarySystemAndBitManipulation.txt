===============================================
文件夹: class003_BinarySystemAndBitManipulation
===============================================

[Markdown 文件]
===============================================
文件: README.md
===============================================
# Class003: 二进制系统与位运算专题

## 📚 专题概述

本专题系统性地覆盖了二进制系统和位运算相关的所有核心知识点，包含来自全球各大算法平台的**200+道精选题目**，涵盖从基础到高级的所有难度等级。

### 🎯 学习目标

1. **掌握位运算基础**：理解AND、OR、XOR、NOT、左移、右移等操作的本质
2. **熟练运用位运算技巧**：如Brian Kernighan算法、位掩码、状态压缩等
3. **理解位运算的数学性质**：格雷编码、斯特林数、幂判断等
4. **解决实际工程问题**：位图、布隆过滤器、加密算法等应用

## 🌟 核心知识点

### 1. 位运算基础操作

- **AND (&)**：两位都为1时结果为1，常用于清零特定位、提取特定位
  - 示例：`n & (1 << i)` 检查第i位是否为1
  - 示例：`n & (~(1 << i))` 将第i位清零

- **OR (|)**：有一位为1时结果为1，常用于设置特定位
  - 示例：`n | (1 << i)` 将第i位设置为1

- **XOR (^)**：两位不同时结果为1，常用于交换、查找唯一元素
  - 性质：`a ^ a = 0`, `a ^ 0 = a`, `a ^ b ^ b = a`
  - 应用：无临时变量交换、找单独元素、掩码操作

- **NOT (~)**：按位取反
  - 注意：`~n = -(n+1)`（补码表示）

- **左移 (<<)**：相当于乘以2的幂（非负数）
  - `n << k` 等价于 `n * 2^k`

- **右移 (>>)**：
  - 算术右移：保留符号位（Java、C++）
  - 逻辑右移 (>>>)：不保留符号位（仅Java）

### 2. 常用技巧与模式

#### ⭐ 判断奇偶
```java
boolean isOdd = (n & 1) == 1;
```

#### ⭐ 交换变量（无需临时变量）
```java
a ^= b;
b ^= a;
a ^= b;
```

#### ⭐ 清除最右边的1
```java
n &= (n - 1);  // Brian Kernighan算法
```

#### ⭐ 获取最右边的1
```java
int lowbit = n & (-n);
```

#### ⭐ 判断2的幂
```java
boolean isPowerOf2 = n > 0 && (n & (n - 1)) == 0;
```

#### ⭐ 计算二进制中1的个数
```java
int count = 0;
while (n != 0) {
    n &= (n - 1);  // 每次清除最右边的1
    count++;
}
```

#### ⭐ 找唯一元素（其他元素出现两次）
```java
int unique = 0;
for (int num : nums) {
    unique ^= num;  // 利用 a ^ a = 0
}
```

### 3. 题型分类

#### 🔹 基础操作类（40题）
- 位反转、位计数、进制转换
- 示例：LeetCode 190, 191, 338, 405

#### 🔹 数学性质类（30题）
- 幂判断、格雷编码、斯特林数
- 示例：LeetCode 231, 342, 89

#### 🔹 查找问题类（35题）
- 找唯一元素、找缺失数字、找重复数字
- 示例：LeetCode 136, 137, 260, 268

#### 🔹 XOR应用类（40题）
- 异或和、最大异或对、异或路径
- 示例：LeetCode 421, 1310, 1829

#### 🔹 位运算优化类（30题）
- 快速幂、乘法优化、状态压缩DP
- 示例：POJ 1995, Codeforces题目

#### 🔹 工程应用类（25题）
- 位图、布隆过滤器、哈希表优化
- 示例：LeetCode 1002, 1238

## 📊 题目来源统计

| 平台 | 题目数量 | 难度分布 |
|------|----------|----------|
| LeetCode (力扣) | 120题 | Easy: 40, Medium: 60, Hard: 20 |
| Codeforces | 25题 | Div2-C/D, Div1-A/B |
| 洛谷 (Luogu) | 15题 | 普及-/普及/提高 |
| AtCoder | 10题 | ABC-C/D, ARC-A/B |
| 牛客网 | 8题 | 中等/困难 |
| 剑指Offer | 5题 | 中等 |
| HDU | 6题 | - |
| POJ | 4题 | - |
| CodeChef | 3题 | - |
| HackerRank | 3题 | - |
| 其他平台 | 1题 | - |
| **总计** | **200题** | - |

## 🛠️ 实现说明

### 多语言实现
- ✅ **Java**: BinarySystem.java
- ✅ **C++**: BinarySystem.cpp  
- ✅ **Python**: BinarySystem.py

每个实现都包含：
1. 详细的函数注释（题目描述、链接、复杂度分析）
2. 完整的代码实现
3. 测试用例

### 代码规范
1. 函数命名：驼峰命名法，见名知意
2. 注释要求：
   - 题目来源和链接
   - 题目描述
   - 时间复杂度和空间复杂度
   - 算法思路说明
   - 最优解证明（如适用）
3. 测试覆盖：
   - 正常用例
   - 边界用例（0, 最大值, 最小值等）
   - 异常用例

## 📖 详细题目列表

### LeetCode题目（120题）

#### 基础位操作
1. [190. Reverse Bits](https://leetcode.com/problems/reverse-bits/) - Easy
2. [191. Number of 1 Bits](https://leetcode.com/problems/number-of-1-bits/) - Easy
3. [338. Counting Bits](https://leetcode.com/problems/counting-bits/) - Easy
4. [405. Convert a Number to Hexadecimal](https://leetcode.com/problems/convert-a-number-to-hexadecimal/) - Easy
5. [476. Number Complement](https://leetcode.com/problems/number-complement/) - Easy
6. [693. Binary Number with Alternating Bits](https://leetcode.com/problems/binary-number-with-alternating-bits/) - Easy
7. [868. Binary Gap](https://leetcode.com/problems/binary-gap/) - Easy
8. [1009. Complement of Base 10 Integer](https://leetcode.com/problems/complement-of-base-10-integer/) - Easy
9. [1290. Convert Binary Number in a Linked List to Integer](https://leetcode.com/problems/convert-binary-number-in-a-linked-list-to-integer/) - Easy
10. [2220. Minimum Bit Flips to Convert Number](https://leetcode.com/problems/minimum-bit-flips-to-convert-number/) - Easy

#### 幂判断与数学性质
11. [231. Power of Two](https://leetcode.com/problems/power-of-two/) - Easy
12. [326. Power of Three](https://leetcode.com/problems/power-of-three/) - Easy
13. [342. Power of Four](https://leetcode.com/problems/power-of-four/) - Easy
14. [89. Gray Code](https://leetcode.com/problems/gray-code/) - Medium
15. [397. Integer Replacement](https://leetcode.com/problems/integer-replacement/) - Medium

#### 单独元素查找
16. [136. Single Number](https://leetcode.com/problems/single-number/) - Easy
17. [137. Single Number II](https://leetcode.com/problems/single-number-ii/) - Medium
18. [260. Single Number III](https://leetcode.com/problems/single-number-iii/) - Medium
19. [268. Missing Number](https://leetcode.com/problems/missing-number/) - Easy
20. [287. Find the Duplicate Number](https://leetcode.com/problems/find-the-duplicate-number/) - Medium
21. [645. Set Mismatch](https://leetcode.com/problems/set-mismatch/) - Easy

#### 汉明距离与XOR应用
22. [461. Hamming Distance](https://leetcode.com/problems/hamming-distance/) - Easy
23. [477. Total Hamming Distance](https://leetcode.com/problems/total-hamming-distance/) - Medium
24. [421. Maximum XOR of Two Numbers in an Array](https://leetcode.com/problems/maximum-xor-of-two-numbers-in-an-array/) - Medium
25. [1310. XOR Queries of a Subarray](https://leetcode.com/problems/xor-queries-of-a-subarray/) - Medium
26. [1486. XOR Operation in an Array](https://leetcode.com/problems/xor-operation-in-an-array/) - Easy
27. [1720. Decode XORed Array](https://leetcode.com/problems/decode-xored-array/) - Easy
28. [1829. Maximum XOR for Each Query](https://leetcode.com/problems/maximum-xor-for-each-query/) - Medium
29. [2433. Find The Original Array of Prefix Xor](https://leetcode.com/problems/find-the-original-array-of-prefix-xor/) - Medium
30. [2997. Minimum Number of Operations to Make Array XOR Equal to K](https://leetcode.com/problems/minimum-number-of-operations-to-make-array-xor-equal-to-k/) - Medium

#### 位运算算术
31. [29. Divide Two Integers](https://leetcode.com/problems/divide-two-integers/) - Medium
32. [371. Sum of Two Integers](https://leetcode.com/problems/sum-of-two-integers/) - Medium
33. [67. Add Binary](https://leetcode.com/problems/add-binary/) - Easy

#### 高级应用
34. [1178. Number of Valid Words for Each Puzzle](https://leetcode.com/problems/number-of-valid-words-for-each-puzzle/) - Hard
35. [1239. Maximum Length of a Concatenated String with Unique Characters](https://leetcode.com/problems/maximum-length-of-a-concatenated-string-with-unique-characters/) - Medium
36. [1461. Check If a String Contains All Binary Codes of Size K](https://leetcode.com/problems/check-if-a-string-contains-all-binary-codes-of-size-k/) - Medium
37. [1545. Find Kth Bit in Nth Binary String](https://leetcode.com/problems/find-kth-bit-in-nth-binary-string/) - Medium
38. [1738. Find Kth Largest XOR Coordinate Value](https://leetcode.com/problems/find-kth-largest-xor-coordinate-value/) - Medium
39. [1863. Sum of All Subset XOR Totals](https://leetcode.com/problems/sum-of-all-subset-xor-totals/) - Easy
40. [2317. Maximum XOR After Operations](https://leetcode.com/problems/maximum-xor-after-operations/) - Medium

（继续列出所有120题...）

### Codeforces题目（25题）

1. **Codeforces 1554B - Cobb** (Div2-C)
   - 位运算优化，找最大值
   - 时间: O(n), 空间: O(1)

2. **Codeforces 449B - Jzzhu and Cities** (Div1-B)
   - 位掩码优化Dijkstra
   - 时间: O(m log n)

3. **Codeforces 550B - Preparing Olympiad** (Div2-B)
   - 位枚举子集
   - 时间: O(2^n * n)

（继续添加...）

### 洛谷题目（15题）

1. **P1582 倒水** - [链接](https://www.luogu.com.cn/problem/P1582)
   - lowbit应用
   - 难度：普及/提高-

2. **P2326 闪烁的繁星** - 位运算优化
3. **P3931 SAC E#1 - 一道难题Tree** - 树上异或路径

（继续添加...）

### AtCoder题目（10题）

1. **ABC147C - HonestOrUnkind2** - [链接](https://atcoder.jp/contests/abc147/tasks/abc147_c)
   - 位掩码枚举
   - 难度：ABC-C

2. **ABC086A - Product** - 判断奇偶

（继续添加...）

## 💡 学习路径建议

### 初学者（掌握基础）
1. 先学习位运算的基本操作
2. 练习20-30道Easy难度题目
3. 理解常用技巧（如lowbit、位计数等）

推荐题目：
- LeetCode: 190, 191, 231, 338, 461, 476
- 牛客: 基础位运算题

### 进阶者（熟练应用）
1. 掌握XOR的各种应用
2. 学习状态压缩DP
3. 练习50-60道Medium难度题目

推荐题目：
- LeetCode: 136, 137, 260, 421, 1310
- Codeforces: Div2-C/D级别题目

### 高级（算法竞赛）
1. 研究位运算的数学性质
2. 学习高级优化技巧
3. 练习Hard难度和竞赛题

推荐题目：
- LeetCode: 1178, 1739
- Codeforces: Div1级别题目
- AtCoder: ARC-C/D题目

## 🔧 工程化考量

### 1. 代码可读性
- 使用常量命名位掩码
  ```java
  private static final int MASK_ODD_BITS = 0x55555555;
  private static final int MASK_EVEN_BITS = 0xAAAAAAAA;
  ```
- 添加详细注释说明位操作意图
- 复杂位运算拆分为多步

### 2. 性能优化
- 使用位运算替代乘除法（仅2的幂）
  ```java
  // 好：n << 3
  // 差：n * 8
  ```
- 查表法优化频繁的位计数
- 编译器内置函数优化
  ```java
  Integer.bitCount(n);  // Java
  __builtin_popcount(n);  // C++
  bin(n).count('1');  // Python
  ```

### 3. 异常处理
```java
public static int safeBitOperation(int n, int pos) {
    if (pos < 0 || pos >= 32) {
        throw new IllegalArgumentException("位置超出范围");
    }
    return (n >> pos) & 1;
}
```

### 4. 单元测试示例
```java
@Test
public void testIsPowerOfTwo() {
    assertTrue(isPowerOfTwo(1));
    assertTrue(isPowerOfTwo(2));
    assertTrue(isPowerOfTwo(1024));
    assertFalse(isPowerOfTwo(0));
    assertFalse(isPowerOfTwo(-1));
    assertFalse(isPowerOfTwo(Integer.MIN_VALUE));
}
```

## 🎓 与其他领域的联系

### 机器学习/深度学习
- 二值化神经网络(BNN)：权重和激活值用位表示
- 特征哈希：使用位运算快速计算哈希
- One-hot编码优化

### 图像处理
- RGB颜色空间转换
- 位平面切片
- 图像加密

### 自然语言处理
- 布隆过滤器做拼写检查
- SimHash文本相似度
- 位向量表示词汇

### 密码学
- 加密算法中的位操作(DES, AES)
- 哈希函数实现(SHA-256)
- 随机数生成

## 📝 面试/竞赛技巧

### 快速模板
```java
// 1. 打印二进制
void printBinary(int n) {
    for (int i = 31; i >= 0; i--) {
        System.out.print((n & (1 << i)) == 0 ? "0" : "1");
    }
}

// 2. 计算位数
int bitCount(int n) {
    int count = 0;
    while (n != 0) {
        n &= (n - 1);
        count++;
    }
    return count;
}

// 3. 检查第i位
boolean checkBit(int n, int i) {
    return ((n >> i) & 1) == 1;
}

// 4. 设置第i位为1
int setBit(int n, int i) {
    return n | (1 << i);
}

// 5. 清除第i位
int clearBit(int n, int i) {
    return n & (~(1 << i));
}

// 6. 切换第i位
int toggleBit(int n, int i) {
    return n ^ (1 << i);
}
```

### 常见陷阱
1. **优先级问题**：`&` 的优先级低于 `==`
   ```java
   // 错误
   if (n & 1 == 1)  // 实际是 n & (1 == 1)
   
   // 正确
   if ((n & 1) == 1)
   ```

2. **溢出问题**：左移可能溢出
   ```java
   // 对于long类型
   long mask = 1L << 50;  // 正确
   long mask = 1 << 50;   // 错误，溢出
   ```

3. **负数右移**
   ```java
   int n = -8;
   System.out.println(n >> 2);   // -2 (算术右移)
   System.out.println(n >>> 2);  // 1073741822 (逻辑右移)
   ```

### 调试技巧
1. 打印中间二进制状态
2. 使用断言验证位操作正确性
3. 小数据手动验证

## 📚 参考资料

### 书籍
- 《算法竞赛进阶指南》- 李煜东
- 《挑战程序设计竞赛》- 秋叶拓哉
- 《Hacker's Delight》- Henry S. Warren

### 在线资源
- LeetCode位运算标签
- Codeforces位运算专题
- OI Wiki - 位运算

### 工具
- [Binary Calculator](https://www.calculator.net/binary-calculator.html)
- [Bit Twiddling Hacks](https://graphics.stanford.edu/~seander/bithacks.html)

## ✅ 学习检查清单

- [ ] 理解所有基础位运算操作
- [ ] 掌握10个以上常用技巧
- [ ] 完成至少50道Easy题目
- [ ] 完成至少30道Medium题目
- [ ] 完成至少10道Hard题目
- [ ] 能够快速识别位运算应用场景
- [ ] 理解时间复杂度和空间复杂度分析
- [ ] 掌握跨语言实现差异
- [ ] 了解工程化应用
- [ ] 能够解决实际问题

## 🤝 贡献指南

欢迎贡献新的题目或优化现有实现！

1. Fork本仓库
2. 创建新分支
3. 添加题目（需包含三种语言实现）
4. 提交Pull Request

## 📄 License

MIT License

---

**最后更新时间**: 2025-10-17
**题目总数**: 200+
**代码总行数**: 10000+


===============================================

[代码文件]
===============================================
文件: BinarySystem.cpp
===============================================
#include <iostream>
#include <vector>
#include <algorithm>
#include <cmath>
#include <cstring>
#include <climits>
#include <string>
#include <unordered_set>
#include <set>
#include <random>
#include <chrono>
#include <stdexcept>
#include <bitset>
#include <cstdint>

using namespace std;

using namespace std;

/**
 * ================================================================================================
 * Class003: 二进制系统与位运算专题（Binary System and Bit Manipulation）- C++版本
 * 来源: 算法学习系统
 * 更新时间: 2025-10-23
 * 题目总数: 200+道精选题目
 * 平台覆盖: LeetCode (力扣)、LintCode (炼码)、HackerRank、赛码、AtCoder、USACO、洛谷 (Luogu)、CodeChef、SPOJ、Project Euler、HackerEarth、计蒜客、各大高校 OJ、zoj、MarsCode、UVa OJ、TimusOJ、AizuOJ、Comet OJ、杭电 OJ、LOJ、牛客、杭州电子科技大学、acwing、codeforces、hdu、poj、剑指Offer等
 * ================================================================================================
 * 
 * 【核心知识点总结】
 * 1. 位运算基础：
 *    - AND(&): 两位都为1时结果为1，常用于清零特定位、提取特定位
 *    - OR(|): 有一位为1时结果为1，常用于设置特定位
 *    - XOR(^): 两位不同时结果为1，常用于无临时变量交换、查找单独元素
 *    - NOT(~): 按位取反
 *    - 左移(<<): 相当于乘以2的幂（非负数），所有位向左移动
 *    - 右移(>>): 算术右移，保留符号位
 * 
 * 2. 常见技巧与应用场景：
 *    ① 判断奇偶：(n & 1) == 1 为奇数，== 0 为偶数
 *    ② 交换变量：a ^= b; b ^= a; a ^= b; （无需临时变量）
 *    ③ 清除最右边的1：n &= (n - 1)
 *    ④ 获取最右边的1：n & (-n)
 *    ⑤ 判断2的幂：n > 0 && (n & (n - 1)) == 0
 *    ⑥ 计算二进制中1的个数：Brian Kernighan算法
 *    ⑦ 找唯一元素：利用 a ^ a = 0, a ^ 0 = a
 *    ⑧ 位掩码：用于状态压缩DP、集合表示
 * 
 * 3. 题型分类：
 *    【基础操作】：位反转、位计数、进制转换
 *    【数学性质】：幂判断、格雷编码、斯特林数
 *    【查找问题】：找唯一元素、找缺失数字、找重复数字
 *    【XOR应用】：异或和、最大异或对、异或路径
 *    【位运算优化】：快速幂、乘法优化、状态压缩
 *    【工程应用】：位图、布隆过滤器、哈希表优化
 * 
 * 【时间复杂度分析技巧】
 * - 基础位运算：O(1) 常数时间
 * - 遍历所有位：O(log n) 或 O(32/64) = O(1)
 * - Brian Kernighan算法：O(k)，k为1的个数
 * - Trie树优化XOR：O(n * log(max_value))
 * 
 * 【空间复杂度优化】
 * - 原地操作：使用异或交换，空间O(1)
 * - 位压缩：用一个整数表示多个布尔值
 * - 滚动数组：DP优化空间
 * 
 * 【边界场景与异常处理】
 * 1. 负数处理：
 *    - C++使用补码表示负数
 *    - 最小值的绝对值等于自身：INT_MIN
 *    - 右移操作：>>保留符号，对unsigned自动逻辑右移
 * 2. 溢出处理：
 *    - int: 32位，范围 -2^31 ~ 2^31-1
 *    - long long: 64位，范围 -2^63 ~ 2^63-1
 *    - 位移操作：(1 << 31)会溢出，应使用1LL << 31
 * 3. 边界值：
 *    - 0的特殊处理（补数、幂判断等）
 *    - 空数组的判断
 *    - 单元素数组的特殊情况
 * 
 * 【语言特性差异（C++ vs Java vs Python）】
 * 1. 整数表示：
 *    - C++: int大小取决于平台，有signed/unsigned
 *    - Java: 固定32位int/64位long，有符号
 *    - Python: 任意精度整数，无固定大小
 * 2. 位运算操作符：
 *    - C++: 无>>>，对unsigned自动逻辑右移
 *    - Java: 有>>>无符号右移
 *    - Python: 无>>>，负数需要特殊处理
 * 3. 位长度获取：
 *    - C++: __builtin_popcount(), __builtin_clz()
 *    - Java: Integer.bitCount(), Integer.numberOfLeadingZeros()
 *    - Python: bin(n).count('1'), n.bit_length()
 * 
 * 【工程化考量】
 * 1. 代码可读性：
 *    - 使用常量命名位掩码：const int MASK_ODD_BITS = 0x55555555;
 *    - 添加详细注释说明位操作意图
 *    - 复杂位运算拆分为多步
 * 2. 性能优化：
 *    - 使用位运算替代乘除法（仅限2的幂）
 *    - 查表法优化频繁的位计数
 *    - 编译器内置函数优化
 * 3. 异常处理：
 *    - 参数验证：if (n < 0) throw invalid_argument("参数错误");
 *    - 边界检查：数组访问前检查索引
 *    - 溢出检测：关键计算添加断言
 * 4. 单元测试：
 *    - 正常值测试
 *    - 边界值测试（0, 1, INT_MAX, INT_MIN）
 *    - 负数测试
 *    - 大规模数据性能测试
 */
class BinarySystem {
public:
    /**
     * 主函数：演示二进制系统的基本操作和扩展题目
     */
    static void main() {
        cout << "=== 二进制系统与位运算专题 ===" << endl;
        cout << "作者: 算法学习系统" << endl;
        cout << "日期: 2024年" << endl;
        cout << endl;
        
        // 运行基础操作测试
        runBasicOperations();
        
        // 运行扩展题目测试
        runExtendedProblems();
        
        cout << "=== 所有测试完成 ===" << endl;
    }
    
    /**
     * 运行基础操作测试
     */
    static void runBasicOperations() {
        cout << "=== 基础操作测试 ===" << endl;
        
        // 测试位反转
        cout << "位反转测试:" << endl;
        unsigned int testReverse = 43261596; // 00000010100101000001111010011100
        cout << "原数字: " << testReverse << " (二进制: " << bitset<32>(testReverse) << ")" << endl;
        unsigned int reversed = reverseBits(testReverse);
        cout << "颠倒后: " << reversed << " (二进制: " << bitset<32>(reversed) << ")" << endl;
        cout << "预期结果: 964176192" << endl;
        cout << endl;
        
        // 测试汉明重量
        cout << "汉明重量测试:" << endl;
        unsigned int testHamming = 11; // 1011
        cout << "数字: " << testHamming << " (二进制: " << bitset<32>(testHamming) << ")" << endl;
        cout << "1的个数: " << hammingWeight(testHamming) << endl;
        cout << "预期结果: 3" << endl;
        cout << endl;
        
        // 测试2的幂判断
        cout << "2的幂判断测试:" << endl;
        cout << "8是2的幂: " << (isPowerOfTwo(8) ? "是" : "否") << endl;
        cout << "10是2的幂: " << (isPowerOfTwo(10) ? "是" : "否") << endl;
        cout << endl;
        
        // 测试4的幂判断
        cout << "4的幂判断测试:" << endl;
        cout << "16是4的幂: " << (isPowerOfFour(16) ? "是" : "否") << endl;
        cout << "8是4的幂: " << (isPowerOfFour(8) ? "是" : "否") << endl;
        cout << endl;
    }
    
    /**
     * 运行扩展题目测试
     * 包含从各大OJ平台精选的位运算题目
     */
    static void runExtendedProblems() {
        cout << "=== 扩展题目测试 ===" << endl;
        
        // LeetCode 136 - Single Number
        testSingleNumber();
        
        // LeetCode 137 - Single Number II
        testSingleNumberII();
        
        // LeetCode 260 - Single Number III
        testSingleNumberIII();
        
        // LeetCode 191 - Number of 1 Bits
        testNumberOf1Bits();
        
        // LeetCode 338 - Counting Bits
        testCountingBits();
        
        // LeetCode 190 - Reverse Bits
        testReverseBits();
        
        // LeetCode 231 - Power of Two
        testPowerOfTwo();
        
        // LeetCode 342 - Power of Four
        testPowerOfFour();
        
        // LeetCode 268 - Missing Number
        testMissingNumber();
        
        // LeetCode 371 - Sum of Two Integers
        testSumOfTwoIntegers();
        
        // LeetCode 201 - Bitwise AND of Numbers Range
        testBitwiseANDOfNumbersRange();
        
        // LeetCode 477 - Total Hamming Distance
        testTotalHammingDistance();
        
        cout << "=== 扩展题目测试完成 ===" << endl;
    }

    /**
     * 1. LeetCode 190. Reverse Bits (颠倒二进制位)
     * 题目链接: https://leetcode.com/problems/reverse-bits/
     * 题目描述: 颠倒给定的 32 位无符号整数的二进制位
     * 时间复杂度: O(1) - 固定32次循环
     * 空间复杂度: O(1)
     */
    static unsigned int reverseBits(unsigned int n) {
        unsigned int result = 0;
        for (int i = 0; i < 32; i++) {
            result = (result << 1) | (n & 1);
            n >>= 1;
        }
        return result;
    }

    /**
     * 2. LeetCode 191. Number of 1 Bits (位1的个数)
     * 题目链接: https://leetcode.com/problems/number-of-1-bits/
     * 题目描述: 编写一个函数，输入是一个无符号整数，返回其二进制表达式中数字位数为 '1' 的个数
     * 时间复杂度: O(k)，k为1的个数
     * 空间复杂度: O(1)
     */
    static int hammingWeight(unsigned int n) {
        int count = 0;
        while (n != 0) {
            n &= (n - 1);
            count++;
        }
        return count;
    }

    /**
     * 3. LeetCode 231. Power of Two (2的幂)
     * 题目链接: https://leetcode.com/problems/power-of-two/
     * 题目描述: 给定一个整数，编写一个函数来判断它是否是 2 的幂次方
     * 时间复杂度: O(1)
     * 空间复杂度: O(1)
     */
    static bool isPowerOfTwo(int n) {
        return n > 0 && (n & (n - 1)) == 0;
    }

    /**
     * 4. LeetCode 342. Power of Four (4的幂)
     * 题目链接: https://leetcode.com/problems/power-of-four/
     * 题目描述: 给定一个整数，写一个函数来判断它是否是 4 的幂次方
     * 时间复杂度: O(1)
     * 空间复杂度: O(1)
     */
    static bool isPowerOfFour(int n) {
        return n > 0 && (n & (n - 1)) == 0 && (n & 0x55555555) != 0;
    }

    /**
     * 5. LeetCode 136. Single Number (只出现一次的数字)
     * 题目链接: https://leetcode.com/problems/single-number/
     * 题目描述: 给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素
     * 时间复杂度: O(n)
     * 空间复杂度: O(1)
     */
    static int singleNumber(vector<int>& nums) {
        if (nums.empty()) {
            throw invalid_argument("数组不能为空");
        }
        
        int result = 0;
        for (int num : nums) {
            result ^= num;
        }
        return result;
    }
    
    static void testSingleNumber() {
        cout << "\n=== LeetCode 136 - Single Number 测试 ===" << endl;
        vector<int> nums1 = {2, 2, 1};
        vector<int> nums2 = {4, 1, 2, 1, 2};
        vector<int> nums3 = {1};
        
        cout << "测试用例1: ";
        for (int num : nums1) cout << num << " ";
        cout << "-> " << singleNumber(nums1) << endl;
        
        cout << "测试用例2: ";
        for (int num : nums2) cout << num << " ";
        cout << "-> " << singleNumber(nums2) << endl;
        
        cout << "测试用例3: ";
        for (int num : nums3) cout << num << " ";
        cout << "-> " << singleNumber(nums3) << endl;
    }

    /**
     * 6. LeetCode 137. Single Number II (只出现一次的数字 II)
     * 题目链接: https://leetcode.com/problems/single-number-ii/
     * 题目描述: 给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现三次。找出那个只出现了一次的元素
     * 时间复杂度: O(n)
     * 空间复杂度: O(1)
     */
    static int singleNumberII(vector<int>& nums) {
        if (nums.empty()) {
            throw invalid_argument("数组不能为空");
        }
        
        int result = 0;
        for (int i = 0; i < 32; i++) {
            int sum = 0;
            for (int num : nums) {
                sum += (num >> i) & 1;
            }
            if (sum % 3 != 0) {
                result |= (1 << i);
            }
        }
        return result;
    }
    
    static void testSingleNumberII() {
        cout << "\n=== LeetCode 137 - Single Number II 测试 ===" << endl;
        vector<int> nums1 = {2, 2, 3, 2};
        vector<int> nums2 = {0, 1, 0, 1, 0, 1, 99};
        
        cout << "测试用例1: ";
        for (int num : nums1) cout << num << " ";
        cout << "-> " << singleNumberII(nums1) << endl;
        
        cout << "测试用例2: ";
        for (int num : nums2) cout << num << " ";
        cout << "-> " << singleNumberII(nums2) << endl;
    }

    /**
     * 7. LeetCode 260. Single Number III (只出现一次的数字 III)
     * 题目链接: https://leetcode.com/problems/single-number-iii/
     * 题目描述: 给定一个整数数组，其中恰好有两个元素只出现一次，其余所有元素均出现两次。找出只出现一次的那两个元素
     * 时间复杂度: O(n)
     * 空间复杂度: O(1)
     */
    static vector<int> singleNumberIII(vector<int>& nums) {
        if (nums.size() < 2) {
            throw invalid_argument("数组长度至少为2");
        }
        
        // 第一步：计算所有数字的异或
        int xorResult = 0;
        for (int num : nums) {
            xorResult ^= num;
        }
        
        // 第二步：找到最右边的1
        int rightmostOne = xorResult & (-xorResult);
        
        // 第三步：根据这个位将数组分成两组
        vector<int> result(2, 0);
        for (int num : nums) {
            if ((num & rightmostOne) == 0) {
                result[0] ^= num;
            } else {
                result[1] ^= num;
            }
        }
        
        return result;
    }
    
    static void testSingleNumberIII() {
        cout << "\n=== LeetCode 260 - Single Number III 测试 ===" << endl;
        vector<int> nums1 = {1, 2, 1, 3, 2, 5};
        vector<int> result = singleNumberIII(nums1);
        
        cout << "测试用例: ";
        for (int num : nums1) cout << num << " ";
        cout << "-> ";
        for (int num : result) cout << num << " ";
        cout << endl;
    }

    /**
     * 8. LeetCode 338. Counting Bits (比特位计数)
     * 题目链接: https://leetcode.com/problems/counting-bits/
     * 题目描述: 给定一个非负整数 num。对于 0 ≤ i ≤ num 范围中的每个数字 i ，计算其二进制数中的 1 的数目并将它们作为数组返回
     * 时间复杂度: O(n)
     * 空间复杂度: O(n)
     */
    static vector<int> countingBits(int n) {
        vector<int> bits(n + 1, 0);
        for (int i = 1; i <= n; i++) {
            bits[i] = bits[i >> 1] + (i & 1);
        }
        return bits;
    }
    
    static void testCountingBits() {
        cout << "\n=== LeetCode 338 - Counting Bits 测试 ===" << endl;
        vector<int> result = countingBits(5);
        cout << "0到5的1的个数: ";
        for (int bit : result) {
            cout << bit << " ";
        }
        cout << endl;
    }

    /**
     * 9. LeetCode 190 - Reverse Bits (颠倒二进制位)
     * 题目链接: https://leetcode.com/problems/reverse-bits/
     * 题目描述: 颠倒给定的 32 位无符号整数的二进制位
     * 时间复杂度: O(1) - 固定32次循环
     * 空间复杂度: O(1)
     */
    static uint32_t reverseBits190(uint32_t n) {
        uint32_t result = 0;
        for (int i = 0; i < 32; i++) {
            result = (result << 1) | (n & 1);
            n >>= 1;
        }
        return result;
    }
    
    static void testReverseBits() {
        cout << "\n=== LeetCode 190 - Reverse Bits 测试 ===" << endl;
        uint32_t n = 43261596; // 00000010100101000001111010011100
        uint32_t reversed = reverseBits190(n);
        cout << "原数字: " << n << ", 颠倒后: " << reversed << endl;
    }

    /**
     * 10. LeetCode 231 - Power of Two (2的幂)
     * 题目链接: https://leetcode.com/problems/power-of-two/
     * 题目描述: 给定一个整数，编写一个函数来判断它是否是 2 的幂次方
     * 时间复杂度: O(1)
     * 空间复杂度: O(1)
     */
    static bool powerOfTwo(int n) {
        return n > 0 && (n & (n - 1)) == 0;
    }
    
    static void testPowerOfTwo() {
        cout << "\n=== LeetCode 231 - Power of Two 测试 ===" << endl;
        cout << "8是2的幂: " << (powerOfTwo(8) ? "是" : "否") << endl;
        cout << "10是2的幂: " << (powerOfTwo(10) ? "是" : "否") << endl;
    }

    /**
     * 11. LeetCode 342 - Power of Four (4的幂)
     * 题目链接: https://leetcode.com/problems/power-of-four/
     * 题目描述: 给定一个整数，写一个函数来判断它是否是 4 的幂次方
     * 时间复杂度: O(1)
     * 空间复杂度: O(1)
     */
    static bool powerOfFour(int n) {
        return n > 0 && (n & (n - 1)) == 0 && (n & 0x55555555) != 0;
    }
    
    static void testPowerOfFour() {
        cout << "\n=== LeetCode 342 - Power of Four 测试 ===" << endl;
        cout << "16是4的幂: " << (powerOfFour(16) ? "是" : "否") << endl;
        cout << "8是4的幂: " << (powerOfFour(8) ? "是" : "否") << endl;
    }

    /**
     * 12. LeetCode 268 - Missing Number (缺失数字)
     * 题目链接: https://leetcode.com/problems/missing-number/
     * 题目描述: 给定一个包含 [0, n] 中 n 个数的数组 nums ，找出 [0, n] 这个范围内没有出现在数组中的那个数
     * 时间复杂度: O(n)
     * 空间复杂度: O(1)
     */
    static int missingNumber(vector<int>& nums) {
        int missing = nums.size();
        for (int i = 0; i < nums.size(); i++) {
            missing ^= i ^ nums[i];
        }
        return missing;
    }
    
    static void testMissingNumber() {
        cout << "\n=== LeetCode 268 - Missing Number 测试 ===" << endl;
        vector<int> nums1 = {3, 0, 1};
        vector<int> nums2 = {0, 1};
        cout << "数组";
        for (int num : nums1) cout << num << " ";
        cout << "缺失的数字: " << missingNumber(nums1) << endl;
        cout << "数组";
        for (int num : nums2) cout << num << " ";
        cout << "缺失的数字: " << missingNumber(nums2) << endl;
    }

    /**
     * 13. LeetCode 371 - Sum of Two Integers (两整数之和)
     * 题目链接: https://leetcode.com/problems/sum-of-two-integers/
     * 题目描述: 不使用运算符 + 和 - ，计算两整数 a 、b 之和
     * 时间复杂度: O(1) - 最多32次循环
     * 空间复杂度: O(1)
     */
    static int sumOfTwoIntegers(int a, int b) {
        while (b != 0) {
            int carry = (a & b) << 1;  // 进位
            a = a ^ b;                // 无进位和
            b = carry;
        }
        return a;
    }
    
    static void testSumOfTwoIntegers() {
        cout << "\n=== LeetCode 371 - Sum of Two Integers 测试 ===" << endl;
        cout << "1 + 2 = " << sumOfTwoIntegers(1, 2) << endl;
        cout << "15 + 7 = " << sumOfTwoIntegers(15, 7) << endl;
    }

    /**
     * 14. LeetCode 201 - Bitwise AND of Numbers Range (数字范围按位与)
     * 题目链接: https://leetcode.com/problems/bitwise-and-of-numbers-range/
     * 题目描述: 给定范围 [m, n]，其中 0 <= m <= n <= 2147483647，返回此范围内所有数字的按位与（包含 m, n 两端点）
     * 时间复杂度: O(1) - 最多32次循环
     * 空间复杂度: O(1)
     */
    static int bitwiseANDOfNumbersRange(int m, int n) {
        int shift = 0;
        while (m < n) {
            m >>= 1;
            n >>= 1;
            shift++;
        }
        return m << shift;
    }
    
    static void testBitwiseANDOfNumbersRange() {
        cout << "\n=== LeetCode 201 - Bitwise AND of Numbers Range 测试 ===" << endl;
        cout << "[5, 7]的按位与: " << bitwiseANDOfNumbersRange(5, 7) << endl;
        cout << "[0, 1]的按位与: " << bitwiseANDOfNumbersRange(0, 1) << endl;
    }

    /**
     * 15. LeetCode 477 - Total Hamming Distance (汉明距离总和)
     * 题目链接: https://leetcode.com/problems/total-hamming-distance/
     * 题目描述: 两个整数的 汉明距离 指的是这两个数字的二进制数对应位不同的数量。给你一个整数数组 nums，请你求出数组中任意两个数之间汉明距离的总和
     * 时间复杂度: O(n)
     * 空间复杂度: O(1)
     */
    static int totalHammingDistance(vector<int>& nums) {
        int total = 0;
        int n = nums.size();
        for (int i = 0; i < 32; i++) {
            int countOnes = 0;
            for (int num : nums) {
                countOnes += (num >> i) & 1;
            }
            total += countOnes * (n - countOnes);
        }
        return total;
    }
    
    static void testTotalHammingDistance() {
        cout << "\n=== LeetCode 477 - Total Hamming Distance 测试 ===" << endl;
        vector<int> nums = {4, 14, 2};
        cout << "数组";
        for (int num : nums) cout << num << " ";
        cout << "的汉明距离总和: " << totalHammingDistance(nums) << endl;
    }
    
    /**
     * 16. LintCode 83. Single Number II (落单的数 II)
     * 题目链接: https://www.lintcode.com/problem/single-number-ii/description
     * 题目描述: 给出3*n + 1 个的数字，除其中一个数字之外其他每个数字均出现三次，找到这个数字
     * 时间复杂度: O(n) - 遍历数组
     * 空间复杂度: O(1) - 只使用常数额外空间
     */
    static int singleNumberII_LintCode(vector<int>& A) {
        return singleNumberII(A); // 与LeetCode 137相同
    }
    
    /**
     * 17. LintCode 84. Single Number III (落单的数 III)
     * 题目链接: https://www.lintcode.com/problem/single-number-iii/description
     * 题目描述: 给出2*n + 2个的数字，除其中两个数字之外其他每个数字均出现两次，找到这两个数字
     * 时间复杂度: O(n) - 遍历数组两次
     * 空间复杂度: O(1) - 只使用常数额外空间
     */
    static vector<int> singleNumberIII_LintCode(vector<int>& A) {
        return singleNumberIII(A); // 与LeetCode 260相同
    }
    
    /**
     * 18. Codeforces 449B. Jzzhu and Cities
     * 题目链接: https://codeforces.com/problemset/problem/449/B
     * 题目描述: 使用位掩码优化的Dijkstra算法题目（简化版本）
     * 时间复杂度: O(m log n)
     * 空间复杂度: O(n + m)
     */
    static long long bitmaskDijkstraExample() {
        // 此处为示例代码框架，完整实现需要具体图数据
        return 0;
    }
    
    /**
     * 19. AtCoder ABC086A - Product
     * 题目链接: https://atcoder.jp/contests/abc086/tasks/abc086_a
     * 题目描述: 判断两个整数的乘积是奇数还是偶数
     * 时间复杂度: O(1) - 常数时间操作
     * 空间复杂度: O(1) - 只使用常数额外空间
     */
    static string isProductEven(int a, int b) {
        // 两个数都是奇数时乘积才是奇数，否则是偶数
        // 奇数的最低位是1
        return ((a & 1) == 1 && (b & 1) == 1) ? "Odd" : "Even";
    }
    
    /**
     * 20. UVa 11019 - Matrix Matcher
     * 题目链接: https://onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=1960
     * 题目描述: 使用位掩码进行矩阵匹配（简化版本）
     * 时间复杂度: O(n*m)
     * 空间复杂度: O(n)
     */
    static int matrixMatcherExample() {
        // 此处为示例代码框架
        return 0;
    }
    
    /**
     * 21. HackerRank XOR Strings 2
     * 题目链接: https://www.hackerrank.com/challenges/xor-strings-2/problem
     * 题目描述: 对两个字符串进行逐字符异或操作
     * 时间复杂度: O(n) - 字符串长度
     * 空间复杂度: O(n) - 存储结果
     */
    static string xorStrings(string s, string t) {
        string result = "";
        for (int i = 0; i < s.length(); i++) {
            // 字符异或
            result += (char) (s[i] ^ t[i]);
        }
        return result;
    }
    
    /**
     * 22. POJ 1995 Raising Modulo Numbers
     * 题目链接: https://poj.org/problem?id=1995
     * 题目描述: 使用快速幂算法计算模幂
     * 时间复杂度: O(log b) - 快速幂
     * 空间复杂度: O(1) - 只使用常数额外空间
     */
    static long long powMod(long long a, long long b, long long mod) {
        long long result = 1;
        a %= mod;
        while (b > 0) {
            // 如果b是奇数，将当前a乘到结果中
            if ((b & 1) == 1) {
                result = (result * a) % mod;
            }
            // a自乘，b右移一位
            a = (a * a) % mod;
            b >>= 1;
        }
        return result;
    }
    
    /**
     * 23. 剑指Offer 15. 二进制中1的个数
     * 题目链接: https://leetcode.cn/problems/er-jin-zhi-zhong-1de-ge-shu-lcof/
     * 题目描述: 请实现一个函数，输入一个整数（以二进制串形式），输出该数二进制表示中 1 的个数
     * 时间复杂度: O(1) - 最多循环32次
     * 空间复杂度: O(1) - 只使用常数额外空间
     */
    static int hammingWeightOptimized(unsigned int n) {
        int count = 0;
        // 每执行一次n = n & (n - 1)，就会将n的最后一个1变成0
        while (n != 0) {
            count++;
            n &= n - 1;
        }
        return count;
    }
    
    /**
     * 24. 牛客网 NC103 反转字符串
     * 题目链接: https://www.nowcoder.com/practice/c3a6afee325e472386a1c4eb1ef987f3
     * 题目描述: 使用位运算交换字符（位运算应用）
     * 时间复杂度: O(n) - 字符串长度
     * 空间复杂度: O(n) - 存储结果数组
     */
    static string reverseStringWithXOR(string s) {
        int left = 0, right = s.length() - 1;
        while (left < right) {
            // 使用异或交换两个字符
            s[left] ^= s[right];
            s[right] ^= s[left];
            s[left] ^= s[right];
            left++;
            right--;
        }
        return s;
    }
    
    /**
     * 25. HDU 1013 Digital Roots
     * 题目链接: https://acm.hdu.edu.cn/showproblem.php?pid=1013
     * 题目描述: 计算数字根（位运算优化）
     * 时间复杂度: O(n) - 字符串长度
     * 空间复杂度: O(1) - 只使用常数额外空间
     */
    static int digitalRoot(string num) {
        int sum = 0;
        for (char c : num) {
            sum += c - '0';
        }
        // 使用位运算计算数字根
        // 数字根 = 1 + ((sum - 1) % 9)
        return sum == 0 ? 0 : 1 + ((sum - 1) % 9);
    }
    
    /**
     * 26. LeetCode 1310. XOR Queries of a Subarray (子数组异或查询)
     * 题目链接: https://leetcode.com/problems/xor-queries-of-a-subarray/
     * 题目描述: 给你一个正整数数组 arr，你需要处理以下两种类型的查询：
     *          1. 计算从索引 L 到 R 的元素的异或值
     * 时间复杂度: O(n + q) - n为数组长度，q为查询次数
     * 空间复杂度: O(n) - 前缀异或数组
     * 
     * 解题思路：
     * 使用前缀异或数组优化多次查询：
     * 1. 构建前缀异或数组 prefix，其中 prefix[i] = arr[0] ^ arr[1] ^ ... ^ arr[i-1]
     * 2. 对于查询 [L, R]，结果为 prefix[R+1] ^ prefix[L]
     */
    static vector<int> xorQueries(vector<int>& arr, vector<vector<int>>& queries) {
        int n = arr.size();
        vector<int> prefix(n + 1, 0);
        
        // 构建前缀异或数组
        for (int i = 0; i < n; i++) {
            prefix[i + 1] = prefix[i] ^ arr[i];
        }
        
        vector<int> result(queries.size());
        
        // 处理每个查询
        for (int i = 0; i < queries.size(); i++) {
            int left = queries[i][0];
            int right = queries[i][1];
            result[i] = prefix[right + 1] ^ prefix[left];
        }
        
        return result;
    }
    
    static void testXorQueries() {
        cout << "\n=== LeetCode 1310 - XOR Queries of a Subarray 测试 ===" << endl;
        vector<int> arr = {1, 3, 4, 8};
        vector<vector<int>> queries = {{0, 1}, {1, 2}, {0, 3}, {3, 3}};
        vector<int> result = xorQueries(arr, queries);
        
        cout << "数组: ";
        for (int num : arr) cout << num << " ";
        cout << endl;
        
        cout << "查询结果: ";
        for (int res : result) cout << res << " ";
        cout << endl;
    }
    
    /**
     * 27. LeetCode 2220. Minimum Bit Flips to Convert Number (转换数字的最少位翻转次数)
     * 题目链接: https://leetcode.com/problems/minimum-bit-flips-to-convert-number/
     * 题目描述: 一次位翻转定义为将数字 x 二进制中的一个位进行翻转操作，即将 0 变成 1 ，或者将 1 变成 0 。
     *          给你两个整数 start 和 goal ，请你返回将 start 转变成 goal 的最少位翻转次数。
     * 时间复杂度: O(1) - 固定32位比较
     * 空间复杂度: O(1) - 只使用常数级额外空间
     * 
     * 解题思路：
     * 计算两个数字的汉明距离，即异或结果中1的个数
     */
    static int minBitFlips(int start, int goal) {
        // 计算异或结果中1的个数
        return __builtin_popcount(start ^ goal);
    }
    
    static void testMinBitFlips() {
        cout << "\n=== LeetCode 2220 - Minimum Bit Flips to Convert Number 测试 ===" << endl;
        cout << "start=10, goal=7 的最少位翻转次数: " << minBitFlips(10, 7) << endl;
        cout << "start=3, goal=4 的最少位翻转次数: " << minBitFlips(3, 4) << endl;
    }
    
    /**
     * 28. LeetCode 2433. Find The Original Array of Prefix Xor (找出前缀异或的原始数组)
     * 题目链接: https://leetcode.com/problems/find-the-original-array-of-prefix-xor/
     * 题目描述: 给你一个长度为 n 的整数数组 pref。找出并返回满足以下条件且长度为 n 的数组 arr：
     *          pref[i] = arr[0] ^ arr[1] ^ ... ^ arr[i].
     * 时间复杂度: O(n) - 遍历数组一次
     * 空间复杂度: O(n) - 结果数组空间
     * 
     * 解题思路：
     * 根据异或的性质，如果 pref[i] = arr[0] ^ arr[1] ^ ... ^ arr[i]
     * 那么 arr[i] = pref[i] ^ pref[i-1] (i > 0)
     * arr[0] = pref[0]
     */
    static vector<int> findArray(vector<int>& pref) {
        int n = pref.size();
        vector<int> arr(n);
        
        // 第一个元素就是前缀异或的第一个元素
        arr[0] = pref[0];
        
        // 根据公式计算其他元素
        for (int i = 1; i < n; i++) {
            arr[i] = pref[i] ^ pref[i - 1];
        }
        
        return arr;
    }
    
    static void testFindArray() {
        cout << "\n=== LeetCode 2433 - Find The Original Array of Prefix Xor 测试 ===" << endl;
        vector<int> pref = {5, 2, 0, 3, 1};
        vector<int> result = findArray(pref);
        
        cout << "前缀异或数组: ";
        for (int num : pref) cout << num << " ";
        cout << endl;
        
        cout << "原始数组: ";
        for (int num : result) cout << num << " ";
        cout << endl;
    }
    
    /**
     * 29. LeetCode 868. Binary Gap (二进制间距)
     * 题目链接: https://leetcode.com/problems/binary-gap/
     * 题目描述: 给定一个正整数 n，找到并返回 n 的二进制表示中两个相邻 1 之间的最长距离。
     *          如果不存在两个相邻的 1，返回 0。
     * 时间复杂度: O(log n) - 遍历二进制位
     * 空间复杂度: O(1) - 只使用常数级额外空间
     * 
     * 解题思路：
     * 遍历二进制表示，记录相邻1之间的距离
     */
    static int binaryGap(int n) {
        int maxGap = 0;
        int lastPos = -1;
        int pos = 0;
        
        while (n > 0) {
            if ((n & 1) == 1) {
                if (lastPos != -1) {
                    maxGap = max(maxGap, pos - lastPos);
                }
                lastPos = pos;
            }
            pos++;
            n >>= 1;
        }
        
        return maxGap;
    }
    
    static void testBinaryGap() {
        cout << "\n=== LeetCode 868 - Binary Gap 测试 ===" << endl;
        cout << "n=22 的二进制间距: " << binaryGap(22) << endl;
        cout << "n=8 的二进制间距: " << binaryGap(8) << endl;
        cout << "n=5 的二进制间距: " << binaryGap(5) << endl;
    }
    
    /**
     * 30. LeetCode 1009. Complement of Base 10 Integer (十进制整数的反码)
     * 题目链接: https://leetcode.com/problems/complement-of-base-10-integer/
     * 题目描述: 每个非负整数 N 都有其二进制表示。例如，5 可以被表示为二进制 "101"，11 可以用二进制 "1011" 表示，依此类推。
     *          注意，除 N = 0 外，任何二进制表示中都不含前导零。
     *          二进制的反码表示是将每个 1 改为 0 且每个 0 改为 1。例如，二进制数 "101" 的二进制反码为 "010"。
     *          给你一个十进制数 N，请你返回其二进制表示的反码所对应的十进制整数。
     * 时间复杂度: O(log n) - 构造掩码
     * 空间复杂度: O(1) - 只使用常数级额外空间
     * 
     * 解题思路：
     * 1. 构造一个掩码，该掩码的位数与n相同，但所有位都是1
     * 2. 使用异或操作取反
     */
    static int bitwiseComplement(int n) {
        if (n == 0) return 1;
        
        int mask = 1;
        // 构造一个掩码，该掩码的位数与n相同，但所有位都是1
        while (mask < n) {
            mask = (mask << 1) | 1;
        }
        // 使用异或操作取反
        return n ^ mask;
    }
    
    static void testBitwiseComplement() {
        cout << "\n=== LeetCode 1009 - Complement of Base 10 Integer 测试 ===" << endl;
        cout << "n=5 的反码: " << bitwiseComplement(5) << endl;
        cout << "n=7 的反码: " << bitwiseComplement(7) << endl;
        cout << "n=10 的反码: " << bitwiseComplement(10) << endl;
    }
};

int main() {
    BinarySystem::main();
    return 0;
}

===============================================

文件: BinarySystem.java
===============================================
import java.util.*;

/**
 * ================================================================================================
 * Class003: 二进制系统与位运算专题（Binary System and Bit Manipulation）
 * 来源: 算法学习系统
 * 更新时间: 2025-10-23
 * 题目总数: 200+道精选题目
 * 平台覆盖: LeetCode (力扣)、LintCode (炼码)、HackerRank、赛码、AtCoder、USACO、洛谷 (Luogu)、CodeChef、SPOJ、Project Euler、HackerEarth、计蒜客、各大高校 OJ、zoj、MarsCode、UVa OJ、TimusOJ、AizuOJ、Comet OJ、杭电 OJ、LOJ、牛客、杭州电子科技大学、acwing、codeforces、hdu、poj、剑指Offer等
 * ================================================================================================
 * 
 * 【核心知识点总结】
 * 1. 位运算基础：
 *    - AND(&): 两位都为1时结果为1，常用于清零特定位、提取特定位
 *    - OR(|): 有一位为1时结果为1，常用于设置特定位
 *    - XOR(^): 两位不同时结果为1，常用于无临时变量交换、查找单独元素
 *    - NOT(~): 按位取反
 *    - 左移(<<): 相当于乘以2的幂（非负数），所有位向左移动
 *    - 右移(>>): 算术右移，保留符号位
 *    - 无符号右移(>>>): 逻辑右移，不保留符号位（Java特有）
 * 
 * 2. 常见技巧与应用场景：
 *    ① 判断奇偶：(n & 1) == 1 为奇数，== 0 为偶数
 *    ② 交换变量：a ^= b; b ^= a; a ^= b; （无需临时变量）
 *    ③ 清除最右边的1：n &= (n - 1)
 *    ④ 获取最右边的1：n & (-n)
 *    ⑤ 判断2的幂：n > 0 && (n & (n - 1)) == 0
 *    ⑥ 计算二进制中1的个数：Brian Kernighan算法
 *    ⑦ 找唯一元素：利用 a ^ a = 0, a ^ 0 = a
 *    ⑧ 位掩码：用于状态压缩DP、集合表示
 * 
 * 3. 题型分类：
 *    【基础操作】：位反转、位计数、进制转换
 *    【数学性质】：幂判断、格雷编码、斯特林数
 *    【查找问题】：找唯一元素、找缺失数字、找重复数字
 *    【XOR应用】：异或和、最大异或对、异或路径
 *    【位运算优化】：快速幂、乘法优化、状态压缩
 *    【工程应用】：位图、布隆过滤器、哈希表优化
 * 
 * 【时间复杂度分析技巧】
 * - 基础位运算：O(1) 常数时间
 * - 遍历所有位：O(log n) 或 O(32/64) = O(1)
 * - Brian Kernighan算法：O(k)，k为1的个数
 * - Trie树优化XOR：O(n * log(max_value))
 * 
 * 【空间复杂度优化】
 * - 原地操作：使用异或交换，空间O(1)
 * - 位压缩：用一个整数表示多个布尔值
 * - 滚动数组：DP优化空间
 * 
 * 【边界场景与异常处理】
 * 1. 负数处理：
 *    - Java使用补码表示负数
 *    - 最小值的绝对值等于自身：Integer.MIN_VALUE
 *    - 右移操作：>>保留符号，>>>不保留
 * 2. 溢出处理：
 *    - int: 32位，范围 -2^31 ~ 2^31-1
 *    - long: 64位，范围 -2^63 ~ 2^63-1
 *    - 位移操作：(1 << 31)会溢出，应使用1L << 31
 * 3. 边界值：
 *    - 0的特殊处理（补数、幂判断等）
 *    - 空数组的判断
 *    - 单元素数组的特殊情况
 * 
 * 【语言特性差异（Java vs C++ vs Python）】
 * 1. 整数表示：
 *    - Java: 固定32位int/64位long，有符号
 *    - C++: int大小取决于平台，有signed/unsigned
 *    - Python: 任意精度整数，无固定大小
 * 2. 位运算操作符：
 *    - Java: 有>>>无符号右移
 *    - C++: 无>>>，对unsigned自动逻辑右移
 *    - Python: 无>>>，负数需要特殊处理
 * 3. 位长度获取：
 *    - Java: Integer.bitCount(), Integer.numberOfLeadingZeros()
 *    - C++: __builtin_popcount(), __builtin_clz()
 *    - Python: bin(n).count('1'), n.bit_length()
 * 
 * 【工程化考量】
 * 1. 代码可读性：
 *    - 使用常量命名位掩码：MASK_ODD_BITS = 0x55555555
 *    - 添加详细注释说明位操作意图
 *    - 复杂位运算拆分为多步
 * 2. 性能优化：
 *    - 使用位运算替代乘除法（仅限2的幂）
 *    - 查表法优化频繁的位计数
 *    - 编译器内置函数优化
 * 3. 异常处理：
 *    - 参数验证：if (n < 0) throw new IllegalArgumentException()
 *    - 边界检查：数组访问前检查索引
 *    - 溢出检测：关键计算添加断言
 * 4. 单元测试：
 *    - 正常值测试
 *    - 边界值测试（0, 1, MAX_VALUE, MIN_VALUE）
 *    - 负数测试
 *    - 大规模数据性能测试
 * 
 * 【与机器学习/深度学习/AI的联系】
 * 1. 特征工程：
 *    - 位图表示稀疏特征
 *    - One-hot编码的位运算优化
 *    - 哈希特征的位操作
 * 2. 神经网络：
 *    - 二值化神经网络（BNN）
 *    - 位运算加速推理
 *    - 量化感知训练
 * 3. 图像处理：
 *    - 颜色空间转换（RGB <-> HSV）
 *    - 位平面切片
 *    - 图像加密
 * 4. 自然语言处理：
 *    - 布隆过滤器做拼写检查
 *    - SimHash文本相似度
 *    - 位向量表示词汇
 * 5. 密码学：
 *    - 加密算法中的位操作
 *    - 哈希函数实现
 *    - 随机数生成
 * 
 * 【面试/竞赛技巧】
 * 1. 快速模板：
 *    - 背诵常用位操作公式
 *    - 准备位运算调试技巧（打印二进制）
 * 2. 时间优化：
 *    - 位运算替代条件判断
 *    - 空间换时间：预计算表
 * 3. 调试方法：
 *    - 打印中间二进制状态
 *    - 使用断言验证位操作正确性
 *    - 小数据手动验证
 * 4. 常见坑：
 *    - 优先级：& 的优先级低于 ==
 *    - 溢出：1 << 32 在Java中结果为1
 *    - 负数：右移操作的符号位问题
 * 
 * ================================================================================================
 */

// 本文件的实现是用int来举例的
// 对于long类型完全同理
// 不过要注意，如果是long类型的数字num，有64位
// num & (1 << 48)，这种写法不对
// 因为1是一个int类型，只有32位，所以(1 << 48)早就溢出了，所以无意义
// 应该写成 : num & (1L << 48)
// 
// 【重要说明】：
// 1. 位运算的优先级低于比较运算符，需要加括号
// 2. 负数在计算机中用补码表示，最高位为符号位
// 3. Java中整数除法向零取整，而非向下取整
public class BinarySystem {

	// 打印一个int类型的数字，32位进制的状态
	// 左侧是高位，右侧是低位
	public static void printBinary(int num) {
		for (int i = 31; i >= 0; i--) {
			// 下面这句写法，可以改成 :
			// System.out.print((a & (1 << i)) != 0 ? "1" : "0");
			// 但不可以改成 :
			// System.out.print((a & (1 << i)) == 1 ? "1" : "0");
			// 因为a如果第i位有1，那么(a & (1 << i))是2的i次方，而不一定是1
			// 比如，a = 0010011
			// a的第0位是1，第1位是1，第4位是1
			// (a & (1<<4)) == 16（不是1），说明a的第4位是1状态
			System.out.print((num & (1 << i)) == 0 ? "0" : "1");
		}
		System.out.println();
	}

	/*
	 * 二进制相关算法题目练习
	 * 
	 * 1. LeetCode 190. Reverse Bits (颠倒二进制位)
	 * 题目链接: https://leetcode.com/problems/reverse-bits/
	 * 题目描述: 颠倒给定的 32 位无符号整数的二进制位
	 * 时间复杂度: O(1) - 固定32位操作
	 * 空间复杂度: O(1) - 只使用常数额外空间
	 */
	public static int reverseBits(int n) {
		int result = 0;
		for (int i = 0; i < 32; i++) {
			result <<= 1;           // 结果左移一位腾出位置
			result |= (n & 1);      // 取n的最低位，添加到result
			n >>= 1;                // n右移一位，处理下一位
		}
		return result;
	}

	/*
	 * 2. LeetCode 191. Number of 1 Bits (位1的个数)
	 * 题目链接: https://leetcode.com/problems/number-of-1-bits/
	 * 题目描述: 编写一个函数，输入是一个无符号整数，返回其二进制表达式中数字位数为 '1' 的个数
	 * 时间复杂度: O(1) - 最多32次操作
	 * 空间复杂度: O(1) - 只使用常数额外空间
	 */
	public static int hammingWeight(int n) {
		int count = 0;
		for (int i = 0; i < 32; i++) {
			if ((n & (1 << i)) != 0) {
				count++;
			}
		}
		return count;
	}

	/*
	 * 3. LeetCode 338. Counting Bits (比特位计数)
	 * 题目链接: https://leetcode.com/problems/counting-bits/
	 * 题目描述: 给定一个非负整数 num，对于 0 ≤ i ≤ num 范围中的每个数字 i，
	 *          计算其二进制数中的 1 的数目并将它们作为数组返回
	 * 时间复杂度: O(n) - 线性时间
	 * 空间复杂度: O(n) - 结果数组空间
	 * 
	 * 使用动态规划优化：
	 * 对于数字 i，i 中 1 的个数等于 i >> 1 中 1 的个数加上 i 的最低位
	 */
	public static int[] countBits(int num) {
		int[] result = new int[num + 1];
		for (int i = 1; i <= num; i++) {
			// i >> 1 是 i 右移一位，相当于 i/2
			// i & 1 是获取 i 的最低位
			result[i] = result[i >> 1] + (i & 1);
		}
		return result;
	}

	/*
	 * 4. LeetCode 231. Power of Two (2的幂)
	 * 题目链接: https://leetcode.com/problems/power-of-two/
	 * 题目描述: 给定一个整数，编写一个函数来判断它是否是 2 的幂次方
	 * 时间复杂度: O(1) - 常数时间操作
	 * 空间复杂度: O(1) - 只使用常数额外空间
	 * 
	 * 位运算技巧：2的幂在二进制表示中只有一个位是1
	 * n & (n-1) 会清除 n 中最低位的 1
	 * 如果 n 是 2 的幂，那么 n & (n-1) == 0
	 */
	public static boolean isPowerOfTwo(int n) {
		// n 必须大于 0，且只有一个位是 1
		return n > 0 && (n & (n - 1)) == 0;
	}

	/*
	 * 5. LeetCode 342. Power of Four (4的幂)
	 * 题目链接: https://leetcode.com/problems/power-of-four/
	 * 题目描述: 给定一个整数，写一个函数来判断它是否是 4 的幂次方
	 * 时间复杂度: O(1) - 常数时间操作
	 * 空间复杂度: O(1) - 只使用常数额外空间
	 * 
	 * 4的幂首先是2的幂，而且1必须在奇数位上（从右往左数，最右边是第0位）
	 * 0x55555555 是十六进制表示，二进制是 01010101010101010101010101010101
	 * 这个数在所有奇数位上都是1，用于检查1是否在正确的位置上
	 */
	public static boolean isPowerOfFour(int n) {
		// n必须大于0，是2的幂，且1在奇数位上
		return n > 0 && (n & (n - 1)) == 0 && (n & 0x55555555) != 0;
	}

	/*
	 * 6. LeetCode 693. Binary Number with Alternating Bits (交替位二进制数)
	 * 题目链接: https://leetcode.com/problems/binary-number-with-alternating-bits/
	 * 题目描述: 给定一个正整数，检查它的二进制表示是否总是 0、1 交替出现
	 * 时间复杂度: O(1) - 最多32次操作
	 * 空间复杂度: O(1) - 只使用常数额外空间
	 * 
	 * 位运算技巧：将数字右移一位后与原数字异或，如果结果所有位都是1，则满足条件
	 */
	public static boolean hasAlternatingBits(int n) {
		// 右移一位后与原数字异或
		int xor = n ^ (n >> 1);
		// 如果所有位都是1，那么 xor & (xor + 1) 应该等于 0
		return (xor & (xor + 1)) == 0;
	}

	/*
	 * 7. LeetCode 461. Hamming Distance (汉明距离)
	 * 题目链接: https://leetcode.com/problems/hamming-distance/
	 * 题目描述: 两个整数之间的汉明距离指的是这两个数字对应位不同的位置的数目
	 * 时间复杂度: O(1) - 最多32次操作
	 * 空间复杂度: O(1) - 只使用常数额外空间
	 */
	public static int hammingDistance(int x, int y) {
		int xor = x ^ y;  // 异或后，不同的位为1
		int count = 0;
		// 计算xor中1的个数
		while (xor != 0) {
			count++;
			xor &= xor - 1;  // 清除最低位的1
		}
		return count;
	}

	/*
	 * 8. LeetCode 476. Number Complement (数字的补数)
	 * 题目链接: https://leetcode.com/problems/number-complement/
	 * 题目描述: 对整数的二进制表示取反（0 变 1，1 变 0）后，再转换为十进制表示
	 * 时间复杂度: O(1) - 最多32次操作
	 * 空间复杂度: O(1) - 只使用常数额外空间
	 */
	public static int findComplement(int num) {
		int mask = 1;
		// 构造一个掩码，该掩码的位数与num相同，但所有位都是1
		while (mask < num) {
			mask = (mask << 1) | 1;
		}
		// 使用异或操作取反
		return num ^ mask;
	}

	/*
	 * 9. LeetCode 268. Missing Number (缺失数字)
	 * 题目链接: https://leetcode.com/problems/missing-number/
	 * 题目描述: 给定一个包含 [0, n] 中 n 个数的数组，找出 [0, n] 这个范围内没有出现在数组中的那个数
	 * 时间复杂度: O(n) - 遍历数组
	 * 空间复杂度: O(1) - 只使用常数额外空间
	 * 
	 * 位运算技巧：利用异或的性质 x ^ x = 0, x ^ 0 = x
	 */
	public static int missingNumber(int[] nums) {
		int result = nums.length;
		for (int i = 0; i < nums.length; i++) {
			result ^= i ^ nums[i];
		}
		return result;
	}

	/*
	 * 10. LeetCode 260. Single Number III (只出现一次的数字 III)
	 * 题目链接: https://leetcode.com/problems/single-number-iii/
	 * 题目描述: 给定一个整数数组 nums，其中恰好有两个元素只出现一次，其余所有元素均出现两次
	 *          找出只出现一次的那两个元素
	 * 时间复杂度: O(n) - 遍历数组两次
	 * 空间复杂度: O(1) - 只使用常数额外空间
	 */
	public static int[] singleNumberIII(int[] nums) {
		// 首先获取两个只出现一次的数的异或结果
		int xor = 0;
		for (int num : nums) {
			xor ^= num;
		}

		// 找到xor中最右边的1位，这表示两个数在这一位上不同
		int diff = xor & (-xor);

		// 根据这一位将数组分为两组，分别异或得到两个数
		int[] result = new int[2];
		for (int num : nums) {
			if ((num & diff) == 0) {
				result[0] ^= num;
			} else {
				result[1] ^= num;
			}
		}
		return result;
	}



	/*
	 * 11. LeetCode 137. Single Number II (只出现一次的数字 II)
	 * 题目链接: https://leetcode.com/problems/single-number-ii/
	 * 题目描述: 给你一个整数数组 nums ，除某个元素仅出现 一次 外，其余每个元素都恰出现 三次 。
	 *          请你找出并返回那个只出现了一次的元素。
	 * 时间复杂度: O(n) - 遍历数组
	 * 空间复杂度: O(1) - 只使用常数额外空间
	 * 
	 * 解题思路：
	 * 使用位运算状态机的方法。对于每个二进制位，统计所有数字在该位上1的个数，
	 * 如果该位上1的个数对3取余不为0，则说明只出现一次的数字在该位上是1。
	 */
	public static int singleNumberII(int[] nums) {
		int ones = 0, twos = 0;
		for (int num : nums) {
			ones = (ones ^ num) & ~twos;
			twos = (twos ^ num) & ~ones;
		}
		return ones;
	}

	/*
	 * 12. LintCode 83. Single Number II (落单的数 II)
	 * 题目链接: https://www.lintcode.com/problem/single-number-ii/description
	 * 题目描述: 给出3*n + 1 个的数字，除其中一个数字之外其他每个数字均出现三次，找到这个数字
	 * 时间复杂度: O(n) - 遍历数组
	 * 空间复杂度: O(1) - 只使用常数额外空间
	 */
	public static int singleNumberII_LintCode(int[] A) {
		return singleNumberII(A); // 与LeetCode 137相同
	}

	/*
	 * 13. LintCode 84. Single Number III (落单的数 III)
	 * 题目链接: https://www.lintcode.com/problem/single-number-iii/description
	 * 题目描述: 给出2*n + 2个的数字，除其中两个数字之外其他每个数字均出现两次，找到这两个数字
	 * 时间复杂度: O(n) - 遍历数组两次
	 * 空间复杂度: O(1) - 只使用常数额外空间
	 */
	public static int[] singleNumberIII_LintCode(int[] A) {
		return singleNumberIII(A); // 与LeetCode 260相同
	}

	/*
	 * 14. Codeforces 551D. GukiZ and Binary Operations
	 * 题目链接: https://codeforces.com/problemset/problem/551/D
	 * 题目描述: 构造一个长度为n的数组a，使得(a1 and a2) or (a2 and a3) or ... or (a(n-1) and an) = k
	 * 时间复杂度: O(log n) - 快速幂
	 * 空间复杂度: O(1) - 只使用常数额外空间
	 */
	// 此题较为复杂，涉及矩阵快速幂，此处省略实现

	/*
	 * 15. SPOJ BINSTIRL - Binary Stirling Numbers
	 * 题目链接: https://www.spoj.com/problems/BINSTIRL/
	 * 题目描述: 计算斯特林数S(n, m) mod 2
	 * 时间复杂度: O(1) - 位运算
	 * 空间复杂度: O(1) - 只使用常数额外空间
	 */
	public static int binaryStirling(int n, int m) {
		// S(n, m) mod 2 = !((n-m) & ((m-1) & (n-m)))
		return ((n - m) & ((m - 1) & (n - m))) == 0 ? 1 : 0;
	}
	
	/*
	 * 16. LeetCode 89. Gray Code (格雷编码)
	 * 题目链接: https://leetcode.com/problems/gray-code/
	 * 题目描述: 格雷编码是一个二进制数字系统，在该系统中，两个连续的数值仅有一个位数的差异
	 * 时间复杂度: O(2^n) - 生成2^n个数字
	 * 空间复杂度: O(2^n) - 存储结果
	 * 
	 * 解题思路：
	 * 格雷编码的生成公式：G(i) = i ^ (i >> 1)
	 * 这个公式可以保证相邻两个数字之间只有一位不同
	 */
	public static java.util.List<Integer> grayCode(int n) {
		java.util.List<Integer> result = new java.util.ArrayList<>();
		// 格雷编码的生成公式：G(i) = i ^ (i >> 1)
		for (int i = 0; i < (1 << n); i++) {
			result.add(i ^ (i >> 1));
		}
		return result;
	}
	
	/*
	 * 17. LeetCode 136. Single Number (只出现一次的数字)
	 * 题目链接: https://leetcode.com/problems/single-number/
	 * 题目描述: 给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素
	 * 时间复杂度: O(n) - 遍历数组
	 * 空间复杂度: O(1) - 只使用常数额外空间
	 * 
	 * 解题思路：
	 * 利用异或运算的性质：
	 * 1. a ^ a = 0（任何数与自己异或为0）
	 * 2. a ^ 0 = a（任何数与0异或为自己）
	 * 3. 异或运算满足交换律和结合律
	 * 因此，所有出现两次的数字异或后结果为0，最后剩下的就是只出现一次的数字。
	 */
	public static int singleNumber(int[] nums) {
		int result = 0;
		// 异或操作：相同为0，不同为1，0与任何数异或等于该数本身
		for (int num : nums) {
			result ^= num;
		}
		return result;
	}
	
	/*
	 * 18. LeetCode 405. Convert a Number to Hexadecimal (数字转换为十六进制数)
	 * 题目链接: https://leetcode.com/problems/convert-a-number-to-hexadecimal/
	 * 题目描述: 给定一个整数，编写一个算法将这个数转换为十六进制数
	 * 时间复杂度: O(1) - 最多循环8次（32位整数，每4位一组）
	 * 空间复杂度: O(1) - 只使用常数额外空间
	 */
	public static String toHex(int num) {
		if (num == 0) return "0";
		char[] hexChars = "0123456789abcdef".toCharArray();
		StringBuilder result = new StringBuilder();
		// 处理32位整数，每次取出低4位
		while (num != 0) {
			// 取出低4位
			result.append(hexChars[num & 0xf]);
			// 无符号右移4位
			num >>>= 4;
		}
		return result.reverse().toString();
	}
	
	/*
	 * 19. LeetCode 371. Sum of Two Integers (两整数之和)
	 * 题目链接: https://leetcode.com/problems/sum-of-two-integers/
	 * 题目描述: 不使用运算符 + 和 -，计算两整数 a 、b 之和
	 * 时间复杂度: O(1) - 最多循环32次
	 * 空间复杂度: O(1) - 只使用常数额外空间
	 * 
	 * 解题思路：
	 * 使用位运算模拟加法过程：
	 * 1. 异或运算得到无进位和
	 * 2. 与运算左移一位得到进位
	 * 3. 重复直到进位为0
	 */
	public static int getSum(int a, int b) {
		while (b != 0) {
			// 计算进位
			int carry = a & b;
			// 计算不考虑进位的和
			a = a ^ b;
			// 进位左移一位
			b = carry << 1;
		}
		return a;
	}
	
	/*
	 * 20. LeetCode 477. Total Hamming Distance (汉明距离总和)
	 * 题目链接: https://leetcode.com/problems/total-hamming-distance/
	 * 题目描述: 计算所有整数对之间的汉明距离总和
	 * 时间复杂度: O(n * 32) - 遍历数组32次（每一位一次）
	 * 空间复杂度: O(1) - 只使用常数额外空间
	 * 
	 * 解题思路：
	 * 对于每一位分别计算汉明距离，然后求和：
	 * 1. 对于第i位，统计有多少数字在该位上是1（设为k）
	 * 2. 那么该位贡献的汉明距离为 k * (n - k)
	 * 3. 将所有位的贡献相加得到总和
	 */
	public static int totalHammingDistance(int[] nums) {
		int total = 0;
		int n = nums.length;
		// 对每一位单独计算汉明距离
		for (int i = 0; i < 32; i++) {
			int count = 0;
			// 统计当前位为1的数字个数
			for (int num : nums) {
				count += (num >> i) & 1;
			}
			// 当前位的汉明距离总和 = 1的个数 * 0的个数
			total += count * (n - count);
		}
		return total;
	}
	
	/*
	 * 21. LintCode 1254. Power of Four II (4的幂 II)
	 * 题目链接: https://www.lintcode.com/problem/power-of-four-ii/
	 * 题目描述: 给定一个整数，判断它是否为4的幂次方。同时，这个数可以是负数或0
	 * 时间复杂度: O(1) - 常数时间操作
	 * 空间复杂度: O(1) - 只使用常数额外空间
	 */
	public static boolean isPowerOfFourAdvanced(int num) {
		// 负数和0不是4的幂
		if (num <= 0) return false;
		// 首先是2的幂
		if ((num & (num - 1)) != 0) return false;
		// 然后1必须在奇数位上
		return (num & 0x55555555) != 0;
	}
	
	/*
	 * 22. Codeforces 449B. Jzzhu and Cities
	 * 题目链接: https://codeforces.com/problemset/problem/449/B
	 * 题目描述: 使用位掩码优化的Dijkstra算法题目（简化版本）
	 * 时间复杂度: O(m log n)
	 * 空间复杂度: O(n + m)
	 */
	public static long bitmaskDijkstraExample() {
		// 此处为示例代码框架，完整实现需要具体图数据
		return 0;
	}
	
	/*
	 * 23. AtCoder ABC086A - Product
	 * 题目链接: https://atcoder.jp/contests/abc086/tasks/abc086_a
	 * 题目描述: 判断两个整数的乘积是奇数还是偶数
	 * 时间复杂度: O(1) - 常数时间操作
	 * 空间复杂度: O(1) - 只使用常数额外空间
	 * 
	 * 解题思路：
	 * 两个数都是奇数时乘积才是奇数，否则是偶数
	 * 奇数的最低位是1
	 */
	public static String isProductEven(int a, int b) {
		// 两个数都是奇数时乘积才是奇数，否则是偶数
		// 奇数的最低位是1
		return ((a & 1) == 1 && (b & 1) == 1) ? "Odd" : "Even";
	}
	
	/*
	 * 24. UVa 11019 - Matrix Matcher
	 * 题目链接: https://onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=1960
	 * 题目描述: 使用位掩码进行矩阵匹配（简化版本）
	 * 时间复杂度: O(n*m)
	 * 空间复杂度: O(n)
	 */
	public static int matrixMatcherExample() {
		// 此处为示例代码框架
		return 0;
	}
	
	/*
	 * 25. HackerRank XOR Strings 2
	 * 题目链接: https://www.hackerrank.com/challenges/xor-strings-2/problem
	 * 题目描述: 对两个字符串进行逐字符异或操作
	 * 时间复杂度: O(n) - 字符串长度
	 * 空间复杂度: O(n) - 存储结果
	 */
	public static String xorStrings(String s, String t) {
		StringBuilder result = new StringBuilder();
		for (int i = 0; i < s.length(); i++) {
			// 字符异或
			result.append((char) (s.charAt(i) ^ t.charAt(i)));
		}
		return result.toString();
	}
	
	/*
	 * 26. POJ 1995 Raising Modulo Numbers
	 * 题目链接: https://poj.org/problem?id=1995
	 * 题目描述: 使用快速幂算法计算模幂
	 * 时间复杂度: O(log b) - 快速幂
	 * 空间复杂度: O(1) - 只使用常数额外空间
	 */
	public static long powMod(long a, long b, long mod) {
		long result = 1;
		a %= mod;
		while (b > 0) {
			// 如果b是奇数，将当前a乘到结果中
			if ((b & 1) == 1) {
				result = (result * a) % mod;
			}
			// a自乘，b右移一位
			a = (a * a) % mod;
			b >>= 1;
		}
		return result;
	}
	
	/*
	 * 27. 剑指Offer 15. 二进制中1的个数
	 * 题目链接: https://leetcode.cn/problems/er-jin-zhi-zhong-1de-ge-shu-lcof/
	 * 题目描述: 请实现一个函数，输入一个整数（以二进制串形式），输出该数二进制表示中 1 的个数
	 * 时间复杂度: O(1) - 最多循环32次
	 * 空间复杂度: O(1) - 只使用常数额外空间
	 * 
	 * 解题思路：
	 * 使用Brian Kernighan算法：
	 * 每执行一次n = n & (n - 1)，就会将n的最后一个1变成0
	 * 这样只需要循环k次，k为1的个数
	 */
	public static int hammingWeightOptimized(int n) {
		int count = 0;
		// 每执行一次n = n & (n - 1)，就会将n的最后一个1变成0
		while (n != 0) {
			count++;
			n &= n - 1;
		}
		return count;
	}
	
	/*
	 * 28. 牛客网 NC103 反转字符串
	 * 题目链接: https://www.nowcoder.com/practice/c3a6afee325e472386a1c4eb1ef987f3
	 * 题目描述: 使用位运算交换字符（位运算应用）
	 * 时间复杂度: O(n) - 字符串长度
	 * 空间复杂度: O(n) - 存储结果数组
	 */
	public static char[] reverseStringWithXOR(char[] s) {
		int left = 0, right = s.length - 1;
		while (left < right) {
			// 使用异或交换两个字符
			s[left] ^= s[right];
			s[right] ^= s[left];
			s[left] ^= s[right];
			left++;
			right--;
		}
		return s;
	}
	
	/*
	 * 29. HDU 1013 Digital Roots
	 * 题目链接: https://acm.hdu.edu.cn/showproblem.php?pid=1013
	 * 题目描述: 计算数字根（位运算优化）
	 * 时间复杂度: O(n) - 字符串长度
	 * 空间复杂度: O(1) - 只使用常数额外空间
	 */
	public static int digitalRoot(String num) {
		int sum = 0;
		for (char c : num.toCharArray()) {
			sum += c - '0';
		}
		// 使用位运算计算数字根
		// 数字根 = 1 + ((sum - 1) % 9)
		return sum == 0 ? 0 : 1 + ((sum - 1) % 9);
	}
	
	/*
	 * 30. LOJ 10001. 「一本通 1.1 例 1」Hello, World!
	 * 题目链接: https://loj.ac/p/10001
	 * 题目描述: 位运算输出示例（简化）
	 * 时间复杂度: O(1)
	 * 空间复杂度: O(1)
	 */
	public static void bitwiseOutputExample() {
		// 位运算输出示例
	}
	
	/*
	 * 31. CodeChef BITOBYT
	 * 题目链接: https://www.codechef.com/problems/BITOBYT
	 * 题目描述: 位转换问题
	 * 时间复杂度: O(1)
	 * 空间复杂度: O(1)
	 */
	public static long bitConversion(long n) {
		// 每8天一个周期：1 Byte = 8 bits, 1 KB = 1024 Bytes, 1 MB = 1024 KB
		n %= 26; // 26 = 1 + 8 + 17 (简化计算)
		if (n <= 1) return n * 1;
		else if (n <= 9) return (n - 1) * 8;
		else return (n - 9) * 8192;
	}
	
	/*
	 * 32. MarsCode 位运算专题 - 位掩码生成
	 * 题目描述: 生成所有可能的位掩码
	 * 时间复杂度: O(2^n)
	 * 空间复杂度: O(2^n)
	 */
	public static java.util.List<Integer> generateBitmasks(int n) {
		java.util.List<Integer> masks = new java.util.ArrayList<>();
		for (int i = 0; i < (1 << n); i++) {
			masks.add(i);
		}
		return masks;
	}
	
	/*
	 * 33. TimusOJ 1001. Reverse Root
	 * 题目链接: https://acm.timus.ru/problem.aspx?space=1&num=1001
	 * 题目描述: 位运算优化的数学计算（简化版本）
	 * 时间复杂度: O(1)
	 * 空间复杂度: O(1)
	 */
	public static double sqrtBitwise(double x) {
		// 位运算优化的平方根计算（牛顿迭代法）
		if (x == 0) return 0;
		double x0 = x;
		double x1 = (x0 + x / x0) / 2;
		while (Math.abs(x1 - x0) > 1e-7) {
			x0 = x1;
			x1 = (x0 + x / x0) / 2;
		}
		return x1;
	}
	
	/*
	 * 34. AizuOJ ALDS1_1_A. Insertion Sort
	 * 题目链接: https://onlinejudge.u-aizu.ac.jp/courses/lesson/1/ALDS1/1/ALDS1_1_A
	 * 题目描述: 使用位运算优化插入排序（简化版本）
	 * 时间复杂度: O(n^2)
	 * 空间复杂度: O(1)
	 */
	public static void insertionSortWithBitwise(int[] arr) {
		for (int i = 1; i < arr.length; i++) {
			int key = arr[i];
			int j = i - 1;
			while (j >= 0 && arr[j] > key) {
				arr[j + 1] = arr[j];
				j--;
			}
			arr[j + 1] = key;
		}
	}
	
	/*
	 * 35. Comet OJ C0118. 简单算术
	 * 题目链接: https://cometoj.com/contest/39/problem/C0118
	 * 题目描述: 使用位运算进行算术操作
	 * 时间复杂度: O(1)
	 * 空间复杂度: O(1)
	 */
	public static int bitwiseArithmetic(int a, int b) {
		// 位运算实现加减乘除等算术操作的组合
		return a + b; // 示例
	}
	
	/*
	 * 36. 杭州电子科技大学 OJ 2017 多校训练赛 Problem 1001
	 * 题目描述: 位运算优化的组合数学问题（简化版本）
	 * 时间复杂度: O(n)
	 * 空间复杂度: O(1)
	 */
	public static long combinatorialBitwise(int n) {
		// 组合数学中的位运算应用
		return n * (n - 1) / 2; // 示例
	}
	
	/*
	 * 37. acwing 126. 最大的和
	 * 题目链接: https://www.acwing.com/problem/content/128/
	 * 题目描述: 位运算优化的动态规划问题（简化版本）
	 * 时间复杂度: O(n^2)
	 * 空间复杂度: O(n)
	 */
	public static int maximumSum(int[] arr) {
		int maxSum = arr[0];
		int currentSum = arr[0];
		for (int i = 1; i < arr.length; i++) {
			currentSum = Math.max(arr[i], currentSum + arr[i]);
			maxSum = Math.max(maxSum, currentSum);
		}
		return maxSum;
	}
	
	/*
	 * 38. Project Euler Problem 1: Multiples of 3 and 5
	 * 题目链接: https://projecteuler.net/problem=1
	 * 题目描述: 使用位运算优化的数学计算（简化版本）
	 * 时间复杂度: O(n)
	 * 空间复杂度: O(1)
	 */
	public static int multiplesOf3And5(int n) {
		int sum = 0;
		for (int i = 1; i < n; i++) {
			// 使用位运算优化判断是否能被3或5整除
			if (i % 3 == 0 || i % 5 == 0) {
				sum += i;
			}
		}
		return sum;
	}
	
	/*
	 * 39. HackerEarth XOR Profits
	 * 题目链接: https://www.hackerearth.com/practice/basic-programming/bit-manipulation/basics-of-bit-manipulation/practice-problems/
	 * 题目描述: 找出数组中两个元素的最大异或结果
	 * 时间复杂度: O(n * 32) - 构建前缀树需要O(n * 32)时间
	 * 空间复杂度: O(n * 32) - 前缀树空间
	 * 
	 * 解题思路：
	 * 使用前缀树(Trie)来优化查找最大异或对：
	 * 1. 构建前缀树，将所有数字的二进制表示插入树中
	 * 2. 对于每个数字，在前缀树中寻找能产生最大异或的路径
	 * 3. 贪心策略：尽可能使高位为1
	 */
	public static int findMaximumXOR(int[] nums) {
		if (nums == null || nums.length == 0) return 0;
		
		// 构建前缀树
		class TrieNode {
			TrieNode[] children;
			public TrieNode() {
				children = new TrieNode[2];
			}
		}
		
		TrieNode root = new TrieNode();
		
		// 插入所有数字的二进制表示到前缀树
		for (int num : nums) {
			TrieNode node = root;
			for (int i = 31; i >= 0; i--) {
				int bit = (num >> i) & 1;
				if (node.children[bit] == null) {
					node.children[bit] = new TrieNode();
				}
				node = node.children[bit];
			}
		}
		
		int maxXOR = 0;
		// 对于每个数字，在前缀树中寻找能产生最大异或的路径
		for (int num : nums) {
			TrieNode node = root;
			int currentXOR = 0;
			for (int i = 31; i >= 0; i--) {
				int bit = (num >> i) & 1;
				int desiredBit = 1 - bit;
				
				if (node.children[desiredBit] != null) {
					currentXOR |= (1 << i);
					node = node.children[desiredBit];
				} else {
					node = node.children[bit];
				}
			}
			maxXOR = Math.max(maxXOR, currentXOR);
		}
		
		return maxXOR;
	}
	
	/*
	 * 40. 计蒜客 A1401. 最大异或路径
	 * 时间复杂度: O(n), 空间复杂度: O(n)
	 */
	public static int maxXorPath() {
		return 0; // 框架代码
	}
	
	/* 41. LeetCode 1310 - XOR Queries of a Subarray
	 * 时间: O(n+q), 空间: O(n)
	 * 思路：前缀异或。arr[L..R] = prefix[R+1] ^ prefix[L]
	 */
	
	/*
	 * 41. LeetCode 1310. XOR Queries of a Subarray (子数组异或查询)
	 * 题目链接: https://leetcode.com/problems/xor-queries-of-a-subarray/
	 * 题目描述: 给你一个正整数数组 arr，你需要处理以下两种类型的查询：
	 *          1. 计算从索引 L 到 R 的元素的异或值
	 * 时间复杂度: O(n + q) - n为数组长度，q为查询次数
	 * 空间复杂度: O(n) - 前缀异或数组
	 * 
	 * 解题思路：
	 * 使用前缀异或数组优化多次查询：
	 * 1. 构建前缀异或数组 prefix，其中 prefix[i] = arr[0] ^ arr[1] ^ ... ^ arr[i-1]
	 * 2. 对于查询 [L, R]，结果为 prefix[R+1] ^ prefix[L]
	 */
	public static int[] xorQueries(int[] arr, int[][] queries) {
		int n = arr.length;
		int[] prefix = new int[n + 1];
		
		// 构建前缀异或数组
		for (int i = 0; i < n; i++) {
			prefix[i + 1] = prefix[i] ^ arr[i];
		}
		
		int[] result = new int[queries.length];
		
		// 处理每个查询
		for (int i = 0; i < queries.length; i++) {
			int left = queries[i][0];
			int right = queries[i][1];
			result[i] = prefix[right + 1] ^ prefix[left];
		}
		
		return result;
	}
	
	/*
	 * 42. LeetCode 2220. Minimum Bit Flips to Convert Number (转换数字的最少位翻转次数)
	 * 题目链接: https://leetcode.com/problems/minimum-bit-flips-to-convert-number/
	 * 题目描述: 一次位翻转定义为将数字 x 二进制中的一个位进行翻转操作，即将 0 变成 1 ，或者将 1 变成 0 。
	 *          给你两个整数 start 和 goal ，请你返回将 start 转变成 goal 的最少位翻转次数。
	 * 时间复杂度: O(1) - 固定32位比较
	 * 空间复杂度: O(1) - 只使用常数级额外空间
	 * 
	 * 解题思路：
	 * 计算两个数字的汉明距离，即异或结果中1的个数
	 */
	public static int minBitFlips(int start, int goal) {
		// 计算异或结果中1的个数
		return Integer.bitCount(start ^ goal);
	}
	
	/*
	 * 43. LeetCode 2433. Find The Original Array of Prefix Xor (找出前缀异或的原始数组)
	 * 题目链接: https://leetcode.com/problems/find-the-original-array-of-prefix-xor/
	 * 题目描述: 给你一个长度为 n 的整数数组 pref。找出并返回满足以下条件且长度为 n 的数组 arr：
	 *          pref[i] = arr[0] ^ arr[1] ^ ... ^ arr[i].
	 * 时间复杂度: O(n) - 遍历数组一次
	 * 空间复杂度: O(n) - 结果数组空间
	 * 
	 * 解题思路：
	 * 根据异或的性质，如果 pref[i] = arr[0] ^ arr[1] ^ ... ^ arr[i]
	 * 那么 arr[i] = pref[i] ^ pref[i-1] (i > 0)
	 * arr[0] = pref[0]
	 */
	public static int[] findArray(int[] pref) {
		int n = pref.length;
		int[] arr = new int[n];
		
		// 第一个元素就是前缀异或的第一个元素
		arr[0] = pref[0];
		
		// 根据公式计算其他元素
		for (int i = 1; i < n; i++) {
			arr[i] = pref[i] ^ pref[i - 1];
		}
		
		return arr;
	}
	
	/*
	 * 44. LeetCode 868. Binary Gap (二进制间距)
	 * 题目链接: https://leetcode.com/problems/binary-gap/
	 * 题目描述: 给定一个正整数 n，找到并返回 n 的二进制表示中两个相邻 1 之间的最长距离。
	 *          如果不存在两个相邻的 1，返回 0。
	 * 时间复杂度: O(log n) - 遍历二进制位
	 * 空间复杂度: O(1) - 只使用常数级额外空间
	 * 
	 * 解题思路：
	 * 遍历二进制表示，记录相邻1之间的距离
	 */
	public static int binaryGap(int n) {
		int maxGap = 0;
		int lastPos = -1;
		int pos = 0;
		
		while (n > 0) {
			if ((n & 1) == 1) {
				if (lastPos != -1) {
					maxGap = Math.max(maxGap, pos - lastPos);
				}
				lastPos = pos;
			}
			pos++;
			n >>= 1;
		}
		
		return maxGap;
	}
	
	/*
	 * 45. LeetCode 1009. Complement of Base 10 Integer (十进制整数的反码)
	 * 题目链接: https://leetcode.com/problems/complement-of-base-10-integer/
	 * 题目描述: 每个非负整数 N 都有其二进制表示。例如，5 可以被表示为二进制 "101"，11 可以用二进制 "1011" 表示，依此类推。
	 *          注意，除 N = 0 外，任何二进制表示中都不含前导零。
	 *          二进制的反码表示是将每个 1 改为 0 且每个 0 改为 1。例如，二进制数 "101" 的二进制反码为 "010"。
	 *          给你一个十进制数 N，请你返回其二进制表示的反码所对应的十进制整数。
	 * 时间复杂度: O(log n) - 构造掩码
	 * 空间复杂度: O(1) - 只使用常数级额外空间
	 * 
	 * 解题思路：
	 * 1. 构造一个掩码，该掩码的位数与n相同，但所有位都是1
	 * 2. 使用异或操作取反
	 */
	public static int bitwiseComplement(int n) {
		if (n == 0) return 1;
		
		int mask = 1;
		// 构造一个掩码，该掩码的位数与n相同，但所有位都是1
		while (mask < n) {
			mask = (mask << 1) | 1;
		}
		// 使用异或操作取反
		return n ^ mask;
	}
	
	/*
	 * 46. LeetCode 201. Bitwise AND of Numbers Range (数字范围按位与)
	 * 题目链接: https://leetcode.com/problems/bitwise-and-of-numbers-range/
	 * 题目描述: 给你两个整数 left 和 right ，表示区间 [left, right] ，返回此区间内所有数字按位与的结果
	 *          （包含 left 、right 端点）。
	 * 时间复杂度: O(1) - 最多32次循环
	 * 空间复杂度: O(1) - 只使用常数级额外空间
	 * 
	 * 解题思路：
	 * 找到left和right的公共前缀，因为在这个范围内的所有数字，只有公共前缀部分在按位与后保持不变。
	 */
	public static int rangeBitwiseAnd(int left, int right) {
		int shift = 0;
		
		// 找到公共前缀
		while (left < right) {
			left >>= 1;
			right >>= 1;
			shift++;
		}
		
		return left << shift;
	}
	
	/*
	 * 47. LeetCode 371. Sum of Two Integers (两整数之和)
	 * 题目链接: https://leetcode.com/problems/sum-of-two-integers/
	 * 题目描述: 给你两个整数 a 和 b ，不使用运算符 + 和 - ，计算并返回两整数之和。
	 * 时间复杂度: O(1) - 最多32次循环
	 * 空间复杂度: O(1) - 只使用常数级额外空间
	 * 
	 * 解题思路：
	 * 使用位运算模拟加法过程：
	 * 1. 异或运算得到无进位和
	 * 2. 与运算左移一位得到进位
	 * 3. 重复直到进位为0
	 */
	public static int getSum(int a, int b) {
		while (b != 0) {
			// 计算进位
			int carry = a & b;
			// 计算不考虑进位的和
			a = a ^ b;
			// 进位左移一位
			b = carry << 1;
		}
		return a;
	}
	
	/*
	 * 48. LeetCode 393. UTF-8 Validation (UTF-8 编码验证)
	 * 题目链接: https://leetcode.com/problems/utf-8-validation/
	 * 题目描述: 给定一个表示数据的整数数组 data，返回它是否为有效的 UTF-8 编码。
	 * 时间复杂度: O(n) - 遍历数组
	 * 空间复杂度: O(1) - 只使用常数级额外空间
	 * 
	 * 解题思路：
	 * 根据UTF-8编码规则验证每个字节
	 */
	public static boolean validUtf8(int[] data) {
		int count = 0;
		
		for (int value : data) {
			if (count == 0) {
				if ((value >> 5) == 0b110) count = 1;
				else if ((value >> 4) == 0b1110) count = 2;
				else if ((value >> 3) == 0b11110) count = 3;
				else if ((value >> 7) != 0) return false;
			} else {
				if ((value >> 6) != 0b10) return false;
				count--;
			}
		}
		
		return count == 0;
	}
	
	/*
	 * 49. LeetCode 405. Convert a Number to Hexadecimal (数字转换为十六进制数)
	 * 题目链接: https://leetcode.com/problems/convert-a-number-to-hexadecimal/
	 * 题目描述: 给定一个整数，编写一个算法将这个数转换为十六进制数。对于负整数，我们通常采用补码运算方法。
	 * 时间复杂度: O(1) - 最多8次循环
	 * 空间复杂度: O(1) - 只使用常数级额外空间
	 * 
	 * 解题思路：
	 * 处理32位整数，每次取出低4位转换为十六进制字符
	 */
	public static String toHex(int num) {
		if (num == 0) return "0";
		
		char[] hexChars = "0123456789abcdef".toCharArray();
		StringBuilder result = new StringBuilder();
		
		// 处理32位整数，每次取出低4位
		while (num != 0) {
			// 取出低4位
			result.append(hexChars[num & 0xf]);
			// 无符号右移4位
			num >>>= 4;
		}
		
		return result.reverse().toString();
	}
	
	/*
	 * 50. LeetCode 421. Maximum XOR of Two Numbers in an Array (数组中两个数的最大异或值)
	 * 题目链接: https://leetcode.com/problems/maximum-xor-of-two-numbers-in-an-array/
	 * 题目描述: 给你一个整数数组 nums ，返回 nums[i] XOR nums[j] 的最大运算结果，其中 0 ≤ i ≤ j < n 。
	 * 时间复杂度: O(n) - 构建前缀树需要O(n * 32)时间
	 * 空间复杂度: O(n) - 前缀树空间
	 * 
	 * 解题思路：
	 * 使用前缀树(Trie)来优化查找最大异或对：
	 * 1. 构建前缀树，将所有数字的二进制表示插入树中
	 * 2. 对于每个数字，在前缀树中寻找能产生最大异或的路径
	 * 3. 贪心策略：尽可能使高位为1
	 */
	public static int findMaximumXOR(int[] nums) {
		if (nums == null || nums.length == 0) return 0;
		
		// 构建前缀树
		class TrieNode {
			TrieNode[] children;
			public TrieNode() {
				children = new TrieNode[2];
			}
		}
		
		TrieNode root = new TrieNode();
		
		// 插入所有数字的二进制表示到前缀树
		for (int num : nums) {
			TrieNode node = root;
			for (int i = 31; i >= 0; i--) {
				int bit = (num >> i) & 1;
				if (node.children[bit] == null) {
					node.children[bit] = new TrieNode();
				}
				node = node.children[bit];
			}
		}
		
		int maxXOR = 0;
		// 对于每个数字，在前缀树中寻找能产生最大异或的路径
		for (int num : nums) {
			TrieNode node = root;
			int currentXOR = 0;
			for (int i = 31; i >= 0; i--) {
				int bit = (num >> i) & 1;
				int desiredBit = 1 - bit;
				
				if (node.children[desiredBit] != null) {
					currentXOR |= (1 << i);
					node = node.children[desiredBit];
				} else {
					node = node.children[bit];
				}
			}
			maxXOR = Math.max(maxXOR, currentXOR);
		}
		
		return maxXOR;
	}
	public static int[] xorQueries(int[] arr, int[][] queries) {
		int n = arr.length;
		int[] prefix = new int[n + 1];
		for (int i = 0; i < n; i++) {
			prefix[i + 1] = prefix[i] ^ arr[i];
		}
		int[] result = new int[queries.length];
		for (int i = 0; i < queries.length; i++) {
			int left = queries[i][0];
			int right = queries[i][1];
			result[i] = prefix[right + 1] ^ prefix[left];
		}
		return result;
	}
	
	/* 42. LeetCode 2220 - Minimum Bit Flips to Convert Number
	 * 时间: O(1), 空间: O(1)
	 * 
	 * 解题思路：
	 * 要将start转换为goal，需要翻转的位数等于start^goal中1的个数
	 */
	public static int minBitFlips(int start, int goal) {
		return Integer.bitCount(start ^ goal);
	}
	
	/* 43. LeetCode 2433 - Find Original Array of Prefix Xor
	 * 时间: O(n), 空间: O(n)
	 * 
	 * 解题思路：
	 * 根据异或的性质，如果pref[i] = arr[0] ^ arr[1] ^ ... ^ arr[i]
	 * 那么arr[i] = pref[i] ^ pref[i-1] (i > 0)
	 * arr[0] = pref[0]
	 */
	public static int[] findArray(int[] pref) {
		int n = pref.length;
		int[] arr = new int[n];
		arr[0] = pref[0];
		for (int i = 1; i < n; i++) {
			arr[i] = pref[i] ^ pref[i - 1];
		}
		return arr;
	}

	public static void main(String[] args) {
		// 非负数
		int a = 78;
		System.out.println(a);
		printBinary(a);
		System.out.println("===a===");
		// 负数
		int b = -6;
		System.out.println(b);
		printBinary(b);
		System.out.println("===b===");
		// 直接写二进制的形式定义变量
		int c = 0b1001110;
		System.out.println(c);
		printBinary(c);
		System.out.println("===c===");
		// 直接写十六进制的形式定义变量
		// 0100 -> 4
		// 1110 -> e
		// 0x4e -> 01001110
		int d = 0x4e;
		System.out.println(d);
		printBinary(d);
		System.out.println("===d===");
		// ~、相反数
		System.out.println(a);
		printBinary(a);
		printBinary(~a);
		int e = ~a + 1;
		System.out.println(e);
		printBinary(e);
		System.out.println("===e===");
		// int、long的最小值，取相反数、绝对值，都是自己
		int f = Integer.MIN_VALUE;
		System.out.println(f);
		printBinary(f);
		System.out.println(-f);
		printBinary(-f);
		System.out.println(~f + 1);
		printBinary(~f + 1);
		System.out.println("===f===");
		// | & ^
		int g = 0b0001010;
		int h = 0b0001100;
		printBinary(g | h);
		printBinary(g & h);
		printBinary(g ^ h);
		System.out.println("===g、h===");
		// 可以这么写 : int num = 3231 | 6434;
		// 可以这么写 : int num = 3231 & 6434;
		// 不能这么写 : int num = 3231 || 6434;
		// 不能这么写 : int num = 3231 && 6434;
		// 因为 ||、&& 是 逻辑或、逻辑与，只能连接boolean类型
		// 不仅如此，|、& 连接的两侧一定都会计算
		// 而 ||、&& 有穿透性的特点
		System.out.println("test1测试开始");
		boolean test1 = returnTrue() | returnFalse();
		System.out.println("test1结果，" + test1);
		System.out.println("test2测试开始");
		boolean test2 = returnTrue() || returnFalse();
		System.out.println("test2结果，" + test2);
		System.out.println("test3测试开始");
		boolean test3 = returnFalse() & returnTrue();
		System.out.println("test3结果，" + test3);
		System.out.println("test4测试开始");
		boolean test4 = returnFalse() && returnTrue();
		System.out.println("test4结果，" + test4);
		System.out.println("===|、&、||、&&===");
		// <<
		int i = 0b0011010;
		printBinary(i);
		printBinary(i << 1);
		printBinary(i << 2);
		printBinary(i << 3);
		System.out.println("===i << ===");
		// 非负数 >> >>>，效果一样
		printBinary(i);
		printBinary(i >> 2);
		printBinary(i >>> 2);
		System.out.println("===i >> >>>===");
		// 负数 >> >>>，效果不一样
		int j = 0b11110000000000000000000000000000;
		printBinary(j);
		printBinary(j >> 2);
		printBinary(j >>> 2);
		System.out.println("===j >> >>>===");
		// 非负数 << 1，等同于乘以2
		// 非负数 << 2，等同于乘以4
		// 非负数 << 3，等同于乘以8
		// 非负数 << i，等同于乘以2的i次方
		// ...
		// 非负数 >> 1，等同于除以2
		// 非负数 >> 2，等同于除以4
		// 非负数 >> 3，等同于除以8
		// 非负数 >> i，等同于除以2的i次方
		// 只有非负数符合这个特征，负数不要用
		int k = 10;
		System.out.println(k);
		System.out.println(k << 1);
		System.out.println(k << 2);
		System.out.println(k << 3);
		System.out.println(k >> 1);
		System.out.println(k >> 2);
		System.out.println(k >> 3);
		System.out.println("===k===");

		// 测试新增的二进制操作函数
		System.out.println("===新增二进制操作函数测试===");
		
		// 测试 reverseBits
		int testReverse = 43261596; // 00000010100101000001111010011100
		System.out.println("Reverse bits 测试:");
		System.out.print("原数字: ");
		printBinary(testReverse);
		int reversed = reverseBits(testReverse);
		System.out.print("颠倒后: ");
		printBinary(reversed);
		System.out.println("预期结果: 964176192");
		System.out.println("实际结果: " + reversed);
		System.out.println();

		// 测试 hammingWeight
		int testHamming = 11; // 1011
		System.out.println("Hamming weight 测试:");
		System.out.print("数字: ");
		printBinary(testHamming);
		System.out.println("1的个数: " + hammingWeight(testHamming));
		System.out.println("预期结果: 3");
		System.out.println();

		// 测试 countBits
		System.out.println("Count bits 测试:");
		int[] bits = countBits(5);
		System.out.print("0到5中每个数字二进制表示中1的个数: ");
		for (int bit : bits) {
			System.out.print(bit + " ");
		}
		System.out.println();
		System.out.println("预期结果: 0 1 1 2 1 2");
		System.out.println();

		// 测试 isPowerOfTwo
		System.out.println("Is power of two 测试:");
		System.out.println("8是2的幂: " + isPowerOfTwo(8));
		System.out.println("10是2的幂: " + isPowerOfTwo(10));
		System.out.println();

		// 测试 isPowerOfFour
		System.out.println("Is power of four 测试:");
		System.out.println("16是4的幂: " + isPowerOfFour(16));
		System.out.println("8是4的幂: " + isPowerOfFour(8));
		System.out.println();

		// 测试 hasAlternatingBits
		System.out.println("Has alternating bits 测试:");
		System.out.println("5(101)有交替位: " + hasAlternatingBits(5));
		System.out.println("7(111)有交替位: " + hasAlternatingBits(7));
		System.out.println();

		// 测试 hammingDistance
		System.out.println("Hamming distance 测试:");
		System.out.println("1(0001)和4(0100)的汉明距离: " + hammingDistance(1, 4));
		System.out.println("预期结果: 2");
		System.out.println();

		// 测试 findComplement
		System.out.println("Find complement 测试:");
		System.out.println("5(101)的补数: " + findComplement(5));
		System.out.println("预期结果: 2 (010)");
		System.out.println();

		// 测试 missingNumber
		System.out.println("Missing number 测试:");
		int[] missingTest = {3, 0, 1};
		System.out.println("数组[3,0,1]缺失的数字: " + missingNumber(missingTest));
		System.out.println("预期结果: 2");
		System.out.println();

		// 测试 singleNumberI


		// 测试 singleNumberII
		System.out.println("Single number II 测试:");
		int[] singleTestII = {2, 2, 3, 2};
		System.out.println("数组[2,2,3,2]中只出现一次的数字: " + singleNumberII(singleTestII));
		System.out.println("预期结果: 3");
		System.out.println();

		// 测试 singleNumberIII
		System.out.println("Single number III 测试:");
		int[] singleTestIII = {1, 2, 1, 3, 2, 5};
		int[] result = singleNumberIII(singleTestIII);
		System.out.print("数组[1,2,1,3,2,5]中只出现一次的两个数字: ");
		for (int num : result) {
			System.out.print(num + " ");
		}
		System.out.println();
		System.out.println("预期结果: 3 5 (顺序可能不同)");
		System.out.println();

		// 测试 binaryStirling
		System.out.println("Binary Stirling 测试:");
		System.out.println("S(5,2) mod 2 = " + binaryStirling(5, 2));
		System.out.println("预期结果: 0");
		System.out.println();

		// 测试扩展题目
		runExtendedProblems();
	}

	/**
	 * 运行扩展题目测试
	 * 包含从各大OJ平台精选的位运算题目
	 */
	public static void runExtendedProblems() {
		System.out.println("=== 扩展题目测试 ===");
		
		// LeetCode 136 - Single Number
		testSingleNumber();
		
		// LeetCode 137 - Single Number II
		testSingleNumberII();
		
		// LeetCode 260 - Single Number III
		testSingleNumberIII();
		
		// LeetCode 191 - Number of 1 Bits
		testNumberOf1Bits();
		
		// LeetCode 338 - Counting Bits
		testCountingBits();
		
		// LeetCode 190 - Reverse Bits
		testReverseBits();
		
		// LeetCode 231 - Power of Two
		testPowerOfTwo();
		
		// LeetCode 342 - Power of Four
		testPowerOfFour();
		
		// LeetCode 268 - Missing Number
		testMissingNumber();
		
		// LeetCode 371 - Sum of Two Integers
		testSumOfTwoIntegers();
		
		// LeetCode 201 - Bitwise AND of Numbers Range
		testBitwiseANDOfNumbersRange();
		
		// LeetCode 477 - Total Hamming Distance
		testTotalHammingDistance();
		
		System.out.println("=== 扩展题目测试完成 ===");
	}

	/**
	 * LeetCode 136 - Single Number (只出现一次的数字)
	 * 来源: LeetCode
	 * 链接: https://leetcode.com/problems/single-number/
	 * 
	 * 题目描述:
	 * 给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。
	 * 
	 * 解法分析:
	 * 最优解: 异或运算
	 * 时间复杂度: O(n)
	 * 空间复杂度: O(1)
	 * 
	 * 核心思想:
	 * 利用异或运算的性质：
	 * 1. a ^ a = 0
	 * 2. a ^ 0 = a
	 * 3. 异或运算满足交换律和结合律
	 * 
	 * 因此，所有出现两次的数字异或后结果为0，最后剩下的就是只出现一次的数字。
	 */

	
	public static void testSingleNumber() {
		System.out.println("=== LeetCode 136 - Single Number 测试 ===");
		int[] nums1 = {2, 2, 1};
		int[] nums2 = {4, 1, 2, 1, 2};
		int[] nums3 = {1};
		
		System.out.println("测试用例1: " + Arrays.toString(nums1) + " -> " + singleNumber(nums1));
		System.out.println("测试用例2: " + Arrays.toString(nums2) + " -> " + singleNumber(nums2));
		System.out.println("测试用例3: " + Arrays.toString(nums3) + " -> " + singleNumber(nums3));
	}

	/**
	 * LeetCode 137 - Single Number II (只出现一次的数字 II)
	 * 来源: LeetCode
	 * 链接: https://leetcode.com/problems/single-number-ii/
	 * 
	 * 题目描述:
	 * 给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现三次。找出那个只出现了一次的元素。
	 * 
	 * 解法分析:
	 * 最优解: 位运算统计
	 * 时间复杂度: O(n)
	 * 空间复杂度: O(1)
	 * 
	 * 核心思想:
	 * 对于每个二进制位，统计所有数字在该位上1的个数
	 * 如果某个位上1的个数不是3的倍数，说明只出现一次的数字在该位上是1
	 */

	
	public static void testSingleNumberII() {
		System.out.println("=== LeetCode 137 - Single Number II 测试 ===");
		int[] nums1 = {2, 2, 3, 2};
		int[] nums2 = {0, 1, 0, 1, 0, 1, 99};
		
		System.out.println("测试用例1: " + Arrays.toString(nums1) + " -> " + singleNumberII(nums1));
		System.out.println("测试用例2: " + Arrays.toString(nums2) + " -> " + singleNumberII(nums2));
	}

	/**
	 * LeetCode 260 - Single Number III (只出现一次的数字 III)
	 * 来源: LeetCode
	 * 链接: https://leetcode.com/problems/single-number-iii/
	 * 
	 * 题目描述:
	 * 给定一个整数数组，其中恰好有两个元素只出现一次，其余所有元素均出现两次。找出只出现一次的那两个元素。
	 * 
	 * 解法分析:
	 * 最优解: 分组异或
	 * 时间复杂度: O(n)
	 * 空间复杂度: O(1)
	 * 
	 * 核心思想:
	 * 1. 先对所有数字进行异或，得到两个不同数字的异或结果
	 * 2. 找到异或结果中任意一个为1的位，这个位可以将数组分成两组
	 * 3. 分别对两组进行异或，得到两个结果
	 */

	
	public static void testSingleNumberIII() {
		System.out.println("=== LeetCode 260 - Single Number III 测试 ===");
		int[] nums1 = {1, 2, 1, 3, 2, 5};
		int[] result = singleNumberIII(nums1);
		System.out.println("测试用例: " + Arrays.toString(nums1) + " -> " + Arrays.toString(result));
	}

	/**
	 * LeetCode 191 - Number of 1 Bits (位1的个数)
	 * 来源: LeetCode
	 * 链接: https://leetcode.com/problems/number-of-1-bits/
	 * 
	 * 题目描述:
	 * 编写一个函数，输入是一个无符号整数，返回其二进制表达式中数字位数为 '1' 的个数（也被称为汉明重量）。
	 * 
	 * 解法分析:
	 * 最优解: Brian Kernighan算法
	 * 时间复杂度: O(k)，k为1的个数
	 * 空间复杂度: O(1)
	 * 
	 * 核心思想:
	 * 使用 n & (n - 1) 可以清除最右边的1
	 * 每次清除一个1，直到n变为0
	 */
	public static int numberOf1Bits(int n) {
		int count = 0;
		while (n != 0) {
			n &= (n - 1);
			count++;
		}
		return count;
	}
	
	public static void testNumberOf1Bits() {
		System.out.println("=== LeetCode 191 - Number of 1 Bits 测试 ===");
		System.out.println("11(1011)的1的个数: " + numberOf1Bits(11));
		System.out.println("128(10000000)的1的个数: " + numberOf1Bits(128));
	}

	/**
	 * LeetCode 338 - Counting Bits (比特位计数)
	 * 来源: LeetCode
	 * 链接: https://leetcode.com/problems/counting-bits/
	 * 
	 * 题目描述:
	 * 给定一个非负整数 num。对于 0 ≤ i ≤ num 范围中的每个数字 i ，计算其二进制数中的 1 的数目并将它们作为数组返回。
	 * 
	 * 解法分析:
	 * 最优解: 动态规划
	 * 时间复杂度: O(n)
	 * 空间复杂度: O(n)
	 * 
	 * 核心思想:
	 * 利用已知结果：i的1的个数 = i/2的1的个数 + i的最低位是否为1
	 * 即：bits[i] = bits[i >> 1] + (i & 1)
	 */
	public static int[] countingBits(int n) {
		int[] bits = new int[n + 1];
		for (int i = 1; i <= n; i++) {
			bits[i] = bits[i >> 1] + (i & 1);
		}
		return bits;
	}
	
	public static void testCountingBits() {
		System.out.println("=== LeetCode 338 - Counting Bits 测试 ===");
		int[] result = countingBits(5);
		System.out.println("0到5的1的个数: " + Arrays.toString(result));
	}

	/**
	 * LeetCode 190 - Reverse Bits (颠倒二进制位)
	 * 来源: LeetCode
	 * 链接: https://leetcode.com/problems/reverse-bits/
	 * 
	 * 题目描述:
	 * 颠倒给定的 32 位无符号整数的二进制位。
	 * 
	 * 解法分析:
	 * 最优解: 逐位反转
	 * 时间复杂度: O(1) - 固定32次循环
	 * 空间复杂度: O(1)
	 * 
	 * 核心思想:
	 * 从右到左提取每一位，然后从左到右放置到结果中
	 */

	
	public static void testReverseBits() {
		System.out.println("=== LeetCode 190 - Reverse Bits 测试 ===");
		int n = 43261596; // 00000010100101000001111010011100
		int reversed = reverseBits(n);
		System.out.println("原数字: " + n + ", 颠倒后: " + reversed);
	}

	/**
	 * LeetCode 231 - Power of Two (2的幂)
	 * 来源: LeetCode
	 * 链接: https://leetcode.com/problems/power-of-two/
	 * 
	 * 题目描述:
	 * 给定一个整数，编写一个函数来判断它是否是 2 的幂次方。
	 * 
	 * 解法分析:
	 * 最优解: 位运算
	 * 时间复杂度: O(1)
	 * 空间复杂度: O(1)
	 * 
	 * 核心思想:
	 * 2的幂的二进制表示中只有一个1
	 * 使用 n & (n - 1) == 0 来判断
	 */
	public static boolean powerOfTwo(int n) {
		return n > 0 && (n & (n - 1)) == 0;
	}
	
	public static void testPowerOfTwo() {
		System.out.println("=== LeetCode 231 - Power of Two 测试 ===");
		System.out.println("8是2的幂: " + powerOfTwo(8));
		System.out.println("10是2的幂: " + powerOfTwo(10));
}

	/**
	 * LeetCode 342 - Power of Four (4的幂)
	 * 来源: LeetCode
	 * 链接: https://leetcode.com/problems/power-of-four/
	 * 
	 * 题目描述:
	 * 给定一个整数，写一个函数来判断它是否是 4 的幂次方。
	 * 
	 * 解法分析:
	 * 最优解: 位运算
	 * 时间复杂度: O(1)
	 * 空间复杂度: O(1)
	 * 
	 * 核心思想:
	 * 4的幂首先是2的幂，而且1必须在奇数位上（从右往左数，最右边是第0位）
	 * 0x55555555 是十六进制表示，二进制是 01010101010101010101010101010101
	 * 这个数在所有奇数位上都是1，用于检查1是否在正确的位置上
	 */
	public static boolean powerOfFour(int n) {
		return n > 0 && (n & (n - 1)) == 0 && (n & 0x55555555) != 0;
	}
	
	public static void testPowerOfFour() {
		System.out.println("=== LeetCode 342 - Power of Four 测试 ===");
		System.out.println("16是4的幂: " + powerOfFour(16));
		System.out.println("8是4的幂: " + powerOfFour(8));
	}


	
	public static void testMissingNumber() {
		System.out.println("=== LeetCode 268 - Missing Number 测试 ===");
		int[] nums1 = {3, 0, 1};
		int[] nums2 = {0, 1};
		System.out.println("数组" + java.util.Arrays.toString(nums1) + "缺失的数字: " + missingNumber(nums1));
		System.out.println("数组" + java.util.Arrays.toString(nums2) + "缺失的数字: " + missingNumber(nums2));
	}

	/**
	 * LeetCode 371 - Sum of Two Integers (两整数之和)
	 * 来源: LeetCode
	 * 链接: https://leetcode.com/problems/sum-of-two-integers/
	 * 
	 * 题目描述:
	 * 不使用运算符 + 和 - ，计算两整数 a 、b 之和。
	 * 
	 * 解法分析:
	 * 最优解: 位运算模拟加法
	 * 时间复杂度: O(1) - 最多32次循环
	 * 空间复杂度: O(1)
	 * 
	 * 核心思想:
	 * 使用位运算模拟加法过程：
	 * 1. 异或运算得到无进位和
	 * 2. 与运算左移一位得到进位
	 * 3. 重复直到进位为0
	 */
	public static int sumOfTwoIntegers(int a, int b) {
		while (b != 0) {
			int carry = (a & b) << 1;  // 进位
			a = a ^ b;                // 无进位和
			b = carry;
		}
		return a;
	}
	
	public static void testSumOfTwoIntegers() {
		System.out.println("=== LeetCode 371 - Sum of Two Integers 测试 ===");
		System.out.println("1 + 2 = " + sumOfTwoIntegers(1, 2));
		System.out.println("15 + 7 = " + sumOfTwoIntegers(15, 7));
	}

	/**
	 * LeetCode 201 - Bitwise AND of Numbers Range (数字范围按位与)
	 * 来源: LeetCode
	 * 链接: https://leetcode.com/problems/bitwise-and-of-numbers-range/
	 * 
	 * 题目描述:
	 * 给定范围 [m, n]，其中 0 <= m <= n <= 2147483647，返回此范围内所有数字的按位与（包含 m, n 两端点）。
	 * 
	 * 解法分析:
	 * 最优解: 位运算
	 * 时间复杂度: O(1) - 最多32次循环
	 * 空间复杂度: O(1)
	 * 
	 * 核心思想:
	 * 找到m和n的公共前缀，因为在这个范围内的所有数字，只有公共前缀部分在按位与后保持不变。
	 */
	public static int bitwiseANDOfNumbersRange(int m, int n) {
		int shift = 0;
		while (m < n) {
			m >>= 1;
			n >>= 1;
			shift++;
		}
		return m << shift;
	}
	
	public static void testBitwiseANDOfNumbersRange() {
		System.out.println("=== LeetCode 201 - Bitwise AND of Numbers Range 测试 ===");
		System.out.println("[5, 7]的按位与: " + bitwiseANDOfNumbersRange(5, 7));
		System.out.println("[0, 1]的按位与: " + bitwiseANDOfNumbersRange(0, 1));
	}


	
	public static void testTotalHammingDistance() {
		System.out.println("=== LeetCode 477 - Total Hamming Distance 测试 ===");
		int[] nums = {4, 14, 2};
		System.out.println("数组" + java.util.Arrays.toString(nums) + "的汉明距离总和: " + totalHammingDistance(nums));
	}

	// 辅助函数：返回true
	private static boolean returnTrue() {
		System.out.println("执行了returnTrue");
		return true;
	}

	// 辅助函数：返回false
	private static boolean returnFalse() {
		System.out.println("执行了returnFalse");
		return false;
	}

}

===============================================

文件: BinarySystem.py
===============================================
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
================================================================================================
Class003: 二进制系统与位运算专题（Binary System and Bit Manipulation）- Python版本
================================================================================================

【核心知识点总结】
1. 位运算基础：
   - AND(&): 两位都为1时结果为1，常用于清零特定位、提取特定位
   - OR(|): 有一位为1时结果为1，常用于设置特定位
   - XOR(^): 两位不同时结果为1，常用于无临时变量交换、查找单独元素
   - NOT(~): 按位取反
   - 左移(<<): 相当于乘以2的幂（非负数），所有位向左移动
   - 右移(>>): 算术右移，保留符号位

2. 常见技巧与应用场景：
   ① 判断奇偶：(n & 1) == 1 为奇数，== 0 为偶数
   ② 交换变量：a ^= b; b ^= a; a ^= b; （无需临时变量）
   ③ 清除最右边的1：n &= (n - 1)
   ④ 获取最右边的1：n & (-n)
   ⑤ 判断2的幂：n > 0 and (n & (n - 1)) == 0
   ⑥ 计算二进制中1的个数：Brian Kernighan算法
   ⑦ 找唯一元素：利用 a ^ a = 0, a ^ 0 = a
   ⑧ 位掩码：用于状态压缩DP、集合表示

3. 题型分类：
   【基础操作】：位反转、位计数、进制转换
   【数学性质】：幂判断、格雷编码、斯特林数
   【查找问题】：找唯一元素、找缺失数字、找重复数字
   【XOR应用】：异或和、最大异或对、异或路径
   【位运算优化】：快速幂、乘法优化、状态压缩
   【工程应用】：位图、布隆过滤器、哈希表优化

【时间复杂度分析技巧】
- 基础位运算：O(1) 常数时间
- 遍历所有位：O(log n) 或 O(32/64) = O(1)
- Brian Kernighan算法：O(k)，k为1的个数
- Trie树优化XOR：O(n * log(max_value))

【空间复杂度优化】
- 原地操作：使用异或交换，空间O(1)
- 位压缩：用一个整数表示多个布尔值
- 滚动数组：DP优化空间

【边界场景与异常处理】
1. 负数处理：
   - Python使用任意精度整数，负数需要特殊处理
   - 对于32位操作，需要使用掩码限制位数
2. 溢出处理：
   - Python整数无溢出问题，但需要注意32位限制
   - 使用掩码 0xFFFFFFFF 限制为32位
3. 边界值：
   - 0的特殊处理（补数、幂判断等）
   - 空数组的判断
   - 单元素数组的特殊情况

【语言特性差异（Python vs Java vs C++）】
1. 整数表示：
   - Python: 任意精度整数，无固定大小
   - Java: 固定32位int/64位long，有符号
   - C++: int大小取决于平台，有signed/unsigned
2. 位运算操作符：
   - Python: 无>>>，负数需要特殊处理
   - Java: 有>>>无符号右移
   - C++: 无>>>，对unsigned自动逻辑右移
3. 位长度获取：
   - Python: bin(n).count('1'), n.bit_length()
   - Java: Integer.bitCount(), Integer.numberOfLeadingZeros()
   - C++: __builtin_popcount(), __builtin_clz()

【工程化考量】
1. 代码可读性：
   - 使用常量命名位掩码：MASK_ODD_BITS = 0x55555555
   - 添加详细注释说明位操作意图
   - 复杂位运算拆分为多步
2. 性能优化：
   - 使用位运算替代乘除法（仅限2的幂）
   - 查表法优化频繁的位计数
   - 使用内置函数优化
3. 异常处理：
   - 参数验证：if n < 0: raise ValueError("参数错误")
   - 边界检查：数组访问前检查索引
   - 类型检查：确保输入为整数
4. 单元测试：
   - 正常值测试
   - 边界值测试（0, 1, 最大值, 最小值）
   - 负数测试
   - 大规模数据性能测试
"""

class BinarySystem:
    """
    二进制系统与位运算专题 - Python实现
    """
    
    @staticmethod
    def main():
        """
        主函数：演示二进制系统的基本操作和扩展题目
        
        来源: 算法学习系统
        更新时间: 2025-10-23
        题目总数: 200+道精选题目
        平台覆盖: LeetCode (力扣)、LintCode (炼码)、HackerRank、赛码、AtCoder、USACO、洛谷 (Luogu)、CodeChef、SPOJ、Project Euler、HackerEarth、计蒜客、各大高校 OJ、zoj、MarsCode、UVa OJ、TimusOJ、AizuOJ、Comet OJ、杭电 OJ、LOJ、牛客、杭州电子科技大学、acwing、codeforces、hdu、poj、剑指Offer等
        """
        print("=== 二进制系统与位运算专题 ===")
        print("作者: 算法学习系统")
        print("日期: 2025年10月23日")
        print()
        
        # 运行基础操作测试
        BinarySystem.run_basic_operations()
        
        # 运行扩展题目测试
        BinarySystem.run_extended_problems()
        
        print("=== 所有测试完成 ===")
    
    @staticmethod
    def run_basic_operations():
        """
        运行基础操作测试
        """
        print("=== 基础操作测试 ===")
        
        # 测试位反转
        print("位反转测试:")
        test_reverse = 43261596  # 00000010100101000001111010011100
        print(f"原数字: {test_reverse} (二进制: {bin(test_reverse)})")
        reversed_num = BinarySystem.reverse_bits(test_reverse)
        print(f"颠倒后: {reversed_num} (二进制: {bin(reversed_num)})")
        print("预期结果: 964176192")
        print()
        
        # 测试汉明重量
        print("汉明重量测试:")
        test_hamming = 11  # 1011
        print(f"数字: {test_hamming} (二进制: {bin(test_hamming)})")
        print(f"1的个数: {BinarySystem.hamming_weight(test_hamming)}")
        print("预期结果: 3")
        print()
        
        # 测试2的幂判断
        print("2的幂判断测试:")
        print(f"8是2的幂: {'是' if BinarySystem.is_power_of_two(8) else '否'}")
        print(f"10是2的幂: {'是' if BinarySystem.is_power_of_two(10) else '否'}")
        print()
        
        # 测试4的幂判断
        print("4的幂判断测试:")
        print(f"16是4的幂: {'是' if BinarySystem.is_power_of_four(16) else '否'}")
        print(f"8是4的幂: {'是' if BinarySystem.is_power_of_four(8) else '否'}")
        print()
    
    @staticmethod
    def run_extended_problems():
        """
        运行扩展题目测试
        包含从各大OJ平台精选的位运算题目
        """
        print("=== 扩展题目测试 ===")
        
        # LeetCode 136 - Single Number
        BinarySystem.test_single_number()
        
        # LeetCode 137 - Single Number II
        BinarySystem.test_single_number_ii()
        
        # LeetCode 260 - Single Number III
        BinarySystem.test_single_number_iii()
        
        # LeetCode 191 - Number of 1 Bits
        BinarySystem.test_number_of_1_bits()
        
        # LeetCode 338 - Counting Bits
        BinarySystem.test_counting_bits()
        
        # LeetCode 190 - Reverse Bits
        BinarySystem.test_reverse_bits()
        
        # LeetCode 231 - Power of Two
        BinarySystem.test_power_of_two()
        
        # LeetCode 342 - Power of Four
        BinarySystem.test_power_of_four()
        
        # LeetCode 268 - Missing Number
        BinarySystem.test_missing_number()
        
        # LeetCode 371 - Sum of Two Integers
        BinarySystem.test_sum_of_two_integers()
        
        # LeetCode 201 - Bitwise AND of Numbers Range
        BinarySystem.test_bitwise_and_of_numbers_range()
        
        # LeetCode 477 - Total Hamming Distance
        BinarySystem.test_total_hamming_distance()
        
        print("=== 扩展题目测试完成 ===")
    
    @staticmethod
    def reverse_bits(n: int) -> int:
        """
        1. LeetCode 190. Reverse Bits (颠倒二进制位)
        题目链接: https://leetcode.com/problems/reverse-bits/
        题目描述: 颠倒给定的 32 位无符号整数的二进制位
        时间复杂度: O(1) - 固定32次循环
        空间复杂度: O(1)
        """
        result = 0
        for i in range(32):
            result = (result << 1) | (n & 1)
            n >>= 1
        return result
    
    @staticmethod
    def hamming_weight(n: int) -> int:
        """
        2. LeetCode 191. Number of 1 Bits (位1的个数)
        题目链接: https://leetcode.com/problems/number-of-1-bits/
        题目描述: 编写一个函数，输入是一个无符号整数，返回其二进制表达式中数字位数为 '1' 的个数
        时间复杂度: O(k)，k为1的个数
        空间复杂度: O(1)
        """
        count = 0
        while n != 0:
            n &= (n - 1)
            count += 1
        return count
    
    @staticmethod
    def is_power_of_two(n: int) -> bool:
        """
        3. LeetCode 231. Power of Two (2的幂)
        题目链接: https://leetcode.com/problems/power-of-two/
        题目描述: 给定一个整数，编写一个函数来判断它是否是 2 的幂次方
        时间复杂度: O(1)
        空间复杂度: O(1)
        """
        return n > 0 and (n & (n - 1)) == 0
    
    @staticmethod
    def is_power_of_four(n: int) -> bool:
        """
        4. LeetCode 342. Power of Four (4的幂)
        题目链接: https://leetcode.com/problems/power-of-four/
        题目描述: 给定一个整数，写一个函数来判断它是否是 4 的幂次方
        时间复杂度: O(1)
        空间复杂度: O(1)
        """
        return n > 0 and (n & (n - 1)) == 0 and (n & 0x55555555) != 0
    
    @staticmethod
    def single_number(nums: list) -> int:
        """
        5. LeetCode 136. Single Number (只出现一次的数字)
        题目链接: https://leetcode.com/problems/single-number/
        题目描述: 给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素
        时间复杂度: O(n)
        空间复杂度: O(1)
        
        解题思路：
        利用异或运算的性质：
        1. a ^ a = 0（任何数与自己异或为0）
        2. a ^ 0 = a（任何数与0异或为自己）
        3. 异或运算满足交换律和结合律
        因此，所有出现两次的数字异或后结果为0，最后剩下的就是只出现一次的数字。
        """
        if not nums:
            raise ValueError("数组不能为空")
        
        result = 0
        for num in nums:
            result ^= num
        return result
    
    @staticmethod
    def test_single_number():
        """测试LeetCode 136"""
        print("\n=== LeetCode 136 - Single Number 测试 ===")
        nums1 = [2, 2, 1]
        nums2 = [4, 1, 2, 1, 2]
        nums3 = [1]
        
        print(f"测试用例1: {nums1} -> {BinarySystem.single_number(nums1)}")
        print(f"测试用例2: {nums2} -> {BinarySystem.single_number(nums2)}")
        print(f"测试用例3: {nums3} -> {BinarySystem.single_number(nums3)}")
    
    @staticmethod
    def single_number_ii(nums: list) -> int:
        """
        6. LeetCode 137. Single Number II (只出现一次的数字 II)
        题目链接: https://leetcode.com/problems/single-number-ii/
        题目描述: 给你一个整数数组 nums ，除某个元素仅出现 一次 外，其余每个元素都恰出现 三次 。请你找出并返回那个只出现了一次的元素。
        时间复杂度: O(n)
        空间复杂度: O(1)
        
        解题思路：
        使用位运算状态机的方法。对于每个二进制位，统计所有数字在该位上1的个数，
        如果该位上1的个数对3取余不为0，则说明只出现一次的数字在该位上是1。
        """
        if not nums:
            raise ValueError("数组不能为空")
        
        result = 0
        for i in range(32):
            sum_bits = 0
            for num in nums:
                # 处理Python的负数右移问题
                if num < 0:
                    # 对于负数，使用补码处理
                    sum_bits += ((num + 0x100000000) >> i) & 1
                else:
                    sum_bits += (num >> i) & 1
            if sum_bits % 3 != 0:
                result |= (1 << i)
        return result
    
    @staticmethod
    def test_single_number_ii():
        """测试LeetCode 137"""
        print("\n=== LeetCode 137 - Single Number II 测试 ===")
        nums1 = [2, 2, 3, 2]
        nums2 = [0, 1, 0, 1, 0, 1, 99]
        
        print(f"测试用例1: {nums1} -> {BinarySystem.single_number_ii(nums1)}")
        print(f"测试用例2: {nums2} -> {BinarySystem.single_number_ii(nums2)}")
    
    @staticmethod
    def single_number_iii(nums: list) -> list:
        """
        7. LeetCode 260. Single Number III (只出现一次的数字 III)
        题目链接: https://leetcode.com/problems/single-number-iii/
        题目描述: 给定一个整数数组 nums，其中恰好有两个元素只出现一次，其余所有元素均出现两次。找出只出现一次的那两个元素
        时间复杂度: O(n)
        空间复杂度: O(1)
        
        解题思路：
        1. 首先获取两个只出现一次的数的异或结果
        2. 找到xor中最右边的1位，这表示两个数在这一位上不同
        3. 根据这一位将数组分为两组，分别异或得到两个数
        """
        if len(nums) < 2:
            raise ValueError("数组长度至少为2")
        
        # 第一步：计算所有数字的异或
        xor = 0
        for num in nums:
            xor ^= num
        
        # 第二步：找到最右边的1
        rightmost_one = xor & (-xor)
        
        # 第三步：根据这个位将数组分成两组
        result = [0, 0]
        for num in nums:
            if (num & rightmost_one) == 0:
                result[0] ^= num
            else:
                result[1] ^= num
        
        return result
    
    @staticmethod
    def test_single_number_iii():
        """测试LeetCode 260"""
        print("\n=== LeetCode 260 - Single Number III 测试 ===")
        nums1 = [1, 2, 1, 3, 2, 5]
        result = BinarySystem.single_number_iii(nums1)
        print(f"测试用例: {nums1} -> {result}")
    
    @staticmethod
    def number_of_1_bits(n: int) -> int:
        """
        8. LeetCode 191. Number of 1 Bits (位1的个数)
        题目链接: https://leetcode.com/problems/number-of-1-bits/
        题目描述: 编写一个函数，输入是一个无符号整数，返回其二进制表达式中数字位数为 '1' 的个数（也被称为汉明重量）
        时间复杂度: O(k)，k为1的个数
        空间复杂度: O(1)
        
        解题思路：
        使用Brian Kernighan算法：
        每执行一次n = n & (n - 1)，就会将n的最后一个1变成0
        这样只需要循环k次，k为1的个数
        """
        # 处理Python的32位限制
        if n < 0:
            n = n & 0xFFFFFFFF
        count = 0
        while n != 0:
            n &= (n - 1)
            count += 1
        return count
    
    @staticmethod
    def test_number_of_1_bits():
        """测试LeetCode 191"""
        print("\n=== LeetCode 191 - Number of 1 Bits 测试 ===")
        print(f"11(1011)的1的个数: {BinarySystem.number_of_1_bits(11)}")
        print(f"128(10000000)的1的个数: {BinarySystem.number_of_1_bits(128)}")
    
    @staticmethod
    def counting_bits(n: int) -> list:
        """
        9. LeetCode 338. Counting Bits (比特位计数)
        题目链接: https://leetcode.com/problems/counting-bits/
        题目描述: 给定一个非负整数 num。对于 0 ≤ i ≤ num 范围中的每个数字 i ，计算其二进制数中的 1 的数目并将它们作为数组返回
        时间复杂度: O(n)
        空间复杂度: O(n)
        
        解题思路：
        利用已知结果：i的1的个数 = i/2的1的个数 + i的最低位是否为1
        即：bits[i] = bits[i >> 1] + (i & 1)
        """
        bits = [0] * (n + 1)
        for i in range(1, n + 1):
            bits[i] = bits[i >> 1] + (i & 1)
        return bits
    
    @staticmethod
    def test_counting_bits():
        """测试LeetCode 338"""
        print("\n=== LeetCode 338 - Counting Bits 测试 ===")
        result = BinarySystem.counting_bits(5)
        print(f"0到5的1的个数: {result}")
    
    @staticmethod
    def reverse_bits_leetcode(n: int) -> int:
        """
        10. LeetCode 190. Reverse Bits (颠倒二进制位)
        题目链接: https://leetcode.com/problems/reverse-bits/
        题目描述: 颠倒给定的 32 位无符号整数的二进制位
        时间复杂度: O(1) - 固定32次循环
        空间复杂度: O(1)
        
        解题思路：
        从右到左提取每一位，然后从左到右放置到结果中
        """
        # 处理32位无符号整数
        result = 0
        for i in range(32):
            result = (result << 1) | (n & 1)
            n >>= 1
        return result
    
    @staticmethod
    def test_reverse_bits():
        """测试LeetCode 190"""
        print("\n=== LeetCode 190 - Reverse Bits 测试 ===")
        n = 43261596  # 00000010100101000001111010011100
        reversed_num = BinarySystem.reverse_bits_leetcode(n)
        print(f"原数字: {n}, 颠倒后: {reversed_num}")
    
    @staticmethod
    def power_of_two(n: int) -> bool:
        """
        11. LeetCode 231. Power of Two (2的幂)
        题目链接: https://leetcode.com/problems/power-of-two/
        题目描述: 给定一个整数，编写一个函数来判断它是否是 2 的幂次方
        时间复杂度: O(1)
        空间复杂度: O(1)
        
        解题思路：
        位运算技巧：2的幂在二进制表示中只有一个位是1
        n & (n-1) 会清除 n 中最低位的 1
        如果 n 是 2 的幂，那么 n & (n-1) == 0
        """
        return n > 0 and (n & (n - 1)) == 0
    
    @staticmethod
    def test_power_of_two():
        """测试LeetCode 231"""
        print("\n=== LeetCode 231 - Power of Two 测试 ===")
        print(f"8是2的幂: {'是' if BinarySystem.power_of_two(8) else '否'}")
        print(f"10是2的幂: {'是' if BinarySystem.power_of_two(10) else '否'}")
    
    @staticmethod
    def power_of_four(n: int) -> bool:
        """
        12. LeetCode 342. Power of Four (4的幂)
        题目链接: https://leetcode.com/problems/power-of-four/
        题目描述: 给定一个整数，写一个函数来判断它是否是 4 的幂次方
        时间复杂度: O(1)
        空间复杂度: O(1)
        
        解题思路：
        4的幂首先是2的幂，而且1必须在奇数位上（从右往左数，最右边是第0位）
        0x55555555 是十六进制表示，二进制是 01010101010101010101010101010101
        这个数在所有奇数位上都是1，用于检查1是否在正确的位置上
        """
        return n > 0 and (n & (n - 1)) == 0 and (n & 0x55555555) != 0
    
    @staticmethod
    def test_power_of_four():
        """测试LeetCode 342"""
        print("\n=== LeetCode 342 - Power of Four 测试 ===")
        print(f"16是4的幂: {'是' if BinarySystem.power_of_four(16) else '否'}")
        print(f"8是4的幂: {'是' if BinarySystem.power_of_four(8) else '否'}")
    
    @staticmethod
    def missing_number(nums: list) -> int:
        """
        13. LeetCode 268. Missing Number (缺失数字)
        题目链接: https://leetcode.com/problems/missing-number/
        题目描述: 给定一个包含 [0, n] 中 n 个数的数组 nums ，找出 [0, n] 这个范围内没有出现在数组中的那个数
        时间复杂度: O(n)
        空间复杂度: O(1)
        
        解题思路：
        利用异或运算的性质：
        1. a ^ a = 0
        2. a ^ 0 = a
        3. 异或运算满足交换律和结合律
        
        位运算技巧：利用异或的性质 x ^ x = 0, x ^ 0 = x
        """
        n = len(nums)
        missing = n
        for i in range(n):
            missing ^= i ^ nums[i]
        return missing
    
    @staticmethod
    def test_missing_number():
        """测试LeetCode 268"""
        print("\n=== LeetCode 268 - Missing Number 测试 ===")
        nums1 = [3, 0, 1]
        nums2 = [0, 1]
        print(f"数组{nums1}缺失的数字: {BinarySystem.missing_number(nums1)}")
        print(f"数组{nums2}缺失的数字: {BinarySystem.missing_number(nums2)}")
    
    @staticmethod
    def sum_of_two_integers(a: int, b: int) -> int:
        """
        14. LeetCode 371. Sum of Two Integers (两整数之和)
        题目链接: https://leetcode.com/problems/sum-of-two-integers/
        题目描述: 不使用运算符 + 和 -，计算两整数 a 、b 之和
        时间复杂度: O(1) - 最多32次循环
        空间复杂度: O(1)
        
        解题思路：
        使用位运算模拟加法过程：
        1. 异或运算得到无进位和
        2. 与运算左移一位得到进位
        3. 重复直到进位为0
        """
        # 处理32位整数
        MASK = 0xFFFFFFFF
        MAX_INT = 0x7FFFFFFF
        
        while b != 0:
            carry = ((a & b) << 1) & MASK
            a = (a ^ b) & MASK
            b = carry
        
        # 处理负数情况
        if a > MAX_INT:
            a = ~(a ^ MASK)
        return a
    
    @staticmethod
    def test_sum_of_two_integers():
        """测试LeetCode 371"""
        print("\n=== LeetCode 371 - Sum of Two Integers 测试 ===")
        print(f"1 + 2 = {BinarySystem.sum_of_two_integers(1, 2)}")
        print(f"15 + 7 = {BinarySystem.sum_of_two_integers(15, 7)}")
    
    @staticmethod
    def bitwise_and_of_numbers_range(m: int, n: int) -> int:
        """
        15. LeetCode 201. Bitwise AND of Numbers Range (数字范围按位与)
        题目链接: https://leetcode.com/problems/bitwise-and-of-numbers-range/
        题目描述: 给定范围 [m, n]，其中 0 <= m <= n <= 2147483647，返回此范围内所有数字的按位与（包含 m, n 两端点）
        时间复杂度: O(1) - 最多32次循环
        空间复杂度: O(1)
        
        解题思路：
        找到m和n的公共前缀，因为在这个范围内的所有数字，只有公共前缀部分在按位与后保持不变。
        """
        shift = 0
        while m < n:
            m >>= 1
            n >>= 1
            shift += 1
        return m << shift
    
    @staticmethod
    def test_bitwise_and_of_numbers_range():
        """测试LeetCode 201"""
        print("\n=== LeetCode 201 - Bitwise AND of Numbers Range 测试 ===")
        print(f"[5, 7]的按位与: {BinarySystem.bitwise_and_of_numbers_range(5, 7)}")
        print(f"[0, 1]的按位与: {BinarySystem.bitwise_and_of_numbers_range(0, 1)}")
    
    @staticmethod
    def total_hamming_distance(nums: list) -> int:
        """
        16. LeetCode 477. Total Hamming Distance (汉明距离总和)
        题目链接: https://leetcode.com/problems/total-hamming-distance/
        题目描述: 两个整数的 汉明距离 指的是这两个数字的二进制数对应位不同的数量。给你一个整数数组 nums，请你求出数组中任意两个数之间汉明距离的总和
        时间复杂度: O(n)
        空间复杂度: O(1)
        
        解题思路：
        对于每一位分别计算汉明距离，然后求和：
        1. 对于第i位，统计有多少数字在该位上是1（设为k）
        2. 那么该位贡献的汉明距离为 k * (n - k)
        3. 将所有位的贡献相加得到总和
        """
        total = 0
        n = len(nums)
        for i in range(32):
            count_ones = 0
            for num in nums:
                count_ones += (num >> i) & 1
            total += count_ones * (n - count_ones)
        return total
    
    @staticmethod
    def test_total_hamming_distance():
        """测试LeetCode 477"""
        print("\n=== LeetCode 477 - Total Hamming Distance 测试 ===")
        nums = [4, 14, 2]
        print(f"数组{nums}的汉明距离总和: {BinarySystem.total_hamming_distance(nums)}")
    
    @staticmethod
    def xor_queries(arr: list, queries: list) -> list:
        """
        17. LeetCode 1310. XOR Queries of a Subarray (子数组异或查询)
        题目链接: https://leetcode.com/problems/xor-queries-of-a-subarray/
        题目描述: 给你一个正整数数组 arr，你需要处理以下两种类型的查询：
                 1. 计算从索引 L 到 R 的元素的异或值
        时间复杂度: O(n + q) - n为数组长度，q为查询次数
        空间复杂度: O(n) - 前缀异或数组
        
        解题思路：
        使用前缀异或数组优化多次查询：
        1. 构建前缀异或数组 prefix，其中 prefix[i] = arr[0] ^ arr[1] ^ ... ^ arr[i-1]
        2. 对于查询 [L, R]，结果为 prefix[R+1] ^ prefix[L]
        """
        n = len(arr)
        prefix = [0] * (n + 1)
        
        # 构建前缀异或数组
        for i in range(n):
            prefix[i + 1] = prefix[i] ^ arr[i]
        
        result = []
        
        # 处理每个查询
        for left, right in queries:
            result.append(prefix[right + 1] ^ prefix[left])
        
        return result
    
    @staticmethod
    def test_xor_queries():
        """测试LeetCode 1310"""
        print("\n=== LeetCode 1310 - XOR Queries of a Subarray 测试 ===")
        arr = [1, 3, 4, 8]
        queries = [[0, 1], [1, 2], [0, 3], [3, 3]]
        result = BinarySystem.xor_queries(arr, queries)
        
        print(f"数组: {arr}")
        print(f"查询结果: {result}")
    
    @staticmethod
    def min_bit_flips(start: int, goal: int) -> int:
        """
        18. LeetCode 2220. Minimum Bit Flips to Convert Number (转换数字的最少位翻转次数)
        题目链接: https://leetcode.com/problems/minimum-bit-flips-to-convert-number/
        题目描述: 一次位翻转定义为将数字 x 二进制中的一个位进行翻转操作，即将 0 变成 1 ，或者将 1 变成 0 。
                 给你两个整数 start 和 goal ，请你返回将 start 转变成 goal 的最少位翻转次数。
        时间复杂度: O(1) - 固定32位比较
        空间复杂度: O(1) - 只使用常数级额外空间
        
        解题思路：
        计算两个数字的汉明距离，即异或结果中1的个数
        """
        # 计算异或结果中1的个数
        return bin(start ^ goal).count('1')
    
    @staticmethod
    def test_min_bit_flips():
        """测试LeetCode 2220"""
        print("\n=== LeetCode 2220 - Minimum Bit Flips to Convert Number 测试 ===")
        print(f"start=10, goal=7 的最少位翻转次数: {BinarySystem.min_bit_flips(10, 7)}")
        print(f"start=3, goal=4 的最少位翻转次数: {BinarySystem.min_bit_flips(3, 4)}")
    
    @staticmethod
    def find_array(pref: list) -> list:
        """
        19. LeetCode 2433. Find The Original Array of Prefix Xor (找出前缀异或的原始数组)
        题目链接: https://leetcode.com/problems/find-the-original-array-of-prefix-xor/
        题目描述: 给你一个长度为 n 的整数数组 pref。找出并返回满足以下条件且长度为 n 的数组 arr：
                 pref[i] = arr[0] ^ arr[1] ^ ... ^ arr[i].
        时间复杂度: O(n) - 遍历数组一次
        空间复杂度: O(n) - 结果数组空间
        
        解题思路：
        根据异或的性质，如果 pref[i] = arr[0] ^ arr[1] ^ ... ^ arr[i]
        那么 arr[i] = pref[i] ^ pref[i-1] (i > 0)
        arr[0] = pref[0]
        """
        n = len(pref)
        arr = [0] * n
        
        # 第一个元素就是前缀异或的第一个元素
        arr[0] = pref[0]
        
        # 根据公式计算其他元素
        for i in range(1, n):
            arr[i] = pref[i] ^ pref[i - 1]
        
        return arr
    
    @staticmethod
    def test_find_array():
        """测试LeetCode 2433"""
        print("\n=== LeetCode 2433 - Find The Original Array of Prefix Xor 测试 ===")
        pref = [5, 2, 0, 3, 1]
        result = BinarySystem.find_array(pref)
        
        print(f"前缀异或数组: {pref}")
        print(f"原始数组: {result}")
    
    @staticmethod
    def binary_gap(n: int) -> int:
        """
        20. LeetCode 868. Binary Gap (二进制间距)
        题目链接: https://leetcode.com/problems/binary-gap/
        题目描述: 给定一个正整数 n，找到并返回 n 的二进制表示中两个相邻 1 之间的最长距离。
                 如果不存在两个相邻的 1，返回 0。
        时间复杂度: O(log n) - 遍历二进制位
        空间复杂度: O(1) - 只使用常数级额外空间
        
        解题思路：
        遍历二进制表示，记录相邻1之间的距离
        """
        max_gap = 0
        last_pos = -1
        pos = 0
        
        while n > 0:
            if (n & 1) == 1:
                if last_pos != -1:
                    max_gap = max(max_gap, pos - last_pos)
                last_pos = pos
            pos += 1
            n >>= 1
        
        return max_gap
    
    @staticmethod
    def test_binary_gap():
        """测试LeetCode 868"""
        print("\n=== LeetCode 868 - Binary Gap 测试 ===")
        print(f"n=22 的二进制间距: {BinarySystem.binary_gap(22)}")
        print(f"n=8 的二进制间距: {BinarySystem.binary_gap(8)}")
        print(f"n=5 的二进制间距: {BinarySystem.binary_gap(5)}")
    
    @staticmethod
    def bitwise_complement(n: int) -> int:
        """
        21. LeetCode 1009. Complement of Base 10 Integer (十进制整数的反码)
        题目链接: https://leetcode.com/problems/complement-of-base-10-integer/
        题目描述: 每个非负整数 N 都有其二进制表示。例如，5 可以被表示为二进制 "101"，11 可以用二进制 "1011" 表示，依此类推。
                 注意，除 N = 0 外，任何二进制表示中都不含前导零。
                 二进制的反码表示是将每个 1 改为 0 且每个 0 改为 1。例如，二进制数 "101" 的二进制反码为 "010"。
                 给你一个十进制数 N，请你返回其二进制表示的反码所对应的十进制整数。
        时间复杂度: O(log n) - 构造掩码
        空间复杂度: O(1) - 只使用常数级额外空间
        
        解题思路：
        1. 构造一个掩码，该掩码的位数与n相同，但所有位都是1
        2. 使用异或操作取反
        """
        if n == 0:
            return 1
        
        mask = 1
        # 构造一个掩码，该掩码的位数与n相同，但所有位都是1
        while mask < n:
            mask = (mask << 1) | 1
        # 使用异或操作取反
        return n ^ mask
    
    @staticmethod
    def test_bitwise_complement():
        """测试LeetCode 1009"""
        print("\n=== LeetCode 1009 - Complement of Base 10 Integer 测试 ===")
        print(f"n=5 的反码: {BinarySystem.bitwise_complement(5)}")
        print(f"n=7 的反码: {BinarySystem.bitwise_complement(7)}")
        print(f"n=10 的反码: {BinarySystem.bitwise_complement(10)}")

if __name__ == "__main__":
    BinarySystem.main()

===============================================

文件: BinarySystem_fixed.java
===============================================
import java.util.*;

/**
 * ================================================================================================
 * Class003: 二进制系统与位运算专题（Binary System and Bit Manipulation）
 * ================================================================================================
 * 
 * 【核心知识点总结】
 * 1. 位运算基础：
 *    - AND(&): 两位都为1时结果为1，常用于清零特定位、提取特定位
 *    - OR(|): 有一位为1时结果为1，常用于设置特定位
 *    - XOR(^): 两位不同时结果为1，常用于无临时变量交换、查找单独元素
 *    - NOT(~): 按位取反
 *    - 左移(<<): 相当于乘以2的幂（非负数），所有位向左移动
 *    - 右移(>>): 算术右移，保留符号位
 *    - 无符号右移(>>>): 逻辑右移，不保留符号位（Java特有）
 * 
 * 2. 常见技巧与应用场景：
 *    ① 判断奇偶：(n & 1) == 1 为奇数，== 0 为偶数
 *    ② 交换变量：a ^= b; b ^= a; a ^= b; （无需临时变量）
 *    ③ 清除最右边的1：n &= (n - 1)
 *    ④ 获取最右边的1：n & (-n)
 *    ⑤ 判断2的幂：n > 0 && (n & (n - 1)) == 0
 *    ⑥ 计算二进制中1的个数：Brian Kernighan算法
 *    ⑦ 找唯一元素：利用 a ^ a = 0, a ^ 0 = a
 *    ⑧ 位掩码：用于状态压缩DP、集合表示
 * 
 * 3. 题型分类：
 *    【基础操作】：位反转、位计数、进制转换
 *    【数学性质】：幂判断、格雷编码、斯特林数
 *    【查找问题】：找唯一元素、找缺失数字、找重复数字
 *    【XOR应用】：异或和、最大异或对、异或路径
 *    【位运算优化】：快速幂、乘法优化、状态压缩
 *    【工程应用】：位图、布隆过滤器、哈希表优化
 * 
 * 【时间复杂度分析技巧】
 * - 基础位运算：O(1) 常数时间
 * - 遍历所有位：O(log n) 或 O(32/64) = O(1)
 * - Brian Kernighan算法：O(k)，k为1的个数
 * - Trie树优化XOR：O(n * log(max_value))
 * 
 * 【空间复杂度优化】
 * - 原地操作：使用异或交换，空间O(1)
 * - 位压缩：用一个整数表示多个布尔值
 * - 滚动数组：DP优化空间
 * 
 * 【边界场景与异常处理】
 * 1. 负数处理：
 *    - Java使用补码表示负数
 *    - 最小值的绝对值等于自身：Integer.MIN_VALUE
 *    - 右移操作：>>保留符号，>>>不保留
 * 2. 溢出处理：
 *    - int: 32位，范围 -2^31 ~ 2^31-1
 *    - long: 64位，范围 -2^63 ~ 2^63-1
 *    - 位移操作：(1 << 31)会溢出，应使用1L << 31
 * 3. 边界值：
 *    - 0的特殊处理（补数、幂判断等）
 *    - 空数组的判断
 *    - 单元素数组的特殊情况
 * 
 * 【语言特性差异（Java vs C++ vs Python）】
 * 1. 整数表示：
 *    - Java: 固定32位int/64位long，有符号
 *    - C++: int大小取决于平台，有signed/unsigned
 *    - Python: 任意精度整数，无固定大小
 * 2. 位运算操作符：
 *    - Java: 有>>>无符号右移
 *    - C++: 无>>>，对unsigned自动逻辑右移
 *    - Python: 无>>>，负数需要特殊处理
 * 3. 位长度获取：
 *    - Java: Integer.bitCount(), Integer.numberOfLeadingZeros()
 *    - C++: __builtin_popcount(), __builtin_clz()
 *    - Python: bin(n).count('1'), n.bit_length()
 * 
 * 【工程化考量】
 * 1. 代码可读性：
 *    - 使用常量命名位掩码：MASK_ODD_BITS = 0x55555555
 *    - 添加详细注释说明位操作意图
 *    - 复杂位运算拆分为多步
 * 2. 性能优化：
 *    - 使用位运算替代乘除法（仅限2的幂）
 *    - 查表法优化频繁的位计数
 *    - 编译器内置函数优化
 * 3. 异常处理：
 *    - 参数验证：if (n < 0) throw new IllegalArgumentException()
 *    - 边界检查：数组访问前检查索引
 *    - 溢出检测：关键计算添加断言
 * 4. 单元测试：
 *    - 正常值测试
 *    - 边界值测试（0, 1, MAX_VALUE, MIN_VALUE）
 *    - 负数测试
 *    - 大规模数据性能测试
 * 
 * 【与机器学习/深度学习/AI的联系】
 * 1. 特征工程：
 *    - 位图表示稀疏特征
 *    - One-hot编码的位运算优化
 *    - 哈希特征的位操作
 * 2. 神经网络：
 *    - 二值化神经网络（BNN）
 *    - 位运算加速推理
 *    - 量化感知训练
 * 3. 图像处理：
 *    - 颜色空间转换（RGB <-> HSV）
 *    - 位平面切片
 *    - 图像加密
 * 4. 自然语言处理：
 *    - 布隆过滤器做拼写检查
 *    - SimHash文本相似度
 *    - 位向量表示词汇
 * 5. 密码学：
 *    - 加密算法中的位操作
 *    - 哈希函数实现
 *    - 随机数生成
 * 
 * 【面试/竞赛技巧】
 * 1. 快速模板：
 *    - 背诵常用位操作公式
 *    - 准备位运算调试技巧（打印二进制）
 * 2. 时间优化：
 *    - 位运算替代条件判断
 *    - 空间换时间：预计算表
 * 3. 调试方法：
 *    - 打印中间二进制状态
 *    - 使用断言验证位操作正确性
 *    - 小数据手动验证
 * 4. 常见坑：
 *    - 优先级：& 的优先级低于 ==
 *    - 溢出：1 << 32 在Java中结果为1
 *    - 负数：右移操作的符号位问题
 * 
 * ================================================================================================
 */

// 本文件的实现是用int来举例的
// 对于long类型完全同理
// 不过要注意，如果是long类型的数字num，有64位
// num & (1 << 48)，这种写法不对
// 因为1是一个int类型，只有32位，所以(1 << 48)早就溢出了，所以无意义
// 应该写成 : num & (1L << 48)
// 
// 【重要说明】：
// 1. 位运算的优先级低于比较运算符，需要加括号
// 2. 负数在计算机中用补码表示，最高位为符号位
// 3. Java中整数除法向零取整，而非向下取整
public class BinarySystem {

	// 打印一个int类型的数字，32位进制的状态
	// 左侧是高位，右侧是低位
	public static void printBinary(int num) {
		for (int i = 31; i >= 0; i--) {
			// 下面这句写法，可以改成 :
			// System.out.print((a & (1 << i)) != 0 ? "1" : "0");
			// 但不可以改成 :
			// System.out.print((a & (1 << i)) == 1 ? "1" : "0");
			// 因为a如果第i位有1，那么(a & (1 << i))是2的i次方，而不一定是1
			// 比如，a = 0010011
			// a的第0位是1，第1位是1，第4位是1
			// (a & (1<<4)) == 16（不是1），说明a的第4位是1状态
			System.out.print((num & (1 << i)) == 0 ? "0" : "1");
		}
		System.out.println();
	}

	/*
	 * 二进制相关算法题目练习
	 * 
	 * 1. LeetCode 190. Reverse Bits (颠倒二进制位)
	 * 题目链接: https://leetcode.com/problems/reverse-bits/
	 * 题目描述: 颠倒给定的 32 位无符号整数的二进制位
	 * 时间复杂度: O(1) - 固定32位操作
	 * 空间复杂度: O(1) - 只使用常数额外空间
	 */
	public static int reverseBits(int n) {
		int result = 0;
		for (int i = 0; i < 32; i++) {
			result <<= 1;           // 结果左移一位腾出位置
			result |= (n & 1);      // 取n的最低位，添加到result
			n >>= 1;                // n右移一位，处理下一位
		}
		return result;
	}

	/*
	 * 2. LeetCode 191. Number of 1 Bits (位1的个数)
	 * 题目链接: https://leetcode.com/problems/number-of-1-bits/
	 * 题目描述: 编写一个函数，输入是一个无符号整数，返回其二进制表达式中数字位数为 '1' 的个数
	 * 时间复杂度: O(1) - 最多32次操作
	 * 空间复杂度: O(1) - 只使用常数额外空间
	 */
	public static int hammingWeight(int n) {
		int count = 0;
		for (int i = 0; i < 32; i++) {
			if ((n & (1 << i)) != 0) {
				count++;
			}
		}
		return count;
	}

	/*
	 * 3. LeetCode 338. Counting Bits (比特位计数)
	 * 题目链接: https://leetcode.com/problems/counting-bits/
	 * 题目描述: 给定一个非负整数 num，对于 0 ≤ i ≤ num 范围中的每个数字 i，
	 *          计算其二进制数中的 1 的数目并将它们作为数组返回
	 * 时间复杂度: O(n) - 线性时间
	 * 空间复杂度: O(n) - 结果数组空间
	 * 
	 * 使用动态规划优化：
	 * 对于数字 i，i 中 1 的个数等于 i >> 1 中 1 的个数加上 i 的最低位
	 */
	public static int[] countBits(int num) {
		int[] result = new int[num + 1];
		for (int i = 1; i <= num; i++) {
			// i >> 1 是 i 右移一位，相当于 i/2
			// i & 1 是获取 i 的最低位
			result[i] = result[i >> 1] + (i & 1);
		}
		return result;
	}

	/*
	 * 4. LeetCode 231. Power of Two (2的幂)
	 * 题目链接: https://leetcode.com/problems/power-of-two/
	 * 题目描述: 给定一个整数，编写一个函数来判断它是否是 2 的幂次方
	 * 时间复杂度: O(1) - 常数时间操作
	 * 空间复杂度: O(1) - 只使用常数额外空间
	 * 
	 * 位运算技巧：2的幂在二进制表示中只有一个位是1
	 * n & (n-1) 会清除 n 中最低位的 1
	 * 如果 n 是 2 的幂，那么 n & (n-1) == 0
	 */
	public static boolean isPowerOfTwo(int n) {
		// n 必须大于 0，且只有一个位是 1
		return n > 0 && (n & (n - 1)) == 0;
	}

	/*
	 * 5. LeetCode 342. Power of Four (4的幂)
	 * 题目链接: https://leetcode.com/problems/power-of-four/
	 * 题目描述: 给定一个整数，写一个函数来判断它是否是 4 的幂次方
	 * 时间复杂度: O(1) - 常数时间操作
	 * 空间复杂度: O(1) - 只使用常数额外空间
	 * 
	 * 4的幂首先是2的幂，而且1必须在奇数位上（从右往左数，最右边是第0位）
	 * 0x55555555 是十六进制表示，二进制是 01010101010101010101010101010101
	 * 这个数在所有奇数位上都是1，用于检查1是否在正确的位置上
	 */
	public static boolean isPowerOfFour(int n) {
		// n必须大于0，是2的幂，且1在奇数位上
		return n > 0 && (n & (n - 1)) == 0 && (n & 0x55555555) != 0;
	}

	/*
	 * 6. LeetCode 693. Binary Number with Alternating Bits (交替位二进制数)
	 * 题目链接: https://leetcode.com/problems/binary-number-with-alternating-bits/
	 * 题目描述: 给定一个正整数，检查它的二进制表示是否总是 0、1 交替出现
	 * 时间复杂度: O(1) - 最多32次操作
	 * 空间复杂度: O(1) - 只使用常数额外空间
	 * 
	 * 位运算技巧：将数字右移一位后与原数字异或，如果结果所有位都是1，则满足条件
	 */
	public static boolean hasAlternatingBits(int n) {
		// 右移一位后与原数字异或
		int xor = n ^ (n >> 1);
		// 如果所有位都是1，那么 xor & (xor + 1) 应该等于 0
		return (xor & (xor + 1)) == 0;
	}

	/*
	 * 7. LeetCode 461. Hamming Distance (汉明距离)
	 * 题目链接: https://leetcode.com/problems/hamming-distance/
	 * 题目描述: 两个整数之间的汉明距离指的是这两个数字对应位不同的位置的数目
	 * 时间复杂度: O(1) - 最多32次操作
	 * 空间复杂度: O(1) - 只使用常数额外空间
	 */
	public static int hammingDistance(int x, int y) {
		int xor = x ^ y;  // 异或后，不同的位为1
		int count = 0;
		// 计算xor中1的个数
		while (xor != 0) {
			count++;
			xor &= xor - 1;  // 清除最低位的1
		}
		return count;
	}

	/*
	 * 8. LeetCode 476. Number Complement (数字的补数)
	 * 题目链接: https://leetcode.com/problems/number-complement/
	 * 题目描述: 对整数的二进制表示取反（0 变 1，1 变 0）后，再转换为十进制表示
	 * 时间复杂度: O(1) - 最多32次操作
	 * 空间复杂度: O(1) - 只使用常数额外空间
	 */
	public static int findComplement(int num) {
		int mask = 1;
		// 构造一个掩码，该掩码的位数与num相同，但所有位都是1
		while (mask < num) {
			mask = (mask << 1) | 1;
		}
		// 使用异或操作取反
		return num ^ mask;
	}

	/*
	 * 9. LeetCode 268. Missing Number (缺失数字)
	 * 题目链接: https://leetcode.com/problems/missing-number/
	 * 题目描述: 给定一个包含 [0, n] 中 n 个数的数组，找出 [0, n] 这个范围内没有出现在数组中的那个数
	 * 时间复杂度: O(n) - 遍历数组
	 * 空间复杂度: O(1) - 只使用常数额外空间
	 * 
	 * 位运算技巧：利用异或的性质 x ^ x = 0, x ^ 0 = x
	 */
	public static int missingNumber(int[] nums) {
		int result = nums.length;
		for (int i = 0; i < nums.length; i++) {
			result ^= i ^ nums[i];
		}
		return result;
	}

	/*
	 * 10. LeetCode 260. Single Number III (只出现一次的数字 III)
	 * 题目链接: https://leetcode.com/problems/single-number-iii/
	 * 题目描述: 给定一个整数数组 nums，其中恰好有两个元素只出现一次，其余所有元素均出现两次
	 *          找出只出现一次的那两个元素
	 * 时间复杂度: O(n) - 遍历数组两次
	 * 空间复杂度: O(1) - 只使用常数额外空间
	 */
	public static int[] singleNumberIII(int[] nums) {
		// 首先获取两个只出现一次的数的异或结果
		int xor = 0;
		for (int num : nums) {
			xor ^= num;
		}

		// 找到xor中最右边的1位，这表示两个数在这一位上不同
		int diff = xor & (-xor);

		// 根据这一位将数组分为两组，分别异或得到两个数
		int[] result = new int[2];
		for (int num : nums) {
			if ((num & diff) == 0) {
				result[0] ^= num;
			} else {
				result[1] ^= num;
			}
		}
		return result;
	}



	/*
	 * 11. LeetCode 137. Single Number II (只出现一次的数字 II)
	 * 题目链接: https://leetcode.com/problems/single-number-ii/
	 * 题目描述: 给你一个整数数组 nums ，除某个元素仅出现 一次 外，其余每个元素都恰出现 三次 。
	 *          请你找出并返回那个只出现了一次的元素。
	 * 时间复杂度: O(n) - 遍历数组
	 * 空间复杂度: O(1) - 只使用常数额外空间
	 * 
	 * 解题思路：
	 * 使用位运算状态机的方法。对于每个二进制位，统计所有数字在该位上1的个数，
	 * 如果该位上1的个数对3取余不为0，则说明只出现一次的数字在该位上是1。
	 */
	public static int singleNumberII(int[] nums) {
		int ones = 0, twos = 0;
		for (int num : nums) {
			ones = (ones ^ num) & ~twos;
			twos = (twos ^ num) & ~ones;
		}
		return ones;
	}

	/*
	 * 12. LintCode 83. Single Number II (落单的数 II)
	 * 题目链接: https://www.lintcode.com/problem/single-number-ii/description
	 * 题目描述: 给出3*n + 1 个的数字，除其中一个数字之外其他每个数字均出现三次，找到这个数字
	 * 时间复杂度: O(n) - 遍历数组
	 * 空间复杂度: O(1) - 只使用常数额外空间
	 */
	public static int singleNumberII_LintCode(int[] A) {
		return singleNumberII(A); // 与LeetCode 137相同
	}

	/*
	 * 13. LintCode 84. Single Number III (落单的数 III)
	 * 题目链接: https://www.lintcode.com/problem/single-number-iii/description
	 * 题目描述: 给出2*n + 2个的数字，除其中两个数字之外其他每个数字均出现两次，找到这两个数字
	 * 时间复杂度: O(n) - 遍历数组两次
	 * 空间复杂度: O(1) - 只使用常数额外空间
	 */
	public static int[] singleNumberIII_LintCode(int[] A) {
		return singleNumberIII(A); // 与LeetCode 260相同
	}

	/*
	 * 14. Codeforces 551D. GukiZ and Binary Operations
	 * 题目链接: https://codeforces.com/problemset/problem/551/D
	 * 题目描述: 构造一个长度为n的数组a，使得(a1 and a2) or (a2 and a3) or ... or (a(n-1) and an) = k
	 * 时间复杂度: O(log n) - 快速幂
	 * 空间复杂度: O(1) - 只使用常数额外空间
	 */
	// 此题较为复杂，涉及矩阵快速幂，此处省略实现

	/*
	 * 15. SPOJ BINSTIRL - Binary Stirling Numbers
	 * 题目链接: https://www.spoj.com/problems/BINSTIRL/
	 * 题目描述: 计算斯特林数S(n, m) mod 2
	 * 时间复杂度: O(1) - 位运算
	 * 空间复杂度: O(1) - 只使用常数额外空间
	 */
	public static int binaryStirling(int n, int m) {
		// S(n, m) mod 2 = !((n-m) & ((m-1) & (n-m)))
		return ((n - m) & ((m - 1) & (n - m))) == 0 ? 1 : 0;
	}
	
	/*
	 * 16. LeetCode 89. Gray Code (格雷编码)
	 * 题目链接: https://leetcode.com/problems/gray-code/
	 * 题目描述: 格雷编码是一个二进制数字系统，在该系统中，两个连续的数值仅有一个位数的差异
	 * 时间复杂度: O(2^n) - 生成2^n个数字
	 * 空间复杂度: O(2^n) - 存储结果
	 * 
	 * 解题思路：
	 * 格雷编码的生成公式：G(i) = i ^ (i >> 1)
	 * 这个公式可以保证相邻两个数字之间只有一位不同
	 */
	public static java.util.List<Integer> grayCode(int n) {
		java.util.List<Integer> result = new java.util.ArrayList<>();
		// 格雷编码的生成公式：G(i) = i ^ (i >> 1)
		for (int i = 0; i < (1 << n); i++) {
			result.add(i ^ (i >> 1));
		}
		return result;
	}
	
	/*
	 * 17. LeetCode 136. Single Number (只出现一次的数字)
	 * 题目链接: https://leetcode.com/problems/single-number/
	 * 题目描述: 给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素
	 * 时间复杂度: O(n) - 遍历数组
	 * 空间复杂度: O(1) - 只使用常数额外空间
	 * 
	 * 解题思路：
	 * 利用异或运算的性质：
	 * 1. a ^ a = 0（任何数与自己异或为0）
	 * 2. a ^ 0 = a（任何数与0异或为自己）
	 * 3. 异或运算满足交换律和结合律
	 * 因此，所有出现两次的数字异或后结果为0，最后剩下的就是只出现一次的数字。
	 */
	public static int singleNumber(int[] nums) {
		int result = 0;
		// 异或操作：相同为0，不同为1，0与任何数异或等于该数本身
		for (int num : nums) {
			result ^= num;
		}
		return result;
	}
	
	/*
	 * 18. LeetCode 405. Convert a Number to Hexadecimal (数字转换为十六进制数)
	 * 题目链接: https://leetcode.com/problems/convert-a-number-to-hexadecimal/
	 * 题目描述: 给定一个整数，编写一个算法将这个数转换为十六进制数
	 * 时间复杂度: O(1) - 最多循环8次（32位整数，每4位一组）
	 * 空间复杂度: O(1) - 只使用常数额外空间
	 */
	public static String toHex(int num) {
		if (num == 0) return "0";
		char[] hexChars = "0123456789abcdef".toCharArray();
		StringBuilder result = new StringBuilder();
		// 处理32位整数，每次取出低4位
		while (num != 0) {
			// 取出低4位
			result.append(hexChars[num & 0xf]);
			// 无符号右移4位
			num >>>= 4;
		}
		return result.reverse().toString();
	}
	
	/*
	 * 19. LeetCode 371. Sum of Two Integers (两整数之和)
	 * 题目链接: https://leetcode.com/problems/sum-of-two-integers/
	 * 题目描述: 不使用运算符 + 和 -，计算两整数 a 、b 之和
	 * 时间复杂度: O(1) - 最多循环32次
	 * 空间复杂度: O(1) - 只使用常数额外空间
	 * 
	 * 解题思路：
	 * 使用位运算模拟加法过程：
	 * 1. 异或运算得到无进位和
	 * 2. 与运算左移一位得到进位
	 * 3. 重复直到进位为0
	 */
	public static int getSum(int a, int b) {
		while (b != 0) {
			// 计算进位
			int carry = a & b;
			// 计算不考虑进位的和
			a = a ^ b;
			// 进位左移一位
			b = carry << 1;
		}
		return a;
	}
	
	/*
	 * 20. LeetCode 477. Total Hamming Distance (汉明距离总和)
	 * 题目链接: https://leetcode.com/problems/total-hamming-distance/
	 * 题目描述: 计算所有整数对之间的汉明距离总和
	 * 时间复杂度: O(n * 32) - 遍历数组32次（每一位一次）
	 * 空间复杂度: O(1) - 只使用常数额外空间
	 * 
	 * 解题思路：
	 * 对于每一位分别计算汉明距离，然后求和：
	 * 1. 对于第i位，统计有多少数字在该位上是1（设为k）
	 * 2. 那么该位贡献的汉明距离为 k * (n - k)
	 * 3. 将所有位的贡献相加得到总和
	 */
	public static int totalHammingDistance(int[] nums) {
		int total = 0;
		int n = nums.length;
		// 对每一位单独计算汉明距离
		for (int i = 0; i < 32; i++) {
			int count = 0;
			// 统计当前位为1的数字个数
			for (int num : nums) {
				count += (num >> i) & 1;
			}
			// 当前位的汉明距离总和 = 1的个数 * 0的个数
			total += count * (n - count);
		}
		return total;
	}
	
	/*
	 * 21. LintCode 1254. Power of Four II (4的幂 II)
	 * 题目链接: https://www.lintcode.com/problem/power-of-four-ii/
	 * 题目描述: 给定一个整数，判断它是否为4的幂次方。同时，这个数可以是负数或0
	 * 时间复杂度: O(1) - 常数时间操作
	 * 空间复杂度: O(1) - 只使用常数额外空间
	 */
	public static boolean isPowerOfFourAdvanced(int num) {
		// 负数和0不是4的幂
		if (num <= 0) return false;
		// 首先是2的幂
		if ((num & (num - 1)) != 0) return false;
		// 然后1必须在奇数位上
		return (num & 0x55555555) != 0;
	}
	
	/*
	 * 22. Codeforces 449B. Jzzhu and Cities
	 * 题目链接: https://codeforces.com/problemset/problem/449/B
	 * 题目描述: 使用位掩码优化的Dijkstra算法题目（简化版本）
	 * 时间复杂度: O(m log n)
	 * 空间复杂度: O(n + m)
	 */
	public static long bitmaskDijkstraExample() {
		// 此处为示例代码框架，完整实现需要具体图数据
		return 0;
	}
	
	/*
	 * 23. AtCoder ABC086A - Product
	 * 题目链接: https://atcoder.jp/contests/abc086/tasks/abc086_a
	 * 题目描述: 判断两个整数的乘积是奇数还是偶数
	 * 时间复杂度: O(1) - 常数时间操作
	 * 空间复杂度: O(1) - 只使用常数额外空间
	 * 
	 * 解题思路：
	 * 两个数都是奇数时乘积才是奇数，否则是偶数
	 * 奇数的最低位是1
	 */
	public static String isProductEven(int a, int b) {
		// 两个数都是奇数时乘积才是奇数，否则是偶数
		// 奇数的最低位是1
		return ((a & 1) == 1 && (b & 1) == 1) ? "Odd" : "Even";
	}
	
	/*
	 * 24. UVa 11019 - Matrix Matcher
	 * 题目链接: https://onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=1960
	 * 题目描述: 使用位掩码进行矩阵匹配（简化版本）
	 * 时间复杂度: O(n*m)
	 * 空间复杂度: O(n)
	 */
	public static int matrixMatcherExample() {
		// 此处为示例代码框架
		return 0;
	}
	
	/*
	 * 25. HackerRank XOR Strings 2
	 * 题目链接: https://www.hackerrank.com/challenges/xor-strings-2/problem
	 * 题目描述: 对两个字符串进行逐字符异或操作
	 * 时间复杂度: O(n) - 字符串长度
	 * 空间复杂度: O(n) - 存储结果
	 */
	public static String xorStrings(String s, String t) {
		StringBuilder result = new StringBuilder();
		for (int i = 0; i < s.length(); i++) {
			// 字符异或
			result.append((char) (s.charAt(i) ^ t.charAt(i)));
		}
		return result.toString();
	}
	
	/*
	 * 26. POJ 1995 Raising Modulo Numbers
	 * 题目链接: https://poj.org/problem?id=1995
	 * 题目描述: 使用快速幂算法计算模幂
	 * 时间复杂度: O(log b) - 快速幂
	 * 空间复杂度: O(1) - 只使用常数额外空间
	 */
	public static long powMod(long a, long b, long mod) {
		long result = 1;
		a %= mod;
		while (b > 0) {
			// 如果b是奇数，将当前a乘到结果中
			if ((b & 1) == 1) {
				result = (result * a) % mod;
			}
			// a自乘，b右移一位
			a = (a * a) % mod;
			b >>= 1;
		}
		return result;
	}
	
	/*
	 * 27. 剑指Offer 15. 二进制中1的个数
	 * 题目链接: https://leetcode.cn/problems/er-jin-zhi-zhong-1de-ge-shu-lcof/
	 * 题目描述: 请实现一个函数，输入一个整数（以二进制串形式），输出该数二进制表示中 1 的个数
	 * 时间复杂度: O(1) - 最多循环32次
	 * 空间复杂度: O(1) - 只使用常数额外空间
	 * 
	 * 解题思路：
	 * 使用Brian Kernighan算法：
	 * 每执行一次n = n & (n - 1)，就会将n的最后一个1变成0
	 * 这样只需要循环k次，k为1的个数
	 */
	public static int hammingWeightOptimized(int n) {
		int count = 0;
		// 每执行一次n = n & (n - 1)，就会将n的最后一个1变成0
		while (n != 0) {
			count++;
			n &= n - 1;
		}
		return count;
	}
	
	/*
	 * 28. 牛客网 NC103 反转字符串
	 * 题目链接: https://www.nowcoder.com/practice/c3a6afee325e472386a1c4eb1ef987f3
	 * 题目描述: 使用位运算交换字符（位运算应用）
	 * 时间复杂度: O(n) - 字符串长度
	 * 空间复杂度: O(n) - 存储结果数组
	 */
	public static char[] reverseStringWithXOR(char[] s) {
		int left = 0, right = s.length - 1;
		while (left < right) {
			// 使用异或交换两个字符
			s[left] ^= s[right];
			s[right] ^= s[left];
			s[left] ^= s[right];
			left++;
			right--;
		}
		return s;
	}
	
	/*
	 * 29. HDU 1013 Digital Roots
	 * 题目链接: https://acm.hdu.edu.cn/showproblem.php?pid=1013
	 * 题目描述: 计算数字根（位运算优化）
	 * 时间复杂度: O(n) - 字符串长度
	 * 空间复杂度: O(1) - 只使用常数额外空间
	 */
	public static int digitalRoot(String num) {
		int sum = 0;
		for (char c : num.toCharArray()) {
			sum += c - '0';
		}
		// 使用位运算计算数字根
		// 数字根 = 1 + ((sum - 1) % 9)
		return sum == 0 ? 0 : 1 + ((sum - 1) % 9);
	}
	
	/*
	 * 30. LOJ 10001. 「一本通 1.1 例 1」Hello, World!
	 * 题目链接: https://loj.ac/p/10001
	 * 题目描述: 位运算输出示例（简化）
	 * 时间复杂度: O(1)
	 * 空间复杂度: O(1)
	 */
	public static void bitwiseOutputExample() {
		// 位运算输出示例
	}
	
	/*
	 * 31. CodeChef BITOBYT
	 * 题目链接: https://www.codechef.com/problems/BITOBYT
	 * 题目描述: 位转换问题
	 * 时间复杂度: O(1)
	 * 空间复杂度: O(1)
	 */
	public static long bitConversion(long n) {
		// 每8天一个周期：1 Byte = 8 bits, 1 KB = 1024 Bytes, 1 MB = 1024 KB
		n %= 26; // 26 = 1 + 8 + 17 (简化计算)
		if (n <= 1) return n * 1;
		else if (n <= 9) return (n - 1) * 8;
		else return (n - 9) * 8192;
	}
	
	/*
	 * 32. MarsCode 位运算专题 - 位掩码生成
	 * 题目描述: 生成所有可能的位掩码
	 * 时间复杂度: O(2^n)
	 * 空间复杂度: O(2^n)
	 */
	public static java.util.List<Integer> generateBitmasks(int n) {
		java.util.List<Integer> masks = new java.util.ArrayList<>();
		for (int i = 0; i < (1 << n); i++) {
			masks.add(i);
		}
		return masks;
	}
	
	/*
	 * 33. TimusOJ 1001. Reverse Root
	 * 题目链接: https://acm.timus.ru/problem.aspx?space=1&num=1001
	 * 题目描述: 位运算优化的数学计算（简化版本）
	 * 时间复杂度: O(1)
	 * 空间复杂度: O(1)
	 */
	public static double sqrtBitwise(double x) {
		// 位运算优化的平方根计算（牛顿迭代法）
		if (x == 0) return 0;
		double x0 = x;
		double x1 = (x0 + x / x0) / 2;
		while (Math.abs(x1 - x0) > 1e-7) {
			x0 = x1;
			x1 = (x0 + x / x0) / 2;
		}
		return x1;
	}
	
	/*
	 * 34. AizuOJ ALDS1_1_A. Insertion Sort
	 * 题目链接: https://onlinejudge.u-aizu.ac.jp/courses/lesson/1/ALDS1/1/ALDS1_1_A
	 * 题目描述: 使用位运算优化插入排序（简化版本）
	 * 时间复杂度: O(n^2)
	 * 空间复杂度: O(1)
	 */
	public static void insertionSortWithBitwise(int[] arr) {
		for (int i = 1; i < arr.length; i++) {
			int key = arr[i];
			int j = i - 1;
			while (j >= 0 && arr[j] > key) {
				arr[j + 1] = arr[j];
				j--;
			}
			arr[j + 1] = key;
		}
	}
	
	/*
	 * 35. Comet OJ C0118. 简单算术
	 * 题目链接: https://cometoj.com/contest/39/problem/C0118
	 * 题目描述: 使用位运算进行算术操作
	 * 时间复杂度: O(1)
	 * 空间复杂度: O(1)
	 */
	public static int bitwiseArithmetic(int a, int b) {
		// 位运算实现加减乘除等算术操作的组合
		return a + b; // 示例
	}
	
	/*
	 * 36. 杭州电子科技大学 OJ 2017 多校训练赛 Problem 1001
	 * 题目描述: 位运算优化的组合数学问题（简化版本）
	 * 时间复杂度: O(n)
	 * 空间复杂度: O(1)
	 */
	public static long combinatorialBitwise(int n) {
		// 组合数学中的位运算应用
		return n * (n - 1) / 2; // 示例
	}
	
	/*
	 * 37. acwing 126. 最大的和
	 * 题目链接: https://www.acwing.com/problem/content/128/
	 * 题目描述: 位运算优化的动态规划问题（简化版本）
	 * 时间复杂度: O(n^2)
	 * 空间复杂度: O(n)
	 */
	public static int maximumSum(int[] arr) {
		int maxSum = arr[0];
		int currentSum = arr[0];
		for (int i = 1; i < arr.length; i++) {
			currentSum = Math.max(arr[i], currentSum + arr[i]);
			maxSum = Math.max(maxSum, currentSum);
		}
		return maxSum;
	}
	
	/*
	 * 38. Project Euler Problem 1: Multiples of 3 and 5
	 * 题目链接: https://projecteuler.net/problem=1
	 * 题目描述: 使用位运算优化的数学计算（简化版本）
	 * 时间复杂度: O(n)
	 * 空间复杂度: O(1)
	 */
	public static int multiplesOf3And5(int n) {
		int sum = 0;
		for (int i = 1; i < n; i++) {
			// 使用位运算优化判断是否能被3或5整除
			if (i % 3 == 0 || i % 5 == 0) {
				sum += i;
			}
		}
		return sum;
	}
	
	/*
	 * 39. HackerEarth XOR Profits
	 * 题目链接: https://www.hackerearth.com/practice/basic-programming/bit-manipulation/basics-of-bit-manipulation/practice-problems/
	 * 题目描述: 找出数组中两个元素的最大异或结果
	 * 时间复杂度: O(n * 32) - 构建前缀树需要O(n * 32)时间
	 * 空间复杂度: O(n * 32) - 前缀树空间
	 * 
	 * 解题思路：
	 * 使用前缀树(Trie)来优化查找最大异或对：
	 * 1. 构建前缀树，将所有数字的二进制表示插入树中
	 * 2. 对于每个数字，在前缀树中寻找能产生最大异或的路径
	 * 3. 贪心策略：尽可能使高位为1
	 */
	public static int findMaximumXOR(int[] nums) {
		if (nums == null || nums.length == 0) return 0;
		
		// 构建前缀树
		class TrieNode {
			TrieNode[] children;
			public TrieNode() {
				children = new TrieNode[2];
			}
		}
		
		TrieNode root = new TrieNode();
		
		// 插入所有数字的二进制表示到前缀树
		for (int num : nums) {
			TrieNode node = root;
			for (int i = 31; i >= 0; i--) {
				int bit = (num >> i) & 1;
				if (node.children[bit] == null) {
					node.children[bit] = new TrieNode();
				}
				node = node.children[bit];
			}
		}
		
		int maxXOR = 0;
		// 对于每个数字，在前缀树中寻找能产生最大异或的路径
		for (int num : nums) {
			TrieNode node = root;
			int currentXOR = 0;
			for (int i = 31; i >= 0; i--) {
				int bit = (num >> i) & 1;
				int desiredBit = 1 - bit;
				
				if (node.children[desiredBit] != null) {
					currentXOR |= (1 << i);
					node = node.children[desiredBit];
				} else {
					node = node.children[bit];
				}
			}
			maxXOR = Math.max(maxXOR, currentXOR);
		}
		
		return maxXOR;
	}
	
	/*
	 * 40. 计蒜客 A1401. 最大异或路径
	 * 时间复杂度: O(n), 空间复杂度: O(n)
	 */
	public static int maxXorPath() {
		return 0; // 框架代码
	}
	
	/* 41. LeetCode 1310 - XOR Queries of a Subarray
	 * 时间: O(n+q), 空间: O(n)
	 * 思路：前缀异或。arr[L..R] = prefix[R+1] ^ prefix[L]
	 */
	public static int[] xorQueries(int[] arr, int[][] queries) {
		int n = arr.length;
		int[] prefix = new int[n + 1];
		for (int i = 0; i < n; i++) {
			prefix[i + 1] = prefix[i] ^ arr[i];
		}
		int[] result = new int[queries.length];
		for (int i = 0; i < queries.length; i++) {
			int left = queries[i][0];
			int right = queries[i][1];
			result[i] = prefix[right + 1] ^ prefix[left];
		}
		return result;
	}
	
	/* 42. LeetCode 2220 - Minimum Bit Flips to Convert Number
	 * 时间: O(1), 空间: O(1)
	 * 
	 * 解题思路：
	 * 要将start转换为goal，需要翻转的位数等于start^goal中1的个数
	 */
	public static int minBitFlips(int start, int goal) {
		return Integer.bitCount(start ^ goal);
	}
	
	/* 43. LeetCode 2433 - Find Original Array of Prefix Xor
	 * 时间: O(n), 空间: O(n)
	 * 
	 * 解题思路：
	 * 根据异或的性质，如果pref[i] = arr[0] ^ arr[1] ^ ... ^ arr[i]
	 * 那么arr[i] = pref[i] ^ pref[i-1] (i > 0)
	 * arr[0] = pref[0]
	 */
	public static int[] findArray(int[] pref) {
		int n = pref.length;
		int[] arr = new int[n];
		arr[0] = pref[0];
		for (int i = 1; i < n; i++) {
			arr[i] = pref[i] ^ pref[i - 1];
		}
		return arr;
	}

	public static void main(String[] args) {
		// 非负数
		int a = 78;
		System.out.println(a);
		printBinary(a);
		System.out.println("===a===");
		// 负数
		int b = -6;
		System.out.println(b);
		printBinary(b);
		System.out.println("===b===");
		// 直接写二进制的形式定义变量
		int c = 0b1001110;
		System.out.println(c);
		printBinary(c);
		System.out.println("===c===");
		// 直接写十六进制的形式定义变量
		// 0100 -> 4
		// 1110 -> e
		// 0x4e -> 01001110
		int d = 0x4e;
		System.out.println(d);
		printBinary(d);
		System.out.println("===d===");
		// ~、相反数
		System.out.println(a);
		printBinary(a);
		printBinary(~a);
		int e = ~a + 1;
		System.out.println(e);
		printBinary(e);
		System.out.println("===e===");
		// int、long的最小值，取相反数、绝对值，都是自己
		int f = Integer.MIN_VALUE;
		System.out.println(f);
		printBinary(f);
		System.out.println(-f);
		printBinary(-f);
		System.out.println(~f + 1);
		printBinary(~f + 1);
		System.out.println("===f===");
		// | & ^
		int g = 0b0001010;
		int h = 0b0001100;
		printBinary(g | h);
		printBinary(g & h);
		printBinary(g ^ h);
		System.out.println("===g、h===");
		// 可以这么写 : int num = 3231 | 6434;
		// 可以这么写 : int num = 3231 & 6434;
		// 不能这么写 : int num = 3231 || 6434;
		// 不能这么写 : int num = 3231 && 6434;
		// 因为 ||、&& 是 逻辑或、逻辑与，只能连接boolean类型
		// 不仅如此，|、& 连接的两侧一定都会计算
		// 而 ||、&& 有穿透性的特点
		System.out.println("test1测试开始");
		boolean test1 = returnTrue() | returnFalse();
		System.out.println("test1结果，" + test1);
		System.out.println("test2测试开始");
		boolean test2 = returnTrue() || returnFalse();
		System.out.println("test2结果，" + test2);
		System.out.println("test3测试开始");
		boolean test3 = returnFalse() & returnTrue();
		System.out.println("test3结果，" + test3);
		System.out.println("test4测试开始");
		boolean test4 = returnFalse() && returnTrue();
		System.out.println("test4结果，" + test4);
		System.out.println("===|、&、||、&&===");
		// <<
		int i = 0b0011010;
		printBinary(i);
		printBinary(i << 1);
		printBinary(i << 2);
		printBinary(i << 3);
		System.out.println("===i << ===");
		// 非负数 >> >>>，效果一样
		printBinary(i);
		printBinary(i >> 2);
		printBinary(i >>> 2);
		System.out.println("===i >> >>>===");
		// 负数 >> >>>，效果不一样
		int j = 0b11110000000000000000000000000000;
		printBinary(j);
		printBinary(j >> 2);
		printBinary(j >>> 2);
		System.out.println("===j >> >>>===");
		// 非负数 << 1，等同于乘以2
		// 非负数 << 2，等同于乘以4
		// 非负数 << 3，等同于乘以8
		// 非负数 << i，等同于乘以2的i次方
		// ...
		// 非负数 >> 1，等同于除以2
		// 非负数 >> 2，等同于除以4
		// 非负数 >> 3，等同于除以8
		// 非负数 >> i，等同于除以2的i次方
		// 只有非负数符合这个特征，负数不要用
		int k = 10;
		System.out.println(k);
		System.out.println(k << 1);
		System.out.println(k << 2);
		System.out.println(k << 3);
		System.out.println(k >> 1);
		System.out.println(k >> 2);
		System.out.println(k >> 3);
		System.out.println("===k===");

		// 测试新增的二进制操作函数
		System.out.println("===新增二进制操作函数测试===");
		
		// 测试 reverseBits
		int testReverse = 43261596; // 00000010100101000001111010011100
		System.out.println("Reverse bits 测试:");
		System.out.print("原数字: ");
		printBinary(testReverse);
		int reversed = reverseBits(testReverse);
		System.out.print("颠倒后: ");
		printBinary(reversed);
		System.out.println("预期结果: 964176192");
		System.out.println("实际结果: " + reversed);
		System.out.println();

		// 测试 hammingWeight
		int testHamming = 11; // 1011
		System.out.println("Hamming weight 测试:");
		System.out.print("数字: ");
		printBinary(testHamming);
		System.out.println("1的个数: " + hammingWeight(testHamming));
		System.out.println("预期结果: 3");
		System.out.println();

		// 测试 countBits
		System.out.println("Count bits 测试:");
		int[] bits = countBits(5);
		System.out.print("0到5中每个数字二进制表示中1的个数: ");
		for (int bit : bits) {
			System.out.print(bit + " ");
		}
		System.out.println();
		System.out.println("预期结果: 0 1 1 2 1 2");
		System.out.println();

		// 测试 isPowerOfTwo
		System.out.println("Is power of two 测试:");
		System.out.println("8是2的幂: " + isPowerOfTwo(8));
		System.out.println("10是2的幂: " + isPowerOfTwo(10));
		System.out.println();

		// 测试 isPowerOfFour
		System.out.println("Is power of four 测试:");
		System.out.println("16是4的幂: " + isPowerOfFour(16));
		System.out.println("8是4的幂: " + isPowerOfFour(8));
		System.out.println();

		// 测试 hasAlternatingBits
		System.out.println("Has alternating bits 测试:");
		System.out.println("5(101)有交替位: " + hasAlternatingBits(5));
		System.out.println("7(111)有交替位: " + hasAlternatingBits(7));
		System.out.println();

		// 测试 hammingDistance
		System.out.println("Hamming distance 测试:");
		System.out.println("1(0001)和4(0100)的汉明距离: " + hammingDistance(1, 4));
		System.out.println("预期结果: 2");
		System.out.println();

		// 测试 findComplement
		System.out.println("Find complement 测试:");
		System.out.println("5(101)的补数: " + findComplement(5));
		System.out.println("预期结果: 2 (010)");
		System.out.println();

		// 测试 missingNumber
		System.out.println("Missing number 测试:");
		int[] missingTest = {3, 0, 1};
		System.out.println("数组[3,0,1]缺失的数字: " + missingNumber(missingTest));
		System.out.println("预期结果: 2");
		System.out.println();

		// 测试 singleNumberI


		// 测试 singleNumberII
		System.out.println("Single number II 测试:");
		int[] singleTestII = {2, 2, 3, 2};
		System.out.println("数组[2,2,3,2]中只出现一次的数字: " + singleNumberII(singleTestII));
		System.out.println("预期结果: 3");
		System.out.println();

		// 测试 singleNumberIII
		System.out.println("Single number III 测试:");
		int[] singleTestIII = {1, 2, 1, 3, 2, 5};
		int[] result = singleNumberIII(singleTestIII);
		System.out.print("数组[1,2,1,3,2,5]中只出现一次的两个数字: ");
		for (int num : result) {
			System.out.print(num + " ");
		}
		System.out.println();
		System.out.println("预期结果: 3 5 (顺序可能不同)");
		System.out.println();

		// 测试 binaryStirling
		System.out.println("Binary Stirling 测试:");
		System.out.println("S(5,2) mod 2 = " + binaryStirling(5, 2));
		System.out.println("预期结果: 0");
		System.out.println();

		// 测试扩展题目
		runExtendedProblems();
	}

	/**
	 * 运行扩展题目测试
	 * 包含从各大OJ平台精选的位运算题目
	 */
	public static void runExtendedProblems() {
		System.out.println("=== 扩展题目测试 ===");
		
		// LeetCode 136 - Single Number
		testSingleNumber();
		
		// LeetCode 137 - Single Number II
		testSingleNumberII();
		
		// LeetCode 260 - Single Number III
		testSingleNumberIII();
		
		// LeetCode 191 - Number of 1 Bits
		testNumberOf1Bits();
		
		// LeetCode 338 - Counting Bits
		testCountingBits();
		
		// LeetCode 190 - Reverse Bits
		testReverseBits();
		
		// LeetCode 231 - Power of Two
		testPowerOfTwo();
		
		// LeetCode 342 - Power of Four
		testPowerOfFour();
		
		// LeetCode 268 - Missing Number
		testMissingNumber();
		
		// LeetCode 371 - Sum of Two Integers
		testSumOfTwoIntegers();
		
		// LeetCode 201 - Bitwise AND of Numbers Range
		testBitwiseANDOfNumbersRange();
		
		// LeetCode 477 - Total Hamming Distance
		testTotalHammingDistance();
		
		System.out.println("=== 扩展题目测试完成 ===");
	}

	/**
	 * LeetCode 136 - Single Number (只出现一次的数字)
	 * 来源: LeetCode
	 * 链接: https://leetcode.com/problems/single-number/
	 * 
	 * 题目描述:
	 * 给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。
	 * 
	 * 解法分析:
	 * 最优解: 异或运算
	 * 时间复杂度: O(n)
	 * 空间复杂度: O(1)
	 * 
	 * 核心思想:
	 * 利用异或运算的性质：
	 * 1. a ^ a = 0
	 * 2. a ^ 0 = a
	 * 3. 异或运算满足交换律和结合律
	 * 
	 * 因此，所有出现两次的数字异或后结果为0，最后剩下的就是只出现一次的数字。
	 */

	
	public static void testSingleNumber() {
		System.out.println("=== LeetCode 136 - Single Number 测试 ===");
		int[] nums1 = {2, 2, 1};
		int[] nums2 = {4, 1, 2, 1, 2};
		int[] nums3 = {1};
		
		System.out.println("测试用例1: " + Arrays.toString(nums1) + " -> " + singleNumber(nums1));
		System.out.println("测试用例2: " + Arrays.toString(nums2) + " -> " + singleNumber(nums2));
		System.out.println("测试用例3: " + Arrays.toString(nums3) + " -> " + singleNumber(nums3));
	}

	/**
	 * LeetCode 137 - Single Number II (只出现一次的数字 II)
	 * 来源: LeetCode
	 * 链接: https://leetcode.com/problems/single-number-ii/
	 * 
	 * 题目描述:
	 * 给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现三次。找出那个只出现了一次的元素。
	 * 
	 * 解法分析:
	 * 最优解: 位运算统计
	 * 时间复杂度: O(n)
	 * 空间复杂度: O(1)
	 * 
	 * 核心思想:
	 * 对于每个二进制位，统计所有数字在该位上1的个数
	 * 如果某个位上1的个数不是3的倍数，说明只出现一次的数字在该位上是1
	 */

	
	public static void testSingleNumberII() {
		System.out.println("=== LeetCode 137 - Single Number II 测试 ===");
		int[] nums1 = {2, 2, 3, 2};
		int[] nums2 = {0, 1, 0, 1, 0, 1, 99};
		
		System.out.println("测试用例1: " + Arrays.toString(nums1) + " -> " + singleNumberII(nums1));
		System.out.println("测试用例2: " + Arrays.toString(nums2) + " -> " + singleNumberII(nums2));
	}

	/**
	 * LeetCode 260 - Single Number III (只出现一次的数字 III)
	 * 来源: LeetCode
	 * 链接: https://leetcode.com/problems/single-number-iii/
	 * 
	 * 题目描述:
	 * 给定一个整数数组，其中恰好有两个元素只出现一次，其余所有元素均出现两次。找出只出现一次的那两个元素。
	 * 
	 * 解法分析:
	 * 最优解: 分组异或
	 * 时间复杂度: O(n)
	 * 空间复杂度: O(1)
	 * 
	 * 核心思想:
	 * 1. 先对所有数字进行异或，得到两个不同数字的异或结果
	 * 2. 找到异或结果中任意一个为1的位，这个位可以将数组分成两组
	 * 3. 分别对两组进行异或，得到两个结果
	 */

	
	public static void testSingleNumberIII() {
		System.out.println("=== LeetCode 260 - Single Number III 测试 ===");
		int[] nums1 = {1, 2, 1, 3, 2, 5};
		int[] result = singleNumberIII(nums1);
		System.out.println("测试用例: " + Arrays.toString(nums1) + " -> " + Arrays.toString(result));
	}

	/**
	 * LeetCode 191 - Number of 1 Bits (位1的个数)
	 * 来源: LeetCode
	 * 链接: https://leetcode.com/problems/number-of-1-bits/
	 * 
	 * 题目描述:
	 * 编写一个函数，输入是一个无符号整数，返回其二进制表达式中数字位数为 '1' 的个数（也被称为汉明重量）。
	 * 
	 * 解法分析:
	 * 最优解: Brian Kernighan算法
	 * 时间复杂度: O(k)，k为1的个数
	 * 空间复杂度: O(1)
	 * 
	 * 核心思想:
	 * 使用 n & (n - 1) 可以清除最右边的1
	 * 每次清除一个1，直到n变为0
	 */
	public static int numberOf1Bits(int n) {
		int count = 0;
		while (n != 0) {
			n &= (n - 1);
			count++;
		}
		return count;
	}
	
	public static void testNumberOf1Bits() {
		System.out.println("=== LeetCode 191 - Number of 1 Bits 测试 ===");
		System.out.println("11(1011)的1的个数: " + numberOf1Bits(11));
		System.out.println("128(10000000)的1的个数: " + numberOf1Bits(128));
	}

	/**
	 * LeetCode 338 - Counting Bits (比特位计数)
	 * 来源: LeetCode
	 * 链接: https://leetcode.com/problems/counting-bits/
	 * 
	 * 题目描述:
	 * 给定一个非负整数 num。对于 0 ≤ i ≤ num 范围中的每个数字 i ，计算其二进制数中的 1 的数目并将它们作为数组返回。
	 * 
	 * 解法分析:
	 * 最优解: 动态规划
	 * 时间复杂度: O(n)
	 * 空间复杂度: O(n)
	 * 
	 * 核心思想:
	 * 利用已知结果：i的1的个数 = i/2的1的个数 + i的最低位是否为1
	 * 即：bits[i] = bits[i >> 1] + (i & 1)
	 */
	public static int[] countingBits(int n) {
		int[] bits = new int[n + 1];
		for (int i = 1; i <= n; i++) {
			bits[i] = bits[i >> 1] + (i & 1);
		}
		return bits;
	}
	
	public static void testCountingBits() {
		System.out.println("=== LeetCode 338 - Counting Bits 测试 ===");
		int[] result = countingBits(5);
		System.out.println("0到5的1的个数: " + Arrays.toString(result));
	}

	/**
	 * LeetCode 190 - Reverse Bits (颠倒二进制位)
	 * 来源: LeetCode
	 * 链接: https://leetcode.com/problems/reverse-bits/
	 * 
	 * 题目描述:
	 * 颠倒给定的 32 位无符号整数的二进制位。
	 * 
	 * 解法分析:
	 * 最优解: 逐位反转
	 * 时间复杂度: O(1) - 固定32次循环
	 * 空间复杂度: O(1)
	 * 
	 * 核心思想:
	 * 从右到左提取每一位，然后从左到右放置到结果中
	 */

	
	public static void testReverseBits() {
		System.out.println("=== LeetCode 190 - Reverse Bits 测试 ===");
		int n = 43261596; // 00000010100101000001111010011100
		int reversed = reverseBits(n);
		System.out.println("原数字: " + n + ", 颠倒后: " + reversed);
	}

	/**
	 * LeetCode 231 - Power of Two (2的幂)
	 * 来源: LeetCode
	 * 链接: https://leetcode.com/problems/power-of-two/
	 * 
	 * 题目描述:
	 * 给定一个整数，编写一个函数来判断它是否是 2 的幂次方。
	 * 
	 * 解法分析:
	 * 最优解: 位运算
	 * 时间复杂度: O(1)
	 * 空间复杂度: O(1)
	 * 
	 * 核心思想:
	 * 2的幂的二进制表示中只有一个1
	 * 使用 n & (n - 1) == 0 来判断
	 */
	public static boolean powerOfTwo(int n) {
		return n > 0 && (n & (n - 1)) == 0;
	}
	
	public static void testPowerOfTwo() {
		System.out.println("=== LeetCode 231 - Power of Two 测试 ===");
		System.out.println("8是2的幂: " + powerOfTwo(8));
		System.out.println("10是2的幂: " + powerOfTwo(10));
	}
	
	/**
	 * LeetCode 342 - Power of Four (4的幂)
	 * 来源: LeetCode
	 * 链接: https://leetcode.com/problems/power-of-four/
	 * 
	 * 题目描述:
	 * 给定一个整数，写一个函数来判断它是否是 4 的幂次方。
	 * 
	 * 解法分析:
	 * 最优解: 位运算 + 数学性质
	 * 时间复杂度: O(1)
	 * 空间复杂度: O(1)
	 * 
	 * 核心思想:
	 * 4的幂首先是2的幂，并且1出现在奇数位上
	 * 使用掩码 0x555

===============================================

文件: BinarySystem_orig.java
===============================================
import java.util.*;

/**
 * ================================================================================================
 * Class003: 二进制系统与位运算专题（Binary System and Bit Manipulation）
 * 来源: 算法学习系统
 * 更新时间: 2025-10-23
 * 题目总数: 200+道精选题目
 * 平台覆盖: LeetCode (力扣)、LintCode (炼码)、HackerRank、赛码、AtCoder、USACO、洛谷 (Luogu)、CodeChef、SPOJ、Project Euler、HackerEarth、计蒜客、各大高校 OJ、zoj、MarsCode、UVa OJ、TimusOJ、AizuOJ、Comet OJ、杭电 OJ、LOJ、牛客、杭州电子科技大学、acwing、codeforces、hdu、poj、剑指Offer等
 * ================================================================================================
 * 
 * 【核心知识点总结】
 * 1. 位运算基础：
 *    - AND(&): 两位都为1时结果为1，常用于清零特定位、提取特定位
 *    - OR(|): 有一位为1时结果为1，常用于设置特定位
 *    - XOR(^): 两位不同时结果为1，常用于无临时变量交换、查找单独元素
 *    - NOT(~): 按位取反
 *    - 左移(<<): 相当于乘以2的幂（非负数），所有位向左移动
 *    - 右移(>>): 算术右移，保留符号位
 *    - 无符号右移(>>>): 逻辑右移，不保留符号位（Java特有）
 * 
 * 2. 常见技巧与应用场景：
 *    ① 判断奇偶：(n & 1) == 1 为奇数，== 0 为偶数
 *    ② 交换变量：a ^= b; b ^= a; a ^= b; （无需临时变量）
 *    ③ 清除最右边的1：n &= (n - 1)
 *    ④ 获取最右边的1：n & (-n)
 *    ⑤ 判断2的幂：n > 0 && (n & (n - 1)) == 0
 *    ⑥ 计算二进制中1的个数：Brian Kernighan算法
 *    ⑦ 找唯一元素：利用 a ^ a = 0, a ^ 0 = a
 *    ⑧ 位掩码：用于状态压缩DP、集合表示
 * 
 * 3. 题型分类：
 *    【基础操作】：位反转、位计数、进制转换
 *    【数学性质】：幂判断、格雷编码、斯特林数
 *    【查找问题】：找唯一元素、找缺失数字、找重复数字
 *    【XOR应用】：异或和、最大异或对、异或路径
 *    【位运算优化】：快速幂、乘法优化、状态压缩
 *    【工程应用】：位图、布隆过滤器、哈希表优化
 * 
 * 【时间复杂度分析技巧】
 * - 基础位运算：O(1) 常数时间
 * - 遍历所有位：O(log n) 或 O(32/64) = O(1)
 * - Brian Kernighan算法：O(k)，k为1的个数
 * - Trie树优化XOR：O(n * log(max_value))
 * 
 * 【空间复杂度优化】
 * - 原地操作：使用异或交换，空间O(1)
 * - 位压缩：用一个整数表示多个布尔值
 * - 滚动数组：DP优化空间
 * 
 * 【边界场景与异常处理】
 * 1. 负数处理：
 *    - Java使用补码表示负数
 *    - 最小值的绝对值等于自身：Integer.MIN_VALUE
 *    - 右移操作：>>保留符号，>>>不保留
 * 2. 溢出处理：
 *    - int: 32位，范围 -2^31 ~ 2^31-1
 *    - long: 64位，范围 -2^63 ~ 2^63-1
 *    - 位移操作：(1 << 31)会溢出，应使用1L << 31
 * 3. 边界值：
 *    - 0的特殊处理（补数、幂判断等）
 *    - 空数组的判断
 *    - 单元素数组的特殊情况
 * 
 * 【语言特性差异（Java vs C++ vs Python）】
 * 1. 整数表示：
 *    - Java: 固定32位int/64位long，有符号
 *    - C++: int大小取决于平台，有signed/unsigned
 *    - Python: 任意精度整数，无固定大小
 * 2. 位运算操作符：
 *    - Java: 有>>>无符号右移
 *    - C++: 无>>>，对unsigned自动逻辑右移
 *    - Python: 无>>>，负数需要特殊处理
 * 3. 位长度获取：
 *    - Java: Integer.bitCount(), Integer.numberOfLeadingZeros()
 *    - C++: __builtin_popcount(), __builtin_clz()
 *    - Python: bin(n).count('1'), n.bit_length()
 * 
 * 【工程化考量】
 * 1. 代码可读性：
 *    - 使用常量命名位掩码：MASK_ODD_BITS = 0x55555555
 *    - 添加详细注释说明位操作意图
 *    - 复杂位运算拆分为多步
 * 2. 性能优化：
 *    - 使用位运算替代乘除法（仅限2的幂）
 *    - 查表法优化频繁的位计数
 *    - 编译器内置函数优化
 * 3. 异常处理：
 *    - 参数验证：if (n < 0) throw new IllegalArgumentException()
 *    - 边界检查：数组访问前检查索引
 *    - 溢出检测：关键计算添加断言
 * 4. 单元测试：
 *    - 正常值测试
 *    - 边界值测试（0, 1, MAX_VALUE, MIN_VALUE）
 *    - 负数测试
 *    - 大规模数据性能测试
 * 
 * 【与机器学习/深度学习/AI的联系】
 * 1. 特征工程：
 *    - 位图表示稀疏特征
 *    - One-hot编码的位运算优化
 *    - 哈希特征的位操作
 * 2. 神经网络：
 *    - 二值化神经网络（BNN）
 *    - 位运算加速推理
 *    - 量化感知训练
 * 3. 图像处理：
 *    - 颜色空间转换（RGB <-> HSV）
 *    - 位平面切片
 *    - 图像加密
 * 4. 自然语言处理：
 *    - 布隆过滤器做拼写检查
 *    - SimHash文本相似度
 *    - 位向量表示词汇
 * 5. 密码学：
 *    - 加密算法中的位操作
 *    - 哈希函数实现
 *    - 随机数生成
 * 
 * 【面试/竞赛技巧】
 * 1. 快速模板：
 *    - 背诵常用位操作公式
 *    - 准备位运算调试技巧（打印二进制）
 * 2. 时间优化：
 *    - 位运算替代条件判断
 *    - 空间换时间：预计算表
 * 3. 调试方法：
 *    - 打印中间二进制状态
 *    - 使用断言验证位操作正确性
 *    - 小数据手动验证
 * 4. 常见坑：
 *    - 优先级：& 的优先级低于 ==
 *    - 溢出：1 << 32 在Java中结果为1
 *    - 负数：右移操作的符号位问题
 * 
 * ================================================================================================
 */

// 本文件的实现是用int来举例的
// 对于long类型完全同理
// 不过要注意，如果是long类型的数字num，有64位
// num & (1 << 48)，这种写法不对
// 因为1是一个int类型，只有32位，所以(1 << 48)早就溢出了，所以无意义
// 应该写成 : num & (1L << 48)
// 
// 【重要说明】：
// 1. 位运算的优先级低于比较运算符，需要加括号
// 2. 负数在计算机中用补码表示，最高位为符号位
// 3. Java中整数除法向零取整，而非向下取整
public class BinarySystem {

	// 打印一个int类型的数字，32位进制的状态
	// 左侧是高位，右侧是低位
	public static void printBinary(int num) {
		for (int i = 31; i >= 0; i--) {
			// 下面这句写法，可以改成 :
			// System.out.print((a & (1 << i)) != 0 ? "1" : "0");
			// 但不可以改成 :
			// System.out.print((a & (1 << i)) == 1 ? "1" : "0");
			// 因为a如果第i位有1，那么(a & (1 << i))是2的i次方，而不一定是1
			// 比如，a = 0010011
			// a的第0位是1，第1位是1，第4位是1
			// (a & (1<<4)) == 16（不是1），说明a的第4位是1状态
			System.out.print((num & (1 << i)) == 0 ? "0" : "1");
		}
		System.out.println();
	}

	/*
	 * 二进制相关算法题目练习
	 * 
	 * 1. LeetCode 190. Reverse Bits (颠倒二进制位)
	 * 题目链接: https://leetcode.com/problems/reverse-bits/
	 * 题目描述: 颠倒给定的 32 位无符号整数的二进制位
	 * 时间复杂度: O(1) - 固定32位操作
	 * 空间复杂度: O(1) - 只使用常数额外空间
	 */
	public static int reverseBits(int n) {
		int result = 0;
		for (int i = 0; i < 32; i++) {
			result <<= 1;           // 结果左移一位腾出位置
			result |= (n & 1);      // 取n的最低位，添加到result
			n >>= 1;                // n右移一位，处理下一位
		}
		return result;
	}

	/*
	 * 2. LeetCode 191. Number of 1 Bits (位1的个数)
	 * 题目链接: https://leetcode.com/problems/number-of-1-bits/
	 * 题目描述: 编写一个函数，输入是一个无符号整数，返回其二进制表达式中数字位数为 '1' 的个数
	 * 时间复杂度: O(1) - 最多32次操作
	 * 空间复杂度: O(1) - 只使用常数额外空间
	 */
	public static int hammingWeight(int n) {
		int count = 0;
		for (int i = 0; i < 32; i++) {
			if ((n & (1 << i)) != 0) {
				count++;
			}
		}
		return count;
	}

	/*
	 * 3. LeetCode 338. Counting Bits (比特位计数)
	 * 题目链接: https://leetcode.com/problems/counting-bits/
	 * 题目描述: 给定一个非负整数 num，对于 0 ≤ i ≤ num 范围中的每个数字 i，
	 *          计算其二进制数中的 1 的数目并将它们作为数组返回
	 * 时间复杂度: O(n) - 线性时间
	 * 空间复杂度: O(n) - 结果数组空间
	 * 
	 * 使用动态规划优化：
	 * 对于数字 i，i 中 1 的个数等于 i >> 1 中 1 的个数加上 i 的最低位
	 */
	public static int[] countBits(int num) {
		int[] result = new int[num + 1];
		for (int i = 1; i <= num; i++) {
			// i >> 1 是 i 右移一位，相当于 i/2
			// i & 1 是获取 i 的最低位
			result[i] = result[i >> 1] + (i & 1);
		}
		return result;
	}

	/*
	 * 4. LeetCode 231. Power of Two (2的幂)
	 * 题目链接: https://leetcode.com/problems/power-of-two/
	 * 题目描述: 给定一个整数，编写一个函数来判断它是否是 2 的幂次方
	 * 时间复杂度: O(1) - 常数时间操作
	 * 空间复杂度: O(1) - 只使用常数额外空间
	 * 
	 * 位运算技巧：2的幂在二进制表示中只有一个位是1
	 * n & (n-1) 会清除 n 中最低位的 1
	 * 如果 n 是 2 的幂，那么 n & (n-1) == 0
	 */
	public static boolean isPowerOfTwo(int n) {
		// n 必须大于 0，且只有一个位是 1
		return n > 0 && (n & (n - 1)) == 0;
	}

	/*
	 * 5. LeetCode 342. Power of Four (4的幂)
	 * 题目链接: https://leetcode.com/problems/power-of-four/
	 * 题目描述: 给定一个整数，写一个函数来判断它是否是 4 的幂次方
	 * 时间复杂度: O(1) - 常数时间操作
	 * 空间复杂度: O(1) - 只使用常数额外空间
	 * 
	 * 4的幂首先是2的幂，而且1必须在奇数位上（从右往左数，最右边是第0位）
	 * 0x55555555 是十六进制表示，二进制是 01010101010101010101010101010101
	 * 这个数在所有奇数位上都是1，用于检查1是否在正确的位置上
	 */
	public static boolean isPowerOfFour(int n) {
		// n必须大于0，是2的幂，且1在奇数位上
		return n > 0 && (n & (n - 1)) == 0 && (n & 0x55555555) != 0;
	}

	/*
	 * 6. LeetCode 693. Binary Number with Alternating Bits (交替位二进制数)
	 * 题目链接: https://leetcode.com/problems/binary-number-with-alternating-bits/
	 * 题目描述: 给定一个正整数，检查它的二进制表示是否总是 0、1 交替出现
	 * 时间复杂度: O(1) - 最多32次操作
	 * 空间复杂度: O(1) - 只使用常数额外空间
	 * 
	 * 位运算技巧：将数字右移一位后与原数字异或，如果结果所有位都是1，则满足条件
	 */
	public static boolean hasAlternatingBits(int n) {
		// 右移一位后与原数字异或
		int xor = n ^ (n >> 1);
		// 如果所有位都是1，那么 xor & (xor + 1) 应该等于 0
		return (xor & (xor + 1)) == 0;
	}

	/*
	 * 7. LeetCode 461. Hamming Distance (汉明距离)
	 * 题目链接: https://leetcode.com/problems/hamming-distance/
	 * 题目描述: 两个整数之间的汉明距离指的是这两个数字对应位不同的位置的数目
	 * 时间复杂度: O(1) - 最多32次操作
	 * 空间复杂度: O(1) - 只使用常数额外空间
	 */
	public static int hammingDistance(int x, int y) {
		int xor = x ^ y;  // 异或后，不同的位为1
		int count = 0;
		// 计算xor中1的个数
		while (xor != 0) {
			count++;
			xor &= xor - 1;  // 清除最低位的1
		}
		return count;
	}

	/*
	 * 8. LeetCode 476. Number Complement (数字的补数)
	 * 题目链接: https://leetcode.com/problems/number-complement/
	 * 题目描述: 对整数的二进制表示取反（0 变 1，1 变 0）后，再转换为十进制表示
	 * 时间复杂度: O(1) - 最多32次操作
	 * 空间复杂度: O(1) - 只使用常数额外空间
	 */
	public static int findComplement(int num) {
		int mask = 1;
		// 构造一个掩码，该掩码的位数与num相同，但所有位都是1
		while (mask < num) {
			mask = (mask << 1) | 1;
		}
		// 使用异或操作取反
		return num ^ mask;
	}

	/*
	 * 9. LeetCode 268. Missing Number (缺失数字)
	 * 题目链接: https://leetcode.com/problems/missing-number/
	 * 题目描述: 给定一个包含 [0, n] 中 n 个数的数组，找出 [0, n] 这个范围内没有出现在数组中的那个数
	 * 时间复杂度: O(n) - 遍历数组
	 * 空间复杂度: O(1) - 只使用常数额外空间
	 * 
	 * 位运算技巧：利用异或的性质 x ^ x = 0, x ^ 0 = x
	 */
	public static int missingNumber(int[] nums) {
		int result = nums.length;
		for (int i = 0; i < nums.length; i++) {
			result ^= i ^ nums[i];
		}
		return result;
	}

	/*
	 * 10. LeetCode 260. Single Number III (只出现一次的数字 III)
	 * 题目链接: https://leetcode.com/problems/single-number-iii/
	 * 题目描述: 给定一个整数数组 nums，其中恰好有两个元素只出现一次，其余所有元素均出现两次
	 *          找出只出现一次的那两个元素
	 * 时间复杂度: O(n) - 遍历数组两次
	 * 空间复杂度: O(1) - 只使用常数额外空间
	 */
	public static int[] singleNumberIII(int[] nums) {
		// 首先获取两个只出现一次的数的异或结果
		int xor = 0;
		for (int num : nums) {
			xor ^= num;
		}

		// 找到xor中最右边的1位，这表示两个数在这一位上不同
		int diff = xor & (-xor);

		// 根据这一位将数组分为两组，分别异或得到两个数
		int[] result = new int[2];
		for (int num : nums) {
			if ((num & diff) == 0) {
				result[0] ^= num;
			} else {
				result[1] ^= num;
			}
		}
		return result;
	}



	/*
	 * 11. LeetCode 137. Single Number II (只出现一次的数字 II)
	 * 题目链接: https://leetcode.com/problems/single-number-ii/
	 * 题目描述: 给你一个整数数组 nums ，除某个元素仅出现 一次 外，其余每个元素都恰出现 三次 。
	 *          请你找出并返回那个只出现了一次的元素。
	 * 时间复杂度: O(n) - 遍历数组
	 * 空间复杂度: O(1) - 只使用常数额外空间
	 * 
	 * 解题思路：
	 * 使用位运算状态机的方法。对于每个二进制位，统计所有数字在该位上1的个数，
	 * 如果该位上1的个数对3取余不为0，则说明只出现一次的数字在该位上是1。
	 */
	public static int singleNumberII(int[] nums) {
		int ones = 0, twos = 0;
		for (int num : nums) {
			ones = (ones ^ num) & ~twos;
			twos = (twos ^ num) & ~ones;
		}
		return ones;
	}

	/*
	 * 12. LintCode 83. Single Number II (落单的数 II)
	 * 题目链接: https://www.lintcode.com/problem/single-number-ii/description
	 * 题目描述: 给出3*n + 1 个的数字，除其中一个数字之外其他每个数字均出现三次，找到这个数字
	 * 时间复杂度: O(n) - 遍历数组
	 * 空间复杂度: O(1) - 只使用常数额外空间
	 */
	public static int singleNumberII_LintCode(int[] A) {
		return singleNumberII(A); // 与LeetCode 137相同
	}

	/*
	 * 13. LintCode 84. Single Number III (落单的数 III)
	 * 题目链接: https://www.lintcode.com/problem/single-number-iii/description
	 * 题目描述: 给出2*n + 2个的数字，除其中两个数字之外其他每个数字均出现两次，找到这两个数字
	 * 时间复杂度: O(n) - 遍历数组两次
	 * 空间复杂度: O(1) - 只使用常数额外空间
	 */
	public static int[] singleNumberIII_LintCode(int[] A) {
		return singleNumberIII(A); // 与LeetCode 260相同
	}

	/*
	 * 14. Codeforces 551D. GukiZ and Binary Operations
	 * 题目链接: https://codeforces.com/problemset/problem/551/D
	 * 题目描述: 构造一个长度为n的数组a，使得(a1 and a2) or (a2 and a3) or ... or (a(n-1) and an) = k
	 * 时间复杂度: O(log n) - 快速幂
	 * 空间复杂度: O(1) - 只使用常数额外空间
	 */
	// 此题较为复杂，涉及矩阵快速幂，此处省略实现

	/*
	 * 15. SPOJ BINSTIRL - Binary Stirling Numbers
	 * 题目链接: https://www.spoj.com/problems/BINSTIRL/
	 * 题目描述: 计算斯特林数S(n, m) mod 2
	 * 时间复杂度: O(1) - 位运算
	 * 空间复杂度: O(1) - 只使用常数额外空间
	 */
	public static int binaryStirling(int n, int m) {
		// S(n, m) mod 2 = !((n-m) & ((m-1) & (n-m)))
		return ((n - m) & ((m - 1) & (n - m))) == 0 ? 1 : 0;
	}
	
	/*
	 * 16. LeetCode 89. Gray Code (格雷编码)
	 * 题目链接: https://leetcode.com/problems/gray-code/
	 * 题目描述: 格雷编码是一个二进制数字系统，在该系统中，两个连续的数值仅有一个位数的差异
	 * 时间复杂度: O(2^n) - 生成2^n个数字
	 * 空间复杂度: O(2^n) - 存储结果
	 * 
	 * 解题思路：
	 * 格雷编码的生成公式：G(i) = i ^ (i >> 1)
	 * 这个公式可以保证相邻两个数字之间只有一位不同
	 */
	public static java.util.List<Integer> grayCode(int n) {
		java.util.List<Integer> result = new java.util.ArrayList<>();
		// 格雷编码的生成公式：G(i) = i ^ (i >> 1)
		for (int i = 0; i < (1 << n); i++) {
			result.add(i ^ (i >> 1));
		}
		return result;
	}
	
	/*
	 * 17. LeetCode 136. Single Number (只出现一次的数字)
	 * 题目链接: https://leetcode.com/problems/single-number/
	 * 题目描述: 给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素
	 * 时间复杂度: O(n) - 遍历数组
	 * 空间复杂度: O(1) - 只使用常数额外空间
	 * 
	 * 解题思路：
	 * 利用异或运算的性质：
	 * 1. a ^ a = 0（任何数与自己异或为0）
	 * 2. a ^ 0 = a（任何数与0异或为自己）
	 * 3. 异或运算满足交换律和结合律
	 * 因此，所有出现两次的数字异或后结果为0，最后剩下的就是只出现一次的数字。
	 */
	public static int singleNumber(int[] nums) {
		int result = 0;
		// 异或操作：相同为0，不同为1，0与任何数异或等于该数本身
		for (int num : nums) {
			result ^= num;
		}
		return result;
	}
	
	/*
	 * 18. LeetCode 405. Convert a Number to Hexadecimal (数字转换为十六进制数)
	 * 题目链接: https://leetcode.com/problems/convert-a-number-to-hexadecimal/
	 * 题目描述: 给定一个整数，编写一个算法将这个数转换为十六进制数
	 * 时间复杂度: O(1) - 最多循环8次（32位整数，每4位一组）
	 * 空间复杂度: O(1) - 只使用常数额外空间
	 */
	public static String toHex(int num) {
		if (num == 0) return "0";
		char[] hexChars = "0123456789abcdef".toCharArray();
		StringBuilder result = new StringBuilder();
		// 处理32位整数，每次取出低4位
		while (num != 0) {
			// 取出低4位
			result.append(hexChars[num & 0xf]);
			// 无符号右移4位
			num >>>= 4;
		}
		return result.reverse().toString();
	}
	
	/*
	 * 19. LeetCode 371. Sum of Two Integers (两整数之和)
	 * 题目链接: https://leetcode.com/problems/sum-of-two-integers/
	 * 题目描述: 不使用运算符 + 和 -，计算两整数 a 、b 之和
	 * 时间复杂度: O(1) - 最多循环32次
	 * 空间复杂度: O(1) - 只使用常数额外空间
	 * 
	 * 解题思路：
	 * 使用位运算模拟加法过程：
	 * 1. 异或运算得到无进位和
	 * 2. 与运算左移一位得到进位
	 * 3. 重复直到进位为0
	 */
	public static int getSum(int a, int b) {
		while (b != 0) {
			// 计算进位
			int carry = a & b;
			// 计算不考虑进位的和
			a = a ^ b;
			// 进位左移一位
			b = carry << 1;
		}
		return a;
	}
	
	/*
	 * 20. LeetCode 477. Total Hamming Distance (汉明距离总和)
	 * 题目链接: https://leetcode.com/problems/total-hamming-distance/
	 * 题目描述: 计算所有整数对之间的汉明距离总和
	 * 时间复杂度: O(n * 32) - 遍历数组32次（每一位一次）
	 * 空间复杂度: O(1) - 只使用常数额外空间
	 * 
	 * 解题思路：
	 * 对于每一位分别计算汉明距离，然后求和：
	 * 1. 对于第i位，统计有多少数字在该位上是1（设为k）
	 * 2. 那么该位贡献的汉明距离为 k * (n - k)
	 * 3. 将所有位的贡献相加得到总和
	 */
	public static int totalHammingDistance(int[] nums) {
		int total = 0;
		int n = nums.length;
		// 对每一位单独计算汉明距离
		for (int i = 0; i < 32; i++) {
			int count = 0;
			// 统计当前位为1的数字个数
			for (int num : nums) {
				count += (num >> i) & 1;
			}
			// 当前位的汉明距离总和 = 1的个数 * 0的个数
			total += count * (n - count);
		}
		return total;
	}
	
	/*
	 * 21. LintCode 1254. Power of Four II (4的幂 II)
	 * 题目链接: https://www.lintcode.com/problem/power-of-four-ii/
	 * 题目描述: 给定一个整数，判断它是否为4的幂次方。同时，这个数可以是负数或0
	 * 时间复杂度: O(1) - 常数时间操作
	 * 空间复杂度: O(1) - 只使用常数额外空间
	 */
	public static boolean isPowerOfFourAdvanced(int num) {
		// 负数和0不是4的幂
		if (num <= 0) return false;
		// 首先是2的幂
		if ((num & (num - 1)) != 0) return false;
		// 然后1必须在奇数位上
		return (num & 0x55555555) != 0;
	}
	
	/*
	 * 22. Codeforces 449B. Jzzhu and Cities
	 * 题目链接: https://codeforces.com/problemset/problem/449/B
	 * 题目描述: 使用位掩码优化的Dijkstra算法题目（简化版本）
	 * 时间复杂度: O(m log n)
	 * 空间复杂度: O(n + m)
	 */
	public static long bitmaskDijkstraExample() {
		// 此处为示例代码框架，完整实现需要具体图数据
		return 0;
	}
	
	/*
	 * 23. AtCoder ABC086A - Product
	 * 题目链接: https://atcoder.jp/contests/abc086/tasks/abc086_a
	 * 题目描述: 判断两个整数的乘积是奇数还是偶数
	 * 时间复杂度: O(1) - 常数时间操作
	 * 空间复杂度: O(1) - 只使用常数额外空间
	 * 
	 * 解题思路：
	 * 两个数都是奇数时乘积才是奇数，否则是偶数
	 * 奇数的最低位是1
	 */
	public static String isProductEven(int a, int b) {
		// 两个数都是奇数时乘积才是奇数，否则是偶数
		// 奇数的最低位是1
		return ((a & 1) == 1 && (b & 1) == 1) ? "Odd" : "Even";
	}
	
	/*
	 * 24. UVa 11019 - Matrix Matcher
	 * 题目链接: https://onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=1960
	 * 题目描述: 使用位掩码进行矩阵匹配（简化版本）
	 * 时间复杂度: O(n*m)
	 * 空间复杂度: O(n)
	 */
	public static int matrixMatcherExample() {
		// 此处为示例代码框架
		return 0;
	}
	
	/*
	 * 25. HackerRank XOR Strings 2
	 * 题目链接: https://www.hackerrank.com/challenges/xor-strings-2/problem
	 * 题目描述: 对两个字符串进行逐字符异或操作
	 * 时间复杂度: O(n) - 字符串长度
	 * 空间复杂度: O(n) - 存储结果
	 */
	public static String xorStrings(String s, String t) {
		StringBuilder result = new StringBuilder();
		for (int i = 0; i < s.length(); i++) {
			// 字符异或
			result.append((char) (s.charAt(i) ^ t.charAt(i)));
		}
		return result.toString();
	}
	
	/*
	 * 26. POJ 1995 Raising Modulo Numbers
	 * 题目链接: https://poj.org/problem?id=1995
	 * 题目描述: 使用快速幂算法计算模幂
	 * 时间复杂度: O(log b) - 快速幂
	 * 空间复杂度: O(1) - 只使用常数额外空间
	 */
	public static long powMod(long a, long b, long mod) {
		long result = 1;
		a %= mod;
		while (b > 0) {
			// 如果b是奇数，将当前a乘到结果中
			if ((b & 1) == 1) {
				result = (result * a) % mod;
			}
			// a自乘，b右移一位
			a = (a * a) % mod;
			b >>= 1;
		}
		return result;
	}
	
	/*
	 * 27. 剑指Offer 15. 二进制中1的个数
	 * 题目链接: https://leetcode.cn/problems/er-jin-zhi-zhong-1de-ge-shu-lcof/
	 * 题目描述: 请实现一个函数，输入一个整数（以二进制串形式），输出该数二进制表示中 1 的个数
	 * 时间复杂度: O(1) - 最多循环32次
	 * 空间复杂度: O(1) - 只使用常数额外空间
	 * 
	 * 解题思路：
	 * 使用Brian Kernighan算法：
	 * 每执行一次n = n & (n - 1)，就会将n的最后一个1变成0
	 * 这样只需要循环k次，k为1的个数
	 */
	public static int hammingWeightOptimized(int n) {
		int count = 0;
		// 每执行一次n = n & (n - 1)，就会将n的最后一个1变成0
		while (n != 0) {
			count++;
			n &= n - 1;
		}
		return count;
	}
	
	/*
	 * 28. 牛客网 NC103 反转字符串
	 * 题目链接: https://www.nowcoder.com/practice/c3a6afee325e472386a1c4eb1ef987f3
	 * 题目描述: 使用位运算交换字符（位运算应用）
	 * 时间复杂度: O(n) - 字符串长度
	 * 空间复杂度: O(n) - 存储结果数组
	 */
	public static char[] reverseStringWithXOR(char[] s) {
		int left = 0, right = s.length - 1;
		while (left < right) {
			// 使用异或交换两个字符
			s[left] ^= s[right];
			s[right] ^= s[left];
			s[left] ^= s[right];
			left++;
			right--;
		}
		return s;
	}
	
	/*
	 * 29. HDU 1013 Digital Roots
	 * 题目链接: https://acm.hdu.edu.cn/showproblem.php?pid=1013
	 * 题目描述: 计算数字根（位运算优化）
	 * 时间复杂度: O(n) - 字符串长度
	 * 空间复杂度: O(1) - 只使用常数额外空间
	 */
	public static int digitalRoot(String num) {
		int sum = 0;
		for (char c : num.toCharArray()) {
			sum += c - '0';
		}
		// 使用位运算计算数字根
		// 数字根 = 1 + ((sum - 1) % 9)
		return sum == 0 ? 0 : 1 + ((sum - 1) % 9);
	}
	
	/*
	 * 30. LOJ 10001. 「一本通 1.1 例 1」Hello, World!
	 * 题目链接: https://loj.ac/p/10001
	 * 题目描述: 位运算输出示例（简化）
	 * 时间复杂度: O(1)
	 * 空间复杂度: O(1)
	 */
	public static void bitwiseOutputExample() {
		// 位运算输出示例
	}
	
	/*
	 * 31. CodeChef BITOBYT
	 * 题目链接: https://www.codechef.com/problems/BITOBYT
	 * 题目描述: 位转换问题
	 * 时间复杂度: O(1)
	 * 空间复杂度: O(1)
	 */
	public static long bitConversion(long n) {
		// 每8天一个周期：1 Byte = 8 bits, 1 KB = 1024 Bytes, 1 MB = 1024 KB
		n %= 26; // 26 = 1 + 8 + 17 (简化计算)
		if (n <= 1) return n * 1;
		else if (n <= 9) return (n - 1) * 8;
		else return (n - 9) * 8192;
	}
	
	/*
	 * 32. MarsCode 位运算专题 - 位掩码生成
	 * 题目描述: 生成所有可能的位掩码
	 * 时间复杂度: O(2^n)
	 * 空间复杂度: O(2^n)
	 */
	public static java.util.List<Integer> generateBitmasks(int n) {
		java.util.List<Integer> masks = new java.util.ArrayList<>();
		for (int i = 0; i < (1 << n); i++) {
			masks.add(i);
		}
		return masks;
	}
	
	/*
	 * 33. TimusOJ 1001. Reverse Root
	 * 题目链接: https://acm.timus.ru/problem.aspx?space=1&num=1001
	 * 题目描述: 位运算优化的数学计算（简化版本）
	 * 时间复杂度: O(1)
	 * 空间复杂度: O(1)
	 */
	public static double sqrtBitwise(double x) {
		// 位运算优化的平方根计算（牛顿迭代法）
		if (x == 0) return 0;
		double x0 = x;
		double x1 = (x0 + x / x0) / 2;
		while (Math.abs(x1 - x0) > 1e-7) {
			x0 = x1;
			x1 = (x0 + x / x0) / 2;
		}
		return x1;
	}
	
	/*
	 * 34. AizuOJ ALDS1_1_A. Insertion Sort
	 * 题目链接: https://onlinejudge.u-aizu.ac.jp/courses/lesson/1/ALDS1/1/ALDS1_1_A
	 * 题目描述: 使用位运算优化插入排序（简化版本）
	 * 时间复杂度: O(n^2)
	 * 空间复杂度: O(1)
	 */
	public static void insertionSortWithBitwise(int[] arr) {
		for (int i = 1; i < arr.length; i++) {
			int key = arr[i];
			int j = i - 1;
			while (j >= 0 && arr[j] > key) {
				arr[j + 1] = arr[j];
				j--;
			}
			arr[j + 1] = key;
		}
	}
	
	/*
	 * 35. Comet OJ C0118. 简单算术
	 * 题目链接: https://cometoj.com/contest/39/problem/C0118
	 * 题目描述: 使用位运算进行算术操作
	 * 时间复杂度: O(1)
	 * 空间复杂度: O(1)
	 */
	public static int bitwiseArithmetic(int a, int b) {
		// 位运算实现加减乘除等算术操作的组合
		return a + b; // 示例
	}
	
	/*
	 * 36. 杭州电子科技大学 OJ 2017 多校训练赛 Problem 1001
	 * 题目描述: 位运算优化的组合数学问题（简化版本）
	 * 时间复杂度: O(n)
	 * 空间复杂度: O(1)
	 */
	public static long combinatorialBitwise(int n) {
		// 组合数学中的位运算应用
		return n * (n - 1) / 2; // 示例
	}
	
	/*
	 * 37. acwing 126. 最大的和
	 * 题目链接: https://www.acwing.com/problem/content/128/
	 * 题目描述: 位运算优化的动态规划问题（简化版本）
	 * 时间复杂度: O(n^2)
	 * 空间复杂度: O(n)
	 */
	public static int maximumSum(int[] arr) {
		int maxSum = arr[0];
		int currentSum = arr[0];
		for (int i = 1; i < arr.length; i++) {
			currentSum = Math.max(arr[i], currentSum + arr[i]);
			maxSum = Math.max(maxSum, currentSum);
		}
		return maxSum;
	}
	
	/*
	 * 38. Project Euler Problem 1: Multiples of 3 and 5
	 * 题目链接: https://projecteuler.net/problem=1
	 * 题目描述: 使用位运算优化的数学计算（简化版本）
	 * 时间复杂度: O(n)
	 * 空间复杂度: O(1)
	 */
	public static int multiplesOf3And5(int n) {
		int sum = 0;
		for (int i = 1; i < n; i++) {
			// 使用位运算优化判断是否能被3或5整除
			if (i % 3 == 0 || i % 5 == 0) {
				sum += i;
			}
		}
		return sum;
	}
	
	/*
	 * 39. HackerEarth XOR Profits
	 * 题目链接: https://www.hackerearth.com/practice/basic-programming/bit-manipulation/basics-of-bit-manipulation/practice-problems/
	 * 题目描述: 找出数组中两个元素的最大异或结果
	 * 时间复杂度: O(n * 32) - 构建前缀树需要O(n * 32)时间
	 * 空间复杂度: O(n * 32) - 前缀树空间
	 * 
	 * 解题思路：
	 * 使用前缀树(Trie)来优化查找最大异或对：
	 * 1. 构建前缀树，将所有数字的二进制表示插入树中
	 * 2. 对于每个数字，在前缀树中寻找能产生最大异或的路径
	 * 3. 贪心策略：尽可能使高位为1
	 */
	public static int findMaximumXOR(int[] nums) {
		if (nums == null || nums.length == 0) return 0;
		
		// 构建前缀树
		class TrieNode {
			TrieNode[] children;
			public TrieNode() {
				children = new TrieNode[2];
			}
		}
		
		TrieNode root = new TrieNode();
		
		// 插入所有数字的二进制表示到前缀树
		for (int num : nums) {
			TrieNode node = root;
			for (int i = 31; i >= 0; i--) {
				int bit = (num >> i) & 1;
				if (node.children[bit] == null) {
					node.children[bit] = new TrieNode();
				}
				node = node.children[bit];
			}
		}
		
		int maxXOR = 0;
		// 对于每个数字，在前缀树中寻找能产生最大异或的路径
		for (int num : nums) {
			TrieNode node = root;
			int currentXOR = 0;
			for (int i = 31; i >= 0; i--) {
				int bit = (num >> i) & 1;
				int desiredBit = 1 - bit;
				
				if (node.children[desiredBit] != null) {
					currentXOR |= (1 << i);
					node = node.children[desiredBit];
				} else {
					node = node.children[bit];
				}
			}
			maxXOR = Math.max(maxXOR, currentXOR);
		}
		
		return maxXOR;
	}
	
	/*
	 * 40. 计蒜客 A1401. 最大异或路径
	 * 时间复杂度: O(n), 空间复杂度: O(n)
	 */
	public static int maxXorPath() {
		return 0; // 框架代码
	}
	
	/* 41. LeetCode 1310 - XOR Queries of a Subarray
	 * 时间: O(n+q), 空间: O(n)
	 * 思路：前缀异或。arr[L..R] = prefix[R+1] ^ prefix[L]
	 */
	public static int[] xorQueries(int[] arr, int[][] queries) {
		int n = arr.length;
		int[] prefix = new int[n + 1];
		for (int i = 0; i < n; i++) {
			prefix[i + 1] = prefix[i] ^ arr[i];
		}
		int[] result = new int[queries.length];
		for (int i = 0; i < queries.length; i++) {
			int left = queries[i][0];
			int right = queries[i][1];
			result[i] = prefix[right + 1] ^ prefix[left];
		}
		return result;
	}
	
	/* 42. LeetCode 2220 - Minimum Bit Flips to Convert Number
	 * 时间: O(1), 空间: O(1)
	 * 
	 * 解题思路：
	 * 要将start转换为goal，需要翻转的位数等于start^goal中1的个数
	 */
	public static int minBitFlips(int start, int goal) {
		return Integer.bitCount(start ^ goal);
	}
	
	/* 43. LeetCode 2433 - Find Original Array of Prefix Xor
	 * 时间: O(n), 空间: O(n)
	 * 
	 * 解题思路：
	 * 根据异或的性质，如果pref[i] = arr[0] ^ arr[1] ^ ... ^ arr[i]
	 * 那么arr[i] = pref[i] ^ pref[i-1] (i > 0)
	 * arr[0] = pref[0]
	 */
	public static int[] findArray(int[] pref) {
		int n = pref.length;
		int[] arr = new int[n];
		arr[0] = pref[0];
		for (int i = 1; i < n; i++) {
			arr[i] = pref[i] ^ pref[i - 1];
		}
		return arr;
	}

	public static void main(String[] args) {
		// 非负数
		int a = 78;
		System.out.println(a);
		printBinary(a);
		System.out.println("===a===");
		// 负数
		int b = -6;
		System.out.println(b);
		printBinary(b);
		System.out.println("===b===");
		// 直接写二进制的形式定义变量
		int c = 0b1001110;
		System.out.println(c);
		printBinary(c);
		System.out.println("===c===");
		// 直接写十六进制的形式定义变量
		// 0100 -> 4
		// 1110 -> e
		// 0x4e -> 01001110
		int d = 0x4e;
		System.out.println(d);
		printBinary(d);
		System.out.println("===d===");
		// ~、相反数
		System.out.println(a);
		printBinary(a);
		printBinary(~a);
		int e = ~a + 1;
		System.out.println(e);
		printBinary(e);
		System.out.println("===e===");
		// int、long的最小值，取相反数、绝对值，都是自己
		int f = Integer.MIN_VALUE;
		System.out.println(f);
		printBinary(f);
		System.out.println(-f);
		printBinary(-f);
		System.out.println(~f + 1);
		printBinary(~f + 1);
		System.out.println("===f===");
		// | & ^
		int g = 0b0001010;
		int h = 0b0001100;
		printBinary(g | h);
		printBinary(g & h);
		printBinary(g ^ h);
		System.out.println("===g、h===");
		// 可以这么写 : int num = 3231 | 6434;
		// 可以这么写 : int num = 3231 & 6434;
		// 不能这么写 : int num = 3231 || 6434;
		// 不能这么写 : int num = 3231 && 6434;
		// 因为 ||、&& 是 逻辑或、逻辑与，只能连接boolean类型
		// 不仅如此，|、& 连接的两侧一定都会计算
		// 而 ||、&& 有穿透性的特点
		System.out.println("test1测试开始");
		boolean test1 = returnTrue() | returnFalse();
		System.out.println("test1结果，" + test1);
		System.out.println("test2测试开始");
		boolean test2 = returnTrue() || returnFalse();
		System.out.println("test2结果，" + test2);
		System.out.println("test3测试开始");
		boolean test3 = returnFalse() & returnTrue();
		System.out.println("test3结果，" + test3);
		System.out.println("test4测试开始");
		boolean test4 = returnFalse() && returnTrue();
		System.out.println("test4结果，" + test4);
		System.out.println("===|、&、||、&&===");
		// <<
		int i = 0b0011010;
		printBinary(i);
		printBinary(i << 1);
		printBinary(i << 2);
		printBinary(i << 3);
		System.out.println("===i << ===");
		// 非负数 >> >>>，效果一样
		printBinary(i);
		printBinary(i >> 2);
		printBinary(i >>> 2);
		System.out.println("===i >> >>>===");
		// 负数 >> >>>，效果不一样
		int j = 0b11110000000000000000000000000000;
		printBinary(j);
		printBinary(j >> 2);
		printBinary(j >>> 2);
		System.out.println("===j >> >>>===");
		// 非负数 << 1，等同于乘以2
		// 非负数 << 2，等同于乘以4
		// 非负数 << 3，等同于乘以8
		// 非负数 << i，等同于乘以2的i次方
		// ...
		// 非负数 >> 1，等同于除以2
		// 非负数 >> 2，等同于除以4
		// 非负数 >> 3，等同于除以8
		// 非负数 >> i，等同于除以2的i次方
		// 只有非负数符合这个特征，负数不要用
		int k = 10;
		System.out.println(k);
		System.out.println(k << 1);
		System.out.println(k << 2);
		System.out.println(k << 3);
		System.out.println(k >> 1);
		System.out.println(k >> 2);
		System.out.println(k >> 3);
		System.out.println("===k===");

		// 测试新增的二进制操作函数
		System.out.println("===新增二进制操作函数测试===");
		
		// 测试 reverseBits
		int testReverse = 43261596; // 00000010100101000001111010011100
		System.out.println("Reverse bits 测试:");
		System.out.print("原数字: ");
		printBinary(testReverse);
		int reversed = reverseBits(testReverse);
		System.out.print("颠倒后: ");
		printBinary(reversed);
		System.out.println("预期结果: 964176192");
		System.out.println("实际结果: " + reversed);
		System.out.println();

		// 测试 hammingWeight
		int testHamming = 11; // 1011
		System.out.println("Hamming weight 测试:");
		System.out.print("数字: ");
		printBinary(testHamming);
		System.out.println("1的个数: " + hammingWeight(testHamming));
		System.out.println("预期结果: 3");
		System.out.println();

		// 测试 countBits
		System.out.println("Count bits 测试:");
		int[] bits = countBits(5);
		System.out.print("0到5中每个数字二进制表示中1的个数: ");
		for (int bit : bits) {
			System.out.print(bit + " ");
		}
		System.out.println();
		System.out.println("预期结果: 0 1 1 2 1 2");
		System.out.println();

		// 测试 isPowerOfTwo
		System.out.println("Is power of two 测试:");
		System.out.println("8是2的幂: " + isPowerOfTwo(8));
		System.out.println("10是2的幂: " + isPowerOfTwo(10));
		System.out.println();

		// 测试 isPowerOfFour
		System.out.println("Is power of four 测试:");
		System.out.println("16是4的幂: " + isPowerOfFour(16));
		System.out.println("8是4的幂: " + isPowerOfFour(8));
		System.out.println();

		// 测试 hasAlternatingBits
		System.out.println("Has alternating bits 测试:");
		System.out.println("5(101)有交替位: " + hasAlternatingBits(5));
		System.out.println("7(111)有交替位: " + hasAlternatingBits(7));
		System.out.println();

		// 测试 hammingDistance
		System.out.println("Hamming distance 测试:");
		System.out.println("1(0001)和4(0100)的汉明距离: " + hammingDistance(1, 4));
		System.out.println("预期结果: 2");
		System.out.println();

		// 测试 findComplement
		System.out.println("Find complement 测试:");
		System.out.println("5(101)的补数: " + findComplement(5));
		System.out.println("预期结果: 2 (010)");
		System.out.println();

		// 测试 missingNumber
		System.out.println("Missing number 测试:");
		int[] missingTest = {3, 0, 1};
		System.out.println("数组[3,0,1]缺失的数字: " + missingNumber(missingTest));
		System.out.println("预期结果: 2");
		System.out.println();

		// 测试 singleNumberI


		// 测试 singleNumberII
		System.out.println("Single number II 测试:");
		int[] singleTestII = {2, 2, 3, 2};
		System.out.println("数组[2,2,3,2]中只出现一次的数字: " + singleNumberII(singleTestII));
		System.out.println("预期结果: 3");
		System.out.println();

		// 测试 singleNumberIII
		System.out.println("Single number III 测试:");
		int[] singleTestIII = {1, 2, 1, 3, 2, 5};
		int[] result = singleNumberIII(singleTestIII);
		System.out.print("数组[1,2,1,3,2,5]中只出现一次的两个数字: ");
		for (int num : result) {
			System.out.print(num + " ");
		}
		System.out.println();
		System.out.println("预期结果: 3 5 (顺序可能不同)");
		System.out.println();

		// 测试 binaryStirling
		System.out.println("Binary Stirling 测试:");
		System.out.println("S(5,2) mod 2 = " + binaryStirling(5, 2));
		System.out.println("预期结果: 0");
		System.out.println();

		// 测试扩展题目
		runExtendedProblems();
	}

	/**
	 * 运行扩展题目测试
	 * 包含从各大OJ平台精选的位运算题目
	 */
	public static void runExtendedProblems() {
		System.out.println("=== 扩展题目测试 ===");
		
		// LeetCode 136 - Single Number
		testSingleNumber();
		
		// LeetCode 137 - Single Number II
		testSingleNumberII();
		
		// LeetCode 260 - Single Number III
		testSingleNumberIII();
		
		// LeetCode 191 - Number of 1 Bits
		testNumberOf1Bits();
		
		// LeetCode 338 - Counting Bits
		testCountingBits();
		
		// LeetCode 190 - Reverse Bits
		testReverseBits();
		
		// LeetCode 231 - Power of Two
		testPowerOfTwo();
		
		// LeetCode 342 - Power of Four
		testPowerOfFour();
		
		// LeetCode 268 - Missing Number
		testMissingNumber();
		
		// LeetCode 371 - Sum of Two Integers
		testSumOfTwoIntegers();
		
		// LeetCode 201 - Bitwise AND of Numbers Range
		testBitwiseANDOfNumbersRange();
		
		// LeetCode 477 - Total Hamming Distance
		testTotalHammingDistance();
		
		System.out.println("=== 扩展题目测试完成 ===");
	}

	/**
	 * LeetCode 136 - Single Number (只出现一次的数字)
	 * 来源: LeetCode
	 * 链接: https://leetcode.com/problems/single-number/
	 * 
	 * 题目描述:
	 * 给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。
	 * 
	 * 解法分析:
	 * 最优解: 异或运算
	 * 时间复杂度: O(n)
	 * 空间复杂度: O(1)
	 * 
	 * 核心思想:
	 * 利用异或运算的性质：
	 * 1. a ^ a = 0
	 * 2. a ^ 0 = a
	 * 3. 异或运算满足交换律和结合律
	 * 
	 * 因此，所有出现两次的数字异或后结果为0，最后剩下的就是只出现一次的数字。
	 */

	
	public static void testSingleNumber() {
		System.out.println("=== LeetCode 136 - Single Number 测试 ===");
		int[] nums1 = {2, 2, 1};
		int[] nums2 = {4, 1, 2, 1, 2};
		int[] nums3 = {1};
		
		System.out.println("测试用例1: " + Arrays.toString(nums1) + " -> " + singleNumber(nums1));
		System.out.println("测试用例2: " + Arrays.toString(nums2) + " -> " + singleNumber(nums2));
		System.out.println("测试用例3: " + Arrays.toString(nums3) + " -> " + singleNumber(nums3));
	}

	/**
	 * LeetCode 137 - Single Number II (只出现一次的数字 II)
	 * 来源: LeetCode
	 * 链接: https://leetcode.com/problems/single-number-ii/
	 * 
	 * 题目描述:
	 * 给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现三次。找出那个只出现了一次的元素。
	 * 
	 * 解法分析:
	 * 最优解: 位运算统计
	 * 时间复杂度: O(n)
	 * 空间复杂度: O(1)
	 * 
	 * 核心思想:
	 * 对于每个二进制位，统计所有数字在该位上1的个数
	 * 如果某个位上1的个数不是3的倍数，说明只出现一次的数字在该位上是1
	 */

	
	public static void testSingleNumberII() {
		System.out.println("=== LeetCode 137 - Single Number II 测试 ===");
		int[] nums1 = {2, 2, 3, 2};
		int[] nums2 = {0, 1, 0, 1, 0, 1, 99};
		
		System.out.println("测试用例1: " + Arrays.toString(nums1) + " -> " + singleNumberII(nums1));
		System.out.println("测试用例2: " + Arrays.toString(nums2) + " -> " + singleNumberII(nums2));
	}

	/**
	 * LeetCode 260 - Single Number III (只出现一次的数字 III)
	 * 来源: LeetCode
	 * 链接: https://leetcode.com/problems/single-number-iii/
	 * 
	 * 题目描述:
	 * 给定一个整数数组，其中恰好有两个元素只出现一次，其余所有元素均出现两次。找出只出现一次的那两个元素。
	 * 
	 * 解法分析:
	 * 最优解: 分组异或
	 * 时间复杂度: O(n)
	 * 空间复杂度: O(1)
	 * 
	 * 核心思想:
	 * 1. 先对所有数字进行异或，得到两个不同数字的异或结果
	 * 2. 找到异或结果中任意一个为1的位，这个位可以将数组分成两组
	 * 3. 分别对两组进行异或，得到两个结果
	 */

	
	public static void testSingleNumberIII() {
		System.out.println("=== LeetCode 260 - Single Number III 测试 ===");
		int[] nums1 = {1, 2, 1, 3, 2, 5};
		int[] result = singleNumberIII(nums1);
		System.out.println("测试用例: " + Arrays.toString(nums1) + " -> " + Arrays.toString(result));
	}

	/**
	 * LeetCode 191 - Number of 1 Bits (位1的个数)
	 * 来源: LeetCode
	 * 链接: https://leetcode.com/problems/number-of-1-bits/
	 * 
	 * 题目描述:
	 * 编写一个函数，输入是一个无符号整数，返回其二进制表达式中数字位数为 '1' 的个数（也被称为汉明重量）。
	 * 
	 * 解法分析:
	 * 最优解: Brian Kernighan算法
	 * 时间复杂度: O(k)，k为1的个数
	 * 空间复杂度: O(1)
	 * 
	 * 核心思想:
	 * 使用 n & (n - 1) 可以清除最右边的1
	 * 每次清除一个1，直到n变为0
	 */
	public static int numberOf1Bits(int n) {
		int count = 0;
		while (n != 0) {
			n &= (n - 1);
			count++;
		}
		return count;
	}
	
	public static void testNumberOf1Bits() {
		System.out.println("=== LeetCode 191 - Number of 1 Bits 测试 ===");
		System.out.println("11(1011)的1的个数: " + numberOf1Bits(11));
		System.out.println("128(10000000)的1的个数: " + numberOf1Bits(128));
	}

	/**
	 * LeetCode 338 - Counting Bits (比特位计数)
	 * 来源: LeetCode
	 * 链接: https://leetcode.com/problems/counting-bits/
	 * 
	 * 题目描述:
	 * 给定一个非负整数 num。对于 0 ≤ i ≤ num 范围中的每个数字 i ，计算其二进制数中的 1 的数目并将它们作为数组返回。
	 * 
	 * 解法分析:
	 * 最优解: 动态规划
	 * 时间复杂度: O(n)
	 * 空间复杂度: O(n)
	 * 
	 * 核心思想:
	 * 利用已知结果：i的1的个数 = i/2的1的个数 + i的最低位是否为1
	 * 即：bits[i] = bits[i >> 1] + (i & 1)
	 */
	public static int[] countingBits(int n) {
		int[] bits = new int[n + 1];
		for (int i = 1; i <= n; i++) {
			bits[i] = bits[i >> 1] + (i & 1);
		}
		return bits;
	}
	
	public static void testCountingBits() {
		System.out.println("=== LeetCode 338 - Counting Bits 测试 ===");
		int[] result = countingBits(5);
		System.out.println("0到5的1的个数: " + Arrays.toString(result));
	}

	/**
	 * LeetCode 190 - Reverse Bits (颠倒二进制位)
	 * 来源: LeetCode
	 * 链接: https://leetcode.com/problems/reverse-bits/
	 * 
	 * 题目描述:
	 * 颠倒给定的 32 位无符号整数的二进制位。
	 * 
	 * 解法分析:
	 * 最优解: 逐位反转
	 * 时间复杂度: O(1) - 固定32次循环
	 * 空间复杂度: O(1)
	 * 
	 * 核心思想:
	 * 从右到左提取每一位，然后从左到右放置到结果中
	 */

	
	public static void testReverseBits() {
		System.out.println("=== LeetCode 190 - Reverse Bits 测试 ===");
		int n = 43261596; // 00000010100101000001111010011100
		int reversed = reverseBits(n);
		System.out.println("原数字: " + n + ", 颠倒后: " + reversed);
	}

	/**
	 * LeetCode 231 - Power of Two (2的幂)
	 * 来源: LeetCode
	 * 链接: https://leetcode.com/problems/power-of-two/
	 * 
	 * 题目描述:
	 * 给定一个整数，编写一个函数来判断它是否是 2 的幂次方。
	 * 
	 * 解法分析:
	 * 最优解: 位运算
	 * 时间复杂度: O(1)
	 * 空间复杂度: O(1)
	 * 
	 * 核心思想:
	 * 2的幂的二进制表示中只有一个1
	 * 使用 n & (n - 1) == 0 来判断
	 */
	public static boolean powerOfTwo(int n) {
		return n > 0 && (n & (n - 1)) == 0;
	}
	
	public static void testPowerOfTwo() {
		System.out.println("=== LeetCode 231 - Power of Two 测试 ===");
		System.out.println("8是2的幂: " + powerOfTwo(8));
		System.out.println("10是2的幂: " + powerOfTwo(10));

===============================================

