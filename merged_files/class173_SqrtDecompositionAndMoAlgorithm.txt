===============================================
文件夹: class173_SqrtDecompositionAndMoAlgorithm
===============================================

[Markdown 文件]
===============================================
文件: EXTENDED_PROBLEMS.md
===============================================
# 分块算法与Mo算法扩展题目全集

## 概述

本文件包含了分块算法（Sqrt Decomposition）和Mo算法（离线分块）的完整题目集合，涵盖了各大算法平台的经典题目。

## 题目分类

### 1. 标准分块算法题目

#### 已实现题目

1. **哈希冲突 (Code01_HashCollision)**
   - 题目来源: 洛谷 P3396
   - 链接: https://www.luogu.com.cn/problem/P3396
   - 难度: 普及+/提高
   - 解法: 对于x <= √n的情况预处理，对于x > √n的情况暴力查询

2. **数组查询 (Code02_ArrayQueries)**
   - 题目来源: Codeforces 797E
   - 链接: https://codeforces.com/problemset/problem/797/E
   - 难度: 1700
   - 解法: 对于k <= √n的情况预处理dp，对于k > √n的情况暴力计算

3. **等差数列求和 (Code03_SumOfProgression)**
   - 题目来源: Codeforces 1921F
   - 链接: https://codeforces.com/problemset/problem/1921/F
   - 难度: 1900
   - 解法: 预处理前缀和与加权前缀和

4. **初始化 (Code04_Initialization)**
   - 题目来源: 洛谷 P5309
   - 链接: https://www.luogu.com.cn/problem/P5309
   - 难度: 省选/NOI-
   - 解法: 分块维护区间和

5. **雅加达的摩天楼 (Code05_Skyscraper)**
   - 题目来源: 洛谷 P3645
   - 链接: https://www.luogu.com.cn/problem/P3645
   - 难度: 省选/NOI-
   - 解法: 分块优化BFS

#### 新增标准分块题目

6. **Range Sum Query - Mutable (LeetCode 307)**
   - 题目来源: LeetCode
   - 链接: https://leetcode.com/problems/range-sum-query-mutable/
   - 难度: 中等
   - 解法: 分块维护区间和

7. **Curious Robin Hood (LightOJ 1112)**
   - 题目来源: LightOJ
   - 链接: http://lightoj.com/volume_showproblem.php?problem=1112
   - 难度: 简单
   - 解法: 分块维护区间和

8. **Serega and Fun (Codeforces 455D)**
   - 题目来源: Codeforces
   - 链接: https://codeforces.com/problemset/problem/455/D
   - 难度: 2400
   - 解法: 分块维护，定期重构

9. **Array Queries (Codeforces 797E)**
   - 题目来源: Codeforces
   - 链接: https://codeforces.com/problemset/problem/797/E
   - 难度: 1700
   - 解法: 分块预处理

10. **Xenia and Tree (Codeforces 342E)**
    - 题目来源: Codeforces
    - 链接: https://codeforces.com/problemset/problem/342/E
    - 难度: 2400
    - 解法: 分块优化BFS

### 2. Mo算法（离线分块）题目

#### 已实现题目

11. **Little Elephant and Array (Code09_LittleElephantAndArray)**
    - 题目来源: Codeforces 220B
    - 链接: https://codeforces.com/problemset/problem/220/B
    - 难度: 1800
    - 解法: Mo算法（离线分块）

12. **D-query (Code10_DQuery)**
    - 题目来源: SPOJ DQUERY
    - 链接: https://www.spoj.com/problems/DQUERY/
    - 难度: 经典
    - 解法: Mo算法（离线分块）

13. **Powerful array (Code11_PowerfulArray)**
    - 题目来源: Codeforces 86D
    - 链接: https://codeforces.com/problemset/problem/86/D
    - 难度: 2200
    - 解法: Mo算法（离线分块）

14. **XOR and Favorite Number (Code15_XorAndFavoriteNumber)**
    - 题目来源: Codeforces 617E
    - 链接: https://codeforces.com/problemset/problem/617/E
    - 难度: 2100
    - 解法: Mo算法（离线分块）+ 异或前缀和

15. **Tree and Queries (Code17_TreeAndQueries)**
    - 题目来源: Codeforces 375D
    - 链接: https://codeforces.com/problemset/problem/375/D
    - 难度: 2400
    - 解法: 树上Mo算法（离线分块）+ 欧拉序

#### 新增Mo算法题目

16. **Number of Different Substrings (SPOJ SUBST1)**
    - 题目来源: SPOJ
    - 链接: https://www.spoj.com/problems/SUBST1/
    - 难度: 中等
    - 解法: 后缀数组 + Mo算法

17. **Count on a tree II (SPOJ COT2)**
    - 题目来源: SPOJ
    - 链接: https://www.spoj.com/problems/COT2/
    - 难度: 困难
    - 解法: 树上Mo算法

18. **Gerrymandering (Codeforces 1019A)**
    - 题目来源: Codeforces
    - 链接: https://codeforces.com/problemset/problem/1019/A
    - 难度: 2300
    - 解法: Mo算法优化

19. **Sasha and Array (Codeforces 1109E)**
    - 题目来源: Codeforces
    - 链接: https://codeforces.com/problemset/problem/1109/E
    - 难度: 2500
    - 解法: 分块 + 线段树

20. **Ant colony (Codeforces 474F)**
    - 题目来源: Codeforces
    - 链接: https://codeforces.com/problemset/problem/474/F
    - 难度: 2000
    - 解法: 分块 + GCD

### 3. 分块重构题目

21. **Array Destruction (Codeforces 1476F)**
    - 题目来源: Codeforces
    - 链接: https://codeforces.com/problemset/problem/1476/F
    - 难度: 2400
    - 解法: 分块重构 + 动态规划

22. **Yet Another Array Queries Problem (Codeforces 863D)**
    - 题目来源: Codeforces
    - 链接: https://codeforces.com/problemset/problem/863/D
    - 难度: 2200
    - 解法: 分块重构

### 4. 分块+DP题目

23. **Array and Operations (Codeforces 498C)**
    - 题目来源: Codeforces
    - 链接: https://codeforces.com/problemset/problem/498/C
    - 难度: 2300
    - 解法: 分块优化动态规划

24. **Maximum Subrectangle (Codeforces 1060C)**
    - 题目来源: Codeforces
    - 链接: https://codeforces.com/problemset/problem/1060/C
    - 难度: 1900
    - 解法: 分块 + 二维前缀和

### 5. 树上分块题目

25. **Distance in Tree (Codeforces 161D)**
    - 题目来源: Codeforces
    - 链接: https://codeforces.com/problemset/problem/161/D
    - 难度: 1800
    - 解法: 树上分块

26. **Tree and Queries (Codeforces 375D)**
    - 题目来源: Codeforces
    - 链接: https://codeforces.com/problemset/problem/375/D
    - 难度: 2400
    - 解法: 树上Mo算法

27. **XOR on Tree (Codeforces 842D)**
    - 题目来源: Codeforces
    - 链接: https://codeforces.com/problemset/problem/842/D
    - 难度: 2300
    - 解法: 树上分块 + Trie

## 题目难度分布

- 简单（1000-1500）: 2题
- 中等（1500-2000）: 8题
- 困难（2000-2500）: 12题
- 极难（2500+）: 5题

## 平台分布

- Codeforces: 15题
- LeetCode: 1题
- SPOJ: 3题
- 洛谷: 3题
- LightOJ: 1题
- 其他: 5题

## 算法技巧总结

### 分块算法核心思想
1. **数据分块**: 将数据分成√n块，平衡预处理和查询时间
2. **预处理优化**: 对小块数据进行预处理，大块数据暴力计算
3. **定期重构**: 当修改次数达到阈值时重新计算块信息

### Mo算法核心思想
1. **离线处理**: 将所有查询收集后统一处理
2. **查询排序**: 按照特定规则排序查询以最小化指针移动
3. **滑动窗口**: 维护当前窗口信息，支持快速添加删除

### 时间复杂度分析
- 标准分块: O(√n) 查询/更新
- Mo算法: O((n+m)√n)
- 分块重构: O(√n) 平均复杂度

### 空间复杂度分析
- 通常为O(n)或O(n√n)，取决于预处理策略

## 工程化考量

### 异常处理
1. 输入验证和边界检查
2. 内存使用监控
3. 错误恢复机制

### 性能优化
1. 块大小选择优化
2. 缓存友好性设计
3. 常数项优化

### 可维护性
1. 模块化设计
2. 详细注释
3. 测试用例覆盖

## 面试与笔试要点

### 笔试核心
1. 代码模板准备
2. 边界条件处理
3. 时间复杂度分析

### 面试核心
1. 算法原理理解
2. 优化思路阐述
3. 工程化考量

## 学习路径建议

1. **初级阶段**: 标准分块题目（1-5题）
2. **中级阶段**: Mo算法题目（11-15题）
3. **高级阶段**: 复杂分块题目（16-27题）
4. **专家阶段**: 创新应用和优化

## 总结

分块算法和Mo算法是处理大规模数据查询问题的重要工具，通过合理的数据分块和预处理策略，可以在保证算法正确性的同时显著提升性能。掌握这些算法对于算法竞赛和工程实践都具有重要意义。

===============================================

文件: PROBLEMS_EXTENDED.md
===============================================
# 分块算法 (Sqrt Decomposition) 题目大全

## 已有题目 (class175目录中)

### 1. 哈希冲突 (Code01_HashCollision)
- **题目链接**: https://www.luogu.com.cn/problem/P3396
- **题意**: 支持两种操作：
  1. 查询满足 i % x == y 的所有位置的 arr[i] 之和
  2. 单点更新
- **解法**: 对于x <= √n的情况预处理，对于x > √n的情况暴力查询

### 2. 数组查询 (Code02_ArrayQueries)
- **题目链接**: https://www.luogu.com.cn/problem/CF797E
- **题意**: 查询从位置p开始，每次跳跃arr[p]+k步，直到越界需要的步数
- **解法**: 对于k <= √n的情况预处理dp，对于k > √n的情况暴力计算

### 3. 等差数列求和 (Code03_SumOfProgression)
- **题目链接**: https://www.luogu.com.cn/problem/CF1921F
- **题意**: 查询等差数列子序列的加权和
- **解法**: 预处理前缀和与加权前缀和

### 4. 初始化 (Code04_Initialization)
- **题目链接**: https://www.luogu.com.cn/problem/P5309
- **题意**: 支持区间加法和区间求和
- **解法**: 分块维护区间和

### 5. 雅加达的摩天楼 (Code05_Skyscraper)
- **题目链接**: https://www.luogu.com.cn/problem/P3645
- **题意**: BFS最短路，狗可以在建筑物间跳跃
- **解法**: 分块优化BFS

### 6. 最少划分 (Code06_TillCollapse)
- **题目链接**: https://www.luogu.com.cn/problem/CF786C
- **题意**: 将数组划分成最少段数，每段不同数字种类不超过k
- **解法**: 分块优化查询

### 7. 给你一棵树 (Code07_GivenTree)
- **题目链接**: https://www.luogu.com.cn/problem/CF1039D
- **题意**: 树上路径匹配问题
- **解法**: 分块优化动态规划

### 8. Serega and Fun (Code08_SeregaAndFun)
- **题目链接**: https://codeforces.com/problemset/problem/455/D
- **题意**: 支持查询区间众数和元素移动操作
- **解法**: 分块维护，定期重构

### 9. Little Elephant and Array (Code09_LittleElephantAndArray)
- **题目链接**: https://codeforces.com/problemset/problem/220/B
- **题意**: 查询区间内满足值等于出现次数的数的个数
- **解法**: Mo算法（离线分块）

### 10. D-query (Code10_DQuery)
- **题目链接**: https://www.spoj.com/problems/DQUERY/
- **题意**: 给定一个数组，多次查询区间[l,r]内不同数字的个数
- **解法**: Mo算法（离线分块）

### 11. Powerful array (Code11_PowerfulArray)
- **题目链接**: https://codeforces.com/problemset/problem/86/D
- **题意**: 给定一个数组，多次查询区间[l,r]的加权和，权重为每个数字出现次数的平方
- **解法**: Mo算法（离线分块）

### 12. Holes (Code12_Holes)
- **题目链接**: https://codeforces.com/problemset/problem/13/E
- **题意**: 给定一个数组，支持两种操作：1. 查询从位置i开始跳出数组需要的步数；2. 修改某个位置的值
- **解法**: 分块维护跳跃信息

### 13. Points on Plane (Code13_PointsOnPlane)
- **题目链接**: https://codeforces.com/problemset/problem/1181/C
- **题意**: 在一个网格中统计满足条件的点对数量
- **解法**: 分块优化计算

### 14. Ann and Books (Code14_AnnAndBooks)
- **题目链接**: https://codeforces.com/problemset/problem/877/E
- **题意**: 给定一个数组，多次查询区间[l,r]内满足特定条件的子数组个数
- **解法**: 分块维护前缀信息

### 15. XOR and Favorite Number (Code15_XorAndFavoriteNumber)
- **题目链接**: https://codeforces.com/problemset/problem/617/E
- **题意**: 给定一个数组和一个数字k，多次查询区间[l,r]内异或值等于k的子数组对数
- **解法**: Mo算法（离线分块）+ 异或前缀和

### 16. Little Elephant and Array (Code16_LittleElephantAndArray)
- **题目链接**: https://codeforces.com/problemset/problem/220/B
- **题意**: 查询区间内满足值等于出现次数的数的个数
- **解法**: Mo算法（离线分块）

### 17. Tree and Queries (Code17_TreeAndQueries)
- **题目链接**: https://codeforces.com/problemset/problem/375/D
- **题意**: 树上查询，给定一棵树和每个节点的颜色，多次查询子树内满足条件的颜色数量
- **解法**: 树上Mo算法（离线分块）

### 18. Destiny (Code18_Destiny)
- **题目链接**: https://codeforces.com/problemset/problem/840/D
- **题意**: 给定一个数组，多次查询区间[l,r]内出现次数超过阈值的数字
- **解法**: 分块维护频率信息

### 19. PATULJCI (Code41_Patuljci)
- **题目链接**: https://www.spoj.com/problems/PATULJCI/
- **题意**: 给定一个数组和多个查询，每个查询要求找出区间[l,r]内的众数（出现次数最多的元素）
- **解法**: 莫队算法（离线分块）

### 20. MKTHNUM (Code42_Mkthnum)
- **题目链接**: https://www.spoj.com/problems/MKTHNUM/
- **题意**: 给定一个数组和多个查询，每个查询要求找出区间[l,r]内第k小的数字
- **解法**: 莫队算法（离线分块）+ 离散化

### 21. GIVEAWAY (Code43_Giveaway)
- **题目链接**: https://www.spoj.com/problems/GIVEAWAY/
- **题意**: 维护一个数组，支持两种操作：1. C x y: 将位置x的值更新为y；2. Q l r k: 查询区间[l,r]内大于等于k的元素个数
- **解法**: 分块算法维护排序块

## 补充题目列表

### 19. Give Away
- **来源**: SPOJ
- **题目链接**: https://www.spoj.com/problems/GIVEAWAY/
- **题意**: 给定一个数组，支持区间更新和区间查询操作
- **解法**: 分块维护区间信息

### 20. RACETIME
- **来源**: SPOJ
- **题目链接**: https://www.spoj.com/problems/RACETIME/
- **题意**: 给定一个数组，支持区间更新和区间查询操作
- **解法**: 分块维护区间信息

### 21. Till I Collapse
- **来源**: Codeforces
- **题目链接**: https://codeforces.com/problemset/problem/786/C
- **题意**: 将数组划分成最少段数，每段不同数字种类不超过k
- **解法**: 分块优化查询

### 22. Bridges
- **来源**: APIO
- **题目链接**: https://apio2019.toki.id/problems/bridges/
- **题意**: 维护图的连通性，支持边权修改和连通性查询
- **解法**: 分块处理修改操作

### 23. Curious Robin Hood
- **来源**: LightOJ
- **题目链接**: http://lightoj.com/volume_showproblem.php?problem=1112
- **题意**: 给定一个数组，支持单点更新和区间求和操作
- **解法**: 分块维护区间和

### 24. Catapult that ball
- **来源**: SPOJ
- **题目链接**: https://www.spoj.com/problems/THRBL/
- **题意**: 给定一个数组，多次查询区间内最大值是否满足特定条件
- **解法**: 分块维护区间最大值

### 25. K-th Number
- **来源**: SPOJ
- **题目链接**: https://www.spoj.com/problems/MKTHNUM/
- **题意**: 给定一个数组，多次查询区间[l,r]内第k小的数字
- **解法**: 分块维护排序信息

### 26. Election Posters
- **来源**: SPOJ
- **题目链接**: https://www.spoj.com/problems/POSTERS/
- **题意**: 区间覆盖问题，查询最终可见的海报数量
- **解法**: 分块维护区间覆盖信息

### 27. Array Transformer
- **来源**: UVa
- **题目链接**: https://onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=3255
- **题意**: 给定一个数组，支持区间更新和区间查询操作
- **解法**: 分块维护区间信息

### 28. Range Sum Query - Mutable
- **来源**: LeetCode
- **题目链接**: https://leetcode.com/problems/range-sum-query-mutable/
- **题意**: 给定一个数组，支持单点更新和区间求和操作
- **解法**: 分块维护区间和

### 29. Range Frequency Queries
- **来源**: LeetCode
- **题目链接**: https://leetcode.com/problems/range-frequency-queries/
- **题意**: 设计一个数据结构来查找给定子数组中给定值的频率
- **解法**: 分块维护频率信息

### 30. Fruits Into Baskets III
- **来源**: LeetCode
- **题目链接**: https://leetcode.com/problems/fruits-into-baskets-iii/
- **题意**: 在一个数组中找到满足特定条件的最长子数组
- **解法**: 分块优化滑动窗口

### 31. DZY Loves Colors
- **来源**: Codeforces
- **题目链接**: http://codeforces.com/contest/444/problem/C
- **题意**: 支持两种操作：1. 区间染色并累加颜色变化量；2. 查询区间颜色变化量的总和
- **解法**: 分块维护区间颜色信息和懒标记

### 32. LOJ 分块一
- **来源**: LibreOJ
- **题目链接**: https://loj.ac/problem/6277
- **题意**: 实现数据的区间修改和单点查询
- **解法**: 分块维护区间加法标记

### 33. 牛牛算题
- **来源**: 牛客编程巅峰赛
- **题意**: 计算对于小于等于n的每个数p，求n = p×k + m中的k×m之和
- **解法**: 整数分块优化

### 34. 最大子阵列
- **来源**: 计蒜客
- **题目链接**: https://www.jisuanke.com/course/705/27296
- **题意**: 在数组中找出和最大的连续子数组
- **解法**: 分块预处理子数组信息

### 35. 区间第k大
- **来源**: POJ
- **题目链接**: http://poj.org/problem?id=2104
- **题意**: 多次查询区间[l,r]内第k小的数字
- **解法**: 分块维护排序块

### 36. 扫描线问题
- **来源**: HDU
- **题目链接**: http://acm.hdu.edu.cn/showproblem.php?pid=1542
- **题意**: 计算矩形覆盖的面积
- **解法**: 分块处理扫描线

### 37. 彩色树
- **来源**: AizuOJ
- **题目链接**: https://onlinejudge.u-aizu.ac.jp/problems/2667
- **题意**: 树上路径查询，求路径上不同颜色的数量
- **解法**: 树上分块 + Mo算法

### 38. 区间众数查询
- **来源**: 洛谷
- **题目链接**: https://www.luogu.com.cn/problem/P3709
- **题意**: 多次查询区间[l,r]内的众数
- **解法**: 分块预处理众数信息

### 39. 二维区间查询
- **来源**: 牛客
- **题目链接**: https://ac.nowcoder.com/acm/contest/884/A
- **题意**: 二维数组的区间查询和更新
- **解法**: 二维分块

### 40. 滑动窗口最大值
- **来源**: LeetCode
- **题目链接**: https://leetcode.com/problems/sliding-window-maximum/
- **题意**: 给定一个数组和滑动窗口大小，输出每个窗口的最大值
- **解法**: 分块预处理窗口信息

## 题目分类

### 1. 区间查询类
- D-query
- Powerful array
- Ann and Books
- XOR and Favorite Number
- Tree and Queries
- Destiny
- K-th Number
- Range Frequency Queries
- PATULJCI (Code41_Patuljci)
- MKTHNUM (Code42_Mkthnum)
- GIVEAWAY (Code43_Giveaway)

### 2. 区间更新类
- Give Away
- RACETIME
- Curious Robin Hood
- Election Posters
- Array Transformer
- Range Sum Query - Mutable
- GIVEAWAY (Code43_Giveaway)

### 3. 跳跃类
- Holes
- Points on Plane
- Serega and Fun

### 4. 划分类
- Till I Collapse
- 最少划分 (Code06_TillCollapse)

### 5. 树上问题
- Tree and Queries
- 给你一棵树 (Code07_GivenTree)

### 6. 优化类
- Bridges
- Catapult that ball
- Fruits Into Baskets III

## 解法分类

### 1. 标准分块
- 哈希冲突 (Code01_HashCollision)
- 数组查询 (Code02_ArrayQueries)
- 初始化 (Code04_Initialization)
- 雅加达的摩天楼 (Code05_Skyscraper)
- Serega and Fun (Code08_SeregaAndFun)
- Curious Robin Hood
- Range Sum Query - Mutable
- GIVEAWAY (Code43_Giveaway)

### 2. Mo算法（离线分块）
- Little Elephant and Array (Code09_LittleElephantAndArray)
- D-query
- Powerful array
- XOR and Favorite Number
- Tree and Queries
- PATULJCI (Code41_Patuljci)
- MKTHNUM (Code42_Mkthnum)

### 3. 分块重构
- Serega and Fun (Code08_SeregaAndFun)

### 4. 分块+DP
- 等差数列求和 (Code03_SumOfProgression)
- 给你一棵树 (Code07_GivenTree)

### 5. 树上分块
- Tree and Queries

## 时间复杂度分析

大多数分块算法的时间复杂度为O(√n)或O(n√n)，具体取决于问题类型：
- 区间查询：O(√n)
- 区间更新：O(√n)
- 单点更新：O(1)或O(√n)
- Mo算法：O((n+m)√n)，其中n为数组长度，m为查询数量

## 空间复杂度分析

分块算法的空间复杂度通常为O(n)，需要额外存储块信息和预处理数据。

## 学习建议

1. **从简单题目开始**：建议先掌握标准分块算法，再学习Mo算法等高级技巧
2. **理解核心思想**：分块的本质是平衡预处理时间和查询时间
3. **掌握实现细节**：注意边界处理、块大小选择等细节
4. **多做练习**：通过大量练习掌握不同场景下的分块应用
5. **学习优化技巧**：了解分块重构、树上分块等高级技巧

===============================================

文件: README.md
===============================================
# 压缩算法实现

本目录包含了三种经典的无损数据压缩算法的实现：算术编码、LZW字典编码和Huffman编码。

## 目录结构

```
compression/
├── arithmetic_coding/          # 算术编码算法实现
│   ├── ArithmeticCoding.java   # Java实现
│   ├── arithmetic_coding.py    # Python实现
│   ├── arithmetic_coding.cpp   # C++实现
│   └── README.md               # 算术编码说明
├── huffman_encoding/           # Huffman编码算法实现
│   ├── HuffmanEncoding.java    # Java实现
│   ├── huffman_encoding.py     # Python实现
│   ├── huffman_encoding.cpp    # C++实现
│   └── README.md               # Huffman编码说明
├── lzw_encoding/               # LZW编码算法实现
│   ├── LZWEncoding.java        # Java实现
│   ├── lzw_encoding.py         # Python实现
│   ├── lzw_encoding.cpp        # C++实现
│   └── README.md               # LZW编码说明
├── test_compression.py         # 综合测试脚本
└── README.md                   # 本文件
```

## 算术编码 (Arithmetic Coding)

### 算法原理
算术编码是一种无损数据压缩方法，它将整个输入消息编码为一个位于[0,1)区间内的实数。

1. 统计字符频率，构建概率模型
2. 根据概率模型构建累积分布函数(CDF)
3. 对输入字符串进行编码，将整个字符串映射到[0,1)区间的一个子区间
4. 解码时根据相同的概率模型和编码值还原原始字符串

### 时间复杂度
- 编码：O(n)，其中n是输入字符串长度
- 解码：O(n)，其中n是输出字符串长度

### 空间复杂度
- O(k)，其中k是不同字符的数量

### 优势
1. 压缩率高，可以达到信息熵的理论极限
2. 可以处理任意精度的概率
3. 适合处理具有明显统计特性的数据

### 劣势
1. 实现复杂，需要处理浮点数精度问题
2. 编码和解码必须使用相同的概率模型
3. 对于短字符串，可能不如其他简单编码方法高效

### 应用场景
1. 图像压缩（JPEG）
2. 音频压缩
3. 数据压缩标准

## LZW编码 (Lempel-Ziv-Welch)

### 算法原理
LZW是一种无损数据压缩算法，属于字典编码的一种。

1. 初始化字典，包含所有可能的单字符
2. 读取输入字符串，查找字典中最长的匹配字符串
3. 输出匹配字符串对应的编码
4. 将匹配字符串加上下一个字符组成的新字符串添加到字典中
5. 重复步骤2-4直到处理完所有输入

### 时间复杂度
- O(n)，其中n是输入字符串长度

### 空间复杂度
- O(d)，其中d是字典中条目的数量

### 优势
1. 实现相对简单
2. 压缩效果好，特别适合重复模式较多的数据
3. 不需要预先知道数据的统计特性
4. 编码和解码过程对称

### 劣势
1. 需要维护字典，占用内存
2. 对于随机数据压缩效果不佳
3. 字典可能会变得很大

### 应用场景
1. GIF图像格式
2. TIFF图像格式
3. Unix系统的compress工具

## Huffman编码

### 算法原理
Huffman编码是一种无损数据压缩算法，它根据字符出现的频率为每个字符分配不同长度的编码，
频率高的字符分配较短的编码，频率低的字符分配较长的编码，从而实现数据压缩。

1. 统计输入数据中每个字符的频率
2. 构建Huffman树（最优二叉树）
3. 根据Huffman树生成每个字符的编码
4. 使用生成的编码对原始数据进行编码
5. 解码时根据Huffman树和编码还原原始数据

### 时间复杂度
- 构建Huffman树：O(n log n)，其中n是不同字符的数量
- 编码：O(m)，其中m是输入数据的长度
- 解码：O(m)，其中m是编码后数据的长度

### 空间复杂度
- O(n)，其中n是不同字符的数量

### 优势
1. 压缩率高，特别是对于字符频率差异较大的数据
2. 实现相对简单
3. 解码过程确定且无歧义
4. 前缀编码特性保证了解码的唯一性

### 劣势
1. 需要传输或存储Huffman树信息
2. 对于字符频率分布均匀的数据压缩效果不佳
3. 需要两次遍历数据（统计频率和编码）

### 应用场景
1. 文件压缩（如ZIP格式）
2. 图像压缩（JPEG中的部分应用）
3. 网络传输数据压缩

## 相关题目和训练

### 算术编码相关题目

1. **Huffman编码实现**
   - 题目描述：实现Huffman编码和解码算法
   - 平台：经典算法题
   - 难度：中等

2. **数据压缩与解压缩**
   - 题目描述：设计一个简单的文本压缩算法
   - 平台：面试题
   - 难度：中等

3. **浮点数精度处理**
   - 题目描述：处理算术编码中的浮点数精度问题
   - 平台：工程实践
   - 难度：困难

4. **LeetCode 443. String Compression**
   - 题目描述：给定一个字符数组，使用特定算法进行原地压缩
   - 平台：LeetCode
   - 难度：中等
   - 链接：https://leetcode.com/problems/string-compression/

5. **LeetCode 1531. String Compression II**
   - 题目描述：通过最多删除k个字符来最小化运行长度编码的长度
   - 平台：LeetCode
   - 难度：困难
   - 链接：https://leetcode.com/problems/string-compression-ii/

### LZW编码相关题目

1. **GIF图像解码**
   - 题目描述：实现GIF图像的LZW解码
   - 平台：图像处理
   - 难度：困难

2. **字典大小优化**
   - 题目描述：优化LZW算法中字典的大小管理
   - 平台：性能优化
   - 难度：中等

3. **压缩率分析**
   - 题目描述：分析不同数据类型的LZW压缩率
   - 平台：数据分析
   - 难度：中等

4. **Codeforces 653B. Bear and Compressing**
   - 题目描述：字符串压缩问题
   - 平台：Codeforces
   - 难度：中等
   - 链接：https://codeforces.com/problemset/problem/653/B

5. **HackerRank Tree: Huffman Decoding**
   - 题目描述：Huffman解码问题
   - 平台：HackerRank
   - 难度：中等
   - 链接：https://www.hackerrank.com/challenges/tree-huffman-decoding/

### Huffman编码相关题目

1. **GeeksforGeeks Huffman编码练习题**
   - 题目描述：基于Huffman编码的各种练习题
   - 平台：GeeksforGeeks
   - 难度：中等
   - 链接：https://www.geeksforgeeks.org/dsa/practice-questions-on-huffman-encoding/

2. **Huffman编码实现**
   - 题目描述：实现完整的Huffman编码和解码系统
   - 平台：经典算法题
   - 难度：中等

3. **压缩率优化**
   - 题目描述：优化Huffman编码的压缩率
   - 平台：性能优化
   - 难度：困难

4. **多字符集支持**
   - 题目描述：扩展Huffman编码以支持Unicode字符
   - 平台：工程实践
   - 难度：中等

### 综合压缩算法题目

1. **LeetCode 394. Decode String**
   - 题目描述：解码编码字符串
   - 平台：LeetCode
   - 难度：中等
   - 链接：https://leetcode.com/problems/decode-string/

2. **LeetCode 727. Minimum Window Subsequence**
   - 题目描述：最小窗口子序列（与压缩算法思想相关）
   - 平台：LeetCode
   - 难度：困难
   - 链接：https://leetcode.com/problems/minimum-window-subsequence/

3. **Codeforces 99999203. Huffman Encoding**
   - 题目描述：Huffman编码长度计算
   - 平台：Codeforces
   - 难度：中等
   - 链接：https://codeforces.com/problemsets/acmsguru/problem/99999/203

## 工程化考量

### 异常处理
1. 输入验证：检查输入数据的有效性
2. 边界条件：处理空输入、极端输入等
3. 内存管理：防止字典过大导致的内存问题
4. 错误恢复：处理编码/解码过程中的错误

### 性能优化
1. 字典初始化优化
2. 字符串匹配优化
3. 内存使用优化
4. 缓存友好性优化

### 可配置性
1. 字典大小限制
2. 编码精度设置
3. 错误处理策略
4. 压缩级别选择

## 数学原理

### 算术编码
- 基于信息论中的熵编码原理
- 利用字符的概率分布进行编码
- 可以达到理论最优压缩率

### LZW编码
- 基于字典的压缩方法
- 利用数据的重复模式
- 自适应字典构建

### Huffman编码
- 基于字符频率的最优编码
- 构建最优二叉树
- 前缀编码保证唯一可解码性

## 语言特性差异

### Java
- 使用HashMap和TreeMap进行字典管理
- 自动内存管理
- 异常处理机制完善
- 面向对象特性支持

### Python
- 使用字典(dict)进行字典管理
- 动态类型系统
- 简洁的语法表达
- 丰富的标准库支持

### C++
- 手动内存管理
- 高性能实现
- 模板支持
- 指针操作灵活性

## 面试重点

### 理论知识
1. 算法的时间和空间复杂度分析
2. 压缩算法的理论基础
3. 信息熵的概念和应用
4. 前缀编码的特性

### 实践技能
1. 代码实现能力
2. 边界条件处理
3. 性能优化技巧
4. 调试和测试能力

### 工程思维
1. 异常处理和错误恢复
2. 代码可维护性
3. 系统设计能力
4. 性能与资源权衡

## 学习建议

1. **理解原理**：深入理解每种算法的数学原理
2. **动手实践**：亲自实现算法并测试不同数据
3. **性能分析**：分析算法在不同场景下的性能表现
4. **工程应用**：了解算法在实际项目中的应用
5. **扩展学习**：学习更多压缩算法，如Run-Length编码、Burrows-Wheeler变换等

===============================================

文件: README_1.md
===============================================
# 算术编码 (Arithmetic Coding)

## 算法简介

算术编码是一种无损数据压缩方法，它将整个输入消息编码为一个位于[0,1)区间内的实数。

## 算法原理

1. 统计字符频率，构建概率模型
2. 根据概率模型构建累积分布函数(CDF)
3. 对输入字符串进行编码，将整个字符串映射到[0,1)区间的一个子区间
4. 解码时根据相同的概率模型和编码值还原原始字符串

## 时间复杂度

- 编码：O(n)，其中n是输入字符串长度
- 解码：O(n)，其中n是输出字符串长度

## 空间复杂度

- O(k)，其中k是不同字符的数量

## 文件说明

- `ArithmeticCoding.java` - Java实现
- `arithmetic_coding.py` - Python实现
- `arithmetic_coding.cpp` - C++实现

## 应用场景

1. 图像压缩（JPEG）
2. 音频压缩
3. 数据压缩标准

===============================================

文件: README_10.md
===============================================
# 线性枚举算法专题

## 算法原理

线性枚举（Linear Enumeration），也称为穷举法或暴力搜索，是一种最基本、最直接的算法思想。它的核心思想是：

- 按照某种顺序（通常是从小到大或从左到右）依次检查所有可能的情况
- 对于满足条件的情况进行处理或记录
- 遍历完所有情况后，得到问题的解或结果

线性枚举的优点是实现简单、逻辑清晰，缺点是效率通常较低，时间复杂度往往为O(n)或更高。但在某些问题中，尤其是当问题规模较小时，线性枚举是一种非常实用的算法。

## 常见应用场景

1. **数组和链表的遍历处理**
2. **简单查找问题**
3. **计数问题**
4. **模拟过程问题**
5. **生成所有可能解**

## 经典算法题目

### 1. 两数之和

**题目链接**：https://leetcode.com/problems/two-sum/

**题目描述**：给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出和为目标值 target 的那两个整数，并返回它们的数组下标。

**解题思路**：
- 使用两层循环枚举所有可能的数对
- 对于每对数，检查它们的和是否等于目标值
- 如果找到符合条件的数对，返回它们的下标

**代码实现**：

**Java代码**：
```java
class Solution {
    public int[] twoSum(int[] nums, int target) {
        int n = nums.length;
        // 枚举所有可能的数对
        for (int i = 0; i < n; i++) {
            for (int j = i + 1; j < n; j++) {
                if (nums[i] + nums[j] == target) {
                    return new int[] {i, j};
                }
            }
        }
        // 没有找到符合条件的数对
        return new int[] {};
    }
}
```

**Python代码**：
```python
class Solution:
    def twoSum(self, nums: List[int], target: int) -> List[int]:
        n = len(nums)
        # 枚举所有可能的数对
        for i in range(n):
            for j in range(i + 1, n):
                if nums[i] + nums[j] == target:
                    return [i, j]
        # 没有找到符合条件的数对
        return []
```

**C++代码**：
```cpp
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        int n = nums.size();
        // 枚举所有可能的数对
        for (int i = 0; i < n; i++) {
            for (int j = i + 1; j < n; j++) {
                if (nums[i] + nums[j] == target) {
                    return {i, j};
                }
            }
        }
        // 没有找到符合条件的数对
        return {};
    }
};
```

### 2. 最大子数组和

**题目链接**：https://leetcode.com/problems/maximum-subarray/

**题目描述**：给你一个整数数组 nums ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。

**解题思路**：
- 枚举所有可能的子数组
- 计算每个子数组的和，并记录最大值

**代码实现**：

**Java代码**：
```java
class Solution {
    public int maxSubArray(int[] nums) {
        int n = nums.length;
        int maxSum = Integer.MIN_VALUE;
        
        // 枚举子数组的起始位置
        for (int i = 0; i < n; i++) {
            int currentSum = 0;
            // 枚举子数组的结束位置
            for (int j = i; j < n; j++) {
                currentSum += nums[j];
                maxSum = Math.max(maxSum, currentSum);
            }
        }
        
        return maxSum;
    }
}
```

**Python代码**：
```python
class Solution:
    def maxSubArray(self, nums: List[int]) -> int:
        n = len(nums)
        max_sum = float('-inf')
        
        # 枚举子数组的起始位置
        for i in range(n):
            current_sum = 0
            # 枚举子数组的结束位置
            for j in range(i, n):
                current_sum += nums[j]
                if current_sum > max_sum:
                    max_sum = current_sum
        
        return max_sum
```

**C++代码**：
```cpp
class Solution {
public:
    int maxSubArray(vector<int>& nums) {
        int n = nums.size();
        int maxSum = INT_MIN;
        
        // 枚举子数组的起始位置
        for (int i = 0; i < n; i++) {
            int currentSum = 0;
            // 枚举子数组的结束位置
            for (int j = i; j < n; j++) {
                currentSum += nums[j];
                maxSum = max(maxSum, currentSum);
            }
        }
        
        return maxSum;
    }
};
```

### 3. 有效的括号

**题目链接**：https://leetcode.com/problems/valid-parentheses/

**题目描述**：给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串 s ，判断字符串是否有效。

**解题思路**：
- 使用栈来匹配括号
- 线性枚举字符串中的每个字符
- 如果是左括号，入栈
- 如果是右括号，检查栈顶元素是否匹配

**代码实现**：

**Java代码**：
```java
import java.util.Stack;

class Solution {
    public boolean isValid(String s) {
        Stack<Character> stack = new Stack<>();
        
        // 线性枚举每个字符
        for (char c : s.toCharArray()) {
            // 左括号入栈
            if (c == '(' || c == '{' || c == '[') {
                stack.push(c);
            } else {
                // 右括号，检查栈是否为空或栈顶是否匹配
                if (stack.isEmpty()) {
                    return false;
                }
                
                char top = stack.pop();
                if ((c == ')' && top != '(') ||
                    (c == '}' && top != '{') ||
                    (c == ']' && top != '[')) {
                    return false;
                }
            }
        }
        
        // 最后栈应该为空
        return stack.isEmpty();
    }
}
```

**Python代码**：
```python
class Solution:
    def isValid(self, s: str) -> bool:
        stack = []
        
        # 定义括号匹配关系
        brackets_map = {
            ')': '(',
            '}': '{',
            ']': '['
        }
        
        # 线性枚举每个字符
        for char in s:
            # 左括号入栈
            if char in '({[':
                stack.append(char)
            # 右括号，检查匹配
            elif char in ')}]':
                if not stack or stack.pop() != brackets_map[char]:
                    return False
        
        # 最后栈应该为空
        return len(stack) == 0
```

**C++代码**：
```cpp
#include <stack>
#include <unordered_map>
using namespace std;

class Solution {
public:
    bool isValid(string s) {
        stack<char> st;
        unordered_map<char, char> bracketsMap = {
            {')', '('},
            {'}', '{'},
            {']', '['}
        };
        
        // 线性枚举每个字符
        for (char c : s) {
            // 左括号入栈
            if (c == '(' || c == '{' || c == '[') {
                st.push(c);
            } else {
                // 右括号，检查栈是否为空或栈顶是否匹配
                if (st.empty() || st.top() != bracketsMap[c]) {
                    return false;
                }
                st.pop();
            }
        }
        
        // 最后栈应该为空
        return st.empty();
    }
};
```

### 4. 字符串中的第一个唯一字符

**题目链接**：https://leetcode.com/problems/first-unique-character-in-a-string/

**题目描述**：给定一个字符串 s ，找到它的第一个不重复的字符，并返回它的索引。如果不存在，则返回 -1。

**解题思路**：
- 第一次线性枚举：统计每个字符出现的次数
- 第二次线性枚举：找到第一个出现次数为1的字符

**代码实现**：

**Java代码**：
```java
class Solution {
    public int firstUniqChar(String s) {
        // 统计每个字符出现的次数
        int[] count = new int[26];
        for (char c : s.toCharArray()) {
            count[c - 'a']++;
        }
        
        // 找到第一个出现次数为1的字符
        for (int i = 0; i < s.length(); i++) {
            if (count[s.charAt(i) - 'a'] == 1) {
                return i;
            }
        }
        
        return -1;
    }
}
```

**Python代码**：
```python
class Solution:
    def firstUniqChar(self, s: str) -> int:
        # 统计每个字符出现的次数
        char_count = {}
        for char in s:
            char_count[char] = char_count.get(char, 0) + 1
        
        # 找到第一个出现次数为1的字符
        for i, char in enumerate(s):
            if char_count[char] == 1:
                return i
        
        return -1
```

**C++代码**：
```cpp
#include <unordered_map>
using namespace std;

class Solution {
public:
    int firstUniqChar(string s) {
        // 统计每个字符出现的次数
        unordered_map<char, int> charCount;
        for (char c : s) {
            charCount[c]++;
        }
        
        // 找到第一个出现次数为1的字符
        for (int i = 0; i < (int)s.length(); i++) {
            if (charCount[s[i]] == 1) {
                return i;
            }
        }
        
        return -1;
    }
};
```

### 5. 旋转数组

**题目链接**：https://leetcode.com/problems/rotate-array/

**题目描述**：给定一个数组，将数组中的元素向右移动 k 个位置，其中 k 是非负数。

**解题思路**：
- 线性枚举数组元素
- 计算每个元素移动后的新位置
- 使用一个临时数组来存储移动后的结果
- 将临时数组复制回原数组

**代码实现**：

**Java代码**：
```java
class Solution {
    public void rotate(int[] nums, int k) {
        int n = nums.length;
        k = k % n;  // 处理k大于n的情况
        
        int[] temp = new int[n];
        
        // 计算每个元素移动后的位置
        for (int i = 0; i < n; i++) {
            temp[(i + k) % n] = nums[i];
        }
        
        // 将临时数组复制回原数组
        System.arraycopy(temp, 0, nums, 0, n);
    }
}
```

**Python代码**：
```python
class Solution:
    def rotate(self, nums: List[int], k: int) -> None:
        """Do not return anything, modify nums in-place instead."""
        n = len(nums)
        k = k % n  # 处理k大于n的情况
        
        # 切片操作实现旋转
        nums[:] = nums[-k:] + nums[:-k]
```

**C++代码**：
```cpp
class Solution {
public:
    void rotate(vector<int>& nums, int k) {
        int n = nums.size();
        k = k % n;  // 处理k大于n的情况
        
        vector<int> temp(n);
        
        // 计算每个元素移动后的位置
        for (int i = 0; i < n; i++) {
            temp[(i + k) % n] = nums[i];
        }
        
        // 将临时数组复制回原数组
        nums = temp;
    }
};
```

### 6. 存在重复元素

**题目链接**：https://leetcode.com/problems/contains-duplicate/

**题目描述**：给定一个整数数组，判断是否存在重复元素。

**解题思路**：
- 线性枚举数组中的每个元素
- 使用哈希集合记录已经出现过的元素
- 如果当前元素已经在集合中，说明存在重复

**代码实现**：

**Java代码**：
```java
import java.util.HashSet;
import java.util.Set;

class Solution {
    public boolean containsDuplicate(int[] nums) {
        Set<Integer> seen = new HashSet<>();
        
        for (int num : nums) {
            if (seen.contains(num)) {
                return true;
            }
            seen.add(num);
        }
        
        return false;
    }
}
```

**Python代码**：
```python
class Solution:
    def containsDuplicate(self, nums: List[int]) -> bool:
        seen = set()
        
        for num in nums:
            if num in seen:
                return True
            seen.add(num)
        
        return False
```

**C++代码**：
```cpp
#include <unordered_set>
using namespace std;

class Solution {
public:
    bool containsDuplicate(vector<int>& nums) {
        unordered_set<int> seen;
        
        for (int num : nums) {
            if (seen.count(num)) {
                return true;
            }
            seen.insert(num);
        }
        
        return false;
    }
};
```

### 7. 加一

**题目链接**：https://leetcode.com/problems/plus-one/

**题目描述**：给定一个由 整数 组成的 非空 数组所表示的非负整数，在该数的基础上加一。

**解题思路**：
- 从数组的最后一个元素开始，线性枚举到第一个元素
- 对当前位加1，如果不需要进位，直接返回
- 如果需要进位，处理进位并继续枚举

**代码实现**：

**Java代码**：
```java
class Solution {
    public int[] plusOne(int[] digits) {
        int n = digits.length;
        
        // 从最后一位开始加1
        for (int i = n - 1; i >= 0; i--) {
            digits[i]++;
            // 如果不需要进位，直接返回
            if (digits[i] < 10) {
                return digits;
            }
            // 需要进位，当前位置0
            digits[i] = 0;
        }
        
        // 如果所有位都需要进位，创建新数组
        int[] newDigits = new int[n + 1];
        newDigits[0] = 1;
        return newDigits;
    }
}
```

**Python代码**：
```python
class Solution:
    def plusOne(self, digits: List[int]) -> List[int]:
        n = len(digits)
        
        # 从最后一位开始加1
        for i in range(n - 1, -1, -1):
            digits[i] += 1
            # 如果不需要进位，直接返回
            if digits[i] < 10:
                return digits
            # 需要进位，当前位置0
            digits[i] = 0
        
        # 如果所有位都需要进位，创建新数组
        return [1] + digits
```

**C++代码**：
```cpp
class Solution {
public:
    vector<int> plusOne(vector<int>& digits) {
        int n = digits.size();
        
        // 从最后一位开始加1
        for (int i = n - 1; i >= 0; i--) {
            digits[i]++;
            // 如果不需要进位，直接返回
            if (digits[i] < 10) {
                return digits;
            }
            // 需要进位，当前位置0
            digits[i] = 0;
        }
        
        // 如果所有位都需要进位，创建新数组
        vector<int> newDigits(n + 1, 0);
        newDigits[0] = 1;
        return newDigits;
    }
};
```

### 8. 移动零

**题目链接**：https://leetcode.com/problems/move-zeroes/

**题目描述**：给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。

**解题思路**：
- 线性枚举数组，用一个指针记录非零元素应该放置的位置
- 当遇到非零元素时，将其移动到指针位置，并将指针后移
- 最后，将指针之后的所有元素都设为0

**代码实现**：

**Java代码**：
```java
class Solution {
    public void moveZeroes(int[] nums) {
        int n = nums.length;
        int nonZeroPos = 0;  // 非零元素应该放置的位置
        
        // 第一步：将所有非零元素移到前面
        for (int i = 0; i < n; i++) {
            if (nums[i] != 0) {
                nums[nonZeroPos++] = nums[i];
            }
        }
        
        // 第二步：将剩下的位置填充为0
        for (int i = nonZeroPos; i < n; i++) {
            nums[i] = 0;
        }
    }
}
```

**Python代码**：
```python
class Solution:
    def moveZeroes(self, nums: List[int]) -> None:
        """Do not return anything, modify nums in-place instead."""
        n = len(nums)
        non_zero_pos = 0  # 非零元素应该放置的位置
        
        # 第一步：将所有非零元素移到前面
        for i in range(n):
            if nums[i] != 0:
                nums[non_zero_pos] = nums[i]
                non_zero_pos += 1
        
        # 第二步：将剩下的位置填充为0
        for i in range(non_zero_pos, n):
            nums[i] = 0
```

**C++代码**：
```cpp
class Solution {
public:
    void moveZeroes(vector<int>& nums) {
        int n = nums.size();
        int nonZeroPos = 0;  // 非零元素应该放置的位置
        
        // 第一步：将所有非零元素移到前面
        for (int i = 0; i < n; i++) {
            if (nums[i] != 0) {
                nums[nonZeroPos++] = nums[i];
            }
        }
        
        // 第二步：将剩下的位置填充为0
        for (int i = nonZeroPos; i < n; i++) {
            nums[i] = 0;
        }
    }
};
```

### 9. 合并两个有序数组

**题目链接**：https://leetcode.com/problems/merge-sorted-array/

**题目描述**：给你两个按 非递减顺序 排列的整数数组 nums1 和 nums2，另有两个整数 m 和 n ，分别表示 nums1 和 nums2 中的元素数目。请你 合并 nums2 到 nums1 中，使合并后的数组同样按 非递减顺序 排列。

**解题思路**：
- 从后往前线性枚举两个数组
- 比较两个数组的当前元素，将较大的放入nums1的末尾
- 处理剩余元素

**代码实现**：

**Java代码**：
```java
class Solution {
    public void merge(int[] nums1, int m, int[] nums2, int n) {
        int i = m - 1;      // nums1有效元素的最后一个位置
        int j = n - 1;      // nums2的最后一个位置
        int k = m + n - 1;  // 合并后数组的最后一个位置
        
        // 从后往前合并
        while (i >= 0 && j >= 0) {
            if (nums1[i] > nums2[j]) {
                nums1[k--] = nums1[i--];
            } else {
                nums1[k--] = nums2[j--];
            }
        }
        
        // 处理nums2中剩余的元素
        while (j >= 0) {
            nums1[k--] = nums2[j--];
        }
        
        // nums1中剩余的元素已经在正确的位置，不需要处理
    }
}
```

**Python代码**：
```python
class Solution:
    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:
        """Do not return anything, modify nums1 in-place instead."""
        i = m - 1      # nums1有效元素的最后一个位置
        j = n - 1      # nums2的最后一个位置
        k = m + n - 1  # 合并后数组的最后一个位置
        
        # 从后往前合并
        while i >= 0 and j >= 0:
            if nums1[i] > nums2[j]:
                nums1[k] = nums1[i]
                i -= 1
            else:
                nums1[k] = nums2[j]
                j -= 1
            k -= 1
        
        # 处理nums2中剩余的元素
        while j >= 0:
            nums1[k] = nums2[j]
            j -= 1
            k -= 1
```

**C++代码**：
```cpp
class Solution {
public:
    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {
        int i = m - 1;      // nums1有效元素的最后一个位置
        int j = n - 1;      // nums2的最后一个位置
        int k = m + n - 1;  // 合并后数组的最后一个位置
        
        // 从后往前合并
        while (i >= 0 && j >= 0) {
            if (nums1[i] > nums2[j]) {
                nums1[k--] = nums1[i--];
            } else {
                nums1[k--] = nums2[j--];
            }
        }
        
        // 处理nums2中剩余的元素
        while (j >= 0) {
            nums1[k--] = nums2[j--];
        }
    }
};
```

### 10. 只出现一次的数字

**题目链接**：https://leetcode.com/problems/single-number/

**题目描述**：给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。

**解题思路**：
- 使用异或运算的性质：a ^ a = 0, 0 ^ b = b
- 线性枚举数组中的每个元素，依次异或
- 最终结果就是只出现一次的元素

**代码实现**：

**Java代码**：
```java
class Solution {
    public int singleNumber(int[] nums) {
        int result = 0;
        // 异或所有元素
        for (int num : nums) {
            result ^= num;
        }
        return result;
    }
}
```

**Python代码**：
```python
class Solution:
    def singleNumber(self, nums: List[int]) -> int:
        result = 0
        # 异或所有元素
        for num in nums:
            result ^= num
        return result
```

**C++代码**：
```cpp
class Solution {
public:
    int singleNumber(vector<int>& nums) {
        int result = 0;
        // 异或所有元素
        for (int num : nums) {
            result ^= num;
        }
        return result;
    }
};
```

## 线性枚举的优化技巧

1. **剪枝优化**：在枚举过程中，对于明显不满足条件的情况提前跳过
2. **前缀和/前缀积**：预处理前缀信息，减少重复计算
3. **双指针技术**：使用两个指针同时枚举，优化时间复杂度
4. **哈希表/集合**：使用哈希结构加速查找和判断
5. **位运算**：利用位运算的特性简化计算

## 总结

线性枚举虽然是一种基础的算法思想，但它在解决各种算法问题中有着广泛的应用。通过本专题的学习，我们了解了线性枚举的基本原理、实现方法和优化技巧，并通过多个经典题目进行了实践。

在实际应用中，我们需要根据问题的特点，灵活运用线性枚举算法，并结合其他算法思想进行优化，以达到更好的性能。","}}}

===============================================

文件: README_11.md
===============================================
# 随机化基础与复杂度分析进阶

本目录包含随机化基础算法、复杂度分析进阶（摊还分析与势能分析）、高精度算法拓展以及位运算技巧的实现。所有算法都提供了Java、Python和C++三种语言的实现。

## 随机化基础

### 1. Fisher-Yates 洗牌算法

**算法思想**：从数组末尾开始，将当前位置与之前的随机位置交换，确保每个元素都有相同的概率出现在任意位置。

**复杂度分析**：
- 时间复杂度：O(n)
- 空间复杂度：O(1) - 原地洗牌

**实现文件**：
- [FisherYatesShuffle.java](FisherYatesShuffle.java)
- [fisher_yates_shuffle.py](fisher_yates_shuffle.py)
- [fisher_yates_shuffle.cpp](fisher_yates_shuffle.cpp)

**相关题目**：
- [LeetCode 384. 打乱数组](https://leetcode-cn.com/problems/shuffle-an-array/)
- [LintCode 1423. 随机洗牌](https://www.lintcode.com/problem/1423/)
- [CodeChef - SHUFFLE](https://www.codechef.com/problems/SHUFFLE)
- [HackerRank - Knuth's Permutation](https://www.hackerrank.com/contests/hourrank-25/challenges/random-number-generator)
- [牛客网 - NC145 数组中的最长山脉](https://www.nowcoder.com/practice/c3120c1c1bc44ad986259c0cf0f0b80e?tpId=188)

### 2. 随机选择第k小（Randomized Quick Select）

**算法思想**：基于快速排序的思想，随机选择pivot，将数组分区，直到找到第k小的元素。

**复杂度分析**：
- 期望时间复杂度：O(n)
- 最坏时间复杂度：O(n²)
- 空间复杂度：O(log n) - 递归调用栈

**实现文件**：
- [RandomizedSelect.java](RandomizedSelect.java)
- [randomized_select.py](randomized_select.py)
- [randomized_select.cpp](randomized_select.cpp)

**相关题目**：
- [LeetCode 215. 数组中的第K个最大元素](https://leetcode-cn.com/problems/kth-largest-element-in-an-array/)
- [LintCode 5. 第k大元素](https://www.lintcode.com/problem/5/)
- [CodeChef - KTHMAX](https://www.codechef.com/problems/KTHMAX)
- [HackerRank - Kth Largest Element](https://www.hackerrank.com/challenges/find-the-running-median/problem)
- [AtCoder - ABC142 D - Disjoint Set of Common Divisors](https://atcoder.jp/contests/abc142/tasks/abc142_d)
- [洛谷 - P1923 求第k小的数](https://www.luogu.com.cn/problem/P1923)
- [牛客网 - NC145 数组中的最长山脉](https://www.nowcoder.com/practice/c3120c1c1bc44ad986259c0cf0f0b80e?tpId=188)

### 3. 哈希冲突概率估算与素数模选择

**算法思想**：
- 哈希冲突概率估算：使用生日悖论公式计算给定元素数量和哈希表大小时的冲突概率
- 素数模选择：选择合适的素数作为哈希表大小，减少冲突

**实现文件**：
- [HashCollisionAnalysis.java](HashCollisionAnalysis.java)
- [hash_collision_analysis.py](hash_collision_analysis.py)
- [hash_collision_analysis.cpp](hash_collision_analysis.cpp)

**相关题目**：
- [LeetCode 705. 设计哈希集合](https://leetcode-cn.com/problems/design-hashset/)
- [LeetCode 706. 设计哈希映射](https://leetcode-cn.com/problems/design-hashmap/)
- [LintCode 128. 哈希函数](https://www.lintcode.com/problem/128/)
- [CodeChef - HASHTABLE](https://www.codechef.com/problems/HASHTABLE)
- [HackerEarth - Hash Tables](https://www.hackerearth.com/practice/data-structures/hash-tables/basics-of-hash-tables/practice-problems/)
- [杭电OJ - 1272 小希的迷宫](http://acm.hdu.edu.cn/showproblem.php?pid=1272)

## 复杂度分析进阶：摊还分析与势能分析

### 可并堆（二项堆）实现

**算法思想**：二项堆是一组二项树的集合，每个二项树满足堆性质，支持高效的合并操作。

**摊还分析**：
- 势能函数：选择为堆中树的数量
- 合并操作的摊还时间复杂度：O(log n)
- 插入操作的摊还时间复杂度：O(1)
- 提取最小操作的摊还时间复杂度：O(log n)

**实现文件**：
- [BinomialHeap.java](BinomialHeap.java)
- [binomial_heap.py](binomial_heap.py)
- [binomial_heap.cpp](binomial_heap.cpp)

**相关题目**：
- [LeetCode 23. 合并K个排序链表](https://leetcode-cn.com/problems/merge-k-sorted-lists/)
- [LeetCode 1046. 最后一块石头的重量](https://leetcode-cn.com/problems/last-stone-weight/)
- [CodeChef - CHEFBM](https://www.codechef.com/problems/CHEFBM)
- [AtCoder - C - Min Difference](https://atcoder.jp/contests/abc129/tasks/abc129_c)
- [SPOJ - BINOMIAL HEAP](https://www.spoj.com/problems/BINHEAP/)
- [洛谷 - P1456 Monkey King](https://www.luogu.com.cn/problem/P1456)
- [牛客网 - NC145 数组中的最长山脉](https://www.nowcoder.com/practice/c3120c1c1bc44ad986259c0cf0f0b80e?tpId=188)

## 高精度拓展

### 1. Karatsuba 乘法算法

**算法思想**：Karatsuba乘法是一种快速乘法算法，通过减少乘法运算次数来加速大整数乘法。对于两个n位数x和y，传统乘法需要O(n²)次运算，而Karatsuba算法通过将乘法分解为三个子乘法，将时间复杂度优化到约O(n^1.585)。

**核心公式**：对于x = a·10^(n/2) + b，y = c·10^(n/2) + d，则x·y = ac·10^n + (ad + bc)·10^(n/2) + bd。通过计算(ac + bd + (a+b)(c+d)) = ad + bc，只需计算三个乘积：ac、bd和(a+b)(c+d)。

**实现文件**：
- [KaratsubaMultiply.java](KaratsubaMultiply.java)
- [karatsuba_multiply.py](karatsuba_multiply.py)
- [karatsuba_multiply.cpp](karatsuba_multiply.cpp)

**相关题目**：
- [LeetCode 43. 字符串相乘](https://leetcode-cn.com/problems/multiply-strings/) - 高精度乘法
- [LeetCode 66. 加一](https://leetcode-cn.com/problems/plus-one/) - 高精度加法
- [LeetCode 67. 二进制求和](https://leetcode-cn.com/problems/add-binary/) - 二进制高精度加法
- [LintCode 2. 尾部的零](https://www.lintcode.com/problem/2/) - 高精度运算相关
- [CodeChef - MAXPR](https://www.codechef.com/problems/MAXPR) - 大整数处理
- [HackerRank - Extra Long Factorials](https://www.hackerrank.com/challenges/extra-long-factorials/problem) - 超大阶乘计算
- [洛谷 - P1303 A*B Problem](https://www.luogu.com.cn/problem/P1303) - 高精度乘法
- [牛客网 - NC118 数组中的逆序对](https://www.nowcoder.com/practice/96bd6684e04a44eb80e6a68efc0ec6c5?tpId=188) - 高精度相关

### 2. Toom-Cook 乘法算法

**算法思想**：Toom-Cook是Karatsuba算法的推广，通过将n位数分解为m个部分，将时间复杂度进一步优化到约O(n^(log_m(2m-1)))。当m=2时，就是Karatsuba算法；当m=3时，复杂度约为O(n^1.465)。

**核心步骤**：
1. 拆分：将两个大数分成m个部分
2. 求值：在m+1个点上计算多项式值
3. 点乘：对应点相乘
4. 插值：通过结果点插值得到乘积多项式
5. 组合：将多项式系数组合成最终结果

**实现文件**：
- [ToomCookMultiply.java](ToomCookMultiply.java)
- [toom_cook_multiply.py](toom_cook_multiply.py)
- [toom_cook_multiply.cpp](toom_cook_multiply.cpp)

**相关题目**：
- [LeetCode 415. 字符串相加](https://leetcode-cn.com/problems/add-strings/) - 高精度加法
- [LeetCode 989. 数组形式的整数加法](https://leetcode-cn.com/problems/add-to-array-form-of-integer/) - 高精度加法变体
- [HackerRank - Very Big Sum](https://www.hackerrank.com/challenges/a-very-big-sum/problem) - 大整数求和
- [SPOJ - MULTQ3](https://www.spoj.com/problems/MULTQ3/) - 大整数处理
- [AtCoder - ABC196 C - Doubled](https://atcoder.jp/contests/abc196/tasks/abc196_c) - 数字处理
- [杭电OJ - 1042 N!](http://acm.hdu.edu.cn/showproblem.php?pid=1042) - 超大阶乘

### 3. FFT（快速傅里叶变换）乘法

**算法思想**：利用傅里叶变换将时域的卷积转换为频域的点乘，从而将多项式乘法的时间复杂度从O(n²)降低到O(n log n)。高精度整数乘法可以看作是系数相乘，因此可以通过FFT高效计算。

**核心步骤**：
1. 将两个大整数视为多项式系数
2. 对两个多项式进行FFT变换到频域
3. 在频域进行点乘操作
4. 通过逆FFT变换回时域，得到乘积结果

**实现文件**：
- [FFTMultiply.java](FFTMultiply.java)
- [fft_multiply.py](fft_multiply.py)
- [fft_multiply.cpp](fft_multiply.cpp)

**相关题目**：
- [LeetCode 365. 水壶问题](https://leetcode-cn.com/problems/water-and-jug-problem/) - 数学计算
- [LeetCode 204. 计数质数](https://leetcode-cn.com/problems/count-primes/) - 素数计算
- [CodeChef - TASTR](https://www.codechef.com/problems/TASTR) - 字符串处理与FFT
- [HackerEarth - Fast Fourier Transform](https://www.hackerearth.com/practice/notes/fast-fourier-transform/) - FFT应用
- [洛谷 - P4721 【模板】分治 FFT](https://www.luogu.com.cn/problem/P4721) - FFT模板题
- [牛客网 - NC147 买卖股票的最佳时机](https://www.nowcoder.com/practice/64b4262d4e6d4f6181cd45446a5821ec?tpId=188) - 动态规划

### 4. 高精度小数与格式化

**算法思想**：高精度小数需要处理小数点位置和精度控制，格式化则需要处理科学计数法、千分位分隔等显示方式。

**实现内容**：
- 高精度小数的表示与存储
- 小数的四则运算
- 精度控制与四舍五入
- 科学计数法与普通表示法转换
- 千分位分隔与自定义格式

**实现文件**：
- [BigDecimalUtil.java](BigDecimalUtil.java)
- [big_decimal_util.py](big_decimal_util.py)
- [big_decimal_util.cpp](big_decimal_util.cpp)

**相关题目**：
- [LeetCode 166. 分数到小数](https://leetcode-cn.com/problems/fraction-to-recurring-decimal/) - 小数格式化
- [LeetCode 263. 丑数](https://leetcode-cn.com/problems/ugly-number/) - 小数相关
- [LintCode 1333. 浮点数加法](https://www.lintcode.com/problem/1333/) - 高精度浮点数
- [HackerRank - Java BigDecimal](https://www.hackerrank.com/challenges/java-bigdecimal/problem) - 高精度小数处理
- [CodeChef - FLOW001](https://www.codechef.com/problems/FLOW001) - 高精度加法
- [洛谷 - P1518 [USACO2.4] 两只塔姆沃斯牛 The Tamworth Two](https://www.luogu.com.cn/problem/P1518) - 模拟

## 位运算技巧

### 1. 子集枚举技巧

**算法思想**：使用位掩码和特定的循环方式高效枚举一个集合的所有子集。

**核心代码模式**：
```java
// 枚举mask的所有非空子集
for (int sub = mask; sub > 0; sub = (sub - 1) & mask) {
    // 处理子集sub
}
```

**复杂度分析**：枚举n个元素集合的所有子集需要O(2^n)时间，但在实际应用中，我们通常只枚举特定mask的子集。

**实现文件**：
- [SubsetEnumeration.java](SubsetEnumeration.java)
- [subset_enumeration.py](subset_enumeration.py)
- [subset_enumeration.cpp](subset_enumeration.cpp)

**相关题目**：
- [LeetCode 78. 子集](https://leetcode-cn.com/problems/subsets/) - 子集枚举
- [LeetCode 90. 子集 II](https://leetcode-cn.com/problems/subsets-ii/) - 带重复元素的子集枚举
- [LeetCode 491. 递增子序列](https://leetcode-cn.com/problems/increasing-subsequences/) - 子序列枚举
- [LintCode 17. 子集](https://www.lintcode.com/problem/17/) - 子集枚举
- [CodeChef - CHEFING](https://www.codechef.com/problems/CHEFING) - 子集应用
- [HackerRank - Subset Sum](https://www.hackerrank.com/challenges/subset-sum/problem) - 子集和问题
- [洛谷 - P1451 求细胞数量](https://www.luogu.com.cn/problem/P1451) - 连通性问题
- [牛客网 - NC148 买卖股票的最佳时机(二)](https://www.nowcoder.com/practice/9e5e3c2603064829b0a0bbfca10594e9?tpId=188) - 贪心算法

### 2. Popcount 卡常技巧

**算法思想**：Popcount（或称为汉明重量）是计算一个数的二进制表示中1的个数的函数。高效的popcount实现可以显著提升算法性能。

**实现方式**：
- 内置函数：Java的Integer.bitCount()，GCC的__builtin_popcount()
- 查表法：预处理小整数的popcount值
- 位操作优化：使用分治方法计算

**代码示例**：
```java
// Java内置方法
int count = Integer.bitCount(x);

// 位操作优化实现
int popcount(int x) {
    x = x - ((x >>> 1) & 0x55555555);
    x = (x & 0x33333333) + ((x >>> 2) & 0x33333333);
    x = (x + (x >>> 4)) & 0x0f0f0f0f;
    x = x + (x >>> 8);
    x = x + (x >>> 16);
    return x & 0x3f;
}
```

**实现文件**：
- [PopcountUtil.java](PopcountUtil.java)
- [popcount_util.py](popcount_util.py)
- [popcount_util.cpp](popcount_util.cpp)

**相关题目**：
- [LeetCode 191. 位1的个数](https://leetcode-cn.com/problems/number-of-1-bits/) - popcount直接应用
- [LeetCode 338. 比特位计数](https://leetcode-cn.com/problems/counting-bits/) - 动态规划计算popcount
- [LeetCode 461. 汉明距离](https://leetcode-cn.com/problems/hamming-distance/) - 两个数的popcount差
- [LintCode 1344. 转换字符串到整数](https://www.lintcode.com/problem/1344/) - 位运算应用
- [CodeChef - CNTPRIME](https://www.codechef.com/problems/CNTPRIME) - 素数计数
- [HackerRank - Lonely Integer](https://www.hackerrank.com/challenges/lonely-integer/problem) - 位运算
- [洛谷 - P1904 天际线](https://www.luogu.com.cn/problem/P1904) - 扫描线算法
- [牛客网 - NC149 最长公共前缀](https://www.nowcoder.com/practice/28eb3175488f4434a4a6207f6f484f47?tpId=188) - 字符串处理

### 3. 掩码预处理技巧

**算法思想**：通过预处理常用的掩码和位运算结果，避免重复计算，提升算法性能。

**预处理内容**：
- 生成常用掩码（如全1掩码、交替掩码等）
- 预处理每个数的lowbit（最低位1）
- 预处理每个数的最高位1的位置
- 预处理每个数的二进制表示中1的位置

**代码示例**：
```java
// 预处理lowbit数组
int[] lowbit = new int[MAX_N];
for (int i = 1; i < MAX_N; i++) {
    lowbit[i] = i & (-i);
}

// 预处理最高位1的位置
int[] highestBit = new int[MAX_N];
for (int i = 1; i < MAX_N; i++) {
    highestBit[i] = highestBit[i >> 1] + 1;
}
```

**实现文件**：
- [MaskPreprocess.java](MaskPreprocess.java)
- [mask_preprocess.py](mask_preprocess.py)
- [mask_preprocess.cpp](mask_preprocess.cpp)

**相关题目**：
- [LeetCode 201. 数字范围按位与](https://leetcode-cn.com/problems/bitwise-and-of-numbers-range/) - 位掩码应用
- [LeetCode 342. 4的幂](https://leetcode-cn.com/problems/power-of-four/) - 掩码判断
- [LeetCode 476. 数字的补数](https://leetcode-cn.com/problems/number-complement/) - 补码计算
- [LintCode 425. 电话号码的字母组合](https://www.lintcode.com/problem/425/) - 组合问题
- [CodeChef - CHEFBM](https://www.codechef.com/problems/CHEFBM) - 位运算应用
- [HackerRank - XOR Strings 3](https://www.hackerrank.com/challenges/xor-strings-3/problem) - 位运算
- [洛谷 - P2023 [AHOI2009] 维护序列](https://www.luogu.com.cn/problem/P2023) - 线段树+位运算
- [牛客网 - NC150 正则表达式匹配](https://www.nowcoder.com/practice/c0839e5e3e1a4b7ba251417554e07c00?tpId=188) - 动态规划

## 补充题目与训练资源

### 随机化算法补充题目

1. **随机化快速排序**
   - [LeetCode 912. 排序数组](https://leetcode-cn.com/problems/sort-an-array/)
   - [HackerRank - Quicksort 1 - Partition](https://www.hackerrank.com/challenges/quicksort1/problem)

2. **随机采样**
   - [LeetCode 382. 链表随机节点](https://leetcode-cn.com/problems/linked-list-random-node/)
   - [LeetCode 398. 随机数索引](https://leetcode-cn.com/problems/random-pick-index/)

3. **蒙特卡罗方法**
   - [LeetCode 470. 用 Rand7() 实现 Rand10()](https://leetcode-cn.com/problems/implement-rand10-using-rand7/)
   - [HackerEarth - Estimate Pi using Monte Carlo](https://www.hackerearth.com/practice/notes/monte-carlo-method/)

### 复杂度分析进阶补充题目

1. **并查集（带路径压缩和按秩合并）**
   - [LeetCode 547. 省份数量](https://leetcode-cn.com/problems/number-of-provinces/)
   - [洛谷 - P3367 【模板】并查集](https://www.luogu.com.cn/problem/P3367)

2. **动态数组（Vector）的摊还分析**
   - [LeetCode 155. 最小栈](https://leetcode-cn.com/problems/min-stack/)
   - [HackerRank - Dynamic Arrays](https://www.hackerrank.com/challenges/dynamic-array/problem)

3. **伸展树（Splay Tree）**
   - [SPOJ - Splay Tree Operations](https://www.spoj.com/problems/SPLAY/)
   - [CodeChef - SPLAYTREE](https://www.codechef.com/problems/SPLAYTREE)

## 代码编译与运行说明

### Java 代码
```bash
javac 文件名.java
java 文件名
```

### Python 代码
```bash
python 文件名.py
```

### C++ 代码
```bash
g++ 文件名.cpp -o 输出文件名
./输出文件名
```

所有代码都已通过基本测试，可以直接编译运行。每个文件都包含详细的注释说明算法原理、复杂度分析以及测试用例。

===============================================

文件: README_2.md
===============================================
# Huffman编码实现

本目录包含了Huffman编码算法的实现，这是一种经典的无损数据压缩算法。

## 目录结构

```
huffman/
├── HuffmanCoding.java          # Huffman编码 Java实现
├── huffman_coding.py           # Huffman编码 Python实现
├── huffman_coding.cpp          # Huffman编码 C++实现
└── README.md                   # 本文件
```

## 算法介绍

Huffman编码是一种无损数据压缩算法，由David Huffman在1952年提出。它根据字符出现频率构建最优二叉树，使得出现频率高的字符具有较短的编码，出现频率低的字符具有较长的编码。

### 算法原理

1. **统计字符频率**：遍历输入数据，统计每个字符的出现频率
2. **构建Huffman树**：每次选择频率最小的两个节点合并，直到只剩一个根节点
3. **生成编码表**：从根节点到叶节点的路径即为字符的编码（左0右1）
4. **编码和解码过程**：使用编码表进行编码，使用Huffman树进行解码

### 时间复杂度

- **构建Huffman树**：O(n log n)，其中n是不同字符的数量
  - 统计字符频率：O(m)，其中m是输入字符串长度
  - 构建优先队列：O(n)
  - 构建Huffman树：O(n log n)，每次操作需要O(log n)时间，共n次操作
- **编码**：O(m)，其中m是字符串长度
- **解码**：O(k)，其中k是编码后字符串长度

### 空间复杂度

- O(n)，其中n是不同字符的数量
  - Huffman树存储：O(n)
  - 编码表存储：O(n)
  - 优先队列：O(n)

### 最优性证明

Huffman编码是最优前缀码，能够达到信息熵的理论压缩极限。

1. **贪心选择性质**：每次选择频率最小的两个节点合并，符合贪心算法的最优子结构性质
2. **最优子结构**：Huffman树的任何子树都是对应字符集的最优编码树
3. **信息论基础**：根据信息论，Huffman编码的平均码长接近信息熵，是最优的无失真编码

## 核心概念

### Huffman树

Huffman树是一棵带权路径长度最短的二叉树，也称为最优二叉树。树中每个叶节点代表一个字符，节点的权重是字符的频率。

### 编码表

编码表存储了每个字符对应的二进制编码。编码的长度与字符频率成反比，频率高的字符编码短，频率低的字符编码长。

### 前缀码

Huffman编码是一种前缀码，即任何一个字符的编码都不是另一个字符编码的前缀。这保证了解码的唯一性。

## 优势

1. **压缩率高**：能够达到信息熵的理论极限
2. **实现相对简单**：算法思路清晰，易于实现
3. **适合处理具有明显统计特性的数据**：对于频率分布不均匀的数据压缩效果好

## 劣势

1. **需要两次扫描数据**：一次统计频率，一次编码
2. **对于频率分布均匀的数据压缩效果不佳**：当所有字符频率相近时，压缩率较低
3. **编码和解码需要相同的Huffman树**：需要存储或传输Huffman树信息

## 应用场景

### 1. 文件压缩

Huffman编码是许多压缩工具（如ZIP、GZIP）的核心算法之一。

### 2. 图像压缩

在JPEG图像压缩中，Huffman编码用于对DCT系数进行编码。

### 3. 音频压缩

在某些音频压缩格式中，Huffman编码用于减少数据冗余。

### 4. 网络传输

在网络传输中，Huffman编码可以减少数据传输量。

### 5. 数据库系统

在数据库系统中，Huffman编码用于压缩索引和数据页，提高存储效率。

### 6. 游戏开发

在游戏开发中，Huffman编码用于压缩游戏资源，减少游戏包大小。

### 7. 移动应用

在移动应用中，Huffman编码用于减少应用包大小和网络流量消耗。

## 相关题目和训练

### 在线编程平台题目

1. **HackerRank - Tree: Huffman Decoding**
   - 题目描述：给定 Huffman 树的根节点和二进制编码字符串，要求解码并输出原始字符串
   - 难度：中等
   - 链接：https://www.hackerrank.com/challenges/tree-huffman-decoding/problem

2. **杭电 OJ 1053 - Entropy**
   - 题目描述：计算字符串的 8-bit ASCII 编码长度和最优前缀编码长度，输出压缩比
   - 难度：中等
   - 链接：https://acm.hdu.edu.cn/showproblem.php?pid=1053

3. **洛谷 P1090 - 合并果子**
   - 题目描述：合并果子堆，每次合并消耗的体力等于两堆果子重量之和，求最小体力消耗
   - 难度：中等
   - 链接：https://www.luogu.com.cn/problem/P1090

4. **SPOJ VHUFFM - Variable Radix Huffman Encoding**
   - 题目描述：变进制 Huffman 编码，支持 R 进制目标字母表（R>2）
   - 难度：困难
   - 链接：https://www.spoj.com/problems/VHUFFM/

5. **CSES 1161 - Stick Divisions**
   - 题目描述：将一根长度为 x 的木棍分割成 n 根指定长度的小木棍，每次分割的代价等于分割的木棍长度，求最小总代价
   - 难度：中等
   - 链接：https://cses.fi/problemset/task/1161

6. **Codeforces 700D - Huffman Coding on Segment**
   - 题目描述：在数组的连续子段上进行 Huffman 编码
   - 难度：困难（3100分）
   - 链接：https://codeforces.com/problemset/problem/700/D

7. **LeetCode 443 - String Compression**
   - 题目描述：字符串压缩，使用运行长度编码压缩字符数组
   - 难度：中等
   - 链接：https://leetcode.com/problems/string-compression/

8. **LeetCode 1531 - String Compression II**
   - 题目描述：通过最多删除 k 个字符来最小化运行长度编码的长度
   - 难度：困难
   - 链接：https://leetcode.com/problems/string-compression-ii/

9. **GeeksforGeeks - Huffman Encoding**
   - 题目描述：给定字符和频率数组，生成 Huffman 编码
   - 难度：中等
   - 链接：https://www.geeksforgeeks.org/problems/huffman-encoding3345/1

### 面试和实际应用题目

1. **系统设计 - Huffman 编码实现**
   - 题目描述：实现完整的 Huffman 编码和解码系统，包括树的构建、编码表生成、编码和解码过程
   - 应用场景：文件压缩、网络传输优化

2. **自适应 Huffman 编码**
   - 题目描述：实现能够动态调整的 Huffman 编码，适应数据流的变化
   - 应用场景：实时数据压缩

3. **Huffman 编码优化**
   - 题目描述：优化 Huffman 编码的空间和时间复杂度，处理大规模数据
   - 应用场景：大数据处理、高性能计算

### 题目类型分类

1. **基础实现题**
   - 要求实现 Huffman 树构建和编码/解码过程
   - 考察点：数据结构理解、算法实现能力

2. **优化题**
   - 要求优化算法性能或处理特殊情况
   - 考察点：算法优化、边界条件处理

3. **应用题**
   - 将 Huffman 编码应用到具体场景中
   - 考察点：实际应用能力、系统设计思维

## 工程化考量

### 异常处理

1. **输入验证**：检查输入数据的有效性
2. **边界条件**：处理空输入、单字符输入等特殊情况
3. **内存管理**：防止内存泄漏和溢出
4. **错误恢复**：处理编码/解码过程中的错误

### 性能优化

### 算法层面优化

1. **频率统计优化**：使用哈希表提高统计效率
2. **优先队列优化**：使用二叉堆提高树构建效率
3. **编码表缓存**：缓存常用字符的编码
4. **内存池技术**：预分配节点内存，减少频繁内存分配
5. **编码缓存**：对已编码的字符串进行缓存，避免重复编码

### 实现层面优化

1. **位操作优化**：使用位操作代替字符串操作提高编码/解码效率
2. **批量处理**：对大量数据进行批量编码/解码，减少函数调用开销
3. **并行处理**：在多核环境下，可以将数据分块并行处理
4. **SIMD指令**：使用SIMD指令加速编码/解码过程
5. **缓存友好性**：优化数据结构布局，提高缓存命中率

### 可配置性

1. **字符集支持**：支持不同的字符集（ASCII、UTF-8、Unicode等）
2. **编码方式**：支持不同的编码方式（二进制、变进制等）
3. **输出格式**：支持不同的输出格式（二进制、十六进制等）
4. **压缩级别**：支持不同的压缩级别平衡压缩率和速度

### 线程安全性

1. **并发访问控制**：使用锁机制保护共享资源
2. **无状态设计**：尽量设计无状态的编码器，便于并发使用
3. **线程局部存储**：使用线程局部存储避免线程间竞争

### 可测试性

1. **单元测试**：为每个功能模块编写单元测试
2. **集成测试**：测试整个编码解码流程的正确性
3. **性能测试**：测试不同数据规模下的性能表现
4. **边界测试**：测试各种边界条件和异常情况
5. **压力测试**：测试在极端条件下的稳定性和性能
6. **兼容性测试**：测试不同平台和环境下的兼容性

## 数学原理

### 信息论基础

Huffman编码基于信息论中的熵概念，能够达到信息熵的理论压缩极限。

### 贪心算法

Huffman编码使用贪心策略，每次选择频率最小的两个节点进行合并。

### 与机器学习的联系

1. **决策树**：Huffman树与决策树在结构上有相似性，都是基于特征（频率）进行分裂
2. **特征选择**：在机器学习中，特征的重要性类似于字符频率，可以使用类似思路进行特征编码
3. **概率模型**：Huffman编码基于概率分布，与机器学习中的概率模型有共同理论基础
4. **信息熵**：Huffman编码与信息熵理论密切相关，在特征工程中可以用于计算信息增益
5. **自适应编码**：在强化学习中，可以根据环境变化动态调整编码策略

### 与大数据的联系

1. **分布式处理**：在大数据场景下，可以将数据分片后分别进行Huffman编码
2. **流式处理**：结合在线Huffman编码技术处理数据流
3. **存储优化**：在分布式存储系统中使用Huffman编码减少存储空间
4. **实时压缩**：在实时数据处理中，使用Huffman编码减少网络传输开销
5. **增量编码**：对增量数据进行Huffman编码，提高处理效率

## 语言特性差异

### Java

- 使用面向对象设计
- 自动内存管理
- 丰富的集合类支持（PriorityQueue、HashMap等）

### Python

- 动态类型系统
- 简洁的语法表达
- 内置heapq模块支持优先队列

### C++

- 手动内存管理
- 高性能实现
- STL库支持（priority_queue、map等）

## 面试重点

### 理论知识

1. Huffman编码的算法原理和实现步骤
2. 时间和空间复杂度分析
3. 前缀码的概念和重要性

### 实践技能

1. 代码实现能力
2. 边界条件处理
3. 性能优化技巧

### 工程思维

1. 异常处理和错误恢复
2. 代码可维护性
3. 系统设计能力

## 思路技巧与题型分析

### 适用场景识别

1. **数据压缩问题**
   - 当需要减少数据存储空间或传输带宽时
   - 特别是当数据中某些元素出现频率远高于其他元素时

2. **前缀编码问题**
   - 当需要确保任何编码都不是另一个编码的前缀时
   - 保证解码的唯一性和正确性

3. **最优二叉树构建问题**
   - 当需要构建带权路径长度最短的二叉树时
   - 权值通常代表频率或代价

### 解题思路

1. **频率统计**
   - 遍历输入数据，统计每个元素的出现频率
   - 使用哈希表或数组进行高效统计

2. **优先队列应用**
   - 使用最小堆维护节点频率，每次取出频率最小的两个节点
   - 合并节点后将新节点重新放入堆中

3. **树的构建与遍历**
   - 从叶节点到根节点构建编码（自底向上）
   - 或从根节点到叶节点生成编码表（自顶向下）

### 常见变种

1. **变进制 Huffman 编码**
   - 不再局限于二进制编码，可以是 R 进制
   - 每次合并 R 个节点而非 2 个

2. **在线 Huffman 编码**
   - 数据流式输入，需要动态调整编码
   - 适用于实时数据压缩场景

3. **长度限制 Huffman 编码**
   - 限制编码的最大长度
   - 在实际应用中常用于简化解码过程

## 学习建议

1. **理解原理**：深入理解Huffman编码的数学原理和算法思想
2. **动手实践**：亲自实现算法并测试不同数据
3. **性能分析**：分析算法在不同场景下的性能表现
4. **工程应用**：了解算法在实际项目中的应用
5. **扩展学习**：学习更多数据压缩算法，如算术编码、LZW编码等

===============================================

文件: README_3.md
===============================================
# Huffman编码

## 算法简介

Huffman编码是一种无损数据压缩算法，它根据字符出现的频率为每个字符分配不同长度的编码，频率高的字符分配较短的编码，频率低的字符分配较长的编码，从而实现数据压缩。

## 算法原理

1. 统计输入数据中每个字符的频率
2. 构建Huffman树（最优二叉树）
3. 根据Huffman树生成每个字符的编码
4. 使用生成的编码对原始数据进行编码
5. 解码时根据Huffman树和编码还原原始数据

## 时间复杂度

- 构建Huffman树：O(n log n)，其中n是不同字符的数量
- 编码：O(m)，其中m是输入数据的长度
- 解码：O(m)，其中m是编码后数据的长度

## 空间复杂度

- O(n)，其中n是不同字符的数量

## 文件说明

- `HuffmanEncoding.java` - Java实现
- `huffman_encoding.py` - Python实现
- `huffman_encoding.cpp` - C++实现

## 应用场景

1. 文件压缩（如ZIP格式）
2. 图像压缩（JPEG中的部分应用）
3. 网络传输数据压缩

===============================================

文件: README_4.md
===============================================
# LZW编码 (Lempel-Ziv-Welch)

## 算法简介

LZW是一种无损数据压缩算法，属于字典编码的一种。

## 算法原理

1. 初始化字典，包含所有可能的单字符
2. 读取输入字符串，查找字典中最长的匹配字符串
3. 输出匹配字符串对应的编码
4. 将匹配字符串加上下一个字符组成的新字符串添加到字典中
5. 重复步骤2-4直到处理完所有输入

## 时间复杂度

- O(n)，其中n是输入字符串长度

## 空间复杂度

- O(d)，其中d是字典中条目的数量

## 文件说明

- `LZWEncoding.java` - Java实现
- `lzw_encoding.py` - Python实现
- `lzw_encoding.cpp` - C++实现

## 应用场景

1. GIF图像格式
2. TIFF图像格式
3. Unix系统的compress工具

===============================================

文件: README_5.md
===============================================
# 三分枚举算法专题

## 算法原理

三分枚举（Ternary Search）是一种用于在单峰函数（unimodal function）上寻找极值点的搜索算法。单峰函数是指在定义域内先单调递增后单调递减（或先单调递减后单调递增）的函数，即函数只有一个极值点（最大值或最小值）。

三分枚举的基本思想是：

1. 在搜索区间 [left, right] 中选择两个中间点 m1 和 m2（通常取 m1 = left + (right - left)/3 和 m2 = right - (right - left)/3）
2. 比较函数在 m1 和 m2 处的值：f(m1) 和 f(m2)
3. 根据单峰函数的性质，通过比较这两个值来缩小搜索区间：
   - 如果 f(m1) < f(m2)，则极值点在 [m1, right] 区间内
   - 如果 f(m1) > f(m2)，则极值点在 [left, m2] 区间内
4. 重复上述过程，直到区间足够小，满足精度要求

## 时间复杂度分析

- 每次迭代将搜索区间缩小为原来的 2/3
- 经过 n 次迭代后，区间长度为初始长度的 (2/3)^n
- 通常需要 log( (right-left)/ε ) 次迭代，其中 ε 是精度要求
- 时间复杂度为 O(log n)，其中 n 是搜索区间的大小

## 算法实现

### 1. 基本三分枚举实现（求单峰函数的最大值）

**题目来源**：算法基础题

**题目描述**：实现三分枚举算法，在单峰函数上寻找最大值点

**解题思路**：
- 实现三分枚举函数，给定搜索区间和精度要求
- 迭代缩小搜索区间，直到满足精度要求
- 返回极值点的近似位置

**代码实现**：

**Java代码**：
```java
public class TernarySearch {
    // 定义精度常量
    private static final double EPS = 1e-10;
    
    // 单峰函数示例：f(x) = -(x-2)^2 + 5，在x=2处取得最大值5
    private static double func(double x) {
        return -(x - 2) * (x - 2) + 5;
    }
    
    // 三分枚举寻找单峰函数的最大值点
    public static double ternarySearch(double left, double right) {
        // 当区间足够小时停止迭代
        while (right - left > EPS) {
            // 计算两个中间点
            double m1 = left + (right - left) / 3;
            double m2 = right - (right - left) / 3;
            
            // 比较两个中间点的函数值
            double f1 = func(m1);
            double f2 = func(m2);
            
            // 根据单峰函数的性质缩小搜索区间
            if (f1 < f2) {
                // 最大值在[m1, right]区间
                left = m1;
            } else {
                // 最大值在[left, m2]区间
                right = m2;
            }
        }
        
        // 返回极值点的近似位置
        return (left + right) / 2;
    }
    
    public static void main(String[] args) {
        double left = -10.0;
        double right = 10.0;
        double maxPoint = ternarySearch(left, right);
        double maxValue = func(maxPoint);
        
        System.out.println("最大值点: " + maxPoint);
        System.out.println("最大值: " + maxValue);
        System.out.println("实际最大值点: 2.0");
        System.out.println("实际最大值: 5.0");
    }
}
```

**Python代码**：
```python
import math

# 定义精度常量
EPS = 1e-10

# 单峰函数示例：f(x) = -(x-2)^2 + 5，在x=2处取得最大值5
def func(x):
    return -(x - 2) ** 2 + 5

# 三分枚举寻找单峰函数的最大值点
def ternary_search(left, right):
    # 当区间足够小时停止迭代
    while right - left > EPS:
        # 计算两个中间点
        m1 = left + (right - left) / 3
        m2 = right - (right - left) / 3
        
        # 比较两个中间点的函数值
        f1 = func(m1)
        f2 = func(m2)
        
        # 根据单峰函数的性质缩小搜索区间
        if f1 < f2:
            # 最大值在[m1, right]区间
            left = m1
        else:
            # 最大值在[left, m2]区间
            right = m2
    
    # 返回极值点的近似位置
    return (left + right) / 2

# 测试代码
if __name__ == "__main__":
    left = -10.0
    right = 10.0
    max_point = ternary_search(left, right)
    max_value = func(max_point)
    
    print(f"最大值点: {max_point}")
    print(f"最大值: {max_value}")
    print("实际最大值点: 2.0")
    print("实际最大值: 5.0")
```

**C++代码**：
```cpp
#include <iostream>
#include <cmath>
using namespace std;

// 定义精度常量
const double EPS = 1e-10;

// 单峰函数示例：f(x) = -(x-2)^2 + 5，在x=2处取得最大值5
double func(double x) {
    return -(x - 2) * (x - 2) + 5;
}

// 三分枚举寻找单峰函数的最大值点
double ternarySearch(double left, double right) {
    // 当区间足够小时停止迭代
    while (right - left > EPS) {
        // 计算两个中间点
        double m1 = left + (right - left) / 3;
        double m2 = right - (right - left) / 3;
        
        // 比较两个中间点的函数值
        double f1 = func(m1);
        double f2 = func(m2);
        
        // 根据单峰函数的性质缩小搜索区间
        if (f1 < f2) {
            // 最大值在[m1, right]区间
            left = m1;
        } else {
            // 最大值在[left, m2]区间
            right = m2;
        }
    }
    
    // 返回极值点的近似位置
    return (left + right) / 2;
}

int main() {
    double left = -10.0;
    double right = 10.0;
    double maxPoint = ternarySearch(left, right);
    double maxValue = func(maxPoint);
    
    cout.precision(15);
    cout << "最大值点: " << maxPoint << endl;
    cout << "最大值: " << maxValue << endl;
    cout << "实际最大值点: 2.0" << endl;
    cout << "实际最大值: 5.0" << endl;
    
    return 0;
}
```

### 2. 三分枚举求单谷函数的最小值

**题目来源**：算法基础题

**题目描述**：实现三分枚举算法，在单谷函数（先递减后递增）上寻找最小值点

**解题思路**：
- 对于单谷函数，三分枚举的逻辑略有不同
- 比较函数在m1和m2处的值，根据单谷函数的性质缩小搜索区间

**代码实现**：

**Java代码**：
```java
public class TernarySearchMin {
    // 定义精度常量
    private static final double EPS = 1e-10;
    
    // 单谷函数示例：f(x) = (x-3)^2 + 2，在x=3处取得最小值2
    private static double func(double x) {
        return (x - 3) * (x - 3) + 2;
    }
    
    // 三分枚举寻找单谷函数的最小值点
    public static double ternarySearchMin(double left, double right) {
        // 当区间足够小时停止迭代
        while (right - left > EPS) {
            // 计算两个中间点
            double m1 = left + (right - left) / 3;
            double m2 = right - (right - left) / 3;
            
            // 比较两个中间点的函数值
            double f1 = func(m1);
            double f2 = func(m2);
            
            // 根据单谷函数的性质缩小搜索区间
            if (f1 < f2) {
                // 最小值在[left, m2]区间
                right = m2;
            } else {
                // 最小值在[m1, right]区间
                left = m1;
            }
        }
        
        // 返回极值点的近似位置
        return (left + right) / 2;
    }
    
    public static void main(String[] args) {
        double left = -10.0;
        double right = 10.0;
        double minPoint = ternarySearchMin(left, right);
        double minValue = func(minPoint);
        
        System.out.println("最小值点: " + minPoint);
        System.out.println("最小值: " + minValue);
        System.out.println("实际最小值点: 3.0");
        System.out.println("实际最小值: 2.0");
    }
}
```

**Python代码**：
```python
import math

# 定义精度常量
EPS = 1e-10

# 单谷函数示例：f(x) = (x-3)^2 + 2，在x=3处取得最小值2
def func(x):
    return (x - 3) ** 2 + 2

# 三分枚举寻找单谷函数的最小值点
def ternary_search_min(left, right):
    # 当区间足够小时停止迭代
    while right - left > EPS:
        # 计算两个中间点
        m1 = left + (right - left) / 3
        m2 = right - (right - left) / 3
        
        # 比较两个中间点的函数值
        f1 = func(m1)
        f2 = func(m2)
        
        # 根据单谷函数的性质缩小搜索区间
        if f1 < f2:
            # 最小值在[left, m2]区间
            right = m2
        else:
            # 最小值在[m1, right]区间
            left = m1
    
    # 返回极值点的近似位置
    return (left + right) / 2

# 测试代码
if __name__ == "__main__":
    left = -10.0
    right = 10.0
    min_point = ternary_search_min(left, right)
    min_value = func(min_point)
    
    print(f"最小值点: {min_point}")
    print(f"最小值: {min_value}")
    print("实际最小值点: 3.0")
    print("实际最小值: 2.0")
```

**C++代码**：
```cpp
#include <iostream>
#include <cmath>
using namespace std;

// 定义精度常量
const double EPS = 1e-10;

// 单谷函数示例：f(x) = (x-3)^2 + 2，在x=3处取得最小值2
double func(double x) {
    return (x - 3) * (x - 3) + 2;
}

// 三分枚举寻找单谷函数的最小值点
double ternarySearchMin(double left, double right) {
    // 当区间足够小时停止迭代
    while (right - left > EPS) {
        // 计算两个中间点
        double m1 = left + (right - left) / 3;
        double m2 = right - (right - left) / 3;
        
        // 比较两个中间点的函数值
        double f1 = func(m1);
        double f2 = func(m2);
        
        // 根据单谷函数的性质缩小搜索区间
        if (f1 < f2) {
            // 最小值在[left, m2]区间
            right = m2;
        } else {
            // 最小值在[m1, right]区间
            left = m1;
        }
    }
    
    // 返回极值点的近似位置
    return (left + right) / 2;
}

int main() {
    double left = -10.0;
    double right = 10.0;
    double minPoint = ternarySearchMin(left, right);
    double minValue = func(minPoint);
    
    cout.precision(15);
    cout << "最小值点: " << minPoint << endl;
    cout << "最小值: " << minValue << endl;
    cout << "实际最小值点: 3.0" << endl;
    cout << "实际最小值: 2.0" << endl;
    
    return 0;
}
```

## 经典算法题目

### 3. LeetCode 1011. 在 D 天内送达包裹的能力

**题目链接**：https://leetcode.com/problems/capacity-to-ship-packages-within-d-days/

**题目描述**：传送带上的包裹必须在 D 天内从一个港口运送到另一个港口。传送带上的第 i 个包裹的重量为 weights[i]。每一天，我们都会按给出重量的顺序往传送带上装载包裹，我们装载的重量不会超过船的最大运载重量。返回能在 D 天内将所有包裹送达的船的最小运载能力。

**解题思路**：
- 这是一个典型的二分查找问题，但也可以用三分查找解决
- 定义函数：给定运载能力 x，计算需要多少天才能运完所有包裹
- 这个函数是单调递增的，可以用三分查找找到最小的 x 使得所需天数 <= D

**代码实现**：

**Java代码**：
```java
class Solution {
    public int shipWithinDays(int[] weights, int days) {
        // 确定二分查找的上下界
        int left = 0;  // 下界：单个包裹的最大重量
        int right = 0; // 上界：所有包裹的总重量
        for (int weight : weights) {
            left = Math.max(left, weight);
            right += weight;
        }
        
        // 二分查找
        while (left < right) {
            int mid = left + (right - left) / 2;
            int need = calculateDays(weights, mid);
            if (need <= days) {
                // 可以在days天内运完，尝试更小的运载能力
                right = mid;
            } else {
                // 需要更多天，必须增大运载能力
                left = mid + 1;
            }
        }
        
        return left;
    }
    
    // 计算给定运载能力下需要多少天运完所有包裹
    private int calculateDays(int[] weights, int capacity) {
        int days = 1;
        int currentLoad = 0;
        
        for (int weight : weights) {
            if (currentLoad + weight > capacity) {
                // 需要新的一天
                days++;
                currentLoad = weight;
            } else {
                currentLoad += weight;
            }
        }
        
        return days;
    }
}
```

**Python代码**：
```python
class Solution:
    def shipWithinDays(self, weights: List[int], days: int) -> int:
        # 确定二分查找的上下界
        left = max(weights)  # 下界：单个包裹的最大重量
        right = sum(weights)  # 上界：所有包裹的总重量
        
        # 二分查找
        while left < right:
            mid = left + (right - left) // 2
            need = self.calculate_days(weights, mid)
            if need <= days:
                # 可以在days天内运完，尝试更小的运载能力
                right = mid
            else:
                # 需要更多天，必须增大运载能力
                left = mid + 1
        
        return left
    
    def calculate_days(self, weights: List[int], capacity: int) -> int:
        """计算给定运载能力下需要多少天运完所有包裹"""
        days = 1
        current_load = 0
        
        for weight in weights:
            if current_load + weight > capacity:
                # 需要新的一天
                days += 1
                current_load = weight
            else:
                current_load += weight
        
        return days
```

**C++代码**：
```cpp
class Solution {
private:
    // 计算给定运载能力下需要多少天运完所有包裹
    int calculateDays(const vector<int>& weights, int capacity) {
        int days = 1;
        int currentLoad = 0;
        
        for (int weight : weights) {
            if (currentLoad + weight > capacity) {
                // 需要新的一天
                days++;
                currentLoad = weight;
            } else {
                currentLoad += weight;
            }
        }
        
        return days;
    }
    
public:
    int shipWithinDays(vector<int>& weights, int days) {
        // 确定二分查找的上下界
        int left = 0;  // 下界：单个包裹的最大重量
        int right = 0; // 上界：所有包裹的总重量
        for (int weight : weights) {
            left = max(left, weight);
            right += weight;
        }
        
        // 二分查找
        while (left < right) {
            int mid = left + (right - left) / 2;
            int need = calculateDays(weights, mid);
            if (need <= days) {
                // 可以在days天内运完，尝试更小的运载能力
                right = mid;
            } else {
                // 需要更多天，必须增大运载能力
                left = mid + 1;
            }
        }
        
        return left;
    }
};
```

### 4. LeetCode 410. 分割数组的最大值

**题目链接**：https://leetcode.com/problems/split-array-largest-sum/

**题目描述**：给定一个非负整数数组 nums 和一个整数 k，你需要将这个数组分成 k 个非空的连续子数组。设计一个算法使得这 k 个子数组各自和的最大值最小。

**解题思路**：
- 这是一个典型的可以用二分查找或三分查找解决的优化问题
- 定义函数：给定一个最大和的上限 x，判断是否可以将数组分成至多 k 个部分
- 这个函数具有单调性，可以用三分查找找到最小的 x

**代码实现**：

**Java代码**：
```java
class Solution {
    public int splitArray(int[] nums, int k) {
        // 确定二分查找的上下界
        int left = 0;  // 下界：数组中的最大值
        int right = 0; // 上界：数组的总和
        for (int num : nums) {
            left = Math.max(left, num);
            right += num;
        }
        
        // 二分查找
        while (left < right) {
            int mid = left + (right - left) / 2;
            if (canSplit(nums, k, mid)) {
                // 可以分成k个部分，尝试更小的最大值
                right = mid;
            } else {
                // 不能分成k个部分，需要更大的最大值
                left = mid + 1;
            }
        }
        
        return left;
    }
    
    // 判断是否可以将数组分成至多k个部分，使得每个部分的和不超过maxSum
    private boolean canSplit(int[] nums, int k, int maxSum) {
        int count = 1;
        int currentSum = 0;
        
        for (int num : nums) {
            if (currentSum + num > maxSum) {
                // 需要新的一部分
                count++;
                currentSum = num;
                if (count > k) {
                    return false;
                }
            } else {
                currentSum += num;
            }
        }
        
        return true;
    }
}
```

**Python代码**：
```python
class Solution:
    def splitArray(self, nums: List[int], k: int) -> int:
        # 确定二分查找的上下界
        left = max(nums)  # 下界：数组中的最大值
        right = sum(nums)  # 上界：数组的总和
        
        # 二分查找
        while left < right:
            mid = left + (right - left) // 2
            if self.can_split(nums, k, mid):
                # 可以分成k个部分，尝试更小的最大值
                right = mid
            else:
                # 不能分成k个部分，需要更大的最大值
                left = mid + 1
        
        return left
    
    def can_split(self, nums: List[int], k: int, max_sum: int) -> bool:
        """判断是否可以将数组分成至多k个部分，使得每个部分的和不超过max_sum"""
        count = 1
        current_sum = 0
        
        for num in nums:
            if current_sum + num > max_sum:
                # 需要新的一部分
                count += 1
                current_sum = num
                if count > k:
                    return False
            else:
                current_sum += num
        
        return True
```

**C++代码**：
```cpp
class Solution {
private:
    // 判断是否可以将数组分成至多k个部分，使得每个部分的和不超过maxSum
    bool canSplit(const vector<int>& nums, int k, int maxSum) {
        int count = 1;
        int currentSum = 0;
        
        for (int num : nums) {
            if (currentSum + num > maxSum) {
                // 需要新的一部分
                count++;
                currentSum = num;
                if (count > k) {
                    return false;
                }
            } else {
                currentSum += num;
            }
        }
        
        return true;
    }
    
public:
    int splitArray(vector<int>& nums, int k) {
        // 确定二分查找的上下界
        int left = 0;  // 下界：数组中的最大值
        int right = 0; // 上界：数组的总和
        for (int num : nums) {
            left = max(left, num);
            right += num;
        }
        
        // 二分查找
        while (left < right) {
            int mid = left + (right - left) / 2;
            if (canSplit(nums, k, mid)) {
                // 可以分成k个部分，尝试更小的最大值
                right = mid;
            } else {
                // 不能分成k个部分，需要更大的最大值
                left = mid + 1;
            }
        }
        
        return left;
    }
};
```

### 5. 寻找函数的峰值

**题目来源**：算法进阶题

**题目描述**：给定一个单峰函数，找到其峰值点（最大值点）

**解题思路**：
- 使用三分枚举算法寻找单峰函数的峰值
- 迭代缩小搜索区间，直到满足精度要求

**代码实现**：

**Java代码**：
```java
public class FindPeak {
    // 定义精度常量
    private static final double EPS = 1e-10;
    
    // 示例单峰函数
    private static double func(double x) {
        // 示例：f(x) = sin(x) + 0.5*x 在某个区间内是单峰函数
        return Math.sin(x) + 0.5 * x;
    }
    
    // 三分枚举寻找单峰函数的峰值
    public static double findPeak(double left, double right) {
        // 当区间足够小时停止迭代
        while (right - left > EPS) {
            // 计算两个中间点
            double m1 = left + (right - left) / 3;
            double m2 = right - (right - left) / 3;
            
            // 比较两个中间点的函数值
            double f1 = func(m1);
            double f2 = func(m2);
            
            // 根据单峰函数的性质缩小搜索区间
            if (f1 < f2) {
                // 峰值在[m1, right]区间
                left = m1;
            } else {
                // 峰值在[left, m2]区间
                right = m2;
            }
        }
        
        // 返回峰值点的近似位置
        return (left + right) / 2;
    }
    
    public static void main(String[] args) {
        double left = 0.0;
        double right = 10.0;
        double peak = findPeak(left, right);
        double peakValue = func(peak);
        
        System.out.println("峰值点: " + peak);
        System.out.println("峰值: " + peakValue);
    }
}
```

**Python代码**：
```python
import math

# 定义精度常量
EPS = 1e-10

# 示例单峰函数
def func(x):
    # 示例：f(x) = sin(x) + 0.5*x 在某个区间内是单峰函数
    return math.sin(x) + 0.5 * x

# 三分枚举寻找单峰函数的峰值
def find_peak(left, right):
    # 当区间足够小时停止迭代
    while right - left > EPS:
        # 计算两个中间点
        m1 = left + (right - left) / 3
        m2 = right - (right - left) / 3
        
        # 比较两个中间点的函数值
        f1 = func(m1)
        f2 = func(m2)
        
        # 根据单峰函数的性质缩小搜索区间
        if f1 < f2:
            # 峰值在[m1, right]区间
            left = m1
        else:
            # 峰值在[left, m2]区间
            right = m2
    
    # 返回峰值点的近似位置
    return (left + right) / 2

# 测试代码
if __name__ == "__main__":
    left = 0.0
    right = 10.0
    peak = find_peak(left, right)
    peak_value = func(peak)
    
    print(f"峰值点: {peak}")
    print(f"峰值: {peak_value}")
```

**C++代码**：
```cpp
#include <iostream>
#include <cmath>
using namespace std;

// 定义精度常量
const double EPS = 1e-10;

// 示例单峰函数
double func(double x) {
    // 示例：f(x) = sin(x) + 0.5*x 在某个区间内是单峰函数
    return sin(x) + 0.5 * x;
}

// 三分枚举寻找单峰函数的峰值
double findPeak(double left, double right) {
    // 当区间足够小时停止迭代
    while (right - left > EPS) {
        // 计算两个中间点
        double m1 = left + (right - left) / 3;
        double m2 = right - (right - left) / 3;
        
        // 比较两个中间点的函数值
        double f1 = func(m1);
        double f2 = func(m2);
        
        // 根据单峰函数的性质缩小搜索区间
        if (f1 < f2) {
            // 峰值在[m1, right]区间
            left = m1;
        } else {
            // 峰值在[left, m2]区间
            right = m2;
        }
    }
    
    // 返回峰值点的近似位置
    return (left + right) / 2;
}

int main() {
    double left = 0.0;
    double right = 10.0;
    double peak = findPeak(left, right);
    double peakValue = func(peak);
    
    cout.precision(15);
    cout << "峰值点: " << peak << endl;
    cout << "峰值: " << peakValue << endl;
    
    return 0;
}
```

### 6. 二维三分枚举

**题目来源**：算法进阶题

**题目描述**：在二维平面上寻找一个单峰函数的极值点

**解题思路**：
- 对于二维单峰函数，可以使用嵌套的三分枚举
- 先固定一个变量，对另一个变量进行三分枚举
- 然后再对固定的变量进行三分枚举
- 交替进行直到收敛

**代码实现**：

**Java代码**：
```java
public class TwoDTernarySearch {
    // 定义精度常量
    private static final double EPS = 1e-10;
    
    // 二维单峰函数示例：f(x,y) = -(x-1)^2 - (y-2)^2 + 5，在(1,2)处取得最大值5
    private static double func(double x, double y) {
        return -(x - 1) * (x - 1) - (y - 2) * (y - 2) + 5;
    }
    
    // 固定x，对y进行三分枚举
    private static double ternarySearchY(double x, double yLeft, double yRight) {
        while (yRight - yLeft > EPS) {
            double m1 = yLeft + (yRight - yLeft) / 3;
            double m2 = yRight - (yRight - yLeft) / 3;
            double f1 = func(x, m1);
            double f2 = func(x, m2);
            
            if (f1 < f2) {
                yLeft = m1;
            } else {
                yRight = m2;
            }
        }
        return (yLeft + yRight) / 2;
    }
    
    // 二维三分枚举寻找最大值
    public static double[] twoDTernarySearch(double xLeft, double xRight, double yLeft, double yRight) {
        while (xRight - xLeft > EPS) {
            double m1 = xLeft + (xRight - xLeft) / 3;
            double m2 = xRight - (xRight - xLeft) / 3;
            
            // 对每个x值，找到最优的y值
            double bestY1 = ternarySearchY(m1, yLeft, yRight);
            double bestY2 = ternarySearchY(m2, yLeft, yRight);
            
            // 比较两个点的函数值
            double f1 = func(m1, bestY1);
            double f2 = func(m2, bestY2);
            
            if (f1 < f2) {
                xLeft = m1;
            } else {
                xRight = m2;
            }
        }
        
        // 找到最终的x对应的最优y
        double bestX = (xLeft + xRight) / 2;
        double bestY = ternarySearchY(bestX, yLeft, yRight);
        
        return new double[] {bestX, bestY, func(bestX, bestY)};
    }
    
    public static void main(String[] args) {
        double xLeft = -10.0, xRight = 10.0;
        double yLeft = -10.0, yRight = 10.0;
        
        double[] result = twoDTernarySearch(xLeft, xRight, yLeft, yRight);
        
        System.out.println("最大值点: (" + result[0] + ", " + result[1] + ")");
        System.out.println("最大值: " + result[2]);
        System.out.println("实际最大值点: (1.0, 2.0)");
        System.out.println("实际最大值: 5.0");
    }
}
```

**Python代码**：
```python
import math

# 定义精度常量
EPS = 1e-10

# 二维单峰函数示例：f(x,y) = -(x-1)^2 - (y-2)^2 + 5，在(1,2)处取得最大值5
def func(x, y):
    return -(x - 1) ** 2 - (y - 2) ** 2 + 5

# 固定x，对y进行三分枚举
def ternary_search_y(x, y_left, y_right):
    while y_right - y_left > EPS:
        m1 = y_left + (y_right - y_left) / 3
        m2 = y_right - (y_right - y_left) / 3
        f1 = func(x, m1)
        f2 = func(x, m2)
        
        if f1 < f2:
            y_left = m1
        else:
            y_right = m2
    return (y_left + y_right) / 2

# 二维三分枚举寻找最大值
def two_d_ternary_search(x_left, x_right, y_left, y_right):
    while x_right - x_left > EPS:
        m1 = x_left + (x_right - x_left) / 3
        m2 = x_right - (x_right - x_left) / 3
        
        # 对每个x值，找到最优的y值
        best_y1 = ternary_search_y(m1, y_left, y_right)
        best_y2 = ternary_search_y(m2, y_left, y_right)
        
        # 比较两个点的函数值
        f1 = func(m1, best_y1)
        f2 = func(m2, best_y2)
        
        if f1 < f2:
            x_left = m1
        else:
            x_right = m2
    
    # 找到最终的x对应的最优y
    best_x = (x_left + x_right) / 2
    best_y = ternary_search_y(best_x, y_left, y_right)
    
    return best_x, best_y, func(best_x, best_y)

# 测试代码
if __name__ == "__main__":
    x_left, x_right = -10.0, 10.0
    y_left, y_right = -10.0, 10.0
    
    best_x, best_y, max_value = two_d_ternary_search(x_left, x_right, y_left, y_right)
    
    print(f"最大值点: ({best_x}, {best_y})")
    print(f"最大值: {max_value}")
    print("实际最大值点: (1.0, 2.0)")
    print("实际最大值: 5.0")
```

**C++代码**：
```cpp
#include <iostream>
#include <cmath>
#include <vector>
using namespace std;

// 定义精度常量
const double EPS = 1e-10;

// 二维单峰函数示例：f(x,y) = -(x-1)^2 - (y-2)^2 + 5，在(1,2)处取得最大值5
double func(double x, double y) {
    return -(x - 1) * (x - 1) - (y - 2) * (y - 2) + 5;
}

// 固定x，对y进行三分枚举
double ternarySearchY(double x, double yLeft, double yRight) {
    while (yRight - yLeft > EPS) {
        double m1 = yLeft + (yRight - yLeft) / 3;
        double m2 = yRight - (yRight - yLeft) / 3;
        double f1 = func(x, m1);
        double f2 = func(x, m2);
        
        if (f1 < f2) {
            yLeft = m1;
        } else {
            yRight = m2;
        }
    }
    return (yLeft + yRight) / 2;
}

// 二维三分枚举寻找最大值
vector<double> twoDTernarySearch(double xLeft, double xRight, double yLeft, double yRight) {
    while (xRight - xLeft > EPS) {
        double m1 = xLeft + (xRight - xLeft) / 3;
        double m2 = xRight - (xRight - xLeft) / 3;
        
        // 对每个x值，找到最优的y值
        double bestY1 = ternarySearchY(m1, yLeft, yRight);
        double bestY2 = ternarySearchY(m2, yLeft, yRight);
        
        // 比较两个点的函数值
        double f1 = func(m1, bestY1);
        double f2 = func(m2, bestY2);
        
        if (f1 < f2) {
            xLeft = m1;
        } else {
            xRight = m2;
        }
    }
    
    // 找到最终的x对应的最优y
    double bestX = (xLeft + xRight) / 2;
    double bestY = ternarySearchY(bestX, yLeft, yRight);
    
    return {bestX, bestY, func(bestX, bestY)};
}

int main() {
    double xLeft = -10.0, xRight = 10.0;
    double yLeft = -10.0, yRight = 10.0;
    
    vector<double> result = twoDTernarySearch(xLeft, xRight, yLeft, yRight);
    
    cout.precision(15);
    cout << "最大值点: (" << result[0] << ", " << result[1] << ")" << endl;
    cout << "最大值: " << result[2] << endl;
    cout << "实际最大值点: (1.0, 2.0)" << endl;
    cout << "实际最大值: 5.0" << endl;
    
    return 0;
}
```

## 三分枚举与二分查找的比较

| 特性 | 三分枚举 | 二分查找 |
|------|---------|----------|
| 适用函数类型 | 单峰/单谷函数 | 单调函数 |
| 搜索目的 | 寻找极值点 | 寻找特定值或阈值 |
| 时间复杂度 | O(log n) | O(log n) |
| 每次迭代操作 | 比较两个中间点的函数值 | 比较中间点的函数值与目标值 |
| 区间缩小方式 | 每次缩小为原来的2/3 | 每次缩小为原来的1/2 |

## 三分枚举的注意事项

1. **函数必须是单峰/单谷的**：三分枚举只能应用于单峰或单谷函数，如果函数有多个极值点，结果可能不准确
2. **精度设置**：需要根据问题的要求设置合适的精度阈值
3. **初始搜索区间**：需要确定合适的初始搜索区间，确保极值点在区间内
4. **浮点误差**：由于使用浮点数，需要注意精度问题
5. **收敛速度**：三分枚举的收敛速度略慢于二分查找，但对于非单调函数的极值查找，是一种有效的方法

## 总结

三分枚举是一种用于在单峰或单谷函数上寻找极值的有效算法。它通过不断缩小搜索区间，逐步逼近极值点。虽然在某些情况下可以用二分查找替代，但三分枚举在处理非单调函数的极值问题时具有独特的优势。

在实际应用中，我们需要注意函数的单峰/单谷性质、精度设置、初始搜索区间等因素，以确保算法的正确性和效率。","}}}

===============================================

文件: README_6.md
===============================================
# 二叉搜索树查找算法专题

## 算法原理

二叉搜索树（Binary Search Tree，简称BST）是一种特殊的二叉树，它满足以下性质：
- 左子树上所有节点的值均小于根节点的值
- 右子树上所有节点的值均大于根节点的值
- 左右子树也分别为二叉搜索树

这种特性使得二叉搜索树可以高效地进行查找操作，平均时间复杂度为O(log n)。

## 基本操作

### 1. 基本二叉搜索树实现

**题目来源**：数据结构基础题

**题目描述**：实现二叉搜索树的基本结构和查找功能

**解题思路**：
- 定义二叉搜索树节点结构
- 实现查找、插入等基本操作
- 处理边界情况

**代码实现**：

**Java代码**：
```java
public class BinarySearchTree {
    // 定义树节点
    static class TreeNode {
        int val;
        TreeNode left;
        TreeNode right;
        
        TreeNode(int val) {
            this.val = val;
        }
    }
    
    private TreeNode root;
    
    // 插入节点
    public void insert(int val) {
        root = insertRec(root, val);
    }
    
    private TreeNode insertRec(TreeNode root, int val) {
        if (root == null) {
            return new TreeNode(val);
        }
        
        if (val < root.val) {
            root.left = insertRec(root.left, val);
        } else if (val > root.val) {
            root.right = insertRec(root.right, val);
        }
        
        return root;
    }
    
    // 查找节点
    public boolean search(int val) {
        return searchRec(root, val);
    }
    
    private boolean searchRec(TreeNode root, int val) {
        if (root == null) {
            return false;
        }
        
        if (val == root.val) {
            return true;
        }
        
        if (val < root.val) {
            return searchRec(root.left, val);
        } else {
            return searchRec(root.right, val);
        }
    }
    
    // 中序遍历（验证BST的正确性）
    public void inorderTraversal() {
        inorderRec(root);
        System.out.println();
    }
    
    private void inorderRec(TreeNode root) {
        if (root != null) {
            inorderRec(root.left);
            System.out.print(root.val + " ");
            inorderRec(root.right);
        }
    }
    
    public static void main(String[] args) {
        BinarySearchTree bst = new BinarySearchTree();
        int[] values = {50, 30, 70, 20, 40, 60, 80};
        
        for (int val : values) {
            bst.insert(val);
        }
        
        System.out.print("中序遍历结果: ");
        bst.inorderTraversal();
        
        System.out.println("查找值 40: " + bst.search(40));
        System.out.println("查找值 45: " + bst.search(45));
    }
}
```

**Python代码**：
```python
class TreeNode:
    def __init__(self, val=0):
        self.val = val
        self.left = None
        self.right = None

class BinarySearchTree:
    def __init__(self):
        self.root = None
    
    def insert(self, val):
        """插入节点到BST"""
        self.root = self._insert_recursive(self.root, val)
    
    def _insert_recursive(self, root, val):
        if root is None:
            return TreeNode(val)
        
        if val < root.val:
            root.left = self._insert_recursive(root.left, val)
        elif val > root.val:
            root.right = self._insert_recursive(root.right, val)
        
        return root
    
    def search(self, val):
        """在BST中查找值"""
        return self._search_recursive(self.root, val)
    
    def _search_recursive(self, root, val):
        if root is None:
            return False
        
        if val == root.val:
            return True
        
        if val < root.val:
            return self._search_recursive(root.left, val)
        else:
            return self._search_recursive(root.right, val)
    
    def inorder_traversal(self):
        """中序遍历BST"""
        result = []
        self._inorder_recursive(self.root, result)
        return result
    
    def _inorder_recursive(self, root, result):
        if root:
            self._inorder_recursive(root.left, result)
            result.append(root.val)
            self._inorder_recursive(root.right, result)

# 测试代码
if __name__ == "__main__":
    bst = BinarySearchTree()
    values = [50, 30, 70, 20, 40, 60, 80]
    
    for val in values:
        bst.insert(val)
    
    print("中序遍历结果:", bst.inorder_traversal())
    print("查找值 40:", bst.search(40))
    print("查找值 45:", bst.search(45))
```

**C++代码**：
```cpp
#include <iostream>
#include <vector>
using namespace std;

struct TreeNode {
    int val;
    TreeNode* left;
    TreeNode* right;
    
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
};

class BinarySearchTree {
private:
    TreeNode* root;
    
    TreeNode* insertRec(TreeNode* root, int val) {
        if (root == nullptr) {
            return new TreeNode(val);
        }
        
        if (val < root->val) {
            root->left = insertRec(root->left, val);
        } else if (val > root->val) {
            root->right = insertRec(root->right, val);
        }
        
        return root;
    }
    
    bool searchRec(TreeNode* root, int val) {
        if (root == nullptr) {
            return false;
        }
        
        if (val == root->val) {
            return true;
        }
        
        if (val < root->val) {
            return searchRec(root->left, val);
        } else {
            return searchRec(root->right, val);
        }
    }
    
    void inorderRec(TreeNode* root, vector<int>& result) {
        if (root != nullptr) {
            inorderRec(root->left, result);
            result.push_back(root->val);
            inorderRec(root->right, result);
        }
    }
    
    void deleteTree(TreeNode* root) {
        if (root != nullptr) {
            deleteTree(root->left);
            deleteTree(root->right);
            delete root;
        }
    }
    
public:
    BinarySearchTree() : root(nullptr) {}
    
    ~BinarySearchTree() {
        deleteTree(root);
    }
    
    void insert(int val) {
        root = insertRec(root, val);
    }
    
    bool search(int val) {
        return searchRec(root, val);
    }
    
    vector<int> inorderTraversal() {
        vector<int> result;
        inorderRec(root, result);
        return result;
    }
};

int main() {
    BinarySearchTree bst;
    int values[] = {50, 30, 70, 20, 40, 60, 80};
    
    for (int val : values) {
        bst.insert(val);
    }
    
    vector<int> result = bst.inorderTraversal();
    cout << "中序遍历结果: ";
    for (int val : result) {
        cout << val << " ";
    }
    cout << endl;
    
    cout << "查找值 40: " << (bst.search(40) ? "true" : "false") << endl;
    cout << "查找值 45: " << (bst.search(45) ? "true" : "false") << endl;
    
    return 0;
}
```

### 2. 二叉搜索树的高级查找操作

**题目来源**：数据结构进阶题

**题目描述**：实现二叉搜索树的高级查找功能，如查找最小值、最大值、前驱节点、后继节点等

**解题思路**：
- 利用BST的性质实现各种高级查找操作
- 注意处理边界情况

**代码实现**：

**Java代码**：
```java
public class BSTAdvancedOperations {
    static class TreeNode {
        int val;
        TreeNode left;
        TreeNode right;
        
        TreeNode(int val) {
            this.val = val;
        }
    }
    
    // 查找最小值
    public static TreeNode findMin(TreeNode root) {
        if (root == null) {
            return null;
        }
        TreeNode current = root;
        while (current.left != null) {
            current = current.left;
        }
        return current;
    }
    
    // 查找最大值
    public static TreeNode findMax(TreeNode root) {
        if (root == null) {
            return null;
        }
        TreeNode current = root;
        while (current.right != null) {
            current = current.right;
        }
        return current;
    }
    
    // 查找给定值的节点
    public static TreeNode findNode(TreeNode root, int val) {
        if (root == null || root.val == val) {
            return root;
        }
        
        if (val < root.val) {
            return findNode(root.left, val);
        } else {
            return findNode(root.right, val);
        }
    }
    
    // 查找后继节点（大于给定值的最小节点）
    public static TreeNode findSuccessor(TreeNode root, int val) {
        TreeNode current = root;
        TreeNode successor = null;
        
        while (current != null) {
            if (current.val > val) {
                successor = current;
                current = current.left;
            } else {
                current = current.right;
            }
        }
        
        return successor;
    }
    
    // 查找前驱节点（小于给定值的最大节点）
    public static TreeNode findPredecessor(TreeNode root, int val) {
        TreeNode current = root;
        TreeNode predecessor = null;
        
        while (current != null) {
            if (current.val < val) {
                predecessor = current;
                current = current.right;
            } else {
                current = current.left;
            }
        }
        
        return predecessor;
    }
    
    // 查找第k小的元素
    public static int findKthSmallest(TreeNode root, int k) {
        int[] result = new int[2]; // result[0]存储计数，result[1]存储结果
        inorderKth(root, k, result);
        return result[1];
    }
    
    private static void inorderKth(TreeNode root, int k, int[] result) {
        if (root == null || result[0] >= k) {
            return;
        }
        
        inorderKth(root.left, k, result);
        
        result[0]++;
        if (result[0] == k) {
            result[1] = root.val;
            return;
        }
        
        inorderKth(root.right, k, result);
    }
    
    // 测试代码
    public static void main(String[] args) {
        // 构建测试树
        TreeNode root = new TreeNode(50);
        root.left = new TreeNode(30);
        root.right = new TreeNode(70);
        root.left.left = new TreeNode(20);
        root.left.right = new TreeNode(40);
        root.right.left = new TreeNode(60);
        root.right.right = new TreeNode(80);
        
        System.out.println("最小值: " + findMin(root).val);
        System.out.println("最大值: " + findMax(root).val);
        System.out.println("查找值 40: " + (findNode(root, 40) != null ? findNode(root, 40).val : "不存在"));
        System.out.println("后继节点(40): " + findSuccessor(root, 40).val);
        System.out.println("前驱节点(40): " + findPredecessor(root, 40).val);
        System.out.println("第3小的元素: " + findKthSmallest(root, 3));
    }
}
```

**Python代码**：
```python
class TreeNode:
    def __init__(self, val=0):
        self.val = val
        self.left = None
        self.right = None

# 查找最小值
def find_min(root):
    if root is None:
        return None
    current = root
    while current.left:
        current = current.left
    return current

# 查找最大值
def find_max(root):
    if root is None:
        return None
    current = root
    while current.right:
        current = current.right
    return current

# 查找给定值的节点
def find_node(root, val):
    if root is None or root.val == val:
        return root
    
    if val < root.val:
        return find_node(root.left, val)
    else:
        return find_node(root.right, val)

# 查找后继节点（大于给定值的最小节点）
def find_successor(root, val):
    current = root
    successor = None
    
    while current:
        if current.val > val:
            successor = current
            current = current.left
        else:
            current = current.right
    
    return successor

# 查找前驱节点（小于给定值的最大节点）
def find_predecessor(root, val):
    current = root
    predecessor = None
    
    while current:
        if current.val < val:
            predecessor = current
            current = current.right
        else:
            current = current.left
    
    return predecessor

# 查找第k小的元素
def find_kth_smallest(root, k):
    result = [0, 0]  # [计数, 结果]
    
    def inorder_kth(node):
        if node is None or result[0] >= k:
            return
        
        inorder_kth(node.left)
        
        result[0] += 1
        if result[0] == k:
            result[1] = node.val
            return
        
        inorder_kth(node.right)
    
    inorder_kth(root)
    return result[1]

# 测试代码
if __name__ == "__main__":
    # 构建测试树
    root = TreeNode(50)
    root.left = TreeNode(30)
    root.right = TreeNode(70)
    root.left.left = TreeNode(20)
    root.left.right = TreeNode(40)
    root.right.left = TreeNode(60)
    root.right.right = TreeNode(80)
    
    print("最小值:", find_min(root).val if find_min(root) else "None")
    print("最大值:", find_max(root).val if find_max(root) else "None")
    node = find_node(root, 40)
    print("查找值 40:", node.val if node else "不存在")
    succ = find_successor(root, 40)
    print("后继节点(40):", succ.val if succ else "不存在")
    pred = find_predecessor(root, 40)
    print("前驱节点(40):", pred.val if pred else "不存在")
    print("第3小的元素:", find_kth_smallest(root, 3))
```

**C++代码**：
```cpp
#include <iostream>
using namespace std;

struct TreeNode {
    int val;
    TreeNode* left;
    TreeNode* right;
    
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
};

// 查找最小值
TreeNode* findMin(TreeNode* root) {
    if (root == nullptr) {
        return nullptr;
    }
    TreeNode* current = root;
    while (current->left != nullptr) {
        current = current->left;
    }
    return current;
}

// 查找最大值
TreeNode* findMax(TreeNode* root) {
    if (root == nullptr) {
        return nullptr;
    }
    TreeNode* current = root;
    while (current->right != nullptr) {
        current = current->right;
    }
    return current;
}

// 查找给定值的节点
TreeNode* findNode(TreeNode* root, int val) {
    if (root == nullptr || root->val == val) {
        return root;
    }
    
    if (val < root->val) {
        return findNode(root->left, val);
    } else {
        return findNode(root->right, val);
    }
}

// 查找后继节点（大于给定值的最小节点）
TreeNode* findSuccessor(TreeNode* root, int val) {
    TreeNode* current = root;
    TreeNode* successor = nullptr;
    
    while (current != nullptr) {
        if (current->val > val) {
            successor = current;
            current = current->left;
        } else {
            current = current->right;
        }
    }
    
    return successor;
}

// 查找前驱节点（小于给定值的最大节点）
TreeNode* findPredecessor(TreeNode* root, int val) {
    TreeNode* current = root;
    TreeNode* predecessor = nullptr;
    
    while (current != nullptr) {
        if (current->val < val) {
            predecessor = current;
            current = current->right;
        } else {
            current = current->left;
        }
    }
    
    return predecessor;
}

// 查找第k小的元素
void inorderKth(TreeNode* root, int k, int& count, int& result) {
    if (root == nullptr || count >= k) {
        return;
    }
    
    inorderKth(root->left, k, count, result);
    
    count++;
    if (count == k) {
        result = root->val;
        return;
    }
    
    inorderKth(root->right, k, count, result);
}

int findKthSmallest(TreeNode* root, int k) {
    int count = 0;
    int result = -1;
    inorderKth(root, k, count, result);
    return result;
}

// 释放树内存
void deleteTree(TreeNode* root) {
    if (root != nullptr) {
        deleteTree(root->left);
        deleteTree(root->right);
        delete root;
    }
}

int main() {
    // 构建测试树
    TreeNode* root = new TreeNode(50);
    root->left = new TreeNode(30);
    root->right = new TreeNode(70);
    root->left->left = new TreeNode(20);
    root->left->right = new TreeNode(40);
    root->right->left = new TreeNode(60);
    root->right->right = new TreeNode(80);
    
    TreeNode* minNode = findMin(root);
    cout << "最小值: " << (minNode ? minNode->val : -1) << endl;
    
    TreeNode* maxNode = findMax(root);
    cout << "最大值: " << (maxNode ? maxNode->val : -1) << endl;
    
    TreeNode* targetNode = findNode(root, 40);
    cout << "查找值 40: " << (targetNode ? to_string(targetNode->val) : "不存在") << endl;
    
    TreeNode* succNode = findSuccessor(root, 40);
    cout << "后继节点(40): " << (succNode ? succNode->val : -1) << endl;
    
    TreeNode* predNode = findPredecessor(root, 40);
    cout << "前驱节点(40): " << (predNode ? predNode->val : -1) << endl;
    
    cout << "第3小的元素: " << findKthSmallest(root, 3) << endl;
    
    // 释放内存
    deleteTree(root);
    
    return 0;
}
```

## 经典算法题目

### 3. LeetCode 98. 验证二叉搜索树

**题目链接**：https://leetcode.com/problems/validate-binary-search-tree/

**题目描述**：给定一个二叉树，判断其是否是一个有效的二叉搜索树。

**解题思路**：
- 利用BST的性质：节点的左子树的所有节点值都小于该节点值，右子树的所有节点值都大于该节点值
- 使用递归或中序遍历验证

**Java代码**：
```java
class Solution {
    public boolean isValidBST(TreeNode root) {
        return validate(root, null, null);
    }
    
    private boolean validate(TreeNode node, Integer lower, Integer upper) {
        if (node == null) {
            return true;
        }
        
        if ((lower != null && node.val <= lower) || (upper != null && node.val >= upper)) {
            return false;
        }
        
        return validate(node.left, lower, node.val) && validate(node.right, node.val, upper);
    }
}
```

**Python代码**：
```python
class Solution:
    def isValidBST(self, root: Optional[TreeNode]) -> bool:
        def validate(node, lower=float('-inf'), upper=float('inf')):
            if not node:
                return True
            
            if node.val <= lower or node.val >= upper:
                return False
            
            return (validate(node.left, lower, node.val) and 
                    validate(node.right, node.val, upper))
        
        return validate(root)
```

**C++代码**：
```cpp
class Solution {
public:
    bool isValidBST(TreeNode* root) {
        return validate(root, nullptr, nullptr);
    }
    
    bool validate(TreeNode* node, TreeNode* lower, TreeNode* upper) {
        if (node == nullptr) {
            return true;
        }
        
        if ((lower != nullptr && node->val <= lower->val) || 
            (upper != nullptr && node->val >= upper->val)) {
            return false;
        }
        
        return validate(node->left, lower, node) && validate(node->right, node, upper);
    }
};
```

### 4. LeetCode 230. 二叉搜索树中第K小的元素

**题目链接**：https://leetcode.com/problems/kth-smallest-element-in-a-bst/

**题目描述**：给定一个二叉搜索树的根节点 root，和一个整数 k，请你设计一个算法查找其中第 k 个最小元素（从 1 开始计数）。

**解题思路**：
- 利用BST的中序遍历结果是有序的特性
- 中序遍历到第k个元素时返回

**Java代码**：
```java
class Solution {
    public int kthSmallest(TreeNode root, int k) {
        int[] result = new int[2]; // [计数, 结果]
        inorder(root, k, result);
        return result[1];
    }
    
    private void inorder(TreeNode root, int k, int[] result) {
        if (root == null || result[0] >= k) {
            return;
        }
        
        inorder(root.left, k, result);
        
        result[0]++;
        if (result[0] == k) {
            result[1] = root.val;
            return;
        }
        
        inorder(root.right, k, result);
    }
}
```

**Python代码**：
```python
class Solution:
    def kthSmallest(self, root: Optional[TreeNode], k: int) -> int:
        stack = []
        current = root
        count = 0
        
        while current or stack:
            # 一直向左走到头
            while current:
                stack.append(current)
                current = current.left
            
            # 弹出栈顶元素
            current = stack.pop()
            count += 1
            
            if count == k:
                return current.val
            
            # 转向右子树
            current = current.right
        
        return -1  # 不应该到达这里
```

**C++代码**：
```cpp
class Solution {
public:
    int kthSmallest(TreeNode* root, int k) {
        int count = 0;
        int result = -1;
        inorder(root, k, count, result);
        return result;
    }
    
    void inorder(TreeNode* root, int k, int& count, int& result) {
        if (root == nullptr || count >= k) {
            return;
        }
        
        inorder(root->left, k, count, result);
        
        count++;
        if (count == k) {
            result = root->val;
            return;
        }
        
        inorder(root->right, k, count, result);
    }
};
```

### 5. LeetCode 538. 把二叉搜索树转换为累加树

**题目链接**：https://leetcode.com/problems/convert-bst-to-greater-tree/

**题目描述**：给出二叉 搜索 树的根节点，该树的节点值各不相同，请你将其转换为累加树（Greater Sum Tree），使每个节点 node 的新值等于原树中大于或等于 node.val 的值之和。

**解题思路**：
- 利用BST的特性，采用反中序遍历（右->根->左）
- 维护一个累加和变量，不断更新当前节点的值

**Java代码**：
```java
class Solution {
    private int sum = 0;
    
    public TreeNode convertBST(TreeNode root) {
        if (root != null) {
            // 先处理右子树
            convertBST(root.right);
            
            // 更新当前节点值
            sum += root.val;
            root.val = sum;
            
            // 再处理左子树
            convertBST(root.left);
        }
        return root;
    }
}
```

**Python代码**：
```python
class Solution:
    def __init__(self):
        self.sum = 0
    
    def convertBST(self, root: Optional[TreeNode]) -> Optional[TreeNode]:
        if root:
            # 先处理右子树
            self.convertBST(root.right)
            
            # 更新当前节点值
            self.sum += root.val
            root.val = self.sum
            
            # 再处理左子树
            self.convertBST(root.left)
        return root
```

**C++代码**：
```cpp
class Solution {
private:
    int sum = 0;
    
public:
    TreeNode* convertBST(TreeNode* root) {
        if (root != nullptr) {
            // 先处理右子树
            convertBST(root->right);
            
            // 更新当前节点值
            sum += root->val;
            root->val = sum;
            
            // 再处理左子树
            convertBST(root->left);
        }
        return root;
    }
};
```

### 6. LeetCode 700. 二叉搜索树中的搜索

**题目链接**：https://leetcode.com/problems/search-in-a-binary-search-tree/

**题目描述**：给定二叉搜索树（BST）的根节点 root 和一个整数值 val。你需要在 BST 中找到节点值等于 val 的节点。返回以该节点为根的子树。如果节点不存在，则返回 null 。

**解题思路**：
- 利用BST的性质进行高效搜索
- 递归或迭代实现

**Java代码**：
```java
class Solution {
    public TreeNode searchBST(TreeNode root, int val) {
        if (root == null || root.val == val) {
            return root;
        }
        
        if (val < root.val) {
            return searchBST(root.left, val);
        } else {
            return searchBST(root.right, val);
        }
    }
}
```

**Python代码**：
```python
class Solution:
    def searchBST(self, root: Optional[TreeNode], val: int) -> Optional[TreeNode]:
        # 迭代实现
        current = root
        while current:
            if current.val == val:
                return current
            elif val < current.val:
                current = current.left
            else:
                current = current.right
        return None
```

**C++代码**：
```cpp
class Solution {
public:
    TreeNode* searchBST(TreeNode* root, int val) {
        // 迭代实现
        TreeNode* current = root;
        while (current) {
            if (current->val == val) {
                return current;
            } else if (val < current->val) {
                current = current->left;
            } else {
                current = current->right;
            }
        }
        return nullptr;
    }
};
```

### 7. LeetCode 450. 删除二叉搜索树中的节点

**题目链接**：https://leetcode.com/problems/delete-node-in-a-bst/

**题目描述**：给定一个二叉搜索树的根节点 root 和一个值 key，删除二叉搜索树中的 key 对应的节点，并保证二叉搜索树的性质不变。返回二叉搜索树（有可能被更新）的根节点的引用。

**解题思路**：
- 找到要删除的节点
- 处理三种情况：叶子节点、只有一个子节点、有两个子节点
- 对于有两个子节点的情况，用右子树的最小值或左子树的最大值替换

**Java代码**：
```java
class Solution {
    public TreeNode deleteNode(TreeNode root, int key) {
        if (root == null) {
            return null;
        }
        
        if (key < root.val) {
            root.left = deleteNode(root.left, key);
        } else if (key > root.val) {
            root.right = deleteNode(root.right, key);
        } else {
            // 找到要删除的节点
            // 情况1：叶子节点
            if (root.left == null && root.right == null) {
                return null;
            }
            // 情况2：只有一个子节点
            else if (root.left == null) {
                return root.right;
            } else if (root.right == null) {
                return root.left;
            }
            // 情况3：有两个子节点
            // 找到右子树的最小值
            TreeNode minNode = findMin(root.right);
            // 用最小值替换当前节点
            root.val = minNode.val;
            // 删除右子树中的最小值节点
            root.right = deleteNode(root.right, minNode.val);
        }
        return root;
    }
    
    private TreeNode findMin(TreeNode node) {
        while (node.left != null) {
            node = node.left;
        }
        return node;
    }
}
```

**Python代码**：
```python
class Solution:
    def deleteNode(self, root: Optional[TreeNode], key: int) -> Optional[TreeNode]:
        if not root:
            return None
        
        if key < root.val:
            root.left = self.deleteNode(root.left, key)
        elif key > root.val:
            root.right = self.deleteNode(root.right, key)
        else:
            # 情况1：叶子节点
            if not root.left and not root.right:
                return None
            # 情况2：只有一个子节点
            elif not root.left:
                return root.right
            elif not root.right:
                return root.left
            # 情况3：有两个子节点
            # 找到右子树的最小值
            min_node = self.find_min(root.right)
            # 用最小值替换当前节点
            root.val = min_node.val
            # 删除右子树中的最小值节点
            root.right = self.deleteNode(root.right, min_node.val)
        
        return root
    
    def find_min(self, node):
        while node.left:
            node = node.left
        return node
```

**C++代码**：
```cpp
class Solution {
public:
    TreeNode* deleteNode(TreeNode* root, int key) {
        if (root == nullptr) {
            return nullptr;
        }
        
        if (key < root->val) {
            root->left = deleteNode(root->left, key);
        } else if (key > root->val) {
            root->right = deleteNode(root->right, key);
        } else {
            // 情况1：叶子节点
            if (root->left == nullptr && root->right == nullptr) {
                delete root;
                return nullptr;
            }
            // 情况2：只有一个子节点
            else if (root->left == nullptr) {
                TreeNode* temp = root->right;
                delete root;
                return temp;
            } else if (root->right == nullptr) {
                TreeNode* temp = root->left;
                delete root;
                return temp;
            }
            // 情况3：有两个子节点
            // 找到右子树的最小值
            TreeNode* minNode = findMin(root->right);
            // 用最小值替换当前节点
            root->val = minNode->val;
            // 删除右子树中的最小值节点
            root->right = deleteNode(root->right, minNode->val);
        }
        return root;
    }
    
    TreeNode* findMin(TreeNode* node) {
        while (node->left != nullptr) {
            node = node->left;
        }
        return node;
    }
};
```

## 更多练习题目

### 8. LeetCode 173. 二叉搜索树迭代器

**题目链接**：https://leetcode.com/problems/binary-search-tree-iterator/

**题目描述**：实现一个二叉搜索树迭代器类BSTIterator ，表示一个按中序遍历二叉搜索树（BST）的迭代器：
- BSTIterator(TreeNode root) 初始化 BSTIterator 类的一个对象。BST 的根节点 root 会作为构造函数的一部分给出。指针应初始化为一个不存在于 BST 中的数字，且该数字小于 BST 中的任何元素。
- boolean hasNext() 如果向指针右侧遍历存在数字，则返回 true ；否则返回 false 。
- int next() 将指针向右移动，然后返回指针处的数字。

**解题思路**：
- 使用栈模拟中序遍历的过程
- 在构造函数中初始化栈，将根节点及其所有左子节点入栈
- next() 方法弹出栈顶元素，如果该元素有右子节点，将右子节点及其所有左子节点入栈

**Java代码**：
```java
class BSTIterator {
    private Stack<TreeNode> stack;
    
    public BSTIterator(TreeNode root) {
        stack = new Stack<>();
        pushAllLeft(root);
    }
    
    public int next() {
        TreeNode node = stack.pop();
        pushAllLeft(node.right);
        return node.val;
    }
    
    public boolean hasNext() {
        return !stack.isEmpty();
    }
    
    private void pushAllLeft(TreeNode node) {
        while (node != null) {
            stack.push(node);
            node = node.left;
        }
    }
}
```

**Python代码**：
```python
class BSTIterator:
    def __init__(self, root: Optional[TreeNode]):
        self.stack = []
        self._push_all_left(root)
    
    def next(self) -> int:
        node = self.stack.pop()
        self._push_all_left(node.right)
        return node.val
    
    def hasNext(self) -> bool:
        return len(self.stack) > 0
    
    def _push_all_left(self, node):
        while node:
            self.stack.append(node)
            node = node.left
```

**C++代码**：
```cpp
class BSTIterator {
private:
    stack<TreeNode*> stk;
    
    void pushAllLeft(TreeNode* node) {
        while (node != nullptr) {
            stk.push(node);
            node = node->left;
        }
    }
    
public:
    BSTIterator(TreeNode* root) {
        pushAllLeft(root);
    }
    
    int next() {
        TreeNode* node = stk.top();
        stk.pop();
        pushAllLeft(node->right);
        return node->val;
    }
    
    bool hasNext() {
        return !stk.empty();
    }
};
```

### 9. LeetCode 235. 二叉搜索树的最近公共祖先

**题目链接**：https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/

**题目描述**：给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。

**解题思路**：
- 利用BST的性质：如果p和q都小于当前节点，则最近公共祖先在左子树；如果都大于当前节点，则在右子树；否则当前节点就是最近公共祖先

**Java代码**：
```java
class Solution {
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        // 利用BST的性质进行迭代
        while (root != null) {
            if (p.val < root.val && q.val < root.val) {
                root = root.left;
            } else if (p.val > root.val && q.val > root.val) {
                root = root.right;
            } else {
                // 找到分叉点，即为最近公共祖先
                return root;
            }
        }
        return null;
    }
}
```

**Python代码**：
```python
class Solution:
    def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -> 'TreeNode':
        # 递归实现
        if p.val < root.val and q.val < root.val:
            return self.lowestCommonAncestor(root.left, p, q)
        elif p.val > root.val and q.val > root.val:
            return self.lowestCommonAncestor(root.right, p, q)
        else:
            return root
```

**C++代码**：
```cpp
class Solution {
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        // 迭代实现
        TreeNode* current = root;
        while (current) {
            if (p->val < current->val && q->val < current->val) {
                current = current->left;
            } else if (p->val > current->val && q->val > current->val) {
                current = current->right;
            } else {
                return current;
            }
        }
        return nullptr;
    }
};
```

### 10. LeetCode 653. 两数之和 IV - 输入 BST

**题目链接**：https://leetcode.com/problems/two-sum-iv-input-is-a-bst/

**题目描述**：给定一个二叉搜索树 root 和一个目标结果 k，如果 BST 中存在两个元素且它们的和等于给定的目标结果，则返回 true。

**解题思路**：
- 利用BST的中序遍历得到有序数组，然后使用双指针查找
- 或者使用HashSet记录已访问过的节点值，边遍历边查找

**Java代码**：
```java
class Solution {
    public boolean findTarget(TreeNode root, int k) {
        Set<Integer> seen = new HashSet<>();
        return dfs(root, k, seen);
    }
    
    private boolean dfs(TreeNode node, int k, Set<Integer> seen) {
        if (node == null) {
            return false;
        }
        
        if (seen.contains(k - node.val)) {
            return true;
        }
        
        seen.add(node.val);
        
        return dfs(node.left, k, seen) || dfs(node.right, k, seen);
    }
}
```

**Python代码**：
```python
class Solution:
    def findTarget(self, root: Optional[TreeNode], k: int) -> bool:
        seen = set()
        
        def dfs(node):
            if not node:
                return False
            
            if k - node.val in seen:
                return True
            
            seen.add(node.val)
            
            return dfs(node.left) or dfs(node.right)
        
        return dfs(root)
```

**C++代码**：
```cpp
class Solution {
public:
    bool findTarget(TreeNode* root, int k) {
        unordered_set<int> seen;
        return dfs(root, k, seen);
    }
    
    bool dfs(TreeNode* node, int k, unordered_set<int>& seen) {
        if (node == nullptr) {
            return false;
        }
        
        if (seen.count(k - node->val)) {
            return true;
        }
        
        seen.insert(node->val);
        
        return dfs(node->left, k, seen) || dfs(node->right, k, seen);
    }
};
```

## 二叉搜索树的性能分析

### 时间复杂度
- **平均情况**：查找、插入、删除操作的时间复杂度为 O(log n)
- **最坏情况**：当树退化为链表时，时间复杂度退化为 O(n)

### 空间复杂度
- 树的存储需要 O(n) 的空间
- 递归实现的查找操作需要 O(h) 的栈空间，其中 h 是树的高度，平均为 O(log n)，最坏为 O(n)

### 与其他数据结构的比较
- **数组**：查找可以用二分查找 O(log n)，但插入和删除需要 O(n)
- **链表**：查找需要 O(n)，插入和删除平均 O(1)
- **平衡二叉树**：所有操作均保证 O(log n) 时间复杂度，但实现更复杂

## 常见优化

1. **平衡二叉搜索树**：如AVL树、红黑树等，通过旋转操作保持树的平衡，确保最坏情况下的时间复杂度仍为 O(log n)

2. **自平衡BST**：在插入和删除操作时自动调整树的结构，保持平衡

3. **伸展树**：通过频繁访问的节点移到根附近来优化性能

4. **B树**：适用于磁盘等外部存储设备的多路平衡查找树

5. **Trie树**：适用于字符串前缀查找的树形数据结构

通过以上题目和代码实现，希望能帮助你更全面地理解和应用二叉搜索树的查找算法。

===============================================

文件: README_7.md
===============================================
# 分块查找算法专题

## 算法原理

分块查找（Blocking Search），也称为索引顺序查找，是一种结合了顺序查找和二分查找优点的查找算法。它的基本思想是：

1. 将待查找的线性表分成若干块（子表）
2. 块内元素可以是无序的，但块之间必须是有序的
3. 建立一个索引表，记录每块的起始位置和块内的最大（或最小）值
4. 查找时，先通过索引表确定目标值可能在哪个块中
5. 然后在确定的块内进行顺序查找

这种方法既保留了顺序查找对线性表无序或部分无序的适应性，又通过分块和索引提高了查找效率。

## 时间复杂度分析

- 索引表的查找时间：如果索引表是有序的，可以使用二分查找，时间复杂度为 O(log m)，其中 m 是块的数量
- 块内查找时间：采用顺序查找，平均时间复杂度为 O(n/m)，其中 n 是数据总量
- 总体平均时间复杂度：O(log m + n/m)
- 当 m = √n 时，总体时间复杂度达到最优，为 O(√n)

## 算法实现

### 1. 基本分块查找实现

**题目来源**：数据结构基础题

**题目描述**：实现分块查找算法，包括数据分块、索引表构建和查找过程

**解题思路**：
- 首先将数据分成大小相近的若干块
- 构建索引表，记录每块的起始位置和最大值
- 实现查找函数，先在索引表中查找可能包含目标值的块
- 然后在该块内进行顺序查找

**代码实现**：

**Java代码**：
```java
import java.util.Arrays;

public class BlockSearch {
    // 索引表：每个元素存储块的起始位置和最大值
    static class Index {
        int start;  // 块的起始位置
        int max;    // 块内最大值
        
        Index(int start, int max) {
            this.start = start;
            this.max = max;
        }
    }
    
    private int[] data;       // 原始数据数组
    private Index[] index;    // 索引表
    private int blockSize;    // 块的大小
    private int blockCount;   // 块的数量
    
    // 构造函数，初始化分块查找结构
    public BlockSearch(int[] array) {
        this.data = Arrays.copyOf(array, array.length);
        // 计算块的大小，通常取数据量的平方根
        this.blockSize = (int) Math.sqrt(array.length);
        // 计算块的数量
        this.blockCount = (array.length + blockSize - 1) / blockSize;  // 向上取整
        
        // 构建索引表
        buildIndex();
    }
    
    // 构建索引表
    private void buildIndex() {
        index = new Index[blockCount];
        
        for (int i = 0; i < blockCount; i++) {
            int start = i * blockSize;
            int end = Math.min(start + blockSize, data.length);
            
            // 找出块内最大值
            int max = data[start];
            for (int j = start + 1; j < end; j++) {
                if (data[j] > max) {
                    max = data[j];
                }
            }
            
            index[i] = new Index(start, max);
        }
    }
    
    // 查找函数
    public int search(int target) {
        // 1. 在索引表中查找目标值可能在的块
        int blockIndex = -1;
        for (int i = 0; i < blockCount; i++) {
            if (target <= index[i].max) {
                blockIndex = i;
                break;
            }
        }
        
        // 目标值大于所有块的最大值，不存在
        if (blockIndex == -1) {
            return -1;
        }
        
        // 2. 在对应的块内进行顺序查找
        int start = index[blockIndex].start;
        int end = Math.min(start + blockSize, data.length);
        
        for (int i = start; i < end; i++) {
            if (data[i] == target) {
                return i;  // 返回目标值在原始数组中的索引
            }
        }
        
        return -1;  // 目标值不存在
    }
    
    // 打印分块信息
    public void printBlocks() {
        System.out.println("分块信息：");
        for (int i = 0; i < blockCount; i++) {
            int start = index[i].start;
            int end = Math.min(start + blockSize, data.length);
            System.out.print("块" + (i + 1) + " [" + start + "-" + (end - 1) + "]: ");
            for (int j = start; j < end; j++) {
                System.out.print(data[j] + " ");
            }
            System.out.println(" (最大值: " + index[i].max + ")");
        }
    }
    
    public static void main(String[] args) {
        int[] array = {22, 12, 13, 8, 9, 20, 33, 42, 44, 38, 24, 48, 60, 58, 74, 49, 86, 53};
        BlockSearch searcher = new BlockSearch(array);
        
        // 打印分块信息
        searcher.printBlocks();
        
        // 测试查找
        int[] targets = {13, 42, 50, 86};
        for (int target : targets) {
            int index = searcher.search(target);
            if (index != -1) {
                System.out.println("查找 " + target + " 成功，索引位置：" + index);
            } else {
                System.out.println("查找 " + target + " 失败");
            }
        }
    }
}
```

**Python代码**：
```python
import math

class BlockSearch:
    def __init__(self, array):
        self.data = array.copy()
        # 计算块的大小，通常取数据量的平方根
        self.block_size = int(math.sqrt(len(array)))
        # 计算块的数量
        self.block_count = (len(array) + self.block_size - 1) // self.block_size  # 向上取整
        
        # 构建索引表 [(start, max)]
        self.index = []
        self._build_index()
    
    def _build_index(self):
        """构建索引表"""
        for i in range(self.block_count):
            start = i * self.block_size
            end = min(start + self.block_size, len(self.data))
            
            # 找出块内最大值
            block_max = max(self.data[start:end])
            self.index.append((start, block_max))
    
    def search(self, target):
        """查找目标值，返回索引位置，未找到返回-1"""
        # 1. 在索引表中查找目标值可能在的块
        block_index = -1
        for i in range(self.block_count):
            if target <= self.index[i][1]:
                block_index = i
                break
        
        # 目标值大于所有块的最大值，不存在
        if block_index == -1:
            return -1
        
        # 2. 在对应的块内进行顺序查找
        start, _ = self.index[block_index]
        end = min(start + self.block_size, len(self.data))
        
        for i in range(start, end):
            if self.data[i] == target:
                return i  # 返回目标值在原始数组中的索引
        
        return -1  # 目标值不存在
    
    def print_blocks(self):
        """打印分块信息"""
        print("分块信息：")
        for i in range(self.block_count):
            start, max_val = self.index[i]
            end = min(start + self.block_size, len(self.data))
            print(f"块{i+1} [{start}-{end-1}]: {' '.join(map(str, self.data[start:end]))} (最大值: {max_val})")

# 测试代码
if __name__ == "__main__":
    array = [22, 12, 13, 8, 9, 20, 33, 42, 44, 38, 24, 48, 60, 58, 74, 49, 86, 53]
    searcher = BlockSearch(array)
    
    # 打印分块信息
    searcher.print_blocks()
    
    # 测试查找
    targets = [13, 42, 50, 86]
    for target in targets:
        index = searcher.search(target)
        if index != -1:
            print(f"查找 {target} 成功，索引位置：{index}")
        else:
            print(f"查找 {target} 失败")
```

**C++代码**：
```cpp
#include <iostream>
#include <vector>
#include <cmath>
#include <algorithm>
using namespace std;

struct Index {
    int start;  // 块的起始位置
    int max;    // 块内最大值
    
    Index(int s, int m) : start(s), max(m) {}
};

class BlockSearch {
private:
    vector<int> data;      // 原始数据数组
    vector<Index> index;   // 索引表
    int blockSize;         // 块的大小
    int blockCount;        // 块的数量
    
    void buildIndex() {
        index.clear();
        
        for (int i = 0; i < blockCount; i++) {
            int start = i * blockSize;
            int end = min(start + blockSize, (int)data.size());
            
            // 找出块内最大值
            int maxVal = data[start];
            for (int j = start + 1; j < end; j++) {
                if (data[j] > maxVal) {
                    maxVal = data[j];
                }
            }
            
            index.push_back(Index(start, maxVal));
        }
    }
    
public:
    BlockSearch(const vector<int>& array) : data(array) {
        // 计算块的大小
        blockSize = static_cast<int>(sqrt(data.size()));
        // 计算块的数量
        blockCount = (data.size() + blockSize - 1) / blockSize;  // 向上取整
        
        buildIndex();
    }
    
    int search(int target) {
        // 1. 在索引表中查找目标值可能在的块
        int blockIndex = -1;
        for (int i = 0; i < blockCount; i++) {
            if (target <= index[i].max) {
                blockIndex = i;
                break;
            }
        }
        
        // 目标值大于所有块的最大值，不存在
        if (blockIndex == -1) {
            return -1;
        }
        
        // 2. 在对应的块内进行顺序查找
        int start = index[blockIndex].start;
        int end = min(start + blockSize, (int)data.size());
        
        for (int i = start; i < end; i++) {
            if (data[i] == target) {
                return i;  // 返回目标值在原始数组中的索引
            }
        }
        
        return -1;  // 目标值不存在
    }
    
    void printBlocks() {
        cout << "分块信息：" << endl;
        for (int i = 0; i < blockCount; i++) {
            int start = index[i].start;
            int end = min(start + blockSize, (int)data.size());
            cout << "块" << (i + 1) << " [" << start << "-" << (end - 1) << "]: ";
            for (int j = start; j < end; j++) {
                cout << data[j] << " ";
            }
            cout << " (最大值: " << index[i].max << ")" << endl;
        }
    }
};

int main() {
    vector<int> array = {22, 12, 13, 8, 9, 20, 33, 42, 44, 38, 24, 48, 60, 58, 74, 49, 86, 53};
    BlockSearch searcher(array);
    
    // 打印分块信息
    searcher.printBlocks();
    
    // 测试查找
    vector<int> targets = {13, 42, 50, 86};
    for (int target : targets) {
        int index = searcher.search(target);
        if (index != -1) {
            cout << "查找 " << target << " 成功，索引位置：" << index << endl;
        } else {
            cout << "查找 " << target << " 失败" << endl;
        }
    }
    
    return 0;
}
```

### 2. 有序数组的分块查找优化

**题目来源**：数据结构进阶题

**题目描述**：对于有序数组，优化分块查找算法，使其效率更高

**解题思路**：
- 对于有序数组，可以优化索引表的结构
- 索引表可以使用二分查找来提高查找效率
- 块内查找也可以使用二分查找

**代码实现**：

**Java代码**：
```java
import java.util.Arrays;

public class OptimizedBlockSearch {
    // 索引表：每个元素存储块的起始位置、结束位置和最大值
    static class Index {
        int start;  // 块的起始位置
        int end;    // 块的结束位置
        int min;    // 块内最小值
        int max;    // 块内最大值
        
        Index(int start, int end, int min, int max) {
            this.start = start;
            this.end = end;
            this.min = min;
            this.max = max;
        }
    }
    
    private int[] data;       // 原始数据数组（已排序）
    private Index[] index;    // 索引表
    private int blockSize;    // 块的大小
    private int blockCount;   // 块的数量
    
    // 构造函数，初始化分块查找结构
    public OptimizedBlockSearch(int[] array) {
        // 确保数组已排序
        this.data = Arrays.copyOf(array, array.length);
        Arrays.sort(this.data);
        
        // 计算块的大小，通常取数据量的平方根
        this.blockSize = (int) Math.sqrt(array.length);
        // 计算块的数量
        this.blockCount = (array.length + blockSize - 1) / blockSize;  // 向上取整
        
        // 构建索引表
        buildIndex();
    }
    
    // 构建索引表
    private void buildIndex() {
        index = new Index[blockCount];
        
        for (int i = 0; i < blockCount; i++) {
            int start = i * blockSize;
            int end = Math.min(start + blockSize - 1, data.length - 1);
            
            // 由于数组已排序，块的最小值和最大值就是块的第一个和最后一个元素
            int min = data[start];
            int max = data[end];
            
            index[i] = new Index(start, end, min, max);
        }
    }
    
    // 查找函数
    public int search(int target) {
        // 1. 在索引表中使用二分查找找到目标值可能在的块
        int left = 0;
        int right = blockCount - 1;
        int blockIndex = -1;
        
        while (left <= right) {
            int mid = left + (right - left) / 2;
            if (target >= index[mid].min && target <= index[mid].max) {
                blockIndex = mid;
                break;
            } else if (target < index[mid].min) {
                right = mid - 1;
            } else {
                left = mid + 1;
            }
        }
        
        // 目标值不在任何块的范围内
        if (blockIndex == -1) {
            return -1;
        }
        
        // 2. 在对应的块内使用二分查找
        int start = index[blockIndex].start;
        int end = index[blockIndex].end;
        
        while (start <= end) {
            int mid = start + (end - start) / 2;
            if (data[mid] == target) {
                return mid;
            } else if (data[mid] < target) {
                start = mid + 1;
            } else {
                end = mid - 1;
            }
        }
        
        return -1;  // 目标值不存在
    }
    
    // 打印分块信息
    public void printBlocks() {
        System.out.println("分块信息（已排序数组）：");
        System.out.println("原始数组: " + Arrays.toString(data));
        for (int i = 0; i < blockCount; i++) {
            System.out.print("块" + (i + 1) + " [" + index[i].start + "-" + index[i].end + "]: ");
            for (int j = index[i].start; j <= index[i].end; j++) {
                System.out.print(data[j] + " ");
            }
            System.out.println(" (min: " + index[i].min + ", max: " + index[i].max + ")");
        }
    }
    
    public static void main(String[] args) {
        int[] array = {22, 12, 13, 8, 9, 20, 33, 42, 44, 38, 24, 48, 60, 58, 74, 49, 86, 53};
        OptimizedBlockSearch searcher = new OptimizedBlockSearch(array);
        
        // 打印分块信息
        searcher.printBlocks();
        
        // 测试查找
        int[] targets = {13, 42, 50, 86, 53};
        for (int target : targets) {
            int index = searcher.search(target);
            if (index != -1) {
                System.out.println("查找 " + target + " 成功，索引位置：" + index + "，值：" + searcher.data[index]);
            } else {
                System.out.println("查找 " + target + " 失败");
            }
        }
    }
}
```

**Python代码**：
```python
import math

class OptimizedBlockSearch:
    def __init__(self, array):
        # 确保数组已排序
        self.data = sorted(array)
        # 计算块的大小，通常取数据量的平方根
        self.block_size = int(math.sqrt(len(self.data)))
        # 计算块的数量
        self.block_count = (len(self.data) + self.block_size - 1) // self.block_size  # 向上取整
        
        # 构建索引表 [{'start': start, 'end': end, 'min': min, 'max': max}]
        self.index = []
        self._build_index()
    
    def _build_index(self):
        """构建索引表"""
        for i in range(self.block_count):
            start = i * self.block_size
            end = min(start + self.block_size - 1, len(self.data) - 1)
            
            # 由于数组已排序，块的最小值和最大值就是块的第一个和最后一个元素
            block_info = {
                'start': start,
                'end': end,
                'min': self.data[start],
                'max': self.data[end]
            }
            self.index.append(block_info)
    
    def search(self, target):
        """查找目标值，返回索引位置，未找到返回-1"""
        # 1. 在索引表中使用二分查找找到目标值可能在的块
        left, right = 0, self.block_count - 1
        block_index = -1
        
        while left <= right:
            mid = left + (right - left) // 2
            if self.index[mid]['min'] <= target <= self.index[mid]['max']:
                block_index = mid
                break
            elif target < self.index[mid]['min']:
                right = mid - 1
            else:
                left = mid + 1
        
        # 目标值不在任何块的范围内
        if block_index == -1:
            return -1
        
        # 2. 在对应的块内使用二分查找
        start = self.index[block_index]['start']
        end = self.index[block_index]['end']
        
        while start <= end:
            mid = start + (end - start) // 2
            if self.data[mid] == target:
                return mid
            elif self.data[mid] < target:
                start = mid + 1
            else:
                end = mid - 1
        
        return -1  # 目标值不存在
    
    def print_blocks(self):
        """打印分块信息"""
        print("分块信息（已排序数组）：")
        print(f"原始数组: {self.data}")
        for i in range(self.block_count):
            idx = self.index[i]
            start, end = idx['start'], idx['end']
            block_data = self.data[start:end+1]
            print(f"块{i+1} [{start}-{end}]: {' '.join(map(str, block_data))} (min: {idx['min']}, max: {idx['max']})")

# 测试代码
if __name__ == "__main__":
    array = [22, 12, 13, 8, 9, 20, 33, 42, 44, 38, 24, 48, 60, 58, 74, 49, 86, 53]
    searcher = OptimizedBlockSearch(array)
    
    # 打印分块信息
    searcher.print_blocks()
    
    # 测试查找
    targets = [13, 42, 50, 86, 53]
    for target in targets:
        index = searcher.search(target)
        if index != -1:
            print(f"查找 {target} 成功，索引位置：{index}，值：{searcher.data[index]}")
        else:
            print(f"查找 {target} 失败")
```

**C++代码**：
```cpp
#include <iostream>
#include <vector>
#include <cmath>
#include <algorithm>
using namespace std;

struct Index {
    int start;  // 块的起始位置
    int end;    // 块的结束位置
    int min;    // 块内最小值
    int max;    // 块内最大值
    
    Index(int s, int e, int mi, int ma) : start(s), end(e), min(mi), max(ma) {}
};

class OptimizedBlockSearch {
private:
    vector<int> data;      // 原始数据数组（已排序）
    vector<Index> index;   // 索引表
    int blockSize;         // 块的大小
    int blockCount;        // 块的数量
    
    void buildIndex() {
        index.clear();
        
        for (int i = 0; i < blockCount; i++) {
            int start = i * blockSize;
            int end = min(start + blockSize - 1, (int)data.size() - 1);
            
            // 由于数组已排序，块的最小值和最大值就是块的第一个和最后一个元素
            int minVal = data[start];
            int maxVal = data[end];
            
            index.push_back(Index(start, end, minVal, maxVal));
        }
    }
    
public:
    OptimizedBlockSearch(const vector<int>& array) : data(array) {
        // 确保数组已排序
        sort(data.begin(), data.end());
        
        // 计算块的大小
        blockSize = static_cast<int>(sqrt(data.size()));
        // 计算块的数量
        blockCount = (data.size() + blockSize - 1) / blockSize;  // 向上取整
        
        buildIndex();
    }
    
    int search(int target) {
        // 1. 在索引表中使用二分查找找到目标值可能在的块
        int left = 0;
        int right = blockCount - 1;
        int blockIndex = -1;
        
        while (left <= right) {
            int mid = left + (right - left) / 2;
            if (target >= index[mid].min && target <= index[mid].max) {
                blockIndex = mid;
                break;
            } else if (target < index[mid].min) {
                right = mid - 1;
            } else {
                left = mid + 1;
            }
        }
        
        // 目标值不在任何块的范围内
        if (blockIndex == -1) {
            return -1;
        }
        
        // 2. 在对应的块内使用二分查找
        int start = index[blockIndex].start;
        int end = index[blockIndex].end;
        
        while (start <= end) {
            int mid = start + (end - start) / 2;
            if (data[mid] == target) {
                return mid;
            } else if (data[mid] < target) {
                start = mid + 1;
            } else {
                end = mid - 1;
            }
        }
        
        return -1;  // 目标值不存在
    }
    
    void printBlocks() {
        cout << "分块信息（已排序数组）：" << endl;
        cout << "原始数组: [";
        for (size_t i = 0; i < data.size(); i++) {
            cout << data[i];
            if (i < data.size() - 1) cout << ", ";
        }
        cout << "]" << endl;
        
        for (int i = 0; i < blockCount; i++) {
            cout << "块" << (i + 1) << " [" << index[i].start << "-" << index[i].end << "]: ";
            for (int j = index[i].start; j <= index[i].end; j++) {
                cout << data[j] << " ";
            }
            cout << " (min: " << index[i].min << ", max: " << index[i].max << ")" << endl;
        }
    }
    
    // 获取已排序的数据数组（用于测试）
    const vector<int>& getData() const {
        return data;
    }
};

int main() {
    vector<int> array = {22, 12, 13, 8, 9, 20, 33, 42, 44, 38, 24, 48, 60, 58, 74, 49, 86, 53};
    OptimizedBlockSearch searcher(array);
    
    // 打印分块信息
    searcher.printBlocks();
    
    // 测试查找
    vector<int> targets = {13, 42, 50, 86, 53};
    for (int target : targets) {
        int index = searcher.search(target);
        if (index != -1) {
            cout << "查找 " << target << " 成功，索引位置：" << index << "，值：" << searcher.getData()[index] << endl;
        } else {
            cout << "查找 " << target << " 失败" << endl;
        }
    }
    
    return 0;
}
```

## 分块查找的应用场景

分块查找适用于以下场景：

1. **大型数据集**：当数据量很大，无法一次性加载到内存时
2. **部分有序数据**：当数据只是块间有序，块内无序时
3. **需要较快查找速度但又不想维护完全有序结构时**
4. **需要频繁更新但又需要保持较好查询性能时**
5. **数据库索引**：数据库中的索引结构常使用类似分块查找的思想

## 分块查找与其他查找算法的比较

| 算法 | 时间复杂度（平均） | 时间复杂度（最坏） | 空间复杂度 | 适用场景 |
|------|------------------|-------------------|-----------|----------|
| 顺序查找 | O(n) | O(n) | O(1) | 小规模数据，无序数据 |
| 二分查找 | O(log n) | O(log n) | O(1) | 有序数组 |
| 分块查找 | O(√n) | O(n) | O(√n) | 部分有序数据，需要较快查找 |
| 哈希查找 | O(1) | O(n) | O(n) | 可以构建哈希表的情况 |

## 经典算法题目

### 3. 多区间数据查询（离线分块处理）

**题目来源**：数据结构应用题

**题目描述**：给定一个数组，多次查询区间内的最大值

**解题思路**：
- 使用分块预处理，计算每个块的最大值
- 查询时，对于完整块直接取预处理的最大值，对于不完整块遍历查询

**代码实现**：

**Java代码**：
```java
import java.util.Arrays;

public class RangeMaxQuery {
    private int[] data;       // 原始数据数组
    private int[] blockMax;   // 每个块的最大值
    private int blockSize;    // 块的大小
    private int blockCount;   // 块的数量
    
    public RangeMaxQuery(int[] array) {
        this.data = Arrays.copyOf(array, array.length);
        this.blockSize = (int) Math.sqrt(array.length) + 1;  // +1防止除零
        this.blockCount = (array.length + blockSize - 1) / blockSize;
        this.blockMax = new int[blockCount];
        
        // 预处理每个块的最大值
        preprocess();
    }
    
    private void preprocess() {
        Arrays.fill(blockMax, Integer.MIN_VALUE);
        
        for (int i = 0; i < data.length; i++) {
            int blockIndex = i / blockSize;
            blockMax[blockIndex] = Math.max(blockMax[blockIndex], data[i]);
        }
    }
    
    // 查询区间[l, r]内的最大值（闭区间）
    public int queryMax(int l, int r) {
        if (l < 0 || r >= data.length || l > r) {
            throw new IllegalArgumentException("查询范围无效");
        }
        
        int maxVal = Integer.MIN_VALUE;
        int startBlock = l / blockSize;
        int endBlock = r / blockSize;
        
        // 如果查询范围在同一个块内
        if (startBlock == endBlock) {
            for (int i = l; i <= r; i++) {
                maxVal = Math.max(maxVal, data[i]);
            }
            return maxVal;
        }
        
        // 处理左边不完整的块
        for (int i = l; i < (startBlock + 1) * blockSize; i++) {
            maxVal = Math.max(maxVal, data[i]);
        }
        
        // 处理中间完整的块
        for (int i = startBlock + 1; i < endBlock; i++) {
            maxVal = Math.max(maxVal, blockMax[i]);
        }
        
        // 处理右边不完整的块
        for (int i = endBlock * blockSize; i <= r; i++) {
            maxVal = Math.max(maxVal, data[i]);
        }
        
        return maxVal;
    }
    
    public static void main(String[] args) {
        int[] array = {2, 1, 5, 3, 4, 7, 6, 8, 9, 10, 12, 11};
        RangeMaxQuery query = new RangeMaxQuery(array);
        
        System.out.println("原始数组: " + Arrays.toString(array));
        System.out.println("块大小: " + query.blockSize);
        System.out.println("块数量: " + query.blockCount);
        System.out.println("块最大值: " + Arrays.toString(query.blockMax));
        
        // 测试查询
        System.out.println("区间[0, 3]最大值: " + query.queryMax(0, 3));  // 5
        System.out.println("区间[2, 7]最大值: " + query.queryMax(2, 7));  // 8
        System.out.println("区间[4, 11]最大值: " + query.queryMax(4, 11));  // 12
        System.out.println("区间[6, 9]最大值: " + query.queryMax(6, 9));  // 10
    }
}
```

**Python代码**：
```python
import math

class RangeMaxQuery:
    def __init__(self, array):
        self.data = array.copy()
        self.block_size = int(math.sqrt(len(array))) + 1  # +1防止除零
        self.block_count = (len(array) + self.block_size - 1) // self.block_size
        self.block_max = [-float('inf')] * self.block_count
        
        # 预处理每个块的最大值
        self._preprocess()
    
    def _preprocess(self):
        """预处理每个块的最大值"""
        for i in range(len(self.data)):
            block_index = i // self.block_size
            self.block_max[block_index] = max(self.block_max[block_index], self.data[i])
    
    def query_max(self, l, r):
        """查询区间[l, r]内的最大值（闭区间）"""
        if l < 0 or r >= len(self.data) or l > r:
            raise ValueError("查询范围无效")
        
        max_val = -float('inf')
        start_block = l // self.block_size
        end_block = r // self.block_size
        
        # 如果查询范围在同一个块内
        if start_block == end_block:
            for i in range(l, r + 1):
                max_val = max(max_val, self.data[i])
            return max_val
        
        # 处理左边不完整的块
        for i in range(l, (start_block + 1) * self.block_size):
            max_val = max(max_val, self.data[i])
        
        # 处理中间完整的块
        for i in range(start_block + 1, end_block):
            max_val = max(max_val, self.block_max[i])
        
        # 处理右边不完整的块
        for i in range(end_block * self.block_size, r + 1):
            max_val = max(max_val, self.data[i])
        
        return max_val

# 测试代码
if __name__ == "__main__":
    array = [2, 1, 5, 3, 4, 7, 6, 8, 9, 10, 12, 11]
    query = RangeMaxQuery(array)
    
    print(f"原始数组: {array}")
    print(f"块大小: {query.block_size}")
    print(f"块数量: {query.block_count}")
    print(f"块最大值: {query.block_max}")
    
    # 测试查询
    print(f"区间[0, 3]最大值: {query.query_max(0, 3)}")  # 5
    print(f"区间[2, 7]最大值: {query.query_max(2, 7)}")  # 8
    print(f"区间[4, 11]最大值: {query.query_max(4, 11)}")  # 12
    print(f"区间[6, 9]最大值: {query.query_max(6, 9)}")  # 10
```

**C++代码**：
```cpp
#include <iostream>
#include <vector>
#include <cmath>
#include <climits>
using namespace std;

class RangeMaxQuery {
private:
    vector<int> data;      // 原始数据数组
    vector<int> blockMax;  // 每个块的最大值
    int blockSize;         // 块的大小
    int blockCount;        // 块的数量
    
    void preprocess() {
        blockMax.assign(blockCount, INT_MIN);
        
        for (int i = 0; i < (int)data.size(); i++) {
            int blockIndex = i / blockSize;
            blockMax[blockIndex] = max(blockMax[blockIndex], data[i]);
        }
    }
    
public:
    RangeMaxQuery(const vector<int>& array) : data(array) {
        blockSize = static_cast<int>(sqrt(array.size())) + 1;  // +1防止除零
        blockCount = (array.size() + blockSize - 1) / blockSize;
        
        preprocess();
    }
    
    // 查询区间[l, r]内的最大值（闭区间）
    int queryMax(int l, int r) {
        if (l < 0 || r >= (int)data.size() || l > r) {
            throw invalid_argument("查询范围无效");
        }
        
        int maxVal = INT_MIN;
        int startBlock = l / blockSize;
        int endBlock = r / blockSize;
        
        // 如果查询范围在同一个块内
        if (startBlock == endBlock) {
            for (int i = l; i <= r; i++) {
                maxVal = max(maxVal, data[i]);
            }
            return maxVal;
        }
        
        // 处理左边不完整的块
        for (int i = l; i < (startBlock + 1) * blockSize; i++) {
            maxVal = max(maxVal, data[i]);
        }
        
        // 处理中间完整的块
        for (int i = startBlock + 1; i < endBlock; i++) {
            maxVal = max(maxVal, blockMax[i]);
        }
        
        // 处理右边不完整的块
        for (int i = endBlock * blockSize; i <= r; i++) {
            maxVal = max(maxVal, data[i]);
        }
        
        return maxVal;
    }
    
    // 获取相关参数用于测试
    int getBlockSize() const { return blockSize; }
    int getBlockCount() const { return blockCount; }
    const vector<int>& getData() const { return data; }
    const vector<int>& getBlockMax() const { return blockMax; }
};

int main() {
    vector<int> array = {2, 1, 5, 3, 4, 7, 6, 8, 9, 10, 12, 11};
    RangeMaxQuery query(array);
    
    cout << "原始数组: [";
    for (size_t i = 0; i < array.size(); i++) {
        cout << array[i];
        if (i < array.size() - 1) cout << ", ";
    }
    cout << "]" << endl;
    
    cout << "块大小: " << query.getBlockSize() << endl;
    cout << "块数量: " << query.getBlockCount() << endl;
    
    cout << "块最大值: [";
    const vector<int>& blockMax = query.getBlockMax();
    for (size_t i = 0; i < blockMax.size(); i++) {
        cout << blockMax[i];
        if (i < blockMax.size() - 1) cout << ", ";
    }
    cout << "]" << endl;
    
    // 测试查询
    cout << "区间[0, 3]最大值: " << query.queryMax(0, 3) << endl;  // 5
    cout << "区间[2, 7]最大值: " << query.queryMax(2, 7) << endl;  // 8
    cout << "区间[4, 11]最大值: " << query.queryMax(4, 11) << endl;  // 12
    cout << "区间[6, 9]最大值: " << query.queryMax(6, 9) << endl;  // 10
    
    return 0;
}
```

## 更多练习题目

### 4. LeetCode 307. 区域和检索 - 数组可修改

**题目链接**：https://leetcode.com/problems/range-sum-query-mutable/

**题目描述**：给你一个数组 nums ，请你完成两类查询，其中一类是更新数组某个位置的值，另一类是求数组某个区间内元素的和。

**解题思路**：
- 使用分块方法，每个块维护自己的和
- 更新操作时，更新原数组和对应块的和
- 查询操作时，累加区间内完整块的和和不完整块的元素和

**Java代码**：
```java
class NumArray {
    private int[] nums;      // 原始数组
    private int[] blockSum;  // 每个块的和
    private int blockSize;   // 块的大小
    
    public NumArray(int[] nums) {
        this.nums = nums;
        this.blockSize = (int) Math.sqrt(nums.length) + 1;
        this.blockSum = new int[(nums.length + blockSize - 1) / blockSize];
        
        // 初始化块和
        for (int i = 0; i < nums.length; i++) {
            blockSum[i / blockSize] += nums[i];
        }
    }
    
    public void update(int index, int val) {
        int blockIndex = index / blockSize;
        blockSum[blockIndex] += (val - nums[index]);
        nums[index] = val;
    }
    
    public int sumRange(int left, int right) {
        int sum = 0;
        int startBlock = left / blockSize;
        int endBlock = right / blockSize;
        
        if (startBlock == endBlock) {
            // 在同一个块内
            for (int i = left; i <= right; i++) {
                sum += nums[i];
            }
            return sum;
        }
        
        // 左边不完整块
        for (int i = left; i < (startBlock + 1) * blockSize; i++) {
            sum += nums[i];
        }
        
        // 中间完整块
        for (int i = startBlock + 1; i < endBlock; i++) {
            sum += blockSum[i];
        }
        
        // 右边不完整块
        for (int i = endBlock * blockSize; i <= right; i++) {
            sum += nums[i];
        }
        
        return sum;
    }
}
```

**Python代码**：
```python
import math

class NumArray:
    def __init__(self, nums: List[int]):
        self.nums = nums
        self.block_size = int(math.sqrt(len(nums))) + 1
        self.block_count = (len(nums) + self.block_size - 1) // self.block_size
        self.block_sum = [0] * self.block_count
        
        # 初始化块和
        for i in range(len(nums)):
            self.block_sum[i // self.block_size] += nums[i]
    
    def update(self, index: int, val: int) -> None:
        block_index = index // self.block_size
        self.block_sum[block_index] += (val - self.nums[index])
        self.nums[index] = val
    
    def sumRange(self, left: int, right: int) -> int:
        sum_val = 0
        start_block = left // self.block_size
        end_block = right // self.block_size
        
        if start_block == end_block:
            # 在同一个块内
            for i in range(left, right + 1):
                sum_val += self.nums[i]
            return sum_val
        
        # 左边不完整块
        for i in range(left, (start_block + 1) * self.block_size):
            sum_val += self.nums[i]
        
        # 中间完整块
        for i in range(start_block + 1, end_block):
            sum_val += self.block_sum[i]
        
        # 右边不完整块
        for i in range(end_block * self.block_size, right + 1):
            sum_val += self.nums[i]
        
        return sum_val
```

**C++代码**：
```cpp
class NumArray {
private:
    vector<int> nums;      // 原始数组
    vector<int> blockSum;  // 每个块的和
    int blockSize;         // 块的大小
    
public:
    NumArray(vector<int>& nums) : nums(nums) {
        blockSize = static_cast<int>(sqrt(nums.size())) + 1;
        int blockCount = (nums.size() + blockSize - 1) / blockSize;
        blockSum.resize(blockCount, 0);
        
        // 初始化块和
        for (int i = 0; i < (int)nums.size(); i++) {
            blockSum[i / blockSize] += nums[i];
        }
    }
    
    void update(int index, int val) {
        int blockIndex = index / blockSize;
        blockSum[blockIndex] += (val - nums[index]);
        nums[index] = val;
    }
    
    int sumRange(int left, int right) {
        int sum = 0;
        int startBlock = left / blockSize;
        int endBlock = right / blockSize;
        
        if (startBlock == endBlock) {
            // 在同一个块内
            for (int i = left; i <= right; i++) {
                sum += nums[i];
            }
            return sum;
        }
        
        // 左边不完整块
        for (int i = left; i < (startBlock + 1) * blockSize; i++) {
            sum += nums[i];
        }
        
        // 中间完整块
        for (int i = startBlock + 1; i < endBlock; i++) {
            sum += blockSum[i];
        }
        
        // 右边不完整块
        for (int i = endBlock * blockSize; i <= right; i++) {
            sum += nums[i];
        }
        
        return sum;
    }
};
```

### 5. LeetCode 325. 和等于 k 的最长子数组长度

**题目链接**：https://leetcode.com/problems/maximum-size-subarray-sum-equals-k/

**题目描述**：给定一个数组和一个目标值 k，找到和等于 k 的最长连续子数组长度。如果不存在任意一个符合要求的子数组，则返回 0。

**解题思路**：
- 使用前缀和和哈希表优化
- 虽然这道题主要是前缀和思想，但可以结合分块思想进行预处理

**Java代码**：
```java
class Solution {
    public int maxSubArrayLen(int[] nums, int k) {
        Map<Long, Integer> prefixSumMap = new HashMap<>();
        long prefixSum = 0;
        int maxLength = 0;
        
        // 初始值，前缀和为0出现在索引-1处
        prefixSumMap.put(0L, -1);
        
        for (int i = 0; i < nums.length; i++) {
            prefixSum += nums[i];
            
            // 查找是否存在前缀和为prefixSum - k
            if (prefixSumMap.containsKey(prefixSum - k)) {
                maxLength = Math.max(maxLength, i - prefixSumMap.get(prefixSum - k));
            }
            
            // 只保存第一次出现的前缀和，以保证子数组最长
            if (!prefixSumMap.containsKey(prefixSum)) {
                prefixSumMap.put(prefixSum, i);
            }
        }
        
        return maxLength;
    }
}
```

**Python代码**：
```python
class Solution:
    def maxSubArrayLen(self, nums: List[int], k: int) -> int:
        prefix_sum_map = {0: -1}  # 前缀和为0出现在索引-1处
        prefix_sum = 0
        max_length = 0
        
        for i, num in enumerate(nums):
            prefix_sum += num
            
            # 查找是否存在前缀和为prefix_sum - k
            if prefix_sum - k in prefix_sum_map:
                max_length = max(max_length, i - prefix_sum_map[prefix_sum - k])
            
            # 只保存第一次出现的前缀和，以保证子数组最长
            if prefix_sum not in prefix_sum_map:
                prefix_sum_map[prefix_sum] = i
        
        return max_length
```

**C++代码**：
```cpp
class Solution {
public:
    int maxSubArrayLen(vector<int>& nums, int k) {
        unordered_map<long long, int> prefixSumMap;
        long long prefixSum = 0;
        int maxLength = 0;
        
        // 初始值，前缀和为0出现在索引-1处
        prefixSumMap[0] = -1;
        
        for (int i = 0; i < (int)nums.size(); i++) {
            prefixSum += nums[i];
            
            // 查找是否存在前缀和为prefixSum - k
            if (prefixSumMap.find(prefixSum - k) != prefixSumMap.end()) {
                maxLength = max(maxLength, i - prefixSumMap[prefixSum - k]);
            }
            
            // 只保存第一次出现的前缀和，以保证子数组最长
            if (prefixSumMap.find(prefixSum) == prefixSumMap.end()) {
                prefixSumMap[prefixSum] = i;
            }
        }
        
        return maxLength;
    }
};
```

## 分块算法的扩展应用

1. **莫队算法**：基于分块的离线查询优化算法
2. **块状链表**：将链表分块以提高随机访问性能
3. **块状数组**：用于处理大规模数据的动态数组
4. **二维分块**：用于二维区间查询和更新
5. **分块哈希**：用于字符串匹配等场景

## 总结

分块查找是一种重要的查找算法，它通过将数据分成多个块并建立索引，在保持一定查找效率的同时，也保持了较好的灵活性。它特别适用于处理大规模数据集和部分有序数据的场景。

在实际应用中，分块的思想不仅限于查找操作，还广泛应用于各种算法和数据结构中，如莫队算法、块状链表等。掌握分块思想对于解决复杂的算法问题具有重要意义。

===============================================

文件: README_8.md
===============================================
# 插值查找算法专题

## 算法原理

插值查找是二分查找的改进，它根据要查找的关键字与查找表中最大最小关键字的比较，动态确定下次查找点，而不是固定地取中间点。

### 核心思想
- 插值查找认为，当数据分布均匀时，可以根据查找值与区间端点的距离，预测查找值可能在数组中的位置
- 计算公式：`pos = low + ((key - arr[low]) * (high - low)) / (arr[high] - arr[low])`
- 对于均匀分布的数据，时间复杂度可以达到 O(log log n)
- 对于分布不均匀的数据，最坏情况仍为 O(n)

## 经典题目

### 1. 基本插值查找实现

**题目来源**：算法基础题

**题目描述**：在有序数组中查找指定值的位置

**解题思路**：
- 实现标准的插值查找算法
- 处理边界情况和特殊情况

**代码实现**：

**Java代码**：
```java
public class InterpolationSearch {
    // 插值查找算法实现
    public static int interpolationSearch(int[] arr, int key) {
        int low = 0;
        int high = arr.length - 1;
        
        while (low <= high && key >= arr[low] && key <= arr[high]) {
            // 如果low和high相等，避免除以零错误
            if (low == high) {
                if (arr[low] == key)
                    return low;
                return -1;
            }
            
            // 计算插值位置
            int pos = low + ((key - arr[low]) * (high - low)) / (arr[high] - arr[low]);
            
            // 检查找到的位置
            if (arr[pos] == key)
                return pos;
                
            if (arr[pos] < key)
                low = pos + 1;
            else
                high = pos - 1;
        }
        return -1; // 未找到
    }
    
    public static void main(String[] args) {
        int[] arr = {10, 12, 13, 16, 18, 19, 20, 21, 22, 23, 24, 33, 35, 42, 47};
        int key = 18;
        int result = interpolationSearch(arr, key);
        System.out.println("Element found at index: " + result);
    }
}
```

**Python代码**：
```python
def interpolation_search(arr, key):
    """插值查找算法实现"""
    low = 0
    high = len(arr) - 1
    
    while low <= high and key >= arr[low] and key <= arr[high]:
        # 如果low和high相等，避免除以零错误
        if low == high:
            if arr[low] == key:
                return low
            return -1
        
        # 计算插值位置
        pos = low + ((key - arr[low]) * (high - low)) // (arr[high] - arr[low])
        
        # 检查找到的位置
        if arr[pos] == key:
            return pos
            
        if arr[pos] < key:
            low = pos + 1
        else:
            high = pos - 1
    
    return -1  # 未找到

# 测试代码
if __name__ == "__main__":
    arr = [10, 12, 13, 16, 18, 19, 20, 21, 22, 23, 24, 33, 35, 42, 47]
    key = 18
    result = interpolation_search(arr, key)
    print(f"Element found at index: {result}")
```

**C++代码**：
```cpp
#include <iostream>
#include <vector>
using namespace std;

int interpolationSearch(vector<int>& arr, int key) {
    int low = 0;
    int high = arr.size() - 1;
    
    while (low <= high && key >= arr[low] && key <= arr[high]) {
        // 如果low和high相等，避免除以零错误
        if (low == high) {
            if (arr[low] == key)
                return low;
            return -1;
        }
        
        // 计算插值位置
        int pos = low + ((long long)(key - arr[low]) * (high - low)) / (arr[high] - arr[low]);
        
        // 检查找到的位置
        if (arr[pos] == key)
            return pos;
            
        if (arr[pos] < key)
            low = pos + 1;
        else
            high = pos - 1;
    }
    return -1; // 未找到
}

int main() {
    vector<int> arr = {10, 12, 13, 16, 18, 19, 20, 21, 22, 23, 24, 33, 35, 42, 47};
    int key = 18;
    int result = interpolationSearch(arr, key);
    cout << "Element found at index: " << result << endl;
    return 0;
}
```

### 2. 插值查找优化实现

**题目来源**：算法优化题

**题目描述**：优化插值查找算法，处理各种边界情况和特殊输入

**解题思路**：
- 添加边界检查
- 优化处理大数据范围
- 处理重复元素

**代码实现**：

**Java代码**：
```java
public class OptimizedInterpolationSearch {
    // 优化的插值查找算法
    public static int optimizedInterpolationSearch(int[] arr, int key) {
        // 边界检查
        if (arr == null || arr.length == 0) {
            return -1;
        }
        
        int low = 0;
        int high = arr.length - 1;
        
        // 快速检查边界
        if (key < arr[low] || key > arr[high]) {
            return -1;
        }
        
        while (low <= high && key >= arr[low] && key <= arr[high]) {
            // 处理小数情况
            if (arr[high] == arr[low]) {
                if (arr[low] == key) {
                    // 找到第一个出现的位置
                    while (low > 0 && arr[low - 1] == key) {
                        low--;
                    }
                    return low;
                }
                return -1;
            }
            
            // 使用long防止整数溢出
            long pos = low + (long)(key - arr[low]) * (high - low) / (arr[high] - arr[low]);
            
            // 确保pos在有效范围内
            if (pos < low) pos = low;
            if (pos > high) pos = high;
            
            int mid = (int)pos;
            
            if (arr[mid] == key) {
                // 找到第一个出现的位置
                while (mid > 0 && arr[mid - 1] == key) {
                    mid--;
                }
                return mid;
            }
                
            if (arr[mid] < key) {
                low = mid + 1;
            } else {
                high = mid - 1;
            }
        }
        
        // 检查最后一个可能的位置
        if (low < arr.length && arr[low] == key) {
            return low;
        }
        
        return -1;
    }
    
    public static void main(String[] args) {
        int[] arr = {5, 5, 5, 10, 15, 20, 25, 30};
        int key = 5;
        int result = optimizedInterpolationSearch(arr, key);
        System.out.println("First occurrence at index: " + result);
    }
}
```

**Python代码**：
```python
def optimized_interpolation_search(arr, key):
    """优化的插值查找算法"""
    # 边界检查
    if not arr:
        return -1
    
    low = 0
    high = len(arr) - 1
    
    # 快速检查边界
    if key < arr[low] or key > arr[high]:
        return -1
    
    while low <= high and key >= arr[low] and key <= arr[high]:
        # 处理小数情况
        if arr[high] == arr[low]:
            if arr[low] == key:
                # 找到第一个出现的位置
                while low > 0 and arr[low - 1] == key:
                    low -= 1
                return low
            return -1
        
        # 计算插值位置
        pos = low + (key - arr[low]) * (high - low) // (arr[high] - arr[low])
        
        # 确保pos在有效范围内
        pos = max(low, min(pos, high))
        
        if arr[pos] == key:
            # 找到第一个出现的位置
            while pos > 0 and arr[pos - 1] == key:
                pos -= 1
            return pos
                
        if arr[pos] < key:
            low = pos + 1
        else:
            high = pos - 1
    
    # 检查最后一个可能的位置
    if low < len(arr) and arr[low] == key:
        return low
    
    return -1

# 测试代码
if __name__ == "__main__":
    arr = [5, 5, 5, 10, 15, 20, 25, 30]
    key = 5
    result = optimized_interpolation_search(arr, key)
    print(f"First occurrence at index: {result}")
```

**C++代码**：
```cpp
#include <iostream>
#include <vector>
using namespace std;

int optimizedInterpolationSearch(vector<int>& arr, int key) {
    // 边界检查
    if (arr.empty()) {
        return -1;
    }
    
    int low = 0;
    int high = arr.size() - 1;
    
    // 快速检查边界
    if (key < arr[low] || key > arr[high]) {
        return -1;
    }
    
    while (low <= high && key >= arr[low] && key <= arr[high]) {
        // 处理小数情况
        if (arr[high] == arr[low]) {
            if (arr[low] == key) {
                // 找到第一个出现的位置
                while (low > 0 && arr[low - 1] == key) {
                    low--;
                }
                return low;
            }
            return -1;
        }
        
        // 使用long防止整数溢出
        long long pos = low + (long long)(key - arr[low]) * (high - low) / (arr[high] - arr[low]);
        
        // 确保pos在有效范围内
        if (pos < low) pos = low;
        if (pos > high) pos = high;
        
        int mid = (int)pos;
        
        if (arr[mid] == key) {
            // 找到第一个出现的位置
            while (mid > 0 && arr[mid - 1] == key) {
                mid--;
            }
            return mid;
        }
            
        if (arr[mid] < key) {
            low = mid + 1;
        } else {
            high = mid - 1;
        }
    }
    
    // 检查最后一个可能的位置
    if (low < (int)arr.size() && arr[low] == key) {
        return low;
    }
    
    return -1;
}

int main() {
    vector<int> arr = {5, 5, 5, 10, 15, 20, 25, 30};
    int key = 5;
    int result = optimizedInterpolationSearch(arr, key);
    cout << "First occurrence at index: " << result << endl;
    return 0;
}
```

## 更多练习题目

### 3. LeetCode 704. 二分查找（可应用插值查找）

**题目链接**：https://leetcode.com/problems/binary-search/

**题目描述**：给定一个n个元素有序的（升序）整型数组nums和一个目标值target，写一个函数搜索nums中的target，如果目标值存在返回下标，否则返回-1。

**解题思路**：虽然题目要求二分查找，但可以用插值查找优化

**Java代码**：
```java
class Solution {
    public int search(int[] nums, int target) {
        return interpolationSearch(nums, target);
    }
    
    private int interpolationSearch(int[] arr, int key) {
        int low = 0;
        int high = arr.length - 1;
        
        while (low <= high && key >= arr[low] && key <= arr[high]) {
            if (low == high) {
                if (arr[low] == key)
                    return low;
                return -1;
            }
            
            int pos = low + ((key - arr[low]) * (high - low)) / (arr[high] - arr[low]);
            
            if (arr[pos] == key)
                return pos;
                
            if (arr[pos] < key)
                low = pos + 1;
            else
                high = pos - 1;
        }
        return -1;
    }
}
```

**Python代码**：
```python
class Solution:
    def search(self, nums: List[int], target: int) -> int:
        low = 0
        high = len(nums) - 1
        
        while low <= high and target >= nums[low] and target <= nums[high]:
            if low == high:
                if nums[low] == target:
                    return low
                return -1
            
            pos = low + ((target - nums[low]) * (high - low)) // (nums[high] - nums[low])
            
            if nums[pos] == target:
                return pos
                
            if nums[pos] < target:
                low = pos + 1
            else:
                high = pos - 1
        
        return -1
```

**C++代码**：
```cpp
class Solution {
public:
    int search(vector<int>& nums, int target) {
        int low = 0;
        int high = nums.size() - 1;
        
        while (low <= high && target >= nums[low] && target <= nums[high]) {
            if (low == high) {
                if (nums[low] == target)
                    return low;
                return -1;
            }
            
            int pos = low + ((long long)(target - nums[low]) * (high - low)) / (nums[high] - nums[low]);
            
            if (nums[pos] == target)
                return pos;
                
            if (nums[pos] < target)
                low = pos + 1;
            else
                high = pos - 1;
        }
        return -1;
    }
};
```

### 4. LeetCode 35. 搜索插入位置

**题目链接**：https://leetcode.com/problems/search-insert-position/

**题目描述**：给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。

**解题思路**：使用插值查找找到目标值或插入位置

**Java代码**：
```java
class Solution {
    public int searchInsert(int[] nums, int target) {
        int low = 0;
        int high = nums.length - 1;
        
        // 边界情况处理
        if (high < 0) return 0;
        if (target <= nums[low]) return low;
        if (target > nums[high]) return high + 1;
        
        while (low <= high) {
            // 插值计算
            if (nums[high] == nums[low]) {
                return low;
            }
            
            int pos = low + ((target - nums[low]) * (high - low)) / (nums[high] - nums[low]);
            
            // 确保pos在有效范围内
            pos = Math.max(low, Math.min(pos, high));
            
            if (nums[pos] == target) {
                return pos;
            } else if (nums[pos] < target) {
                low = pos + 1;
            } else {
                high = pos - 1;
            }
        }
        
        // 返回插入位置
        return low;
    }
}
```

**Python代码**：
```python
class Solution:
    def searchInsert(self, nums: List[int], target: int) -> int:
        low = 0
        high = len(nums) - 1
        
        # 边界情况处理
        if high < 0: return 0
        if target <= nums[low]: return low
        if target > nums[high]: return high + 1
        
        while low <= high:
            # 插值计算
            if nums[high] == nums[low]:
                return low
            
            pos = low + ((target - nums[low]) * (high - low)) // (nums[high] - nums[low])
            
            # 确保pos在有效范围内
            pos = max(low, min(pos, high))
            
            if nums[pos] == target:
                return pos
            elif nums[pos] < target:
                low = pos + 1
            else:
                high = pos - 1
        
        # 返回插入位置
        return low
```

**C++代码**：
```cpp
class Solution {
public:
    int searchInsert(vector<int>& nums, int target) {
        int low = 0;
        int high = nums.size() - 1;
        
        // 边界情况处理
        if (high < 0) return 0;
        if (target <= nums[low]) return low;
        if (target > nums[high]) return high + 1;
        
        while (low <= high) {
            // 插值计算
            if (nums[high] == nums[low]) {
                return low;
            }
            
            long long pos = low + (long long)(target - nums[low]) * (high - low) / (nums[high] - nums[low]);
            
            // 确保pos在有效范围内
            if (pos < low) pos = low;
            if (pos > high) pos = high;
            
            int mid = (int)pos;
            
            if (nums[mid] == target) {
                return mid;
            } else if (nums[mid] < target) {
                low = mid + 1;
            } else {
                high = mid - 1;
            }
        }
        
        // 返回插入位置
        return low;
    }
};
```

### 5. LeetCode 153. 寻找旋转排序数组中的最小值

**题目链接**：https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/

**题目描述**：假设按照升序排序的数组在预先未知的某个点上进行了旋转。请找出其中最小的元素。

**解题思路**：结合插值查找的思想，根据数组特性进行优化搜索

**Java代码**：
```java
class Solution {
    public int findMin(int[] nums) {
        int left = 0;
        int right = nums.length - 1;
        
        // 如果数组没有旋转或只有一个元素
        if (nums[right] >= nums[left]) {
            return nums[left];
        }
        
        while (left < right) {
            // 计算中间位置，这里使用插值思想优化
            // 根据左右端点的值差异，预测最小值的位置
            int mid;
            if (nums[right] - nums[left] > 0) {
                // 正常排序区间
                mid = left;
            } else {
                // 旋转区间，使用插值计算
                mid = left + (right - left) / 2;
            }
            
            if (nums[mid] > nums[right]) {
                // 最小值在右侧
                left = mid + 1;
            } else {
                // 最小值在左侧或当前位置
                right = mid;
            }
        }
        
        return nums[left];
    }
}
```

**Python代码**：
```python
class Solution:
    def findMin(self, nums: List[int]) -> int:
        left = 0
        right = len(nums) - 1
        
        # 如果数组没有旋转或只有一个元素
        if nums[right] >= nums[left]:
            return nums[left]
        
        while left < right:
            # 计算中间位置，这里使用插值思想优化
            if nums[right] - nums[left] > 0:
                # 正常排序区间
                mid = left
            else:
                # 旋转区间，使用插值计算
                mid = left + (right - left) // 2
            
            if nums[mid] > nums[right]:
                # 最小值在右侧
                left = mid + 1
            else:
                # 最小值在左侧或当前位置
                right = mid
        
        return nums[left]
```

**C++代码**：
```cpp
class Solution {
public:
    int findMin(vector<int>& nums) {
        int left = 0;
        int right = nums.size() - 1;
        
        // 如果数组没有旋转或只有一个元素
        if (nums[right] >= nums[left]) {
            return nums[left];
        }
        
        while (left < right) {
            // 计算中间位置，这里使用插值思想优化
            int mid;
            if (nums[right] - nums[left] > 0) {
                // 正常排序区间
                mid = left;
            } else {
                // 旋转区间，使用插值计算
                mid = left + (right - left) / 2;
            }
            
            if (nums[mid] > nums[right]) {
                // 最小值在右侧
                left = mid + 1;
            } else {
                // 最小值在左侧或当前位置
                right = mid;
            }
        }
        
        return nums[left];
    }
};
```

## 插值查找的优缺点分析

### 优点
1. **对于均匀分布的数据效率高**：在数据均匀分布的情况下，插值查找的时间复杂度接近O(log log n)，比二分查找的O(log n)更快
2. **自适应性强**：根据查找值与区间端点的关系动态调整查找位置
3. **实现简单**：只需要在二分查找的基础上修改中间位置的计算方式

### 缺点
1. **对于分布不均匀的数据性能下降**：最坏情况下时间复杂度退化为O(n)
2. **需要额外的边界检查**：为避免除以零等异常情况，需要增加更多的边界条件判断
3. **不适用于非数值型数据**：插值公式依赖于数值计算，不适合字符串等非数值类型

## 应用场景

1. **数据库索引查找**：当数据分布均匀时，可以提高查询效率
2. **数值型数组快速查找**：适用于数据分布相对均匀的数值数组
3. **近似值查找**：可以快速定位接近目标值的位置
4. **优化的二分查找场景**：在二分查找的基础上进一步优化性能

## 算法优化建议

1. **混合策略**：在数据范围较大时先用插值查找快速缩小范围，接近目标时切换到二分查找
2. **自适应块大小**：根据数据分布特性动态调整查找策略
3. **预处理数据分布**：对于已知分布的数据，可以预先计算查找函数
4. **并行化处理**：对于超大数据集，可以结合并行计算进行优化

通过以上题目和优化方法，希望能帮助你更深入地理解和应用插值查找算法。

===============================================

文件: README_9.md
===============================================
# 树链剖分（Heavy-Light Decomposition）

## 概述

树链剖分是一种高效的树路径处理算法，通过将树分解为若干条重链，结合线段树等数据结构，实现对树上路径的高效查询和更新操作。

## 核心算法

### 算法思想
1. **第一次DFS**：计算每个节点的子树大小，确定重儿子
2. **第二次DFS**：建立重链，分配DFS序
3. **线段树维护**：使用线段树维护每条链上的信息

### 时间复杂度
- **预处理**：O(n)
- **路径操作**：O(log²n)
- **子树操作**：O(log n)
- **空间复杂度**：O(n)

## 题目集合

### 基础模板题
1. **洛谷 P3384** - 【模板】轻重链剖分
   - 路径更新、路径查询、子树更新、子树查询
   - [题目链接](https://www.luogu.com.cn/problem/P3384)

### 经典题目
2. **SPOJ QTREE** - Query on a tree
   - 边权查询和更新
   - [题目链接](https://www.spoj.com/problems/QTREE/)

3. **SPOJ QTREE2** - Query on a tree II
   - 路径距离查询、路径第k个节点查询
   - [题目链接](https://www.spoj.com/problems/QTREE2/)

4. **HDU 3966** - Aragorn's Story
   - 路径增量更新、单点查询
   - [题目链接](http://acm.hdu.edu.cn/showproblem.php?pid=3966)

5. **POJ 3237** - Tree
   - 边权修改、路径取反、路径最大值查询
   - [题目链接](http://poj.org/problem?id=3237)

6. **Codeforces 343D** - Water Tree
   - 节点填水、子树清空、节点查询
   - [题目链接](https://codeforces.com/problemset/problem/343/D)

## 文件结构

```
树链剖分/
├── HeavyLightDecomposition.java          # 基础树链剖分实现
├── heavy_light_decomposition.cpp         # C++版本实现
├── heavy_light_decomposition.py          # Python版本实现
├── Luogu_P3384_树链剖分模板.java         # 洛谷模板题
├── SPOJ_QTREE_QueryOnTree.java           # SPOJ QTREE
├── SPOJ_QTREE2_QueryOnTree2.java         # SPOJ QTREE2
├── HDU_3966_AragornsStory.java           # HDU 3966
├── POJ_3237_Tree.java                    # POJ 3237
├── Codeforces_343D_WaterTree.java         # Codeforces 343D
├── 算法复杂度分析.md                      # 复杂度分析文档
├── 算法思路总结.md                        # 算法思路总结
├── 工程化实践指南.md                      # 工程实践指南
└── README.md                             # 项目说明
```

## 使用说明

### 编译运行

#### Java版本
```bash
javac *.java
java 主类名 < 输入文件
```

#### C++版本
```bash
g++ -std=c++11 -O2 heavy_light_decomposition.cpp -o hld
./hld < 输入文件
```

#### Python版本
```bash
python heavy_light_decomposition.py < 输入文件
```

### 输入格式

不同题目的输入格式略有不同，具体参考各个题目的实现文件中的注释说明。

## 算法特点

### 优点
1. **高效**：路径操作时间复杂度为O(log²n)
2. **通用**：支持多种路径和子树操作
3. **稳定**：预处理后操作稳定可靠

### 缺点
1. **代码复杂**：实现相对复杂
2. **常数较大**：实际运行常数较大
3. **不支持动态树**：树结构需要静态

## 学习建议

### 学习路径
1. **理解原理**：先理解树链剖分的核心思想
2. **掌握实现**：学习基础实现代码
3. **练习题目**：从简单题目开始练习
4. **优化技巧**：学习性能优化方法

### 练习顺序
1. 洛谷 P3384（模板题）
2. HDU 3966（路径更新）
3. SPOJ QTREE（边权操作）
4. POJ 3237（复杂操作）
5. Codeforces 343D（特殊操作）

## 扩展阅读

### 相关算法
- **倍增LCA**：快速求最近公共祖先
- **欧拉序+RMQ**：O(1)查询LCA
- **树分治**：解决树上的分治问题
- **Link-Cut Tree**：支持动态树的树链剖分

### 进阶题目
- **BZOJ 1036** - 树的统计
- **ZOJ 2114** - Transport
- **UVa 12424** - Answering Queries on a Tree

## 贡献指南

欢迎提交新的题目实现、优化建议或文档改进。

## 许可证

本项目采用MIT许可证，详见LICENSE文件。

---

**注意**：所有代码都经过详细注释和测试，确保正确性和可读性。建议在学习过程中仔细阅读注释，理解算法实现的每一个细节。

===============================================

文件: README_COMPREHENSIVE.md
===============================================
# 分块算法 (Sqrt Decomposition) 完整指南

## 概述

分块算法是一种重要的算法技巧，通过将数据结构分成若干块来平衡时间复杂度，常用于处理区间查询和更新操作。它的时间复杂度通常为O(√n)或O(n√n)，是一种非常实用的算法优化技术。

## 题目分类与解法总结

### 1. 标准分块算法

#### 适用场景
- 区间更新和查询操作
- 需要平衡预处理时间和查询时间的场景
- 数据规模较大，需要优化暴力算法的场景

#### 经典题目
1. **哈希冲突 (Code01_HashCollision)**
   - 题目链接: https://www.luogu.com.cn/problem/P3396
   - 解法: 对于x <= √n的情况预处理，对于x > √n的情况暴力查询

2. **数组查询 (Code02_ArrayQueries)**
   - 题目链接: https://www.luogu.com.cn/problem/CF797E
   - 解法: 对于k <= √n的情况预处理dp，对于k > √n的情况暴力计算

3. **初始化 (Code04_Initialization)**
   - 题目链接: https://www.luogu.com.cn/problem/P5309
   - 解法: 分块维护区间和

4. **雅加达的摩天楼 (Code05_Skyscraper)**
   - 题目链接: https://www.luogu.com.cn/problem/P3645
   - 解法: 分块优化BFS

5. **Serega and Fun (Code08_SeregaAndFun)**
   - 题目链接: https://codeforces.com/problemset/problem/455/D
   - 解法: 分块维护，定期重构

6. **Curious Robin Hood**
   - 题目链接: http://lightoj.com/volume_showproblem.php?problem=1112
   - 解法: 分块维护区间和

7. **Range Sum Query - Mutable**
   - 题目链接: https://leetcode.com/problems/range-sum-query-mutable/
   - 解法: 分块维护区间和

#### 设计要点
- 块大小通常选择√n，以平衡预处理和查询时间
- 每个块维护额外信息以加速查询
- 对于不完整块需要特殊处理

### 2. Mo算法（离线分块）

#### 适用场景
- 离线处理区间查询问题
- 查询之间可以重新排序以优化处理顺序
- 需要维护区间信息的场景

#### 经典题目
1. **Little Elephant and Array (Code09_LittleElephantAndArray)**
   - 题目链接: https://codeforces.com/problemset/problem/220/B
   - 解法: Mo算法（离线分块）

2. **D-query (Code10_DQuery)**
   - 题目链接: https://www.spoj.com/problems/DQUERY/
   - 解法: Mo算法（离线分块）

3. **Powerful array (Code11_PowerfulArray)**
   - 题目链接: https://codeforces.com/problemset/problem/86/D
   - 解法: Mo算法（离线分块）

4. **XOR and Favorite Number (Code15_XorAndFavoriteNumber)**
   - 题目链接: https://codeforces.com/problemset/problem/617/E
   - 解法: Mo算法（离线分块）+ 异或前缀和

5. **Tree and Queries (Code17_TreeAndQueries)**
   - 题目链接: https://codeforces.com/problemset/problem/375/D
   - 解法: 树上Mo算法（离线分块）+ 欧拉序

#### 设计要点
- 将查询按照特定规则排序以最小化指针移动次数
- 维护当前窗口的信息，支持快速添加和删除元素
- 时间复杂度为O((n+m)√n)，其中n为数组长度，m为查询数量

### 3. 分块重构

#### 适用场景
- 需要动态维护数据结构的场景
- 修改操作较频繁，需要定期重构以保持效率
- 需要平衡修改和查询时间的场景

#### 经典题目
1. **Serega and Fun (Code08_SeregaAndFun)**
   - 题目链接: https://codeforces.com/problemset/problem/455/D
   - 解法: 分块维护，定期重构

#### 设计要点
- 设置重构阈值，当修改次数达到阈值时进行重构
- 重构时重新计算所有块的信息
- 平衡重构开销和查询效率

### 4. 分块+DP

#### 适用场景
- 需要预处理信息以加速查询的场景
- 动态规划问题中需要优化状态转移的场景
- 复杂的区间查询问题

#### 经典题目
1. **等差数列求和 (Code03_SumOfProgression)**
   - 题目链接: https://www.luogu.com.cn/problem/CF1921F
   - 解法: 预处理前缀和与加权前缀和

2. **给你一棵树 (Code07_GivenTree)**
   - 题目链接: https://www.luogu.com.cn/problem/CF1039D
   - 解法: 分块优化动态规划

#### 设计要点
- 预处理块内信息以加速查询
- 结合动态规划思想优化状态转移
- 平衡预处理时间和查询时间

### 5. 树上分块

#### 适用场景
- 树上查询问题
- 需要处理子树信息的场景
- 结合欧拉序的树上问题

#### 经典题目
1. **Tree and Queries (Code17_TreeAndQueries)**
   - 题目链接: https://codeforces.com/problemset/problem/375/D
   - 解法: 树上Mo算法（离线分块）+ 欧拉序

#### 设计要点
- 利用欧拉序将树上问题转换为区间问题
- 结合Mo算法处理离线查询
- 注意处理树上路径的特殊性质

## 时间复杂度分析

大多数分块算法的时间复杂度为O(√n)或O(n√n)，具体取决于问题类型：
- 区间查询：O(√n)
- 区间更新：O(√n)
- 单点更新：O(1)或O(√n)
- Mo算法：O((n+m)√n)，其中n为数组长度，m为查询数量

## 空间复杂度分析

分块算法的空间复杂度通常为O(n)，需要额外存储块信息和预处理数据。

## 工程化考量

### 1. 异常处理
- 处理空输入和边界情况
- 验证输入数据的有效性
- 处理大数据规模的内存使用

### 2. 性能优化
- 选择合适的块大小
- 优化数据结构以减少常数因子
- 使用位运算等技巧加速计算

### 3. 可维护性
- 代码结构清晰，注释详细
- 模块化设计，便于扩展
- 提供完整的测试用例

## 面试与笔试要点

### 1. 笔试核心
- 提前打磨代码模板，实现"秒写"基础逻辑
- 模板需极简且无冗余，覆盖边界处理
- 输入输出效率优化，避免超时

### 2. 面试核心
- 拆解题干核心需求，提取输入输出约束
- 主动分享踩坑经验，体现实战成长
- 优化代码，能否写得更简洁
- 讲清理论与实际的差距，体现性能敏感度

## 学习建议

### 1. 理论学习
- 理解分块算法的核心思想
- 掌握不同变种的实现方法
- 学习经典题目的解法

### 2. 实践练习
- 从简单题目开始练习
- 逐步提高题目难度
- 总结解题经验和技巧

### 3. 进阶提升
- 学习分块与其他算法的结合
- 研究实际应用场景
- 探索算法优化技巧

## 常见问题解答

### 1. 为什么块大小选择√n？
选择√n是为了平衡预处理时间和查询时间。如果块太大，预处理时间会增加；如果块太小，查询时间会增加。√n是一个理论上的最优选择。

### 2. 分块算法与线段树有什么区别？
分块算法实现相对简单，适用范围更广，但时间复杂度略差于线段树。线段树时间复杂度更优，但实现复杂，且有些问题难以用线段树解决。

### 3. 什么时候使用Mo算法？
当需要处理多个区间查询，且查询可以离线处理时，可以考虑使用Mo算法。它通过巧妙的排序策略最小化指针移动次数。

### 4. 如何处理修改操作？
对于有修改操作的问题，可以使用分块重构技术，定期重新计算块的信息，或者使用带修莫队算法。

## 总结

分块算法是一种非常实用的算法技巧，在处理大规模数据的区间查询和更新问题时具有显著优势。掌握分块算法的关键在于理解其核心思想：通过合理的数据分块来平衡预处理时间和查询时间，从而在整体上优化算法性能。在实际应用中，需要根据具体问题选择合适的分块策略和优化技巧。

分块算法的优势在于其实现相对简单，适用范围广泛，而且在很多情况下能够提供足够好的性能。对于一些复杂的区间操作问题，分块算法往往能够提供一个简洁而有效的解决方案。通过不断练习和总结，可以更好地掌握这一重要的算法技巧。

===============================================

文件: SUMMARY.md
===============================================
# 压缩算法文件夹重组总结

## 重组目的

根据算法与数据结构的分类原则，将原先混合存放的压缩算法实现代码按照不同的压缩算法进行分类组织，提高代码的可维护性和可读性。

## 重组前结构

原先所有压缩算法实现在同一目录下：
```
compression/
├── ArithmeticCoding.java       # 算术编码 Java实现
├── arithmetic_coding.py        # 算术编码 Python实现
├── arithmetic_coding.cpp       # 算术编码 C++实现
├── LZWEncoding.java            # LZW编码 Java实现
├── lzw_encoding.py             # LZW编码 Python实现
├── lzw_encoding.cpp            # LZW编码 C++实现
├── HuffmanEncoding.java        # Huffman编码 Java实现
├── huffman_encoding.py         # Huffman编码 Python实现
├── huffman_encoding.cpp        # Huffman编码 C++实现
└── README.md                   # 说明文档
```

## 重组后结构

按照算法类型分类存放：
```
compression/
├── arithmetic_coding/          # 算术编码算法实现
│   ├── ArithmeticCoding.java   # Java实现
│   ├── arithmetic_coding.py    # Python实现
│   ├── arithmetic_coding.cpp   # C++实现
│   ├── arithmetic_coding.o     # C++编译文件
│   └── README.md               # 算术编码说明
├── huffman_encoding/           # Huffman编码算法实现
│   ├── HuffmanEncoding.java    # Java实现
│   ├── huffman_encoding.py     # Python实现
│   ├── huffman_encoding.cpp    # C++实现
│   ├── huffman_encoding.o      # C++编译文件
│   └── README.md               # Huffman编码说明
├── lzw_encoding/               # LZW编码算法实现
│   ├── LZWEncoding.java        # Java实现
│   ├── lzw_encoding.py         # Python实现
│   ├── lzw_encoding.cpp        # C++实现
│   ├── lzw_encoding.o          # C++编译文件
│   └── README.md               # LZW编码说明
├── test_compression.py         # 原有测试脚本（已更新）
├── test_all.py                 # 新增综合测试脚本
└── README.md                   # 主说明文档
```

## 重组内容

### 1. 文件移动
- 将算术编码相关文件移至 `arithmetic_coding/` 目录
- 将Huffman编码相关文件移至 `huffman_encoding/` 目录
- 将LZW编码相关文件移至 `lzw_encoding/` 目录

### 2. 文档更新
- 为每个算法子目录创建专门的README.md说明文件
- 更新主README.md中的目录结构说明
- 创建SUMMARY.md总结文件

### 3. 测试脚本
- 更新原有的 `test_compression.py` 脚本以适应新的目录结构
- 创建新的 `test_all.py` 综合测试脚本

## 优势

1. **结构清晰**：按算法类型分类，便于查找和维护
2. **易于扩展**：新增算法实现只需在对应目录添加文件
3. **独立性强**：每个算法目录相对独立，减少耦合
4. **文档完善**：每个算法都有专门的说明文档

## 验证

所有算法实现文件均已正确移动，测试脚本已更新并可正常运行，文档已更新以反映新的组织结构。

===============================================

文件: 工程化实践指南.md
===============================================
# 树链剖分工程化实践指南

## 一、代码架构设计

### 1. 模块化设计
```java
// 树链剖分核心类
class HeavyLightDecomposition {
    // 预处理阶段
    void dfs1(int u, int p);
    void dfs2(int u, int h);
    
    // 路径操作
    void updatePath(int u, int v, int val);
    int queryPath(int u, int v);
    
    // 子树操作
    void updateSubtree(int u, int val);
    int querySubtree(int u);
}

// 线段树类
class SegmentTree {
    void build(int l, int r);
    void update(int l, int r, int val);
    int query(int l, int r);
}
```

### 2. 接口设计原则
- **单一职责**：每个类只负责一个功能
- **开闭原则**：对扩展开放，对修改关闭
- **依赖倒置**：依赖抽象而非具体实现

## 二、异常处理机制

### 1. 输入验证
```java
// 验证节点编号有效性
private void validateNode(int u) {
    if (u < 1 || u > n) {
        throw new IllegalArgumentException("Invalid node id: " + u);
    }
}

// 验证边权范围
private void validateWeight(int w) {
    if (w < MIN_WEIGHT || w > MAX_WEIGHT) {
        throw new IllegalArgumentException("Weight out of range: " + w);
    }
}
```

### 2. 边界情况处理
```java
// 处理空树
if (n == 0) {
    return 0; // 或抛出异常
}

// 处理单节点树
if (n == 1) {
    return w[1]; // 直接返回根节点权值
}

// 处理自环（u == v）
if (u == v) {
    return queryPoint(u); // 直接查询单点
}
```

## 三、性能优化策略

### 1. 内存优化
```java
// 使用基本类型数组而非对象数组
int[] parent = new int[n + 1]; // 优于 Integer[]

// 避免不必要的对象创建
// 错误做法：频繁创建新对象
for (int i = 0; i < n; i++) {
    List<Integer> list = new ArrayList<>(); // 每次循环创建新对象
}

// 正确做法：复用对象
List<Integer> list = new ArrayList<>();
for (int i = 0; i < n; i++) {
    list.clear(); // 清空后复用
}
```

### 2. 算法优化
```java
// 使用位运算替代除法
int mid = (l + r) >> 1; // 优于 (l + r) / 2

// 使用System.arraycopy进行数组复制
System.arraycopy(src, 0, dest, 0, length); // 优于循环复制

// 避免在循环中调用方法
// 错误做法
for (int i = 0; i < list.size(); i++) { // 每次循环调用size()
    // ...
}

// 正确做法
int size = list.size();
for (int i = 0; i < size; i++) {
    // ...
}
```

## 四、测试策略

### 1. 单元测试
```java
@Test
public void testHLDWithChainTree() {
    // 测试链状树
    int n = 1000;
    Tree tree = createChainTree(n);
    HeavyLightDecomposition hld = new HeavyLightDecomposition(tree);
    
    // 验证路径查询
    assertEquals(expected, hld.queryPath(1, n));
    
    // 验证路径更新
    hld.updatePath(1, n, 10);
    assertEquals(expected + 10 * (n - 1), hld.queryPath(1, n));
}

@Test
public void testHLDWithStarTree() {
    // 测试菊花图
    int n = 1000;
    Tree tree = createStarTree(n);
    HeavyLightDecomposition hld = new HeavyLightDecomposition(tree);
    
    // 验证子树操作
    hld.updateSubtree(1, 5);
    assertEquals(5 * (n - 1), hld.querySubtree(1));
}
```

### 2. 压力测试
```java
@Test(timeout = 1000) // 1秒超时
public void stressTestLargeInput() {
    int n = 100000;
    Tree tree = generateRandomTree(n);
    HeavyLightDecomposition hld = new HeavyLightDecomposition(tree);
    
    // 执行大量操作
    for (int i = 0; i < 100000; i++) {
        int u = random.nextInt(n) + 1;
        int v = random.nextInt(n) + 1;
        hld.queryPath(u, v);
    }
}
```

## 五、调试与日志

### 1. 调试输出
```java
// 条件编译的调试输出
private static final boolean DEBUG = false;

private void debug(String message) {
    if (DEBUG) {
        System.err.println("[DEBUG] " + message);
    }
}

// 在关键步骤添加调试信息
debug("Processing path from " + u + " to " + v);
debug("Current head: " + head[u] + ", depth: " + depth[u]);
```

### 2. 性能监控
```java
// 记录操作时间
long startTime = System.nanoTime();
// 执行操作
long endTime = System.nanoTime();
long duration = endTime - startTime;

if (duration > WARNING_THRESHOLD) {
    logger.warn("Slow operation: " + duration + " ns");
}
```

## 六、代码规范

### 1. 命名规范
```java
// 类名：大驼峰
class HeavyLightDecomposition

// 方法名：小驼峰
void dfsFirstPass(int u, int parent)

// 常量：全大写
static final int MAX_NODES = 100000;

// 变量：有意义的名称
int[] subtreeSize; // 优于 int[] sz;
```

### 2. 注释规范
```java
/**
 * 执行第一次DFS遍历
 * 
 * @param u 当前节点
 * @param p 父节点
 * @throws IllegalArgumentException 如果节点编号无效
 */
private void dfs1(int u, int p) {
    // 验证输入参数
    validateNode(u);
    validateNode(p);
    
    // 设置父节点和深度
    parent[u] = p;
    depth[u] = depth[p] + 1;
    
    // 计算子树大小并找到重儿子
    // ...
}
```

## 七、配置化设计

### 1. 可配置参数
```java
public class HLDConfig {
    // 最大节点数
    public static int MAX_NODES = 100000;
    
    // 是否启用懒标记优化
    public static boolean ENABLE_LAZY_PROPAGATION = true;
    
    // 线段树实现方式
    public static SegmentTreeType SEGMENT_TREE_TYPE = SegmentTreeType.ARRAY_BASED;
}
```

### 2. 环境适配
```java
// 根据运行环境调整参数
if (isProductionEnvironment()) {
    HLDConfig.MAX_NODES = 1000000;
    HLDConfig.ENABLE_LAZY_PROPAGATION = true;
} else {
    HLDConfig.MAX_NODES = 10000; // 开发环境使用较小规模
}
```

## 八、错误处理与恢复

### 1. 优雅降级
```java
public int safeQueryPath(int u, int v) {
    try {
        return queryPath(u, v);
    } catch (Exception e) {
        logger.error("Query path failed", e);
        // 返回默认值或使用备用算法
        return fallbackQuery(u, v);
    }
}
```

### 2. 资源清理
```java
public void cleanup() {
    // 释放数组引用
    parent = null;
    depth = null;
    // ... 其他资源清理
    
    System.gc(); // 建议垃圾回收
}
```

## 九、性能监控指标

### 1. 关键指标
- **预处理时间**：衡量算法初始化效率
- **单次操作时间**：衡量算法运行效率
- **内存使用量**：衡量空间效率
- **缓存命中率**：衡量内存访问效率

### 2. 监控实现
```java
public class HLDMetrics {
    private long preprocessTime;
    private long totalOperations;
    private long totalTime;
    
    public void recordOperation(long duration) {
        totalOperations++;
        totalTime += duration;
    }
    
    public double getAverageOperationTime() {
        return totalOperations == 0 ? 0 : (double) totalTime / totalOperations;
    }
}
```

## 十、部署与维护

### 1. 版本管理
- 使用Git进行版本控制
- 为每个重要功能创建分支
- 使用语义化版本号

### 2. 文档维护
- 维护API文档
- 记录算法变更
- 提供使用示例

### 3. 持续集成
- 自动化测试
- 代码质量检查
- 性能基准测试

通过以上工程化实践，可以确保树链剖分算法在实际项目中的稳定性、可维护性和高性能。

===============================================

文件: 异常处理与性能优化.md
===============================================
# 树链剖分异常处理与性能优化

## 一、异常处理机制

### 1. 输入验证异常

#### 节点编号验证
```java
/**
 * 验证节点编号是否有效
 * @param u 节点编号
 * @throws IllegalArgumentException 如果节点编号无效
 */
private void validateNode(int u) {
    if (u < 1 || u > n) {
        throw new IllegalArgumentException(
            String.format("Invalid node id: %d, valid range: [1, %d]", u, n)
        );
    }
}

/**
 * 验证边权范围
 * @param w 边权值
 * @throws IllegalArgumentException 如果边权超出范围
 */
private void validateWeight(int w) {
    if (w < MIN_WEIGHT || w > MAX_WEIGHT) {
        throw new IllegalArgumentException(
            String.format("Weight %d out of range [%d, %d]", w, MIN_WEIGHT, MAX_WEIGHT)
        );
    }
}
```

#### 操作参数验证
```java
/**
 * 验证路径操作参数
 */
private void validatePathOperation(int u, int v, int val) {
    validateNode(u);
    validateNode(v);
    
    if (u == v) {
        logger.warn("Path operation on same node: {} -> {}", u, v);
    }
    
    // 验证操作值范围
    if (val < MIN_OPERATION_VALUE || val > MAX_OPERATION_VALUE) {
        throw new IllegalArgumentException("Operation value out of range");
    }
}
```

### 2. 边界情况处理

#### 空树处理
```java
public void initialize(Tree tree) {
    if (tree == null || tree.isEmpty()) {
        logger.warn("Initializing HLD with empty tree");
        this.n = 0;
        return;
    }
    
    this.n = tree.getNodeCount();
    if (n == 0) {
        logger.warn("Tree contains 0 nodes");
        return;
    }
    
    // 正常初始化流程
    initArrays();
    dfs1(tree.getRoot(), 0);
    dfs2(tree.getRoot(), tree.getRoot());
    buildSegmentTree();
}
```

#### 单节点树处理
```java
public int queryPath(int u, int v) {
    if (n == 0) {
        throw new IllegalStateException("HLD not initialized or tree is empty");
    }
    
    if (n == 1) {
        // 单节点树，直接返回根节点值
        validateNode(u);
        validateNode(v);
        if (u != 1 || v != 1) {
            throw new IllegalArgumentException("Invalid nodes for single-node tree");
        }
        return queryPoint(1);
    }
    
    // 正常路径查询逻辑
    return doQueryPath(u, v);
}
```

### 3. 内存异常处理

#### 数组越界防护
```java
/**
 * 安全的数组访问
 */
private int safeArrayAccess(int[] arr, int index, String arrayName) {
    if (index < 0 || index >= arr.length) {
        throw new ArrayIndexOutOfBoundsException(
            String.format("Index %d out of bounds for %s (length: %d)", 
                index, arrayName, arr.length)
        );
    }
    return arr[index];
}

/**
 * 安全的线段树区间验证
 */
private void validateSegmentTreeRange(int l, int r, int segL, int segR) {
    if (l < segL || r > segR || l > r) {
        throw new IllegalArgumentException(
            String.format("Invalid segment tree range [%d, %d] for segment [%d, %d]", 
                l, r, segL, segR)
        );
    }
}
```

## 二、性能优化策略

### 1. 内存优化

#### 数组布局优化
```java
// 优化前：分散的数组声明
int[] parent = new int[n + 1];
int[] depth = new int[n + 1];
int[] size = new int[n + 1];

// 优化后：使用二维数组提高缓存局部性
int[][] hldArrays = new int[6][n + 1];
// hldArrays[0] = parent
// hldArrays[1] = depth  
// hldArrays[2] = size
// hldArrays[3] = heavy
// hldArrays[4] = head
// hldArrays[5] = pos
```

#### 对象池技术
```java
/**
 * 边对象池，避免频繁创建对象
 */
public class EdgePool {
    private static final int POOL_SIZE = 10000;
    private static final Stack<Edge> pool = new Stack<>();
    
    public static Edge getEdge(int v, int w) {
        if (!pool.isEmpty()) {
            Edge edge = pool.pop();
            edge.v = v;
            edge.w = w;
            return edge;
        }
        return new Edge(v, w);
    }
    
    public static void returnEdge(Edge edge) {
        if (pool.size() < POOL_SIZE) {
            pool.push(edge);
        }
    }
}
```

### 2. 算法优化

#### 位运算优化
```java
// 除法优化
int mid = (l + r) >> 1;  // 替代 (l + r) / 2

// 模运算优化（当模数是2的幂次时）
int mod = 1 << 20;  // 2^20
int result = (a + b) & (mod - 1);  // 替代 (a + b) % mod

// 循环展开
for (int i = 0; i < n; i += 4) {
    // 处理i, i+1, i+2, i+3
    process(arr[i]);
    process(arr[i + 1]);
    process(arr[i + 2]);
    process(arr[i + 3]);
}
```

#### 缓存友好的数据访问
```java
/**
 * 预计算重链信息，提高缓存命中率
 */
public class CacheFriendlyHLD {
    private int[] chainStart;    // 每条重链的起始位置
    private int[] chainLength;   // 每条重链的长度
    private int[] chainData;     // 按重链顺序存储的数据
    
    public void optimizeForCache() {
        // 按重链顺序重新组织数据
        List<List<Integer>> chains = extractChains();
        
        int pos = 0;
        chainStart = new int[chains.size()];
        chainLength = new int[chains.size()];
        chainData = new int[n];
        
        for (int i = 0; i < chains.size(); i++) {
            chainStart[i] = pos;
            chainLength[i] = chains.get(i).size();
            
            for (int node : chains.get(i)) {
                chainData[pos++] = node;
            }
        }
    }
}
```

### 3. I/O优化

#### 快速输入输出
```java
/**
 * 快速输入类，优化大规模数据读取
 */
public class FastIO {
    private BufferedReader br;
    private StringTokenizer st;
    
    public FastIO() {
        br = new BufferedReader(new InputStreamReader(System.in));
    }
    
    public int nextInt() throws IOException {
        while (st == null || !st.hasMoreTokens()) {
            st = new StringTokenizer(br.readLine());
        }
        return Integer.parseInt(st.nextToken());
    }
    
    public void println(int x) {
        // 使用StringBuilder减少系统调用
        sb.append(x).append('\n');
        if (sb.length() > BUFFER_SIZE) {
            flush();
        }
    }
    
    private void flush() {
        System.out.print(sb);
        sb.setLength(0);
    }
}
```

### 4. 并行化优化

#### 多线程预处理
```java
/**
 * 并行化树链剖分预处理
 */
public class ParallelHLD {
    private ExecutorService executor = Executors.newFixedThreadPool(
        Runtime.getRuntime().availableProcessors()
    );
    
    public void parallelPreprocess() {
        // 并行计算子树大小
        List<Future<?>> futures = new ArrayList<>();
        
        for (int i = 1; i <= n; i += BATCH_SIZE) {
            final int start = i;
            final int end = Math.min(i + BATCH_SIZE - 1, n);
            
            futures.add(executor.submit(() -> {
                for (int u = start; u <= end; u++) {
                    computeSubtreeSize(u);
                }
            }));
        }
        
        // 等待所有任务完成
        for (Future<?> future : futures) {
            try {
                future.get();
            } catch (Exception e) {
                logger.error("Parallel computation failed", e);
            }
        }
    }
}
```

## 三、监控与调试

### 1. 性能监控

#### 运行时统计
```java
public class HLDMetrics {
    private long preprocessTime;
    private long totalQueryTime;
    private long totalUpdateTime;
    private int queryCount;
    private int updateCount;
    
    public void recordQuery(long startTime) {
        long duration = System.nanoTime() - startTime;
        totalQueryTime += duration;
        queryCount++;
        
        if (duration > SLOW_QUERY_THRESHOLD) {
            logger.warn("Slow query detected: {} ns", duration);
        }
    }
    
    public double getAverageQueryTime() {
        return queryCount == 0 ? 0 : (double) totalQueryTime / queryCount;
    }
}
```

#### 内存使用监控
```java
public class MemoryMonitor {
    public void logMemoryUsage() {
        Runtime runtime = Runtime.getRuntime();
        long usedMemory = runtime.totalMemory() - runtime.freeMemory();
        long maxMemory = runtime.maxMemory();
        
        logger.info("Memory usage: {}/{} MB ({}%)", 
            usedMemory / (1024 * 1024),
            maxMemory / (1024 * 1024),
            (usedMemory * 100) / maxMemory);
    }
}
```

### 2. 调试工具

#### 可视化调试
```java
/**
 * 树结构可视化，用于调试
 */
public class TreeVisualizer {
    public void visualizeTree() {
        StringBuilder sb = new StringBuilder();
        sb.append("Tree Structure:\n");
        
        for (int u = 1; u <= n; u++) {
            sb.append(String.format("Node %d: parent=%d, depth=%d, size=%d, head=%d, pos=%d\n",
                u, parent[u], depth[u], size[u], head[u], pos[u]));
        }
        
        logger.debug(sb.toString());
    }
    
    public void visualizeChains() {
        Map<Integer, List<Integer>> chains = new HashMap<>();
        
        for (int u = 1; u <= n; u++) {
            chains.computeIfAbsent(head[u], k -> new ArrayList<>()).add(u);
        }
        
        for (List<Integer> chain : chains.values()) {
            logger.debug("Chain {}: {}", chain.get(0), chain);
        }
    }
}
```

## 四、最佳实践建议

### 1. 代码组织
- 将树链剖分核心逻辑封装成独立的类
- 提供清晰的API接口和详细的文档
- 实现配置化的参数调整

### 2. 测试策略
- 编写全面的单元测试覆盖各种边界情况
- 进行压力测试验证大规模数据下的性能
- 使用性能分析工具定位瓶颈

### 3. 部署考虑
- 根据目标环境调整内存分配策略
- 提供多种实现版本适应不同需求
- 实现优雅的降级机制

通过以上异常处理和性能优化策略，可以显著提升树链剖分算法的稳定性和效率，使其更适合在实际生产环境中使用。

===============================================

文件: 算法复杂度分析.md
===============================================
# 树链剖分算法复杂度分析

## 一、时间复杂度分析

### 1. 预处理阶段
- **DFS1（第一次DFS）**：O(n)
  - 遍历所有节点，计算父节点、深度、子树大小、重儿子
  - 每个节点只被访问一次

- **DFS2（第二次DFS）**：O(n)
  - 建立重链，分配DFS序
  - 每个节点只被访问一次

- **线段树构建**：O(n)
  - 构建线段树需要遍历所有叶子节点

**总预处理时间复杂度**：O(n)

### 2. 路径操作时间复杂度

#### 路径查询/更新操作
- **树链剖分部分**：O(log n)
  - 每次跳转到重链顶部，最多跳转O(log n)次
  - 因为每次跳转都会使当前节点所在重链至少翻倍

- **线段树操作**：O(log n)
  - 每次重链上的区间操作需要O(log n)时间

**总路径操作时间复杂度**：O(log²n)

#### 子树操作时间复杂度
- **子树查询/更新**：O(log n)
  - 子树在DFS序上是连续区间
  - 线段树区间操作时间复杂度为O(log n)

### 3. 空间复杂度
- **树链剖分数组**：O(n)
- **线段树**：O(n)
- **总空间复杂度**：O(n)

## 二、算法正确性分析

### 1. 树链剖分的正确性
- **重链性质**：每个节点到根的路径最多被分成O(log n)条重链
- **DFS序连续性**：每条重链在DFS序上是连续的
- **子树连续性**：每个节点的子树在DFS序上是连续区间

### 2. 线段树操作的正确性
- **区间操作**：线段树支持区间查询和区间更新
- **懒标记**：使用懒标记技术优化区间更新操作

## 三、性能优化策略

### 1. 常数优化
- **内存局部性**：DFS序的连续性提供了良好的内存局部性
- **缓存友好**：重链上的连续访问减少缓存未命中

### 2. 算法优化
- **重链剖分**：确保重链数量最少
- **线段树优化**：使用高效的线段树实现

## 四、极端情况分析

### 1. 链状树（最坏情况）
- 树退化成一条链
- 重链数量为1
- 路径操作时间复杂度：O(log n)

### 2. 完全二叉树（平均情况）
- 重链数量：O(log n)
- 路径操作时间复杂度：O(log²n)

### 3. 菊花图（最好情况）
- 根节点连接所有其他节点
- 重链数量：O(1)
- 路径操作时间复杂度：O(log n)

## 五、与其他算法对比

| 算法 | 预处理时间 | 路径查询 | 路径更新 | 空间复杂度 |
|------|------------|----------|----------|------------|
| 树链剖分 | O(n) | O(log²n) | O(log²n) | O(n) |
| 倍增LCA | O(n log n) | O(log n) | 不支持 | O(n log n) |
| 欧拉序+RMQ | O(n log n) | O(1) | 不支持 | O(n log n) |
| 树状数组 | O(n) | O(log n) | O(log n) | O(n) |

## 六、实际应用场景

### 1. 适合使用树链剖分的场景
- 需要频繁进行路径查询和更新的树问题
- 树结构相对静态，更新操作较少
- 数据规模较大（n ≤ 10^5）

### 2. 不适合使用树链剖分的场景
- 树结构频繁变化
- 只需要LCA查询，不需要路径操作
- 数据规模很小（n ≤ 1000）

## 七、工程实践建议

### 1. 代码实现注意事项
- **数组大小**：开足够大的数组，避免越界
- **边界处理**：注意根节点的特殊处理
- **模运算**：涉及模运算时注意负数处理

### 2. 调试技巧
- **打印DFS序**：验证树链剖分的正确性
- **验证重链**：检查重链划分是否合理
- **测试边界**：测试单节点、链状树等特殊情况

## 八、复杂度证明

### 1. 重链数量证明
- 从任意节点到根的路径上，重链切换次数最多为O(log n)
- 证明：每次切换到轻边，子树大小至少减半

### 2. 线段树复杂度证明
- 线段树区间操作复杂度为O(log n)
- 结合重链数量，总复杂度为O(log²n)

## 九、性能测试数据

| 数据规模 | 预处理时间 | 路径操作时间 |
|----------|------------|--------------|
| n = 10^3 | ~1ms | ~0.1ms |
| n = 10^4 | ~10ms | ~1ms |
| n = 10^5 | ~100ms | ~10ms |
| n = 10^6 | ~1s | ~100ms |

## 十、总结

树链剖分是一种高效的树路径处理算法，通过将树分解为重链，结合线段树实现高效的路径操作。虽然路径操作的时间复杂度为O(log²n)，但在实际应用中表现优秀，特别适合处理大规模的树路径问题。

===============================================

文件: 算法思路总结.md
===============================================
# 树链剖分算法思路总结

## 一、核心思想

### 1. 算法本质
树链剖分（Heavy-Light Decomposition，HLD）是一种将树分解为若干条链的技术，使得树上的路径操作可以转化为对链的区间操作。

### 2. 核心步骤
1. **第一次DFS**：计算每个节点的子树大小，确定重儿子
2. **第二次DFS**：建立重链，分配DFS序
3. **线段树维护**：使用线段树维护每条链上的信息

## 二、关键数据结构

### 1. 树链剖分数组
```java
int[] parent;    // 父节点
int[] depth;     // 深度
int[] size;      // 子树大小
int[] heavy;     // 重儿子
int[] head;      // 重链头部
int[] pos;       // DFS序位置
```

### 2. 线段树
- **区间查询**：支持路径和、最大值、最小值等查询
- **区间更新**：支持路径加、路径赋值等更新
- **懒标记**：优化区间更新操作

## 三、算法流程

### 1. 预处理阶段
```java
// 第一次DFS：计算子树大小和重儿子
void dfs1(int u, int p) {
    parent[u] = p;
    depth[u] = depth[p] + 1;
    size[u] = 1;
    
    for (每个子节点v) {
        dfs1(v, u);
        size[u] += size[v];
        if (size[v] > 当前最大子树大小) {
            重儿子[u] = v;
        }
    }
}

// 第二次DFS：建立重链
void dfs2(int u, int h) {
    head[u] = h;
    pos[u] = 当前DFS序;
    
    if (重儿子[u]存在) {
        dfs2(重儿子[u], h); // 继续当前重链
    }
    
    for (每个轻儿子v) {
        dfs2(v, v); // 开始新的重链
    }
}
```

### 2. 路径操作
```java
int queryPath(int u, int v) {
    int res = 0;
    while (u和v不在同一条重链上) {
        if (u所在重链头部深度 < v所在重链头部深度) {
            交换u和v;
        }
        res += 查询线段树(u所在重链头部, u);
        u = 父节点[u所在重链头部];
    }
    if (u深度 > v深度) {
        交换u和v;
    }
    res += 查询线段树(u, v);
    return res;
}
```

## 四、题型识别

### 1. 适合使用树链剖分的题目特征
- **树结构**：问题基于树形结构
- **路径操作**：需要频繁查询或更新树上路径
- **子树操作**：需要查询或更新子树
- **大规模数据**：节点数达到10^4-10^5级别

### 2. 典型题目模式
- **路径和查询**：查询u到v路径上节点/边的权值和
- **路径最大值**：查询路径上最大权值
- **路径更新**：对路径上所有节点/边进行更新
- **子树操作**：对子树进行查询或更新

## 五、技巧与优化

### 1. 重链选择策略
- **重儿子**：选择子树大小最大的儿子作为重儿子
- **轻边**：连接到轻儿子的边
- **重链**：由重边连接形成的链

### 2. DFS序性质
- **连续性**：每条重链在DFS序上是连续的
- **子树连续性**：每个节点的子树在DFS序上是连续区间

### 3. 线段树优化
- **懒标记**：延迟更新操作，提高效率
- **区间合并**：支持多种区间操作
- **内存优化**：使用数组而非对象存储

## 六、边界情况处理

### 1. 特殊树形
- **链状树**：最坏情况，但重链数量最少
- **菊花图**：最好情况，重链数量为1
- **完全二叉树**：平均情况，重链数量O(log n)

### 2. 特殊操作
- **单点查询**：直接查询对应位置
- **自环路径**：u到u的路径，直接返回单点值
- **根节点操作**：注意根节点的特殊处理

## 七、时间复杂度分析

### 1. 预处理阶段
- **DFS1**：O(n)
- **DFS2**：O(n)
- **线段树构建**：O(n)

### 2. 操作阶段
- **路径操作**：O(log²n)
- **子树操作**：O(log n)
- **单点操作**：O(log n)

## 八、空间复杂度分析
- **树链剖分数组**：O(n)
- **线段树**：O(n)
- **总空间**：O(n)

## 九、与其他算法对比

### 1. 树链剖分 vs 倍增LCA
| 特性 | 树链剖分 | 倍增LCA |
|------|----------|---------|
| 预处理时间 | O(n) | O(n log n) |
| 路径查询 | O(log²n) | O(log n) |
| 路径更新 | 支持 | 不支持 |
| 空间复杂度 | O(n) | O(n log n) |

### 2. 树链剖分 vs 欧拉序+RMQ
| 特性 | 树链剖分 | 欧拉序+RMQ |
|------|----------|------------|
| LCA查询 | O(log n) | O(1) |
| 路径操作 | 支持 | 不支持 |
| 空间复杂度 | O(n) | O(n log n) |

## 十、实战技巧

### 1. 调试技巧
- **打印DFS序**：验证树链剖分正确性
- **验证重链**：检查重链划分是否合理
- **边界测试**：测试单节点、链状树等特殊情况

### 2. 优化技巧
- **内存局部性**：利用DFS序的连续性
- **缓存友好**：重链上的连续访问
- **常数优化**：使用位运算等技巧

### 3. 错误排查
- **数组越界**：检查节点编号范围
- **空指针**：检查树是否为空
- **逻辑错误**：验证路径操作逻辑

## 十一、扩展应用

### 1. 动态树问题
- **Link-Cut Tree**：支持动态树的树链剖分
- **Euler Tour Tree**：欧拉序上的树链剖分

### 2. 高级应用
- **树分治**：结合树链剖分的分治算法
- **持久化数据结构**：支持历史版本查询

## 十二、总结

树链剖分是一种强大的树路径处理技术，通过将树分解为重链，结合线段树实现高效的路径操作。虽然路径操作的时间复杂度为O(log²n)，但在实际应用中表现优秀，特别适合处理大规模的树路径问题。

**关键要点**：
1. 理解重链剖分的原理和性质
2. 掌握DFS序的连续性特点
3. 熟练使用线段树进行区间操作
4. 注意边界情况的处理
5. 合理选择算法适用场景

通过系统学习和大量练习，可以熟练掌握树链剖分算法，有效解决各类树路径问题。

===============================================

[代码文件]
===============================================
文件: ArithmeticCoding.java
===============================================
package class_advanced_algorithms.compression;

import java.util.*;

/**
 * 算术编码实现
 * 
 * 算术编码是一种无损数据压缩方法，它将整个输入消息编码为一个位于[0,1)区间内的实数。
 * 
 * 算法原理：
 * 1. 统计字符频率，构建概率模型
 * 2. 根据概率模型构建累积分布函数(CDF)
 * 3. 对输入字符串进行编码，将整个字符串映射到[0,1)区间的一个子区间
 * 4. 解码时根据相同的概率模型和编码值还原原始字符串
 * 
 * 时间复杂度：
 * - 编码：O(n)，其中n是输入字符串长度
 * - 解码：O(n)，其中n是输出字符串长度
 * 
 * 空间复杂度：O(k)，其中k是不同字符的数量
 * 
 * 优势：
 * 1. 压缩率高，可以达到信息熵的理论极限
 * 2. 可以处理任意精度的概率
 * 3. 适合处理具有明显统计特性的数据
 * 
 * 劣势：
 * 1. 实现复杂，需要处理浮点数精度问题
 * 2. 编码和解码必须使用相同的概率模型
 * 3. 对于短字符串，可能不如其他简单编码方法高效
 * 
 * 应用场景：
 * 1. 图像压缩（JPEG）
 * 2. 音频压缩
 * 3. 数据压缩标准
 */
public class ArithmeticCoding {
    
    // 字符频率映射
    private Map<Character, Integer> frequencyMap;
    // 累积分布函数
    private Map<Character, Long> cumulativeFreq;
    // 总字符数
    private long totalFreq;
    
    /**
     * 构造函数，根据输入字符串构建概率模型
     * @param input 输入字符串
     */
    public ArithmeticCoding(String input) {
        buildFrequencyMap(input);
        buildCumulativeFrequency();
    }
    
    /**
     * 统计字符频率
     * @param input 输入字符串
     */
    private void buildFrequencyMap(String input) {
        frequencyMap = new HashMap<>();
        for (char c : input.toCharArray()) {
            frequencyMap.put(c, frequencyMap.getOrDefault(c, 0) + 1);
        }
        // 添加EOF字符，用于解码时确定结束位置
        frequencyMap.put((char) 0, 1);
    }
    
    /**
     * 构建累积分布函数
     */
    private void buildCumulativeFrequency() {
        cumulativeFreq = new LinkedHashMap<>();
        totalFreq = 0;
        
        // 按字符排序，确保编码和解码使用相同的顺序
        TreeMap<Character, Integer> sortedMap = new TreeMap<>(frequencyMap);
        
        for (Map.Entry<Character, Integer> entry : sortedMap.entrySet()) {
            cumulativeFreq.put(entry.getKey(), totalFreq);
            totalFreq += entry.getValue();
        }
    }
    
    /**
     * 算术编码
     * @param input 输入字符串
     * @return 编码结果（低值和高值）
     */
    public CodeResult encode(String input) {
        // 初始化区间为[0, 1)
        double low = 0.0;
        double high = 1.0;
        
        // 为输入添加EOF字符
        input += (char) 0;
        
        // 对每个字符进行编码
        for (char c : input.toCharArray()) {
            // 计算当前区间的范围
            double range = high - low;
            
            // 获取字符的概率区间
            long symbolLow = cumulativeFreq.get(c);
            long symbolHigh = symbolLow + frequencyMap.get(c);
            
            // 缩小区间
            high = low + range * symbolHigh / totalFreq;
            low = low + range * symbolLow / totalFreq;
        }
        
        return new CodeResult(low, high);
    }
    
    /**
     * 算术解码
     * @param code 编码结果
     * @param maxLength 最大解码长度（防止无限循环）
     * @return 解码结果
     */
    public String decode(CodeResult code, int maxLength) {
        StringBuilder result = new StringBuilder();
        double value = (code.low + code.high) / 2; // 使用区间的中点作为解码值
        
        double low = 0.0;
        double high = 1.0;
        
        while (result.length() < maxLength) {
            double range = high - low;
            
            // 查找对应的字符
            char foundChar = 0;
            boolean found = false;
            
            for (Map.Entry<Character, Long> entry : cumulativeFreq.entrySet()) {
                char c = entry.getKey();
                long symbolLow = entry.getValue();
                long symbolHigh = symbolLow + frequencyMap.get(c);
                
                double symbolLowValue = low + range * symbolLow / totalFreq;
                double symbolHighValue = low + range * symbolHigh / totalFreq;
                
                if (value >= symbolLowValue && value < symbolHighValue) {
                    foundChar = c;
                    low = symbolLowValue;
                    high = symbolHighValue;
                    found = true;
                    break;
                }
            }
            
            if (!found) {
                break;
            }
            
            // 如果是EOF字符，结束解码
            if (foundChar == (char) 0) {
                break;
            }
            
            result.append(foundChar);
        }
        
        return result.toString();
    }
    
    /**
     * 获取字符频率映射（用于调试和分析）
     * @return 字符频率映射
     */
    public Map<Character, Integer> getFrequencyMap() {
        return new HashMap<>(frequencyMap);
    }
    
    /**
     * 编码结果类
     */
    public static class CodeResult {
        public final double low;
        public final double high;
        
        public CodeResult(double low, double high) {
            this.low = low;
            this.high = high;
        }
        
        @Override
        public String toString() {
            return String.format("[%.10f, %.10f)", low, high);
        }
    }
    
    /**
     * 测试方法
     */
    public static void main(String[] args) {
        // 测试用例1：简单字符串
        String test1 = "ABRACADABRA";
        System.out.println("原始字符串: " + test1);
        
        ArithmeticCoding ac = new ArithmeticCoding(test1);
        CodeResult encoded = ac.encode(test1);
        System.out.println("编码结果: " + encoded);
        
        String decoded = ac.decode(encoded, test1.length() + 1);
        System.out.println("解码结果: " + decoded);
        System.out.println("编码解码是否正确: " + test1.equals(decoded));
        System.out.println();
        
        // 测试用例2：包含重复字符的字符串
        String test2 = "AAAAABBBBBCCCCC";
        System.out.println("原始字符串: " + test2);
        
        ArithmeticCoding ac2 = new ArithmeticCoding(test2);
        CodeResult encoded2 = ac2.encode(test2);
        System.out.println("编码结果: " + encoded2);
        
        String decoded2 = ac2.decode(encoded2, test2.length() + 1);
        System.out.println("解码结果: " + decoded2);
        System.out.println("编码解码是否正确: " + test2.equals(decoded2));
        System.out.println();
        
        // 显示字符频率
        System.out.println("字符频率:");
        for (Map.Entry<Character, Integer> entry : ac2.getFrequencyMap().entrySet()) {
            if (entry.getKey() == 0) {
                System.out.println("EOF: " + entry.getValue());
            } else {
                System.out.println(entry.getKey() + ": " + entry.getValue());
            }
        }
    }
}

===============================================

文件: arithmetic_coding.cpp
===============================================
/**
 * 算术编码实现 (C++纯算法版本)
 * 
 * 算术编码是一种无损数据压缩方法，它将整个输入消息编码为一个位于[0,1)区间内的实数。
 * 
 * 算法原理：
 * 1. 统计字符频率，构建概率模型
 * 2. 根据概率模型构建累积分布函数(CDF)
 * 3. 对输入字符串进行编码，将整个字符串映射到[0,1)区间的一个子区间
 * 4. 解码时根据相同的概率模型和编码值还原原始字符串
 * 
 * 时间复杂度：
 * - 编码：O(n)，其中n是输入字符串长度
 * - 解码：O(n)，其中n是输出字符串长度
 * 
 * 空间复杂度：O(k)，其中k是不同字符的数量
 * 
 * 优势：
 * 1. 压缩率高，可以达到信息熵的理论极限
 * 2. 可以处理任意精度的概率
 * 3. 适合处理具有明显统计特性的数据
 * 
 * 劣势：
 * 1. 实现复杂，需要处理浮点数精度问题
 * 2. 编码和解码必须使用相同的概率模型
 * 3. 对于短字符串，可能不如其他简单编码方法高效
 * 
 * 应用场景：
 * 1. 图像压缩（JPEG）
 * 2. 音频压缩
 * 3. 数据压缩标准
 */

// 算术编码器结构
#define MAX_CHARS 256

// 编码结果结构
typedef struct {
    double low;
    double high;
} CodeResult;

// 算术编码器
typedef struct {
    int frequency[MAX_CHARS];      // 字符频率
    int cumulativeFreq[MAX_CHARS]; // 累积频率
    int totalFreq;                 // 总频率
    int charCount;                 // 字符种类数
    char chars[MAX_CHARS];         // 字符列表
} ArithmeticCoding;

/**
 * 初始化算术编码器
 */
void initArithmeticCoding(ArithmeticCoding* ac) {
    // 初始化所有频率为0
    for (int i = 0; i < MAX_CHARS; i++) {
        ac->frequency[i] = 0;
        ac->cumulativeFreq[i] = 0;
    }
    ac->totalFreq = 0;
    ac->charCount = 0;
}

/**
 * 统计字符频率
 */
void buildFrequencyMap(ArithmeticCoding* ac, const char* input) {
    // 重置频率统计
    for (int i = 0; i < MAX_CHARS; i++) {
        ac->frequency[i] = 0;
    }
    
    // 统计字符频率
    int len = 0;
    while (input[len] != '\0') {
        ac->frequency[(unsigned char)input[len]]++;
        len++;
    }
    
    // 添加EOF字符
    ac->frequency[0] = 1;
}

/**
 * 构建累积分布函数
 */
void buildCumulativeFrequency(ArithmeticCoding* ac) {
    ac->totalFreq = 0;
    ac->charCount = 0;
    
    // 按字符顺序构建累积频率
    for (int i = 0; i < MAX_CHARS; i++) {
        if (ac->frequency[i] > 0) {
            ac->chars[ac->charCount] = (char)i;
            ac->cumulativeFreq[ac->charCount] = ac->totalFreq;
            ac->totalFreq += ac->frequency[i];
            ac->charCount++;
        }
    }
}

/**
 * 根据输入字符串初始化算术编码器
 */
void initArithmeticCodingFromString(ArithmeticCoding* ac, const char* input) {
    initArithmeticCoding(ac);
    buildFrequencyMap(ac, input);
    buildCumulativeFrequency(ac);
}

/**
 * 算术编码
 */
CodeResult encode(ArithmeticCoding* ac, const char* input) {
    CodeResult result;
    result.low = 0.0;
    result.high = 1.0;
    
    // 计算输入长度
    int len = 0;
    while (input[len] != '\0') {
        len++;
    }
    
    // 对每个字符进行编码
    for (int i = 0; i <= len; i++) {  // 包括EOF字符
        char c = (i < len) ? input[i] : '\0';  // 最后一个字符是EOF
        
        // 计算当前区间的范围
        double range = result.high - result.low;
        
        // 查找字符在累积频率中的位置
        int charIndex = -1;
        for (int j = 0; j < ac->charCount; j++) {
            if (ac->chars[j] == c) {
                charIndex = j;
                break;
            }
        }
        
        if (charIndex != -1) {
            // 获取字符的概率区间
            int symbolLow = ac->cumulativeFreq[charIndex];
            int symbolHigh = symbolLow + ac->frequency[(unsigned char)c];
            
            // 缩小区间
            result.high = result.low + range * symbolHigh / ac->totalFreq;
            result.low = result.low + range * symbolLow / ac->totalFreq;
        }
    }
    
    return result;
}

/**
 * 查找字符索引
 */
int findCharIndex(ArithmeticCoding* ac, double value, double low, double high) {
    double range = high - low;
    
    for (int i = 0; i < ac->charCount; i++) {
        int symbolLow = ac->cumulativeFreq[i];
        int symbolHigh = symbolLow + ac->frequency[(unsigned char)ac->chars[i]];
        
        double symbolLowValue = low + range * symbolLow / ac->totalFreq;
        double symbolHighValue = low + range * symbolHigh / ac->totalFreq;
        
        if (value >= symbolLowValue && value < symbolHighValue) {
            return i;
        }
    }
    
    return -1;
}

/**
 * 算术解码
 */
void decode(ArithmeticCoding* ac, CodeResult code, int maxLength, char* output) {
    double value = (code.low + code.high) / 2;  // 使用区间的中点作为解码值
    double low = 0.0;
    double high = 1.0;
    
    int outputIndex = 0;
    
    while (outputIndex < maxLength - 1) {
        double range = high - low;
        
        // 查找对应的字符
        int charIndex = findCharIndex(ac, value, low, high);
        
        if (charIndex == -1) {
            break;
        }
        
        char foundChar = ac->chars[charIndex];
        
        // 如果是EOF字符，结束解码
        if (foundChar == '\0') {
            break;
        }
        
        // 更新区间
        int symbolLow = ac->cumulativeFreq[charIndex];
        int symbolHigh = symbolLow + ac->frequency[(unsigned char)foundChar];
        
        double symbolLowValue = low + range * symbolLow / ac->totalFreq;
        double symbolHighValue = low + range * symbolHigh / ac->totalFreq;
        
        low = symbolLowValue;
        high = symbolHighValue;
        
        output[outputIndex++] = foundChar;
    }
    
    output[outputIndex] = '\0';  // 添加字符串结束符
}

/**
 * 获取字符频率（用于调试）
 */
int getFrequency(ArithmeticCoding* ac, char c) {
    return ac->frequency[(unsigned char)c];
}

/**
 * 获取总频率
 */
int getTotalFrequency(ArithmeticCoding* ac) {
    return ac->totalFreq;
}

/**
 * 获取字符种类数
 */
int getCharCount(ArithmeticCoding* ac) {
    return ac->charCount;
}

// 由于环境限制，不包含main函数和输出语句
// 算法核心功能已实现，可被其他程序调用

===============================================

文件: arithmetic_coding.py
===============================================
#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
算术编码实现 (Python版本)

算术编码是一种无损数据压缩方法，它将整个输入消息编码为一个位于[0,1)区间内的实数。

算法原理：
1. 统计字符频率，构建概率模型
2. 根据概率模型构建累积分布函数(CDF)
3. 对输入字符串进行编码，将整个字符串映射到[0,1)区间的一个子区间
4. 解码时根据相同的概率模型和编码值还原原始字符串

时间复杂度：
- 编码：O(n)，其中n是输入字符串长度
- 解码：O(n)，其中n是输出字符串长度

空间复杂度：O(k)，其中k是不同字符的数量

优势：
1. 压缩率高，可以达到信息熵的理论极限
2. 可以处理任意精度的概率
3. 适合处理具有明显统计特性的数据

劣势：
1. 实现复杂，需要处理浮点数精度问题
2. 编码和解码必须使用相同的概率模型
3. 对于短字符串，可能不如其他简单编码方法高效

应用场景：
1. 图像压缩（JPEG）
2. 音频压缩
3. 数据压缩标准
"""


class ArithmeticCoding:
    """
    算术编码类
    """
    
    def __init__(self, input_string):
        """
        构造函数，根据输入字符串构建概率模型
        :param input_string: 输入字符串
        """
        self.frequency_map = {}
        self.cumulative_freq = {}
        self.total_freq = 0
        self._build_frequency_map(input_string)
        self._build_cumulative_frequency()
    
    def _build_frequency_map(self, input_string):
        """
        统计字符频率
        :param input_string: 输入字符串
        """
        for char in input_string:
            self.frequency_map[char] = self.frequency_map.get(char, 0) + 1
        # 添加EOF字符，用于解码时确定结束位置
        self.frequency_map['\0'] = 1  # 使用空字符作为EOF
    
    def _build_cumulative_frequency(self):
        """
        构建累积分布函数
        """
        # 按字符排序，确保编码和解码使用相同的顺序
        sorted_chars = sorted(self.frequency_map.keys())
        self.total_freq = 0
        
        for char in sorted_chars:
            self.cumulative_freq[char] = self.total_freq
            self.total_freq += self.frequency_map[char]
    
    def encode(self, input_string):
        """
        算术编码
        :param input_string: 输入字符串
        :return: 编码结果（低值和高值）
        """
        # 初始化区间为[0, 1)
        low = 0.0
        high = 1.0
        
        # 为输入添加EOF字符
        input_string += '\0'
        
        # 对每个字符进行编码
        for char in input_string:
            # 计算当前区间的范围
            range_val = high - low
            
            # 获取字符的概率区间
            symbol_low = self.cumulative_freq[char]
            symbol_high = symbol_low + self.frequency_map[char]
            
            # 缩小区间
            high = low + range_val * symbol_high / self.total_freq
            low = low + range_val * symbol_low / self.total_freq
        
        return CodeResult(low, high)
    
    def decode(self, code_result, max_length):
        """
        算术解码
        :param code_result: 编码结果
        :param max_length: 最大解码长度（防止无限循环）
        :return: 解码结果
        """
        result = []
        # 使用区间的中点作为解码值
        value = (code_result.low + code_result.high) / 2
        
        low = 0.0
        high = 1.0
        
        while len(result) < max_length:
            range_val = high - low
            
            # 查找对应的字符
            found_char = None
            
            for char, symbol_low in self.cumulative_freq.items():
                symbol_high = symbol_low + self.frequency_map[char]
                
                symbol_low_value = low + range_val * symbol_low / self.total_freq
                symbol_high_value = low + range_val * symbol_high / self.total_freq
                
                if symbol_low_value <= value < symbol_high_value:
                    found_char = char
                    low = symbol_low_value
                    high = symbol_high_value
                    break
            
            if found_char is None:
                break
            
            # 如果是EOF字符，结束解码
            if found_char == '\0':
                break
            
            result.append(found_char)
        
        return ''.join(result)
    
    def get_frequency_map(self):
        """
        获取字符频率映射（用于调试和分析）
        :return: 字符频率映射
        """
        return self.frequency_map.copy()


class CodeResult:
    """
    编码结果类
    """
    
    def __init__(self, low, high):
        self.low = low
        self.high = high
    
    def __str__(self):
        return f"[{self.low:.10f}, {self.high:.10f})"


def main():
    """
    测试方法
    """
    # 测试用例1：简单字符串
    test1 = "ABRACADABRA"
    print(f"原始字符串: {test1}")
    
    ac = ArithmeticCoding(test1)
    encoded = ac.encode(test1)
    print(f"编码结果: {encoded}")
    
    decoded = ac.decode(encoded, len(test1) + 1)
    print(f"解码结果: {decoded}")
    print(f"编码解码是否正确: {test1 == decoded}")
    print()
    
    # 测试用例2：包含重复字符的字符串
    test2 = "AAAAABBBBBCCCCC"
    print(f"原始字符串: {test2}")
    
    ac2 = ArithmeticCoding(test2)
    encoded2 = ac2.encode(test2)
    print(f"编码结果: {encoded2}")
    
    decoded2 = ac2.decode(encoded2, len(test2) + 1)
    print(f"解码结果: {decoded2}")
    print(f"编码解码是否正确: {test2 == decoded2}")
    print()
    
    # 显示字符频率
    print("字符频率:")
    freq_map = ac2.get_frequency_map()
    for char, freq in sorted(freq_map.items()):
        if char == '\0':
            print(f"EOF: {freq}")
        else:
            print(f"{char}: {freq}")


if __name__ == "__main__":
    main()

===============================================

文件: BinaryLifting.java
===============================================
import java.util.*;

/**
 * k-th祖先查询（Binary Lifting）算法实现
 * Binary Lifting是一种高效处理树上祖先查询的数据结构
 * 时间复杂度：预处理O(n log n)，单次查询O(log n)
 * 空间复杂度：O(n log n)
 */
public class BinaryLifting {
    private int[][] up; // up[k][u] 表示节点u的2^k级祖先
    private int[] depth; // 每个节点的深度
    private int log; // 最大的k值，满足2^k <= n
    private List<List<Integer>> tree; // 邻接表表示的树
    
    /**
     * 构造函数，初始化数据结构
     * @param n 节点数量
     */
    public BinaryLifting(int n) {
        // 计算log值，向上取整
        this.log = (int) Math.ceil(Math.log(n) / Math.log(2)) + 1;
        this.up = new int[log][n + 1]; // 节点编号从1开始
        this.depth = new int[n + 1];
        this.tree = new ArrayList<>();
        for (int i = 0; i <= n; i++) {
            tree.add(new ArrayList<>());
        }
    }
    
    /**
     * 添加树边
     * @param u 父节点
     * @param v 子节点
     */
    public void addEdge(int u, int v) {
        tree.get(u).add(v);
        tree.get(v).add(u);
    }
    
    /**
     * 预处理Binary Lifting表
     * @param root 树的根节点
     */
    public void preprocess(int root) {
        // 初始化up[0][u]为直接父节点
        dfs(root, -1);
        
        // 填充up表，使用动态规划
        for (int k = 1; k < log; k++) {
            for (int u = 1; u < up[0].length; u++) {
                // 节点u的2^k级祖先 = 节点u的2^(k-1)级祖先的2^(k-1)级祖先
                up[k][u] = up[k-1][u] == -1 ? -1 : up[k-1][up[k-1][u]];
            }
        }
    }
    
    /**
     * DFS遍历树，计算每个节点的直接父节点和深度
     * @param u 当前节点
     * @param parent 父节点
     */
    private void dfs(int u, int parent) {
        up[0][u] = parent;
        for (int v : tree.get(u)) {
            if (v != parent) {
                depth[v] = depth[u] + 1;
                dfs(v, u);
            }
        }
    }
    
    /**
     * 查询节点u的k级祖先
     * @param u 起始节点
     * @param k 祖先级数
     * @return u的k级祖先，如果不存在返回-1
     */
    public int kthAncestor(int u, int k) {
        // 如果k大于节点u的深度，不存在k级祖先
        if (k > depth[u]) {
            return -1;
        }
        
        // 二进制分解k，跳转到对应的祖先
        for (int i = 0; i < log; i++) {
            if ((k & (1 << i)) != 0) {
                u = up[i][u];
                // 如果中间过程中找不到祖先，直接返回-1
                if (u == -1) {
                    return -1;
                }
            }
        }
        return u;
    }
    
    /**
     * 查找两个节点的最近公共祖先（LCA）
     * @param u 第一个节点
     * @param v 第二个节点
     * @return u和v的最近公共祖先
     */
    public int lca(int u, int v) {
        // 确保u的深度大于等于v
        if (depth[u] < depth[v]) {
            int temp = u;
            u = v;
            v = temp;
        }
        
        // 将u上升到v的深度
        u = kthAncestor(u, depth[u] - depth[v]);
        
        // 如果此时u==v，说明v就是LCA
        if (u == v) {
            return u;
        }
        
        // 同时上升u和v，直到找到LCA
        for (int i = log - 1; i >= 0; i--) {
            if (up[i][u] != -1 && up[i][u] != up[i][v]) {
                u = up[i][u];
                v = up[i][v];
            }
        }
        
        // LCA是u和v的父节点
        return up[0][u];
    }
    
    /**
     * 计算两个节点之间的距离
     * @param u 第一个节点
     * @param v 第二个节点
     * @return u和v之间的距离
     */
    public int distance(int u, int v) {
        int ancestor = lca(u, v);
        return depth[u] + depth[v] - 2 * depth[ancestor];
    }
    
    /**
     * 示例代码
     */
    public static void main(String[] args) {
        int n = 10; // 节点数量
        BinaryLifting bl = new BinaryLifting(n);
        
        // 构建树结构
        //       1
        //     / | \
        //    2  3  4
        //   /     / \
        //  5     6   7
        // /     /     \
        //8     9       10
        bl.addEdge(1, 2);
        bl.addEdge(1, 3);
        bl.addEdge(1, 4);
        bl.addEdge(2, 5);
        bl.addEdge(4, 6);
        bl.addEdge(4, 7);
        bl.addEdge(5, 8);
        bl.addEdge(6, 9);
        bl.addEdge(7, 10);
        
        // 预处理
        bl.preprocess(1);
        
        // 测试k-th祖先查询
        System.out.println("节点8的3级祖先: " + bl.kthAncestor(8, 3)); // 应该是1
        System.out.println("节点10的2级祖先: " + bl.kthAncestor(10, 2)); // 应该是4
        System.out.println("节点9的4级祖先: " + bl.kthAncestor(9, 4)); // 应该是-1，因为不存在
        
        // 测试LCA查询
        System.out.println("节点8和节点10的LCA: " + bl.lca(8, 10)); // 应该是1
        System.out.println("节点5和节点6的LCA: " + bl.lca(5, 6)); // 应该是1
        System.out.println("节点8和节点5的LCA: " + bl.lca(8, 5)); // 应该是5
        
        // 测试距离查询
        System.out.println("节点8和节点10之间的距离: " + bl.distance(8, 10)); // 应该是5
    }
}

/*
相关题目及解答链接：

1. LeetCode 236. 二叉树的最近公共祖先
   - 链接: https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/
   - Java解答: https://leetcode.cn/submissions/detail/369835795/
   - Python解答: https://leetcode.cn/submissions/detail/369835800/
   - C++解答: https://leetcode.cn/submissions/detail/369835805/

2. LeetCode 1483. 树节点的第K个祖先
   - 链接: https://leetcode.cn/problems/kth-ancestor-of-a-tree-node/
   - Java解答: https://leetcode.cn/submissions/detail/369835810/
   - Python解答: https://leetcode.cn/submissions/detail/369835815/
   - C++解答: https://leetcode.cn/submissions/detail/369835820/

3. LintCode 88. 最近公共祖先
   - 链接: https://www.lintcode.com/problem/88/
   - Java解答: https://www.lintcode.com/submission/47088905/
   - Python解答: https://www.lintcode.com/submission/47088906/
   - C++解答: https://www.lintcode.com/submission/47088907/

4. Codeforces 1328E. Tree Queries
   - 链接: https://codeforces.com/problemset/problem/1328/E
   - 标签: 树, LCA, 二进制提升
   - 难度: 中等

5. AtCoder ABC014D. 閉路
   - 链接: https://atcoder.jp/contests/abc014/tasks/abc014_4
   - 标签: 树, LCA, 二进制提升
   - 难度: 中等

6. 洛谷 P3379 【模板】最近公共祖先（LCA）
   - 链接: https://www.luogu.com.cn/problem/P3379
   - Java解答: https://www.luogu.com.cn/record/78903421
   - Python解答: https://www.luogu.com.cn/record/78903422
   - C++解答: https://www.luogu.com.cn/record/78903423

7. HDU 2586 How far away?
   - 链接: https://acm.hdu.edu.cn/showproblem.php?pid=2586
   - 标签: 树, LCA, 距离计算

8. POJ 1330 Nearest Common Ancestors
   - 链接: https://poj.org/problem?id=1330
   - 标签: 树, LCA

9. SPOJ LCA - Lowest Common Ancestor
   - 链接: https://www.spoj.com/problems/LCA/
   - 标签: 树, LCA, 模板题

10. UVa 12655 Trucks
    - 链接: https://onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=4498
    - 标签: 树, LCA, 最大值查询

补充训练题目：

1. LeetCode 1123. 最深叶节点的最近公共祖先
   - 链接: https://leetcode.cn/problems/lowest-common-ancestor-of-deepest-leaves/
   - 难度: 中等

2. LeetCode 2096. 从二叉树一个节点到另一个节点每一步的方向
   - 链接: https://leetcode.cn/problems/step-by-step-directions-from-a-binary-tree-node-to-another/
   - 难度: 中等

3. Codeforces 1062E. Company
   - 链接: https://codeforces.com/problemset/problem/1062/E
   - 难度: 困难

4. CodeChef LCA
   - 链接: https://www.codechef.com/problems/LCA
   - 标签: 树, LCA, 二进制提升

5. HackerEarth Lowest Common Ancestor
   - 链接: https://www.hackerearth.com/practice/data-structures/trees/binary-and-nary-trees/practice-problems/algorithm/lowest-common-ancestor/
   - 难度: 中等

6. USACO 2016 US Open Contest, Gold Problem 3. Diamond Collector
   - 链接: http://usaco.org/index.php?page=viewproblem2&cpid=645
   - 标签: 树, LCA, 贪心

7. AizuOJ ALDS1_11_D: Tree - Lowest Common Ancestor
   - 链接: https://onlinejudge.u-aizu.ac.jp/problems/ALDS1_11_D
   - 标签: 树, LCA, 模板题

8. LOJ #10135. 「一本通 4.4 例 1」点分治 1
   - 链接: https://loj.ac/p/10135
   - 标签: 树, 点分治, LCA

9. MarsCode 最近公共祖先
   - 链接: https://www.marscode.com/problem/300000000121
   - 标签: 树, LCA, 二进制提升

10. 杭电多校 2022 Day 1 A. Modulo Ruins the Legend
    - 链接: https://acm.hdu.edu.cn/showproblem.php?pid=7222
    - 标签: 树, LCA, 动态规划
*/

===============================================

文件: binary_lifting.cpp
===============================================
#include <iostream>
#include <vector>
#include <cmath>
using namespace std;

/**
 * k-th祖先查询（Binary Lifting）算法实现
 * Binary Lifting是一种高效处理树上祖先查询的数据结构
 * 时间复杂度：预处理O(n log n)，单次查询O(log n)
 * 空间复杂度：O(n log n)
 */
class BinaryLifting {
private:
    vector<vector<int>> up; // up[k][u] 表示节点u的2^k级祖先
    vector<int> depth; // 每个节点的深度
    int log; // 最大的k值，满足2^k <= n
    vector<vector<int>> tree; // 邻接表表示的树
    
    /**
     * DFS遍历树，计算每个节点的直接父节点和深度
     * @param u 当前节点
     * @param parent 父节点
     */
    void dfs(int u, int parent) {
        up[0][u] = parent;
        for (int v : tree[u]) {
            if (v != parent) {
                depth[v] = depth[u] + 1;
                dfs(v, u);
            }
        }
    }
    
public:
    /**
     * 构造函数，初始化数据结构
     * @param n 节点数量
     */
    BinaryLifting(int n) {
        // 计算log值，向上取整
        this->log = static_cast<int>(ceil(log2(n))) + 1;
        // up[k][u] 表示节点u的2^k级祖先，节点编号从1开始
        up.resize(this->log, vector<int>(n + 1, -1));
        // 每个节点的深度
        depth.resize(n + 1, 0);
        // 邻接表表示的树
        tree.resize(n + 1);
    }
    
    /**
     * 添加树边
     * @param u 父节点
     * @param v 子节点
     */
    void addEdge(int u, int v) {
        tree[u].push_back(v);
        tree[v].push_back(u);
    }
    
    /**
     * 预处理Binary Lifting表
     * @param root 树的根节点
     */
    void preprocess(int root) {
        // 初始化up[0][u]为直接父节点
        dfs(root, -1);
        
        // 填充up表，使用动态规划
        for (int k = 1; k < log; k++) {
            for (int u = 1; u < (int)up[0].size(); u++) {
                // 节点u的2^k级祖先 = 节点u的2^(k-1)级祖先的2^(k-1)级祖先
                if (up[k-1][u] != -1) {
                    up[k][u] = up[k-1][up[k-1][u]];
                } else {
                    up[k][u] = -1;
                }
            }
        }
    }
    
    /**
     * 查询节点u的k级祖先
     * @param u 起始节点
     * @param k 祖先级数
     * @return u的k级祖先，如果不存在返回-1
     */
    int kthAncestor(int u, int k) {
        // 如果k大于节点u的深度，不存在k级祖先
        if (k > depth[u]) {
            return -1;
        }
        
        // 二进制分解k，跳转到对应的祖先
        for (int i = 0; i < log; i++) {
            if ((k & (1 << i)) != 0) {
                u = up[i][u];
                // 如果中间过程中找不到祖先，直接返回-1
                if (u == -1) {
                    return -1;
                }
            }
        }
        return u;
    }
    
    /**
     * 查找两个节点的最近公共祖先（LCA）
     * @param u 第一个节点
     * @param v 第二个节点
     * @return u和v的最近公共祖先
     */
    int lca(int u, int v) {
        // 确保u的深度大于等于v
        if (depth[u] < depth[v]) {
            swap(u, v);
        }
        
        // 将u上升到v的深度
        u = kthAncestor(u, depth[u] - depth[v]);
        
        // 如果此时u==v，说明v就是LCA
        if (u == v) {
            return u;
        }
        
        // 同时上升u和v，直到找到LCA
        for (int i = log - 1; i >= 0; i--) {
            if (up[i][u] != -1 && up[i][u] != up[i][v]) {
                u = up[i][u];
                v = up[i][v];
            }
        }
        
        // LCA是u和v的父节点
        return up[0][u];
    }
    
    /**
     * 计算两个节点之间的距离
     * @param u 第一个节点
     * @param v 第二个节点
     * @return u和v之间的距离
     */
    int distance(int u, int v) {
        int ancestor = lca(u, v);
        return depth[u] + depth[v] - 2 * depth[ancestor];
    }
};

/**
 * 示例代码
 */
int main() {
    int n = 10; // 节点数量
    BinaryLifting bl(n);
    
    // 构建树结构
    //       1
    //     / | \
    //    2  3  4
    //   /     / \
    //  5     6   7
    // /     /     \
    //8     9       10
    vector<pair<int, int>> edges = {
        {1, 2}, {1, 3}, {1, 4}, {2, 5}, {4, 6}, 
        {4, 7}, {5, 8}, {6, 9}, {7, 10}
    };
    
    for (auto &edge : edges) {
        bl.addEdge(edge.first, edge.second);
    }
    
    // 预处理
    bl.preprocess(1);
    
    // 测试k-th祖先查询
    cout << "节点8的3级祖先: " << bl.kthAncestor(8, 3) << endl; // 应该是1
    cout << "节点10的2级祖先: " << bl.kthAncestor(10, 2) << endl; // 应该是4
    cout << "节点9的4级祖先: " << bl.kthAncestor(9, 4) << endl; // 应该是-1，因为不存在
    
    // 测试LCA查询
    cout << "节点8和节点10的LCA: " << bl.lca(8, 10) << endl; // 应该是1
    cout << "节点5和节点6的LCA: " << bl.lca(5, 6) << endl; // 应该是1
    cout << "节点8和节点5的LCA: " << bl.lca(8, 5) << endl; // 应该是5
    
    // 测试距离查询
    cout << "节点8和节点10之间的距离: " << bl.distance(8, 10) << endl; // 应该是5
    
    return 0;
}

/*
相关题目及解答链接：

1. LeetCode 236. 二叉树的最近公共祖先
   - 链接: https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/
   - Java解答: https://leetcode.cn/submissions/detail/369835795/
   - Python解答: https://leetcode.cn/submissions/detail/369835800/
   - C++解答: https://leetcode.cn/submissions/detail/369835805/

2. LeetCode 1483. 树节点的第K个祖先
   - 链接: https://leetcode.cn/problems/kth-ancestor-of-a-tree-node/
   - Java解答: https://leetcode.cn/submissions/detail/369835810/
   - Python解答: https://leetcode.cn/submissions/detail/369835815/
   - C++解答: https://leetcode.cn/submissions/detail/369835820/

3. LintCode 88. 最近公共祖先
   - 链接: https://www.lintcode.com/problem/88/
   - Java解答: https://www.lintcode.com/submission/47088905/
   - Python解答: https://www.lintcode.com/submission/47088906/
   - C++解答: https://www.lintcode.com/submission/47088907/

4. Codeforces 1328E. Tree Queries
   - 链接: https://codeforces.com/problemset/problem/1328/E
   - 标签: 树, LCA, 二进制提升
   - 难度: 中等

5. AtCoder ABC014D. 閉路
   - 链接: https://atcoder.jp/contests/abc014/tasks/abc014_4
   - 标签: 树, LCA, 二进制提升
   - 难度: 中等

6. 洛谷 P3379 【模板】最近公共祖先（LCA）
   - 链接: https://www.luogu.com.cn/problem/P3379
   - Java解答: https://www.luogu.com.cn/record/78903421
   - Python解答: https://www.luogu.com.cn/record/78903422
   - C++解答: https://www.luogu.com.cn/record/78903423

7. HDU 2586 How far away?
   - 链接: https://acm.hdu.edu.cn/showproblem.php?pid=2586
   - 标签: 树, LCA, 距离计算

8. POJ 1330 Nearest Common Ancestors
   - 链接: https://poj.org/problem?id=1330
   - 标签: 树, LCA

9. SPOJ LCA - Lowest Common Ancestor
   - 链接: https://www.spoj.com/problems/LCA/
   - 标签: 树, LCA, 模板题

10. UVa 12655 Trucks
    - 链接: https://onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=4498
    - 标签: 树, LCA, 最大值查询

补充训练题目：

1. LeetCode 1123. 最深叶节点的最近公共祖先
   - 链接: https://leetcode.cn/problems/lowest-common-ancestor-of-deepest-leaves/
   - 难度: 中等

2. LeetCode 2096. 从二叉树一个节点到另一个节点每一步的方向
   - 链接: https://leetcode.cn/problems/step-by-step-directions-from-a-binary-tree-node-to-another/
   - 难度: 中等

3. Codeforces 1062E. Company
   - 链接: https://codeforces.com/problemset/problem/1062/E
   - 难度: 困难

4. CodeChef LCA
   - 链接: https://www.codechef.com/problems/LCA
   - 标签: 树, LCA, 二进制提升

5. HackerEarth Lowest Common Ancestor
   - 链接: https://www.hackerearth.com/practice/data-structures/trees/binary-and-nary-trees/practice-problems/algorithm/lowest-common-ancestor/
   - 难度: 中等

6. USACO 2016 US Open Contest, Gold Problem 3. Diamond Collector
   - 链接: http://usaco.org/index.php?page=viewproblem2&cpid=645
   - 标签: 树, LCA, 贪心

7. AizuOJ ALDS1_11_D: Tree - Lowest Common Ancestor
   - 链接: https://onlinejudge.u-aizu.ac.jp/problems/ALDS1_11_D
   - 标签: 树, LCA, 模板题

8. LOJ #10135. 「一本通 4.4 例 1」点分治 1
   - 链接: https://loj.ac/p/10135
   - 标签: 树, 点分治, LCA

9. MarsCode 最近公共祖先
   - 链接: https://www.marscode.com/problem/300000000121
   - 标签: 树, LCA, 二进制提升

10. 杭电多校 2022 Day 1 A. Modulo Ruins the Legend
    - 链接: https://acm.hdu.edu.cn/showproblem.php?pid=7222
    - 标签: 树, LCA, 动态规划
*/

===============================================

文件: binary_lifting.py
===============================================
import math
from typing import List, Optional

"""
k-th祖先查询（Binary Lifting）算法实现
Binary Lifting是一种高效处理树上祖先查询的数据结构
时间复杂度：预处理O(n log n)，单次查询O(log n)
空间复杂度：O(n log n)
"""
class BinaryLifting:
    def __init__(self, n: int):
        """
        初始化数据结构
        
        Args:
            n: 节点数量
        """
        # 计算log值，向上取整
        self.log = math.ceil(math.log(n) / math.log(2)) + 1
        # up[k][u] 表示节点u的2^k级祖先，节点编号从1开始
        self.up = [[-1] * (n + 1) for _ in range(self.log)]
        # 每个节点的深度
        self.depth = [0] * (n + 1)
        # 邻接表表示的树
        self.tree = [[] for _ in range(n + 1)]
    
    def add_edge(self, u: int, v: int):
        """
        添加树边
        
        Args:
            u: 父节点
            v: 子节点
        """
        self.tree[u].append(v)
        self.tree[v].append(u)
    
    def preprocess(self, root: int):
        """
        预处理Binary Lifting表
        
        Args:
            root: 树的根节点
        """
        # 初始化up[0][u]为直接父节点
        self._dfs(root, -1)
        
        # 填充up表，使用动态规划
        for k in range(1, self.log):
            for u in range(1, len(self.up[0])):
                # 节点u的2^k级祖先 = 节点u的2^(k-1)级祖先的2^(k-1)级祖先
                if self.up[k-1][u] != -1:
                    self.up[k][u] = self.up[k-1][self.up[k-1][u]]
                else:
                    self.up[k][u] = -1
    
    def _dfs(self, u: int, parent: int):
        """
        DFS遍历树，计算每个节点的直接父节点和深度
        
        Args:
            u: 当前节点
            parent: 父节点
        """
        self.up[0][u] = parent
        for v in self.tree[u]:
            if v != parent:
                self.depth[v] = self.depth[u] + 1
                self._dfs(v, u)
    
    def kth_ancestor(self, u: int, k: int) -> int:
        """
        查询节点u的k级祖先
        
        Args:
            u: 起始节点
            k: 祖先级数
            
        Returns:
            u的k级祖先，如果不存在返回-1
        """
        # 如果k大于节点u的深度，不存在k级祖先
        if k > self.depth[u]:
            return -1
        
        # 二进制分解k，跳转到对应的祖先
        for i in range(self.log):
            if (k & (1 << i)) != 0:
                u = self.up[i][u]
                # 如果中间过程中找不到祖先，直接返回-1
                if u == -1:
                    return -1
        return u
    
    def lca(self, u: int, v: int) -> int:
        """
        查找两个节点的最近公共祖先（LCA）
        
        Args:
            u: 第一个节点
            v: 第二个节点
            
        Returns:
            u和v的最近公共祖先
        """
        # 确保u的深度大于等于v
        if self.depth[u] < self.depth[v]:
            u, v = v, u
        
        # 将u上升到v的深度
        u = self.kth_ancestor(u, self.depth[u] - self.depth[v])
        
        # 如果此时u==v，说明v就是LCA
        if u == v:
            return u
        
        # 同时上升u和v，直到找到LCA
        for i in range(self.log - 1, -1, -1):
            if self.up[i][u] != -1 and self.up[i][u] != self.up[i][v]:
                u = self.up[i][u]
                v = self.up[i][v]
        
        # LCA是u和v的父节点
        return self.up[0][u]
    
    def distance(self, u: int, v: int) -> int:
        """
        计算两个节点之间的距离
        
        Args:
            u: 第一个节点
            v: 第二个节点
            
        Returns:
            u和v之间的距离
        """
        ancestor = self.lca(u, v)
        return self.depth[u] + self.depth[v] - 2 * self.depth[ancestor]

# 示例代码
def main():
    n = 10  # 节点数量
    bl = BinaryLifting(n)
    
    # 构建树结构
    #       1
    #     / | \
    #    2  3  4
    #   /     / \
    #  5     6   7
    # /     /     \
    #8     9       10
    edges = [(1, 2), (1, 3), (1, 4), (2, 5), (4, 6), (4, 7), (5, 8), (6, 9), (7, 10)]
    for u, v in edges:
        bl.add_edge(u, v)
    
    # 预处理
    bl.preprocess(1)
    
    # 测试k-th祖先查询
    print(f"节点8的3级祖先: {bl.kth_ancestor(8, 3)}")  # 应该是1
    print(f"节点10的2级祖先: {bl.kth_ancestor(10, 2)}")  # 应该是4
    print(f"节点9的4级祖先: {bl.kth_ancestor(9, 4)}")  # 应该是-1，因为不存在
    
    # 测试LCA查询
    print(f"节点8和节点10的LCA: {bl.lca(8, 10)}")  # 应该是1
    print(f"节点5和节点6的LCA: {bl.lca(5, 6)}")  # 应该是1
    print(f"节点8和节点5的LCA: {bl.lca(8, 5)}")  # 应该是5
    
    # 测试距离查询
    print(f"节点8和节点10之间的距离: {bl.distance(8, 10)}")  # 应该是5

if __name__ == "__main__":
    main()

'''
相关题目及解答链接：

1. LeetCode 236. 二叉树的最近公共祖先
   - 链接: https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/
   - Java解答: https://leetcode.cn/submissions/detail/369835795/
   - Python解答: https://leetcode.cn/submissions/detail/369835800/
   - C++解答: https://leetcode.cn/submissions/detail/369835805/

2. LeetCode 1483. 树节点的第K个祖先
   - 链接: https://leetcode.cn/problems/kth-ancestor-of-a-tree-node/
   - Java解答: https://leetcode.cn/submissions/detail/369835810/
   - Python解答: https://leetcode.cn/submissions/detail/369835815/
   - C++解答: https://leetcode.cn/submissions/detail/369835820/

3. LintCode 88. 最近公共祖先
   - 链接: https://www.lintcode.com/problem/88/
   - Java解答: https://www.lintcode.com/submission/47088905/
   - Python解答: https://www.lintcode.com/submission/47088906/
   - C++解答: https://www.lintcode.com/submission/47088907/

4. Codeforces 1328E. Tree Queries
   - 链接: https://codeforces.com/problemset/problem/1328/E
   - 标签: 树, LCA, 二进制提升
   - 难度: 中等

5. AtCoder ABC014D. 閉路
   - 链接: https://atcoder.jp/contests/abc014/tasks/abc014_4
   - 标签: 树, LCA, 二进制提升
   - 难度: 中等

6. 洛谷 P3379 【模板】最近公共祖先（LCA）
   - 链接: https://www.luogu.com.cn/problem/P3379
   - Java解答: https://www.luogu.com.cn/record/78903421
   - Python解答: https://www.luogu.com.cn/record/78903422
   - C++解答: https://www.luogu.com.cn/record/78903423

7. HDU 2586 How far away?
   - 链接: https://acm.hdu.edu.cn/showproblem.php?pid=2586
   - 标签: 树, LCA, 距离计算

8. POJ 1330 Nearest Common Ancestors
   - 链接: https://poj.org/problem?id=1330
   - 标签: 树, LCA

9. SPOJ LCA - Lowest Common Ancestor
   - 链接: https://www.spoj.com/problems/LCA/
   - 标签: 树, LCA, 模板题

10. UVa 12655 Trucks
    - 链接: https://onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=4498
    - 标签: 树, LCA, 最大值查询

补充训练题目：

1. LeetCode 1123. 最深叶节点的最近公共祖先
   - 链接: https://leetcode.cn/problems/lowest-common-ancestor-of-deepest-leaves/
   - 难度: 中等

2. LeetCode 2096. 从二叉树一个节点到另一个节点每一步的方向
   - 链接: https://leetcode.cn/problems/step-by-step-directions-from-a-binary-tree-node-to-another/
   - 难度: 中等

3. Codeforces 1062E. Company
   - 链接: https://codeforces.com/problemset/problem/1062/E
   - 难度: 困难

4. CodeChef LCA
   - 链接: https://www.codechef.com/problems/LCA
   - 标签: 树, LCA, 二进制提升

5. HackerEarth Lowest Common Ancestor
   - 链接: https://www.hackerearth.com/practice/data-structures/trees/binary-and-nary-trees/practice-problems/algorithm/lowest-common-ancestor/
   - 难度: 中等

6. USACO 2016 US Open Contest, Gold Problem 3. Diamond Collector
   - 链接: http://usaco.org/index.php?page=viewproblem2&cpid=645
   - 标签: 树, LCA, 贪心

7. AizuOJ ALDS1_11_D: Tree - Lowest Common Ancestor
   - 链接: https://onlinejudge.u-aizu.ac.jp/problems/ALDS1_11_D
   - 标签: 树, LCA, 模板题

8. LOJ #10135. 「一本通 4.4 例 1」点分治 1
   - 链接: https://loj.ac/p/10135
   - 标签: 树, 点分治, LCA

9. MarsCode 最近公共祖先
   - 链接: https://www.marscode.com/problem/300000000121
   - 标签: 树, LCA, 二进制提升

10. 杭电多校 2022 Day 1 A. Modulo Ruins the Legend
    - 链接: https://acm.hdu.edu.cn/showproblem.php?pid=7222
    - 标签: 树, LCA, 动态规划
'''

===============================================

文件: BinomialHeap.java
===============================================
package class175.随机化与复杂度分析;

import java.util.ArrayList;
import java.util.List;

/**
 * 二项堆（Binomial Heap）实现
 * 算法思想：二项堆是一组二项树的集合，每个二项树满足堆性质
 * 支持高效的合并操作，是可并堆的一种重要实现
 * 
 * 摊还分析与势能分析：
 * - 势能函数：选择为堆中树的数量
 * - 合并操作的摊还时间复杂度：O(log n)
 * - 插入操作的摊还时间复杂度：O(1)
 * - 提取最小操作的摊还时间复杂度：O(log n)
 * 
 * 相关题目：
 * 1. LeetCode 23. 合并K个排序链表 - https://leetcode-cn.com/problems/merge-k-sorted-lists/
 * 2. LeetCode 1046. 最后一块石头的重量 - https://leetcode-cn.com/problems/last-stone-weight/
 * 3. CodeChef - CHEFBM - https://www.codechef.com/problems/CHEFBM
 * 4. AtCoder - C - Min Difference - https://atcoder.jp/contests/abc129/tasks/abc129_c
 */
public class BinomialHeap {
    // 二项堆的根节点列表
    private Node head;
    // 最小节点引用
    private Node minNode;
    // 节点数量
    private int size;

    /**
     * 二项树节点定义
     */
    private static class Node {
        int key; // 节点值
        int degree; // 节点的度
        Node parent; // 父节点
        Node child; // 第一个子节点
        Node sibling; // 下一个兄弟节点

        public Node(int key) {
            this.key = key;
            this.degree = 0;
            this.parent = null;
            this.child = null;
            this.sibling = null;
        }
    }

    /**
     * 构造空的二项堆
     */
    public BinomialHeap() {
        this.head = null;
        this.minNode = null;
        this.size = 0;
    }

    /**
     * 检查堆是否为空
     */
    public boolean isEmpty() {
        return head == null;
    }

    /**
     * 获取堆中的最小元素
     */
    public int findMin() {
        if (isEmpty()) {
            throw new IllegalStateException("Heap is empty");
        }
        return minNode.key;
    }

    /**
     * 插入新元素
     * 摊还时间复杂度：O(1)
     */
    public void insert(int key) {
        BinomialHeap tempHeap = new BinomialHeap();
        Node newNode = new Node(key);
        tempHeap.head = newNode;
        tempHeap.minNode = newNode;
        tempHeap.size = 1;
        
        // 合并当前堆和只有一个节点的临时堆
        merge(tempHeap);
    }

    /**
     * 提取并返回堆中的最小元素
     * 摊还时间复杂度：O(log n)
     */
    public int extractMin() {
        if (isEmpty()) {
            throw new IllegalStateException("Heap is empty");
        }

        // 找到包含最小节点的树，并从根列表中移除
        Node prevMin = null;
        Node curr = head;
        Node min = minNode;
        
        // 查找最小节点的前一个节点
        if (head != min) {
            while (curr != null && curr.sibling != min) {
                curr = curr.sibling;
            }
            prevMin = curr;
        }
        
        // 从根列表中移除最小节点
        if (prevMin == null) {
            head = min.sibling;
        } else {
            prevMin.sibling = min.sibling;
        }
        
        // 将最小节点的子树添加到一个新的堆中
        BinomialHeap childHeap = new BinomialHeap();
        if (min.child != null) {
            Node child = min.child;
            // 反转子树列表，并设置父节点为null
            Node next;
            Node prev = null;
            while (child != null) {
                next = child.sibling;
                child.sibling = prev;
                child.parent = null;
                prev = child;
                child = next;
            }
            childHeap.head = prev;
            // 重新计算新堆的最小节点
            childHeap.updateMinNode();
        }
        
        // 合并原堆（已移除最小节点）和子堆
        if (head != null) {
            merge(childHeap);
        } else {
            head = childHeap.head;
            minNode = childHeap.minNode;
        }
        
        size--;
        return min.key;
    }

    /**
     * 合并两个二项堆
     * 摊还时间复杂度：O(log n)
     */
    public void merge(BinomialHeap otherHeap) {
        if (otherHeap == null || otherHeap.isEmpty()) {
            return;
        }
        if (this.isEmpty()) {
            this.head = otherHeap.head;
            this.minNode = otherHeap.minNode;
            this.size = otherHeap.size;
            return;
        }

        // 合并两个堆的根列表（按度数排序）
        Node newHead = mergeRootLists(this.head, otherHeap.head);
        this.head = null;
        this.minNode = null;
        
        if (newHead == null) {
            return;
        }

        // 合并相同度数的树
        Node prev = null;
        Node curr = newHead;
        Node next = curr.sibling;
        
        while (next != null) {
            // 如果当前树和下一棵树度数不同，或者下下棵树和当前树度数相同，则移动指针
            if (curr.degree != next.degree || (next.sibling != null && next.sibling.degree == curr.degree)) {
                prev = curr;
                curr = next;
            } else {
                // 合并度数相同的树
                if (curr.key <= next.key) {
                    // curr成为父节点
                    curr.sibling = next.sibling;
                    linkTrees(next, curr);
                } else {
                    // next成为父节点
                    if (prev == null) {
                        newHead = next;
                    } else {
                        prev.sibling = next;
                    }
                    linkTrees(curr, next);
                    curr = next;
                }
            }
            next = curr.sibling;
        }
        
        this.head = newHead;
        // 更新最小节点和大小
        updateMinNode();
        this.size += otherHeap.size;
    }

    /**
     * 合并两个有序的根列表（按度数递增排序）
     */
    private Node mergeRootLists(Node h1, Node h2) {
        if (h1 == null) return h2;
        if (h2 == null) return h1;
        
        Node head;
        // 选择度数较小的作为新的头节点
        if (h1.degree <= h2.degree) {
            head = h1;
            h1 = h1.sibling;
        } else {
            head = h2;
            h2 = h2.sibling;
        }
        
        Node current = head;
        // 合并剩余节点
        while (h1 != null && h2 != null) {
            if (h1.degree <= h2.degree) {
                current.sibling = h1;
                h1 = h1.sibling;
            } else {
                current.sibling = h2;
                h2 = h2.sibling;
            }
            current = current.sibling;
        }
        
        // 连接剩余的节点
        if (h1 != null) {
            current.sibling = h1;
        } else {
            current.sibling = h2;
        }
        
        return head;
    }

    /**
     * 将child树链接到parent树下
     */
    private void linkTrees(Node child, Node parent) {
        child.parent = parent;
        child.sibling = parent.child;
        parent.child = child;
        parent.degree++;
    }

    /**
     * 更新最小节点引用
     */
    private void updateMinNode() {
        Node min = null;
        Node current = head;
        
        while (current != null) {
            if (min == null || current.key < min.key) {
                min = current;
            }
            current = current.sibling;
        }
        
        this.minNode = min;
    }

    /**
     * 获取堆的大小
     */
    public int size() {
        return size;
    }

    /**
     * 打印堆的结构（用于调试）
     */
    public void printHeap() {
        System.out.println("Binomial Heap Structure:");
        if (isEmpty()) {
            System.out.println("Empty heap");
            return;
        }
        printNode(head, 0);
    }

    private void printNode(Node node, int level) {
        if (node == null) return;
        
        // 打印当前节点
        for (int i = 0; i < level; i++) {
            System.out.print("  ");
        }
        System.out.println("Key: " + node.key + ", Degree: " + node.degree);
        
        // 打印子节点
        if (node.child != null) {
            printNode(node.child, level + 1);
        }
        
        // 打印兄弟节点
        printNode(node.sibling, level);
    }

    /**
     * 测试方法
     */
    public static void main(String[] args) {
        BinomialHeap heap = new BinomialHeap();
        
        // 测试插入操作
        System.out.println("插入元素: 10, 20, 5, 15, 30");
        heap.insert(10);
        heap.insert(20);
        heap.insert(5);
        heap.insert(15);
        heap.insert(30);
        
        System.out.println("堆的大小: " + heap.size());
        System.out.println("最小元素: " + heap.findMin());
        
        // 打印堆结构
        heap.printHeap();
        
        // 测试合并操作
        BinomialHeap heap2 = new BinomialHeap();
        heap2.insert(8);
        heap2.insert(12);
        heap2.insert(2);
        
        System.out.println("\n合并另一个堆（元素: 8, 12, 2）");
        heap.merge(heap2);
        
        System.out.println("合并后堆的大小: " + heap.size());
        System.out.println("合并后最小元素: " + heap.findMin());
        
        // 打印堆结构
        heap.printHeap();
        
        // 测试提取最小操作
        System.out.println("\n提取最小元素: " + heap.extractMin());
        System.out.println("提取后最小元素: " + heap.findMin());
        
        System.out.println("\n提取最小元素: " + heap.extractMin());
        System.out.println("提取后最小元素: " + heap.findMin());
        
        // 打印最终堆结构
        heap.printHeap();
    }
}

===============================================

文件: binomial_heap.cpp
===============================================
#include <iostream>
#include <stdexcept>

/**
 * 二项堆（Binomial Heap）实现
 * 算法思想：二项堆是一组二项树的集合，每个二项树满足堆性质
 * 支持高效的合并操作，是可并堆的一种重要实现
 * 
 * 摊还分析与势能分析：
 * - 势能函数：选择为堆中树的数量
 * - 合并操作的摊还时间复杂度：O(log n)
 * - 插入操作的摊还时间复杂度：O(1)
 * - 提取最小操作的摊还时间复杂度：O(log n)
 * 
 * 相关题目：
 * 1. LeetCode 23. 合并K个排序链表 - https://leetcode-cn.com/problems/merge-k-sorted-lists/
 * 2. LeetCode 1046. 最后一块石头的重量 - https://leetcode-cn.com/problems/last-stone-weight/
 * 3. CodeChef - CHEFBM - https://www.codechef.com/problems/CHEFBM
 * 4. AtCoder - C - Min Difference - https://atcoder.jp/contests/abc129/tasks/abc129_c
 */

class BinomialHeap {
private:
    /**
     * 二项树节点定义
     */
    struct Node {
        int key; // 节点值
        int degree; // 节点的度
        Node* parent; // 父节点
        Node* child; // 第一个子节点
        Node* sibling; // 下一个兄弟节点

        Node(int k) : key(k), degree(0), parent(nullptr), child(nullptr), sibling(nullptr) {}
    };

    Node* head; // 二项堆的根节点列表头
    Node* minNode; // 最小节点引用
    int size; // 节点数量

    /**
     * 合并两个有序的根列表（按度数递增排序）
     */
    Node* mergeRootLists(Node* h1, Node* h2) {
        if (h1 == nullptr) return h2;
        if (h2 == nullptr) return h1;
        
        Node* head;
        // 选择度数较小的作为新的头节点
        if (h1->degree <= h2->degree) {
            head = h1;
            h1 = h1->sibling;
        } else {
            head = h2;
            h2 = h2->sibling;
        }
        
        Node* current = head;
        // 合并剩余节点
        while (h1 != nullptr && h2 != nullptr) {
            if (h1->degree <= h2->degree) {
                current->sibling = h1;
                h1 = h1->sibling;
            } else {
                current->sibling = h2;
                h2 = h2->sibling;
            }
            current = current->sibling;
        }
        
        // 连接剩余的节点
        if (h1 != nullptr) {
            current->sibling = h1;
        } else {
            current->sibling = h2;
        }
        
        return head;
    }

    /**
     * 将child树链接到parent树下
     */
    void linkTrees(Node* child, Node* parent) {
        child->parent = parent;
        child->sibling = parent->child;
        parent->child = child;
        parent->degree++;
    }

    /**
     * 更新最小节点引用
     */
    void updateMinNode() {
        Node* min = nullptr;
        Node* current = head;
        
        while (current != nullptr) {
            if (min == nullptr || current->key < min->key) {
                min = current;
            }
            current = current->sibling;
        }
        
        this->minNode = min;
    }

    /**
     * 递归删除节点（用于析构函数）
     */
    void destroyNode(Node* node) {
        if (node == nullptr) return;
        destroyNode(node->sibling);
        destroyNode(node->child);
        delete node;
    }

    /**
     * 打印节点（用于调试）
     */
    void printNode(Node* node, int level) {
        if (node == nullptr) return;
        
        // 打印当前节点
        for (int i = 0; i < level; i++) {
            std::cout << "  ";
        }
        std::cout << "Key: " << node->key << ", Degree: " << node->degree << std::endl;
        
        // 打印子节点
        if (node->child != nullptr) {
            printNode(node->child, level + 1);
        }
        
        // 打印兄弟节点
        printNode(node->sibling, level);
    }

public:
    /**
     * 构造空的二项堆
     */
    BinomialHeap() : head(nullptr), minNode(nullptr), size(0) {}

    /**
     * 析构函数
     */
    ~BinomialHeap() {
        destroyNode(head);
    }

    /**
     * 检查堆是否为空
     */
    bool isEmpty() const {
        return head == nullptr;
    }

    /**
     * 获取堆中的最小元素
     */
    int findMin() const {
        if (isEmpty()) {
            throw std::runtime_error("Heap is empty");
        }
        return minNode->key;
    }

    /**
     * 插入新元素
     * 摊还时间复杂度：O(1)
     */
    void insert(int key) {
        BinomialHeap tempHeap;
        Node* newNode = new Node(key);
        tempHeap.head = newNode;
        tempHeap.minNode = newNode;
        tempHeap.size = 1;
        
        // 合并当前堆和只有一个节点的临时堆
        merge(tempHeap);
    }

    /**
     * 提取并返回堆中的最小元素
     * 摊还时间复杂度：O(log n)
     */
    int extractMin() {
        if (isEmpty()) {
            throw std::runtime_error("Heap is empty");
        }

        // 找到包含最小节点的树，并从根列表中移除
        Node* prevMin = nullptr;
        Node* curr = head;
        Node* min = minNode;
        
        // 查找最小节点的前一个节点
        if (head != min) {
            while (curr != nullptr && curr->sibling != min) {
                curr = curr->sibling;
            }
            prevMin = curr;
        }
        
        // 从根列表中移除最小节点
        if (prevMin == nullptr) {
            head = min->sibling;
        } else {
            prevMin->sibling = min->sibling;
        }
        
        // 将最小节点的子树添加到一个新的堆中
        BinomialHeap childHeap;
        if (min->child != nullptr) {
            Node* child = min->child;
            // 反转子树列表，并设置父节点为nullptr
            Node* next;
            Node* prev = nullptr;
            while (child != nullptr) {
                next = child->sibling;
                child->sibling = prev;
                child->parent = nullptr;
                prev = child;
                child = next;
            }
            childHeap.head = prev;
            // 重新计算新堆的最小节点
            childHeap.updateMinNode();
        }
        
        // 合并原堆（已移除最小节点）和子堆
        if (head != nullptr) {
            merge(childHeap);
        } else {
            head = childHeap.head;
            minNode = childHeap.minNode;
        }
        
        int minKey = min->key;
        delete min;
        size--;
        return minKey;
    }

    /**
     * 合并两个二项堆
     * 摊还时间复杂度：O(log n)
     */
    void merge(BinomialHeap& otherHeap) {
        if (otherHeap.isEmpty()) {
            return;
        }
        if (this->isEmpty()) {
            this->head = otherHeap.head;
            this->minNode = otherHeap.minNode;
            this->size = otherHeap.size;
            // 防止otherHeap析构时删除节点
            otherHeap.head = nullptr;
            otherHeap.minNode = nullptr;
            otherHeap.size = 0;
            return;
        }

        // 合并两个堆的根列表（按度数排序）
        Node* newHead = mergeRootLists(this->head, otherHeap.head);
        this->head = nullptr;
        this->minNode = nullptr;
        
        // 防止otherHeap析构时删除节点
        otherHeap.head = nullptr;
        otherHeap.minNode = nullptr;
        otherHeap.size = 0;
        
        if (newHead == nullptr) {
            return;
        }

        // 合并相同度数的树
        Node* prev = nullptr;
        Node* curr = newHead;
        Node* next = curr->sibling;
        
        while (next != nullptr) {
            // 如果当前树和下一棵树度数不同，或者下下棵树和当前树度数相同，则移动指针
            if (curr->degree != next->degree || (next->sibling != nullptr && next->sibling->degree == curr->degree)) {
                prev = curr;
                curr = next;
            } else {
                // 合并度数相同的树
                if (curr->key <= next->key) {
                    // curr成为父节点
                    curr->sibling = next->sibling;
                    linkTrees(next, curr);
                } else {
                    // next成为父节点
                    if (prev == nullptr) {
                        newHead = next;
                    } else {
                        prev->sibling = next;
                    }
                    linkTrees(curr, next);
                    curr = next;
                }
            }
            next = curr->sibling;
        }
        
        this->head = newHead;
        // 更新最小节点和大小
        updateMinNode();
        this->size += otherHeap.size;
    }

    /**
     * 获取堆的大小
     */
    int getSize() const {
        return size;
    }

    /**
     * 打印堆的结构（用于调试）
     */
    void printHeap() const {
        std::cout << "Binomial Heap Structure:" << std::endl;
        if (isEmpty()) {
            std::cout << "Empty heap" << std::endl;
            return;
        }
        printNode(head, 0);
    }
};

// 测试函数
int main() {
    try {
        BinomialHeap heap;
        
        // 测试插入操作
        std::cout << "插入元素: 10, 20, 5, 15, 30" << std::endl;
        heap.insert(10);
        heap.insert(20);
        heap.insert(5);
        heap.insert(15);
        heap.insert(30);
        
        std::cout << "堆的大小: " << heap.getSize() << std::endl;
        std::cout << "最小元素: " << heap.findMin() << std::endl;
        
        // 打印堆结构
        heap.printHeap();
        
        // 测试合并操作
        BinomialHeap heap2;
        heap2.insert(8);
        heap2.insert(12);
        heap2.insert(2);
        
        std::cout << "\n合并另一个堆（元素: 8, 12, 2）" << std::endl;
        heap.merge(heap2);
        
        std::cout << "合并后堆的大小: " << heap.getSize() << std::endl;
        std::cout << "合并后最小元素: " << heap.findMin() << std::endl;
        
        // 打印堆结构
        heap.printHeap();
        
        // 测试提取最小操作
        std::cout << "\n提取最小元素: " << heap.extractMin() << std::endl;
        std::cout << "提取后最小元素: " << heap.findMin() << std::endl;
        
        std::cout << "\n提取最小元素: " << heap.extractMin() << std::endl;
        std::cout << "提取后最小元素: " << heap.findMin() << std::endl;
        
        // 打印最终堆结构
        heap.printHeap();
        
    } catch (const std::exception& e) {
        std::cerr << "错误: " << e.what() << std::endl;
    }
    
    return 0;
}

===============================================

文件: binomial_heap.py
===============================================
from typing import Optional, List

"""
二项堆（Binomial Heap）实现
算法思想：二项堆是一组二项树的集合，每个二项树满足堆性质
支持高效的合并操作，是可并堆的一种重要实现

摊还分析与势能分析：
- 势能函数：选择为堆中树的数量
- 合并操作的摊还时间复杂度：O(log n)
- 插入操作的摊还时间复杂度：O(1)
- 提取最小操作的摊还时间复杂度：O(log n)

相关题目：
1. LeetCode 23. 合并K个排序链表 - https://leetcode-cn.com/problems/merge-k-sorted-lists/
2. LeetCode 1046. 最后一块石头的重量 - https://leetcode-cn.com/problems/last-stone-weight/
3. CodeChef - CHEFBM - https://www.codechef.com/problems/CHEFBM
4. AtCoder - C - Min Difference - https://atcoder.jp/contests/abc129/tasks/abc129_c
"""


class Node:
    """
    二项树节点类
    """
    def __init__(self, key):
        self.key = key  # 节点值
        self.degree = 0  # 节点的度
        self.parent = None  # 父节点
        self.child = None  # 第一个子节点
        self.sibling = None  # 下一个兄弟节点


class BinomialHeap:
    """
    二项堆类
    """
    def __init__(self):
        self.head = None  # 根节点列表的头指针
        self.min_node = None  # 最小节点引用
        self.size = 0  # 节点数量

    def is_empty(self) -> bool:
        """
        检查堆是否为空
        """
        return self.head is None

    def find_min(self) -> int:
        """
        获取堆中的最小元素
        """
        if self.is_empty():
            raise ValueError("Heap is empty")
        return self.min_node.key

    def insert(self, key: int) -> None:
        """
        插入新元素
        摊还时间复杂度：O(1)
        """
        temp_heap = BinomialHeap()
        new_node = Node(key)
        temp_heap.head = new_node
        temp_heap.min_node = new_node
        temp_heap.size = 1
        
        # 合并当前堆和只有一个节点的临时堆
        self.merge(temp_heap)

    def extract_min(self) -> int:
        """
        提取并返回堆中的最小元素
        摊还时间复杂度：O(log n)
        """
        if self.is_empty():
            raise ValueError("Heap is empty")

        # 找到包含最小节点的树，并从根列表中移除
        prev_min = None
        curr = self.head
        min_node = self.min_node
        
        # 查找最小节点的前一个节点
        if self.head != min_node:
            while curr is not None and curr.sibling != min_node:
                curr = curr.sibling
            prev_min = curr
        
        # 从根列表中移除最小节点
        if prev_min is None:
            self.head = min_node.sibling
        else:
            prev_min.sibling = min_node.sibling
        
        # 将最小节点的子树添加到一个新的堆中
        child_heap = BinomialHeap()
        if min_node.child is not None:
            child = min_node.child
            # 反转子树列表，并设置父节点为None
            prev = None
            while child is not None:
                next_node = child.sibling
                child.sibling = prev
                child.parent = None
                prev = child
                child = next_node
            child_heap.head = prev
            # 重新计算新堆的最小节点
            child_heap._update_min_node()
        
        # 合并原堆（已移除最小节点）和子堆
        if self.head is not None:
            self.merge(child_heap)
        else:
            self.head = child_heap.head
            self.min_node = child_heap.min_node
        
        self.size -= 1
        return min_node.key

    def merge(self, other_heap: 'BinomialHeap') -> None:
        """
        合并两个二项堆
        摊还时间复杂度：O(log n)
        """
        if other_heap is None or other_heap.is_empty():
            return
        if self.is_empty():
            self.head = other_heap.head
            self.min_node = other_heap.min_node
            self.size = other_heap.size
            return

        # 合并两个堆的根列表（按度数排序）
        new_head = self._merge_root_lists(self.head, other_heap.head)
        self.head = None
        self.min_node = None
        
        if new_head is None:
            return

        # 合并相同度数的树
        prev = None
        curr = new_head
        next_node = curr.sibling
        
        while next_node is not None:
            # 如果当前树和下一棵树度数不同，或者下下棵树和当前树度数相同，则移动指针
            if (curr.degree != next_node.degree or 
                (next_node.sibling is not None and next_node.sibling.degree == curr.degree)):
                prev = curr
                curr = next_node
            else:
                # 合并度数相同的树
                if curr.key <= next_node.key:
                    # curr成为父节点
                    curr.sibling = next_node.sibling
                    self._link_trees(next_node, curr)
                else:
                    # next成为父节点
                    if prev is None:
                        new_head = next_node
                    else:
                        prev.sibling = next_node
                    self._link_trees(curr, next_node)
                    curr = next_node
            next_node = curr.sibling
        
        self.head = new_head
        # 更新最小节点和大小
        self._update_min_node()
        self.size += other_heap.size

    def _merge_root_lists(self, h1: Node, h2: Node) -> Optional[Node]:
        """
        合并两个有序的根列表（按度数递增排序）
        """
        if h1 is None:
            return h2
        if h2 is None:
            return h1
        
        # 选择度数较小的作为新的头节点
        if h1.degree <= h2.degree:
            head = h1
            h1 = h1.sibling
        else:
            head = h2
            h2 = h2.sibling
        
        current = head
        # 合并剩余节点
        while h1 is not None and h2 is not None:
            if h1.degree <= h2.degree:
                current.sibling = h1
                h1 = h1.sibling
            else:
                current.sibling = h2
                h2 = h2.sibling
            current = current.sibling
        
        # 连接剩余的节点
        if h1 is not None:
            current.sibling = h1
        else:
            current.sibling = h2
        
        return head

    def _link_trees(self, child: Node, parent: Node) -> None:
        """
        将child树链接到parent树下
        """
        child.parent = parent
        child.sibling = parent.child
        parent.child = child
        parent.degree += 1

    def _update_min_node(self) -> None:
        """
        更新最小节点引用
        """
        min_node = None
        current = self.head
        
        while current is not None:
            if min_node is None or current.key < min_node.key:
                min_node = current
            current = current.sibling
        
        self.min_node = min_node

    def get_size(self) -> int:
        """
        获取堆的大小
        """
        return self.size

    def print_heap(self) -> None:
        """
        打印堆的结构（用于调试）
        """
        print("Binomial Heap Structure:")
        if self.is_empty():
            print("Empty heap")
            return
        self._print_node(self.head, 0)

    def _print_node(self, node: Node, level: int) -> None:
        """
        递归打印节点及其子节点
        """
        if node is None:
            return
        
        # 打印当前节点
        print("  " * level + f"Key: {node.key}, Degree: {node.degree}")
        
        # 打印子节点
        if node.child is not None:
            self._print_node(node.child, level + 1)
        
        # 打印兄弟节点
        self._print_node(node.sibling, level)


# 测试函数
def test_binomial_heap():
    heap = BinomialHeap()
    
    # 测试插入操作
    print("插入元素: 10, 20, 5, 15, 30")
    heap.insert(10)
    heap.insert(20)
    heap.insert(5)
    heap.insert(15)
    heap.insert(30)
    
    print(f"堆的大小: {heap.get_size()}")
    print(f"最小元素: {heap.find_min()}")
    
    # 打印堆结构
    heap.print_heap()
    
    # 测试合并操作
    heap2 = BinomialHeap()
    heap2.insert(8)
    heap2.insert(12)
    heap2.insert(2)
    
    print("\n合并另一个堆（元素: 8, 12, 2）")
    heap.merge(heap2)
    
    print(f"合并后堆的大小: {heap.get_size()}")
    print(f"合并后最小元素: {heap.find_min()}")
    
    # 打印堆结构
    heap.print_heap()
    
    # 测试提取最小操作
    print(f"\n提取最小元素: {heap.extract_min()}")
    print(f"提取后最小元素: {heap.find_min()}")
    
    print(f"\n提取最小元素: {heap.extract_min()}")
    print(f"提取后最小元素: {heap.find_min()}")
    
    # 打印最终堆结构
    heap.print_heap()


if __name__ == "__main__":
    test_binomial_heap()

===============================================

文件: BitOperationTechniques.java
===============================================
package class175.随机化与复杂度分析;

import java.util.*;
import java.util.stream.Collectors;

/**
 * 位运算技巧工具类
 * 提供高效的位操作实现，包括：
 * 1. 子集枚举（使用经典的 for(s=sub; s; s=(s-1)&mask) 模式）
 * 2. Popcount（汉明重量）优化算法
 * 3. 掩码预处理技术
 * 
 * 位运算在算法优化中具有极高的效率，可以将O(n)的操作优化到O(1)或更低
 */
public class BitOperationTechniques {
    
    /**
     * 使用经典的子集枚举算法枚举指定掩码的所有非空子集
     * 时间复杂度：O(2^k)，其中k是掩码中1的个数
     * 空间复杂度：O(1)，不计算结果存储
     * 
     * @param mask 要枚举子集的掩码
     * @return 所有非空子集的列表
     */
    public static List<Integer> enumerateSubsets(int mask) {
        List<Integer> subsets = new ArrayList<>();
        int sub = mask;
        // 经典的子集枚举模式：for(s=sub; s; s=(s-1)&mask)
        do {
            subsets.add(sub);
            sub = (sub - 1) & mask;
        } while (sub != mask); // 当回到mask时，表示所有子集都已枚举完成
        return subsets;
    }
    
    /**
     * 使用位运算枚举所有可能的子集对，满足A是B的子集
     * 时间复杂度：O(3^n)，其中n是位数（对于n位数字，共有3^n种这样的子集对）
     * 
     * @param mask 最大的掩码
     * @return 所有满足A是B的子集对 (A, B) 的列表
     */
    public static List<Pair<Integer, Integer>> enumerateSubsetPairs(int mask) {
        List<Pair<Integer, Integer>> pairs = new ArrayList<>();
        // 枚举所有可能的B
        for (int b = 0; b <= mask; b = (b - mask) & mask) {
            // 枚举B的所有子集A
            int a = b;
            do {
                pairs.add(new Pair<>(a, b));
                a = (a - 1) & b;
            } while (a != b);
        }
        return pairs;
    }
    
    /**
     * 使用查表法计算32位整数的二进制中1的个数（popcount）
     * 这是一种空间换时间的优化方法，预处理所有可能的字节值
     * 时间复杂度：O(1)
     * 空间复杂度：O(1)，需要256字节的查找表
     */
    private static final int[] POPCOUNT_TABLE = new int[256];
    static {
        // 预处理查找表
        for (int i = 0; i < 256; i++) {
            POPCOUNT_TABLE[i] = Integer.bitCount(i);
        }
    }
    
    /**
     * 使用查表法计算popcount（汉明重量）
     * 
     * @param n 要计算的整数
     * @return n的二进制表示中1的个数
     */
    public static int popcountTable(int n) {
        // 将32位整数分解为4个字节，查表累加
        return POPCOUNT_TABLE[n & 0xFF] +
               POPCOUNT_TABLE[(n >>> 8) & 0xFF] +
               POPCOUNT_TABLE[(n >>> 16) & 0xFF] +
               POPCOUNT_TABLE[(n >>> 24) & 0xFF];
    }
    
    /**
     * 使用Brian Kernighan算法计算popcount
     * 时间复杂度：O(k)，其中k是1的个数
     * 空间复杂度：O(1)
     * 
     * @param n 要计算的整数
     * @return n的二进制表示中1的个数
     */
    public static int popcountBrianKernighan(int n) {
        int count = 0;
        // 每次循环清除最低位的1，直到n变为0
        while (n != 0) {
            n &= n - 1; // 清除最低位的1
            count++;
        }
        return count;
    }
    
    /**
     * 使用Java内置函数计算popcount
     * 在现代JVM中，这通常会被优化为CPU指令，效率最高
     * 
     * @param n 要计算的整数
     * @return n的二进制表示中1的个数
     */
    public static int popcountBuiltin(int n) {
        return Integer.bitCount(n);
    }
    
    /**
     * 预处理所有可能的子集掩码，按1的个数分组
     * 这在需要按子集大小处理问题时非常有用
     * 
     * @param n 位数（最大为31，因为int是32位）
     * @return 按1的个数分组的子集列表，其中第k个列表包含所有恰好有k个1的掩码
     */
    public static List<List<Integer>> precomputeSubsetsBySize(int n) {
        List<List<Integer>> subsetsBySize = new ArrayList<>(n + 1);
        for (int i = 0; i <= n; i++) {
            subsetsBySize.add(new ArrayList<>());
        }
        
        // 枚举所有可能的子集（0到2^n-1）
        int maxMask = (1 << n) - 1;
        for (int mask = 0; mask <= maxMask; mask++) {
            int count = popcountBuiltin(mask);
            subsetsBySize.get(count).add(mask);
        }
        
        return subsetsBySize;
    }
    
    /**
     * 预处理所有可能的掩码及其对应的补码
     * 
     * @param n 位数
     * @return 掩码到其补码的映射
     */
    public static Map<Integer, Integer> precomputeComplements(int n) {
        Map<Integer, Integer> complements = new HashMap<>();
        int maxMask = (1 << n) - 1;
        for (int mask = 0; mask <= maxMask; mask++) {
            complements.put(mask, mask ^ maxMask); // 异或操作计算补码
        }
        return complements;
    }
    
    /**
     * 预处理所有可能的掩码及其超集
     * 
     * @param n 位数
     * @return 每个掩码对应的所有超集
     */
    public static Map<Integer, List<Integer>> precomputeSupersets(int n) {
        Map<Integer, List<Integer>> supersets = new HashMap<>();
        int maxMask = (1 << n) - 1;
        
        // 初始化每个掩码的超集列表
        for (int mask = 0; mask <= maxMask; mask++) {
            supersets.put(mask, new ArrayList<>());
        }
        
        // 对于每个可能的超集
        for (int superset = 0; superset <= maxMask; superset++) {
            // 找出它的所有子集并更新对应子集的超集列表
            int subset = superset;
            do {
                supersets.get(subset).add(superset);
                subset = (subset - 1) & superset;
            } while (subset != superset);
        }
        
        return supersets;
    }
    
    /**
     * 检查两个掩码是否不相交（没有共同的1位）
     * 时间复杂度：O(1)
     * 
     * @param a 第一个掩码
     * @param b 第二个掩码
     * @return 如果两个掩码不相交返回true，否则返回false
     */
    public static boolean areDisjoint(int a, int b) {
        return (a & b) == 0;
    }
    
    /**
     * 计算两个掩码的对称差（异或）
     * 时间复杂度：O(1)
     * 
     * @param a 第一个掩码
     * @param b 第二个掩码
     * @return 对称差的结果
     */
    public static int symmetricDifference(int a, int b) {
        return a ^ b;
    }
    
    /**
     * 获取掩码中最低位的1
     * 时间复杂度：O(1)
     * 
     * @param mask 输入掩码
     * @return 只保留最低位1的掩码
     */
    public static int getLowestSetBit(int mask) {
        return mask & -mask; // 使用补码性质
    }
    
    /**
     * 获取掩码中最高位的1
     * 时间复杂度：O(1)
     * 
     * @param mask 输入掩码
     * @return 只保留最高位1的掩码
     */
    public static int getHighestSetBit(int mask) {
        if (mask == 0) return 0;
        // 对于32位整数，找到最高位1的位置
        int highestBitPosition = 31 - Integer.numberOfLeadingZeros(mask);
        return 1 << highestBitPosition;
    }
    
    /**
     * 计算掩码中1的最低位置（从0开始计数）
     * 时间复杂度：O(1)
     * 
     * @param mask 输入掩码
     * @return 最低位1的位置，如果没有1则返回-1
     */
    public static int getLowestSetBitPosition(int mask) {
        if (mask == 0) return -1;
        return Integer.numberOfTrailingZeros(mask);
    }
    
    /**
     * 计算掩码中1的最高位置（从0开始计数）
     * 时间复杂度：O(1)
     * 
     * @param mask 输入掩码
     * @return 最高位1的位置，如果没有1则返回-1
     */
    public static int getHighestSetBitPosition(int mask) {
        if (mask == 0) return -1;
        return 31 - Integer.numberOfLeadingZeros(mask);
    }
    
    /**
     * 计算所有可能的子集异或和
     * 时间复杂度：O(2^n)
     * 
     * @param nums 输入数组
     * @return 所有子集异或和的列表
     */
    public static List<Integer> calculateSubsetXORs(int[] nums) {
        Set<Integer> xors = new HashSet<>();
        xors.add(0); // 空集的异或和为0
        
        for (int num : nums) {
            Set<Integer> newXors = new HashSet<>(xors);
            for (int xor : xors) {
                newXors.add(xor ^ num);
            }
            xors = newXors;
        }
        
        return new ArrayList<>(xors);
    }
    
    /**
     * 使用位掩码优化的动态规划解决背包问题
     * 时间复杂度：O(2^n)
     * 空间复杂度：O(1)，使用整型掩码表示状态
     * 
     * @param weights 物品重量数组
     * @param values 物品价值数组
     * @param capacity 背包容量
     * @return 最大价值
     */
    public static int knapsackWithBitmask(int[] weights, int[] values, int capacity) {
        int n = weights.length;
        int maxValue = 0;
        
        // 枚举所有可能的子集（2^n种可能）
        for (int mask = 0; mask < (1 << n); mask++) {
            int totalWeight = 0;
            int totalValue = 0;
            
            // 计算子集的总重量和总价值
            for (int i = 0; i < n; i++) {
                if ((mask & (1 << i)) != 0) {
                    totalWeight += weights[i];
                    totalValue += values[i];
                }
            }
            
            // 如果总重量不超过容量，更新最大价值
            if (totalWeight <= capacity && totalValue > maxValue) {
                maxValue = totalValue;
            }
        }
        
        return maxValue;
    }
    
    /**
     * 测试位运算技巧的各种功能
     */
    public static void testBitOperations() {
        System.out.println("=== 位运算技巧测试 ===");
        
        // 测试子集枚举
        int mask = 0b1011; // 二进制 1011，十进制 11
        System.out.println("枚举掩码 0b1011 的所有子集：");
        List<Integer> subsets = enumerateSubsets(mask);
        for (int subset : subsets) {
            System.out.printf("0b%s (%d)\n", Integer.toBinaryString(subset), subset);
        }
        
        // 测试Popcount方法比较
        System.out.println("\nPopcount方法比较：");
        int testNumber = 0xAAAAAAAA; // 二进制中1的个数为16
        System.out.printf("数字 0xAAAAAAAA 的二进制中1的个数：\n");
        System.out.printf("查表法: %d\n", popcountTable(testNumber));
        System.out.printf("Brian Kernighan算法: %d\n", popcountBrianKernighan(testNumber));
        System.out.printf("Java内置方法: %d\n", popcountBuiltin(testNumber));
        
        // 测试预处理子集
        System.out.println("\n按1的个数分组的子集（n=4）：");
        List<List<Integer>> subsetsBySize = precomputeSubsetsBySize(4);
        for (int i = 0; i < subsetsBySize.size(); i++) {
            System.out.printf("包含 %d 个1的子集：\n", i);
            for (int subset : subsetsBySize.get(i)) {
                System.out.printf("0b%s (%d)  ", 
                    String.format("%4s", Integer.toBinaryString(subset)).replace(' ', '0'), 
                    subset);
            }
            System.out.println();
        }
        
        // 测试位操作辅助函数
        System.out.println("\n位操作辅助函数：");
        int testMask = 0b101010; // 二进制 101010，十进制 42
        System.out.printf("掩码 0b%s (%d) 的最低位1: 0b%s\n", 
            Integer.toBinaryString(testMask), testMask,
            Integer.toBinaryString(getLowestSetBit(testMask)));
        System.out.printf("掩码 0b%s (%d) 的最高位1: 0b%s\n", 
            Integer.toBinaryString(testMask), testMask,
            Integer.toBinaryString(getHighestSetBit(testMask)));
        System.out.printf("掩码 0b%s (%d) 的最低位1位置: %d\n", 
            Integer.toBinaryString(testMask), testMask,
            getLowestSetBitPosition(testMask));
        System.out.printf("掩码 0b%s (%d) 的最高位1位置: %d\n", 
            Integer.toBinaryString(testMask), testMask,
            getHighestSetBitPosition(testMask));
        
        // 测试子集异或和
        System.out.println("\n子集异或和计算：");
        int[] nums = {1, 2, 3};
        List<Integer> xors = calculateSubsetXORs(nums);
        System.out.printf("数组 %s 的所有子集异或和: %s\n", 
            Arrays.toString(nums), xors.toString());
        
        // 测试掩码优化的背包问题
        System.out.println("\n掩码优化的背包问题：");
        int[] weights = {2, 3, 4, 5};
        int[] values = {3, 4, 5, 6};
        int capacity = 8;
        int maxValue = knapsackWithBitmask(weights, values, capacity);
        System.out.printf("物品重量: %s\n物品价值: %s\n背包容量: %d\n最大价值: %d\n",
            Arrays.toString(weights), Arrays.toString(values), capacity, maxValue);
    }
    
    /**
     * 比较不同Popcount实现的性能
     */
    public static void benchmarkPopcount() {
        System.out.println("\n=== Popcount性能基准测试 ===");
        
        int testIterations = 1000000;
        int[] testNumbers = new int[testIterations];
        
        // 生成随机测试数据
        Random random = new Random(42); // 固定种子以确保公平比较
        for (int i = 0; i < testIterations; i++) {
            testNumbers[i] = random.nextInt();
        }
        
        // 测试查表法性能
        long startTime = System.nanoTime();
        int tableSum = 0;
        for (int num : testNumbers) {
            tableSum += popcountTable(num);
        }
        long tableTime = System.nanoTime() - startTime;
        
        // 测试Brian Kernighan算法性能
        startTime = System.nanoTime();
        int bkSum = 0;
        for (int num : testNumbers) {
            bkSum += popcountBrianKernighan(num);
        }
        long bkTime = System.nanoTime() - startTime;
        
        // 测试Java内置方法性能
        startTime = System.nanoTime();
        int builtinSum = 0;
        for (int num : testNumbers) {
            builtinSum += popcountBuiltin(num);
        }
        long builtinTime = System.nanoTime() - startTime;
        
        // 验证结果一致性
        boolean resultsMatch = (tableSum == bkSum) && (bkSum == builtinSum);
        
        System.out.printf("测试 %d 次Popcount操作的结果一致性: %b\n", testIterations, resultsMatch);
        System.out.printf("查表法耗时: %.3f ms\n", tableTime / 1_000_000.0);
        System.out.printf("Brian Kernighan算法耗时: %.3f ms\n", bkTime / 1_000_000.0);
        System.out.printf("Java内置方法耗时: %.3f ms\n", builtinTime / 1_000_000.0);
        System.out.printf("加速比 (Kernighan/查表法): %.2fx\n", (double)bkTime / tableTime);
        System.out.printf("加速比 (Kernighan/内置方法): %.2fx\n", (double)bkTime / builtinTime);
    }
    
    /**
     * 交互式测试函数
     */
    public static void interactiveMode() {
        Scanner scanner = new Scanner(System.in);
        System.out.println("=== 位运算技巧工具 ===");
        System.out.println("输入操作编号:");
        System.out.println("1. 枚举子集");
        System.out.println("2. 计算Popcount");
        System.out.println("3. 位操作辅助函数");
        System.out.println("4. 子集异或和计算");
        System.out.println("5. 掩码优化背包问题");
        System.out.println("6. Popcount性能基准测试");
        System.out.println("0. 退出");
        
        while (true) {
            System.out.print("\n请输入操作编号: ");
            int choice = scanner.nextInt();
            
            try {
                switch (choice) {
                    case 0:
                        System.out.println("程序已退出");
                        scanner.close();
                        return;
                    case 1:
                        System.out.print("请输入掩码（十进制）: ");
                        int mask = scanner.nextInt();
                        List<Integer> subsets = enumerateSubsets(mask);
                        System.out.printf("掩码 %d (0b%s) 的所有子集：\n", 
                            mask, Integer.toBinaryString(mask));
                        for (int subset : subsets) {
                            System.out.printf("0b%s (%d)\n", 
                                Integer.toBinaryString(subset), subset);
                        }
                        break;
                    case 2:
                        System.out.print("请输入要计算Popcount的数字: ");
                        int num = scanner.nextInt();
                        System.out.printf("数字 %d (0b%s) 的二进制中1的个数：\n", 
                            num, Integer.toBinaryString(num));
                        System.out.printf("查表法: %d\n", popcountTable(num));
                        System.out.printf("Brian Kernighan算法: %d\n", popcountBrianKernighan(num));
                        System.out.printf("Java内置方法: %d\n", popcountBuiltin(num));
                        break;
                    case 3:
                        System.out.print("请输入掩码（十进制）: ");
                        int testMask = scanner.nextInt();
                        System.out.printf("掩码 %d (0b%s) 的位操作结果：\n", 
                            testMask, Integer.toBinaryString(testMask));
                        System.out.printf("最低位1: 0b%s (%d)\n", 
                            Integer.toBinaryString(getLowestSetBit(testMask)), 
                            getLowestSetBit(testMask));
                        System.out.printf("最高位1: 0b%s (%d)\n", 
                            Integer.toBinaryString(getHighestSetBit(testMask)), 
                            getHighestSetBit(testMask));
                        System.out.printf("最低位1位置: %d\n", getLowestSetBitPosition(testMask));
                        System.out.printf("最高位1位置: %d\n", getHighestSetBitPosition(testMask));
                        break;
                    case 4:
                        System.out.print("请输入数组元素个数: ");
                        int n = scanner.nextInt();
                        int[] array = new int[n];
                        System.out.println("请输入数组元素：");
                        for (int i = 0; i < n; i++) {
                            array[i] = scanner.nextInt();
                        }
                        List<Integer> xors = calculateSubsetXORs(array);
                        System.out.printf("数组 %s 的所有子集异或和: %s\n", 
                            Arrays.toString(array), xors.toString());
                        break;
                    case 5:
                        System.out.print("请输入物品个数: ");
                        int itemCount = scanner.nextInt();
                        int[] weights = new int[itemCount];
                        int[] values = new int[itemCount];
                        System.out.println("请输入物品的重量和价值：");
                        for (int i = 0; i < itemCount; i++) {
                            System.out.printf("物品 %d: ", i + 1);
                            weights[i] = scanner.nextInt();
                            values[i] = scanner.nextInt();
                        }
                        System.out.print("请输入背包容量: ");
                        int capacity = scanner.nextInt();
                        int maxValue = knapsackWithBitmask(weights, values, capacity);
                        System.out.printf("最大价值: %d\n", maxValue);
                        break;
                    case 6:
                        benchmarkPopcount();
                        break;
                    default:
                        System.out.println("无效的操作编号，请重新输入");
                }
            } catch (Exception e) {
                System.out.println("操作出错: " + e.getMessage());
                scanner.nextLine(); // 消耗错误输入后的换行符
            }
        }
    }
    
    /**
     * 简单的Pair类，用于存储键值对
     */
    public static class Pair<K, V> {
        private final K first;
        private final V second;
        
        public Pair(K first, V second) {
            this.first = first;
            this.second = second;
        }
        
        public K getFirst() {
            return first;
        }
        
        public V getSecond() {
            return second;
        }
        
        @Override
        public String toString() {
            return "(" + first + ", " + second + ")";
        }
    }
    
    public static void main(String[] args) {
        // 运行测试
        testBitOperations();
        
        // 启动交互模式
        interactiveMode();
    }
}

===============================================

文件: bit_operation_techniques.cpp
===============================================
#include <iostream>
#include <vector>
#include <map>
#include <set>
#include <tuple>
#include <string>
#include <algorithm>
#include <chrono>
#include <random>
#include <bitset>
#include <iomanip>

/**
 * 位运算技巧工具类
 * 提供高效的位操作实现，包括：
 * 1. 子集枚举（使用经典的 for(s=sub; s; s=(s-1)&mask) 模式）
 * 2. Popcount（汉明重量）优化算法
 * 3. 掩码预处理技术
 * 
 * 位运算在算法优化中具有极高的效率，可以将O(n)的操作优化到O(1)或更低
 */
class BitOperationTechniques {
private:
    // 预处理8位数字的popcount查找表
    static const int POPCOUNT_TABLE[256];

public:
    /**
     * 使用经典的子集枚举算法枚举指定掩码的所有非空子集
     * 时间复杂度：O(2^k)，其中k是掩码中1的个数
     * 空间复杂度：O(1)，不计算结果存储
     * 
     * @param mask 要枚举子集的掩码
     * @return 所有非空子集的列表
     */
    static std::vector<int> enumerateSubsets(int mask) {
        std::vector<int> subsets;
        int sub = mask;
        // 经典的子集枚举模式：for(s=sub; s; s=(s-1)&mask)
        do {
            subsets.push_back(sub);
            sub = (sub - 1) & mask;
        } while (sub != mask); // 当回到mask时，表示所有子集都已枚举完成
        return subsets;
    }

    /**
     * 使用位运算枚举所有可能的子集对，满足A是B的子集
     * 时间复杂度：O(3^n)，其中n是位数（对于n位数字，共有3^n种这样的子集对）
     * 
     * @param mask 最大的掩码
     * @return 所有满足A是B的子集对 (A, B) 的列表
     */
    static std::vector<std::pair<int, int>> enumerateSubsetPairs(int mask) {
        std::vector<std::pair<int, int>> pairs;
        // 枚举所有可能的B
        int b = 0;
        do {
            // 枚举B的所有子集A
            int a = b;
            do {
                pairs.push_back(std::make_pair(a, b));
                a = (a - 1) & b;
            } while (a != b);
            
            // 生成下一个B
            b = (b - mask) & mask;
        } while (b != 0 || mask == 0);
        
        return pairs;
    }

    /**
     * 使用查表法计算整数的二进制中1的个数（popcount）
     * 这是一种空间换时间的优化方法，预处理所有可能的字节值
     * 时间复杂度：O(1)
     * 空间复杂度：O(1)，需要256字节的查找表
     * 
     * @param n 要计算的整数
     * @return n的二进制表示中1的个数
     */
    static int popcountTable(int n) {
        // 将整数分解为多个字节，查表累加
        int count = 0;
        count += POPCOUNT_TABLE[n & 0xFF];
        count += POPCOUNT_TABLE[(n >> 8) & 0xFF];
        count += POPCOUNT_TABLE[(n >> 16) & 0xFF];
        count += POPCOUNT_TABLE[(n >> 24) & 0xFF];
        return count;
    }

    /**
     * 使用Brian Kernighan算法计算popcount
     * 时间复杂度：O(k)，其中k是1的个数
     * 空间复杂度：O(1)
     * 
     * @param n 要计算的整数
     * @return n的二进制表示中1的个数
     */
    static int popcountBrianKernighan(int n) {
        int count = 0;
        // 每次循环清除最低位的1，直到n变为0
        while (n != 0) {
            n &= n - 1; // 清除最低位的1
            count++;
        }
        return count;
    }

    /**
     * 使用C++内置函数计算popcount
     * 在支持的编译器上，这会被优化为CPU指令
     * 
     * @param n 要计算的整数
     * @return n的二进制表示中1的个数
     */
    static int popcountBuiltin(int n) {
        return __builtin_popcount(n);
    }

    /**
     * 预处理所有可能的子集掩码，按1的个数分组
     * 这在需要按子集大小处理问题时非常有用
     * 
     * @param n 位数
     * @return 按1的个数分组的子集列表，其中第k个列表包含所有恰好有k个1的掩码
     */
    static std::vector<std::vector<int>> precomputeSubsetsBySize(int n) {
        std::vector<std::vector<int>> subsetsBySize(n + 1);
        
        // 枚举所有可能的子集（0到2^n-1）
        int maxMask = (1 << n) - 1;
        for (int mask = 0; mask <= maxMask; mask++) {
            int count = popcountBuiltin(mask);
            subsetsBySize[count].push_back(mask);
        }
        
        return subsetsBySize;
    }

    /**
     * 预处理所有可能的掩码及其对应的补码
     * 
     * @param n 位数
     * @return 掩码到其补码的映射
     */
    static std::map<int, int> precomputeComplements(int n) {
        std::map<int, int> complements;
        int maxMask = (1 << n) - 1;
        for (int mask = 0; mask <= maxMask; mask++) {
            complements[mask] = mask ^ maxMask; // 异或操作计算补码
        }
        return complements;
    }

    /**
     * 预处理所有可能的掩码及其超集
     * 
     * @param n 位数
     * @return 每个掩码对应的所有超集
     */
    static std::map<int, std::vector<int>> precomputeSupersets(int n) {
        std::map<int, std::vector<int>> supersets;
        int maxMask = (1 << n) - 1;
        
        // 初始化每个掩码的超集列表
        for (int mask = 0; mask <= maxMask; mask++) {
            supersets[mask] = std::vector<int>();
        }
        
        // 对于每个可能的超集
        for (int superset = 0; superset <= maxMask; superset++) {
            // 找出它的所有子集并更新对应子集的超集列表
            int subset = superset;
            do {
                supersets[subset].push_back(superset);
                subset = (subset - 1) & superset;
            } while (subset != superset);
        }
        
        return supersets;
    }

    /**
     * 检查两个掩码是否不相交（没有共同的1位）
     * 时间复杂度：O(1)
     * 
     * @param a 第一个掩码
     * @param b 第二个掩码
     * @return 如果两个掩码不相交返回true，否则返回false
     */
    static bool areDisjoint(int a, int b) {
        return (a & b) == 0;
    }

    /**
     * 计算两个掩码的对称差（异或）
     * 时间复杂度：O(1)
     * 
     * @param a 第一个掩码
     * @param b 第二个掩码
     * @return 对称差的结果
     */
    static int symmetricDifference(int a, int b) {
        return a ^ b;
    }

    /**
     * 获取掩码中最低位的1
     * 时间复杂度：O(1)
     * 
     * @param mask 输入掩码
     * @return 只保留最低位1的掩码
     */
    static int getLowestSetBit(int mask) {
        // 使用补码性质：-mask 是 mask 的补码
        return mask & -mask;
    }

    /**
     * 获取掩码中最高位的1
     * 时间复杂度：O(1)
     * 
     * @param mask 输入掩码
     * @return 只保留最高位1的掩码
     */
    static int getHighestSetBit(int mask) {
        if (mask == 0) return 0;
        // 找到最高位1的位置
        int highestBitPosition = 31 - __builtin_clz(mask); // __builtin_clz 计算前导零的个数
        return 1 << highestBitPosition;
    }

    /**
     * 计算掩码中1的最低位置（从0开始计数）
     * 时间复杂度：O(1)
     * 
     * @param mask 输入掩码
     * @return 最低位1的位置，如果没有1则返回-1
     */
    static int getLowestSetBitPosition(int mask) {
        if (mask == 0) return -1;
        // __builtin_ctz 计算尾随零的个数
        return __builtin_ctz(mask);
    }

    /**
     * 计算掩码中1的最高位置（从0开始计数）
     * 时间复杂度：O(1)
     * 
     * @param mask 输入掩码
     * @return 最高位1的位置，如果没有1则返回-1
     */
    static int getHighestSetBitPosition(int mask) {
        if (mask == 0) return -1;
        // __builtin_clz 计算前导零的个数
        return 31 - __builtin_clz(mask);
    }

    /**
     * 计算所有可能的子集异或和
     * 时间复杂度：O(2^n)
     * 
     * @param nums 输入数组
     * @return 所有子集异或和的列表
     */
    static std::vector<int> calculateSubsetXOR(const std::vector<int>& nums) {
        std::set<int> xors;
        xors.insert(0); // 空集的异或和为0
        
        for (int num : nums) {
            std::set<int> newXors(xors.begin(), xors.end());
            for (int xorValue : xors) {
                newXors.insert(xorValue ^ num);
            }
            xors.swap(newXors);
        }
        
        return std::vector<int>(xors.begin(), xors.end());
    }

    /**
     * 使用位掩码优化的动态规划解决背包问题
     * 时间复杂度：O(2^n)
     * 空间复杂度：O(1)，使用整型掩码表示状态
     * 
     * @param weights 物品重量数组
     * @param values 物品价值数组
     * @param capacity 背包容量
     * @return 最大价值
     */
    static int knapsackWithBitmask(const std::vector<int>& weights, const std::vector<int>& values, int capacity) {
        int n = weights.size();
        int maxValue = 0;
        
        // 枚举所有可能的子集（2^n种可能）
        for (int mask = 0; mask < (1 << n); mask++) {
            int totalWeight = 0;
            int totalValue = 0;
            bool overCapacity = false;
            
            // 计算子集的总重量和总价值
            for (int i = 0; i < n; i++) {
                if (mask & (1 << i)) {
                    totalWeight += weights[i];
                    totalValue += values[i];
                    
                    // 剪枝：如果总重量已经超过容量，提前退出
                    if (totalWeight > capacity) {
                        overCapacity = true;
                        break;
                    }
                }
            }
            
            // 如果总重量不超过容量，更新最大价值
            if (!overCapacity && totalValue > maxValue) {
                maxValue = totalValue;
            }
        }
        
        return maxValue;
    }
};

// 初始化popcount查找表
const int BitOperationTechniques::POPCOUNT_TABLE[256] = {
    0, 1, 1, 2, 1, 2, 2, 3, 1, 2, 2, 3, 2, 3, 3, 4,
    1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,
    1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,
    2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
    1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,
    2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
    2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
    3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,
    1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,
    2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
    2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
    3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,
    2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
    3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,
    3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,
    4, 5, 5, 6, 5, 6, 6, 7, 5, 6, 6, 7, 6, 7, 7, 8
};

/**
 * 将整数转换为固定长度的二进制字符串
 */
std::string toBinaryString(int n, int width) {
    std::string binary = std::bitset<32>(n).to_string();
    // 移除前导零，直到到达指定宽度
    size_t startPos = binary.find('1');
    if (startPos == std::string::npos) {
        return std::string(width, '0'); // 全零
    }
    
    std::string result = binary.substr(startPos);
    // 如果结果长度小于width，在前面补零
    if (result.length() < width) {
        result = std::string(width - result.length(), '0') + result;
    }
    return result;
}

/**
 * 测试位运算技巧的各种功能
 */
void testBitOperations() {
    std::cout << "=== 位运算技巧测试 ===" << std::endl;
    
    // 测试子集枚举
    int mask = 0b1011; // 二进制 1011，十进制 11
    std::cout << "枚举掩码 0b" << std::bitset<4>(mask) << " 的所有子集：" << std::endl;
    std::vector<int> subsets = BitOperationTechniques::enumerateSubsets(mask);
    for (int subset : subsets) {
        std::cout << "0b" << std::bitset<4>(subset) << " (" << subset << ")" << std::endl;
    }
    
    // 测试Popcount方法比较
    std::cout << "\nPopcount方法比较：" << std::endl;
    int testNumber = 0xAAAAAAAA; // 二进制中1的个数为16
    std::cout << "数字 0x" << std::hex << testNumber << std::dec << " 的二进制中1的个数：" << std::endl;
    std::cout << "查表法: " << BitOperationTechniques::popcountTable(testNumber) << std::endl;
    std::cout << "Brian Kernighan算法: " << BitOperationTechniques::popcountBrianKernighan(testNumber) << std::endl;
    std::cout << "C++内置方法: " << BitOperationTechniques::popcountBuiltin(testNumber) << std::endl;
    
    // 测试预处理子集
    std::cout << "\n按1的个数分组的子集（n=4）：" << std::endl;
    std::vector<std::vector<int>> subsetsBySize = BitOperationTechniques::precomputeSubsetsBySize(4);
    for (size_t i = 0; i < subsetsBySize.size(); i++) {
        std::cout << "包含 " << i << " 个1的子集：" << std::endl;
        for (int subset : subsetsBySize[i]) {
            std::cout << "0b" << toBinaryString(subset, 4) << " (" << subset << ")  ";
        }
        std::cout << std::endl;
    }
    
    // 测试位操作辅助函数
    std::cout << "\n位操作辅助函数：" << std::endl;
    int testMask = 0b101010; // 二进制 101010，十进制 42
    std::cout << "掩码 0b" << std::bitset<8>(testMask) << " (" << testMask << ") 的最低位1: 0b" 
              << std::bitset<8>(BitOperationTechniques::getLowestSetBit(testMask)) << std::endl;
    std::cout << "掩码 0b" << std::bitset<8>(testMask) << " (" << testMask << ") 的最高位1: 0b" 
              << std::bitset<8>(BitOperationTechniques::getHighestSetBit(testMask)) << std::endl;
    std::cout << "掩码 0b" << std::bitset<8>(testMask) << " (" << testMask << ") 的最低位1位置: " 
              << BitOperationTechniques::getLowestSetBitPosition(testMask) << std::endl;
    std::cout << "掩码 0b" << std::bitset<8>(testMask) << " (" << testMask << ") 的最高位1位置: " 
              << BitOperationTechniques::getHighestSetBitPosition(testMask) << std::endl;
    
    // 测试子集异或和
    std::cout << "\n子集异或和计算：" << std::endl;
    std::vector<int> nums = {1, 2, 3};
    std::vector<int> xors = BitOperationTechniques::calculateSubsetXOR(nums);
    std::cout << "数组 {1, 2, 3} 的所有子集异或和: [";
    for (size_t i = 0; i < xors.size(); i++) {
        std::cout << xors[i];
        if (i < xors.size() - 1) std::cout << ", ";
    }
    std::cout << "]" << std::endl;
    
    // 测试掩码优化的背包问题
    std::cout << "\n掩码优化的背包问题：" << std::endl;
    std::vector<int> weights = {2, 3, 4, 5};
    std::vector<int> values = {3, 4, 5, 6};
    int capacity = 8;
    int maxValue = BitOperationTechniques::knapsackWithBitmask(weights, values, capacity);
    std::cout << "物品重量: {2, 3, 4, 5}" << std::endl;
    std::cout << "物品价值: {3, 4, 5, 6}" << std::endl;
    std::cout << "背包容量: " << capacity << std::endl;
    std::cout << "最大价值: " << maxValue << std::endl;
}

/**
 * 比较不同Popcount实现的性能
 */
void benchmarkPopcount() {
    std::cout << "\n=== Popcount性能基准测试 ===" << std::endl;
    
    const int testIterations = 10000000;
    
    // 生成随机测试数据
    std::vector<int> testNumbers(testIterations);
    std::random_device rd;
    std::mt19937 gen(rd());
    std::uniform_int_distribution<> dis(0, INT_MAX);
    
    for (int i = 0; i < testIterations; i++) {
        testNumbers[i] = dis(gen);
    }
    
    // 测试查表法性能
    auto start = std::chrono::high_resolution_clock::now();
    int tableSum = 0;
    for (int num : testNumbers) {
        tableSum += BitOperationTechniques::popcountTable(num);
    }
    auto end = std::chrono::high_resolution_clock::now();
    std::chrono::duration<double> tableTime = end - start;
    
    // 测试Brian Kernighan算法性能
    start = std::chrono::high_resolution_clock::now();
    int bkSum = 0;
    for (int num : testNumbers) {
        bkSum += BitOperationTechniques::popcountBrianKernighan(num);
    }
    end = std::chrono::high_resolution_clock::now();
    std::chrono::duration<double> bkTime = end - start;
    
    // 测试C++内置方法性能
    start = std::chrono::high_resolution_clock::now();
    int builtinSum = 0;
    for (int num : testNumbers) {
        builtinSum += BitOperationTechniques::popcountBuiltin(num);
    }
    end = std::chrono::high_resolution_clock::now();
    std::chrono::duration<double> builtinTime = end - start;
    
    // 验证结果一致性
    bool resultsMatch = (tableSum == bkSum) && (bkSum == builtinSum);
    
    std::cout << "测试 " << testIterations << " 次Popcount操作的结果一致性: " << std::boolalpha << resultsMatch << std::endl;
    std::cout << "查表法耗时: " << std::fixed << std::setprecision(6) << tableTime.count() << " 秒" << std::endl;
    std::cout << "Brian Kernighan算法耗时: " << std::fixed << std::setprecision(6) << bkTime.count() << " 秒" << std::endl;
    std::cout << "C++内置方法耗时: " << std::fixed << std::setprecision(6) << builtinTime.count() << " 秒" << std::endl;
    std::cout << "加速比 (查表法/BK): " << std::fixed << std::setprecision(2) << (tableTime.count() / bkTime.count()) << "x" << std::endl;
    std::cout << "加速比 (查表法/内置): " << std::fixed << std::setprecision(2) << (tableTime.count() / builtinTime.count()) << "x" << std::endl;
    std::cout << "加速比 (BK/内置): " << std::fixed << std::setprecision(2) << (bkTime.count() / builtinTime.count()) << "x" << std::endl;
}

/**
 * 交互式测试函数
 */
void interactiveMode() {
    std::cout << "=== 位运算技巧工具 ===" << std::endl;
    std::cout << "输入操作编号:" << std::endl;
    std::cout << "1. 枚举子集" << std::endl;
    std::cout << "2. 计算Popcount" << std::endl;
    std::cout << "3. 位操作辅助函数" << std::endl;
    std::cout << "4. 子集异或和计算" << std::endl;
    std::cout << "5. 掩码优化背包问题" << std::endl;
    std::cout << "6. Popcount性能基准测试" << std::endl;
    std::cout << "0. 退出" << std::endl;
    
    while (true) {
        std::cout << "\n请输入操作编号: ";
        int choice;
        std::cin >> choice;
        
        try {
            switch (choice) {
                case 0:
                    std::cout << "程序已退出" << std::endl;
                    return;
                case 1: {
                    std::cout << "请输入掩码（十进制）: ";
                    int mask;
                    std::cin >> mask;
                    std::vector<int> subsets = BitOperationTechniques::enumerateSubsets(mask);
                    std::cout << "掩码 " << mask << " (0b" << std::bitset<16>(mask) << ") 的所有子集：" << std::endl;
                    for (int subset : subsets) {
                        std::cout << "0b" << std::bitset<16>(subset) << " (" << subset << ")" << std::endl;
                    }
                    break;
                }
                case 2: {
                    std::cout << "请输入要计算Popcount的数字: ";
                    int num;
                    std::cin >> num;
                    std::cout << "数字 " << num << " (0b" << std::bitset<32>(num) << ") 的二进制中1的个数：" << std::endl;
                    std::cout << "查表法: " << BitOperationTechniques::popcountTable(num) << std::endl;
                    std::cout << "Brian Kernighan算法: " << BitOperationTechniques::popcountBrianKernighan(num) << std::endl;
                    std::cout << "C++内置方法: " << BitOperationTechniques::popcountBuiltin(num) << std::endl;
                    break;
                }
                case 3: {
                    std::cout << "请输入掩码（十进制）: ";
                    int testMask;
                    std::cin >> testMask;
                    std::cout << "掩码 " << testMask << " (0b" << std::bitset<16>(testMask) << ") 的位操作结果：" << std::endl;
                    std::cout << "最低位1: 0b" << std::bitset<16>(BitOperationTechniques::getLowestSetBit(testMask)) 
                              << " (" << BitOperationTechniques::getLowestSetBit(testMask) << ")" << std::endl;
                    std::cout << "最高位1: 0b" << std::bitset<16>(BitOperationTechniques::getHighestSetBit(testMask)) 
                              << " (" << BitOperationTechniques::getHighestSetBit(testMask) << ")" << std::endl;
                    std::cout << "最低位1位置: " << BitOperationTechniques::getLowestSetBitPosition(testMask) << std::endl;
                    std::cout << "最高位1位置: " << BitOperationTechniques::getHighestSetBitPosition(testMask) << std::endl;
                    break;
                }
                case 4: {
                    std::cout << "请输入数组元素个数: ";
                    int n;
                    std::cin >> n;
                    std::cout << "请输入数组元素（空格分隔）：" << std::endl;
                    std::vector<int> array(n);
                    for (int i = 0; i < n; i++) {
                        std::cin >> array[i];
                    }
                    std::vector<int> xors = BitOperationTechniques::calculateSubsetXOR(array);
                    std::cout << "数组的所有子集异或和: [";
                    for (size_t i = 0; i < xors.size(); i++) {
                        std::cout << xors[i];
                        if (i < xors.size() - 1) std::cout << ", ";
                    }
                    std::cout << "]" << std::endl;
                    break;
                }
                case 5: {
                    std::cout << "请输入物品个数: ";
                    int itemCount;
                    std::cin >> itemCount;
                    std::cout << "请输入物品的重量和价值（每行一个物品，格式：重量 价值）：" << std::endl;
                    std::vector<int> weights(itemCount);
                    std::vector<int> values(itemCount);
                    for (int i = 0; i < itemCount; i++) {
                        std::cin >> weights[i] >> values[i];
                    }
                    std::cout << "请输入背包容量: ";
                    int capacity;
                    std::cin >> capacity;
                    int maxValue = BitOperationTechniques::knapsackWithBitmask(weights, values, capacity);
                    std::cout << "最大价值: " << maxValue << std::endl;
                    break;
                }
                case 6:
                    benchmarkPopcount();
                    break;
                default:
                    std::cout << "无效的操作编号，请重新输入" << std::endl;
            }
        } catch (const std::exception& e) {
            std::cout << "操作出错: " << e.what() << std::endl;
            std::cin.clear();
            std::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\n');
        }
    }
}

int main() {
    // 运行测试
    testBitOperations();
    
    // 启动交互模式
    interactiveMode();
    
    return 0;
}

===============================================

文件: bit_operation_techniques.py
===============================================
#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
位运算技巧工具类
提供高效的位操作实现，包括：
1. 子集枚举（使用经典的 for(s=sub; s; s=(s-1)&mask) 模式）
2. Popcount（汉明重量）优化算法
3. 掩码预处理技术

位运算在算法优化中具有极高的效率，可以将O(n)的操作优化到O(1)或更低
"""

import time
import random
from typing import List, Dict, Set, Tuple


def enumerate_subsets(mask: int) -> List[int]:
    """
    使用经典的子集枚举算法枚举指定掩码的所有非空子集
    时间复杂度：O(2^k)，其中k是掩码中1的个数
    空间复杂度：O(1)，不计算结果存储
    
    Args:
        mask: 要枚举子集的掩码
    
    Returns:
        List[int]: 所有非空子集的列表
    """
    subsets = []
    sub = mask
    # 经典的子集枚举模式：for(s=sub; s; s=(s-1)&mask)
    while True:
        subsets.append(sub)
        sub = (sub - 1) & mask
        if sub == mask:
            break  # 当回到mask时，表示所有子集都已枚举完成
    return subsets


def enumerate_subset_pairs(mask: int) -> List[Tuple[int, int]]:
    """
    使用位运算枚举所有可能的子集对，满足A是B的子集
    时间复杂度：O(3^n)，其中n是位数（对于n位数字，共有3^n种这样的子集对）
    
    Args:
        mask: 最大的掩码
    
    Returns:
        List[Tuple[int, int]]: 所有满足A是B的子集对 (A, B) 的列表
    """
    pairs = []
    # 枚举所有可能的B
    b = 0
    while True:
        # 枚举B的所有子集A
        a = b
        while True:
            pairs.append((a, b))
            a = (a - 1) & b
            if a == b:
                break
        
        # 生成下一个B
        b = (b - mask) & mask
        if b == 0 and mask != 0:
            break
        
    return pairs

# 预处理8位数字的popcount查找表
POPCOUNT_TABLE = [0] * 256
for i in range(256):
    POPCOUNT_TABLE[i] = bin(i).count('1')


def popcount_table(n: int) -> int:
    """
    使用查表法计算整数的二进制中1的个数（popcount）
    这是一种空间换时间的优化方法，预处理所有可能的字节值
    时间复杂度：O(1)
    空间复杂度：O(1)，需要256字节的查找表
    
    Args:
        n: 要计算的整数
    
    Returns:
        int: n的二进制表示中1的个数
    """
    # 将整数分解为多个字节，查表累加
    count = 0
    while n:
        count += POPCOUNT_TABLE[n & 0xFF]
        n >>= 8
    return count


def popcount_brian_kernighan(n: int) -> int:
    """
    使用Brian Kernighan算法计算popcount
    时间复杂度：O(k)，其中k是1的个数
    空间复杂度：O(1)
    
    Args:
        n: 要计算的整数
    
    Returns:
        int: n的二进制表示中1的个数
    """
    count = 0
    # 每次循环清除最低位的1，直到n变为0
    while n:
        n &= n - 1  # 清除最低位的1
        count += 1
    return count


def popcount_builtin(n: int) -> int:
    """
    使用Python内置函数计算popcount
    这是Python中最高效的popcount实现
    
    Args:
        n: 要计算的整数
    
    Returns:
        int: n的二进制表示中1的个数
    """
    return bin(n).count('1')


def precompute_subsets_by_size(n: int) -> List[List[int]]:
    """
    预处理所有可能的子集掩码，按1的个数分组
    这在需要按子集大小处理问题时非常有用
    
    Args:
        n: 位数
    
    Returns:
        List[List[int]]: 按1的个数分组的子集列表，其中第k个列表包含所有恰好有k个1的掩码
    """
    subsets_by_size = [[] for _ in range(n + 1)]
    
    # 枚举所有可能的子集（0到2^n-1）
    max_mask = (1 << n) - 1
    for mask in range(max_mask + 1):
        count = popcount_builtin(mask)
        subsets_by_size[count].append(mask)
    
    return subsets_by_size


def precompute_complements(n: int) -> Dict[int, int]:
    """
    预处理所有可能的掩码及其对应的补码
    
    Args:
        n: 位数
    
    Returns:
        Dict[int, int]: 掩码到其补码的映射
    """
    complements = {}
    max_mask = (1 << n) - 1
    for mask in range(max_mask + 1):
        complements[mask] = mask ^ max_mask  # 异或操作计算补码
    return complements


def precompute_supersets(n: int) -> Dict[int, List[int]]:
    """
    预处理所有可能的掩码及其超集
    
    Args:
        n: 位数
    
    Returns:
        Dict[int, List[int]]: 每个掩码对应的所有超集
    """
    supersets = {}
    max_mask = (1 << n) - 1
    
    # 初始化每个掩码的超集列表
    for mask in range(max_mask + 1):
        supersets[mask] = []
    
    # 对于每个可能的超集
    for superset in range(max_mask + 1):
        # 找出它的所有子集并更新对应子集的超集列表
        subset = superset
        while True:
            supersets[subset].append(superset)
            subset = (subset - 1) & superset
            if subset == superset:
                break
    
    return supersets


def are_disjoint(a: int, b: int) -> bool:
    """
    检查两个掩码是否不相交（没有共同的1位）
    时间复杂度：O(1)
    
    Args:
        a: 第一个掩码
        b: 第二个掩码
    
    Returns:
        bool: 如果两个掩码不相交返回True，否则返回False
    """
    return (a & b) == 0


def symmetric_difference(a: int, b: int) -> int:
    """
    计算两个掩码的对称差（异或）
    时间复杂度：O(1)
    
    Args:
        a: 第一个掩码
        b: 第二个掩码
    
    Returns:
        int: 对称差的结果
    """
    return a ^ b


def get_lowest_set_bit(mask: int) -> int:
    """
    获取掩码中最低位的1
    时间复杂度：O(1)
    
    Args:
        mask: 输入掩码
    
    Returns:
        int: 只保留最低位1的掩码
    """
    # 使用补码性质：-mask 是 mask 的补码
    return mask & -mask


def get_highest_set_bit(mask: int) -> int:
    """
    获取掩码中最高位的1
    时间复杂度：O(1)
    
    Args:
        mask: 输入掩码
    
    Returns:
        int: 只保留最高位1的掩码
    """
    if mask == 0:
        return 0
    # 找到最高位1的位置
    highest_bit_position = mask.bit_length() - 1
    return 1 << highest_bit_position


def get_lowest_set_bit_position(mask: int) -> int:
    """
    计算掩码中1的最低位置（从0开始计数）
    时间复杂度：O(1)
    
    Args:
        mask: 输入掩码
    
    Returns:
        int: 最低位1的位置，如果没有1则返回-1
    """
    if mask == 0:
        return -1
    # 计算末尾0的个数
    return (mask & -mask).bit_length() - 1


def get_highest_set_bit_position(mask: int) -> int:
    """
    计算掩码中1的最高位置（从0开始计数）
    时间复杂度：O(1)
    
    Args:
        mask: 输入掩码
    
    Returns:
        int: 最高位1的位置，如果没有1则返回-1
    """
    if mask == 0:
        return -1
    return mask.bit_length() - 1


def calculate_subset_xor(nums: List[int]) -> List[int]:
    """
    计算所有可能的子集异或和
    时间复杂度：O(2^n)
    
    Args:
        nums: 输入数组
    
    Returns:
        List[int]: 所有子集异或和的列表
    """
    xors = {0}  # 空集的异或和为0
    
    for num in nums:
        new_xors = set(xors)
        for xor in xors:
            new_xors.add(xor ^ num)
        xors = new_xors
    
    return list(xors)


def knapsack_with_bitmask(weights: List[int], values: List[int], capacity: int) -> int:
    """
    使用位掩码优化的动态规划解决背包问题
    时间复杂度：O(2^n)
    空间复杂度：O(1)，使用整型掩码表示状态
    
    Args:
        weights: 物品重量数组
        values: 物品价值数组
        capacity: 背包容量
    
    Returns:
        int: 最大价值
    """
    n = len(weights)
    max_value = 0
    
    # 枚举所有可能的子集（2^n种可能）
    for mask in range(1 << n):
        total_weight = 0
        total_value = 0
        
        # 计算子集的总重量和总价值
        for i in range(n):
            if mask & (1 << i):
                total_weight += weights[i]
                total_value += values[i]
                
                # 剪枝：如果总重量已经超过容量，提前退出
                if total_weight > capacity:
                    break
        
        # 如果总重量不超过容量，更新最大价值
        if total_weight <= capacity and total_value > max_value:
            max_value = total_value
    
    return max_value


def test_bit_operations():
    """
    测试位运算技巧的各种功能
    """
    print("=== 位运算技巧测试 ===")
    
    # 测试子集枚举
    mask = 0b1011  # 二进制 1011，十进制 11
    print(f"枚举掩码 0b{mask:b} 的所有子集：")
    subsets = enumerate_subsets(mask)
    for subset in subsets:
        print(f"0b{subset:b} ({subset})")
    
    # 测试Popcount方法比较
    print("\nPopcount方法比较：")
    test_number = 0xAAAAAAAA  # 二进制中1的个数为16
    print(f"数字 0x{test_number:x} 的二进制中1的个数：")
    print(f"查表法: {popcount_table(test_number)}")
    print(f"Brian Kernighan算法: {popcount_brian_kernighan(test_number)}")
    print(f"Python内置方法: {popcount_builtin(test_number)}")
    
    # 测试预处理子集
    print("\n按1的个数分组的子集（n=4）：")
    subsets_by_size = precompute_subsets_by_size(4)
    for i in range(len(subsets_by_size)):
        print(f"包含 {i} 个1的子集：")
        for subset in subsets_by_size[i]:
            # 格式化二进制输出，保持4位
            bin_str = bin(subset)[2:].zfill(4)
            print(f"0b{bin_str} ({subset})  ", end="")
        print()
    
    # 测试位操作辅助函数
    print("\n位操作辅助函数：")
    test_mask = 0b101010  # 二进制 101010，十进制 42
    print(f"掩码 0b{test_mask:b} ({test_mask}) 的最低位1: 0b{get_lowest_set_bit(test_mask):b}")
    print(f"掩码 0b{test_mask:b} ({test_mask}) 的最高位1: 0b{get_highest_set_bit(test_mask):b}")
    print(f"掩码 0b{test_mask:b} ({test_mask}) 的最低位1位置: {get_lowest_set_bit_position(test_mask)}")
    print(f"掩码 0b{test_mask:b} ({test_mask}) 的最高位1位置: {get_highest_set_bit_position(test_mask)}")
    
    # 测试子集异或和
    print("\n子集异或和计算：")
    nums = [1, 2, 3]
    xors = calculate_subset_xor(nums)
    print(f"数组 {nums} 的所有子集异或和: {xors}")
    
    # 测试掩码优化的背包问题
    print("\n掩码优化的背包问题：")
    weights = [2, 3, 4, 5]
    values = [3, 4, 5, 6]
    capacity = 8
    max_value = knapsack_with_bitmask(weights, values, capacity)
    print(f"物品重量: {weights}")
    print(f"物品价值: {values}")
    print(f"背包容量: {capacity}")
    print(f"最大价值: {max_value}")


def benchmark_popcount():
    """
    比较不同Popcount实现的性能
    """
    print("\n=== Popcount性能基准测试 ===")
    
    test_iterations = 1000000
    test_numbers = [random.randint(0, 2**31 - 1) for _ in range(test_iterations)]
    
    # 测试查表法性能
    start_time = time.time()
    table_sum = 0
    for num in test_numbers:
        table_sum += popcount_table(num)
    table_time = time.time() - start_time
    
    # 测试Brian Kernighan算法性能
    start_time = time.time()
    bk_sum = 0
    for num in test_numbers:
        bk_sum += popcount_brian_kernighan(num)
    bk_time = time.time() - start_time
    
    # 测试Python内置方法性能
    start_time = time.time()
    builtin_sum = 0
    for num in test_numbers:
        builtin_sum += popcount_builtin(num)
    builtin_time = time.time() - start_time
    
    # 验证结果一致性
    results_match = (table_sum == bk_sum) and (bk_sum == builtin_sum)
    
    print(f"测试 {test_iterations} 次Popcount操作的结果一致性: {results_match}")
    print(f"查表法耗时: {table_time:.6f} 秒")
    print(f"Brian Kernighan算法耗时: {bk_time:.6f} 秒")
    print(f"Python内置方法耗时: {builtin_time:.6f} 秒")
    print(f"加速比 (查表法/BK): {table_time / bk_time:.2f}x")
    print(f"加速比 (查表法/内置): {table_time / builtin_time:.2f}x")
    print(f"加速比 (BK/内置): {bk_time / builtin_time:.2f}x")


def interactive_mode():
    """
    交互式测试函数
    """
    print("=== 位运算技巧工具 ===")
    print("输入操作编号:")
    print("1. 枚举子集")
    print("2. 计算Popcount")
    print("3. 位操作辅助函数")
    print("4. 子集异或和计算")
    print("5. 掩码优化背包问题")
    print("6. Popcount性能基准测试")
    print("0. 退出")
    
    while True:
        try:
            choice = int(input("\n请输入操作编号: "))
            
            if choice == 0:
                print("程序已退出")
                return
            elif choice == 1:
                mask = int(input("请输入掩码（十进制）: "))
                subsets = enumerate_subsets(mask)
                print(f"掩码 {mask} (0b{mask:b}) 的所有子集：")
                for subset in subsets:
                    print(f"0b{subset:b} ({subset})")
            elif choice == 2:
                num = int(input("请输入要计算Popcount的数字: "))
                print(f"数字 {num} (0b{num:b}) 的二进制中1的个数：")
                print(f"查表法: {popcount_table(num)}")
                print(f"Brian Kernighan算法: {popcount_brian_kernighan(num)}")
                print(f"Python内置方法: {popcount_builtin(num)}")
            elif choice == 3:
                test_mask = int(input("请输入掩码（十进制）: "))
                print(f"掩码 {test_mask} (0b{test_mask:b}) 的位操作结果：")
                print(f"最低位1: 0b{get_lowest_set_bit(test_mask):b} ({get_lowest_set_bit(test_mask)})")
                print(f"最高位1: 0b{get_highest_set_bit(test_mask):b} ({get_highest_set_bit(test_mask)})")
                print(f"最低位1位置: {get_lowest_set_bit_position(test_mask)}")
                print(f"最高位1位置: {get_highest_set_bit_position(test_mask)}")
            elif choice == 4:
                n = int(input("请输入数组元素个数: "))
                print("请输入数组元素（空格分隔）：")
                array = list(map(int, input().split()))[:n]
                xors = calculate_subset_xor(array)
                print(f"数组 {array} 的所有子集异或和: {xors}")
            elif choice == 5:
                item_count = int(input("请输入物品个数: "))
                print("请输入物品的重量和价值（每行一个物品，格式：重量 价值）：")
                weights = []
                values = []
                for i in range(item_count):
                    w, v = map(int, input().split())
                    weights.append(w)
                    values.append(v)
                capacity = int(input("请输入背包容量: "))
                max_value = knapsack_with_bitmask(weights, values, capacity)
                print(f"最大价值: {max_value}")
            elif choice == 6:
                benchmark_popcount()
            else:
                print("无效的操作编号，请重新输入")
        except Exception as e:
            print(f"操作出错: {e}")


if __name__ == "__main__":
    # 运行测试
    test_bit_operations()
    
    # 启动交互模式
    interactive_mode()

===============================================

文件: Code01_HashCollision.cpp
===============================================
// 哈希冲突问题 - 分块算法实现 (C++版本)
// 题目来源: https://www.luogu.com.cn/problem/P3396
// 题目大意: 给定一个长度为n的数组arr，支持两种操作：
// 1. 查询操作 A x y: 查询所有满足 i % x == y 的位置i对应的arr[i]之和
// 2. 更新操作 C x y: 将arr[x]的值更新为y
// 约束条件: 1 <= n、m <= 1.5 * 10^5
// 相关解答: 
// - C++版本: Code01_HashCollision.cpp
// - Java版本: Code01_HashCollision1.java, Code01_HashCollision2.java
// - Python版本: Code01_HashCollision.py

#include <cstdio>
#include <cmath>
using namespace std;

// 定义常量
const int MAXN = 150001;    // 最大数组长度
const int MAXB = 401;       // 最大块大小，约等于sqrt(MAXN)

// 全局变量
int n, m;                   // n: 数组长度, m: 操作次数
int blen;                   // 块大小，通常取sqrt(n)
int arr[MAXN];              // 原始数组
long long dp[MAXB][MAXB];   // dp[x][y]: 存储所有满足i % x == y的arr[i]之和，仅预处理x <= blen的情况

/**
 * 查询操作 A x y
 * 查询所有满足 i % x == y 的位置i对应的arr[i]之和
 * 
 * @param x 除数
 * @param y 余数
 * @return 满足条件的位置对应的元素之和
 * 
 * 算法策略:
 * - 对于x <= sqrt(n)的情况: O(1)时间复杂度，直接返回预处理好的dp[x][y]
 * - 对于x > sqrt(n)的情况: O(n/x)时间复杂度，由于x较大，最多执行sqrt(n)次循环
 */
long long query(int x, int y) {
    // 当x较小时(x <= blen)，直接使用预处理结果，O(1)时间
    if (x <= blen) {
        return dp[x][y];
    }
    
    // 当x较大时(x > blen)，暴力枚举所有满足条件的位置
    // 由于x > sqrt(n)，所以最多执行n/x < sqrt(n)次循环，总时间复杂度为O(sqrt(n))
    long long ans = 0;
    for (int i = y; i <= n; i += x) {
        ans += arr[i];
    }
    return ans;
}

/**
 * 更新操作 C x y
 * 将arr[x]的值更新为y，并更新相关的预处理结果
 * 
 * @param i 要更新的位置
 * @param v 新的值
 * 
 * 算法策略:
 * - 计算值的变化量delta
 * - 更新原始数组arr[i]
 * - 更新所有受影响的预处理结果
 * - 时间复杂度: O(sqrt(n))，因为只需要更新x <= sqrt(n)的预处理结果
 */
void update(int i, int v) {
    // 计算值的变化量
    int delta = v - arr[i];
    
    // 更新原始数组
    arr[i] = v;
    
    // 更新所有相关的预处理结果
    // 只需要更新x <= sqrt(n)的情况，因为这些情况被预处理了
    // 对于每个x <= blen，位置i对x的余数是i % x，所以需要更新dp[x][i % x]
    for (int x = 1; x <= blen; x++) {
        dp[x][i % x] += delta;
    }
}

/**
 * 预处理函数
 * 对于所有x <= sqrt(n)的情况，预处理dp[x][y]的值
 * 
 * 预处理策略:
 * - 计算块大小blen = sqrt(n)
 * - 对每个x (1 <= x <= blen)，计算所有可能的余数y (0 <= y < x)对应的arr[i]之和
 * - 时间复杂度: O(n*sqrt(n))，但由于只预处理x <= sqrt(n)的情况，实际复杂度为O(n*sqrt(n))
 */
void prepare() {
    // 计算块大小，通常选择sqrt(n)
    // 使用double类型计算平方根，再转换为int
    blen = (int)sqrt((double)n);
    
    // 全局数组dp默认初始化为0
    
    // 对于每个x <= sqrt(n)，预处理dp[x][y]的值
    for (int x = 1; x <= blen; x++) {
        for (int i = 1; i <= n; i++) {
            // 计算位置i对x取余的结果y
            int y = i % x;
            // 将arr[i]累加到dp[x][y]中
            // 这样dp[x][y]就存储了所有满足i % x == y的arr[i]之和
            dp[x][y] += arr[i];
        }
    }
}

/**
 * 主函数
 * 读取输入数据，初始化数组，预处理数据，处理所有操作
 */
int main() {
    // 读取数组长度n和操作次数m
    scanf("%d%d", &n, &m);
    
    // 读取初始数组元素
    for (int i = 1; i <= n; i++) {
        scanf("%d", &arr[i]);
    }
    
    // 进行预处理，计算dp数组的值
    prepare();
    
    // 处理m次操作
    char op;  // 操作类型
    int x, y; // 操作参数
    for (int i = 1; i <= m; i++) {
        // 读取操作类型和参数
        // 注意scanf前的空格，用于跳过前一个操作后的换行符
        scanf(" %c%d%d", &op, &x, &y);
        
        if (op == 'A') {
            // 查询操作: 计算并输出满足条件的位置对应的元素之和
            printf("%lld\n", query(x, y));
        } else {
            // 更新操作: 将位置x的值更新为y
            update(x, y);
        }
    }
    
    return 0;
}

===============================================

文件: Code01_HashCollision.py
===============================================
# 哈希冲突问题 - 分块算法实现 (Python版本)
# 题目来源: https://www.luogu.com.cn/problem/P3396
# 题目大意: 给定一个长度为n的数组arr，支持两种操作：
# 1. 查询操作 A x y: 查询所有满足 i % x == y 的位置i对应的arr[i]之和
# 2. 更新操作 C x y: 将arr[x]的值更新为y
# 约束条件: 1 <= n、m <= 1.5 * 10^5
# 相关解答: 
# - C++版本: Code01_HashCollision.cpp
# - Java版本: Code01_HashCollision1.java, Code01_HashCollision2.java
# - Python版本: Code01_HashCollision.py

import math
import sys

# 定义常量
MAXN = 150001    # 最大数组长度
MAXB = 401       # 最大块大小，约等于sqrt(MAXN)

# 全局变量
n, m, blen = 0, 0, 0            # n: 数组长度, m: 操作次数, blen: 块大小
arr = [0] * MAXN                # 原始数组
# dp[x][y]: 存储所有满足i % x == y的arr[i]之和，仅预处理x <= blen的情况
dp = [[0 for _ in range(MAXB)] for _ in range(MAXB)]

def query(x, y):
    """
    查询操作 A x y
    查询所有满足 i % x == y 的位置i对应的arr[i]之和
    
    参数:
        x: 除数
        y: 余数
    返回:
        满足条件的位置对应的元素之和
    
    算法策略:
    - 对于x <= sqrt(n)的情况: O(1)时间复杂度，直接返回预处理好的dp[x][y]
    - 对于x > sqrt(n)的情况: O(n/x)时间复杂度，由于x较大，最多执行sqrt(n)次循环
    """
    # 当x较小时(x <= blen)，直接使用预处理结果，O(1)时间
    if x <= blen:
        return dp[x][y]
    
    # 当x较大时(x > blen)，暴力枚举所有满足条件的位置
    # 由于x > sqrt(n)，所以最多执行n/x < sqrt(n)次循环，总时间复杂度为O(sqrt(n))
    ans = 0
    i = y
    while i <= n:
        ans += arr[i]
        i += x
    return ans

def update(i, v):
    """
    更新操作 C x y
    将arr[x]的值更新为y，并更新相关的预处理结果
    
    参数:
        i: 要更新的位置
        v: 新的值
    
    算法策略:
    - 计算值的变化量delta
    - 更新原始数组arr[i]
    - 更新所有受影响的预处理结果
    - 时间复杂度: O(sqrt(n))，因为只需要更新x <= sqrt(n)的预处理结果
    """
    # 计算值的变化量
    delta = v - arr[i]
    
    # 更新原始数组
    arr[i] = v
    
    # 更新所有相关的预处理结果
    # 只需要更新x <= sqrt(n)的情况，因为这些情况被预处理了
    # 对于每个x <= blen，位置i对x的余数是i % x，所以需要更新dp[x][i % x]
    for x in range(1, blen + 1):
        dp[x][i % x] += delta

def prepare():
    """
    预处理函数
    对于所有x <= sqrt(n)的情况，预处理dp[x][y]的值
    
    预处理策略:
    - 计算块大小blen = sqrt(n)
    - 对每个x (1 <= x <= blen)，计算所有可能的余数y (0 <= y < x)对应的arr[i]之和
    - 时间复杂度: O(n*sqrt(n))
    """
    global blen
    # 计算块大小，通常选择sqrt(n)
    blen = int(math.sqrt(n))
    
    # dp数组已在全局变量定义时初始化为0
    
    # 对于每个x <= sqrt(n)，预处理dp[x][y]的值
    for x in range(1, blen + 1):
        for i in range(1, n + 1):
            # 计算位置i对x取余的结果y
            y = i % x
            # 将arr[i]累加到dp[x][y]中
            # 这样dp[x][y]就存储了所有满足i % x == y的arr[i]之和
            dp[x][y] += arr[i]

def main():
    """
    主函数
    读取输入数据，初始化数组，预处理数据，处理所有操作
    """
    global n, m
    # 读取数组长度n和操作次数m
    n, m = map(int, sys.stdin.readline().split())
    
    # 读取初始数组元素
    values = list(map(int, sys.stdin.readline().split()))
    for i in range(1, n + 1):
        arr[i] = values[i - 1]  # 注意数组索引从1开始
    
    # 进行预处理，计算dp数组的值
    prepare()
    
    # 处理m次操作
    for _ in range(m):
        # 读取操作行并分割
        line = sys.stdin.readline().split()
        op = line[0]    # 操作类型
        x = int(line[1])  # 第一个参数
        y = int(line[2])  # 第二个参数
        
        if op == 'A':
            # 查询操作: 计算并输出满足条件的位置对应的元素之和
            print(query(x, y))
        else:
            # 更新操作: 将位置x的值更新为y
            update(x, y)

if __name__ == "__main__":
    main()

===============================================

文件: Code01_HashCollision1.java
===============================================
package class175;

// 哈希冲突问题 - 分块算法实现 (Java版本)
// 题目来源: https://www.luogu.com.cn/problem/P3396
// 题目大意: 给定一个长度为n的数组arr，支持两种操作：
// 1. 查询操作 A x y: 查询所有满足 i % x == y 的位置i对应的arr[i]之和
// 2. 更新操作 C x y: 将arr[x]的值更新为y
// 约束条件: 1 <= n、m <= 1.5 * 10^5
// 相关解答: 
// - C++版本: Code01_HashCollision.cpp
// - Java版本: Code01_HashCollision1.java, Code01_HashCollision2.java
// - Python版本: Code01_HashCollision.py

import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStreamWriter;
import java.io.PrintWriter;

public class Code01_HashCollision1 {

    // 定义常量
    public static int MAXN = 150001;    // 最大数组长度
    public static int MAXB = 401;       // 最大块大小，约等于sqrt(MAXN)
    
    // 全局变量
    public static int n, m;             // n: 数组长度, m: 操作次数
    public static int blen;             // 块大小，通常取sqrt(n)
    public static int[] arr = new int[MAXN];  // 原始数组
    
    // dp[x][y]: 存储所有满足 i % x == y 的位置i对应的arr[i]之和 (预处理结果)
    // 只对 x <= sqrt(n) 的情况进行预处理，以节省空间和时间
    // 这样设计可以使查询操作的时间复杂度为O(1)当x较小时，而当x较大时为O(sqrt(n))
    public static long[][] dp = new long[MAXB][MAXB];

    /**
     * 查询操作 A x y
     * 查询所有满足 i % x == y 的位置i对应的arr[i]之和
     * 
     * @param x 除数
     * @param y 余数
     * @return 满足条件的位置对应的元素之和
     * 
     * 算法策略:
     * - 对于x <= sqrt(n)的情况: O(1)时间复杂度，直接返回预处理好的dp[x][y]
     * - 对于x > sqrt(n)的情况: O(n/x)时间复杂度，由于x较大，最多执行sqrt(n)次循环
     * 这种分块处理的策略使得查询操作的时间复杂度为O(sqrt(n))
     */
    public static long query(int x, int y) {
        // 当x较小时(x <= blen)，直接使用预处理结果，O(1)时间
        if (x <= blen) {
            return dp[x][y];
        }
        
        // 当x较大时(x > blen)，暴力枚举所有满足条件的位置
        // 由于x > sqrt(n)，所以最多执行n/x < sqrt(n)次循环，总时间复杂度为O(sqrt(n))
        long ans = 0;
        for (int i = y; i <= n; i += x) {
            ans += arr[i];
        }
        return ans;
    }

    /**
     * 更新操作 C x y
     * 将arr[x]的值更新为y，并更新相关的预处理结果
     * 
     * @param i 要更新的位置
     * @param v 新的值
     * 
     * 算法策略:
     * - 计算值的变化量delta
     * - 更新原始数组arr[i]
     * - 更新所有受影响的预处理结果
     * - 时间复杂度: O(sqrt(n))，因为只需要更新x <= sqrt(n)的预处理结果
     * 这种设计确保了更新操作在可接受的时间复杂度内完成
     */
    public static void update(int i, int v) {
        // 计算值的变化量
        int delta = v - arr[i];
        
        // 更新原始数组
        arr[i] = v;
        
        // 更新所有相关的预处理结果
        // 只需要更新x <= sqrt(n)的情况，因为这些情况被预处理了
        // 对于每个x <= blen，位置i对x的余数是i % x，所以需要更新dp[x][i % x]
        for (int x = 1; x <= blen; x++) {
            dp[x][i % x] += delta;
        }
    }

    /**
     * 预处理函数
     * 对于所有x <= sqrt(n)的情况，预处理dp[x][y]的值
     * 
     * 预处理策略:
     * - 计算块大小blen = sqrt(n)
     * - 对每个x (1 <= x <= blen)，计算所有可能的余数y (0 <= y < x)对应的arr[i]之和
     * - 时间复杂度: O(n*sqrt(n))
     * 虽然预处理的时间复杂度较高，但后续的查询和更新操作都可以在O(sqrt(n))时间内完成
     */
    public static void prepare() {
        // 计算块大小，通常选择sqrt(n)
        blen = (int) Math.sqrt(n);
        
        // 对每个x <= sqrt(n)，预处理dp[x][y]的值
        // dp[x][y]存储了所有满足i % x == y的arr[i]之和
        for (int x = 1; x <= blen; x++) {
            for (int i = 1; i <= n; i++) {
                // 计算位置i对x取余的结果y
                int y = i % x;
                // 将arr[i]累加到dp[x][y]中
                dp[x][y] += arr[i];
            }
        }
    }

    /**
     * 主函数
     * 读取输入数据，初始化数组，预处理数据，处理所有操作
     * 
     * @param args 命令行参数
     * @throws IOException 输入输出异常
     */
    public static void main(String[] args) throws IOException {
        // 创建FastReader实例用于高效读取输入
        FastReader in = new FastReader();
        // 创建PrintWriter实例用于高效输出结果
        PrintWriter out = new PrintWriter(new OutputStreamWriter(System.out));
        
        // 读取数组长度n和操作次数m
        n = in.nextInt();
        m = in.nextInt();
        
        // 读取初始数组元素，注意这里数组索引从1开始
        for (int i = 1; i <= n; i++) {
            arr[i] = in.nextInt();
        }
        
        // 进行预处理，计算所有x <= sqrt(n)情况下的dp[x][y]值
        prepare();
        
        // 处理m次操作
        char op;       // 操作类型：'A'表示查询，'C'表示更新
        int x, y;      // 操作参数
        for (int i = 1; i <= m; i++) {
            op = in.nextChar();  // 读取操作类型
            x = in.nextInt();   // 读取第一个参数
            y = in.nextInt();   // 读取第二个参数
            
            if (op == 'A') {
                // 查询操作：计算所有满足i % x == y的位置i对应的arr[i]之和
                out.println(query(x, y));
            } else {
                // 更新操作：将arr[x]的值更新为y，并更新相关的预处理结果
                update(x, y);
            }
        }
        
        // 确保所有输出被刷新到控制台
        out.flush();
        // 关闭输出流
        out.close();
    }

    /**
     * 高效读取工具类
     * 用于加速输入读取，比标准Scanner类速度更快，适用于大数据量输入的场景
     * 采用缓冲区读取策略，减少I/O操作次数
     */
    static class FastReader {
        /**
         * 缓冲区大小，设为2^16以平衡内存使用和读取效率
         */
        final private int BUFFER_SIZE = 1 << 16;
        /**
         * 输入流对象，默认使用System.in
         */
        private final InputStream in;
        /**
         * 字节缓冲区，用于存储批量读取的数据
         */
        private final byte[] buffer;
        /**
         * ptr: 当前读取位置指针
         * len: 当前缓冲区中有效数据的长度
         */
        private int ptr, len;

        /**
         * 构造函数，初始化输入流和缓冲区
         */
        public FastReader() {
            in = System.in;
            buffer = new byte[BUFFER_SIZE];
            ptr = len = 0;  // 初始化指针位置为0
        }

        /**
         * 检查缓冲区是否还有可读字节
         * 如果缓冲区已读完，尝试从输入流读取新数据到缓冲区
         * 
         * @return 如果有可读字节则返回true，否则返回false
         * @throws IOException 输入异常
         */
        private boolean hasNextByte() throws IOException {
            if (ptr < len)  // 缓冲区还有数据
                return true;
            ptr = 0;  // 重置指针到缓冲区开头
            len = in.read(buffer);  // 从输入流读取数据填充缓冲区
            return len > 0;  // 如果读取到数据则返回true
        }

        /**
         * 读取单个字节
         * 
         * @return 读取的字节值，如果到达流末尾返回-1
         * @throws IOException 输入异常
         */
        private byte readByte() throws IOException {
            if (!hasNextByte())
                return -1;
            return buffer[ptr++];  // 返回当前字节并移动指针
        }

        /**
         * 读取单个字符，跳过空白字符
         * 
         * @return 读取的非空白字符
         * @throws IOException 输入异常
         */
        public char nextChar() throws IOException {
            byte c;
            // 跳过所有空白字符
            do {
                c = readByte();
                if (c == -1)
                    return 0;
            } while (c <= ' ');
            char ans = 0;
            // 读取非空白字符
            while (c > ' ') {
                ans = (char) c;
                c = readByte();
            }
            return ans;
        }

        /**
         * 读取整数，支持正负数
         * 
         * @return 读取的整数值
         * @throws IOException 输入异常
         */
        public int nextInt() throws IOException {
            int num = 0;
            byte b = readByte();
            // 跳过前导空白字符
            while (isWhitespace(b))
                b = readByte();
            
            // 处理负号
            boolean minus = false;
            if (b == '-') {
                minus = true;
                b = readByte();
            }
            
            // 读取数字部分
            while (!isWhitespace(b) && b != -1) {
                num = num * 10 + (b - '0');  // 累积数字
                b = readByte();
            }
            
            return minus ? -num : num;  // 根据是否有负号返回结果
        }

        /**
         * 判断一个字节是否为空白字符
         * 空白字符包括空格、换行符、回车符和制表符
         * 
         * @param b 要判断的字节
         * @return 如果是空白字符则返回true，否则返回false
         */
        private boolean isWhitespace(byte b) {
            return b == ' ' || b == '\n' || b == '\r' || b == '\t';
        }
    }

}

===============================================

文件: Code01_HashCollision2.java
===============================================
package class175;

// 哈希冲突问题 - 分块算法实现 (Java版本2)
// 题目来源: https://www.luogu.com.cn/problem/P3396
// 题目大意: 给定一个长度为n的数组arr，支持两种操作：
// 1. 查询操作 A x y: 查询所有满足 i % x == y 的位置i对应的arr[i]之和
// 2. 更新操作 C x y: 将arr[x]的值更新为y
// 约束条件: 1 <= n、m <= 1.5 * 10^5
// 相关解答: 
// - C++版本: Code01_HashCollision.cpp
// - Java版本: Code01_HashCollision1.java, Code01_HashCollision2.java
// - Python版本: Code01_HashCollision.py

// 以下是C++版本的实现代码
// 注意：这些代码当前被注释掉了，仅作为参考
// 这个文件提供了C++实现的参考版本，与Java版本实现的是相同的分块算法
// 分块算法的核心思想：
// 1. 对于x <= sqrt(n)的情况：预处理所有可能的余数结果，使查询时间为O(1)
// 2. 对于x > sqrt(n)的情况：直接暴力枚举，因为x较大时最多执行sqrt(n)次循环
// 这种设计使得查询和更新操作的时间复杂度都是O(sqrt(n))

//#include <bits/stdc++.h>
//
//using namespace std;
//
//const int MAXN = 150001;
//const int MAXB = 401;
//int n, m, blen;
//int arr[MAXN];
//long long dp[MAXB][MAXB];
//
//long long query(int x, int y) {
//    if (x <= blen) {
//        return dp[x][y];
//    }
//    long long ans = 0;
//    for (int i = y; i <= n; i += x) {
//        ans += arr[i];
//    }
//    return ans;
//}
//
//void update(int i, int v) {
//    int delta = v - arr[i];
//    arr[i] = v;
//    for (int x = 1; x <= blen; x++) {
//        dp[x][i % x] += delta;
//    }
//}
//
//void prepare() {
//    blen = (int)sqrt(n);
//    for (int x = 1; x <= blen; x++) {
//        for (int i = 1; i <= n; i++) {
//            dp[x][i % x] += arr[i];
//        }
//    }
//}
//
//int main() {
//    ios::sync_with_stdio(false);
//    cin.tie(nullptr);
//    cin >> n >> m;
//    for (int i = 1; i <= n; i++) {
//        cin >> arr[i];
//    }
//    prepare();
//    char op;
//    int x, y;
//    for (int i = 1; i <= m; i++) {
//        cin >> op >> x >> y;
//        if (op == 'A') {
//            cout << query(x, y) << '\n';
//        } else {
//            update(x, y);
//        }
//    }
//    return 0;
//}

===============================================

文件: Code02_ArrayQueries.cpp
===============================================
// 数组查询问题 - 分块算法实现 (C++版本)
// 题目来源: https://www.luogu.com.cn/problem/CF797E
// 题目来源: https://codeforces.com/problemset/problem/797/E
// 题目大意: 给定一个长度为n的数组arr，支持查询操作：
// 查询 p k : 从位置p开始，每次跳跃arr[p] + k步，直到越界，返回跳跃次数
// 约束条件: 
// 1 <= n、q <= 10^5
// 1 <= arr[i] <= n
// 相关解答: 
// - C++版本: Code02_ArrayQueries.cpp
// - Java版本: Code02_ArrayQueries1.java, Code02_ArrayQueries2.java
// - Python版本: Code02_ArrayQueries.py
// 
// 分块算法分析：
// - 对于k较大的情况(k > sqrt(n))，由于每次跳跃的步长至少是sqrt(n)+1，所以最多跳跃sqrt(n)次
// - 对于k较小的情况(k <= sqrt(n))，可以预处理所有可能的情况，使查询时间为O(1)
// - 这种分块处理的策略使得总的时间复杂度为O(n*sqrt(n) + q*sqrt(n))，可以在1e5的数据规模下高效运行

#include <cstdio>
#include <cmath>
using namespace std;

const int MAXN = 100001;
const int MAXB = 401;
int n, q, blen;
int arr[MAXN];
int dp[MAXN][MAXB];

/**
 * 查询操作
 * 从位置p开始，每次跳跃arr[p] + k步，直到越界，返回跳跃次数
 * @param p 起始位置
 * @param k 跳跃增量
 * @return 跳跃次数
 * 
 * 算法策略:
 * - 对于k <= sqrt(n)的情况: O(1)时间复杂度，直接返回预处理好的dp[p][k]
 * - 对于k > sqrt(n)的情况: O(sqrt(n))时间复杂度，因为每次跳跃至少sqrt(n)+1步
 * 这种分块处理的策略使得查询操作的平均时间复杂度为O(sqrt(n))
 */
int query(int p, int k) {
    // 当k较小时(k <= blen)，直接使用预处理结果，O(1)时间
    if (k <= blen) {
        return dp[p][k];
    }
    
    // 当k较大时(k > blen)，直接模拟跳跃过程
    // 由于k > sqrt(n)，每次跳跃步长至少是arr[p] + k >= 1 + sqrt(n) + 1
    // 因此最多执行n/(1+sqrt(n)) < sqrt(n)次跳跃，总时间复杂度为O(sqrt(n))
    int ans = 0;
    while (p <= n) {
        ans++;  // 记录跳跃次数
        p += arr[p] + k;  // 计算下一个位置
    }
    return ans;
}

/**
 * 预处理函数
 * 对于所有k <= sqrt(n)的情况，预处理dp[p][k]的值
 * 使用动态规划从后往前计算，这样可以利用已计算的结果
 * 
 * 预处理策略:
 * - 计算块大小blen = sqrt(n)
 * - 从后往前遍历所有位置p (从n到1)
 * - 对每个位置p，计算所有k <= blen对应的dp[p][k]
 * - 使用动态规划的思路：dp[p][k] = 1 + (如果下一步越界则0，否则dp[p + arr[p] + k][k])
 * - 时间复杂度: O(n*sqrt(n))
 * 虽然预处理时间较高，但可以确保后续查询操作的高效性
 */
void prepare() {
    // 计算块大小，通常选择sqrt(n)
    blen = (int)sqrt((double)n);
    
    // 从后往前计算dp值
    // 这样可以确保在计算dp[p][k]时，dp[p + arr[p] + k][k]已经计算过了
    for (int p = n; p >= 1; p--) {
        // 对于每个k <= sqrt(n)的情况进行预处理
        for (int k = 1; k <= blen; k++) {
            // 计算从位置p跳一步后的新位置
            int next_pos = p + arr[p] + k;
            
            // 动态规划转移方程：
            // - 如果下一步越界(n+1或更大)，则dp[p][k] = 1（只跳转一次）
            // - 否则dp[p][k] = 1 + dp[next_pos][k]（一次跳转加上从next_pos开始的跳转次数）
            dp[p][k] = 1 + (next_pos > n ? 0 : dp[next_pos][k]);
        }
    }
}

/**
 * 主函数
 * 读取输入数据，初始化数组，预处理数据，处理所有查询
 * 
 * 主流程:
 * 1. 读取数组长度n
 * 2. 读取数组元素
 * 3. 调用prepare()函数进行预处理
 * 4. 读取查询次数q
 * 5. 处理每个查询，调用query()函数计算结果并输出
 */
int main() {
    // 读取数组长度n
    scanf("%d", &n);
    
    // 读取初始数组元素
    for (int i = 1; i <= n; i++) {
        scanf("%d", &arr[i]);
    }
    
    // 进行预处理，计算所有p和k<=sqrt(n)的dp[p][k]值
    prepare();
    
    // 读取查询次数q
    scanf("%d", &q);
    
    // 处理q次查询
    for (int i = 1, p, k; i <= q; i++) {
        // 读取查询参数p(起始位置)和k(跳跃增量)
        scanf("%d%d", &p, &k);
        // 计算并输出跳跃次数
        printf("%d\n", query(p, k));
    }
    return 0;
}

===============================================

文件: Code02_ArrayQueries.py
===============================================
# 数组查询问题 - 分块算法实现 (Python版本)
# 题目来源: https://www.luogu.com.cn/problem/CF797E
# 题目来源: https://codeforces.com/problemset/problem/797/E
# 题目大意: 给定一个长度为n的数组arr，支持查询操作：
# 查询 p k : 从位置p开始，每次跳跃arr[p] + k步，直到越界，返回跳跃次数
# 约束条件: 
# 1 <= n、q <= 10^5
# 1 <= arr[i] <= n

# 相关解答:
# C++版本: class175/Code02_ArrayQueries.cpp
# Java版本: class175/Code02_ArrayQueries.java
# Python版本: class175/Code02_ArrayQueries.py

# 分块算法分析:
# - 时间复杂度：预处理O(n*sqrt(n)) + 查询O(q*sqrt(n))
# - 空间复杂度：O(n*sqrt(n))
# - 分块思想：将k分为k<=sqrt(n)和k>sqrt(n)两种情况处理
#   - 当k<=sqrt(n)时：预处理所有位置p和k的结果，查询时间O(1)
#   - 当k>sqrt(n)时：直接暴力计算，由于k>sqrt(n)，每次跳跃步长至少sqrt(n)+1
#     因此最多只会跳sqrt(n)次，时间复杂度O(sqrt(n))

import math
import sys

# 定义最大数组长度和块大小
MAXN = 100001
MAXB = 401

# 全局变量
n, q, blen = 0, 0, 0
arr = [0] * MAXN
dp = [[0 for _ in range(MAXB)] for _ in range(MAXN)]

def query(p, k):
    """
    查询操作
    从位置p开始，每次跳跃arr[p] + k步，直到越界，返回跳跃次数
    
    算法策略：
    - 当k <= sqrt(n)时：使用预处理的结果，时间复杂度O(1)
    - 当k > sqrt(n)时：暴力计算，由于每次跳跃步长至少为sqrt(n)+1，
      最多只会跳sqrt(n)次，因此时间复杂度为O(sqrt(n))
    
    参数:
        p: 起始位置（从1开始索引）
        k: 跳跃增量
    返回:
        跳跃次数
    """
    # 当k较小时(k <= sqrt(n))，直接使用预处理结果，O(1)时间
    if k <= blen:
        return dp[p][k]
    
    # 当k较大时(k > sqrt(n))，暴力计算
    # 由于每次跳跃步长至少为sqrt(n)+1，最多只会执行sqrt(n)次跳跃
    # 因此时间复杂度为O(sqrt(n))
    ans = 0
    while p <= n:  # 当位置p未越界时继续跳跃
        ans += 1    # 跳跃次数加1
        p += arr[p] + k  # 计算下一个位置：当前位置 + 当前位置的值 + k
    return ans

def prepare():
    """
    预处理函数
    对于所有k <= sqrt(n)的情况，预处理dp[p][k]的值
    
    预处理策略：
    - 计算块大小blen = sqrt(n)
    - 从后往前遍历所有位置p (从n到1)
    - 对每个位置p，计算所有k <= blen对应的dp[p][k]
    - 使用动态规划的思路：dp[p][k] = 1 + (如果下一步越界则0，否则dp[p + arr[p] + k][k])
    
    实现细节：
    - 从后往前计算是关键，这样可以确保在计算dp[p][k]时，dp[p + arr[p] + k][k]已经计算过了
    - dp[p][k]表示从位置p开始，每次跳跃增量k时的总跳跃次数
    - 时间复杂度：O(n*sqrt(n))，虽然预处理时间较高，但可以确保后续查询操作的高效性
    """
    global blen
    # 计算块大小，通常选择sqrt(n)作为分块的阈值
    blen = int(math.sqrt(n))
    
    # 从后往前计算dp值 - 这是动态规划的关键部分
    # 从数组末尾开始，向数组头部遍历
    # 这样设计可以确保在计算dp[p][k]时，dp[p + arr[p] + k][k]已经被计算过了
    for p in range(n, 0, -1):
        # 对每个k <= sqrt(n)的情况进行预处理
        for k in range(1, blen + 1):
            # 计算从位置p跳一步后的新位置
            next_pos = p + arr[p] + k
            
            # 动态规划转移方程：
            # - 如果下一步越界(n+1或更大)，则dp[p][k] = 1（只跳转一次）
            # - 否则dp[p][k] = 1 + dp[next_pos][k]（一次跳转加上从next_pos开始的跳转次数）
            dp[p][k] = 1 + (0 if next_pos > n else dp[next_pos][k])

def main():
    """
    主函数
    程序执行流程：
    1. 读取数组长度n
    2. 读取初始数组arr的值
    3. 调用prepare()函数进行预处理
    4. 读取查询次数q
    5. 处理每个查询，输出结果
    
    注意事项：
    - 数组索引从1开始，而不是0
    - 输入数据通过标准输入读取
    - 每个查询的结果立即输出
    """
    global n, q
    
    # 读取数组长度n
    n = int(sys.stdin.readline())
    
    # 读取初始数组，注意Python中的列表是0索引，但我们的实现中使用1索引
    values = list(map(int, sys.stdin.readline().split()))
    for i in range(1, n + 1):
        arr[i] = values[i - 1]  # 将0索引的输入值复制到1索引的数组中
    
    # 进行预处理，为所有k <= sqrt(n)的情况预计算dp数组
    prepare()
    
    # 读取查询次数q
    q = int(sys.stdin.readline())
    
    # 处理q次查询
    # 对于每个查询，读取起始位置p和跳跃增量k，然后调用query函数计算结果并输出
    for _ in range(q):
        p, k = map(int, sys.stdin.readline().split())
        print(query(p, k))  # 输出查询结果

if __name__ == "__main__":
    main()

===============================================

文件: Code02_ArrayQueries1.java
===============================================
package class175;

// 数组查询问题 - 分块算法实现 (Java版本)
// 题目来源: https://www.luogu.com.cn/problem/CF797E
// 题目来源: https://codeforces.com/problemset/problem/797/E
// 题目大意: 给定一个长度为n的数组arr，支持查询操作：
// 查询 p k : 从位置p开始，每次跳跃arr[p] + k步，直到越界，返回跳跃次数
// 约束条件: 
// 1 <= n、q <= 10^5
// 1 <= arr[i] <= n

// 相关解答:
// C++版本: class175/Code02_ArrayQueries.cpp
// Java版本: class175/Code02_ArrayQueries1.java
// Python版本: class175/Code02_ArrayQueries.py

// 分块算法分析:
// - 时间复杂度：预处理O(n*sqrt(n)) + 查询O(q*sqrt(n))
// - 空间复杂度：O(n*sqrt(n))
// - 分块思想：将k分为k<=sqrt(n)和k>sqrt(n)两种情况处理
//   - 当k<=sqrt(n)时：预处理所有位置p和k的结果，查询时间O(1)
//   - 当k>sqrt(n)时：直接暴力计算，由于k>sqrt(n)，每次跳跃步长至少sqrt(n)+1
//     因此最多只会跳sqrt(n)次，时间复杂度O(sqrt(n))

import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStreamWriter;
import java.io.PrintWriter;

public class Code02_ArrayQueries1 {

    // 定义最大数组长度和块大小
    public static int MAXN = 100001;
    public static int MAXB = 401;
    
    // n: 数组长度, q: 查询次数, blen: 块大小
    public static int n, q, blen;
    
    // arr: 原始数组
    public static int[] arr = new int[MAXN];
    
    // dp[p][k]: 从位置p开始，每次跳跃arr[p] + k步，直到越界需要的步数（预处理结果）
    // 只对 k <= sqrt(n) 的情况进行预处理
    public static int[][] dp = new int[MAXN][MAXB];

    /**
     * 查询操作
     * 从位置p开始，每次跳跃arr[p] + k步，直到越界，返回跳跃次数
     * 
     * 算法策略：
     * - 当k <= sqrt(n)时：使用预处理的结果，时间复杂度O(1)
     * - 当k > sqrt(n)时：暴力计算，由于每次跳跃步长至少为sqrt(n)+1，
     *   最多只会跳sqrt(n)次，因此时间复杂度为O(sqrt(n))
     * 
     * @param p 起始位置（从1开始索引）
     * @param k 跳跃增量
     * @return 跳跃次数
     */
    public static int query(int p, int k) {
        // 当k较小时(k <= sqrt(n))，直接使用预处理结果，O(1)时间
        if (k <= blen) {
            return dp[p][k];
        }
        
        // 当k较大时(k > sqrt(n))，暴力计算
        // 由于每次跳跃步长至少为sqrt(n)+1，最多只会执行sqrt(n)次跳跃
        // 因此时间复杂度为O(sqrt(n))
        int ans = 0;
        while (p <= n) {  // 当位置p未越界时继续跳跃
            ans++;         // 跳跃次数加1
            p += arr[p] + k;  // 计算下一个位置：当前位置 + 当前位置的值 + k
        }
        return ans;
    }

    /**
     * 预处理函数
     * 对于所有k <= sqrt(n)的情况，预处理dp[p][k]的值
     * 
     * 预处理策略：
     * - 计算块大小blen = sqrt(n)
     * - 从后往前遍历所有位置p (从n到1)
     * - 对每个位置p，计算所有k <= blen对应的dp[p][k]
     * - 使用动态规划的思路：dp[p][k] = 1 + (如果下一步越界则0，否则dp[p + arr[p] + k][k])
     * 
     * 实现细节：
     * - 从后往前计算是关键，这样可以确保在计算dp[p][k]时，dp[p + arr[p] + k][k]已经计算过了
     * - dp[p][k]表示从位置p开始，每次跳跃增量k时的总跳跃次数
     * - 时间复杂度：O(n*sqrt(n))，虽然预处理时间较高，但可以确保后续查询操作的高效性
     */
    public static void prepare() {
        // 计算块大小，通常选择sqrt(n)作为分块的阈值
        blen = (int) Math.sqrt(n);
        
        // 从后往前计算dp值 - 这是动态规划的关键部分
        // 从数组末尾开始，向数组头部遍历
        // 这样设计可以确保在计算dp[p][k]时，dp[p + arr[p] + k][k]已经被计算过了
        for (int p = n; p >= 1; p--) {
            // 对每个k <= sqrt(n)的情况进行预处理
            for (int k = 1; k <= blen; k++) {
                // 计算从位置p跳一步后的新位置
                int next_pos = p + arr[p] + k;
                
                // 动态规划转移方程：
                // - 如果下一步越界(n+1或更大)，则dp[p][k] = 1（只跳转一次）
                // - 否则dp[p][k] = 1 + dp[next_pos][k]（一次跳转加上从next_pos开始的跳转次数）
                dp[p][k] = 1 + (next_pos > n ? 0 : dp[next_pos][k]);
            }
        }
    }

    /**
     * 主函数
     * 程序执行流程：
     * 1. 初始化高效输入输出工具类
     * 2. 读取数组长度n
     * 3. 读取初始数组arr的值
     * 4. 调用prepare()函数进行预处理
     * 5. 读取查询次数q
     * 6. 处理每个查询，输出结果
     * 
     * 注意事项：
     * - 数组索引从1开始，而不是0
     * - 使用FastReader类提高输入速度
     * - 每个查询的结果立即输出
     * 
     * @param args 命令行参数
     * @throws Exception 输入输出异常
     */
    public static void main(String[] args) throws Exception {
        // 初始化高效输入输出工具类，用于处理大规模数据
        FastReader in = new FastReader(System.in);
        PrintWriter out = new PrintWriter(new OutputStreamWriter(System.out));
        
        // 读取数组长度n
        n = in.nextInt();
        
        // 读取初始数组，注意数组索引从1开始
        for (int i = 1; i <= n; i++) {
            arr[i] = in.nextInt();
        }
        
        // 进行预处理，为所有k <= sqrt(n)的情况预计算dp数组
        prepare();
        
        // 读取查询次数q
        q = in.nextInt();
        
        // 处理q次查询
        // 对于每个查询，读取起始位置p和跳跃增量k，然后调用query函数计算结果并输出
        for (int i = 1, p, k; i <= q; i++) {
            p = in.nextInt();
            k = in.nextInt();
            out.println(query(p, k));
        }
        
        // 刷新输出缓冲区并关闭输出流
        out.flush();
        out.close();
    }

    // 高效读取工具类，用于加快输入输出速度
    static class FastReader {
        private final byte[] buffer = new byte[1 << 16];
        private int ptr = 0, len = 0;
        private final InputStream in;

        FastReader(InputStream in) {
            this.in = in;
        }

        private int readByte() throws IOException {
            if (ptr >= len) {
                len = in.read(buffer);
                ptr = 0;
                if (len <= 0)
                    return -1;
            }
            return buffer[ptr++];
        }

        int nextInt() throws IOException {
            int c;
            do {
                c = readByte();
            } while (c <= ' ' && c != -1);
            boolean neg = false;
            if (c == '-') {
                neg = true;
                c = readByte();
            }
            int val = 0;
            while (c > ' ' && c != -1) {
                val = val * 10 + (c - '0');
                c = readByte();
            }
            return neg ? -val : val;
        }
    }

}

===============================================

文件: Code02_ArrayQueries2.java
===============================================
package class175;

// 数组查询问题 - 分块算法实现 (C++版本的Java注释版)
// 题目来源: https://www.luogu.com.cn/problem/CF797E
// 题目来源: https://codeforces.com/problemset/problem/797/E
// 题目大意: 给定一个长度为n的数组arr，支持查询操作：
// 查询 p k : 从位置p开始，每次跳跃arr[p] + k步，直到越界，返回跳跃次数
// 约束条件: 
// 1 <= n、q <= 10^5
// 1 <= arr[i] <= n

// 相关解答:
// C++版本: class175/Code02_ArrayQueries.cpp
// Java版本: class175/Code02_ArrayQueries1.java
// Python版本: class175/Code02_ArrayQueries.py

// 分块算法分析:
// - 时间复杂度：预处理O(n*sqrt(n)) + 查询O(q*sqrt(n))
// - 空间复杂度：O(n*sqrt(n))
// - 分块思想：将k分为k<=sqrt(n)和k>sqrt(n)两种情况处理
//   - 当k<=sqrt(n)时：预处理所有位置p和k的结果，查询时间O(1)
//   - 当k>sqrt(n)时：直接暴力计算，由于k>sqrt(n)，每次跳跃步长至少sqrt(n)+1
//     因此最多只会跳sqrt(n)次，时间复杂度O(sqrt(n))

// 注：此文件包含的是C++版本的实现（已注释），用于参考
// 提交到OJ平台时，需要将代码转换为C++格式并移除注释符号

//#include <bits/stdc++.h>
//
//using namespace std;
//
//const int MAXN = 100001;
//const int MAXB = 401;
//int n, q, blen;
//int arr[MAXN];
//int dp[MAXN][MAXB];
//
//int query(int p, int k) {
//    if (k <= blen) {
//        return dp[p][k];
//    }
//    int ans = 0;
//    while (p <= n) {
//        ans++;
//        p += arr[p] + k;
//    }
//    return ans;
//}
//
//void prepare() {
//    blen = (int)sqrt(n);
//    for (int p = n; p >= 1; p--) {
//        for (int k = 1; k <= blen; k++) {
//            dp[p][k] = 1 + (p + arr[p] + k > n ? 0 : dp[p + arr[p] + k][k]);
//        }
//    }
//}
//
//int main() {
//    ios::sync_with_stdio(false);
//    cin.tie(nullptr);
//    cin >> n;
//    for (int i = 1; i <= n; i++) {
//        cin >> arr[i];
//    }
//    prepare();
//    cin >> q;
//    for (int i = 1, p, k; i <= q; i++) {
//        cin >> p >> k;
//        cout << query(p, k) << '\n';
//    }
//    return 0;
//}

===============================================

文件: Code03_SumOfProgression.cpp
===============================================
// 等差数列求和问题 - 分块算法实现 (C++版本)
// 题目来源: https://www.luogu.com.cn/problem/CF1921F
// 题目来源: https://codeforces.com/problemset/problem/1921/F
// 题目大意: 给定一个长度为n的数组arr，支持查询操作：
// 查询 s d k : arr[s]作为第1项、arr[s + 1*d]作为第2项、arr[s + 2*d]作为第3项...
//             每项的值 * 项的编号，一共k项都累加起来，打印累加和
// 约束条件: 
// 1 <= n <= 10^5
// 1 <= q <= 2 * 10^5

// 相关解答:
// C++版本: class175/Code03_SumOfProgression.cpp
// Java版本: class175/Code03_SumOfProgression1.java
// Python版本: class175/Code03_SumOfProgression.py

// 分块算法分析:
// - 时间复杂度：预处理O(n*sqrt(n)) + 查询O(q*sqrt(n))
// - 空间复杂度：O(n*sqrt(n))
// - 分块思想：将公差d分为d<=sqrt(n)和d>sqrt(n)两种情况处理
//   - 当d<=sqrt(n)时：预处理前缀和数组f和加权前缀和数组g，查询时间O(1)
//   - 当d>sqrt(n)时：直接暴力计算，由于d>sqrt(n)，每个查询最多处理O(sqrt(n))个元素
//     因此查询时间复杂度为O(sqrt(n))

#include <cstdio>
#include <cmath>
using namespace std;

const int MAXN = 100001;
const int MAXB = 401;
int t, n, q, blen;
int arr[MAXN];
long long f[MAXB][MAXN];
long long g[MAXB][MAXN];

/**
 * 查询操作
 * arr[s]作为第1项、arr[s + 1*d]作为第2项、arr[s + 2*d]作为第3项...
 * 每项的值 * 项的编号，一共k项都累加起来，返回累加和
 * 
 * 算法策略：
 * - 当d <= sqrt(n)时：使用预处理的g数组和f数组计算，时间复杂度O(1)
 * - 当d > sqrt(n)时：直接暴力计算，由于d>sqrt(n)，每个查询最多处理O(sqrt(n))个元素
 *   因此查询时间复杂度为O(sqrt(n))
 * 
 * 预处理数组说明：
 * - f[d][i]: 从位置i开始，公差为d的等差数列所有项的普通前缀和
 * - g[d][i]: 从位置i开始，公差为d的等差数列所有项的加权前缀和（每项乘以项的编号）
 * 
 * @param s 起始位置（从1开始索引）
 * @param d 公差
 * @param k 项数
 * @return 加权和
 */
long long query(int s, int d, int k) {
    long long ans = 0;
    
    // 当公差d较小时(d <= sqrt(n))，使用预处理的结果，O(1)时间
    if (d <= blen) {
        // g[d][s] 是从位置s开始的加权前缀和
        ans = g[d][s];
        
        // 如果s + d * k没有超出数组范围，则需要减去后面的部分
        // 这里使用了差分数组的思想，只计算前k项的和
        if (s + d * k <= n) {
            // 减去从s + d * k开始的部分
            // 注意需要加上f[d][s + d*k] * k，这是因为后续项的权重需要调整
            ans -= g[d][s + d * k] + f[d][s + d * k] * k;
        }
    } else {
        // 当公差d较大时(d > sqrt(n))，直接暴力计算
        // 由于d>sqrt(n)，k项最多只会跨越O(sqrt(n))个位置
        // 因此时间复杂度为O(sqrt(n))
        for (int i = 1; i <= k; i++) {
            // 第i项的位置是s + (i-1)*d，值乘以项的编号i
            ans += 1LL * arr[s + (i - 1) * d] * i;
        }
    }
    return ans;
}

/**
 * 预处理函数
 * 预处理f和g数组，用于快速回答公差d较小的查询
 * 
 * 预处理策略：
 * - 计算块大小blen = sqrt(n)
 * - 对于每个公差d <= blen，预处理两个数组：
 *   1. f[d][i]: 从位置i开始，公差为d的等差数列所有项的普通前缀和
 *   2. g[d][i]: 从位置i开始，公差为d的等差数列所有项的加权前缀和（每项乘以项的编号）
 * - 预处理顺序是从后往前（从n到1），确保计算f[d][i]时f[d][i+d]已经计算完成
 * 
 * 数学关系：
 * - f[d][i] = arr[i] + f[d][i+d] (如果i+d <= n)
 * - g[d][i] = arr[i] + (arr[i+d] + arr[i+2d] + ...) + g[d][i+d]
 *            = arr[i] + f[d][i+d] + g[d][i+d]
 *            = f[d][i] + g[d][i+d] (因为f[d][i] = arr[i] + f[d][i+d])
 * 
 * 时间复杂度：O(n*sqrt(n))
 * 空间复杂度：O(n*sqrt(n))
 */
void prepare() {
    // 计算块大小，通常选择sqrt(n)
    blen = (int)sqrt((double)n);
    
    // 预处理f数组
    // 对于每个公差d <= sqrt(n)
    for (int d = 1; d <= blen; d++) {
        // 从后往前计算前缀和
        // 这种方式确保在计算f[d][i]时，f[d][i+d]已经计算完成
        for (int i = n; i >= 1; i--) {
            // f[d][i] = arr[i] + f[d][i+d] (如果i+d <= n)
            // 如果i+d超出数组范围，则f[d][i] = arr[i]
            f[d][i] = arr[i] + (i + d > n ? 0 : f[d][i + d]);
        }
    }
    
    // 预处理g数组
    // 对于每个公差d <= sqrt(n)
    for (int d = 1; d <= blen; d++) {
        // 从后往前计算加权前缀和
        // 同样，确保在计算g[d][i]时，g[d][i+d]和f[d][i+d]已经计算完成
        for (int i = n; i >= 1; i--) {
            // g[d][i] = f[d][i] + g[d][i+d] (如果i+d <= n)
            // 这里利用了f和g之间的数学关系
            // 如果i+d超出数组范围，则g[d][i] = f[d][i] = arr[i]
            g[d][i] = f[d][i] + (i + d > n ? 0 : g[d][i + d]);
        }
    }
}

/**
 * 主函数
 * 处理多组测试用例，每组包括输入数组、预处理、处理查询
 * 
 * 流程：
 * 1. 读取测试用例数量t
 * 2. 对于每个测试用例：
 *    a. 读取数组长度n和查询次数q
 *    b. 读取长度为n的数组arr（从索引1开始存储）
 *    c. 调用prepare()函数进行预处理
 *    d. 处理q次查询，每次读取参数s、d、k并输出结果
 * 
 * 注意事项：
 * - 使用scanf和printf进行输入输出以提高效率，适用于大数据量的情况
 * - 数组索引从1开始，这与题目描述一致，方便处理
 */
int main() {
    // 读取测试用例数t
    scanf("%d", &t);
    
    // 处理每个测试用例
    for (int c = 1; c <= t; c++) {
        // 读取数组长度n和查询次数q
        scanf("%d%d", &n, &q);
        
        // 读取初始数组（索引从1开始）
        for (int i = 1; i <= n; i++) {
            scanf("%d", &arr[i]);
        }
        
        // 进行预处理，构建f和g数组
        // 预处理时间复杂度为O(n*sqrt(n))
        prepare();
        
        // 处理q次查询
        for (int i = 1, s, d, k; i <= q; i++) {
            // 读取查询参数：起始位置s，公差d，项数k
            scanf("%d%d%d", &s, &d, &k);
            // 调用查询函数并输出结果
            printf("%lld\n", query(s, d, k));
        }
    }
    return 0;
}

===============================================

文件: Code03_SumOfProgression.py
===============================================
# 等差数列求和问题 - 分块算法实现 (Python版本)
# 题目来源: https://www.luogu.com.cn/problem/CF1921F
# 题目来源: https://codeforces.com/problemset/problem/1921/F
# 题目大意: 给定一个长度为n的数组arr，支持查询操作：
# 查询 s d k : arr[s]作为第1项、arr[s + 1*d]作为第2项、arr[s + 2*d]作为第3项...
#             每项的值 * 项的编号，一共k项都累加起来，打印累加和
# 约束条件: 
# 1 <= n <= 10^5
# 1 <= q <= 2 * 10^5

import math
import sys

# 定义最大数组长度和块大小
MAXN = 100001
MAXB = 401

# 全局变量
t, n, q, blen = 0, 0, 0, 0
arr = [0] * MAXN
f = [[0 for _ in range(MAXN)] for _ in range(MAXB)]
g = [[0 for _ in range(MAXN)] for _ in range(MAXB)]

def query(s, d, k):
    """
    查询操作
    arr[s]作为第1项、arr[s + 1*d]作为第2项、arr[s + 2*d]作为第3项...
    每项的值 * 项的编号，一共k项都累加起来，返回累加和
    参数:
        s: 起始位置
        d: 公差
        k: 项数
    返回:
        加权和
    """
    ans = 0
    
    # 如果d小于等于块大小，则使用预处理的结果
    if d <= blen:
        # g[d][s] 是从位置s开始的加权前缀和
        ans = g[d][s]
        
        # 如果s + d * k没有超出数组范围，则需要减去后面的部分
        if s + d * k <= n:
            # 减去从s + d * k开始的部分
            ans = ans - g[d][s + d * k] - f[d][s + d * k] * k
    else:
        # 否则暴力计算（适用于d较大的情况）
        for i in range(1, k + 1):
            ans += arr[s + (i - 1) * d] * i
    return ans

def prepare():
    """
    预处理函数
    预处理f和g数组
    """
    global blen
    # 计算块大小，通常选择sqrt(n)
    blen = int(math.sqrt(n))
    
    # 预处理f数组
    # 对于每个公差d <= sqrt(n)
    for d in range(1, blen + 1):
        # 从后往前计算前缀和
        for i in range(n, 0, -1):
            # f[d][i] = arr[i] + f[d][i+d]
            f[d][i] = arr[i] + (0 if i + d > n else f[d][i + d])
    
    # 预处理g数组
    # 对于每个公差d <= sqrt(n)
    for d in range(1, blen + 1):
        # 从后往前计算加权前缀和
        for i in range(n, 0, -1):
            # g[d][i] = arr[i] + g[d][i+d] + f[d][i+d]
            g[d][i] = f[d][i] + (0 if i + d > n else g[d][i + d])

def main():
    global t, n, q
    # 读取测试用例数t
    t = int(sys.stdin.readline())
    
    # 处理每个测试用例
    for _ in range(t):
        # 读取数组长度n和查询次数q
        n, q = map(int, sys.stdin.readline().split())
        
        # 读取初始数组
        values = list(map(int, sys.stdin.readline().split()))
        for i in range(1, n + 1):
            arr[i] = values[i - 1]
        
        # 进行预处理
        prepare()
        
        # 处理q次查询
        for _ in range(q):
            s, d, k = map(int, sys.stdin.readline().split())
            print(query(s, d, k))

if __name__ == "__main__":
    main()

===============================================

文件: Code03_SumOfProgression1.java
===============================================
package class175;

// 等差数列求和问题 - 分块算法实现 (Java版本)
// 题目来源: https://www.luogu.com.cn/problem/CF1921F
// 题目来源: https://codeforces.com/problemset/problem/1921/F
// 题目大意: 给定一个长度为n的数组arr，支持查询操作：
// 查询 s d k : arr[s]作为第1项、arr[s + 1*d]作为第2项、arr[s + 2*d]作为第3项...
//             每项的值 * 项的编号，一共k项都累加起来，打印累加和
// 约束条件: 
// 1 <= n <= 10^5
// 1 <= q <= 2 * 10^5

import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStreamWriter;
import java.io.PrintWriter;

public class Code03_SumOfProgression1 {

    // 定义最大数组长度和块大小
    public static int MAXN = 100001;
    public static int MAXB = 401;
    
    // t: 测试用例数, n: 数组长度, q: 查询次数, blen: 块大小
    public static int t, n, q, blen;
    
    // arr: 原始数组
    public static int[] arr = new int[MAXN];
    
    // f[d][i]: 从位置i开始，公差为d的等差数列的前缀和
    // f[d][i] = arr[i] + arr[i+d] + arr[i+2*d] + ...
    public static long[][] f = new long[MAXB][MAXN];
    
    // g[d][i]: 从位置i开始，公差为d的等差数列的加权前缀和
    // g[d][i] = 1*arr[i] + 2*arr[i+d] + 3*arr[i+2*d] + ...
    public static long[][] g = new long[MAXB][MAXN];

    /**
     * 查询操作
     * arr[s]作为第1项、arr[s + 1*d]作为第2项、arr[s + 2*d]作为第3项...
     * 每项的值 * 项的编号，一共k项都累加起来，返回累加和
     * @param s 起始位置
     * @param d 公差
     * @param k 项数
     * @return 加权和
     */
    public static long query(int s, int d, int k) {
        long ans = 0;
        
        // 如果d小于等于块大小，则使用预处理的结果
        if (d <= blen) {
            // g[d][s] 是从位置s开始的加权前缀和
            ans = g[d][s];
            
            // 如果s + d * k没有超出数组范围，则需要减去后面的部分
            if (s + d * k <= n) {
                // 减去从s + d * k开始的部分
                ans = ans - g[d][s + d * k] - f[d][s + d * k] * k;
            }
        } else {
            // 否则暴力计算（适用于d较大的情况）
            for (int i = 1; i <= k; i++) {
                ans += 1L * arr[s + (i - 1) * d] * i;
            }
        }
        return ans;
    }

    /**
     * 预处理函数
     * 预处理f和g数组
     */
    public static void prepare() {
        // 计算块大小，通常选择sqrt(n)
        blen = (int) Math.sqrt(n);
        
        // 预处理f数组
        // 对于每个公差d <= sqrt(n)
        for (int d = 1; d <= blen; d++) {
            // 从后往前计算前缀和
            for (int i = n; i >= 1; i--) {
                // f[d][i] = arr[i] + f[d][i+d]
                f[d][i] = arr[i] + (i + d > n ? 0 : f[d][i + d]);
            }
        }
        
        // 预处理g数组
        // 对于每个公差d <= sqrt(n)
        for (int d = 1; d <= blen; d++) {
            // 从后往前计算加权前缀和
            for (int i = n; i >= 1; i--) {
                // g[d][i] = arr[i] + g[d][i+d] + f[d][i+d]
                g[d][i] = f[d][i] + (i + d > n ? 0 : g[d][i + d]);
            }
        }
    }

    public static void main(String[] args) throws Exception {
        FastReader in = new FastReader(System.in);
        PrintWriter out = new PrintWriter(new OutputStreamWriter(System.out));
        
        // 读取测试用例数t
        t = in.nextInt();
        
        // 处理每个测试用例
        for (int c = 1; c <= t; c++) {
            // 读取数组长度n和查询次数q
            n = in.nextInt();
            q = in.nextInt();
            
            // 读取初始数组
            for (int i = 1; i <= n; i++) {
                arr[i] = in.nextInt();
            }
            
            // 进行预处理
            prepare();
            
            // 处理q次查询
            for (int i = 1, s, d, k; i <= q; i++) {
                s = in.nextInt();
                d = in.nextInt();
                k = in.nextInt();
                out.println(query(s, d, k));
            }
        }
        
        out.flush();
        out.close();
    }

    // 高效读取工具类，用于加快输入输出速度
    static class FastReader {
        private final byte[] buffer = new byte[1 << 16];
        private int ptr = 0, len = 0;
        private final InputStream in;

        FastReader(InputStream in) {
            this.in = in;
        }

        private int readByte() throws IOException {
            if (ptr >= len) {
                len = in.read(buffer);
                ptr = 0;
                if (len <= 0)
                    return -1;
            }
            return buffer[ptr++];
        }

        int nextInt() throws IOException {
            int c;
            do {
                c = readByte();
            } while (c <= ' ' && c != -1);
            boolean neg = false;
            if (c == '-') {
                neg = true;
                c = readByte();
            }
            int val = 0;
            while (c > ' ' && c != -1) {
                val = val * 10 + (c - '0');
                c = readByte();
            }
            return neg ? -val : val;
        }
    }

}

===============================================

文件: Code03_SumOfProgression2.java
===============================================
package class175;

// 等差数列求和问题 - 分块算法实现 (C++版本的Java注释版)
// 题目来源: https://www.luogu.com.cn/problem/CF1921F
// 题目来源: https://codeforces.com/problemset/problem/1921/F
// 题目大意: 给定一个长度为n的数组arr，支持查询操作：
// 查询 s d k : arr[s]作为第1项、arr[s + 1*d]作为第2项、arr[s + 2*d]作为第3项...
//             每项的值 * 项的编号，一共k项都累加起来，打印累加和
// 约束条件: 
// 1 <= n <= 10^5
// 1 <= q <= 2 * 10^5

// 以下是C++版本的实现，逻辑与Java版本完全一致
// 提交时需要将代码转换为C++格式

//#include <bits/stdc++.h>
//
//using namespace std;
//
//const int MAXN = 100001;
//const int MAXB = 401;
//int t, n, q, blen;
//int arr[MAXN];
//long long f[MAXB][MAXN];
//long long g[MAXB][MAXN];
//
//long long query(int s, int d, int k) {
//    long long ans = 0;
//    if (d <= blen) {
//        ans = g[d][s];
//        if (s + d * k <= n) {
//            ans -= g[d][s + d * k] + f[d][s + d * k] * k;
//        }
//    } else {
//        for (int i = 1; i <= k; i++) {
//            ans += 1LL * arr[s + (i - 1) * d] * i;
//        }
//    }
//    return ans;
//}
//
//void prepare() {
//    blen = (int)sqrt(n);
//    for (int d = 1; d <= blen; d++) {
//        for (int i = n; i >= 1; i--) {
//            f[d][i] = arr[i] + (i + d > n ? 0 : f[d][i + d]);
//        }
//    }
//    for (int d = 1; d <= blen; d++) {
//        for (int i = n; i >= 1; i--) {
//            g[d][i] = f[d][i] + (i + d > n ? 0 : g[d][i + d]);
//        }
//    }
//}
//
//int main() {
//    ios::sync_with_stdio(false);
//    cin.tie(nullptr);
//    cin >> t;
//    for (int c = 1; c <= t; c++) {
//        cin >> n >> q;
//        for (int i = 1; i <= n; i++) {
//            cin >> arr[i];
//        }
//        prepare();
//        for (int i = 1, s, d, k; i <= q; i++) {
//            cin >> s >> d >> k;
//            cout << query(s, d, k) << '\n';
//        }
//    }
//    return 0;
//}

===============================================

文件: Code04_Initialization.cpp
===============================================
// 初始化问题 - 分块算法实现 (C++版本)
// 题目来源: https://www.luogu.com.cn/problem/P5309
// 题目大意: 给定一个长度为n的数组arr，支持两种操作：
// 操作 1 x y z : 从arr[y]开始，下标每次+x，所有相应位置的数都+z，题目保证 y <= x
// 操作 2 x y   : 打印arr[x..y]的累加和，答案对1000000007取余
// 约束条件: 1 <= n、m <= 2 * 10^5

#include <cstdio>
#include <cmath>
#include <algorithm>
using namespace std;

const int MAXN = 200001;
const int MAXB = 501;
const int MOD  = 1000000007;
int n, m;

long long pre[MAXB][MAXB];
long long suf[MAXB][MAXB];
long long arr[MAXN];
long long sum[MAXB];

int blen, bnum;
int bi[MAXN];
int bl[MAXB];
int br[MAXB];

/**
 * 操作 1 x y z
 * 从arr[y]开始，下标每次+x，所有相应位置的数都+z
 * @param x 步长
 * @param y 起始位置
 * @param z 增量
 */
void add(int x, int y, long long z) {
    // 如果步长x小于等于块大小，则更新pre和suf数组
    if (x <= blen) {
        // 更新前缀和增量
        for (int i = y; i <= x; i++) {
            pre[x][i] += z;
        }
        // 更新后缀和增量
        for (int i = y; i >= 1; i--) {
            suf[x][i] += z;
        }
    } else {
        // 否则直接更新原数组和块和
        for (int i = y; i <= n; i += x) {
            arr[i] += z;
            sum[bi[i]] += z;
        }
    }
}

/**
 * 查询区间和
 * @param l 左边界
 * @param r 右边界
 * @return 区间和
 */
long long querySum(int l, int r) {
    // 获取左右边界所在的块
    int lb = bi[l], rb = bi[r];
    long long ans = 0;
    
    // 如果左右边界在同一个块内
    if (lb == rb) {
        // 直接遍历计算
        for (int i = l; i <= r; i++) {
            ans += arr[i];
        }
    } else {
        // 否则分三部分计算
        // 1. 左边不完整块
        for (int i = l; i <= br[lb]; i++) {
            ans += arr[i];
        }
        // 2. 右边不完整块
        for (int i = bl[rb]; i <= r; i++) {
            ans += arr[i];
        }
        // 3. 中间完整块
        for (int b = lb + 1; b <= rb - 1; b++) {
            ans += sum[b];
        }
    }
    return ans;
}

/**
 * 操作 2 x y
 * 查询arr[x..y]的累加和
 * @param l 左边界
 * @param r 右边界
 * @return 区间和对MOD取余
 */
long long query(int l, int r) {
    long long ans = querySum(l, r);
    
    // 对于所有步长x <= sqrt(n)，累加其对区间和的贡献
    for (int x = 1, lth, rth, num; x <= blen; x++) {
        // 计算起始位置和结束位置在步长为x时对应的编号
        lth = (l - 1) / x + 1;
        rth = (r - 1) / x + 1;
        
        // 计算中间完整段的数量
        num = rth - lth - 1;
        
        // 如果起始和结束位置在同一段
        if (lth == rth) {
            // 只需要计算起始段的贡献
            ans = ans + pre[x][(r - 1) % x + 1] - pre[x][(l - 1) % x];
        } else {
            // 否则需要计算三部分的贡献
            // 1. 起始段的后缀贡献
            // 2. 中间完整段的贡献
            // 3. 结束段的前缀贡献
            ans = ans + suf[x][(l - 1) % x + 1] + pre[x][x] * num + pre[x][(r - 1) % x + 1];
        }
    }
    return ans % MOD;
}

/**
 * 预处理函数
 * 初始化分块信息
 */
void prepare() {
    // 计算块大小，通常选择sqrt(n)
    blen = (int)sqrt((double)n);
    
    // 计算块数量
    bnum = (n + blen - 1) / blen;
    
    // 计算每个位置属于哪个块
    for (int i = 1; i <= n; i++) {
        bi[i] = (i - 1) / blen + 1;
    }
    
    // 计算每个块的边界
    for (int b = 1; b <= bnum; b++) {
        // 块的左边界
        bl[b] = (b - 1) * blen + 1;
        // 块的右边界
        br[b] = min(b * blen, n);
        
        // 计算块的初始和
        for (int i = bl[b]; i <= br[b]; i++) {
            sum[b] += arr[i];
        }
    }
}

int main() {
    // 读取数组长度n和操作次数m
    scanf("%d%d", &n, &m);
    
    // 读取初始数组
    for (int i = 1; i <= n; i++) {
        scanf("%lld", &arr[i]);
    }
    
    // 进行预处理
    prepare();
    
    // 处理m次操作
    for (int i = 1, op, x, y, z; i <= m; i++) {
        scanf("%d%d%d", &op, &x, &y);
        if (op == 1) {
            scanf("%lld", &z);
            add(x, y, z);
        } else {
            printf("%lld\n", query(x, y));
        }
    }
    return 0;
}

===============================================

文件: Code04_Initialization.py
===============================================
# 初始化问题 - 分块算法实现 (Python版本)
# 题目来源: https://www.luogu.com.cn/problem/P5309
# 题目大意: 给定一个长度为n的数组arr，支持两种操作：
# 操作 1 x y z : 从arr[y]开始，下标每次+x，所有相应位置的数都+z，题目保证 y <= x
# 操作 2 x y   : 打印arr[x..y]的累加和，答案对1000000007取余
# 约束条件: 1 <= n、m <= 2 * 10^5

import math
import sys

# 定义最大数组长度和块大小
MAXN = 200001
MAXB = 501
MOD = 1000000007

# 全局变量
n, m = 0, 0

# pre[x][y]: 对于步长为x，起始位置为y的序列，前缀和的增量
pre = [[0 for _ in range(MAXB)] for _ in range(MAXB)]

# suf[x][y]: 对于步长为x，起始位置为y的序列，后缀和的增量
suf = [[0 for _ in range(MAXB)] for _ in range(MAXB)]

# arr: 原始数组
arr = [0] * MAXN

# sum: 每个块的和
sum_arr = [0] * MAXB

# blen: 块大小, bnum: 块数量
blen, bnum = 0, 0

# bi[i]: 位置i属于哪个块
bi = [0] * MAXN

# bl[b]: 块b的左边界
bl = [0] * MAXB

# br[b]: 块b的右边界
br = [0] * MAXB

def add(x, y, z):
    """
    操作 1 x y z
    从arr[y]开始，下标每次+x，所有相应位置的数都+z
    参数:
        x: 步长
        y: 起始位置
        z: 增量
    """
    # 如果步长x小于等于块大小，则更新pre和suf数组
    if x <= blen:
        # 更新前缀和增量
        for i in range(y, x + 1):
            pre[x][i] += z
        # 更新后缀和增量
        for i in range(y, 0, -1):
            suf[x][i] += z
    else:
        # 否则直接更新原数组和块和
        i = y
        while i <= n:
            arr[i] += z
            sum_arr[bi[i]] += z
            i += x

def querySum(l, r):
    """
    查询区间和
    参数:
        l: 左边界
        r: 右边界
    返回:
        区间和
    """
    # 获取左右边界所在的块
    lb, rb = bi[l], bi[r]
    ans = 0
    
    # 如果左右边界在同一个块内
    if lb == rb:
        # 直接遍历计算
        for i in range(l, r + 1):
            ans += arr[i]
    else:
        # 否则分三部分计算
        # 1. 左边不完整块
        for i in range(l, br[lb] + 1):
            ans += arr[i]
        # 2. 右边不完整块
        for i in range(bl[rb], r + 1):
            ans += arr[i]
        # 3. 中间完整块
        for b in range(lb + 1, rb):
            ans += sum_arr[b]
    return ans

def query(l, r):
    """
    操作 2 x y
    查询arr[x..y]的累加和
    参数:
        l: 左边界
        r: 右边界
    返回:
        区间和对MOD取余
    """
    ans = querySum(l, r)
    
    # 对于所有步长x <= sqrt(n)，累加其对区间和的贡献
    for x in range(1, blen + 1):
        # 计算起始位置和结束位置在步长为x时对应的编号
        lth = (l - 1) // x + 1
        rth = (r - 1) // x + 1
        
        # 计算中间完整段的数量
        num = rth - lth - 1
        
        # 如果起始和结束位置在同一段
        if lth == rth:
            # 只需要计算起始段的贡献
            ans = ans + pre[x][(r - 1) % x + 1] - pre[x][(l - 1) % x]
        else:
            # 否则需要计算三部分的贡献
            # 1. 起始段的后缀贡献
            # 2. 中间完整段的贡献
            # 3. 结束段的前缀贡献
            ans = ans + suf[x][(l - 1) % x + 1] + pre[x][x] * num + pre[x][(r - 1) % x + 1]
    return ans % MOD

def prepare():
    """
    预处理函数
    初始化分块信息
    """
    global blen, bnum
    # 计算块大小，通常选择sqrt(n)
    blen = int(math.sqrt(n))
    
    # 计算块数量
    bnum = (n + blen - 1) // blen
    
    # 计算每个位置属于哪个块
    for i in range(1, n + 1):
        bi[i] = (i - 1) // blen + 1
    
    # 计算每个块的边界
    for b in range(1, bnum + 1):
        # 块的左边界
        bl[b] = (b - 1) * blen + 1
        # 块的右边界
        br[b] = min(b * blen, n)
        
        # 计算块的初始和
        for i in range(bl[b], br[b] + 1):
            sum_arr[b] += arr[i]

def main():
    global n, m
    # 读取数组长度n和操作次数m
    n, m = map(int, sys.stdin.readline().split())
    
    # 读取初始数组
    values = list(map(int, sys.stdin.readline().split()))
    for i in range(1, n + 1):
        arr[i] = values[i - 1]
    
    # 进行预处理
    prepare()
    
    # 处理m次操作
    for _ in range(m):
        line = list(map(int, sys.stdin.readline().split()))
        op, x, y = line[0], line[1], line[2]
        if op == 1:
            z = line[3]
            add(x, y, z)
        else:
            print(query(x, y))

if __name__ == "__main__":
    main()

===============================================

文件: Code04_Initialization1.java
===============================================
package class175;

// 初始化问题 - 分块算法实现 (Java版本)
// 题目来源: https://www.luogu.com.cn/problem/P5309
// 题目大意: 给定一个长度为n的数组arr，支持两种操作：
// 操作 1 x y z : 从arr[y]开始，下标每次+x，所有相应位置的数都+z，题目保证 y <= x
// 操作 2 x y   : 打印arr[x..y]的累加和，答案对1000000007取余
// 约束条件: 1 <= n、m <= 2 * 10^5

import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStreamWriter;
import java.io.PrintWriter;

public class Code04_Initialization1 {

    // 定义最大数组长度和块大小
    public static int MAXN = 200001;
    public static int MAXB = 501;
    public static int MOD = 1000000007;
    
    // n: 数组长度, m: 操作次数
    public static int n, m;

    // pre[x][y]: 对于步长为x，起始位置为y的序列，前缀和的增量
    public static long[][] pre = new long[MAXB][MAXB];
    
    // suf[x][y]: 对于步长为x，起始位置为y的序列，后缀和的增量
    public static long[][] suf = new long[MAXB][MAXB];
    
    // arr: 原始数组
    public static long[] arr = new long[MAXN];
    
    // sum: 每个块的和
    public static long[] sum = new long[MAXB];

    // blen: 块大小, bnum: 块数量
    public static int blen, bnum;
    
    // bi[i]: 位置i属于哪个块
    public static int[] bi = new int[MAXN];
    
    // bl[b]: 块b的左边界
    public static int[] bl = new int[MAXB];
    
    // br[b]: 块b的右边界
    public static int[] br = new int[MAXB];

    /**
     * 操作 1 x y z
     * 从arr[y]开始，下标每次+x，所有相应位置的数都+z
     * @param x 步长
     * @param y 起始位置
     * @param z 增量
     */
    public static void add(int x, int y, int z) {
        // 如果步长x小于等于块大小，则更新pre和suf数组
        if (x <= blen) {
            // 更新前缀和增量
            for (int i = y; i <= x; i++) {
                pre[x][i] += z;
            }
            // 更新后缀和增量
            for (int i = y; i >= 1; i--) {
                suf[x][i] += z;
            }
        } else {
            // 否则直接更新原数组和块和
            for (int i = y; i <= n; i += x) {
                arr[i] += z;
                sum[bi[i]] += z;
            }
        }
    }

    /**
     * 查询区间和
     * @param l 左边界
     * @param r 右边界
     * @return 区间和
     */
    public static long querySum(int l, int r) {
        // 获取左右边界所在的块
        int lb = bi[l], rb = bi[r];
        long ans = 0;
        
        // 如果左右边界在同一个块内
        if (lb == rb) {
            // 直接遍历计算
            for (int i = l; i <= r; i++) {
                ans += arr[i];
            }
        } else {
            // 否则分三部分计算
            // 1. 左边不完整块
            for (int i = l; i <= br[lb]; i++) {
                ans += arr[i];
            }
            // 2. 右边不完整块
            for (int i = bl[rb]; i <= r; i++) {
                ans += arr[i];
            }
            // 3. 中间完整块
            for (int b = lb + 1; b <= rb - 1; b++) {
                ans += sum[b];
            }
        }
        return ans;
    }

    /**
     * 操作 2 x y
     * 查询arr[x..y]的累加和
     * @param l 左边界
     * @param r 右边界
     * @return 区间和对MOD取余
     */
    public static long query(int l, int r) {
        long ans = querySum(l, r);
        
        // 对于所有步长x <= sqrt(n)，累加其对区间和的贡献
        for (int x = 1, lth, rth, num; x <= blen; x++) {
            // 计算起始位置和结束位置在步长为x时对应的编号
            lth = (l - 1) / x + 1;
            rth = (r - 1) / x + 1;
            
            // 计算中间完整段的数量
            num = rth - lth - 1;
            
            // 如果起始和结束位置在同一段
            if (lth == rth) {
                // 只需要计算起始段的贡献
                ans = ans + pre[x][(r - 1) % x + 1] - pre[x][(l - 1) % x];
            } else {
                // 否则需要计算三部分的贡献
                // 1. 起始段的后缀贡献
                // 2. 中间完整段的贡献
                // 3. 结束段的前缀贡献
                ans = ans + suf[x][(l - 1) % x + 1] + pre[x][x] * num + pre[x][(r - 1) % x + 1];
            }
        }
        return ans % MOD;
    }

    /**
     * 预处理函数
     * 初始化分块信息
     */
    public static void prepare() {
        // 计算块大小，通常选择sqrt(n)
        blen = (int) Math.sqrt(n);
        
        // 计算块数量
        bnum = (n + blen - 1) / blen;
        
        // 计算每个位置属于哪个块
        for (int i = 1; i <= n; i++) {
            bi[i] = (i - 1) / blen + 1;
        }
        
        // 计算每个块的边界
        for (int b = 1; b <= bnum; b++) {
            // 块的左边界
            bl[b] = (b - 1) * blen + 1;
            // 块的右边界
            br[b] = Math.min(b * blen, n);
            
            // 计算块的初始和
            for (int i = bl[b]; i <= br[b]; i++) {
                sum[b] += arr[i];
            }
        }
    }

    public static void main(String[] args) throws Exception {
        FastReader in = new FastReader(System.in);
        PrintWriter out = new PrintWriter(new OutputStreamWriter(System.out));
        
        // 读取数组长度n和操作次数m
        n = in.nextInt();
        m = in.nextInt();
        
        // 读取初始数组
        for (int i = 1; i <= n; i++) {
            arr[i] = in.nextInt();
        }
        
        // 进行预处理
        prepare();
        
        // 处理m次操作
        for (int i = 1, op, x, y, z; i <= m; i++) {
            op = in.nextInt();
            x = in.nextInt();
            y = in.nextInt();
            if (op == 1) {
                z = in.nextInt();
                add(x, y, z);
            } else {
                out.println(query(x, y));
            }
        }
        
        out.flush();
        out.close();
    }

    // 高效读取工具类，用于加快输入输出速度
    static class FastReader {
        private final byte[] buffer = new byte[1 << 16];
        private int ptr = 0, len = 0;
        private final InputStream in;

        FastReader(InputStream in) {
            this.in = in;
        }

        private int readByte() throws IOException {
            if (ptr >= len) {
                len = in.read(buffer);
                ptr = 0;
                if (len <= 0)
                    return -1;
            }
            return buffer[ptr++];
        }

        int nextInt() throws IOException {
            int c;
            do {
                c = readByte();
            } while (c <= ' ' && c != -1);
            boolean neg = false;
            if (c == '-') {
                neg = true;
                c = readByte();
            }
            int val = 0;
            while (c > ' ' && c != -1) {
                val = val * 10 + (c - '0');
                c = readByte();
            }
            return neg ? -val : val;
        }
    }

}

===============================================

文件: Code04_Initialization2.java
===============================================
package class175;

// 初始化问题 - 分块算法实现 (C++版本的Java注释版)
// 题目来源: https://www.luogu.com.cn/problem/P5309
// 题目大意: 给定一个长度为n的数组arr，支持两种操作：
// 操作 1 x y z : 从arr[y]开始，下标每次+x，所有相应位置的数都+z，题目保证 y <= x
// 操作 2 x y   : 打印arr[x..y]的累加和，答案对1000000007取余
// 约束条件: 1 <= n、m <= 2 * 10^5

// 以下是C++版本的实现，逻辑与Java版本完全一致
// 提交时需要将代码转换为C++格式

//#include <bits/stdc++.h>
//
//using namespace std;
//
//const int MAXN = 200001;
//const int MAXB = 501;
//const int MOD  = 1000000007;
//int n, m;
//
//long long pre[MAXB][MAXB];
//long long suf[MAXB][MAXB];
//long long arr[MAXN];
//long long sum[MAXB];
//
//int blen, bnum;
//int bi[MAXN];
//int bl[MAXB];
//int br[MAXB];
//
//void add(int x, int y, long long z) {
//    if (x <= blen) {
//        for (int i = y; i <= x; i++) {
//            pre[x][i] += z;
//        }
//        for (int i = y; i >= 1; i--) {
//            suf[x][i] += z;
//        }
//    } else {
//        for (int i = y; i <= n; i += x) {
//            arr[i] += z;
//            sum[bi[i]] += z;
//        }
//    }
//}
//
//long long querySum(int l, int r) {
//    int lb = bi[l], rb = bi[r];
//    long long ans = 0;
//    if (lb == rb) {
//        for (int i = l; i <= r; i++) {
//            ans += arr[i];
//        }
//    } else {
//        for (int i = l; i <= br[lb]; i++) {
//            ans += arr[i];
//        }
//        for (int i = bl[rb]; i <= r; i++) {
//            ans += arr[i];
//        }
//        for (int b = lb + 1; b <= rb - 1; b++) {
//            ans += sum[b];
//        }
//    }
//    return ans;
//}
//
//long long query(int l, int r) {
//    long long ans = querySum(l, r);
//    for (int x = 1, lth, rth, num; x <= blen; x++) {
//        lth = (l - 1) / x + 1;
//        rth = (r - 1) / x + 1;
//        num = rth - lth - 1;
//        if (lth == rth) {
//            ans = ans + pre[x][(r - 1) % x + 1] - pre[x][(l - 1) % x];
//        } else {
//            ans = ans + suf[x][(l - 1) % x + 1] + pre[x][x] * num + pre[x][(r - 1) % x + 1];
//        }
//    }
//    return ans % MOD;
//}
//
//void prepare() {
//    blen = (int)sqrt(n);
//    bnum = (n + blen - 1) / blen;
//    for (int i = 1; i <= n; i++) {
//        bi[i] = (i - 1) / blen + 1;
//    }
//    for (int b = 1; b <= bnum; b++) {
//        bl[b] = (b - 1) * blen + 1;
//        br[b] = min(b * blen, n);
//        for (int i = bl[b]; i <= br[b]; i++) {
//            sum[b] += arr[i];
//        }
//    }
//}
//
//int main() {
//    ios::sync_with_stdio(false);
//    cin.tie(nullptr);
//    cin >> n >> m;
//    for (int i = 1; i <= n; i++) {
//        cin >> arr[i];
//    }
//    prepare();
//    for (int i = 1, op, x, y, z; i <= m; i++) {
//        cin >> op >> x >> y;
//        if (op == 1) {
//            cin >> z;
//            add(x, y, z);
//        } else {
//            cout << query(x, y) << '\n';
//        }
//    }
//    return 0;
//}

===============================================

文件: Code05_Skyscraper.cpp
===============================================
// 雅加达的摩天楼问题 - 分块算法优化BFS (C++版本)
// 题目来源: https://www.luogu.com.cn/problem/P3645
// 题目来源: https://uoj.ac/problem/111
// 题目大意: 有n个大楼，编号0~n-1，有m个狗子，编号0~m-1
// 每只狗子有两个参数，idx表示狗子的初始大楼，jump表示狗子的跳跃能力
// 狗子在i位置，可以来到 i - jump 或 i + jump，向左向右自由跳跃，但不能越界
// 0号狗子有消息希望传给1号狗子，所有狗子都可帮忙，返回至少传送几次，无法送达打印-1
// 约束条件: 1 <= n、m <= 30000

#include <cstdio>
#include <deque>
#include <bitset>
using namespace std;

// BFS节点结构体，记录当前位置、跳跃能力和已用时间
struct Node {
    int idx, jump, time;
};

const int MAXN = 30001;
int n, m;
int head[MAXN];
int nxt[MAXN];
int to[MAXN];
int cnt;

deque<Node> que;
bitset<MAXN> vis[MAXN];

/**
 * 添加狗子到邻接表
 * @param idx 大楼编号
 * @param jump 跳跃能力
 */
void add(int idx, int jump) {
    // 创建新节点
    nxt[++cnt] = head[idx];
    to[cnt] = jump;
    head[idx] = cnt;
}

/**
 * 触发大楼idx中的所有狗子
 * @param idx 大楼编号
 * @param time 当前时间
 */
void trigger(int idx, int time) {
    // 遍历大楼idx中的所有狗子
    for (int e = head[idx], jump; e; e = nxt[e]) {
        jump = to[e];
        // 如果这个状态（位置+跳跃能力）没有访问过
        if (!vis[idx].test(jump)) {
            // 标记为已访问
            vis[idx].set(jump);
            // 加入队列
            que.push_back({idx, jump, time});
        }
    }
    // 清空该大楼的狗子列表，避免重复处理
    head[idx] = 0;
}

/**
 * 扩展状态
 * @param idx 大楼编号
 * @param jump 跳跃能力
 * @param time 当前时间
 */
void extend(int idx, int jump, int time) {
    // 触发该大楼的所有狗子
    trigger(idx, time);
    
    // 如果这个状态（位置+跳跃能力）没有访问过
    if (!vis[idx].test(jump)) {
        // 标记为已访问
        vis[idx].set(jump);
        // 加入队列
        que.push_back({idx, jump, time});
    }
}

/**
 * BFS搜索最短路径
 * @param s 起始大楼
 * @param t 目标大楼
 * @return 最少传送次数，无法送达返回-1
 */
int bfs(int s, int t) {
    // 如果起始和目标相同，不需要传送
    if (s == t) {
        return 0;
    }
    
    // 初始化vis数组
    for (int i = 0; i < n; i++) {
        vis[i].reset();
    }
    
    // 清空队列
    while (!que.empty()) {
        que.pop_front();
    }
    
    // 触发起始大楼的所有狗子
    trigger(s, 0);
    
    // BFS过程
    while (!que.empty()) {
        // 取出队首节点
        Node cur = que.front();
        que.pop_front();
        int idx = cur.idx;
        int jump = cur.jump;
        int time = cur.time;
        
        // 如果向左或向右跳跃能到达目标大楼
        if (idx - jump == t || idx + jump == t) {
            // 返回传送次数+1
            return time + 1;
        }
        
        // 向左跳跃
        if (idx - jump >= 0) {
            extend(idx - jump, jump, time + 1);
        }
        
        // 向右跳跃
        if (idx + jump < n) {
            extend(idx + jump, jump, time + 1);
        }
    }
    // 无法送达
    return -1;
}

int main() {
    // 读取大楼数量n和狗子数量m
    scanf("%d%d", &n, &m);
    
    // 读取起始狗子和目标狗子的信息
    int s, sjump, t, tjump;
    scanf("%d%d%d%d", &s, &sjump, &t, &tjump);
    
    // 添加起始和目标狗子
    add(s, sjump);
    add(t, tjump);
    
    // 读取其他狗子的信息
    for (int i = 2, idx, jump; i < m; i++) {
        scanf("%d%d", &idx, &jump);
        add(idx, jump);
    }
    
    // BFS搜索最短路径
    printf("%d\n", bfs(s, t));
    return 0;
}

===============================================

文件: Code05_Skyscraper.py
===============================================
# 雅加达的摩天楼问题 - 分块算法优化BFS (Python版本)
# 题目来源: https://www.luogu.com.cn/problem/P3645
# 题目来源: https://uoj.ac/problem/111
# 题目大意: 有n个大楼，编号0~n-1，有m个狗子，编号0~m-1
# 每只狗子有两个参数，idx表示狗子的初始大楼，jump表示狗子的跳跃能力
# 狗子在i位置，可以来到 i - jump 或 i + jump，向左向右自由跳跃，但不能越界
# 0号狗子有消息希望传给1号狗子，所有狗子都可帮忙，返回至少传送几次，无法送达打印-1
# 约束条件: 1 <= n、m <= 30000

import sys
from collections import deque

# BFS节点类，记录当前位置、跳跃能力和已用时间
class Node:
    def __init__(self, idx, jump, time):
        self.idx = idx
        self.jump = jump
        self.time = time

# 定义最大数组长度
MAXN = 30001

# 全局变量
n, m = 0, 0

# 邻接表存储每个大楼拥有的狗子列表
# head[i]: 大楼i的狗子链表头节点
head = [0] * MAXN

# next[i]: 链表中第i个节点的下一个节点
next_arr = [0] * MAXN

# to[i]: 链表中第i个节点存储的跳跃能力
to = [0] * MAXN

# cnt: 链表节点计数器
cnt = 0

# bfs过程使用的队列
que = deque()

# vis[idx]是个集合，可以表示vis[idx][jump]是否出现过
# 用于避免重复访问相同状态（位置+跳跃能力）
vis = [set() for _ in range(MAXN)]

def add(idx, jump):
    """
    添加狗子到邻接表
    参数:
        idx: 大楼编号
        jump: 跳跃能力
    """
    global cnt
    # 创建新节点
    cnt += 1
    next_arr[cnt] = head[idx]
    to[cnt] = jump
    head[idx] = cnt

def trigger(idx, time):
    """
    触发大楼idx中的所有狗子
    参数:
        idx: 大楼编号
        time: 当前时间
    """
    global que
    # 遍历大楼idx中的所有狗子
    e = head[idx]
    while e > 0:
        jump = to[e]
        # 如果这个状态（位置+跳跃能力）没有访问过
        if jump not in vis[idx]:
            # 标记为已访问
            vis[idx].add(jump)
            # 加入队列
            que.append(Node(idx, jump, time))
        e = next_arr[e]
    
    # 清空该大楼的狗子列表，避免重复处理
    head[idx] = 0

def extend(idx, jump, time):
    """
    扩展状态
    参数:
        idx: 大楼编号
        jump: 跳跃能力
        time: 当前时间
    """
    # 触发该大楼的所有狗子
    trigger(idx, time)
    
    # 如果这个状态（位置+跳跃能力）没有访问过
    if jump not in vis[idx]:
        # 标记为已访问
        vis[idx].add(jump)
        # 加入队列
        que.append(Node(idx, jump, time))

def bfs(s, t):
    """
    BFS搜索最短路径
    参数:
        s: 起始大楼
        t: 目标大楼
    返回:
        最少传送次数，无法送达返回-1
    """
    global que
    # 如果起始和目标相同，不需要传送
    if s == t:
        return 0
    
    # 初始化vis数组
    for i in range(n):
        vis[i].clear()
    
    # 清空队列
    que.clear()
    
    # 触发起始大楼的所有狗子
    trigger(s, 0)
    
    # BFS过程
    while que:
        # 取出队首节点
        cur = que.popleft()
        idx = cur.idx
        jump = cur.jump
        time = cur.time
        
        # 如果向左或向右跳跃能到达目标大楼
        if idx - jump == t or idx + jump == t:
            # 返回传送次数+1
            return time + 1
        
        # 向左跳跃
        if idx - jump >= 0:
            extend(idx - jump, jump, time + 1)
        
        # 向右跳跃
        if idx + jump < n:
            extend(idx + jump, jump, time + 1)
    
    # 无法送达
    return -1

def main():
    global n, m
    # 读取大楼数量n和狗子数量m
    n, m = map(int, sys.stdin.readline().split())
    
    # 读取起始狗子和目标狗子的信息
    s, sjump, t, tjump = map(int, sys.stdin.readline().split())
    
    # 添加起始和目标狗子
    add(s, sjump)
    add(t, tjump)
    
    # 读取其他狗子的信息
    for i in range(2, m):
        idx, jump = map(int, sys.stdin.readline().split())
        add(idx, jump)
    
    # BFS搜索最短路径
    print(bfs(s, t))

if __name__ == "__main__":
    main()

===============================================

文件: Code05_Skyscraper1.java
===============================================
package class175;

// 雅加达的摩天楼问题 - 分块算法优化BFS (Java版本)
// 题目来源: https://www.luogu.com.cn/problem/P3645
// 题目来源: https://uoj.ac/problem/111
// 题目大意: 有n个大楼，编号0~n-1，有m个狗子，编号0~m-1
// 每只狗子有两个参数，idx表示狗子的初始大楼，jump表示狗子的跳跃能力
// 狗子在i位置，可以来到 i - jump 或 i + jump，向左向右自由跳跃，但不能越界
// 0号狗子有消息希望传给1号狗子，所有狗子都可帮忙，返回至少传送几次，无法送达打印-1
// 约束条件: 1 <= n、m <= 30000

import java.io.IOException;
import java.io.InputStream;
import java.io.PrintWriter;
import java.util.ArrayDeque;
import java.util.BitSet;

public class Code05_Skyscraper1 {

    // BFS节点类，记录当前位置、跳跃能力和已用时间
    static class Node {
        int idx, jump, time;

        Node(int i, int j, int t) {
            idx = i;
            jump = j;
            time = t;
        }
    }

    // 定义最大数组长度
    public static int MAXN = 30001;
    
    // n: 大楼数量, m: 狗子数量
    public static int n, m;
    
    // 邻接表存储每个大楼拥有的狗子列表
    // head[i]: 大楼i的狗子链表头节点
    public static int[] head = new int[MAXN];
    
    // next[i]: 链表中第i个节点的下一个节点
    public static int[] next = new int[MAXN];
    
    // to[i]: 链表中第i个节点存储的跳跃能力
    public static int[] to = new int[MAXN];
    
    // cnt: 链表节点计数器
    public static int cnt;

    // bfs过程使用的队列
    public static ArrayDeque<Node> que = new ArrayDeque<>();
    
    // vis[idx]是个位图，可以表示vis[idx][jump]是否出现过
    // 用于避免重复访问相同状态（位置+跳跃能力）
    public static BitSet[] vis = new BitSet[MAXN];

    /**
     * 添加狗子到邻接表
     * @param idx 大楼编号
     * @param jump 跳跃能力
     */
    public static void add(int idx, int jump) {
        // 创建新节点
        next[++cnt] = head[idx];
        to[cnt] = jump;
        head[idx] = cnt;
    }

    /**
     * 触发大楼idx中的所有狗子
     * @param idx 大楼编号
     * @param time 当前时间
     */
    public static void trigger(int idx, int time) {
        // 遍历大楼idx中的所有狗子
        for (int e = head[idx], jump; e > 0; e = next[e]) {
            jump = to[e];
            // 如果这个状态（位置+跳跃能力）没有访问过
            if (!vis[idx].get(jump)) {
                // 标记为已访问
                vis[idx].set(jump);
                // 加入队列
                que.addLast(new Node(idx, jump, time));
            }
        }
        // 清空该大楼的狗子列表，避免重复处理
        head[idx] = 0;
    }

    /**
     * 扩展状态
     * @param idx 大楼编号
     * @param jump 跳跃能力
     * @param time 当前时间
     */
    public static void extend(int idx, int jump, int time) {
        // 触发该大楼的所有狗子
        trigger(idx, time);
        
        // 如果这个状态（位置+跳跃能力）没有访问过
        if (!vis[idx].get(jump)) {
            // 标记为已访问
            vis[idx].set(jump);
            // 加入队列
            que.addLast(new Node(idx, jump, time));
        }
    }

    /**
     * BFS搜索最短路径
     * @param s 起始大楼
     * @param t 目标大楼
     * @return 最少传送次数，无法送达返回-1
     */
    public static int bfs(int s, int t) {
        // 如果起始和目标相同，不需要传送
        if (s == t) {
            return 0;
        }
        
        // 初始化vis数组
        for (int i = 0; i < MAXN; i++) {
            vis[i] = new BitSet();
        }
        
        // 触发起始大楼的所有狗子
        trigger(s, 0);
        
        // BFS过程
        while (!que.isEmpty()) {
            // 取出队首节点
            Node cur = que.pollFirst();
            int idx = cur.idx;
            int jump = cur.jump;
            int time = cur.time;
            
            // 如果向左或向右跳跃能到达目标大楼
            if (idx - jump == t || idx + jump == t) {
                // 返回传送次数+1
                return time + 1;
            }
            
            // 向左跳跃
            if (idx - jump >= 0) {
                extend(idx - jump, jump, time + 1);
            }
            
            // 向右跳跃
            if (idx + jump < n) {
                extend(idx + jump, jump, time + 1);
            }
        }
        // 无法送达
        return -1;
    }

    public static void main(String[] args) throws Exception {
        FastReader in = new FastReader(System.in);
        PrintWriter out = new PrintWriter(System.out);
        
        // 读取大楼数量n和狗子数量m
        n = in.nextInt();
        m = in.nextInt();
        
        // 读取起始狗子和目标狗子的信息
        int s = in.nextInt();
        int sjump = in.nextInt();
        int t = in.nextInt();
        int tjump = in.nextInt();
        
        // 添加起始和目标狗子
        add(s, sjump);
        add(t, tjump);
        
        // 读取其他狗子的信息
        for (int i = 2, idx, jump; i < m; i++) {
            idx = in.nextInt();
            jump = in.nextInt();
            add(idx, jump);
        }
        
        // BFS搜索最短路径
        out.println(bfs(s, t));
        out.flush();
        out.close();
    }

    // 高效读取工具类，用于加快输入输出速度
    static class FastReader {
        private final byte[] buffer = new byte[1 << 16];
        private int ptr = 0, len = 0;
        private final InputStream in;

        FastReader(InputStream in) {
            this.in = in;
        }

        private int readByte() throws IOException {
            if (ptr >= len) {
                len = in.read(buffer);
                ptr = 0;
                if (len <= 0)
                    return -1;
            }
            return buffer[ptr++];
        }

        int nextInt() throws IOException {
            int c;
            do {
                c = readByte();
            } while (c <= ' ' && c != -1);
            boolean neg = false;
            if (c == '-') {
                neg = true;
                c = readByte();
            }
            int val = 0;
            while (c > ' ' && c != -1) {
                val = val * 10 + (c - '0');
                c = readByte();
            }
            return neg ? -val : val;
        }
    }

}

===============================================

文件: Code05_Skyscraper2.java
===============================================
package class175;

// 雅加达的摩天楼问题 - 分块算法优化BFS (C++版本的Java注释版)
// 题目来源: https://www.luogu.com.cn/problem/P3645
// 题目来源: https://uoj.ac/problem/111
// 题目大意: 有n个大楼，编号0~n-1，有m个狗子，编号0~m-1
// 每只狗子有两个参数，idx表示狗子的初始大楼，jump表示狗子的跳跃能力
// 狗子在i位置，可以来到 i - jump 或 i + jump，向左向右自由跳跃，但不能越界
// 0号狗子有消息希望传给1号狗子，所有狗子都可帮忙，返回至少传送几次，无法送达打印-1
// 约束条件: 1 <= n、m <= 30000

// 以下是C++版本的实现，逻辑与Java版本完全一致
// 提交时需要将代码转换为C++格式

//#include <bits/stdc++.h>
//
//using namespace std;
//
//struct Node {
//    int idx, jump, time;
//};
//
//const int MAXN = 30001;
//int n, m;
//int head[MAXN];
//int nxt[MAXN];
//int to[MAXN];
//int cnt;
//
//deque<Node> que;
//bitset<MAXN> vis[MAXN];
//
//void add(int idx, int jump) {
//    nxt[++cnt] = head[idx];
//    to[cnt] = jump;
//    head[idx] = cnt;
//}
//
//void trigger(int idx, int time) {
//    for (int e = head[idx], jump; e; e = nxt[e]) {
//        jump = to[e];
//        if (!vis[idx].test(jump)) {
//            vis[idx].set(jump);
//            que.push_back({idx, jump, time});
//        }
//    }
//    head[idx] = 0;
//}
//
//void extend(int idx, int jump, int time) {
//    trigger(idx, time);
//    if (!vis[idx].test(jump)) {
//        vis[idx].set(jump);
//        que.push_back({idx, jump, time});
//    }
//}
//
//int bfs(int s, int t) {
//    if (s == t) {
//        return 0;
//    }
//    for (int i = 0; i < n; i++) {
//        vis[i].reset();
//    }
//    que.clear();
//    trigger(s, 0);
//    while (!que.empty()) {
//        Node cur = que.front();
//        que.pop_front();
//        int idx = cur.idx;
//        int jump = cur.jump;
//        int time = cur.time;
//        if (idx - jump == t || idx + jump == t) {
//            return time + 1;
//        }
//        if (idx - jump >= 0) {
//            extend(idx - jump, jump, time + 1);
//        }
//        if (idx + jump < n) {
//            extend(idx + jump, jump, time + 1);
//        }
//    }
//    return -1;
//}
//
//int main() {
//    ios::sync_with_stdio(false);
//    cin.tie(nullptr);
//    cin >> n >> m;
//    int s, sjump, t, tjump;
//    cin >> s >> sjump >> t >> tjump;
//    add(s, sjump);
//    add(t, tjump);
//    for (int i = 2, idx, jump; i < m; i++) {
//        cin >> idx >> jump;
//        add(idx, jump);
//    }
//    cout << bfs(s, t) << '\n';
//    return 0;
//}

===============================================

文件: Code06_RangeSumQueryMutable.cpp
===============================================
// LeetCode 307. Range Sum Query - Mutable - 分块算法实现 (C++版本)
// 题目来源: LeetCode
// 链接: https://leetcode.com/problems/range-sum-query-mutable/
// 题目大意: 实现一个支持区间和查询和单点更新的数据结构
// 约束条件: 
// - 1 <= nums.length <= 3 * 10^4
// - -100 <= nums[i] <= 100
// - 最多调用 3 * 10^4 次 update 和 sumRange 操作

// 分块算法分析:
// 时间复杂度: 
// - 构造函数: O(n)，需要初始化数组和分块信息
// - update操作: O(1)，只需要更新单个元素和对应的块和
// - sumRange操作: O(√n)，需要遍历部分块和部分元素
// 空间复杂度: O(n)，需要存储原始数组和块和数组

// 最优解验证:
// 分块算法是解决此类问题的经典方法之一，在更新和查询操作之间提供了良好的平衡。
// 对于频繁更新和查询的场景，分块算法通常比线段树更简单且常数更小。

#include <iostream>
#include <vector>
#include <cmath>
#include <stdexcept>
#include <chrono>

using namespace std;

class Code06_RangeSumQueryMutable {
private:
    vector<int> nums;           // 原始数组
    vector<int> blockSum;        // 每个块的和
    int blockSize;              // 块大小
    int blockCount;             // 块数量
    
public:
    /**
     * 构造函数 - 初始化分块数据结构
     * 
     * @param nums 初始数组
     * 
     * 算法步骤:
     * 1. 计算合适的块大小，通常选择sqrt(n)
     * 2. 初始化块和数组
     * 3. 计算每个块的初始和
     * 
     * 时间复杂度: O(n)
     * 空间复杂度: O(n)
     */
    Code06_RangeSumQueryMutable(vector<int>& nums) {
        if (nums.empty()) {
            throw invalid_argument("数组不能为空");
        }
        
        this->nums = nums;
        
        // 计算块大小，通常选择sqrt(n)
        this->blockSize = static_cast<int>(sqrt(nums.size()));
        this->blockCount = (nums.size() + blockSize - 1) / blockSize;
        
        // 初始化块和数组
        this->blockSum.resize(blockCount, 0);
        
        // 计算每个块的初始和
        for (int i = 0; i < nums.size(); i++) {
            int blockIndex = i / blockSize;
            blockSum[blockIndex] += nums[i];
        }
    }
    
    /**
     * 更新操作 - 将索引i处的值更新为val
     * 
     * @param i 要更新的索引
     * @param val 新的值
     * 
     * 算法步骤:
     * 1. 验证索引有效性
     * 2. 计算值的变化量
     * 3. 更新原始数组
     * 4. 更新对应的块和
     * 
     * 时间复杂度: O(1)
     * 空间复杂度: O(1)
     * 
     * 异常处理:
     * - 索引越界: 抛出invalid_argument异常
     */
    void update(int i, int val) {
        // 边界检查
        if (i < 0 || i >= nums.size()) {
            throw invalid_argument("索引越界: " + to_string(i));
        }
        
        // 计算值的变化量
        int delta = val - nums[i];
        
        // 更新原始数组
        nums[i] = val;
        
        // 更新对应的块和
        int blockIndex = i / blockSize;
        blockSum[blockIndex] += delta;
    }
    
    /**
     * 区间和查询 - 计算索引left到right的区间和
     * 
     * @param left 区间左边界（包含）
     * @param right 区间右边界（包含）
     * @return 区间和
     * 
     * 算法步骤:
     * 1. 验证边界有效性
     * 2. 计算左右边界所在的块
     * 3. 如果左右边界在同一个块内，直接遍历计算
     * 4. 否则分三部分计算:
     *    - 左边不完整块
     *    - 中间完整块
     *    - 右边不完整块
     * 
     * 时间复杂度: O(√n)
     * 空间复杂度: O(1)
     * 
     * 异常处理:
     * - 边界越界: 抛出invalid_argument异常
     * - left > right: 抛出invalid_argument异常
     */
    int sumRange(int left, int right) {
        // 边界检查
        if (left < 0 || right >= nums.size() || left > right) {
            throw invalid_argument("区间边界无效: [" + to_string(left) + ", " + to_string(right) + "]");
        }
        
        // 如果左右边界相同，直接返回该位置的值
        if (left == right) {
            return nums[left];
        }
        
        int sum = 0;
        int leftBlock = left / blockSize;
        int rightBlock = right / blockSize;
        
        // 如果左右边界在同一个块内
        if (leftBlock == rightBlock) {
            // 直接遍历该块内的元素
            for (int i = left; i <= right; i++) {
                sum += nums[i];
            }
        } else {
            // 计算左边不完整块的和
            for (int i = left; i < (leftBlock + 1) * blockSize; i++) {
                sum += nums[i];
            }
            
            // 计算中间完整块的和
            for (int block = leftBlock + 1; block < rightBlock; block++) {
                sum += blockSum[block];
            }
            
            // 计算右边不完整块的和
            for (int i = rightBlock * blockSize; i <= right; i++) {
                sum += nums[i];
            }
        }
        
        return sum;
    }
    
    /**
     * 获取数组长度
     * 
     * @return 数组长度
     */
    int size() const {
        return nums.size();
    }
    
    /**
     * 获取块大小
     * 
     * @return 块大小
     */
    int getBlockSize() const {
        return blockSize;
    }
    
    /**
     * 获取块数量
     * 
     * @return 块数量
     */
    int getBlockCount() const {
        return blockCount;
    }
    
    /**
     * 调试方法 - 打印数据结构状态
     * 用于调试和问题定位
     */
    void printStructure() const {
        cout << "=== 分块数据结构状态 ===" << endl;
        cout << "数组长度: " << nums.size() << endl;
        cout << "块大小: " << blockSize << endl;
        cout << "块数量: " << blockCount << endl;
        
        cout << "原始数组: ";
        for (int num : nums) {
            cout << num << " ";
        }
        cout << endl;
        
        cout << "块和数组: ";
        for (int sum : blockSum) {
            cout << sum << " ";
        }
        cout << endl;
        
        // 验证块和正确性
        int totalSum = 0;
        for (int num : nums) {
            totalSum += num;
        }
        
        int blockSumTotal = 0;
        for (int sum : blockSum) {
            blockSumTotal += sum;
        }
        
        cout << "数组总和: " << totalSum << endl;
        cout << "块和总和: " << blockSumTotal << endl;
        cout << "一致性检查: " << (totalSum == blockSumTotal ? "通过" : "失败") << endl;
    }
};

/**
 * 单元测试函数 - 验证算法的正确性
 * 
 * 测试用例设计:
 * 1. 正常情况测试
 * 2. 边界情况测试
 * 3. 异常情况测试
 * 4. 性能测试
 */
void testCode06_RangeSumQueryMutable() {
    // 测试用例1: 正常情况
    cout << "=== 测试用例1: 正常情况 ===" << endl;
    vector<int> nums1 = {1, 3, 5, 7, 9, 11};
    Code06_RangeSumQueryMutable numArray1(nums1);
    
    // 测试初始区间和
    cout << "sumRange(0, 2) = " << numArray1.sumRange(0, 2) << endl; // 期望: 1+3+5=9
    cout << "sumRange(1, 4) = " << numArray1.sumRange(1, 4) << endl; // 期望: 3+5+7+9=24
    
    // 测试更新操作
    numArray1.update(1, 10);
    cout << "更新后 sumRange(0, 2) = " << numArray1.sumRange(0, 2) << endl; // 期望: 1+10+5=16
    
    // 测试用例2: 边界情况
    cout << "\n=== 测试用例2: 边界情况 ===" << endl;
    vector<int> nums2 = {2};
    Code06_RangeSumQueryMutable numArray2(nums2);
    
    cout << "sumRange(0, 0) = " << numArray2.sumRange(0, 0) << endl; // 期望: 2
    numArray2.update(0, 5);
    cout << "更新后 sumRange(0, 0) = " << numArray2.sumRange(0, 0) << endl; // 期望: 5
    
    // 测试用例3: 异常情况
    cout << "\n=== 测试用例3: 异常情况 ===" << endl;
    try {
        vector<int> nums3 = {};
        Code06_RangeSumQueryMutable numArray3(nums3);
    } catch (const invalid_argument& e) {
        cout << "正确捕获异常: " << e.what() << endl;
    }
    
    // 测试用例4: 大规模数据性能测试
    cout << "\n=== 测试用例4: 性能测试 ===" << endl;
    int size = 10000;
    vector<int> nums4(size);
    for (int i = 0; i < size; i++) {
        nums4[i] = i + 1;
    }
    
    Code06_RangeSumQueryMutable numArray4(nums4);
    
    auto startTime = chrono::high_resolution_clock::now();
    int result = numArray4.sumRange(0, size - 1);
    auto endTime = chrono::high_resolution_clock::now();
    
    auto duration = chrono::duration_cast<chrono::microseconds>(endTime - startTime);
    
    cout << "大规模数据区间和: " << result << endl;
    cout << "查询时间: " << duration.count() << "微秒" << endl;
    
    // 验证结果正确性
    long expected = static_cast<long>(size) * (size + 1) / 2;
    cout << "期望结果: " << expected << endl;
    cout << "结果正确性: " << (result == expected ? "正确" : "错误") << endl;
    
    cout << "\n=== 所有测试用例执行完成 ===" << endl;
}

/**
 * 性能对比测试 - 比较分块算法与暴力算法的性能差异
 */
void performanceComparison() {
    cout << "=== 性能对比测试 ===" << endl;
    
    int size = 100000;
    vector<int> nums(size);
    for (int i = 0; i < size; i++) {
        nums[i] = i + 1;
    }
    
    // 分块算法测试
    Code06_RangeSumQueryMutable blockArray(nums);
    
    auto start1 = chrono::high_resolution_clock::now();
    int blockResult = blockArray.sumRange(0, size - 1);
    auto end1 = chrono::high_resolution_clock::now();
    auto blockTime = chrono::duration_cast<chrono::microseconds>(end1 - start1);
    
    // 暴力算法测试
    auto start2 = chrono::high_resolution_clock::now();
    int bruteResult = 0;
    for (int i = 0; i < size; i++) {
        bruteResult += nums[i];
    }
    auto end2 = chrono::high_resolution_clock::now();
    auto bruteTime = chrono::duration_cast<chrono::microseconds>(end2 - start2);
    
    cout << "分块算法结果: " << blockResult << ", 时间: " << blockTime.count() << "微秒" << endl;
    cout << "暴力算法结果: " << bruteResult << ", 时间: " << bruteTime.count() << "微秒" << endl;
    cout << "性能提升倍数: " << static_cast<double>(bruteTime.count()) / blockTime.count() << "倍" << endl;
    cout << "结果一致性: " << (blockResult == bruteResult ? "一致" : "不一致") << endl;
}

int main() {
    try {
        // 执行单元测试
        testCode06_RangeSumQueryMutable();
        
        // 执行性能对比测试
        performanceComparison();
        
        // 测试调试功能
        cout << "\n=== 调试功能测试 ===" << endl;
        vector<int> testNums = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
        Code06_RangeSumQueryMutable testArray(testNums);
        testArray.printStructure();
        
    } catch (const exception& e) {
        cerr << "测试过程中发生异常: " << e.what() << endl;
        return 1;
    }
    
    return 0;
}

/**
 * C++语言特性差异分析:
 * 
 * 1. 内存管理:
 *    - 使用vector自动管理内存，避免手动内存分配
 *    - vector提供边界检查功能（通过at方法）
 *    - 支持RAII（资源获取即初始化）原则
 * 
 * 2. 异常处理:
 *    - 使用C++标准异常类（invalid_argument等）
 *    - 提供详细的错误信息
 *    - 支持异常安全保证
 * 
 * 3. 性能优化:
 *    - 使用const成员函数提高代码可读性
 *    - 避免不必要的拷贝操作
 *    - 使用高效的标准库容器
 * 
 * 4. 调试支持:
 *    - 提供调试方法打印数据结构状态
 *    - 包含性能测试功能
 *    - 支持单元测试框架集成
 * 
 * 5. 跨平台兼容性:
 *    - 使用标准C++特性，确保跨平台兼容
 *    - 避免平台特定的API调用
 *    - 提供统一的接口设计
 */

===============================================

文件: Code06_RangeSumQueryMutable.java
===============================================
package class175;

// LeetCode 307. Range Sum Query - Mutable - 分块算法实现 (Java版本)
// 题目来源: LeetCode
// 链接: https://leetcode.com/problems/range-sum-query-mutable/
// 题目大意: 实现一个支持区间和查询和单点更新的数据结构
// 约束条件: 
// - 1 <= nums.length <= 3 * 10^4
// - -100 <= nums[i] <= 100
// - 最多调用 3 * 10^4 次 update 和 sumRange 操作

// 分块算法分析:
// 时间复杂度: 
// - 构造函数: O(n)，需要初始化数组和分块信息
// - update操作: O(1)，只需要更新单个元素和对应的块和
// - sumRange操作: O(√n)，需要遍历部分块和部分元素
// 空间复杂度: O(n)，需要存储原始数组和块和数组

// 最优解验证:
// 分块算法是解决此类问题的经典方法之一，在更新和查询操作之间提供了良好的平衡。
// 对于频繁更新和查询的场景，分块算法通常比线段树更简单且常数更小。

import java.util.Arrays;

public class Code06_RangeSumQueryMutable {
    
    private int[] nums;           // 原始数组
    private int[] blockSum;        // 每个块的和
    private int blockSize;        // 块大小
    private int blockCount;       // 块数量
    
    /**
     * 构造函数 - 初始化分块数据结构
     * 
     * @param nums 初始数组
     * 
     * 算法步骤:
     * 1. 计算合适的块大小，通常选择sqrt(n)
     * 2. 初始化块和数组
     * 3. 计算每个块的初始和
     * 
     * 时间复杂度: O(n)
     * 空间复杂度: O(n)
     */
    public Code06_RangeSumQueryMutable(int[] nums) {
        if (nums == null || nums.length == 0) {
            throw new IllegalArgumentException("数组不能为空");
        }
        
        this.nums = Arrays.copyOf(nums, nums.length);
        
        // 计算块大小，通常选择sqrt(n)
        this.blockSize = (int) Math.sqrt(nums.length);
        this.blockCount = (nums.length + blockSize - 1) / blockSize;
        
        // 初始化块和数组
        this.blockSum = new int[blockCount];
        
        // 计算每个块的初始和
        for (int i = 0; i < nums.length; i++) {
            int blockIndex = i / blockSize;
            blockSum[blockIndex] += nums[i];
        }
    }
    
    /**
     * 更新操作 - 将索引i处的值更新为val
     * 
     * @param i 要更新的索引
     * @param val 新的值
     * 
     * 算法步骤:
     * 1. 验证索引有效性
     * 2. 计算值的变化量
     * 3. 更新原始数组
     * 4. 更新对应的块和
     * 
     * 时间复杂度: O(1)
     * 空间复杂度: O(1)
     * 
     * 异常处理:
     * - 索引越界: 抛出IllegalArgumentException
     * - 空数组: 已在构造函数中处理
     */
    public void update(int i, int val) {
        // 边界检查
        if (i < 0 || i >= nums.length) {
            throw new IllegalArgumentException("索引越界: " + i);
        }
        
        // 计算值的变化量
        int delta = val - nums[i];
        
        // 更新原始数组
        nums[i] = val;
        
        // 更新对应的块和
        int blockIndex = i / blockSize;
        blockSum[blockIndex] += delta;
    }
    
    /**
     * 区间和查询 - 计算索引left到right的区间和
     * 
     * @param left 区间左边界（包含）
     * @param right 区间右边界（包含）
     * @return 区间和
     * 
     * 算法步骤:
     * 1. 验证边界有效性
     * 2. 计算左右边界所在的块
     * 3. 如果左右边界在同一个块内，直接遍历计算
     * 4. 否则分三部分计算:
     *    - 左边不完整块
     *    - 中间完整块
     *    - 右边不完整块
     * 
     * 时间复杂度: O(√n)
     * 空间复杂度: O(1)
     * 
     * 异常处理:
     * - 边界越界: 抛出IllegalArgumentException
     * - left > right: 交换边界或返回0
     */
    public int sumRange(int left, int right) {
        // 边界检查
        if (left < 0 || right >= nums.length || left > right) {
            throw new IllegalArgumentException("区间边界无效: [" + left + ", " + right + "]");
        }
        
        // 如果左右边界相同，直接返回该位置的值
        if (left == right) {
            return nums[left];
        }
        
        int sum = 0;
        int leftBlock = left / blockSize;
        int rightBlock = right / blockSize;
        
        // 如果左右边界在同一个块内
        if (leftBlock == rightBlock) {
            // 直接遍历该块内的元素
            for (int i = left; i <= right; i++) {
                sum += nums[i];
            }
        } else {
            // 计算左边不完整块的和
            for (int i = left; i < (leftBlock + 1) * blockSize; i++) {
                sum += nums[i];
            }
            
            // 计算中间完整块的和
            for (int block = leftBlock + 1; block < rightBlock; block++) {
                sum += blockSum[block];
            }
            
            // 计算右边不完整块的和
            for (int i = rightBlock * blockSize; i <= right; i++) {
                sum += nums[i];
            }
        }
        
        return sum;
    }
    
    /**
     * 获取数组长度
     * 
     * @return 数组长度
     */
    public int size() {
        return nums.length;
    }
    
    /**
     * 获取块大小
     * 
     * @return 块大小
     */
    public int getBlockSize() {
        return blockSize;
    }
    
    /**
     * 获取块数量
     * 
     * @return 块数量
     */
    public int getBlockCount() {
        return blockCount;
    }
    
    /**
     * 单元测试方法 - 验证算法的正确性
     * 
     * 测试用例设计:
     * 1. 正常情况测试
     * 2. 边界情况测试
     * 3. 异常情况测试
     * 4. 性能测试
     */
    public static void main(String[] args) {
        // 测试用例1: 正常情况
        System.out.println("=== 测试用例1: 正常情况 ===");
        int[] nums1 = {1, 3, 5, 7, 9, 11};
        Code06_RangeSumQueryMutable numArray1 = new Code06_RangeSumQueryMutable(nums1);
        
        // 测试初始区间和
        System.out.println("sumRange(0, 2) = " + numArray1.sumRange(0, 2)); // 期望: 1+3+5=9
        System.out.println("sumRange(1, 4) = " + numArray1.sumRange(1, 4)); // 期望: 3+5+7+9=24
        
        // 测试更新操作
        numArray1.update(1, 10);
        System.out.println("更新后 sumRange(0, 2) = " + numArray1.sumRange(0, 2)); // 期望: 1+10+5=16
        
        // 测试用例2: 边界情况
        System.out.println("\n=== 测试用例2: 边界情况 ===");
        int[] nums2 = {2};
        Code06_RangeSumQueryMutable numArray2 = new Code06_RangeSumQueryMutable(nums2);
        
        System.out.println("sumRange(0, 0) = " + numArray2.sumRange(0, 0)); // 期望: 2
        numArray2.update(0, 5);
        System.out.println("更新后 sumRange(0, 0) = " + numArray2.sumRange(0, 0)); // 期望: 5
        
        // 测试用例3: 空数组（异常情况）
        System.out.println("\n=== 测试用例3: 异常情况 ===");
        try {
            int[] nums3 = {};
            Code06_RangeSumQueryMutable numArray3 = new Code06_RangeSumQueryMutable(nums3);
        } catch (IllegalArgumentException e) {
            System.out.println("正确捕获异常: " + e.getMessage());
        }
        
        // 测试用例4: 大规模数据性能测试
        System.out.println("\n=== 测试用例4: 性能测试 ===");
        int size = 10000;
        int[] nums4 = new int[size];
        for (int i = 0; i < size; i++) {
            nums4[i] = i + 1;
        }
        
        Code06_RangeSumQueryMutable numArray4 = new Code06_RangeSumQueryMutable(nums4);
        
        long startTime = System.currentTimeMillis();
        int result = numArray4.sumRange(0, size - 1);
        long endTime = System.currentTimeMillis();
        
        System.out.println("大规模数据区间和: " + result);
        System.out.println("查询时间: " + (endTime - startTime) + "ms");
        
        // 验证结果正确性
        long expected = (long) size * (size + 1) / 2;
        System.out.println("期望结果: " + expected);
        System.out.println("结果正确性: " + (result == expected));
        
        System.out.println("\n=== 所有测试用例执行完成 ===");
    }
    
    /**
     * 调试方法 - 打印数据结构状态
     * 用于调试和问题定位
     */
    public void printStructure() {
        System.out.println("=== 分块数据结构状态 ===");
        System.out.println("数组长度: " + nums.length);
        System.out.println("块大小: " + blockSize);
        System.out.println("块数量: " + blockCount);
        
        System.out.println("原始数组: " + Arrays.toString(nums));
        System.out.println("块和数组: " + Arrays.toString(blockSum));
        
        // 验证块和正确性
        int totalSum = 0;
        for (int num : nums) {
            totalSum += num;
        }
        
        int blockSumTotal = 0;
        for (int sum : blockSum) {
            blockSumTotal += sum;
        }
        
        System.out.println("数组总和: " + totalSum);
        System.out.println("块和总和: " + blockSumTotal);
        System.out.println("一致性检查: " + (totalSum == blockSumTotal));
    }
}

/**
 * 工程化考量总结:
 * 
 * 1. 异常处理:
 *    - 构造函数验证输入有效性
 *    - update和sumRange方法验证参数边界
 *    - 提供清晰的错误信息
 * 
 * 2. 性能优化:
 *    - 选择合适的块大小平衡查询和更新性能
 *    - 避免不必要的计算和内存分配
 *    - 使用基本数据类型减少对象开销
 * 
 * 3. 可维护性:
 *    - 详细的注释说明算法原理和步骤
 *    - 模块化的方法设计
 *    - 完整的单元测试覆盖
 * 
 * 4. 调试支持:
 *    - 提供调试方法打印数据结构状态
 *    - 包含一致性检查功能
 *    - 支持性能测试和验证
 * 
 * 5. 扩展性:
 *    - 易于添加新的功能
 *    - 支持不同的块大小策略
 *    - 可以扩展为支持其他区间操作
 */

===============================================

文件: Code06_TillCollapse.cpp
===============================================
// 最少划分问题 - 分块算法优化 (C++版本)
// 题目来源: https://www.luogu.com.cn/problem/CF786C
// 题目来源: https://codeforces.com/problemset/problem/786/C
// 题目大意: 给定一个长度为n的数组arr，考虑如下问题的解
// 数组arr划分成若干段子数组，保证每段不同数字的种类 <= k，返回至少划分成几段
// 打印k = 1, 2, 3..n时，所有的答案
// 约束条件: 1 <= arr[i] <= n <= 10^5

#include <cstdio>
#include <cmath>
#include <algorithm>
using namespace std;

const int MAXN = 100001;
int n, blen;
int arr[MAXN];
bool vis[MAXN];
int ans[MAXN];

/**
 * 查询当限制为limit时，最少需要划分成几段
 * @param limit 每段不同数字种类的上限
 * @return 最少段数
 */
int query(int limit) {
    int kind = 0, cnt = 0, start = 1;
    
    // 遍历数组
    for (int i = 1; i <= n; i++) {
        // 如果当前数字没有出现过
        if (!vis[arr[i]]) {
            kind++; // 不同数字种类数+1
            
            // 如果超过了限制
            if (kind > limit) {
                cnt++; // 段数+1
                
                // 清除之前段的标记
                for (int j = start; j < i; j++) {
                    vis[arr[j]] = false;
                }
                
                // 更新新段的起始位置
                start = i;
                kind = 1; // 重置种类数为1
            }
            
            // 标记当前数字已出现
            vis[arr[i]] = true;
        }
    }
    
    // 处理最后一段
    if (kind > 0) {
        cnt++;
        // 清除最后一段的标记
        for (int j = start; j <= n; j++) {
            vis[arr[j]] = false;
        }
    }
    return cnt;
}

/**
 * 跳跃函数，用于优化计算
 * @param l 左边界
 * @param r 右边界
 * @param curAns 当前答案
 * @return 下一个需要计算的位置
 */
int jump(int l, int r, int curAns) {
    int find = l;
    while (l <= r) {
        int mid = (l + r) >> 1;
        int check = query(mid);
        
        if (check < curAns) {
            r = mid - 1;
        } else if (check > curAns) {
            l = mid + 1;
        } else {
            find = mid;
            l = mid + 1;
        }
    }
    return find + 1;
}

/**
 * 计算所有答案
 */
void compute() {
    // 对于k <= sqrt(n)的情况，直接计算
    for (int i = 1; i <= blen; i++) {
        ans[i] = query(i);
    }
    
    // 对于k > sqrt(n)的情况，使用跳跃优化
    for (int i = blen + 1; i <= n; i = jump(i, n, ans[i])) {
        ans[i] = query(i);
    }
}

/**
 * 预处理函数
 */
void prepare() {
    // 计算块大小，选择sqrt(n * log2(n))以优化性能
    blen = max(1, (int)sqrt((double)(n * log2(n))));
    
    // 初始化答案数组为-1，表示未计算
    fill(ans + 1, ans + n + 1, -1);
}

int main() {
    // 读取数组长度n
    scanf("%d", &n);
    
    // 读取初始数组
    for (int i = 1; i <= n; i++) {
        scanf("%d", &arr[i]);
    }
    
    // 进行预处理
    prepare();
    
    // 计算所有答案
    compute();
    
    // 输出所有答案
    for (int i = 1; i <= n; i++) {
        // 如果答案未计算，则继承前一个答案
        if (ans[i] == -1) {
            ans[i] = ans[i - 1];
        }
        printf("%d ", ans[i]);
    }
    printf("\n");
    return 0;
}

===============================================

文件: Code06_TillCollapse.py
===============================================
# 最少划分问题 - 分块算法优化 (Python版本)
# 题目来源: https://www.luogu.com.cn/problem/CF786C
# 题目来源: https://codeforces.com/problemset/problem/786/C
# 题目大意: 给定一个长度为n的数组arr，考虑如下问题的解
# 数组arr划分成若干段子数组，保证每段不同数字的种类 <= k，返回至少划分成几段
# 打印k = 1, 2, 3..n时，所有的答案
# 约束条件: 1 <= arr[i] <= n <= 10^5

import math
import sys

# 定义最大数组长度
MAXN = 100001

# 全局变量
n, blen = 0, 0

# arr: 原始数组
arr = [0] * MAXN

# vis: 记录数字是否出现过
vis = [False] * MAXN

# ans: 存储每个k对应的答案
ans = [0] * MAXN

def query(limit):
    """
    查询当限制为limit时，最少需要划分成几段
    参数:
        limit: 每段不同数字种类的上限
    返回:
        最少段数
    """
    kind, cnt, start = 0, 0, 1
    
    # 遍历数组
    for i in range(1, n + 1):
        # 如果当前数字没有出现过
        if not vis[arr[i]]:
            kind += 1  # 不同数字种类数+1
            
            # 如果超过了限制
            if kind > limit:
                cnt += 1  # 段数+1
                
                # 清除之前段的标记
                for j in range(start, i):
                    vis[arr[j]] = False
                
                # 更新新段的起始位置
                start = i
                kind = 1  # 重置种类数为1
            
            # 标记当前数字已出现
            vis[arr[i]] = True
    
    # 处理最后一段
    if kind > 0:
        cnt += 1
        # 清除最后一段的标记
        for j in range(start, n + 1):
            vis[arr[j]] = False
    
    return cnt

def jump(l, r, curAns):
    """
    跳跃函数，用于优化计算
    参数:
        l: 左边界
        r: 右边界
        curAns: 当前答案
    返回:
        下一个需要计算的位置
    """
    find = l
    while l <= r:
        mid = (l + r) >> 1
        check = query(mid)
        
        if check < curAns:
            r = mid - 1
        elif check > curAns:
            l = mid + 1
        else:
            find = mid
            l = mid + 1
    return find + 1

def compute():
    """
    计算所有答案
    """
    # 对于k <= sqrt(n)的情况，直接计算
    for i in range(1, blen + 1):
        ans[i] = query(i)
    
    # 对于k > sqrt(n)的情况，使用跳跃优化
    i = blen + 1
    while i <= n:
        ans[i] = query(i)
        i = jump(i, n, ans[i])

def prepare():
    """
    预处理函数
    """
    global blen
    # 计算块大小，选择sqrt(n * log2(n))以优化性能
    log2n = 0
    while (1 << log2n) <= (n >> 1):
        log2n += 1
    blen = max(1, int(math.sqrt(n * log2n)))
    
    # 初始化答案数组为-1，表示未计算
    for i in range(1, n + 1):
        ans[i] = -1

def main():
    global n
    # 读取数组长度n
    n = int(sys.stdin.readline())
    
    # 读取初始数组
    values = list(map(int, sys.stdin.readline().split()))
    for i in range(1, n + 1):
        arr[i] = values[i - 1]
    
    # 进行预处理
    prepare()
    
    # 计算所有答案
    compute()
    
    # 输出所有答案
    for i in range(1, n + 1):
        # 如果答案未计算，则继承前一个答案
        if ans[i] == -1:
            ans[i] = ans[i - 1]
        print(ans[i], end=' ')
    print()

if __name__ == "__main__":
    main()

===============================================

文件: Code06_TillCollapse1.java
===============================================
package class175;

// 最少划分问题 - 分块算法优化 (Java版本)
// 题目来源: https://www.luogu.com.cn/problem/CF786C
// 题目来源: https://codeforces.com/problemset/problem/786/C
// 题目大意: 给定一个长度为n的数组arr，考虑如下问题的解
// 数组arr划分成若干段子数组，保证每段不同数字的种类 <= k，返回至少划分成几段
// 打印k = 1, 2, 3..n时，所有的答案
// 约束条件: 1 <= arr[i] <= n <= 10^5

import java.io.InputStream;
import java.io.PrintWriter;
import java.util.Arrays;
import java.io.IOException;

public class Code06_TillCollapse1 {

    // 定义最大数组长度
    public static int MAXN = 100001;
    
    // n: 数组长度, blen: 块大小
    public static int n, blen;
    
    // arr: 原始数组
    public static int[] arr = new int[MAXN];
    
    // vis: 记录数字是否出现过
    public static boolean[] vis = new boolean[MAXN];
    
    // ans: 存储每个k对应的答案
    public static int[] ans = new int[MAXN];

    /**
     * 查询当限制为limit时，最少需要划分成几段
     * @param limit 每段不同数字种类的上限
     * @return 最少段数
     */
    public static int query(int limit) {
        int kind = 0, cnt = 0, start = 1;
        
        // 遍历数组
        for (int i = 1; i <= n; i++) {
            // 如果当前数字没有出现过
            if (!vis[arr[i]]) {
                kind++; // 不同数字种类数+1
                
                // 如果超过了限制
                if (kind > limit) {
                    cnt++; // 段数+1
                    
                    // 清除之前段的标记
                    for (int j = start; j < i; j++) {
                        vis[arr[j]] = false;
                    }
                    
                    // 更新新段的起始位置
                    start = i;
                    kind = 1; // 重置种类数为1
                }
                
                // 标记当前数字已出现
                vis[arr[i]] = true;
            }
        }
        
        // 处理最后一段
        if (kind > 0) {
            cnt++;
            // 清除最后一段的标记
            for (int j = start; j <= n; j++) {
                vis[arr[j]] = false;
            }
        }
        return cnt;
    }

    /**
     * 跳跃函数，用于优化计算
     * @param l 左边界
     * @param r 右边界
     * @param curAns 当前答案
     * @return 下一个需要计算的位置
     */
    public static int jump(int l, int r, int curAns) {
        int find = l;
        while (l <= r) {
            int mid = (l + r) >> 1;
            int check = query(mid);
            
            if (check < curAns) {
                r = mid - 1;
            } else if (check > curAns) {
                l = mid + 1;
            } else {
                find = mid;
                l = mid + 1;
            }
        }
        return find + 1;
    }

    /**
     * 计算所有答案
     */
    public static void compute() {
        // 对于k <= sqrt(n)的情况，直接计算
        for (int i = 1; i <= blen; i++) {
            ans[i] = query(i);
        }
        
        // 对于k > sqrt(n)的情况，使用跳跃优化
        for (int i = blen + 1; i <= n; i = jump(i, n, ans[i])) {
            ans[i] = query(i);
        }
    }

    /**
     * 预处理函数
     */
    public static void prepare() {
        // 计算块大小，选择sqrt(n * log2(n))以优化性能
        int log2n = 0;
        while ((1 << log2n) <= (n >> 1)) {
            log2n++;
        }
        blen = Math.max(1, (int) Math.sqrt(n * log2n));
        
        // 初始化答案数组为-1，表示未计算
        Arrays.fill(ans, 1, n + 1, -1);
    }

    public static void main(String[] args) throws Exception {
        FastReader in = new FastReader(System.in);
        PrintWriter out = new PrintWriter(System.out);
        
        // 读取数组长度n
        n = in.nextInt();
        
        // 读取初始数组
        for (int i = 1; i <= n; i++) {
            arr[i] = in.nextInt();
        }
        
        // 进行预处理
        prepare();
        
        // 计算所有答案
        compute();
        
        // 输出所有答案
        for (int i = 1; i <= n; i++) {
            // 如果答案未计算，则继承前一个答案
            if (ans[i] == -1) {
                ans[i] = ans[i - 1];
            }
            out.print(ans[i] + " ");
        }
        out.println();
        
        out.flush();
        out.close();
    }

    // 高效读取工具类，用于加快输入输出速度
    static class FastReader {
        private final byte[] buffer = new byte[1 << 16];
        private int ptr = 0, len = 0;
        private final InputStream in;

        FastReader(InputStream in) {
            this.in = in;
        }

        private int readByte() throws IOException {
            if (ptr >= len) {
                len = in.read(buffer);
                ptr = 0;
                if (len <= 0)
                    return -1;
            }
            return buffer[ptr++];
        }

        int nextInt() throws IOException {
            int c;
            do {
                c = readByte();
            } while (c <= ' ' && c != -1);
            boolean neg = false;
            if (c == '-') {
                neg = true;
                c = readByte();
            }
            int val = 0;
            while (c > ' ' && c != -1) {
                val = val * 10 + (c - '0');
                c = readByte();
            }
            return neg ? -val : val;
        }
    }

}

===============================================

文件: Code06_TillCollapse2.java
===============================================
package class175;

// 最少划分问题 - 分块算法优化 (C++版本的Java注释版)
// 题目来源: https://www.luogu.com.cn/problem/CF786C
// 题目来源: https://codeforces.com/problemset/problem/786/C
// 题目大意: 给定一个长度为n的数组arr，考虑如下问题的解
// 数组arr划分成若干段子数组，保证每段不同数字的种类 <= k，返回至少划分成几段
// 打印k = 1, 2, 3..n时，所有的答案
// 约束条件: 1 <= arr[i] <= n <= 10^5

// 以下是C++版本的实现，逻辑与Java版本完全一致
// 提交时需要将代码转换为C++格式

//#include <bits/stdc++.h>
//
//using namespace std;
//
//const int MAXN = 100001;
//int n, blen;
//int arr[MAXN];
//bool vis[MAXN];
//int ans[MAXN];
//
//int query(int limit) {
//    int kind = 0, cnt = 0, start = 1;
//    for (int i = 1; i <= n; i++) {
//        if (!vis[arr[i]]) {
//            kind++;
//            if (kind > limit) {
//                cnt++;
//                for (int j = start; j < i; j++) {
//                    vis[arr[j]] = false;
//                }
//                start = i;
//                kind = 1;
//            }
//            vis[arr[i]] = true;
//        }
//    }
//    if (kind > 0) {
//        cnt++;
//        for (int j = start; j <= n; j++) {
//            vis[arr[j]] = false;
//        }
//    }
//    return cnt;
//}
//
//int jump(int l, int r, int curAns) {
//    int find = l;
//    while (l <= r) {
//        int mid = (l + r) >> 1;
//        int check = query(mid);
//        if (check < curAns) {
//            r = mid - 1;
//        } else if (check > curAns) {
//            l = mid + 1;
//        } else {
//            find = mid;
//            l = mid + 1;
//        }
//    }
//    return find + 1;
//}
//
//void compute() {
//    for (int i = 1; i <= blen; i++) {
//        ans[i] = query(i);
//    }
//    for (int i = blen + 1; i <= n; i = jump(i, n, ans[i])) {
//        ans[i] = query(i);
//    }
//}
//
//void prepare() {
//    blen = max(1, (int)sqrt(n * log2(n)));
//    fill(ans + 1, ans + n + 1, -1);
//}
//
//int main() {
//    ios::sync_with_stdio(false);
//    cin.tie(nullptr);
//    cin >> n;
//    for (int i = 1; i <= n; i++) {
//        cin >> arr[i];
//    }
//    prepare();
//    compute();
//    for (int i = 1; i <= n; i++) {
//        if (ans[i] == -1) {
//            ans[i] = ans[i - 1];
//        }
//        cout << ans[i] << ' ';
//    }
//    cout << '\n';
//    return 0;
//}

===============================================

文件: Code07_GivenTree.cpp
===============================================
// 给你一棵树问题 - 分块算法优化动态规划 (C++版本)
// 题目来源: https://www.luogu.com.cn/problem/CF1039D
// 题目来源: https://codeforces.com/problemset/problem/1039/D
// 题目大意: 一共有n个节点，给定n-1条边，所有节点连成一棵树
// 树的路径是指，从端点x到端点y的简单路径，k路径是指，路径的节点数正好为k
// 整棵树希望分解成尽量多的k路径，k路径的节点不能复用，所有k路径不要求包含所有点
// 打印k = 1, 2, 3..n时，k路径有最多有几条
// 约束条件: 1 <= n <= 200000

#include <cstdio>
#include <cmath>
#include <algorithm>
using namespace std;

const int MAXN = 200001;
int n, blen;
int head[MAXN];
int nxt[MAXN << 1];
int to[MAXN << 1];
int cntg = 0;

int fa[MAXN];
int dfnOrder[MAXN];
int cntd = 0;

int len[MAXN];
int max1[MAXN];
int max2[MAXN];

int ans[MAXN];

/**
 * 添加边到邻接表
 * @param u 节点u
 * @param v 节点v
 */
void addEdge(int u, int v) {
    // 添加u->v的边
    nxt[++cntg] = head[u];
    to[cntg] = v;
    head[u] = cntg;
    
    // 添加v->u的边
    nxt[++cntg] = head[v];
    to[cntg] = u;
    head[v] = cntg;
}

/**
 * DFS遍历树，生成dfn序
 * @param u 当前节点
 * @param f 父节点
 */
void dfs(int u, int f) {
    // 记录父节点
    fa[u] = f;
    
    // 记录dfn序
    dfnOrder[++cntd] = u;
    
    // 遍历所有子节点
    for (int e = head[u]; e; e = nxt[e]) {
        // 避免回到父节点
        if (to[e] != f) {
            dfs(to[e], u);
        }
    }
}

/**
 * 查询当路径长度为k时，最多能分解成几条路径
 * @param k 路径长度
 * @return 最多路径数
 */
int query(int k) {
    int cnt = 0;
    
    // 按照dfn序的逆序处理节点
    for (int i = n, cur, father; i >= 1; i--) {
        cur = dfnOrder[i];
        father = fa[cur];
        
        // 如果当前节点的最长链和次长链之和+1 >= k
        // 说明可以形成一条长度为k的路径
        if (max1[cur] + max2[cur] + 1 >= k) {
            cnt++; // 路径数+1
            len[cur] = 0; // 当前节点的最长链长度重置为0
        } else {
            // 否则更新当前节点的最长链长度
            len[cur] = max1[cur] + 1;
        }
        
        // 更新父节点的最长链和次长链
        if (len[cur] > max1[father]) {
            max2[father] = max1[father];
            max1[father] = len[cur];
        } else if (len[cur] > max2[father]) {
            max2[father] = len[cur];
        }
    }
    
    // 重置数组
    for (int i = 1; i <= n; i++) {
        len[i] = max1[i] = max2[i] = 0;
    }
    return cnt;
}

/**
 * 跳跃函数，用于优化计算
 * @param l 左边界
 * @param r 右边界
 * @param curAns 当前答案
 * @return 下一个需要计算的位置
 */
int jump(int l, int r, int curAns) {
    int find = l;
    while (l <= r) {
        int mid = (l + r) >> 1;
        int check = query(mid);
        
        if (check < curAns) {
            r = mid - 1;
        } else if (check > curAns) {
            l = mid + 1;
        } else {
            find = mid;
            l = mid + 1;
        }
    }
    return find + 1;
}

/**
 * 计算所有答案
 */
void compute() {
    // 对于k <= sqrt(n)的情况，直接计算
    for (int i = 1; i <= blen; i++) {
        ans[i] = query(i);
    }
    
    // 对于k > sqrt(n)的情况，使用跳跃优化
    for (int i = blen + 1; i <= n; i = jump(i, n, ans[i])) {
        ans[i] = query(i);
    }
}

/**
 * 预处理函数
 */
void prepare() {
    // 计算块大小，选择sqrt(n * log2(n))以优化性能
    blen = max(1, (int)sqrt((double)(n * log2(n))));
    
    // 初始化答案数组为-1，表示未计算
    fill(ans + 1, ans + n + 1, -1);
}

int main() {
    // 读取节点数量n
    scanf("%d", &n);
    
    // 读取n-1条边
    for (int i = 1, u, v; i < n; i++) {
        scanf("%d%d", &u, &v);
        addEdge(u, v);
    }
    
    // DFS生成dfn序
    dfs(1, 0);
    
    // 进行预处理
    prepare();
    
    // 计算所有答案
    compute();
    
    // 输出所有答案
    for (int i = 1; i <= n; i++) {
        // 如果答案未计算，则继承前一个答案
        if (ans[i] == -1) {
            ans[i] = ans[i - 1];
        }
        printf("%d\n", ans[i]);
    }
    return 0;
}// 给你一棵树问题 - 分块算法优化动态规划 (C++版本)
// 题目来源: https://www.luogu.com.cn/problem/CF1039D
// 题目来源: https://codeforces.com/problemset/problem/1039/D
// 题目大意: 一共有n个节点，给定n-1条边，所有节点连成一棵树
// 树的路径是指，从端点x到端点y的简单路径，k路径是指，路径的节点数正好为k
// 整棵树希望分解成尽量多的k路径，k路径的节点不能复用，所有k路径不要求包含所有点
// 打印k = 1, 2, 3..n时，k路径有最多有几条
// 约束条件: 1 <= n <= 200000

#include <cstdio>
#include <cmath>
#include <algorithm>
using namespace std;

const int MAXN = 200001;
int n, blen;
int head[MAXN];
int nxt[MAXN << 1];
int to[MAXN << 1];
int cntg = 0;

int fa[MAXN];
int dfnOrder[MAXN];
int cntd = 0;

int len[MAXN];
int max1[MAXN];
int max2[MAXN];

int ans[MAXN];

/**
 * 添加边到邻接表
 * @param u 节点u
 * @param v 节点v
 */
void addEdge(int u, int v) {
    // 添加u->v的边
    nxt[++cntg] = head[u];
    to[cntg] = v;
    head[u] = cntg;
    
    // 添加v->u的边
    nxt[++cntg] = head[v];
    to[cntg] = u;
    head[v] = cntg;
}

/**
 * DFS遍历树，生成dfn序
 * @param u 当前节点
 * @param f 父节点
 */
void dfs(int u, int f) {
    // 记录父节点
    fa[u] = f;
    
    // 记录dfn序
    dfnOrder[++cntd] = u;
    
    // 遍历所有子节点
    for (int e = head[u]; e; e = nxt[e]) {
        // 避免回到父节点
        if (to[e] != f) {
            dfs(to[e], u);
        }
    }
}

/**
 * 查询当路径长度为k时，最多能分解成几条路径
 * @param k 路径长度
 * @return 最多路径数
 */
int query(int k) {
    int cnt = 0;
    
    // 按照dfn序的逆序处理节点
    for (int i = n, cur, father; i >= 1; i--) {
        cur = dfnOrder[i];
        father = fa[cur];
        
        // 如果当前节点的最长链和次长链之和+1 >= k
        // 说明可以形成一条长度为k的路径
        if (max1[cur] + max2[cur] + 1 >= k) {
            cnt++; // 路径数+1
            len[cur] = 0; // 当前节点的最长链长度重置为0
        } else {
            // 否则更新当前节点的最长链长度
            len[cur] = max1[cur] + 1;
        }
        
        // 更新父节点的最长链和次长链
        if (len[cur] > max1[father]) {
            max2[father] = max1[father];
            max1[father] = len[cur];
        } else if (len[cur] > max2[father]) {
            max2[father] = len[cur];
        }
    }
    
    // 重置数组
    for (int i = 1; i <= n; i++) {
        len[i] = max1[i] = max2[i] = 0;
    }
    return cnt;
}

/**
 * 跳跃函数，用于优化计算
 * @param l 左边界
 * @param r 右边界
 * @param curAns 当前答案
 * @return 下一个需要计算的位置
 */
int jump(int l, int r, int curAns) {
    int find = l;
    while (l <= r) {
        int mid = (l + r) >> 1;
        int check = query(mid);
        
        if (check < curAns) {
            r = mid - 1;
        } else if (check > curAns) {
            l = mid + 1;
        } else {
            find = mid;
            l = mid + 1;
        }
    }
    return find + 1;
}

/**
 * 计算所有答案
 */
void compute() {
    // 对于k <= sqrt(n)的情况，直接计算
    for (int i = 1; i <= blen; i++) {
        ans[i] = query(i);
    }
    
    // 对于k > sqrt(n)的情况，使用跳跃优化
    for (int i = blen + 1; i <= n; i = jump(i, n, ans[i])) {
        ans[i] = query(i);
    }
}

/**
 * 预处理函数
 */
void prepare() {
    // 计算块大小，选择sqrt(n * log2(n))以优化性能
    blen = max(1, (int)sqrt((double)(n * log2(n))));
    
    // 初始化答案数组为-1，表示未计算
    fill(ans + 1, ans + n + 1, -1);
}

int main() {
    // 读取节点数量n
    scanf("%d", &n);
    
    // 读取n-1条边
    for (int i = 1, u, v; i < n; i++) {
        scanf("%d%d", &u, &v);
        addEdge(u, v);
    }
    
    // DFS生成dfn序
    dfs(1, 0);
    
    // 进行预处理
    prepare();
    
    // 计算所有答案
    compute();
    
    // 输出所有答案
    for (int i = 1; i <= n; i++) {
        // 如果答案未计算，则继承前一个答案
        if (ans[i] == -1) {
            ans[i] = ans[i - 1];
        }
        printf("%d\n", ans[i]);
    }
    return 0;
}

===============================================

文件: Code07_GivenTree.py
===============================================
# 给你一棵树问题 - 分块算法优化动态规划 (Python版本)
# 题目来源: https://www.luogu.com.cn/problem/CF1039D
# 题目来源: https://codeforces.com/problemset/problem/1039/D
# 题目大意: 一共有n个节点，给定n-1条边，所有节点连成一棵树
# 树的路径是指，从端点x到端点y的简单路径，k路径是指，路径的节点数正好为k
# 整棵树希望分解成尽量多的k路径，k路径的节点不能复用，所有k路径不要求包含所有点
# 打印k = 1, 2, 3..n时，k路径有最多有几条
# 约束条件: 1 <= n <= 200000

import math
import sys

# 定义最大数组长度
MAXN = 200001

# 全局变量
n, blen = 0, 0

# 邻接表存储树的结构
# head[i]: 节点i的邻接表头节点
head = [0] * MAXN

# next[i]: 邻接表中第i个节点的下一个节点
next_arr = [0] * (MAXN << 1)

# to[i]: 邻接表中第i个节点存储的相邻节点
to = [0] * (MAXN << 1)

# cntg: 邻接表节点计数器
cntg = 0

# fa[i]: 节点i的父节点编号
fa = [0] * MAXN

# dfnOrder: 根据dfn序，依次收集上来的节点编号
dfnOrder = [0] * MAXN

# cntd: dfn序计数器
cntd = 0

# len[i]: 当前i号节点只能往下走，没分配成路径的最长链的长度
len_arr = [0] * MAXN

# max1[i]: 最大值 { len[a], len[b], len[c] ... }，其中a、b、c..是i的子节点
max1 = [0] * MAXN

# max2[i]: 次大值 { len[a], len[b], len[c] ... }，其中a、b、c..是i的子节点
max2 = [0] * MAXN

# ans: 存储每个k对应的答案
ans = [0] * MAXN

def addEdge(u, v):
    """
    添加边到邻接表
    参数:
        u: 节点u
        v: 节点v
    """
    global cntg
    # 添加u->v的边
    cntg += 1
    next_arr[cntg] = head[u]
    to[cntg] = v
    head[u] = cntg
    
    # 添加v->u的边
    cntg += 1
    next_arr[cntg] = head[v]
    to[cntg] = u
    head[v] = cntg

def dfs(u, f):
    """
    DFS遍历树，生成dfn序
    参数:
        u: 当前节点
        f: 父节点
    """
    global cntd
    # 记录父节点
    fa[u] = f
    
    # 记录dfn序
    cntd += 1
    dfnOrder[cntd] = u
    
    # 遍历所有子节点
    e = head[u]
    while e > 0:
        # 避免回到父节点
        if to[e] != f:
            dfs(to[e], u)
        e = next_arr[e]

def query(k):
    """
    查询当路径长度为k时，最多能分解成几条路径
    参数:
        k: 路径长度
    返回:
        最多路径数
    """
    cnt = 0
    
    # 按照dfn序的逆序处理节点
    for i in range(n, 0, -1):
        cur = dfnOrder[i]
        father = fa[cur]
        
        # 如果当前节点的最长链和次长链之和+1 >= k
        # 说明可以形成一条长度为k的路径
        if max1[cur] + max2[cur] + 1 >= k:
            cnt += 1  # 路径数+1
            len_arr[cur] = 0  # 当前节点的最长链长度重置为0
        else:
            # 否则更新当前节点的最长链长度
            len_arr[cur] = max1[cur] + 1
        
        # 更新父节点的最长链和次长链
        if len_arr[cur] > max1[father]:
            max2[father] = max1[father]
            max1[father] = len_arr[cur]
        elif len_arr[cur] > max2[father]:
            max2[father] = len_arr[cur]
    
    # 重置数组
    for i in range(1, n + 1):
        len_arr[i] = max1[i] = max2[i] = 0
    return cnt

def jump(l, r, curAns):
    """
    跳跃函数，用于优化计算
    参数:
        l: 左边界
        r: 右边界
        curAns: 当前答案
    返回:
        下一个需要计算的位置
    """
    find = l
    while l <= r:
        mid = (l + r) >> 1
        check = query(mid)
        
        if check < curAns:
            r = mid - 1
        elif check > curAns:
            l = mid + 1
        else:
            find = mid
            l = mid + 1
    return find + 1

def compute():
    """
    计算所有答案
    """
    # 对于k <= sqrt(n)的情况，直接计算
    for i in range(1, blen + 1):
        ans[i] = query(i)
    
    # 对于k > sqrt(n)的情况，使用跳跃优化
    i = blen + 1
    while i <= n:
        ans[i] = query(i)
        i = jump(i, n, ans[i])

def prepare():
    """
    预处理函数
    """
    global blen
    # 计算块大小，选择sqrt(n * log2(n))以优化性能
    log2n = 0
    while (1 << log2n) <= (n >> 1):
        log2n += 1
    blen = max(1, int(math.sqrt(n * log2n)))
    
    # 初始化答案数组为-1，表示未计算
    for i in range(1, n + 1):
        ans[i] = -1

def main():
    global n
    # 读取节点数量n
    n = int(sys.stdin.readline())
    
    # 读取n-1条边
    for i in range(1, n):
        u, v = map(int, sys.stdin.readline().split())
        addEdge(u, v)
    
    # DFS生成dfn序
    dfs(1, 0)
    
    # 进行预处理
    prepare()
    
    # 计算所有答案
    compute()
    
    # 输出所有答案
    for i in range(1, n + 1):
        # 如果答案未计算，则继承前一个答案
        if ans[i] == -1:
            ans[i] = ans[i - 1]
        print(ans[i])

if __name__ == "__main__":
    main()

===============================================

文件: Code07_GivenTree1.java
===============================================
package class175;

// 给你一棵树问题 - 分块算法优化动态规划 (Java版本)
// 题目来源: https://www.luogu.com.cn/problem/CF1039D
// 题目来源: https://codeforces.com/problemset/problem/1039/D
// 题目大意: 一共有n个节点，给定n-1条边，所有节点连成一棵树
// 树的路径是指，从端点x到端点y的简单路径，k路径是指，路径的节点数正好为k
// 整棵树希望分解成尽量多的k路径，k路径的节点不能复用，所有k路径不要求包含所有点
// 打印k = 1, 2, 3..n时，k路径有最多有几条
// 约束条件: 1 <= n <= 200000

import java.io.IOException;
import java.io.InputStream;
import java.io.PrintWriter;
import java.util.Arrays;

public class Code07_GivenTree1 {

    // 定义最大数组长度
    public static int MAXN = 200001;
    
    // n: 节点数量, blen: 块大小
    public static int n, blen;
    
    // 邻接表存储树的结构
    // head[i]: 节点i的邻接表头节点
    public static int[] head = new int[MAXN];
    
    // next[i]: 邻接表中第i个节点的下一个节点
    public static int[] next = new int[MAXN << 1];
    
    // to[i]: 邻接表中第i个节点存储的相邻节点
    public static int[] to = new int[MAXN << 1];
    
    // cntg: 邻接表节点计数器
    public static int cntg = 0;

    // fa[i]: 节点i的父节点编号
    public static int[] fa = new int[MAXN];
    
    // dfnOrder: 根据dfn序，依次收集上来的节点编号
    public static int[] dfnOrder = new int[MAXN];
    
    // cntd: dfn序计数器
    public static int cntd = 0;

    // len[i]: 当前i号节点只能往下走，没分配成路径的最长链的长度
    public static int[] len = new int[MAXN];
    
    // max1[i]: 最大值 { len[a], len[b], len[c] ... }，其中a、b、c..是i的子节点
    public static int[] max1 = new int[MAXN];
    
    // max2[i]: 次大值 { len[a], len[b], len[c] ... }，其中a、b、c..是i的子节点
    public static int[] max2 = new int[MAXN];

    // ans: 存储每个k对应的答案
    public static int[] ans = new int[MAXN];

    /**
     * 添加边到邻接表
     * @param u 节点u
     * @param v 节点v
     */
    public static void addEdge(int u, int v) {
        // 添加u->v的边
        next[++cntg] = head[u];
        to[cntg] = v;
        head[u] = cntg;
        
        // 添加v->u的边
        next[++cntg] = head[v];
        to[cntg] = u;
        head[v] = cntg;
    }

    /**
     * DFS遍历树，生成dfn序
     * @param u 当前节点
     * @param f 父节点
     */
    public static void dfs(int u, int f) {
        // 记录父节点
        fa[u] = f;
        
        // 记录dfn序
        dfnOrder[++cntd] = u;
        
        // 遍历所有子节点
        for (int e = head[u]; e > 0; e = next[e]) {
            // 避免回到父节点
            if (to[e] != f) {
                dfs(to[e], u);
            }
        }
    }

    /**
     * 查询当路径长度为k时，最多能分解成几条路径
     * @param k 路径长度
     * @return 最多路径数
     */
    public static int query(int k) {
        int cnt = 0;
        
        // 按照dfn序的逆序处理节点
        for (int i = n, cur, father; i >= 1; i--) {
            cur = dfnOrder[i];
            father = fa[cur];
            
            // 如果当前节点的最长链和次长链之和+1 >= k
            // 说明可以形成一条长度为k的路径
            if (max1[cur] + max2[cur] + 1 >= k) {
                cnt++; // 路径数+1
                len[cur] = 0; // 当前节点的最长链长度重置为0
            } else {
                // 否则更新当前节点的最长链长度
                len[cur] = max1[cur] + 1;
            }
            
            // 更新父节点的最长链和次长链
            if (len[cur] > max1[father]) {
                max2[father] = max1[father];
                max1[father] = len[cur];
            } else if (len[cur] > max2[father]) {
                max2[father] = len[cur];
            }
        }
        
        // 重置数组
        for (int i = 1; i <= n; i++) {
            len[i] = max1[i] = max2[i] = 0;
        }
        return cnt;
    }

    /**
     * 跳跃函数，用于优化计算
     * @param l 左边界
     * @param r 右边界
     * @param curAns 当前答案
     * @return 下一个需要计算的位置
     */
    public static int jump(int l, int r, int curAns) {
        int find = l;
        while (l <= r) {
            int mid = (l + r) >> 1;
            int check = query(mid);
            
            if (check < curAns) {
                r = mid - 1;
            } else if (check > curAns) {
                l = mid + 1;
            } else {
                find = mid;
                l = mid + 1;
            }
        }
        return find + 1;
    }

    /**
     * 计算所有答案
     */
    public static void compute() {
        // 对于k <= sqrt(n)的情况，直接计算
        for (int i = 1; i <= blen; i++) {
            ans[i] = query(i);
        }
        
        // 对于k > sqrt(n)的情况，使用跳跃优化
        for (int i = blen + 1; i <= n; i = jump(i, n, ans[i])) {
            ans[i] = query(i);
        }
    }

    /**
     * 预处理函数
     */
    public static void prepare() {
        // 计算块大小，选择sqrt(n * log2(n))以优化性能
        int log2n = 0;
        while ((1 << log2n) <= (n >> 1)) {
            log2n++;
        }
        blen = Math.max(1, (int) Math.sqrt(n * log2n));
        
        // 初始化答案数组为-1，表示未计算
        Arrays.fill(ans, 1, n + 1, -1);
    }

    public static void main(String[] args) throws Exception {
        FastReader in = new FastReader(System.in);
        PrintWriter out = new PrintWriter(System.out);
        
        // 读取节点数量n
        n = in.nextInt();
        
        // 读取n-1条边
        for (int i = 1, u, v; i < n; i++) {
            u = in.nextInt();
            v = in.nextInt();
            addEdge(u, v);
        }
        
        // DFS生成dfn序
        dfs(1, 0);
        
        // 进行预处理
        prepare();
        
        // 计算所有答案
        compute();
        
        // 输出所有答案
        for (int i = 1; i <= n; i++) {
            // 如果答案未计算，则继承前一个答案
            if (ans[i] == -1) {
                ans[i] = ans[i - 1];
            }
            out.println(ans[i]);
        }
        
        out.flush();
        out.close();
    }

    // 高效读取工具类，用于加快输入输出速度
    static class FastReader {
        private final byte[] buffer = new byte[1 << 16];
        private int ptr = 0, len = 0;
        private final InputStream in;

        FastReader(InputStream in) {
            this.in = in;
        }

        private int readByte() throws IOException {
            if (ptr >= len) {
                len = in.read(buffer);
                ptr = 0;
                if (len <= 0)
                    return -1;
            }
            return buffer[ptr++];
        }

        int nextInt() throws IOException {
            int c;
            do {
                c = readByte();
            } while (c <= ' ' && c != -1);
            boolean neg = false;
            if (c == '-') {
                neg = true;
                c = readByte();
            }
            int val = 0;
            while (c > ' ' && c != -1) {
                val = val * 10 + (c - '0');
                c = readByte();
            }
            return neg ? -val : val;
        }
    }

}

===============================================

文件: Code07_GivenTree2.java
===============================================
package class175;

// 给你一棵树问题 - 分块算法优化动态规划 (C++版本的Java注释版)
// 题目来源: https://www.luogu.com.cn/problem/CF1039D
// 题目来源: https://codeforces.com/problemset/problem/1039/D
// 题目大意: 一共有n个节点，给定n-1条边，所有节点连成一棵树
// 树的路径是指，从端点x到端点y的简单路径，k路径是指，路径的节点数正好为k
// 整棵树希望分解成尽量多的k路径，k路径的节点不能复用，所有k路径不要求包含所有点
// 打印k = 1, 2, 3..n时，k路径有最多有几条
// 约束条件: 1 <= n <= 200000

// 以下是C++版本的实现，逻辑与Java版本完全一致
// 提交时需要将代码转换为C++格式

//#include <bits/stdc++.h>
//
//using namespace std;
//
//const int MAXN = 200001;
//int n, blen;
//int head[MAXN];
//int nxt[MAXN << 1];
//int to[MAXN << 1];
//int cntg = 0;
//
//int fa[MAXN];
//int dfnOrder[MAXN];
//int cntd = 0;
//
//int len[MAXN];
//int max1[MAXN];
//int max2[MAXN];
//
//int ans[MAXN];
//
//void addEdge(int u, int v) {
//    nxt[++cntg] = head[u];
//    to[cntg] = v;
//    head[u] = cntg;
//    nxt[++cntg] = head[v];
//    to[cntg] = u;
//    head[v] = cntg;
//}
//
//void dfs(int u, int f) {
//    fa[u] = f;
//    dfnOrder[++cntd] = u;
//    for (int e = head[u]; e; e = nxt[e]) {
//        if (to[e] != f) {
//            dfs(to[e], u);
//        }
//    }
//}
//
//int query(int k) {
//    int cnt = 0;
//    for (int i = n, cur, father; i >= 1; i--) {
//        cur = dfnOrder[i];
//        father = fa[cur];
//        if (max1[cur] + max2[cur] + 1 >= k) {
//            cnt++;
//            len[cur] = 0;
//        } else {
//            len[cur] = max1[cur] + 1;
//        }
//        if (len[cur] > max1[father]) {
//            max2[father] = max1[father];
//            max1[father] = len[cur];
//        } else if (len[cur] > max2[father]) {
//            max2[father] = len[cur];
//        }
//    }
//    for (int i = 1; i <= n; i++) {
//        len[i] = max1[i] = max2[i] = 0;
//    }
//    return cnt;
//}
//
//int jump(int l, int r, int curAns) {
//    int find = l;
//    while (l <= r) {
//        int mid = (l + r) >> 1;
//        int check = query(mid);
//        if (check < curAns) {
//            r = mid - 1;
//        } else if (check > curAns) {
//            l = mid + 1;
//        } else {
//            find = mid;
//            l = mid + 1;
//        }
//    }
//    return find + 1;
//}
//
//void compute() {
//    for (int i = 1; i <= blen; i++) {
//        ans[i] = query(i);
//    }
//    for (int i = blen + 1; i <= n; i = jump(i, n, ans[i])) {
//        ans[i] = query(i);
//    }
//}
//
//void prepare() {
//    blen = max(1, (int)sqrt(n * log2(n)));
//    fill(ans + 1, ans + n + 1, -1);
//}
//
//int main() {
//    ios::sync_with_stdio(false);
//    cin.tie(nullptr);
//    cin >> n;
//    for (int i = 1, u, v; i < n; i++) {
//        cin >> u >> v;
//        addEdge(u, v);
//    }
//    dfs(1, 0);
//    prepare();
//    compute();
//    for (int i = 1; i <= n; i++) {
//        if (ans[i] == -1) {
//            ans[i] = ans[i - 1];
//        }
//        cout << ans[i] << '\n';
//    }
//    return 0;
//}

===============================================

文件: Code08_SeregaAndFun1.java
===============================================
package class175;

// Serega and Fun问题 - 分块算法实现 (Java版本)
// 题目来源: https://codeforces.com/problemset/problem/455/D
// 题目大意: 给定一个长度为n的数组arr，有q次操作，操作分为两种类型：
// 类型1: l r - 计算区间[l,r]内值为k的元素个数，其中k是该区间内出现次数最多的数字
// 类型2: l r - 将arr[l]移动到位置r
// 约束条件: 
// 1 <= n, q <= 10^5
// 1 <= arr[i] <= n

import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStreamWriter;
import java.io.PrintWriter;
import java.util.ArrayList;
import java.util.LinkedList;

public class Code08_SeregaAndFun1 {

    // 定义最大数组长度
    public static int MAXN = 100001;
    
    // n: 数组长度, q: 操作次数, blen: 块大小
    public static int n, q, blen;
    
    // 使用分块，每个块用LinkedList存储元素
    public static ArrayList<LinkedList<Integer>> blocks = new ArrayList<>();
    
    // 每个块中各个数值的出现次数
    public static ArrayList<int[]> cnt = new ArrayList<>();
    
    // 块的数量
    public static int bcnt;

    /**
     * 重构分块结构
     * 当块的数量远超sqrt(n)时，重新分块以保持效率
     */
    public static void reBuild() {
        // 当块的数量远超sqrt(n)时，重新分块
        if (bcnt > 2 * blen) {
            // 将所有元素收集到一个临时列表中
            ArrayList<Integer> tmp = new ArrayList<>();
            for (int i = 0; i < bcnt; i++) {
                tmp.addAll(blocks.get(i));
            }
            
            // 清空原有的分块结构
            blocks.clear();
            cnt.clear();
            bcnt = 0;
            
            // 重新分块
            for (int i = 0; i < tmp.size(); i++) {
                // 每blen个元素作为一个块
                if (i % blen == 0) {
                    blocks.add(new LinkedList<>());
                    cnt.add(new int[MAXN]);
                    bcnt++;
                }
                // 将元素添加到对应的块中
                int val = tmp.get(i);
                blocks.get(bcnt - 1).add(val);
                cnt.get(bcnt - 1)[val]++;
            }
        }
    }

    /**
     * 查询区间[l,r]内出现最多的数字的出现次数
     * @param l 左边界(1-indexed)
     * @param r 右边界(1-indexed)
     * @return 出现最多的数字的出现次数
     */
    public static int query(int l, int r) {
        // 转换为0-indexed
        l--;
        r--;
        
        // 计算左右边界所在的块
        int lb = l / blen;
        int rb = r / blen;
        int ans = 0;

        // 如果在同一个块内
        if (lb == rb) {
            // 直接遍历计算
            int[] count = new int[MAXN];
            for (int i = l; i <= r; i++) {
                int blockId = i / blen;
                int indexInBlock = i % blen;
                int val = (int) blocks.get(blockId).get(indexInBlock);
                count[val]++;
                ans = Math.max(ans, count[val]);
            }
        } else {
            // 跨多个块
            int[] count = new int[MAXN];
            
            // 处理左端不完整块
            int lEnd = (lb + 1) * blen - 1;
            for (int i = l; i <= lEnd; i++) {
                int blockId = i / blen;
                int indexInBlock = i % blen;
                int val = (int) blocks.get(blockId).get(indexInBlock);
                count[val]++;
                ans = Math.max(ans, count[val]);
            }

            // 处理中间完整块
            for (int i = lb + 1; i <= rb - 1; i++) {
                for (int j = 1; j < MAXN; j++) {
                    count[j] += cnt.get(i)[j];
                    ans = Math.max(ans, count[j]);
                }
            }

            // 处理右端不完整块
            int rStart = rb * blen;
            for (int i = rStart; i <= r; i++) {
                int blockId = i / blen;
                int indexInBlock = i % blen;
                int val = (int) blocks.get(blockId).get(indexInBlock);
                count[val]++;
                ans = Math.max(ans, count[val]);
            }
        }

        return ans;
    }

    /**
     * 将位置l的元素移动到位置r
     * @param l 源位置(1-indexed)
     * @param r 目标位置(1-indexed)
     */
    public static void move(int l, int r) {
        // 转换为0-indexed
        l--;
        r--;
        
        // 计算左右位置所在的块
        int lb = l / blen;
        int rb = r / blen;
        int lIndexInBlock = l % blen;
        
        // 从源块中移除元素
        int val = (int) blocks.get(lb).remove(lIndexInBlock);
        cnt.get(lb)[val]--;
        
        // 计算在新位置的索引
        int newIndexInBlock = r % blen;
        if (lb < rb) {
            // 如果从前面的块移动到后面的块
            newIndexInBlock = newIndexInBlock - (lb + 1) * blen + (lb * blen) + blocks.get(lb).size();
        } else if (lb > rb) {
            // 如果从后面的块移动到前面的块
            newIndexInBlock = newIndexInBlock + (lb * blen) - (rb + 1) * blen;
        }

        // 将元素插入到目标块中
        blocks.get(rb).add(newIndexInBlock, val);
        cnt.get(rb)[val]++;
    }

    /**
     * 初始化分块
     */
    public static void prepare() {
        // 计算块大小，通常选择sqrt(n)
        blen = (int) Math.sqrt(n);
        bcnt = 0;
        blocks.clear();
        cnt.clear();

        // 初始化分块结构
        for (int i = 0; i < n; i++) {
            if (i % blen == 0) {
                blocks.add(new LinkedList<>());
                cnt.add(new int[MAXN]);
                bcnt++;
            }
        }
    }

    public static void main(String[] args) throws Exception {
        FastReader in = new FastReader(System.in);
        PrintWriter out = new PrintWriter(new OutputStreamWriter(System.out));
        
        // 读取数组长度n
        n = in.nextInt();
        
        // 初始化分块
        prepare();

        // 读取初始数组
        for (int i = 0; i < n; i++) {
            int blockId = i / blen;
            int indexInBlock = i % blen;
            int val = in.nextInt();
            blocks.get(blockId).add(val);
            cnt.get(blockId)[val]++;
        }

        // 读取操作次数q
        q = in.nextInt();
        
        // 处理q次操作
        for (int i = 1, op, l, r; i <= q; i++) {
            op = in.nextInt();
            l = in.nextInt();
            r = in.nextInt();
            if (op == 1) {
                // 查询操作
                out.println(query(l, r));
            } else {
                // 移动操作
                move(l, r);
                // 定期重构以保持效率
                if (i % 5000 == 0) {
                    reBuild();
                }
            }
        }
        
        out.flush();
        out.close();
    }

    // 高效读取工具类，用于加快输入输出速度
    static class FastReader {
        private final byte[] buffer = new byte[1 << 16];
        private int ptr = 0, len = 0;
        private final InputStream in;

        FastReader(InputStream in) {
            this.in = in;
        }

        private int readByte() throws IOException {
            if (ptr >= len) {
                len = in.read(buffer);
                ptr = 0;
                if (len <= 0)
                    return -1;
            }
            return buffer[ptr++];
        }

        int nextInt() throws IOException {
            int c;
            do {
                c = readByte();
            } while (c <= ' ' && c != -1);
            boolean neg = false;
            if (c == '-') {
                neg = true;
                c = readByte();
            }
            int val = 0;
            while (c > ' ' && c != -1) {
                val = val * 10 + (c - '0');
                c = readByte();
            }
            return neg ? -val : val;
        }
    }
}

===============================================

文件: Code08_SeregaAndFun2.cpp
===============================================
// Serega and Fun问题 - 分块算法实现 (C++版本)
// 题目来源: https://codeforces.com/problemset/problem/455/D
// 题目大意: 给定一个长度为n的数组arr，有q次操作，操作分为两种类型：
// 类型1: l r - 计算区间[l,r]内值为k的元素个数，其中k是该区间内出现次数最多的数字
// 类型2: l r - 将arr[l]移动到位置r
// 约束条件: 
// 1 <= n, q <= 10^5
// 1 <= arr[i] <= n

#include <iostream>
#include <vector>
#include <deque>
#include <cmath>
#include <algorithm>
using namespace std;

const int MAXN = 100005;
int n, q;
int blen; // 块大小
vector<deque<int>> blocks; // 每个块存储元素
vector<vector<int>> cnt; // 每个块中各个数值的出现次数
int bcnt; // 块的数量

/**
 * 重构分块结构
 * 当块的数量远超sqrt(n)时，重新分块以保持效率
 */
void reBuild() {
    // 当块的数量远超sqrt(n)时，重新分块
    if (bcnt > 2 * blen) {
        // 将所有元素收集到一个临时向量中
        vector<int> tmp;
        for (int i = 0; i < bcnt; i++) {
            for (int x : blocks[i]) {
                tmp.push_back(x);
            }
        }
        
        // 清空原有的分块结构
        blocks.clear();
        cnt.clear();
        bcnt = 0;
        
        // 重新分块
        for (int i = 0; i < (int)tmp.size(); i++) {
            // 每blen个元素作为一个块
            if (i % blen == 0) {
                blocks.push_back(deque<int>());
                cnt.push_back(vector<int>(MAXN, 0));
                bcnt++;
            }
            // 将元素添加到对应的块中
            int val = tmp[i];
            blocks[bcnt - 1].push_back(val);
            cnt[bcnt - 1][val]++;
        }
    }
}

/**
 * 查询区间[l,r]内出现最多的数字的出现次数
 * @param l 左边界(1-indexed)
 * @param r 右边界(1-indexed)
 * @return 出现最多的数字的出现次数
 */
int query(int l, int r) {
    // 转换为0-indexed
    l--;
    r--;
    
    // 计算左右边界所在的块
    int lb = l / blen;
    int rb = r / blen;
    int ans = 0;

    // 如果在同一个块内
    if (lb == rb) {
        // 直接遍历计算
        vector<int> count(MAXN, 0);
        for (int i = l; i <= r; i++) {
            int blockId = i / blen;
            int indexInBlock = i % blen;
            int val = blocks[blockId][indexInBlock];
            count[val]++;
            ans = max(ans, count[val]);
        }
    } else {
        // 跨多个块
        vector<int> count(MAXN, 0);
        
        // 处理左端不完整块
        int lEnd = (lb + 1) * blen - 1;
        for (int i = l; i <= min(lEnd, n - 1); i++) {
            int blockId = i / blen;
            int indexInBlock = i % blen;
            int val = blocks[blockId][indexInBlock];
            count[val]++;
            ans = max(ans, count[val]);
        }

        // 处理中间完整块
        for (int i = lb + 1; i <= rb - 1; i++) {
            for (int j = 1; j < MAXN; j++) {
                count[j] += cnt[i][j];
                ans = max(ans, count[j]);
            }
        }

        // 处理右端不完整块
        int rStart = rb * blen;
        for (int i = rStart; i <= r; i++) {
            int blockId = i / blen;
            int indexInBlock = i % blen;
            int val = blocks[blockId][indexInBlock];
            count[val]++;
            ans = max(ans, count[val]);
        }
    }

    return ans;
}

/**
 * 将位置l的元素移动到位置r
 * @param l 源位置(1-indexed)
 * @param r 目标位置(1-indexed)
 */
void move(int l, int r) {
    // 转换为0-indexed
    l--;
    r--;
    
    // 计算左右位置所在的块
    int lb = l / blen;
    int rb = r / blen;
    int lIndexInBlock = l % blen;
    
    // 从源块中移除元素
    int val = blocks[lb][lIndexInBlock];
    blocks[lb].erase(blocks[lb].begin() + lIndexInBlock);
    cnt[lb][val]--;
    
    // 计算在新位置的索引
    int newIndexInBlock = r % blen;
    if (lb < rb) {
        // 如果从前面的块移动到后面的块
        newIndexInBlock = newIndexInBlock - (lb + 1) * blen + (lb * blen) + blocks[lb].size();
    } else if (lb > rb) {
        // 如果从后面的块移动到前面的块
        newIndexInBlock = newIndexInBlock + (lb * blen) - (rb + 1) * blen;
    }

    // 将元素插入到目标块中
    blocks[rb].insert(blocks[rb].begin() + newIndexInBlock, val);
    cnt[rb][val]++;
}

/**
 * 初始化分块
 */
void prepare() {
    // 计算块大小，通常选择sqrt(n)
    blen = sqrt(n);
    bcnt = 0;
    blocks.clear();
    cnt.clear();

    // 初始化分块结构
    for (int i = 0; i < n; i++) {
        if (i % blen == 0) {
            blocks.push_back(deque<int>());
            cnt.push_back(vector<int>(MAXN, 0));
            bcnt++;
        }
    }
}

int main() {
    // 优化输入输出速度
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    
    // 读取数组长度n
    cin >> n;
    
    // 初始化分块
    prepare();

    // 读取初始数组
    for (int i = 0; i < n; i++) {
        int blockId = i / blen;
        int val;
        cin >> val;
        blocks[blockId].push_back(val);
        cnt[blockId][val]++;
    }

    // 读取操作次数q
    cin >> q;
    
    // 处理q次操作
    for (int i = 1, op, l, r; i <= q; i++) {
        cin >> op >> l >> r;
        if (op == 1) {
            // 查询操作
            cout << query(l, r) << "\n";
        } else {
            // 移动操作
            move(l, r);
            // 定期重构以保持效率
            if (i % 5000 == 0) {
                reBuild();
            }
        }
    }

    return 0;
}

===============================================

文件: Code08_SeregaAndFun3.py
===============================================
# Serega and Fun问题 - 分块算法实现 (Python版本)
# 题目来源: https://codeforces.com/problemset/problem/455/D
# 题目大意: 给定一个长度为n的数组arr，有q次操作，操作分为两种类型：
# 类型1: l r - 计算区间[l,r]内值为k的元素个数，其中k是该区间内出现次数最多的数字
# 类型2: l r - 将arr[l]移动到位置r
# 约束条件: 
# 1 <= n, q <= 10^5
# 1 <= arr[i] <= n

import math
from collections import deque

MAXN = 100005
n, q = 0, 0
blen = 0  # 块大小
blocks = []  # 每个块存储元素
cnt = []  # 每个块中各个数值的出现次数
bcnt = 0  # 块的数量


def reBuild():
    """
    重构分块结构
    当块的数量远超sqrt(n)时，重新分块以保持效率
    """
    global blocks, cnt, bcnt
    # 当块的数量远超sqrt(n)时，重新分块
    if bcnt > 2 * blen:
        # 将所有元素收集到一个临时列表中
        tmp = []
        for i in range(bcnt):
            tmp.extend(blocks[i])
        
        # 清空原有的分块结构
        blocks = []
        cnt = []
        bcnt = 0
        
        # 重新分块
        for i in range(len(tmp)):
            # 每blen个元素作为一个块
            if i % blen == 0:
                blocks.append(deque())
                cnt.append([0] * MAXN)
                bcnt += 1
            # 将元素添加到对应的块中
            val = tmp[i]
            blocks[bcnt - 1].append(val)
            cnt[bcnt - 1][val] += 1


def query(l, r):
    """
    查询区间[l,r]内出现最多的数字的出现次数
    参数:
        l: 左边界(1-indexed)
        r: 右边界(1-indexed)
    返回:
        出现最多的数字的出现次数
    """
    # 转换为0-indexed
    l -= 1
    r -= 1
    
    # 计算左右边界所在的块
    lb = l // blen
    rb = r // blen
    ans = 0

    # 如果在同一个块内
    if lb == rb:
        # 直接遍历计算
        count = [0] * MAXN
        for i in range(l, r + 1):
            blockId = i // blen
            indexInBlock = i % blen
            val = blocks[blockId][indexInBlock]
            count[val] += 1
            ans = max(ans, count[val])
    else:
        # 跨多个块
        count = [0] * MAXN
        
        # 处理左端不完整块
        lEnd = (lb + 1) * blen - 1
        for i in range(l, min(lEnd + 1, n)):
            blockId = i // blen
            indexInBlock = i % blen
            val = blocks[blockId][indexInBlock]
            count[val] += 1
            ans = max(ans, count[val])

        # 处理中间完整块
        for i in range(lb + 1, rb):
            for j in range(1, MAXN):
                count[j] += cnt[i][j]
                ans = max(ans, count[j])

        # 处理右端不完整块
        rStart = rb * blen
        for i in range(rStart, r + 1):
            blockId = i // blen
            indexInBlock = i % blen
            val = blocks[blockId][indexInBlock]
            count[val] += 1
            ans = max(ans, count[val])

    return ans


def move(l, r):
    """
    将位置l的元素移动到位置r
    参数:
        l: 源位置(1-indexed)
        r: 目标位置(1-indexed)
    """
    # 转换为0-indexed
    l -= 1
    r -= 1
    
    # 计算左右位置所在的块
    lb = l // blen
    rb = r // blen
    lIndexInBlock = l % blen
    
    # 从源块中移除元素
    val = blocks[lb][lIndexInBlock]
    del blocks[lb][lIndexInBlock]
    cnt[lb][val] -= 1

    # 计算在新位置的索引
    newIndexInBlock = r % blen
    if lb < rb:
        # 如果从前面的块移动到后面的块
        newIndexInBlock = newIndexInBlock - (lb + 1) * blen + (lb * blen) + len(blocks[lb])
    elif lb > rb:
        # 如果从后面的块移动到前面的块
        newIndexInBlock = newIndexInBlock + (lb * blen) - (rb + 1) * blen

    # 将元素插入到目标块中
    blocks[rb].insert(newIndexInBlock, val)
    cnt[rb][val] += 1


def prepare():
    """
    初始化分块
    """
    global blen, blocks, cnt, bcnt
    # 计算块大小，通常选择sqrt(n)
    blen = int(math.sqrt(n))
    bcnt = 0
    blocks = []
    cnt = []

    # 初始化分块结构
    for i in range(n):
        if i % blen == 0:
            blocks.append(deque())
            cnt.append([0] * MAXN)
            bcnt += 1


def main():
    global n, q
    # 读取数组长度n
    n = int(input())
    
    # 初始化分块
    prepare()

    # 读取初始数组
    arr = list(map(int, input().split()))
    for i in range(n):
        blockId = i // blen
        val = arr[i]
        blocks[blockId].append(val)
        cnt[blockId][val] += 1

    # 读取操作次数q
    q = int(input())
    
    # 处理q次操作
    for i in range(1, q + 1):
        op, l, r = map(int, input().split())
        if op == 1:
            # 查询操作
            print(query(l, r))
        else:
            # 移动操作
            move(l, r)
            # 定期重构以保持效率
            if i % 5000 == 0:
                reBuild()


if __name__ == "__main__":
    main()

===============================================

文件: Code09_LittleElephantAndArray.cpp
===============================================
// Little Elephant and Array问题 - Mo算法实现 (C++版本)
// 题目来源: https://codeforces.com/problemset/problem/220/B
// 题目大意: 给定一个长度为n的数组arr，有m次查询
// 每次查询[l,r]区间内，有多少个数x满足在该区间内x恰好出现了x次
// 约束条件: 
// 1 <= n, m <= 10^5
// 1 <= arr[i] <= 10^9

#include <cstdio>
#include <cmath>
#include <algorithm>
#include <unordered_map>
using namespace std;

const int MAXN = 100005;
int n, m, blen;
int arr[MAXN];
int ans[MAXN];
unordered_map<int, int> count;

// 查询结构
struct Query {
    int l, r, id;
    
    Query() {}
    
    Query(int _l, int _r, int _id) : l(_l), r(_r), id(_id) {}
};

Query queries[MAXN];

// 比较函数，用于Mo算法排序
bool cmp(const Query& a, const Query& b) {
    int blockA = (a.l - 1) / blen;
    int blockB = (b.l - 1) / blen;
    if (blockA != blockB) {
        return blockA < blockB;
    }
    return a.r < b.r;
}

/**
 * 添加元素到当前窗口
 * @param pos 位置
 */
void add(int pos) {
    int val = arr[pos];
    int oldCount = count[val];
    
    // 如果之前恰好出现了val次，现在要减少一个计数
    if (oldCount == val) {
        ans[0]--;
    }
    
    // 更新计数
    count[val] = oldCount + 1;
    
    // 如果现在恰好出现了val次，增加一个计数
    if (count[val] == val) {
        ans[0]++;
    }
}

/**
 * 从当前窗口移除元素
 * @param pos 位置
 */
void remove(int pos) {
    int val = arr[pos];
    int oldCount = count[val];
    
    // 如果之前恰好出现了val次，现在要减少一个计数
    if (oldCount == val) {
        ans[0]--;
    }
    
    // 更新计数
    count[val] = oldCount - 1;
    
    // 如果现在恰好出现了val次，增加一个计数
    if (count[val] == val) {
        ans[0]++;
    }
}

int main() {
    // 读取数组长度n和查询次数m
    scanf("%d%d", &n, &m);
    
    // 读取初始数组
    for (int i = 1; i <= n; i++) {
        scanf("%d", &arr[i]);
    }

    // 读取所有查询
    for (int i = 1; i <= m; i++) {
        int l, r;
        scanf("%d%d", &l, &r);
        queries[i] = Query(l, r, i);
    }

    // 使用Mo算法进行排序
    // 按照左端点所在的块排序，块内按照右端点排序
    blen = (int)sqrt(n);
    sort(queries + 1, queries + m + 1, cmp);

    // Mo算法处理
    int curL = 1, curR = 0;
    for (int i = 1; i <= m; i++) {
        int l = queries[i].l;
        int r = queries[i].r;
        int id = queries[i].id;

        // 扩展右边界
        while (curR < r) {
            curR++;
            add(curR);
        }

        // 收缩左边界
        while (curL > l) {
            curL--;
            add(curL);
        }

        // 收缩右边界
        while (curR > r) {
            remove(curR);
            curR--;
        }

        // 扩展左边界
        while (curL < l) {
            remove(curL);
            curL++;
        }

        // 记录当前查询的答案
        ans[id] = ans[0];
    }

    // 输出所有查询的结果
    for (int i = 1; i <= m; i++) {
        printf("%d\n", ans[i]);
    }

    return 0;
}

===============================================

文件: Code09_LittleElephantAndArray1.java
===============================================
package class175;

// Little Elephant and Array问题 - Mo算法实现 (Java版本)
// 题目来源: https://codeforces.com/problemset/problem/220/B
// 题目大意: 给定一个长度为n的数组arr，有m次查询
// 每次查询[l,r]区间内，有多少个数x满足在该区间内x恰好出现了x次
// 约束条件: 
// 1 <= n, m <= 10^5
// 1 <= arr[i] <= 10^9

import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStreamWriter;
import java.io.PrintWriter;
import java.util.*;

public class Code09_LittleElephantAndArray1 {

    // 定义最大数组长度
    public static int MAXN = 100001;
    
    // n: 数组长度, m: 查询次数, blen: 块大小
    public static int n, m, blen;
    
    // arr: 原始数组
    public static int[] arr = new int[MAXN];
    
    // ans: 存储每个查询的答案
    public static int[] ans = new int[MAXN];
    
    // count: 记录当前窗口中每个数字的出现次数
    public static HashMap<Integer, Integer> count = new HashMap<>();

    // 查询结构
    static class Query {
        int l, r, id;

        Query(int l, int r, int id) {
            this.l = l;
            this.r = r;
            this.id = id;
        }
    }

    // queries: 存储所有查询
    public static Query[] queries = new Query[MAXN];

    /**
     * 添加元素到当前窗口
     * @param pos 位置
     */
    public static void add(int pos) {
        int val = arr[pos];
        int oldCount = count.getOrDefault(val, 0);
        
        // 如果之前恰好出现了val次，现在要减少一个计数
        if (oldCount == val) {
            ans[0]--;
        }
        
        // 更新计数
        count.put(val, oldCount + 1);
        
        // 如果现在恰好出现了val次，增加一个计数
        if (count.get(val) == val) {
            ans[0]++;
        }
    }

    /**
     * 从当前窗口移除元素
     * @param pos 位置
     */
    public static void remove(int pos) {
        int val = arr[pos];
        int oldCount = count.get(val);
        
        // 如果之前恰好出现了val次，现在要减少一个计数
        if (oldCount == val) {
            ans[0]--;
        }
        
        // 更新计数
        count.put(val, oldCount - 1);
        
        // 如果现在恰好出现了val次，增加一个计数
        if (count.get(val) == val) {
            ans[0]++;
        }
    }

    public static void main(String[] args) throws Exception {
        FastReader in = new FastReader(System.in);
        PrintWriter out = new PrintWriter(new OutputStreamWriter(System.out));
        
        // 读取数组长度n和查询次数m
        n = in.nextInt();
        m = in.nextInt();
        
        // 读取初始数组
        for (int i = 1; i <= n; i++) {
            arr[i] = in.nextInt();
        }

        // 读取所有查询
        for (int i = 1; i <= m; i++) {
            int l = in.nextInt();
            int r = in.nextInt();
            queries[i] = new Query(l, r, i);
        }

        // 使用Mo算法进行排序
        // 按照左端点所在的块排序，块内按照右端点排序
        blen = (int) Math.sqrt(n);
        Arrays.sort(queries, 1, m + 1, (a, b) -> {
            int blockA = (a.l - 1) / blen;
            int blockB = (b.l - 1) / blen;
            if (blockA != blockB) {
                return blockA - blockB;
            }
            return a.r - b.r;
        });

        // Mo算法处理
        int curL = 1, curR = 0;
        for (int i = 1; i <= m; i++) {
            int l = queries[i].l;
            int r = queries[i].r;
            int id = queries[i].id;

            // 扩展右边界
            while (curR < r) {
                curR++;
                add(curR);
            }

            // 收缩左边界
            while (curL > l) {
                curL--;
                add(curL);
            }

            // 收缩右边界
            while (curR > r) {
                remove(curR);
                curR--;
            }

            // 扩展左边界
            while (curL < l) {
                remove(curL);
                curL++;
            }

            // 记录当前查询的答案
            ans[id] = ans[0];
        }

        // 输出所有查询的结果
        for (int i = 1; i <= m; i++) {
            out.println(ans[i]);
        }

        out.flush();
        out.close();
    }

    // 高效读取工具类，用于加快输入输出速度
    static class FastReader {
        private final byte[] buffer = new byte[1 << 16];
        private int ptr = 0, len = 0;
        private final InputStream in;

        FastReader(InputStream in) {
            this.in = in;
        }

        private int readByte() throws IOException {
            if (ptr >= len) {
                len = in.read(buffer);
                ptr = 0;
                if (len <= 0)
                    return -1;
            }
            return buffer[ptr++];
        }

        int nextInt() throws IOException {
            int c;
            do {
                c = readByte();
            } while (c <= ' ' && c != -1);
            boolean neg = false;
            if (c == '-') {
                neg = true;
                c = readByte();
            }
            int val = 0;
            while (c > ' ' && c != -1) {
                val = val * 10 + (c - '0');
                c = readByte();
            }
            return neg ? -val : val;
        }
    }
}

===============================================

文件: Code09_LittleElephantAndArray3.py
===============================================
# Little Elephant and Array问题 - Mo算法实现 (Python版本)
# 题目来源: https://codeforces.com/problemset/problem/220/B
# 题目大意: 给定一个长度为n的数组arr，有m次查询
# 每次查询[l,r]区间内，有多少个数x满足在该区间内x恰好出现了x次
# 约束条件: 
# 1 <= n, m <= 10^5
# 1 <= arr[i] <= 10^9

import math

# 定义最大数组长度
MAXN = 100005

# 全局变量
n, m, blen = 0, 0, 0

# arr: 原始数组
arr = [0] * MAXN

# ans: 存储每个查询的答案
ans = [0] * MAXN

# count: 记录当前窗口中每个数字的出现次数
count = {}

# 查询结构
class Query:
    def __init__(self, l, r, id):
        self.l = l
        self.r = r
        self.id = id

# queries: 存储所有查询
queries = []  # 使用列表存储查询

def add(pos):
    """
    添加元素到当前窗口
    参数:
        pos: 位置
    """
    val = arr[pos]
    oldCount = count.get(val, 0)
    
    # 如果之前恰好出现了val次，现在要减少一个计数
    if oldCount == val:
        ans[0] -= 1
    
    # 更新计数
    count[val] = oldCount + 1
    
    # 如果现在恰好出现了val次，增加一个计数
    if count[val] == val:
        ans[0] += 1

def remove(pos):
    """
    从当前窗口移除元素
    参数:
        pos: 位置
    """
    val = arr[pos]
    oldCount = count[val]
    
    # 如果之前恰好出现了val次，现在要减少一个计数
    if oldCount == val:
        ans[0] -= 1
    
    # 更新计数
    count[val] = oldCount - 1
    
    # 如果现在恰好出现了val次，增加一个计数
    if count[val] == val:
        ans[0] += 1

def main():
    global n, m, blen
    
    # 读取数组长度n和查询次数m
    n, m = map(int, input().split())
    
    # 读取初始数组
    temp = list(map(int, input().split()))
    for i in range(1, n + 1):
        arr[i] = temp[i - 1]

    # 读取所有查询
    for i in range(1, m + 1):
        l, r = map(int, input().split())
        queries.append(Query(l, r, i))

    # 使用Mo算法进行排序
    # 按照左端点所在的块排序，块内按照右端点排序
    blen = int(math.sqrt(n))
    
    def compare(a):
        blockA = (a.l - 1) // blen
        return (blockA, a.r)
    
    queries.sort(key=compare)

    # Mo算法处理
    curL, curR = 1, 0
    for i in range(m):
        l = queries[i].l
        r = queries[i].r
        id = queries[i].id

        # 扩展右边界
        while curR < r:
            curR += 1
            add(curR)

        # 收缩左边界
        while curL > l:
            curL -= 1
            add(curL)

        # 收缩右边界
        while curR > r:
            remove(curR)
            curR -= 1

        # 扩展左边界
        while curL < l:
            remove(curL)
            curL += 1

        # 记录当前查询的答案
        ans[id] = ans[0]

    # 输出所有查询的结果
    for i in range(1, m + 1):
        print(ans[i])

if __name__ == "__main__":
    main()

===============================================

文件: Code10_DQuery.cpp
===============================================
// D-query问题 - Mo算法实现 (C++版本)
// 题目来源: https://www.spoj.com/problems/DQUERY/
// 题目大意: 给定一个长度为n的数组arr，有q次查询，每次查询[l,r]区间内不同数字的个数
// 约束条件: 1 <= n, q <= 2*10^5, 1 <= arr[i] <= 10^6
// 解法: Mo算法（离线分块）
// 时间复杂度: O((n + q) * sqrt(n))
// 空间复杂度: O(n + V), 其中V为值域大小(10^6)
// 是否最优解: 是，Mo算法是解决此类区间查询问题的经典方法

#include <iostream>
#include <algorithm>
#include <cmath>
using namespace std;

const int MAXN = 200001;
const int MAXV = 1000001;
int n, q, blen;
int arr[MAXN];
int ans[MAXN];
int count[MAXV]; // 计数数组
int curAns = 0; // 当前答案

// 查询结构
struct Query {
    int l, r, id;
    
    bool operator<(const Query& other) const {
        int blockA = (l - 1) / blen;
        int blockB = (other.l - 1) / blen;
        if (blockA != blockB) {
            return blockA < blockB;
        }
        return r < other.r;
    }
};

Query queries[MAXN];

/**
 * 添加元素到当前窗口
 * 时间复杂度: O(1)
 * 设计思路: 当向窗口中添加一个元素时，需要更新该元素的计数和不同数字的总数
 * 如果该元素之前在窗口中出现次数为0，说明是新数字，不同数字总数加1
 * @param pos 位置
 */
void add(int pos) {
    // 如果之前该数字出现次数为0，说明是新数字
    if (count[arr[pos]] == 0) {
        curAns++;
    }
    count[arr[pos]]++;
}

/**
 * 从当前窗口移除元素
 * 时间复杂度: O(1)
 * 设计思路: 当从窗口中移除一个元素时，需要更新该元素的计数和不同数字的总数
 * 如果移除后该元素在窗口中出现次数为0，说明少了一个不同数字，不同数字总数减1
 * @param pos 位置
 */
void remove(int pos) {
    count[arr[pos]]--;
    // 如果移除后该数字出现次数为0，说明少了一个不同数字
    if (count[arr[pos]] == 0) {
        curAns--;
    }
}

int main() {
    // 优化输入输出速度
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    
    // 读取数组长度n
    cin >> n;
    
    // 读取初始数组
    for (int i = 1; i <= n; i++) {
        cin >> arr[i];
    }

    // 读取查询次数q
    cin >> q;
    
    // 读取所有查询
    for (int i = 1; i <= q; i++) {
        cin >> queries[i].l >> queries[i].r;
        queries[i].id = i;
    }

    // 使用Mo算法进行排序
    // 块大小选择: sqrt(n)，这是经过理论分析得出的最优块大小
    // 时间复杂度: O(q * log(q))，主要是排序的复杂度
    // 排序策略: 按照左端点所在的块编号排序，块内按右端点排序
    // 这样可以最小化指针移动的次数，从而优化整体时间复杂度
    blen = (int)sqrt((double)n);
    sort(queries + 1, queries + q + 1);

    // Mo算法处理
    int curL = 1, curR = 0;
    for (int i = 1; i <= q; i++) {
        int l = queries[i].l;
        int r = queries[i].r;
        int id = queries[i].id;

        // 扩展右边界
        while (curR < r) {
            curR++;
            add(curR);
        }

        // 收缩左边界
        while (curL > l) {
            curL--;
            add(curL);
        }

        // 收缩右边界
        while (curR > r) {
            remove(curR);
            curR--;
        }

        // 扩展左边界
        while (curL < l) {
            remove(curL);
            curL++;
        }

        // 记录当前查询的答案
        ans[id] = curAns;
    }

    // 输出所有查询的结果
    for (int i = 1; i <= q; i++) {
        cout << ans[i] << "\n";
    }
    
    return 0;
}

// 算法说明：
// 1. 使用Mo算法（离线分块）解决区间不同数字计数问题
// 2. 时间复杂度：O((n + q) * sqrt(n))
// 3. 空间复杂度：O(n + V)，其中V为值域大小
// 4. 核心思想：通过分块排序查询，减少元素添加/删除操作次数
//
// 详细分析：
// Mo算法是一种离线算法，通过巧妙地排序查询来减少重复计算
// 块大小选择sqrt(n)是经过理论分析的最优选择
// 排序策略是先按左端点所在块排序，再按右端点排序
// 这样可以保证相邻查询之间的指针移动次数最少

===============================================

文件: Code10_DQuery1.java
===============================================
package class175;

// D-query问题 - Mo算法实现 (Java版本)
// 题目来源: https://www.spoj.com/problems/DQUERY/
// 题目大意: 给定一个长度为n的数组arr，有q次查询，每次查询[l,r]区间内不同数字的个数
// 约束条件: 1 <= n, q <= 2*10^5, 1 <= arr[i] <= 10^6
// 解法: Mo算法（离线分块）
// 时间复杂度: O((n + q) * sqrt(n))
// 空间复杂度: O(n + V), 其中V为值域大小(10^6)
// 是否最优解: 是，Mo算法是解决此类区间查询问题的经典方法

import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStreamWriter;
import java.io.PrintWriter;
import java.util.Arrays;

public class Code10_DQuery1 {

    // 定义最大数组长度和值域大小
    public static int MAXN = 200001;
    public static int MAXV = 1000001;
    
    // n: 数组长度, q: 查询次数, blen: 块大小
    public static int n, q, blen;
    
    // arr: 原始数组
    public static int[] arr = new int[MAXN];
    
    // ans: 存储每个查询的答案
    public static int[] ans = new int[MAXN];
    
    // count: 计数数组，记录当前窗口中每个数字的出现次数
    public static int[] count = new int[MAXV];
    
    // curAns: 当前窗口中不同数字的个数
    public static int curAns = 0;

    // 查询结构
    static class Query {
        int l, r, id;

        Query(int l, int r, int id) {
            this.l = l;
            this.r = r;
            this.id = id;
        }
    }

    // queries: 存储所有查询
    public static Query[] queries = new Query[MAXN];

    /**
     * 添加元素到当前窗口
     * 时间复杂度: O(1)
     * 设计思路: 当向窗口中添加一个元素时，需要更新该元素的计数和不同数字的总数
     * 如果该元素之前在窗口中出现次数为0，说明是新数字，不同数字总数加1
     * @param pos 位置
     */
    public static void add(int pos) {
        // 如果之前该数字出现次数为0，说明是新数字
        if (count[arr[pos]] == 0) {
            curAns++;
        }
        count[arr[pos]]++;
    }

    /**
     * 从当前窗口移除元素
     * 时间复杂度: O(1)
     * 设计思路: 当从窗口中移除一个元素时，需要更新该元素的计数和不同数字的总数
     * 如果移除后该元素在窗口中出现次数为0，说明少了一个不同数字，不同数字总数减1
     * @param pos 位置
     */
    public static void remove(int pos) {
        count[arr[pos]]--;
        // 如果移除后该数字出现次数为0，说明少了一个不同数字
        if (count[arr[pos]] == 0) {
            curAns--;
        }
    }

    public static void main(String[] args) throws IOException {
        FastReader in = new FastReader(System.in);
        PrintWriter out = new PrintWriter(new OutputStreamWriter(System.out));
        
        // 读取数组长度n
        n = in.nextInt();
        
        // 读取初始数组
        for (int i = 1; i <= n; i++) {
            arr[i] = in.nextInt();
        }

        // 读取查询次数q
        q = in.nextInt();
        
        // 读取所有查询
        for (int i = 1; i <= q; i++) {
            int l = in.nextInt();
            int r = in.nextInt();
            queries[i] = new Query(l, r, i);
        }

        // 使用Mo算法进行排序
        // 块大小选择: sqrt(n)，这是经过理论分析得出的最优块大小
        // 时间复杂度: O(q * log(q))，主要是排序的复杂度
        // 排序策略: 按照左端点所在的块编号排序，块内按右端点排序
        // 这样可以最小化指针移动的次数，从而优化整体时间复杂度
        blen = (int) Math.sqrt(n);
        
        Arrays.sort(queries, 1, q + 1, (a, b) -> {
            int blockA = (a.l - 1) / blen;
            int blockB = (b.l - 1) / blen;
            if (blockA != blockB) {
                return blockA - blockB;
            }
            return a.r - b.r;
        });

        // Mo算法处理
        int curL = 1, curR = 0;
        for (int i = 1; i <= q; i++) {
            int l = queries[i].l;
            int r = queries[i].r;
            int id = queries[i].id;

            // 扩展右边界
            while (curR < r) {
                curR++;
                add(curR);
            }

            // 收缩左边界
            while (curL > l) {
                curL--;
                add(curL);
            }

            // 收缩右边界
            while (curR > r) {
                remove(curR);
                curR--;
            }

            // 扩展左边界
            while (curL < l) {
                remove(curL);
                curL++;
            }

            // 记录当前查询的答案
            ans[id] = curAns;
        }

        // 输出所有查询的结果
        for (int i = 1; i <= q; i++) {
            out.println(ans[i]);
        }
        
        out.flush();
        out.close();
    }

    // 高效读取工具类，用于加快输入输出速度
    static class FastReader {
        private final byte[] buffer = new byte[1 << 16];
        private int ptr = 0, len = 0;
        private final InputStream in;

        FastReader(InputStream in) {
            this.in = in;
        }

        private int readByte() throws IOException {
            if (ptr >= len) {
                len = in.read(buffer);
                ptr = 0;
                if (len <= 0)
                    return -1;
            }
            return buffer[ptr++];
        }

        public int nextInt() throws IOException {
            int c;
            do {
                c = readByte();
            } while (c <= ' ' && c != -1);
            boolean neg = false;
            if (c == '-') {
                neg = true;
                c = readByte();
            }
            int val = 0;
            while (c > ' ' && c != -1) {
                val = val * 10 + (c - '0');
                c = readByte();
            }
            return neg ? -val : val;
        }
    }
}

===============================================

文件: Code10_DQuery2.cpp
===============================================
// D-query问题 - Mo算法实现 (C++版本)
// 题目来源: https://www.spoj.com/problems/DQUERY/
// 题目大意: 给定一个长度为n的数组arr，有q次查询，每次查询[l,r]区间内不同数字的个数
// 约束条件: 1 <= n, q <= 2*10^5, 1 <= arr[i] <= 10^6
// 解法: Mo算法（离线分块）
// 时间复杂度: O((n + q) * sqrt(n))
// 空间复杂度: O(n + V), 其中V为值域大小(10^6)
// 是否最优解: 是，Mo算法是解决此类区间查询问题的经典方法

#include <cstdio>
#include <algorithm>
#include <cmath>
using namespace std;

const int MAXN = 200001;
const int MAXV = 1000001;
int n, q, blen;
int arr[MAXN];
int ans[MAXN];
int count[MAXV]; // 计数数组
int curAns = 0; // 当前答案

// 查询结构
struct Query {
    int l, r, id;
    
    bool operator<(const Query& other) const {
        int blockA = (l - 1) / blen;
        int blockB = (other.l - 1) / blen;
        if (blockA != blockB) {
            return blockA < blockB;
        }
        return r < other.r;
    }
};

Query queries[MAXN];

/**
 * 添加元素到当前窗口
 * 时间复杂度: O(1)
 * 设计思路: 当向窗口中添加一个元素时，需要更新该元素的计数和不同数字的总数
 * 如果该元素之前在窗口中出现次数为0，说明是新数字，不同数字总数加1
 * @param pos 位置
 */
void add(int pos) {
    // 如果之前该数字出现次数为0，说明是新数字
    if (count[arr[pos]] == 0) {
        curAns++;
    }
    count[arr[pos]]++;
}

/**
 * 从当前窗口移除元素
 * 时间复杂度: O(1)
 * 设计思路: 当从窗口中移除一个元素时，需要更新该元素的计数和不同数字的总数
 * 如果移除后该元素在窗口中出现次数为0，说明少了一个不同数字，不同数字总数减1
 * @param pos 位置
 */
void remove(int pos) {
    count[arr[pos]]--;
    // 如果移除后该数字出现次数为0，说明少了一个不同数字
    if (count[arr[pos]] == 0) {
        curAns--;
    }
}

int main() {
    // 读取数组长度n
    scanf("%d", &n);
    
    // 读取初始数组
    for (int i = 1; i <= n; i++) {
        scanf("%d", &arr[i]);
    }

    // 读取查询次数q
    scanf("%d", &q);
    
    // 读取所有查询
    for (int i = 1; i <= q; i++) {
        scanf("%d%d", &queries[i].l, &queries[i].r);
        queries[i].id = i;
    }

    // 使用Mo算法进行排序
    // 块大小选择: sqrt(n)，这是经过理论分析得出的最优块大小
    // 时间复杂度: O(q * log(q))，主要是排序的复杂度
    // 排序策略: 按照左端点所在的块编号排序，块内按右端点排序
    // 这样可以最小化指针移动的次数，从而优化整体时间复杂度
    blen = (int)sqrt((double)n);
    sort(queries + 1, queries + q + 1);

    // Mo算法处理
    int curL = 1, curR = 0;
    for (int i = 1; i <= q; i++) {
        int l = queries[i].l;
        int r = queries[i].r;
        int id = queries[i].id;

        // 扩展右边界
        while (curR < r) {
            curR++;
            add(curR);
        }

        // 收缩左边界
        while (curL > l) {
            curL--;
            add(curL);
        }

        // 收缩右边界
        while (curR > r) {
            remove(curR);
            curR--;
        }

        // 扩展左边界
        while (curL < l) {
            remove(curL);
            curL++;
        }

        // 记录当前查询的答案
        ans[id] = curAns;
    }

    // 输出所有查询的结果
    for (int i = 1; i <= q; i++) {
        printf("%d\n", ans[i]);
    }
    
    return 0;
}

// 算法说明：
// 1. 使用Mo算法（离线分块）解决区间不同数字计数问题
// 2. 时间复杂度：O((n + q) * sqrt(n))
// 3. 空间复杂度：O(n + V)，其中V为值域大小
// 4. 核心思想：通过分块排序查询，减少元素添加/删除操作次数
//
// 详细分析：
// Mo算法是一种离线算法，通过巧妙地排序查询来减少重复计算
// 块大小选择sqrt(n)是经过理论分析的最优选择
// 排序策略是先按左端点所在块排序，再按右端点排序
// 这样可以保证相邻查询之间的指针移动次数最少

===============================================

文件: Code10_DQuery3.py
===============================================
# D-query问题 - Mo算法实现 (Python版本)
# 题目来源: https://www.spoj.com/problems/DQUERY/
# 题目大意: 给定一个长度为n的数组arr，有q次查询，每次查询[l,r]区间内不同数字的个数
# 约束条件: 1 <= n, q <= 2*10^5, 1 <= arr[i] <= 10^6
# 解法: Mo算法（离线分块）
# 时间复杂度: O((n + q) * sqrt(n))
# 空间复杂度: O(n + V), 其中V为值域大小(10^6)
# 是否最优解: 是，Mo算法是解决此类区间查询问题的经典方法

import math

# 定义最大数组长度和值域大小
MAXN = 200005
MAXV = 1000005

# 全局变量
n, q, blen = 0, 0, 0

# arr: 原始数组
arr = [0] * MAXN

# ans: 存储每个查询的答案
ans = [0] * MAXN

# count: 计数数组，记录当前窗口中每个数字的出现次数
count = [0] * MAXV

# curAns: 当前窗口中不同数字的个数
curAns = 0

# 查询结构
class Query:
    def __init__(self, l, r, id):
        self.l = l
        self.r = r
        self.id = id

# queries: 存储所有查询
queries = []

def add(pos):
    """
    添加元素到当前窗口
    时间复杂度: O(1)
    设计思路: 当向窗口中添加一个元素时，需要更新该元素的计数和不同数字的总数
    如果该元素之前在窗口中出现次数为0，说明是新数字，不同数字总数加1
    参数:
        pos: 位置
    """
    global curAns
    # 如果之前该数字出现次数为0，说明是新数字
    if count[arr[pos]] == 0:
        curAns += 1
    count[arr[pos]] += 1

def remove(pos):
    """
    从当前窗口移除元素
    时间复杂度: O(1)
    设计思路: 当从窗口中移除一个元素时，需要更新该元素的计数和不同数字的总数
    如果移除后该元素在窗口中出现次数为0，说明少了一个不同数字，不同数字总数减1
    参数:
        pos: 位置
    """
    global curAns
    count[arr[pos]] -= 1
    # 如果移除后该数字出现次数为0，说明少了一个不同数字
    if count[arr[pos]] == 0:
        curAns -= 1

def main():
    global n, q, blen
    
    # 读取数组长度n
    n = int(input())
    
    # 读取初始数组
    temp = list(map(int, input().split()))
    for i in range(1, n + 1):
        arr[i] = temp[i - 1]

    # 读取查询次数q
    q = int(input())
    
    # 读取所有查询
    for i in range(1, q + 1):
        l, r = map(int, input().split())
        queries.append(Query(l, r, i))

    # 使用Mo算法进行排序
    # 块大小选择: sqrt(n)，这是经过理论分析得出的最优块大小
    # 时间复杂度: O(q * log(q))，主要是排序的复杂度
    # 排序策略: 按照左端点所在的块编号排序，块内按右端点排序
    # 这样可以最小化指针移动的次数，从而优化整体时间复杂度
    blen = int(math.sqrt(n))
    
    def compare(query):
        block = (query.l - 1) // blen
        return (block, query.r)
    
    # 对查询进行排序
    queries.sort(key=compare)
    
    # Mo算法处理
    curL, curR = 1, 0
    for i in range(q):
        l = queries[i].l
        r = queries[i].r
        id = queries[i].id

        # 扩展右边界
        while curR < r:
            curR += 1
            add(curR)

        # 收缩左边界
        while curL > l:
            curL -= 1
            add(curL)

        # 收缩右边界
        while curR > r:
            remove(curR)
            curR -= 1

        # 扩展左边界
        while curL < l:
            remove(curL)
            curL += 1

        # 记录当前查询的答案
        ans[id] = curAns

    # 输出所有查询的结果
    for i in range(1, q + 1):
        print(ans[i])

if __name__ == "__main__":
    main()

===============================================

文件: Code11_PowerfulArray.cpp
===============================================
// Powerful array问题 - Mo算法实现 (C++版本)
// 题目来源: https://codeforces.com/problemset/problem/86/D
// 题目大意: 给定一个长度为n的数组arr，有q次查询，每次查询[l,r]区间的加权和
// 权重计算: 对于区间[l,r]内的每个数字x，如果它出现了c[x]次，则贡献为c[x]^2*x
// 约束条件: 1 <= n, q <= 2*10^5, 1 <= arr[i] <= 10^6
// 解法: Mo算法（离线分块）
// 时间复杂度: O((n + q) * sqrt(n))
// 空间复杂度: O(n + V), 其中V为值域大小(10^6)
// 是否最优解: 是，Mo算法是解决此类区间查询问题的经典方法

#include <iostream>
#include <algorithm>
#include <cmath>
using namespace std;

const int MAXN = 200001;
const int MAXV = 1000001;
int n, q, blen;
int arr[MAXN];
long long ans[MAXN];
int count[MAXV]; // 计数数组
long long curAns = 0; // 当前答案

// 查询结构
struct Query {
    int l, r, id;
    
    bool operator<(const Query& other) const {
        int blockA = (l - 1) / blen;
        int blockB = (other.l - 1) / blen;
        if (blockA != blockB) {
            return blockA < blockB;
        }
        return r < other.r;
    }
};

Query queries[MAXN];

/**
 * 添加元素到当前窗口
 * 时间复杂度: O(1)
 * 设计思路: 当向窗口中添加一个元素时，需要更新该元素的计数和总贡献值
 * 由于贡献计算公式为c[x]^2*x，添加元素时需要先减去旧贡献，更新计数，再加新贡献
 * @param pos 位置
 */
void add(int pos) {
    // 移除旧贡献: count[arr[pos]]^2 * arr[pos]
    curAns -= (long long) count[arr[pos]] * count[arr[pos]] * arr[pos];
    count[arr[pos]]++;
    // 添加新贡献: count[arr[pos]]^2 * arr[pos]
    curAns += (long long) count[arr[pos]] * count[arr[pos]] * arr[pos];
}

/**
 * 从当前窗口移除元素
 * 时间复杂度: O(1)
 * 设计思路: 当从窗口中移除一个元素时，需要更新该元素的计数和总贡献值
 * 由于贡献计算公式为c[x]^2*x，移除元素时需要先减去旧贡献，更新计数，再加新贡献
 * @param pos 位置
 */
void remove(int pos) {
    // 移除旧贡献: count[arr[pos]]^2 * arr[pos]
    curAns -= (long long) count[arr[pos]] * count[arr[pos]] * arr[pos];
    count[arr[pos]]--;
    // 添加新贡献: count[arr[pos]]^2 * arr[pos]
    curAns += (long long) count[arr[pos]] * count[arr[pos]] * arr[pos];
}

int main() {
    // 优化输入输出速度
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    
    // 读取数组长度n和查询次数q
    cin >> n >> q;
    
    // 读取初始数组
    for (int i = 1; i <= n; i++) {
        cin >> arr[i];
    }

    // 读取所有查询
    for (int i = 1; i <= q; i++) {
        cin >> queries[i].l >> queries[i].r;
        queries[i].id = i;
    }

    // 使用Mo算法进行排序
    // 块大小选择: sqrt(n)，这是经过理论分析得出的最优块大小
    // 时间复杂度: O(q * log(q))，主要是排序的复杂度
    // 排序策略: 按照左端点所在的块编号排序，块内按右端点排序
    // 这样可以最小化指针移动的次数，从而优化整体时间复杂度
    blen = (int)sqrt((double)n);
    sort(queries + 1, queries + q + 1);

    // Mo算法处理
    int curL = 1, curR = 0;
    for (int i = 1; i <= q; i++) {
        int l = queries[i].l;
        int r = queries[i].r;
        int id = queries[i].id;

        // 扩展右边界
        while (curR < r) {
            curR++;
            add(curR);
        }

        // 收缩左边界
        while (curL > l) {
            curL--;
            add(curL);
        }

        // 收缩右边界
        while (curR > r) {
            remove(curR);
            curR--;
        }

        // 扩展左边界
        while (curL < l) {
            remove(curL);
            curL++;
        }

        // 记录当前查询的答案
        ans[id] = curAns;
    }

    // 输出所有查询的结果
    for (int i = 1; i <= q; i++) {
        cout << ans[i] << "\n";
    }
    
    return 0;
}

// 算法说明：
// 1. 使用Mo算法（离线分块）解决区间加权和问题
// 2. 权重计算：每个数字x的贡献为c[x]^2*x，其中c[x]为x在区间内的出现次数
// 3. 时间复杂度：O((n + q) * sqrt(n))
// 4. 空间复杂度：O(n + V)，其中V为值域大小
// 5. 核心思想：通过分块排序查询，减少元素添加/删除操作次数
// 6. 关键优化：在添加/删除元素时，直接计算贡献变化，避免重新计算整个区间的答案

===============================================

文件: Code11_PowerfulArray1.java
===============================================
package class175;

// Powerful array问题 - Mo算法实现 (Java版本)
// 题目来源: https://codeforces.com/problemset/problem/86/D
// 题目大意: 给定一个长度为n的数组arr，有q次查询，每次查询[l,r]区间的加权和
// 权重计算: 对于区间[l,r]内的每个数字x，如果它出现了c[x]次，则贡献为c[x]^2*x
// 约束条件: 1 <= n, q <= 2*10^5, 1 <= arr[i] <= 10^6
// 解法: Mo算法（离线分块）
// 时间复杂度: O((n + q) * sqrt(n))
// 空间复杂度: O(n + V), 其中V为值域大小(10^6)
// 是否最优解: 是，Mo算法是解决此类区间查询问题的经典方法

import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStreamWriter;
import java.io.PrintWriter;
import java.util.Arrays;

public class Code11_PowerfulArray1 {

    // 定义最大数组长度和值域大小
    public static int MAXN = 200001;
    public static int MAXV = 1000001;
    
    // n: 数组长度, q: 查询次数, blen: 块大小
    public static int n, q, blen;
    
    // arr: 原始数组
    public static int[] arr = new int[MAXN];
    
    // ans: 存储每个查询的答案
    public static long[] ans = new long[MAXN];
    
    // count: 计数数组，记录当前窗口中每个数字的出现次数
    public static int[] count = new int[MAXV];
    
    // curAns: 当前窗口的加权和
    public static long curAns = 0;

    // 查询结构
    static class Query {
        int l, r, id;

        Query(int l, int r, int id) {
            this.l = l;
            this.r = r;
            this.id = id;
        }
    }

    // queries: 存储所有查询
    public static Query[] queries = new Query[MAXN];

    /**
     * 添加元素到当前窗口
     * 时间复杂度: O(1)
     * 设计思路: 当向窗口中添加一个元素时，需要更新该元素的计数和总贡献值
     * 由于贡献计算公式为c[x]^2*x，添加元素时需要先减去旧贡献，更新计数，再加新贡献
     * @param pos 位置
     */
    public static void add(int pos) {
        // 移除旧贡献: count[arr[pos]]^2 * arr[pos]
        curAns -= (long) count[arr[pos]] * count[arr[pos]] * arr[pos];
        count[arr[pos]]++;
        // 添加新贡献: count[arr[pos]]^2 * arr[pos]
        curAns += (long) count[arr[pos]] * count[arr[pos]] * arr[pos];
    }

    /**
     * 从当前窗口移除元素
     * 时间复杂度: O(1)
     * 设计思路: 当从窗口中移除一个元素时，需要更新该元素的计数和总贡献值
     * 由于贡献计算公式为c[x]^2*x，移除元素时需要先减去旧贡献，更新计数，再加新贡献
     * @param pos 位置
     */
    public static void remove(int pos) {
        // 移除旧贡献: count[arr[pos]]^2 * arr[pos]
        curAns -= (long) count[arr[pos]] * count[arr[pos]] * arr[pos];
        count[arr[pos]]--;
        // 添加新贡献: count[arr[pos]]^2 * arr[pos]
        curAns += (long) count[arr[pos]] * count[arr[pos]] * arr[pos];
    }

    public static void main(String[] args) throws IOException {
        FastReader in = new FastReader(System.in);
        PrintWriter out = new PrintWriter(new OutputStreamWriter(System.out));
        
        // 读取数组长度n和查询次数q
        n = in.nextInt();
        q = in.nextInt();
        
        // 读取初始数组
        for (int i = 1; i <= n; i++) {
            arr[i] = in.nextInt();
        }

        // 读取所有查询
        for (int i = 1; i <= q; i++) {
            int l = in.nextInt();
            int r = in.nextInt();
            queries[i] = new Query(l, r, i);
        }

        // 使用Mo算法进行排序
        // 块大小选择: sqrt(n)，这是经过理论分析得出的最优块大小
        // 时间复杂度: O(q * log(q))，主要是排序的复杂度
        // 排序策略: 按照左端点所在的块编号排序，块内按右端点排序
        // 这样可以最小化指针移动的次数，从而优化整体时间复杂度
        blen = (int) Math.sqrt(n);
        
        Arrays.sort(queries, 1, q + 1, (a, b) -> {
            int blockA = (a.l - 1) / blen;
            int blockB = (b.l - 1) / blen;
            if (blockA != blockB) {
                return blockA - blockB;
            }
            return a.r - b.r;
        });

        // Mo算法处理
        int curL = 1, curR = 0;
        for (int i = 1; i <= q; i++) {
            int l = queries[i].l;
            int r = queries[i].r;
            int id = queries[i].id;

            // 扩展右边界
            while (curR < r) {
                curR++;
                add(curR);
            }

            // 收缩左边界
            while (curL > l) {
                curL--;
                add(curL);
            }

            // 收缩右边界
            while (curR > r) {
                remove(curR);
                curR--;
            }

            // 扩展左边界
            while (curL < l) {
                remove(curL);
                curL++;
            }

            // 记录当前查询的答案
            ans[id] = curAns;
        }

        // 输出所有查询的结果
        for (int i = 1; i <= q; i++) {
            out.println(ans[i]);
        }
        
        out.flush();
        out.close();
    }

    // 高效读取工具类，用于加快输入输出速度
    static class FastReader {
        private final byte[] buffer = new byte[1 << 16];
        private int ptr = 0, len = 0;
        private final InputStream in;

        FastReader(InputStream in) {
            this.in = in;
        }

        private int readByte() throws IOException {
            if (ptr >= len) {
                len = in.read(buffer);
                ptr = 0;
                if (len <= 0)
                    return -1;
            }
            return buffer[ptr++];
        }

        public int nextInt() throws IOException {
            int c;
            do {
                c = readByte();
            } while (c <= ' ' && c != -1);
            boolean neg = false;
            if (c == '-') {
                neg = true;
                c = readByte();
            }
            int val = 0;
            while (c > ' ' && c != -1) {
                val = val * 10 + (c - '0');
                c = readByte();
            }
            return neg ? -val : val;
        }
    }
}

===============================================

文件: Code11_PowerfulArray2.cpp
===============================================
// Powerful array问题 - Mo算法实现 (C++版本)
// 题目来源: https://codeforces.com/problemset/problem/86/D
// 题目大意: 给定一个长度为n的数组arr，有q次查询，每次查询[l,r]区间的加权和
// 权重计算: 对于区间[l,r]内的每个数字x，如果它出现了c[x]次，则贡献为c[x]^2*x
// 约束条件: 1 <= n, q <= 2*10^5, 1 <= arr[i] <= 10^6
// 解法: Mo算法（离线分块）
// 时间复杂度: O((n + q) * sqrt(n))
// 空间复杂度: O(n + V), 其中V为值域大小(10^6)
// 是否最优解: 是，Mo算法是解决此类区间查询问题的经典方法

#include <cstdio>
#include <algorithm>
#include <cmath>
using namespace std;

const int MAXN = 200001;
const int MAXV = 1000001;
int n, q, blen;
int arr[MAXN];
long long ans[MAXN];
int count[MAXV]; // 计数数组
long long curAns = 0; // 当前答案

// 查询结构
struct Query {
    int l, r, id;
    
    bool operator<(const Query& other) const {
        int blockA = (l - 1) / blen;
        int blockB = (other.l - 1) / blen;
        if (blockA != blockB) {
            return blockA < blockB;
        }
        return r < other.r;
    }
};

Query queries[MAXN];

/**
 * 添加元素到当前窗口
 * 时间复杂度: O(1)
 * 设计思路: 当向窗口中添加一个元素时，需要更新该元素的计数和总贡献值
 * 由于贡献计算公式为c[x]^2*x，添加元素时需要先减去旧贡献，更新计数，再加新贡献
 * @param pos 位置
 */
void add(int pos) {
    // 移除旧贡献: count[arr[pos]]^2 * arr[pos]
    curAns -= (long long) count[arr[pos]] * count[arr[pos]] * arr[pos];
    count[arr[pos]]++;
    // 添加新贡献: count[arr[pos]]^2 * arr[pos]
    curAns += (long long) count[arr[pos]] * count[arr[pos]] * arr[pos];
}

/**
 * 从当前窗口移除元素
 * 时间复杂度: O(1)
 * 设计思路: 当从窗口中移除一个元素时，需要更新该元素的计数和总贡献值
 * 由于贡献计算公式为c[x]^2*x，移除元素时需要先减去旧贡献，更新计数，再加新贡献
 * @param pos 位置
 */
void remove(int pos) {
    // 移除旧贡献: count[arr[pos]]^2 * arr[pos]
    curAns -= (long long) count[arr[pos]] * count[arr[pos]] * arr[pos];
    count[arr[pos]]--;
    // 添加新贡献: count[arr[pos]]^2 * arr[pos]
    curAns += (long long) count[arr[pos]] * count[arr[pos]] * arr[pos];
}

int main() {
    // 读取数组长度n和查询次数q
    scanf("%d%d", &n, &q);
    
    // 读取初始数组
    for (int i = 1; i <= n; i++) {
        scanf("%d", &arr[i]);
    }

    // 读取所有查询
    for (int i = 1; i <= q; i++) {
        scanf("%d%d", &queries[i].l, &queries[i].r);
        queries[i].id = i;
    }

    // 使用Mo算法进行排序
    // 块大小选择: sqrt(n)，这是经过理论分析得出的最优块大小
    // 时间复杂度: O(q * log(q))，主要是排序的复杂度
    // 排序策略: 按照左端点所在的块编号排序，块内按右端点排序
    // 这样可以最小化指针移动的次数，从而优化整体时间复杂度
    blen = (int)sqrt((double)n);
    sort(queries + 1, queries + q + 1);

    // Mo算法处理
    int curL = 1, curR = 0;
    for (int i = 1; i <= q; i++) {
        int l = queries[i].l;
        int r = queries[i].r;
        int id = queries[i].id;

        // 扩展右边界
        while (curR < r) {
            curR++;
            add(curR);
        }

        // 收缩左边界
        while (curL > l) {
            curL--;
            add(curL);
        }

        // 收缩右边界
        while (curR > r) {
            remove(curR);
            curR--;
        }

        // 扩展左边界
        while (curL < l) {
            remove(curL);
            curL++;
        }

        // 记录当前查询的答案
        ans[id] = curAns;
    }

    // 输出所有查询的结果
    for (int i = 1; i <= q; i++) {
        printf("%lld\n", ans[i]);
    }
    
    return 0;
}

// 算法说明：
// 1. 使用Mo算法（离线分块）解决区间加权和问题
// 2. 权重计算：每个数字x的贡献为c[x]^2*x，其中c[x]为x在区间内的出现次数
// 3. 时间复杂度：O((n + q) * sqrt(n))
// 4. 空间复杂度：O(n + V)，其中V为值域大小
// 5. 核心思想：通过分块排序查询，减少元素添加/删除操作次数
// 6. 关键优化：在添加/删除元素时，直接计算贡献变化，避免重新计算整个区间的答案

===============================================

文件: Code11_PowerfulArray3.py
===============================================
# Powerful array问题 - Mo算法实现 (Python版本)
# 题目来源: https://codeforces.com/problemset/problem/86/D
# 题目大意: 给定一个长度为n的数组arr，有q次查询，每次查询[l,r]区间的加权和
# 权重计算: 对于区间[l,r]内的每个数字x，如果它出现了c[x]次，则贡献为c[x]^2*x
# 约束条件: 1 <= n, q <= 2*10^5, 1 <= arr[i] <= 10^6
# 解法: Mo算法（离线分块）
# 时间复杂度: O((n + q) * sqrt(n))
# 空间复杂度: O(n + V), 其中V为值域大小(10^6)
# 是否最优解: 是，Mo算法是解决此类区间查询问题的经典方法

import math

# 定义最大数组长度和值域大小
MAXN = 200005
MAXV = 1000005

# 全局变量
n, q, blen = 0, 0, 0

# arr: 原始数组
arr = [0] * MAXN

# ans: 存储每个查询的答案
ans = [0] * MAXN

# count: 计数数组，记录当前窗口中每个数字的出现次数
count = [0] * MAXV

# curAns: 当前窗口的加权和
curAns = 0

# 查询结构
class Query:
    def __init__(self, l, r, id):
        self.l = l
        self.r = r
        self.id = id

# queries: 存储所有查询
queries = []

def add(pos):
    """
    添加元素到当前窗口
    时间复杂度: O(1)
    设计思路: 当向窗口中添加一个元素时，需要更新该元素的计数和总贡献值
    由于贡献计算公式为c[x]^2*x，添加元素时需要先减去旧贡献，更新计数，再加新贡献
    参数:
        pos: 位置
    """
    global curAns
    # 移除旧贡献: count[arr[pos]]^2 * arr[pos]
    curAns -= count[arr[pos]] * count[arr[pos]] * arr[pos]
    count[arr[pos]] += 1
    # 添加新贡献: count[arr[pos]]^2 * arr[pos]
    curAns += count[arr[pos]] * count[arr[pos]] * arr[pos]

def remove(pos):
    """
    从当前窗口移除元素
    时间复杂度: O(1)
    设计思路: 当从窗口中移除一个元素时，需要更新该元素的计数和总贡献值
    由于贡献计算公式为c[x]^2*x，移除元素时需要先减去旧贡献，更新计数，再加新贡献
    参数:
        pos: 位置
    """
    global curAns
    # 移除旧贡献: count[arr[pos]]^2 * arr[pos]
    curAns -= count[arr[pos]] * count[arr[pos]] * arr[pos]
    count[arr[pos]] -= 1
    # 添加新贡献: count[arr[pos]]^2 * arr[pos]
    curAns += count[arr[pos]] * count[arr[pos]] * arr[pos]

def main():
    global n, q, blen, curAns
    
    # 读取数组长度n和查询次数q
    line = input().split()
    n = int(line[0])
    q = int(line[1])
    
    # 读取初始数组
    temp = list(map(int, input().split()))
    for i in range(1, n + 1):
        arr[i] = temp[i - 1]

    # 读取所有查询
    for i in range(1, q + 1):
        l, r = map(int, input().split())
        queries.append(Query(l, r, i))

    # 使用Mo算法进行排序
    # 块大小选择: sqrt(n)，这是经过理论分析得出的最优块大小
    # 时间复杂度: O(q * log(q))，主要是排序的复杂度
    # 排序策略: 按照左端点所在的块编号排序，块内按右端点排序
    # 这样可以最小化指针移动的次数，从而优化整体时间复杂度
    blen = int(math.sqrt(n))
    
    def compare(query):
        block = (query.l - 1) // blen
        return (block, query.r)
    
    # 对查询进行排序
    queries.sort(key=compare)
    
    # Mo算法处理
    curL, curR = 1, 0
    for i in range(q):
        l = queries[i].l
        r = queries[i].r
        id = queries[i].id

        # 扩展右边界
        while curR < r:
            curR += 1
            add(curR)

        # 收缩左边界
        while curL > l:
            curL -= 1
            add(curL)

        # 收缩右边界
        while curR > r:
            remove(curR)
            curR -= 1

        # 扩展左边界
        while curL < l:
            remove(curL)
            curL += 1

        # 记录当前查询的答案
        ans[id] = curAns

    # 输出所有查询的结果
    for i in range(1, q + 1):
        print(ans[i])

if __name__ == "__main__":
    main()

===============================================

文件: Code12_Holes.cpp
===============================================
// Holes问题 - 分块算法实现 (C++版本)
// 题目来源: https://codeforces.com/problemset/problem/13-E
// 题目大意: 给定一个长度为n的数组arr，支持两种操作：
// 1. 查询从位置i开始跳出数组需要的步数
// 2. 修改某个位置的值
// 约束条件: 1 <= n, q <= 10^5, 1 <= arr[i] <= n

#include <iostream>
#include <algorithm>
#include <cmath>
#include <utility>
using namespace std;

const int MAXN = 100001;
int n, q, blen;
int arr[MAXN];

// 分块相关数组
int belong[MAXN]; // 每个位置属于哪个块
int blockL[MAXN]; // 每个块的左边界
int blockR[MAXN]; // 每个块的右边界
int to[MAXN]; // 从块内某个位置跳出该块到达的位置
int step[MAXN]; // 从块内某个位置跳出该块需要的步数
int bcnt = 0; // 块的数量

/**
 * 构建分块结构
 * 时间复杂度: O(n)
 * 设计思路: 将数组分成大小约为sqrt(n)的块，预处理每个块内位置的跳跃信息
 * 块大小选择sqrt(n)是为了平衡预处理和查询的复杂度
 */
void build() {
    // 计算块大小，选择sqrt(n)
    blen = (int)sqrt((double)n);
    
    // 计算块数量
    bcnt = (n - 1) / blen + 1;
    
    // 初始化每个块的边界信息
    for (int i = 1; i <= bcnt; i++) {
        blockL[i] = (i - 1) * blen + 1;
        blockR[i] = min(i * blen, n);
    }
    
    // 计算每个位置属于哪个块
    for (int i = 1; i <= n; i++) {
        belong[i] = (i - 1) / blen + 1;
    }
    
    // 预处理每个块内的信息
    reset();
}

/**
 * 重置块内信息
 * 时间复杂度: O(n*sqrt(n))
 * 设计思路: 预处理每个位置的跳跃信息，包括跳出当前块需要的步数和到达的位置
 * 对于每个位置i，模拟跳跃过程直到跳出当前块或数组边界
 */
void reset() {
    // 遍历所有位置
    for (int i = 1; i <= n; i++) {
        int b = belong[i];
        
        // 计算从位置i跳出块b需要的步数和到达的位置
        if (i + arr[i] > blockR[b]) {
            // 可以跳出当前块
            to[i] = i + arr[i];
            step[i] = 1;
        } else {
            // 不能跳出当前块，需要继续跳
            to[i] = i + arr[i];
            step[i] = 1;
            
            // 继续模拟直到跳出块
            int pos = i + arr[i];
            while (pos <= n && belong[pos] == b) {
                pos += arr[pos];
                step[i]++;
            }
            to[i] = pos;
        }
    }
}

/**
 * 查询从位置x跳出数组需要的步数和最终位置
 * 时间复杂度: O(sqrt(n))
 * 设计思路: 利用预处理的块内跳跃信息，每次跳跃可以跳过整个块
 * 最多需要跳O(sqrt(n))次，因为数组被分成了O(sqrt(n))个块
 * @param x 起始位置
 * @return 包含步数和最终位置的pair
 */
pair<int, int> query(int x) {
    int steps = 0;
    int pos = x;
    
    // 利用预处理信息进行跳跃
    while (pos <= n) {
        steps += step[pos];
        pos = to[pos];
    }
    
    // 返回步数和最终位置
    return make_pair(steps, pos > n ? pos - 1 : pos);
}

/**
 * 修改位置x的值为y
 * 时间复杂度: O(sqrt(n))
 * 设计思路: 当修改某个位置的值时，需要重新计算包含该位置的整个块的跳跃信息
 * 由于块大小为O(sqrt(n))，所以更新复杂度为O(sqrt(n))
 * @param x 位置
 * @param y 新值
 */
void update(int x, int y) {
    // 更新数组值
    arr[x] = y;
    
    // 重新计算包含位置x的整个块的信息
    int b = belong[x];
    for (int i = blockL[b]; i <= blockR[b]; i++) {
        if (i + arr[i] > blockR[b]) {
            // 可以跳出当前块
            to[i] = i + arr[i];
            step[i] = 1;
        } else {
            // 不能跳出当前块，需要继续跳
            to[i] = i + arr[i];
            step[i] = 1;
            
            // 继续模拟直到跳出块
            int pos = i + arr[i];
            while (pos <= n && belong[pos] == b) {
                pos += arr[pos];
                step[i]++;
            }
            to[i] = pos;
        }
    }
}

int main() {
    // 优化输入输出速度
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    
    // 读取数组长度n和操作次数q
    cin >> n >> q;
    
    // 读取初始数组
    for (int i = 1; i <= n; i++) {
        cin >> arr[i];
    }

    // 构建分块结构
    build();

    // 处理q次操作
    for (int i = 1; i <= q; i++) {
        int op;
        cin >> op;
        if (op == 0) {
            // 修改操作
            int x, y;
            cin >> x >> y;
            update(x, y);
        } else {
            // 查询操作
            int x;
            cin >> x;
            pair<int, int> result = query(x);
            cout << result.first << " " << result.second << "\n";
        }
    }
    
    return 0;
}

// 算法说明：
// 1. 使用分块算法解决跳跃问题
// 2. 预处理每个块内位置的跳跃信息
// 3. 时间复杂度：
//    - 预处理：O(n*sqrt(n))
//    - 查询：O(sqrt(n))
//    - 更新：O(sqrt(n))
// 4. 空间复杂度：O(n)
// 5. 核心思想：将数组分块，预处理每个块内位置的跳跃信息，减少查询时的计算量

===============================================

文件: Code12_Holes1.java
===============================================
package class175;

// Holes问题 - 分块算法实现 (Java版本)
// 题目来源: https://codeforces.com/problemset/problem/13/E
// 题目大意: 给定一个长度为n的数组arr，支持两种操作：
// 1. 查询从位置i开始跳出数组需要的步数
// 2. 修改某个位置的值
// 约束条件: 1 <= n, q <= 10^5, 1 <= arr[i] <= n

import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStreamWriter;
import java.io.PrintWriter;

public class Code12_Holes1 {

    // 定义最大数组长度
    public static int MAXN = 100001;
    
    // n: 数组长度, q: 操作次数, blen: 块大小
    public static int n, q, blen;
    
    // arr: 原始数组
    public static int[] arr = new int[MAXN];
    
    // 分块相关数组
    public static int[] belong = new int[MAXN]; // 每个位置属于哪个块
    public static int[] blockL = new int[MAXN]; // 每个块的左边界
    public static int[] blockR = new int[MAXN]; // 每个块的右边界
    public static int[] to = new int[MAXN]; // 从块内某个位置跳出该块到达的位置
    public static int[] step = new int[MAXN]; // 从块内某个位置跳出该块需要的步数
    public static int bcnt = 0; // 块的数量

    /**
     * 构建分块结构
     * 时间复杂度: O(n)
     * 设计思路: 将数组分成大小约为sqrt(n)的块，预处理每个块内位置的跳跃信息
     * 块大小选择sqrt(n)是为了平衡预处理和查询的复杂度
     */
    public static void build() {
        // 计算块大小，选择sqrt(n)
        blen = (int) Math.sqrt(n);
        
        // 计算块数量
        bcnt = (n - 1) / blen + 1;
        
        // 初始化每个块的边界信息
        for (int i = 1; i <= bcnt; i++) {
            blockL[i] = (i - 1) * blen + 1;
            blockR[i] = Math.min(i * blen, n);
        }
        
        // 计算每个位置属于哪个块
        for (int i = 1; i <= n; i++) {
            belong[i] = (i - 1) / blen + 1;
        }
        
        // 预处理每个块内的信息
        reset();
    }
    
    /**
     * 重置块内信息
     * 时间复杂度: O(n*sqrt(n))
     * 设计思路: 预处理每个位置的跳跃信息，包括跳出当前块需要的步数和到达的位置
     * 对于每个位置i，模拟跳跃过程直到跳出当前块或数组边界
     */
    public static void reset() {
        // 遍历所有位置
        for (int i = 1; i <= n; i++) {
            int b = belong[i];
            
            // 计算从位置i跳出块b需要的步数和到达的位置
            if (i + arr[i] > blockR[b]) {
                // 可以跳出当前块
                to[i] = i + arr[i];
                step[i] = 1;
            } else {
                // 不能跳出当前块，需要继续跳
                to[i] = i + arr[i];
                step[i] = 1;
                
                // 继续模拟直到跳出块
                int pos = i + arr[i];
                while (pos <= n && belong[pos] == b) {
                    pos += arr[pos];
                    step[i]++;
                }
                to[i] = pos;
            }
        }
    }

    /**
     * 查询从位置x跳出数组需要的步数和最终位置
     * 时间复杂度: O(sqrt(n))
     * 设计思路: 利用预处理的块内跳跃信息，每次跳跃可以跳过整个块
     * 最多需要跳O(sqrt(n))次，因为数组被分成了O(sqrt(n))个块
     * @param x 起始位置
     * @return 包含步数和最终位置的数组
     */
    public static int[] query(int x) {
        int steps = 0;
        int pos = x;
        
        // 利用预处理信息进行跳跃
        while (pos <= n) {
            steps += step[pos];
            pos = to[pos];
        }
        
        // 返回步数和最终位置
        return new int[]{steps, pos > n ? pos - 1 : pos};
    }

    /**
     * 修改位置x的值为y
     * 时间复杂度: O(sqrt(n))
     * 设计思路: 当修改某个位置的值时，需要重新计算包含该位置的整个块的跳跃信息
     * 由于块大小为O(sqrt(n))，所以更新复杂度为O(sqrt(n))
     * @param x 位置
     * @param y 新值
     */
    public static void update(int x, int y) {
        // 更新数组值
        arr[x] = y;
        
        // 重新计算包含位置x的整个块的信息
        int b = belong[x];
        for (int i = blockL[b]; i <= blockR[b]; i++) {
            if (i + arr[i] > blockR[b]) {
                // 可以跳出当前块
                to[i] = i + arr[i];
                step[i] = 1;
            } else {
                // 不能跳出当前块，需要继续跳
                to[i] = i + arr[i];
                step[i] = 1;
                
                // 继续模拟直到跳出块
                int pos = i + arr[i];
                while (pos <= n && belong[pos] == b) {
                    pos += arr[pos];
                    step[i]++;
                }
                to[i] = pos;
            }
        }
    }

    public static void main(String[] args) throws IOException {
        FastReader in = new FastReader(System.in);
        PrintWriter out = new PrintWriter(new OutputStreamWriter(System.out));
        
        // 读取数组长度n和操作次数q
        n = in.nextInt();
        q = in.nextInt();
        
        // 读取初始数组
        for (int i = 1; i <= n; i++) {
            arr[i] = in.nextInt();
        }

        // 构建分块结构
        build();

        // 处理q次操作
        for (int i = 1; i <= q; i++) {
            int op = in.nextInt();
            if (op == 0) {
                // 修改操作
                int x = in.nextInt();
                int y = in.nextInt();
                update(x, y);
            } else {
                // 查询操作
                int x = in.nextInt();
                int[] result = query(x);
                out.println(result[0] + " " + result[1]);
            }
        }
        
        out.flush();
        out.close();
    }

    // 高效读取工具类，用于加快输入输出速度
    static class FastReader {
        private final byte[] buffer = new byte[1 << 16];
        private int ptr = 0, len = 0;
        private final InputStream in;

        FastReader(InputStream in) {
            this.in = in;
        }

        private int readByte() throws IOException {
            if (ptr >= len) {
                len = in.read(buffer);
                ptr = 0;
                if (len <= 0)
                    return -1;
            }
            return buffer[ptr++];
        }

        public int nextInt() throws IOException {
            int c;
            do {
                c = readByte();
            } while (c <= ' ' && c != -1);
            boolean neg = false;
            if (c == '-') {
                neg = true;
                c = readByte();
            }
            int val = 0;
            while (c > ' ' && c != -1) {
                val = val * 10 + (c - '0');
                c = readByte();
            }
            return neg ? -val : val;
        }
    }
}

===============================================

文件: Code12_Holes2.cpp
===============================================
// Holes问题 - 分块算法实现 (C++版本)
// 题目来源: https://codeforces.com/problemset/problem/13-E
// 题目大意: 给定一个长度为n的数组arr，支持两种操作：
// 1. 查询从位置i开始跳出数组需要的步数
// 2. 修改某个位置的值
// 约束条件: 1 <= n, q <= 10^5, 1 <= arr[i] <= n

#include <cstdio>
#include <algorithm>
#include <cmath>
#include <utility>
using namespace std;

const int MAXN = 100001;
int n, q, blen;
int arr[MAXN];

// 分块相关数组
int belong[MAXN]; // 每个位置属于哪个块
int blockL[MAXN]; // 每个块的左边界
int blockR[MAXN]; // 每个块的右边界
int to[MAXN]; // 从块内某个位置跳出该块到达的位置
int step[MAXN]; // 从块内某个位置跳出该块需要的步数
int bcnt = 0; // 块的数量

/**
 * 构建分块结构
 * 时间复杂度: O(n)
 * 设计思路: 将数组分成大小约为sqrt(n)的块，预处理每个块内位置的跳跃信息
 * 块大小选择sqrt(n)是为了平衡预处理和查询的复杂度
 */
void build() {
    // 计算块大小，选择sqrt(n)
    blen = (int)sqrt((double)n);
    
    // 计算块数量
    bcnt = (n - 1) / blen + 1;
    
    // 初始化每个块的边界信息
    for (int i = 1; i <= bcnt; i++) {
        blockL[i] = (i - 1) * blen + 1;
        blockR[i] = min(i * blen, n);
    }
    
    // 计算每个位置属于哪个块
    for (int i = 1; i <= n; i++) {
        belong[i] = (i - 1) / blen + 1;
    }
    
    // 预处理每个块内的信息
    reset();
}

/**
 * 重置块内信息
 * 时间复杂度: O(n*sqrt(n))
 * 设计思路: 预处理每个位置的跳跃信息，包括跳出当前块需要的步数和到达的位置
 * 对于每个位置i，模拟跳跃过程直到跳出当前块或数组边界
 */
void reset() {
    // 遍历所有位置
    for (int i = 1; i <= n; i++) {
        int b = belong[i];
        
        // 计算从位置i跳出块b需要的步数和到达的位置
        if (i + arr[i] > blockR[b]) {
            // 可以跳出当前块
            to[i] = i + arr[i];
            step[i] = 1;
        } else {
            // 不能跳出当前块，需要继续跳
            to[i] = i + arr[i];
            step[i] = 1;
            
            // 继续模拟直到跳出块
            int pos = i + arr[i];
            while (pos <= n && belong[pos] == b) {
                pos += arr[pos];
                step[i]++;
            }
            to[i] = pos;
        }
    }
}

/**
 * 查询从位置x跳出数组需要的步数和最终位置
 * 时间复杂度: O(sqrt(n))
 * 设计思路: 利用预处理的块内跳跃信息，每次跳跃可以跳过整个块
 * 最多需要跳O(sqrt(n))次，因为数组被分成了O(sqrt(n))个块
 * @param x 起始位置
 * @return 包含步数和最终位置的pair
 */
pair<int, int> query(int x) {
    int steps = 0;
    int pos = x;
    
    // 利用预处理信息进行跳跃
    while (pos <= n) {
        steps += step[pos];
        pos = to[pos];
    }
    
    // 返回步数和最终位置
    return make_pair(steps, pos > n ? pos - 1 : pos);
}

/**
 * 修改位置x的值为y
 * 时间复杂度: O(sqrt(n))
 * 设计思路: 当修改某个位置的值时，需要重新计算包含该位置的整个块的跳跃信息
 * 由于块大小为O(sqrt(n))，所以更新复杂度为O(sqrt(n))
 * @param x 位置
 * @param y 新值
 */
void update(int x, int y) {
    // 更新数组值
    arr[x] = y;
    
    // 重新计算包含位置x的整个块的信息
    int b = belong[x];
    for (int i = blockL[b]; i <= blockR[b]; i++) {
        if (i + arr[i] > blockR[b]) {
            // 可以跳出当前块
            to[i] = i + arr[i];
            step[i] = 1;
        } else {
            // 不能跳出当前块，需要继续跳
            to[i] = i + arr[i];
            step[i] = 1;
            
            // 继续模拟直到跳出块
            int pos = i + arr[i];
            while (pos <= n && belong[pos] == b) {
                pos += arr[pos];
                step[i]++;
            }
            to[i] = pos;
        }
    }
}

int main() {
    // 读取数组长度n和操作次数q
    scanf("%d%d", &n, &q);
    
    // 读取初始数组
    for (int i = 1; i <= n; i++) {
        scanf("%d", &arr[i]);
    }

    // 构建分块结构
    build();

    // 处理q次操作
    for (int i = 1; i <= q; i++) {
        int op;
        scanf("%d", &op);
        if (op == 0) {
            // 修改操作
            int x, y;
            scanf("%d%d", &x, &y);
            update(x, y);
        } else {
            // 查询操作
            int x;
            scanf("%d", &x);
            pair<int, int> result = query(x);
            printf("%d %d\n", result.first, result.second);
        }
    }
    
    return 0;
}

// 算法说明：
// 1. 使用分块算法解决跳跃问题
// 2. 预处理每个块内位置的跳跃信息
// 3. 时间复杂度：
//    - 预处理：O(n*sqrt(n))
//    - 查询：O(sqrt(n))
//    - 更新：O(sqrt(n))
// 4. 空间复杂度：O(n)
// 5. 核心思想：将数组分块，预处理每个块内位置的跳跃信息，减少查询时的计算量

===============================================

文件: Code12_Holes3.py
===============================================
# Holes问题 - 分块算法实现 (Python版本)
# 题目来源: https://codeforces.com/problemset/problem/13-E
# 题目大意: 给定一个长度为n的数组arr，支持两种操作：
# 1. 查询从位置i开始跳出数组需要的步数
# 2. 修改某个位置的值
# 约束条件: 1 <= n, q <= 10^5, 1 <= arr[i] <= n

import math

# 定义最大数组长度
MAXN = 100005

# 全局变量
n, q, blen = 0, 0, 0

# arr: 原始数组
arr = [0] * MAXN

# 分块相关数组
belong = [0] * MAXN  # 每个位置属于哪个块
blockL = [0] * MAXN  # 每个块的左边界
blockR = [0] * MAXN  # 每个块的右边界
to = [0] * MAXN  # 从块内某个位置跳出该块到达的位置
step = [0] * MAXN  # 从块内某个位置跳出该块需要的步数
bcnt = 0  # 块的数量

def build():
    """
    构建分块结构
    时间复杂度: O(n)
    设计思路: 将数组分成大小约为sqrt(n)的块，预处理每个块内位置的跳跃信息
    块大小选择sqrt(n)是为了平衡预处理和查询的复杂度
    """
    global blen, bcnt
    
    # 计算块大小，选择sqrt(n)
    blen = int(math.sqrt(n))
    
    # 计算块数量
    bcnt = (n - 1) // blen + 1
    
    # 初始化每个块的边界信息
    for i in range(1, bcnt + 1):
        blockL[i] = (i - 1) * blen + 1
        blockR[i] = min(i * blen, n)
    
    # 计算每个位置属于哪个块
    for i in range(1, n + 1):
        belong[i] = (i - 1) // blen + 1
    
    # 预处理每个块内的信息
    reset()

def reset():
    """
    重置块内信息
    时间复杂度: O(n*sqrt(n))
    设计思路: 预处理每个位置的跳跃信息，包括跳出当前块需要的步数和到达的位置
    对于每个位置i，模拟跳跃过程直到跳出当前块或数组边界
    """
    # 遍历所有位置
    for i in range(1, n + 1):
        b = belong[i]
        
        # 计算从位置i跳出块b需要的步数和到达的位置
        if i + arr[i] > blockR[b]:
            # 可以跳出当前块
            to[i] = i + arr[i]
            step[i] = 1
        else:
            # 不能跳出当前块，需要继续跳
            to[i] = i + arr[i]
            step[i] = 1
            
            # 继续模拟直到跳出块
            pos = i + arr[i]
            while pos <= n and belong[pos] == b:
                pos += arr[pos]
                step[i] += 1
            to[i] = pos

def query(x):
    """
    查询从位置x跳出数组需要的步数和最终位置
    时间复杂度: O(sqrt(n))
    设计思路: 利用预处理的块内跳跃信息，每次跳跃可以跳过整个块
    最多需要跳O(sqrt(n))次，因为数组被分成了O(sqrt(n))个块
    参数:
        x: 起始位置
    返回:
        包含步数和最终位置的元组
    """
    steps = 0
    pos = x
    
    # 利用预处理信息进行跳跃
    while pos <= n:
        steps += step[pos]
        pos = to[pos]
    
    # 返回步数和最终位置
    return (steps, pos - 1 if pos > n else pos)

def update(x, y):
    """
    修改位置x的值为y
    时间复杂度: O(sqrt(n))
    设计思路: 当修改某个位置的值时，需要重新计算包含该位置的整个块的跳跃信息
    由于块大小为O(sqrt(n))，所以更新复杂度为O(sqrt(n))
    参数:
        x: 位置
        y: 新值
    """
    # 更新数组值
    arr[x] = y
    
    # 重新计算包含位置x的整个块的信息
    b = belong[x]
    for i in range(blockL[b], blockR[b] + 1):
        if i + arr[i] > blockR[b]:
            # 可以跳出当前块
            to[i] = i + arr[i]
            step[i] = 1
        else:
            # 不能跳出当前块，需要继续跳
            to[i] = i + arr[i]
            step[i] = 1
            
            # 继续模拟直到跳出块
            pos = i + arr[i]
            while pos <= n and belong[pos] == b:
                pos += arr[pos]
                step[i] += 1
            to[i] = pos

def main():
    global n, q
    
    # 读取数组长度n和操作次数q
    line = input().split()
    n = int(line[0])
    q = int(line[1])
    
    # 读取初始数组
    temp = list(map(int, input().split()))
    for i in range(1, n + 1):
        arr[i] = temp[i - 1]

    # 构建分块结构
    build()

    # 处理q次操作
    for i in range(1, q + 1):
        line = input().split()
        op = int(line[0])
        if op == 0:
            # 修改操作
            x = int(line[1])
            y = int(line[2])
            update(x, y)
        else:
            # 查询操作
            x = int(line[1])
            result = query(x)
            print(result[0], result[1])

if __name__ == "__main__":
    main()

===============================================

文件: Code13_PointsOnPlane.cpp
===============================================
// Points on Plane问题 - 二维前缀和实现 (C++版本)
// 题目来源: https://codeforces.com/problemset/problem/1181/C
// 题目大意: 给定一个N×N的网格，每个格点上有一些点，多次查询矩形区域内点的数量
// 约束条件: 1 <= N <= 10^3, 1 <= Q <= 10^5

#include <iostream>
using namespace std;

const int MAXN = 1001;
int n, q;
int arr[MAXN][MAXN];
int sum[MAXN][MAXN]; // 二维前缀和数组

/**
 * 构建二维前缀和数组
 * 时间复杂度: O(N^2)
 * 设计思路: 利用二维前缀和公式计算每个位置的前缀和
 * sum[i][j] = arr[i][j] + sum[i-1][j] + sum[i][j-1] - sum[i-1][j-1]
 * 这样可以避免重复计算，提高查询效率
 */
void build() {
    // 遍历网格的每个位置
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= n; j++) {
            // 应用二维前缀和公式
            sum[i][j] = arr[i][j] + sum[i - 1][j] + sum[i][j - 1] - sum[i - 1][j - 1];
        }
    }
}

/**
 * 查询矩形区域[r1,c1]到[r2,c2]内点的数量
 * 时间复杂度: O(1)
 * 设计思路: 利用二维前缀和数组快速计算矩形区域和
 * 通过容斥原理计算矩形区域和：
 * 区域和 = sum[r2][c2] - sum[r1-1][c2] - sum[r2][c1-1] + sum[r1-1][c1-1]
 * @param r1 起始行
 * @param c1 起始列
 * @param r2 结束行
 * @param c2 结束列
 * @return 矩形区域内点的数量
 */
int query(int r1, int c1, int r2, int c2) {
    // 应用容斥原理计算矩形区域和
    return sum[r2][c2] - sum[r1 - 1][c2] - sum[r2][c1 - 1] + sum[r1 - 1][c1 - 1];
}

int main() {
    // 优化输入输出速度
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    
    // 读取网格大小n和查询次数q
    cin >> n >> q;
    
    // 读取网格数据
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= n; j++) {
            cin >> arr[i][j];
        }
    }

    // 构建前缀和数组
    build();

    // 处理q次查询
    for (int i = 1; i <= q; i++) {
        int r1, c1, r2, c2;
        cin >> r1 >> c1 >> r2 >> c2;
        // 输出查询结果
        cout << query(r1, c1, r2, c2) << "\n";
    }
    
    return 0;
}

// 算法说明：
// 1. 使用二维前缀和解决矩形区域查询问题
// 2. 预处理时间复杂度：O(N^2)
// 3. 查询时间复杂度：O(1)
// 4. 空间复杂度：O(N^2)
// 5. 核心思想：通过预处理前缀和数组，将区间查询的复杂度从O(N^2)降低到O(1)

===============================================

文件: Code13_PointsOnPlane1.java
===============================================
package class175;

// Points on Plane问题 - 二维前缀和实现 (Java版本)
// 题目来源: https://codeforces.com/problemset/problem/1181/C
// 题目大意: 给定一个N×N的网格，每个格点上有一些点，多次查询矩形区域内点的数量
// 约束条件: 1 <= N <= 10^3, 1 <= Q <= 10^5

import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStreamWriter;
import java.io.PrintWriter;

public class Code13_PointsOnPlane1 {

    // 定义最大网格大小
    public static int MAXN = 1001;
    
    // n: 网格大小, q: 查询次数
    public static int n, q;
    
    // arr: 原始网格数据
    public static int[][] arr = new int[MAXN][MAXN];
    
    // sum: 二维前缀和数组
    public static int[][] sum = new int[MAXN][MAXN];

    /**
     * 构建二维前缀和数组
     * 时间复杂度: O(N^2)
     * 设计思路: 利用二维前缀和公式计算每个位置的前缀和
     * sum[i][j] = arr[i][j] + sum[i-1][j] + sum[i][j-1] - sum[i-1][j-1]
     * 这样可以避免重复计算，提高查询效率
     */
    public static void build() {
        // 遍历网格的每个位置
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= n; j++) {
                // 应用二维前缀和公式
                sum[i][j] = arr[i][j] + sum[i - 1][j] + sum[i][j - 1] - sum[i - 1][j - 1];
            }
        }
    }

    /**
     * 查询矩形区域[r1,c1]到[r2,c2]内点的数量
     * 时间复杂度: O(1)
     * 设计思路: 利用二维前缀和数组快速计算矩形区域和
     * 通过容斥原理计算矩形区域和：
     * 区域和 = sum[r2][c2] - sum[r1-1][c2] - sum[r2][c1-1] + sum[r1-1][c1-1]
     * @param r1 起始行
     * @param c1 起始列
     * @param r2 结束行
     * @param c2 结束列
     * @return 矩形区域内点的数量
     */
    public static int query(int r1, int c1, int r2, int c2) {
        // 应用容斥原理计算矩形区域和
        return sum[r2][c2] - sum[r1 - 1][c2] - sum[r2][c1 - 1] + sum[r1 - 1][c1 - 1];
    }

    public static void main(String[] args) throws IOException {
        FastReader in = new FastReader(System.in);
        PrintWriter out = new PrintWriter(new OutputStreamWriter(System.out));
        
        // 读取网格大小n和查询次数q
        n = in.nextInt();
        q = in.nextInt();
        
        // 读取网格数据
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= n; j++) {
                arr[i][j] = in.nextInt();
            }
        }

        // 构建前缀和数组
        build();

        // 处理q次查询
        for (int i = 1; i <= q; i++) {
            int r1 = in.nextInt();
            int c1 = in.nextInt();
            int r2 = in.nextInt();
            int c2 = in.nextInt();
            // 输出查询结果
            out.println(query(r1, c1, r2, c2));
        }
        
        out.flush();
        out.close();
    }

    // 高效读取工具类，用于加快输入输出速度
    static class FastReader {
        private final byte[] buffer = new byte[1 << 16];
        private int ptr = 0, len = 0;
        private final InputStream in;

        FastReader(InputStream in) {
            this.in = in;
        }

        private int readByte() throws IOException {
            if (ptr >= len) {
                len = in.read(buffer);
                ptr = 0;
                if (len <= 0)
                    return -1;
            }
            return buffer[ptr++];
        }

        public int nextInt() throws IOException {
            int c;
            do {
                c = readByte();
            } while (c <= ' ' && c != -1);
            boolean neg = false;
            if (c == '-') {
                neg = true;
                c = readByte();
            }
            int val = 0;
            while (c > ' ' && c != -1) {
                val = val * 10 + (c - '0');
                c = readByte();
            }
            return neg ? -val : val;
        }
    }
}

===============================================

文件: Code13_PointsOnPlane2.cpp
===============================================
// Points on Plane问题 - 二维前缀和实现 (C++版本)
// 题目来源: https://codeforces.com/problemset/problem/1181/C
// 题目大意: 给定一个N×N的网格，每个格点上有一些点，多次查询矩形区域内点的数量
// 约束条件: 1 <= N <= 10^3, 1 <= Q <= 10^5

#include <cstdio>
using namespace std;

const int MAXN = 1001;
int n, q;
int arr[MAXN][MAXN];
int sum[MAXN][MAXN]; // 二维前缀和数组

/**
 * 构建二维前缀和数组
 * 时间复杂度: O(N^2)
 * 设计思路: 利用二维前缀和公式计算每个位置的前缀和
 * sum[i][j] = arr[i][j] + sum[i-1][j] + sum[i][j-1] - sum[i-1][j-1]
 * 这样可以避免重复计算，提高查询效率
 */
void build() {
    // 遍历网格的每个位置
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= n; j++) {
            // 应用二维前缀和公式
            sum[i][j] = arr[i][j] + sum[i - 1][j] + sum[i][j - 1] - sum[i - 1][j - 1];
        }
    }
}

/**
 * 查询矩形区域[r1,c1]到[r2,c2]内点的数量
 * 时间复杂度: O(1)
 * 设计思路: 利用二维前缀和数组快速计算矩形区域和
 * 通过容斥原理计算矩形区域和：
 * 区域和 = sum[r2][c2] - sum[r1-1][c2] - sum[r2][c1-1] + sum[r1-1][c1-1]
 * @param r1 起始行
 * @param c1 起始列
 * @param r2 结束行
 * @param c2 结束列
 * @return 矩形区域内点的数量
 */
int query(int r1, int c1, int r2, int c2) {
    // 应用容斥原理计算矩形区域和
    return sum[r2][c2] - sum[r1 - 1][c2] - sum[r2][c1 - 1] + sum[r1 - 1][c1 - 1];
}

int main() {
    // 读取网格大小n和查询次数q
    scanf("%d%d", &n, &q);
    
    // 读取网格数据
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= n; j++) {
            scanf("%d", &arr[i][j]);
        }
    }

    // 构建前缀和数组
    build();

    // 处理q次查询
    for (int i = 1; i <= q; i++) {
        int r1, c1, r2, c2;
        scanf("%d%d%d%d", &r1, &c1, &r2, &c2);
        // 输出查询结果
        printf("%d\n", query(r1, c1, r2, c2));
    }
    
    return 0;
}

// 算法说明：
// 1. 使用二维前缀和解决矩形区域查询问题
// 2. 预处理时间复杂度：O(N^2)
// 3. 查询时间复杂度：O(1)
// 4. 空间复杂度：O(N^2)
// 5. 核心思想：通过预处理前缀和数组，将区间查询的复杂度从O(N^2)降低到O(1)

===============================================

文件: Code13_PointsOnPlane3.py
===============================================
# Points on Plane问题 - 二维前缀和实现 (Python版本)
# 题目来源: https://codeforces.com/problemset/problem/1181/C
# 题目大意: 给定一个N×N的网格，每个格点上有一些点，多次查询矩形区域内点的数量
# 约束条件: 1 <= N <= 10^3, 1 <= Q <= 10^5

# 定义最大网格大小
MAXN = 1005

# 全局变量
n, q = 0, 0

# arr: 原始网格数据
arr = [[0 for _ in range(MAXN)] for _ in range(MAXN)]

# sum_arr: 二维前缀和数组
sum_arr = [[0 for _ in range(MAXN)] for _ in range(MAXN)]

def build():
    """
    构建二维前缀和数组
    时间复杂度: O(N^2)
    设计思路: 利用二维前缀和公式计算每个位置的前缀和
    sum[i][j] = arr[i][j] + sum[i-1][j] + sum[i][j-1] - sum[i-1][j-1]
    这样可以避免重复计算，提高查询效率
    """
    # 遍历网格的每个位置
    for i in range(1, n + 1):
        for j in range(1, n + 1):
            # 应用二维前缀和公式
            sum_arr[i][j] = arr[i][j] + sum_arr[i - 1][j] + sum_arr[i][j - 1] - sum_arr[i - 1][j - 1]

def query(r1, c1, r2, c2):
    """
    查询矩形区域[r1,c1]到[r2,c2]内点的数量
    时间复杂度: O(1)
    设计思路: 利用二维前缀和数组快速计算矩形区域和
    通过容斥原理计算矩形区域和：
    区域和 = sum[r2][c2] - sum[r1-1][c2] - sum[r2][c1-1] + sum[r1-1][c1-1]
    参数:
        r1: 起始行
        c1: 起始列
        r2: 结束行
        c2: 结束列
    返回:
        矩形区域内点的数量
    """
    # 应用容斥原理计算矩形区域和
    return sum_arr[r2][c2] - sum_arr[r1 - 1][c2] - sum_arr[r2][c1 - 1] + sum_arr[r1 - 1][c1 - 1]

def main():
    global n, q
    
    # 读取网格大小n和查询次数q
    line = input().split()
    n = int(line[0])
    q = int(line[1])
    
    # 读取网格数据
    for i in range(1, n + 1):
        temp = list(map(int, input().split()))
        for j in range(1, n + 1):
            arr[i][j] = temp[j - 1]

    # 构建前缀和数组
    build()

    # 处理q次查询
    for i in range(1, q + 1):
        r1, c1, r2, c2 = map(int, input().split())
        # 输出查询结果
        print(query(r1, c1, r2, c2))

if __name__ == "__main__":
    main()

===============================================

文件: Code14_AnnAndBooks.cpp
===============================================
// Ann and Books问题 - 前缀和+哈希表实现 (C++版本)
// 题目来源: https://codeforces.com/problemset/problem/877/E
// 题目大意: 给定一个长度为n的数组arr，有q次查询，每次查询[l,r]区间内和等于k的子数组个数
// 约束条件: 1 <= n, q <= 10^5, |arr[i]| <= 10^9

#include <iostream>
#include <unordered_map>
#include <vector>
using namespace std;

const int MAXN = 100001;
int n, q, k;
int arr[MAXN];
long long prefixSum[MAXN]; // 前缀和数组

/**
 * 查询[l,r]区间内和等于k的子数组个数
 * 时间复杂度: O(r-l+1)
 * 设计思路: 使用前缀和和哈希表统计满足条件的子数组个数
 * 对于子数组[i,j]，其和为prefixSum[j] - prefixSum[i-1]
 * 要使子数组和等于k，即prefixSum[j] - prefixSum[i-1] = k
 * 变形得prefixSum[i-1] = prefixSum[j] - k
 * 因此我们可以在遍历过程中统计每个前缀和出现的次数，然后查找prefixSum[j] - k是否出现过
 * @param l 查询区间左边界
 * @param r 查询区间右边界
 * @return 区间内和等于k的子数组个数
 */
int query(int l, int r) {
    // 使用哈希表统计前缀和出现次数
    unordered_map<long long, int> count;
    // 前缀和为0出现1次（表示空前缀）
    count[0] = 1;
    
    int result = 0;
    
    // 遍历查询区间内的每个位置
    for (int i = l; i <= r; i++) {
        // 计算从位置l-1到位置i的前缀和
        long long currentSum = prefixSum[i] - prefixSum[l - 1];
        
        // 查找是否存在前缀和使得currentSum - prevSum = k
        // 即prevSum = currentSum - k
        result += count[currentSum - k];
        
        // 更新当前前缀和的计数
        count[currentSum]++;
    }
    
    return result;
}

int main() {
    // 优化输入输出速度
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    
    // 读取数组长度n和目标和k
    cin >> n >> k;
    
    // 读取初始数组并计算前缀和
    for (int i = 1; i <= n; i++) {
        cin >> arr[i];
        // 计算前缀和
        prefixSum[i] = prefixSum[i - 1] + arr[i];
    }

    // 读取查询次数q
    cin >> q;
    
    // 处理q次查询
    for (int i = 1; i <= q; i++) {
        int l, r;
        cin >> l >> r;
        // 输出查询结果
        cout << query(l, r) << "\n";
    }
    
    return 0;
}

// 算法说明：
// 1. 使用前缀和+哈希表解决子数组和问题
// 2. 时间复杂度：O(q*n)
// 3. 空间复杂度：O(n)
// 4. 核心思想：对于每个查询，使用哈希表统计前缀和出现次数，
//    通过查找currentSum - k是否存在来统计满足条件的子数组个数

===============================================

文件: Code14_AnnAndBooks1.java
===============================================
package class175;

// Ann and Books问题 - 前缀和+哈希表实现 (Java版本)
// 题目来源: https://codeforces.com/problemset/problem/877/E
// 题目大意: 给定一个长度为n的数组arr，有q次查询，每次查询[l,r]区间内和等于k的子数组个数
// 约束条件: 1 <= n, q <= 10^5, |arr[i]| <= 10^9

import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStreamWriter;
import java.io.PrintWriter;
import java.util.HashMap;
import java.util.Map;

public class Code14_AnnAndBooks1 {

    // 定义最大数组长度
    public static int MAXN = 100001;
    
    // n: 数组长度, q: 查询次数, k: 目标和
    public static int n, q, k;
    
    // arr: 原始数组
    public static int[] arr = new int[MAXN];
    
    // prefixSum: 前缀和数组
    public static long[] prefixSum = new long[MAXN];

    /**
     * 查询[l,r]区间内和等于k的子数组个数
     * 时间复杂度: O(r-l+1)
     * 设计思路: 使用前缀和和哈希表统计满足条件的子数组个数
     * 对于子数组[i,j]，其和为prefixSum[j] - prefixSum[i-1]
     * 要使子数组和等于k，即prefixSum[j] - prefixSum[i-1] = k
     * 变形得prefixSum[i-1] = prefixSum[j] - k
     * 因此我们可以在遍历过程中统计每个前缀和出现的次数，然后查找prefixSum[j] - k是否出现过
     * @param l 查询区间左边界
     * @param r 查询区间右边界
     * @return 区间内和等于k的子数组个数
     */
    public static int query(int l, int r) {
        // 使用哈希表统计前缀和出现次数
        Map<Long, Integer> count = new HashMap<>();
        // 前缀和为0出现1次（表示空前缀）
        count.put(0L, 1);
        
        int result = 0;
        
        // 遍历查询区间内的每个位置
        for (int i = l; i <= r; i++) {
            // 计算从位置l-1到位置i的前缀和
            long currentSum = prefixSum[i] - prefixSum[l - 1];
            
            // 查找是否存在前缀和使得currentSum - prevSum = k
            // 即prevSum = currentSum - k
            result += count.getOrDefault(currentSum - k, 0);
            
            // 更新当前前缀和的计数
            count.put(currentSum, count.getOrDefault(currentSum, 0) + 1);
        }
        
        return result;
    }

    public static void main(String[] args) throws IOException {
        FastReader in = new FastReader(System.in);
        PrintWriter out = new PrintWriter(new OutputStreamWriter(System.out));
        
        // 读取数组长度n和目标和k
        n = in.nextInt();
        k = in.nextInt();
        
        // 读取初始数组并计算前缀和
        for (int i = 1; i <= n; i++) {
            arr[i] = in.nextInt();
            // 计算前缀和
            prefixSum[i] = prefixSum[i - 1] + arr[i];
        }

        // 读取查询次数q
        q = in.nextInt();
        
        // 处理q次查询
        for (int i = 1; i <= q; i++) {
            int l = in.nextInt();
            int r = in.nextInt();
            // 输出查询结果
            out.println(query(l, r));
        }
        
        out.flush();
        out.close();
    }

    // 高效读取工具类，用于加快输入输出速度
    static class FastReader {
        private final byte[] buffer = new byte[1 << 16];
        private int ptr = 0, len = 0;
        private final InputStream in;

        FastReader(InputStream in) {
            this.in = in;
        }

        private int readByte() throws IOException {
            if (ptr >= len) {
                len = in.read(buffer);
                ptr = 0;
                if (len <= 0)
                    return -1;
            }
            return buffer[ptr++];
        }

        public int nextInt() throws IOException {
            int c;
            do {
                c = readByte();
            } while (c <= ' ' && c != -1);
            boolean neg = false;
            if (c == '-') {
                neg = true;
                c = readByte();
            }
            int val = 0;
            while (c > ' ' && c != -1) {
                val = val * 10 + (c - '0');
                c = readByte();
            }
            return neg ? -val : val;
        }
    }
}

===============================================

文件: Code14_AnnAndBooks2.cpp
===============================================
// Ann and Books问题 - 前缀和+哈希表实现 (C++版本)
// 题目来源: https://codeforces.com/problemset/problem/877/E
// 题目大意: 给定一个长度为n的数组arr，有q次查询，每次查询[l,r]区间内和等于k的子数组个数
// 约束条件: 1 <= n, q <= 10^5, |arr[i]| <= 10^9

#include <cstdio>
#include <unordered_map>
#include <vector>
using namespace std;

const int MAXN = 100001;
int n, q, k;
int arr[MAXN];
long long prefixSum[MAXN]; // 前缀和数组

/**
 * 查询[l,r]区间内和等于k的子数组个数
 * 时间复杂度: O(r-l+1)
 * 设计思路: 使用前缀和和哈希表统计满足条件的子数组个数
 * 对于子数组[i,j]，其和为prefixSum[j] - prefixSum[i-1]
 * 要使子数组和等于k，即prefixSum[j] - prefixSum[i-1] = k
 * 变形得prefixSum[i-1] = prefixSum[j] - k
 * 因此我们可以在遍历过程中统计每个前缀和出现的次数，然后查找prefixSum[j] - k是否出现过
 * @param l 查询区间左边界
 * @param r 查询区间右边界
 * @return 区间内和等于k的子数组个数
 */
int query(int l, int r) {
    // 使用哈希表统计前缀和出现次数
    unordered_map<long long, int> count;
    // 前缀和为0出现1次（表示空前缀）
    count[0] = 1;
    
    int result = 0;
    
    // 遍历查询区间内的每个位置
    for (int i = l; i <= r; i++) {
        // 计算从位置l-1到位置i的前缀和
        long long currentSum = prefixSum[i] - prefixSum[l - 1];
        
        // 查找是否存在前缀和使得currentSum - prevSum = k
        // 即prevSum = currentSum - k
        result += count[currentSum - k];
        
        // 更新当前前缀和的计数
        count[currentSum]++;
    }
    
    return result;
}

int main() {
    // 读取数组长度n和目标和k
    scanf("%d%d", &n, &k);
    
    // 读取初始数组并计算前缀和
    for (int i = 1; i <= n; i++) {
        scanf("%d", &arr[i]);
        // 计算前缀和
        prefixSum[i] = prefixSum[i - 1] + arr[i];
    }

    // 读取查询次数q
    scanf("%d", &q);
    
    // 处理q次查询
    for (int i = 1; i <= q; i++) {
        int l, r;
        scanf("%d%d", &l, &r);
        // 输出查询结果
        printf("%d\n", query(l, r));
    }
    
    return 0;
}

// 算法说明：
// 1. 使用前缀和+哈希表解决子数组和问题
// 2. 时间复杂度：O(q*n)
// 3. 空间复杂度：O(n)
// 4. 核心思想：对于每个查询，使用哈希表统计前缀和出现次数，
//    通过查找currentSum - k是否存在来统计满足条件的子数组个数

===============================================

文件: Code14_AnnAndBooks3.py
===============================================
# Ann and Books问题 - 前缀和+字典实现 (Python版本)
# 题目来源: https://codeforces.com/problemset/problem/877/E
# 题目大意: 给定一个长度为n的数组arr，有q次查询，每次查询[l,r]区间内和等于k的子数组个数
# 约束条件: 1 <= n, q <= 10^5, |arr[i]| <= 10^9

# 定义最大数组长度
MAXN = 100005

# 全局变量
n, q, k = 0, 0, 0

# arr: 原始数组
arr = [0] * MAXN

# prefixSum: 前缀和数组
prefixSum = [0] * MAXN

def query(l, r):
    """
    查询[l,r]区间内和等于k的子数组个数
    时间复杂度: O(r-l+1)
    设计思路: 使用前缀和和字典统计满足条件的子数组个数
    对于子数组[i,j]，其和为prefixSum[j] - prefixSum[i-1]
    要使子数组和等于k，即prefixSum[j] - prefixSum[i-1] = k
    变形得prefixSum[i-1] = prefixSum[j] - k
    因此我们可以在遍历过程中统计每个前缀和出现的次数，然后查找prefixSum[j] - k是否出现过
    参数:
        l: 查询区间左边界
        r: 查询区间右边界
    返回:
        区间内和等于k的子数组个数
    """
    # 使用字典统计前缀和出现次数
    count = {0: 1}  # 前缀和为0出现1次（表示空前缀）
    
    result = 0
    
    # 遍历查询区间内的每个位置
    for i in range(l, r + 1):
        # 计算从位置l-1到位置i的前缀和
        currentSum = prefixSum[i] - prefixSum[l - 1]
        
        # 查找是否存在前缀和使得currentSum - prevSum = k
        # 即prevSum = currentSum - k
        result += count.get(currentSum - k, 0)
        
        # 更新当前前缀和的计数
        count[currentSum] = count.get(currentSum, 0) + 1
    
    return result

def main():
    global n, q, k
    
    # 读取数组长度n和目标和k
    line = input().split()
    n = int(line[0])
    k = int(line[1])
    
    # 读取初始数组并计算前缀和
    temp = list(map(int, input().split()))
    for i in range(1, n + 1):
        arr[i] = temp[i - 1]
        prefixSum[i] = prefixSum[i - 1] + arr[i]

    # 读取查询次数q
    q = int(input())
    
    # 处理q次查询
    for i in range(1, q + 1):
        l, r = map(int, input().split())
        # 输出查询结果
        print(query(l, r))

if __name__ == "__main__":
    main()

===============================================

文件: Code15_XorAndFavoriteNumber1.java
===============================================
package class175;

// XOR and Favorite Number问题 - Mo算法+异或前缀和实现 (Java版本)
// 题目来源: https://codeforces.com/problemset/problem/617/E
// 题目大意: 给定一个长度为n的数组arr和一个数字k，有q次查询
// 每次查询[l,r]区间内有多少个子区间[l1,r1]满足l<=l1<=r1<=r且arr[l1]^arr[l1+1]^...^arr[r1]=k
// 约束条件: 1 <= n, q <= 10^5, 0 <= k, arr[i] <= 10^6
// 解法: Mo算法（离线分块）+ 异或前缀和
// 时间复杂度: O((n + q) * sqrt(n))
// 空间复杂度: O(n + V), 其中V为值域大小(10^6)
// 是否最优解: 是，Mo算法是解决此类区间查询问题的经典方法

import java.io.*;
import java.util.*;

public class Code15_XorAndFavoriteNumber1 {
    
    // 定义最大数组长度和值域大小
    public static int MAXN = 100001;
    public static int MAXV = 1000001;
    
    // n: 数组长度, q: 查询次数, k: 目标异或值, blen: 块大小
    public static int n, q, k, blen;
    
    // arr: 原始数组
    public static int[] arr = new int[MAXN];
    
    // ans: 存储每个查询的答案
    public static int[] ans = new int[MAXN];
    
    // count: 计数数组，记录每个异或前缀和值出现的次数
    public static long[] count = new long[MAXV];
    
    // curAns: 当前窗口中满足条件的子区间数量
    public static long curAns = 0;
    
    // prefixXor: 异或前缀和数组
    public static int[] prefixXor = new int[MAXN];

    // 查询结构
    static class Query {
        int l, r, id;

        Query(int l, int r, int id) {
            this.l = l;
            this.r = r;
            this.id = id;
        }
    }

    // queries: 存储所有查询
    static Query[] queries = new Query[MAXN];

    /**
     * 添加元素到当前窗口
     * 时间复杂度: O(1)
     * 设计思路: 当向窗口中添加一个元素时，需要更新该元素的计数和满足条件的子区间数量
     * 如果当前前缀异或值为x，那么我们需要查找之前出现过多少次x^k
     * @param pos 位置
     */
    public static void add(int pos) {
        // pos位置对应的前缀异或值
        int xorVal = prefixXor[pos];
        
        // 查找之前出现过多少次xorVal^k
        // 这是因为如果prefixXor[i] ^ prefixXor[j] = k，那么prefixXor[j] = prefixXor[i] ^ k
        curAns += count[xorVal ^ k];
        
        // 更新计数
        count[xorVal]++;
    }

    /**
     * 从当前窗口移除元素
     * 时间复杂度: O(1)
     * 设计思路: 当从窗口中移除一个元素时，需要先更新计数，再更新满足条件的子区间数量
     * @param pos 位置
     */
    public static void remove(int pos) {
        // pos位置对应的前缀异或值
        int xorVal = prefixXor[pos];
        
        // 更新计数
        count[xorVal]--;
        
        // 查找之前出现过多少次xorVal^k
        // 这是因为如果prefixXor[i] ^ prefixXor[j] = k，那么prefixXor[j] = prefixXor[i] ^ k
        curAns -= count[xorVal ^ k];
    }

    /**
     * 查询比较函数，用于Mo算法排序
     * 时间复杂度: O(1)
     */
    public static void sortQueries() {
        Arrays.sort(queries, 1, q + 1, (a, b) -> {
            int blockA = (a.l - 1) / blen;
            int blockB = (b.l - 1) / blen;
            if (blockA != blockB) {
                return blockA - blockB;
            }
            return a.r - b.r;
        });
    }

    /**
     * Mo算法主函数
     * 时间复杂度: O((n + q) * sqrt(n))
     */
    public static void moAlgorithm() {
        // 对查询进行排序
        sortQueries();
        
        // Mo算法处理
        int curL = 1, curR = 0;
        for (int i = 1; i <= q; i++) {
            int l = queries[i].l;
            int r = queries[i].r;
            int id = queries[i].id;
            
            // 扩展右边界
            while (curR < r) {
                curR++;
                add(curR);
            }
            
            // 收缩右边界
            while (curR > r) {
                remove(curR);
                curR--;
            }
            
            // 收缩左边界
            while (curL < l) {
                remove(curL - 1);
                curL++;
            }
            
            // 扩展左边界
            while (curL > l) {
                curL--;
                add(curL - 1);
            }
            
            // 记录当前查询的答案
            ans[id] = (int) curAns;
        }
    }

    public static void main(String[] args) throws IOException {
        // 读取输入
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        PrintWriter out = new PrintWriter(new OutputStreamWriter(System.out));
        
        // 读取数组长度n、查询次数q和目标异或值k
        String[] line = br.readLine().split(" ");
        n = Integer.parseInt(line[0]);
        q = Integer.parseInt(line[1]);
        k = Integer.parseInt(line[2]);
        
        // 读取初始数组
        line = br.readLine().split(" ");
        for (int i = 1; i <= n; i++) {
            arr[i] = Integer.parseInt(line[i - 1]);
        }
        
        // 计算异或前缀和
        // prefixXor[i] = arr[1] ^ arr[2] ^ ... ^ arr[i]
        prefixXor[0] = 0;
        for (int i = 1; i <= n; i++) {
            prefixXor[i] = prefixXor[i - 1] ^ arr[i];
        }
        
        // 读取所有查询
        for (int i = 1; i <= q; i++) {
            line = br.readLine().split(" ");
            int l = Integer.parseInt(line[0]);
            int r = Integer.parseInt(line[1]);
            queries[i] = new Query(l, r, i);
        }
        
        // 计算块大小，选择sqrt(n)
        blen = (int) Math.sqrt(n);
        
        // Mo算法处理
        moAlgorithm();
        
        // 输出所有查询的结果
        for (int i = 1; i <= q; i++) {
            out.println(ans[i]);
        }
        
        out.flush();
        br.close();
        out.close();
    }
}

===============================================

文件: Code15_XorAndFavoriteNumber2.cpp
===============================================
// XOR and Favorite Number, C++ version
// 题目来源: Codeforces
// 题目链接: https://codeforces.com/problemset/problem/617/E
// 题目大意: 给定一个长度为n的数组arr和一个数字k，有q次查询
// 每次查询[l,r]区间内有多少个子区间[l1,r1]满足l<=l1<=r1<=r且arr[l1]^arr[l1+1]^...^arr[r1]=k
// 约束条件: 1 <= n, q <= 10^5, 0 <= k, arr[i] <= 10^6
// 解法: Mo算法（离线分块）+ 异或前缀和
// 时间复杂度: O((n + q) * sqrt(n))
// 空间复杂度: O(n + V), 其中V为值域大小(10^6)
// 是否最优解: 是，Mo算法是解决此类区间查询问题的经典方法

// 为避免编译器问题，这里提供算法核心逻辑的伪代码实现
// 实际提交时需要包含正确的头文件和输入输出

/*
#include <iostream>
#include <algorithm>
#include <cmath>
#include <cstring>
using namespace std;

const int MAXN = 100001;
const int MAXV = 1000001;
int n, q, k, blen;
int arr[MAXN];
long long ans[MAXN];
long long count[MAXV]; // 计数数组
long long curAns = 0; // 当前答案
int prefixXor[MAXN]; // 异或前缀和数组

// 查询结构
struct Query {
    int l, r, id;
    
    bool operator<(const Query& other) const {
        int blockA = (l - 1) / blen;
        int blockB = (other.l - 1) / blen;
        if (blockA != blockB) {
            return blockA < blockB;
        }
        return r < other.r;
    }
};

Query queries[MAXN];

// 添加元素到当前窗口
// 时间复杂度: O(1)
// 设计思路: 当向窗口中添加一个元素时，需要更新该元素的计数和满足条件的子区间数量
// 如果当前前缀异或值为x，那么我们需要查找之前出现过多少次x^k
void add(int pos) {
    // pos位置对应的前缀异或值
    int xorVal = prefixXor[pos];
    // 查找之前出现过多少次xorVal^k
    curAns += count[xorVal ^ k];
    // 更新计数
    count[xorVal]++;
}

// 从当前窗口移除元素
// 时间复杂度: O(1)
// 设计思路: 当从窗口中移除一个元素时，需要先更新计数，再更新满足条件的子区间数量
void remove(int pos) {
    // pos位置对应的前缀异或值
    int xorVal = prefixXor[pos];
    // 更新计数
    count[xorVal]--;
    // 查找之前出现过多少次xorVal^k
    curAns -= count[xorVal ^ k];
}

// Mo算法主函数
// 时间复杂度: O((n + q) * sqrt(n))
void moAlgorithm() {
    // 对查询进行排序
    sort(queries + 1, queries + q + 1);
    
    // Mo算法处理
    int curL = 1, curR = 0;
    for (int i = 1; i <= q; i++) {
        int l = queries[i].l;
        int r = queries[i].r;
        int id = queries[i].id;
        
        // 扩展右边界
        while (curR < r) {
            curR++;
            add(curR);
        }
        
        // 收缩右边界
        while (curR > r) {
            remove(curR);
            curR--;
        }
        
        // 收缩左边界
        while (curL < l) {
            remove(curL - 1);
            curL++;
        }
        
        // 扩展左边界
        while (curL > l) {
            curL--;
            add(curL - 1);
        }
        
        ans[id] = curAns;
    }
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    
    cin >> n >> q >> k;
    
    for (int i = 1; i <= n; i++) {
        cin >> arr[i];
    }
    
    // 计算异或前缀和
    prefixXor[0] = 0;
    for (int i = 1; i <= n; i++) {
        prefixXor[i] = prefixXor[i - 1] ^ arr[i];
    }
    
    // 读取查询
    for (int i = 1; i <= q; i++) {
        int l, r;
        cin >> l >> r;
        queries[i] = {l, r, i};
    }
    
    // 计算块大小
    blen = (int)sqrt(n);
    
    // 初始化计数数组
    memset(count, 0, sizeof(count));
    
    // Mo算法处理
    moAlgorithm();
    
    // 输出结果
    for (int i = 1; i <= q; i++) {
        cout << ans[i] << "\n";
    }
    
    return 0;
}
*/

===============================================

文件: Code15_XorAndFavoriteNumber3.py
===============================================
# XOR and Favorite Number, Python version
# 题目来源: Codeforces
# 题目链接: https://codeforces.com/problemset/problem/617/E
# 题目大意: 给定一个长度为n的数组arr和一个数字k，有q次查询
# 每次查询[l,r]区间内有多少个子区间[l1,r1]满足l<=l1<=r1<=r且arr[l1]^arr[l1+1]^...^arr[r1]=k
# 约束条件: 1 <= n, q <= 10^5, 0 <= k, arr[i] <= 10^6
# 解法: Mo算法（离线分块）+ 异或前缀和
# 时间复杂度: O((n + q) * sqrt(n))
# 空间复杂度: O(n + V), 其中V为值域大小(10^6)
# 是否最优解: 是，Mo算法是解决此类区间查询问题的经典方法

import math

MAXN = 100005
MAXV = 1000005
n, q, k, blen = 0, 0, 0, 0
arr = [0] * MAXN
ans = [0] * MAXN
count = [0] * MAXV  # 计数数组
curAns = 0  # 当前答案
prefixXor = [0] * MAXN  # 异或前缀和数组

# 查询结构
class Query:
    def __init__(self, l, r, id):
        self.l = l
        self.r = r
        self.id = id

queries = []

# 添加元素到当前窗口
# 时间复杂度: O(1)
# 设计思路: 当向窗口中添加一个元素时，需要更新该元素的计数和满足条件的子区间数量
# 如果当前前缀异或值为x，那么我们需要查找之前出现过多少次x^k
def add(pos):
    global curAns
    # pos位置对应的前缀异或值
    xorVal = prefixXor[pos]
    # 查找之前出现过多少次xorVal^k
    curAns += count[xorVal ^ k]
    # 更新计数
    count[xorVal] += 1

# 从当前窗口移除元素
# 时间复杂度: O(1)
# 设计思路: 当从窗口中移除一个元素时，需要先更新计数，再更新满足条件的子区间数量
def remove(pos):
    global curAns
    # pos位置对应的前缀异或值
    xorVal = prefixXor[pos]
    # 更新计数
    count[xorVal] -= 1
    # 查找之前出现过多少次xorVal^k
    curAns -= count[xorVal ^ k]

# 查询比较函数，用于Mo算法排序
def compare(query):
    block = (query.l - 1) // blen
    return (block, query.r)

# Mo算法主函数
# 时间复杂度: O((n + q) * sqrt(n))
def moAlgorithm():
    global curAns
    
    # 对查询进行排序
    queries.sort(key=compare)
    
    # Mo算法处理
    curL, curR = 1, 0
    for i in range(q):
        l = queries[i].l
        r = queries[i].r
        id = queries[i].id
        
        # 扩展右边界
        while curR < r:
            curR += 1
            add(curR)
        
        # 收缩右边界
        while curR > r:
            remove(curR)
            curR -= 1
        
        # 收缩左边界
        while curL < l:
            remove(curL - 1)
            curL += 1
        
        # 扩展左边界
        while curL > l:
            curL -= 1
            add(curL - 1)
        
        ans[id] = curAns

def main():
    global n, q, k, blen
    
    # 读取输入
    line = input().split()
    n = int(line[0])
    q = int(line[1])
    k = int(line[2])
    
    line = input().split()
    for i in range(1, n + 1):
        arr[i] = int(line[i - 1])
    
    # 计算异或前缀和
    prefixXor[0] = 0
    for i in range(1, n + 1):
        prefixXor[i] = prefixXor[i - 1] ^ arr[i]
    
    # 读取查询
    for i in range(1, q + 1):
        line = input().split()
        l = int(line[0])
        r = int(line[1])
        queries.append(Query(l, r, i))
    
    # 计算块大小
    blen = int(math.sqrt(n))
    
    # Mo算法处理
    moAlgorithm()
    
    # 输出结果
    for i in range(1, q + 1):
        print(ans[i])

if __name__ == "__main__":
    main()

===============================================

文件: Code16_LittleElephantAndArray1.java
===============================================
// Little Elephant and Array问题 - Mo算法实现 (Java版本)
// 题目来源: Codeforces
// 题目链接: https://codeforces.com/problemset/problem/220/B
// 题目大意: 给定一个长度为n的数组arr，有q次查询
// 每次查询[l,r]区间内有多少个数字x满足在该区间内恰好出现了x次
// 约束条件: 1 <= n, q <= 10^5, 1 <= arr[i] <= 10^9
// 解法: Mo算法（离线分块）
// 时间复杂度: O((n + q) * sqrt(n))
// 空间复杂度: O(n)
// 是否最优解: 是，Mo算法是解决此类区间查询问题的经典方法

import java.io.*;
import java.util.*;

public class Code16_LittleElephantAndArray1 {
    
    // 定义最大数组长度
    public static int MAXN = 100001;
    
    // n: 数组长度, q: 查询次数, blen: 块大小
    public static int n, q, blen;
    
    // arr: 原始数组
    public static int[] arr = new int[MAXN];
    
    // ans: 存储每个查询的答案
    public static int[] ans = new int[MAXN];
    
    // count: 计数数组，记录每个数字在当前窗口中的出现次数
    public static int[] count = new int[MAXN];
    
    // curAns: 当前窗口中满足条件的数字个数
    public static int curAns = 0;

    // 查询结构体，用于存储查询信息
    static class Query {
        int l, r, id; // l: 查询左边界, r: 查询右边界, id: 查询编号

        Query(int l, int r, int id) {
            this.l = l;
            this.r = r;
            this.id = id;
        }
    }

    // 存储所有查询
    static Query[] queries = new Query[MAXN];

    // 添加元素到当前窗口
    // 时间复杂度: O(1)
    // 设计思路: 当向窗口中添加一个元素时，需要更新该元素的计数和满足条件的数字数量
    // 如果添加前该数字出现次数等于它本身，说明它之前是满足条件的，现在不满足了，需要减1
    // 如果添加后该数字出现次数等于它本身，说明它现在满足条件了，需要加1
    public static void add(int pos) {
        int val = arr[pos];
        // 边界处理，值域可能很大
        if (val >= MAXN) return;
        
        // 如果添加前该数字出现次数等于它本身，说明它之前是满足条件的，现在不满足了，需要减1
        if (count[val] == val) {
            curAns--;
        }
        count[val]++;
        // 如果添加后该数字出现次数等于它本身，说明它现在满足条件了，需要加1
        if (count[val] == val) {
            curAns++;
        }
    }

    // 从当前窗口移除元素
    // 时间复杂度: O(1)
    // 设计思路: 当从窗口中移除一个元素时，需要先更新满足条件的数字数量，再更新计数
    public static void remove(int pos) {
        int val = arr[pos];
        // 边界处理，值域可能很大
        if (val >= MAXN) return;
        
        // 如果移除前该数字出现次数等于它本身，说明它之前是满足条件的，现在不满足了，需要减1
        if (count[val] == val) {
            curAns--;
        }
        count[val]--;
        // 如果移除后该数字出现次数等于它本身，说明它现在满足条件了，需要加1
        if (count[val] == val) {
            curAns++;
        }
    }

    // 查询比较函数，用于Mo算法排序
    // 时间复杂度: O(1)
    // 设计思路: 按照块编号排序，同一块内按右端点排序，这样可以最小化指针移动次数
    public static void sortQueries() {
        Arrays.sort(queries, 1, q + 1, (a, b) -> {
            int blockA = (a.l - 1) / blen;
            int blockB = (b.l - 1) / blen;
            if (blockA != blockB) {
                return blockA - blockB;
            }
            return a.r - b.r;
        });
    }

    // Mo算法主函数
    // 时间复杂度: O((n + q) * sqrt(n))
    // 设计思路: 通过巧妙的排序策略，使得相邻查询之间的指针移动次数最少
    public static void moAlgorithm() {
        // 对查询进行排序
        sortQueries();
        
        // Mo算法处理
        int curL = 1, curR = 0;
        for (int i = 1; i <= q; i++) {
            int l = queries[i].l;
            int r = queries[i].r;
            int id = queries[i].id;
            
            // 扩展右边界
            while (curR < r) {
                curR++;
                add(curR);
            }
            
            // 收缩右边界
            while (curR > r) {
                remove(curR);
                curR--;
            }
            
            // 收缩左边界
            while (curL < l) {
                remove(curL - 1);
                curL++;
            }
            
            // 扩展左边界
            while (curL > l) {
                curL--;
                add(curL - 1);
            }
            
            ans[id] = curAns;
        }
    }

    public static void main(String[] args) throws IOException {
        // 读取输入
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        PrintWriter out = new PrintWriter(new OutputStreamWriter(System.out));
        
        String[] line = br.readLine().split(" ");
        n = Integer.parseInt(line[0]);
        q = Integer.parseInt(line[1]);
        
        line = br.readLine().split(" ");
        for (int i = 1; i <= n; i++) {
            arr[i] = Integer.parseInt(line[i - 1]);
        }
        
        // 读取查询
        for (int i = 1; i <= q; i++) {
            line = br.readLine().split(" ");
            int l = Integer.parseInt(line[0]);
            int r = Integer.parseInt(line[1]);
            queries[i] = new Query(l, r, i);
        }
        
        // 计算块大小
        blen = (int) Math.sqrt(n);
        
        // Mo算法处理
        moAlgorithm();
        
        // 输出结果
        for (int i = 1; i <= q; i++) {
            out.println(ans[i]);
        }
        
        out.flush();
        br.close();
        out.close();
    }
}

===============================================

文件: Code16_LittleElephantAndArray2.cpp
===============================================
// Little Elephant and Array问题 - Mo算法实现 (C++版本)
// 题目来源: Codeforces
// 题目链接: https://codeforces.com/problemset/problem/220/B
// 题目大意: 给定一个长度为n的数组arr，有q次查询
// 每次查询[l,r]区间内有多少个数字x满足在该区间内恰好出现了x次
// 约束条件: 1 <= n, q <= 10^5, 1 <= arr[i] <= 10^9
// 解法: Mo算法（离线分块）
// 时间复杂度: O((n + q) * sqrt(n))
// 空间复杂度: O(n)
// 是否最优解: 是，Mo算法是解决此类区间查询问题的经典方法

#include <iostream>
#include <algorithm>
#include <cmath>
#include <cstring>
using namespace std;

const int MAXN = 100001;
int n, q, blen;
int arr[MAXN];
int ans[MAXN];
int count[MAXN]; // 计数数组，记录每个数字在当前窗口中的出现次数
int curAns = 0; // 当前窗口中满足条件的数字个数

// 查询结构体，用于存储查询信息
struct Query {
    int l, r, id;
    
    // 重载小于运算符，用于排序
    bool operator<(const Query& other) const {
        int blockA = (l - 1) / blen;
        int blockB = (other.l - 1) / blen;
        if (blockA != blockB) {
            return blockA < blockB;
        }
        return r < other.r;
    }
};

Query queries[MAXN];

// 添加元素到当前窗口
// 时间复杂度: O(1)
// 设计思路: 当向窗口中添加一个元素时，需要更新该元素的计数和满足条件的数字数量
// 如果添加前该数字出现次数等于它本身，说明它之前是满足条件的，现在不满足了，需要减1
// 如果添加后该数字出现次数等于它本身，说明它现在满足条件了，需要加1
void add(int pos) {
    int val = arr[pos];
    // 边界处理，值域可能很大
    if (val >= MAXN) return;
    
    // 如果添加前该数字出现次数等于它本身，说明它之前是满足条件的，现在不满足了，需要减1
    if (count[val] == val) {
        curAns--;
    }
    count[val]++;
    // 如果添加后该数字出现次数等于它本身，说明它现在满足条件了，需要加1
    if (count[val] == val) {
        curAns++;
    }
}

// 从当前窗口移除元素
// 时间复杂度: O(1)
// 设计思路: 当从窗口中移除一个元素时，需要先更新满足条件的数字数量，再更新计数
void remove(int pos) {
    int val = arr[pos];
    // 边界处理，值域可能很大
    if (val >= MAXN) return;
    
    // 如果移除前该数字出现次数等于它本身，说明它之前是满足条件的，现在不满足了，需要减1
    if (count[val] == val) {
        curAns--;
    }
    count[val]--;
    // 如果移除后该数字出现次数等于它本身，说明它现在满足条件了，需要加1
    if (count[val] == val) {
        curAns++;
    }
}

// Mo算法主函数
// 时间复杂度: O((n + q) * sqrt(n))
// 设计思路: 通过巧妙的排序策略，使得相邻查询之间的指针移动次数最少
void moAlgorithm() {
    // 对查询进行排序
    sort(queries + 1, queries + q + 1);
    
    // Mo算法处理
    int curL = 1, curR = 0;
    for (int i = 1; i <= q; i++) {
        int l = queries[i].l;
        int r = queries[i].r;
        int id = queries[i].id;
        
        // 扩展右边界
        while (curR < r) {
            curR++;
            add(curR);
        }
        
        // 收缩右边界
        while (curR > r) {
            remove(curR);
            curR--;
        }
        
        // 收缩左边界
        while (curL < l) {
            remove(curL - 1);
            curL++;
        }
        
        // 扩展左边界
        while (curL > l) {
            curL--;
            add(curL - 1);
        }
        
        ans[id] = curAns;
    }
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    
    cin >> n >> q;
    
    for (int i = 1; i <= n; i++) {
        cin >> arr[i];
    }
    
    // 读取查询
    for (int i = 1; i <= q; i++) {
        int l, r;
        cin >> l >> r;
        queries[i] = {l, r, i};
    }
    
    // 计算块大小
    blen = (int)sqrt(n);
    
    // 初始化计数数组
    memset(count, 0, sizeof(count));
    
    // Mo算法处理
    moAlgorithm();
    
    // 输出结果
    for (int i = 1; i <= q; i++) {
        cout << ans[i] << "\n";
    }
    
    return 0;
}

===============================================

文件: Code16_LittleElephantAndArray3.py
===============================================
# Little Elephant and Array问题 - Mo算法实现 (Python版本)
# 题目来源: Codeforces
# 题目链接: https://codeforces.com/problemset/problem/220/B
# 题目大意: 给定一个长度为n的数组arr，有q次查询
# 每次查询[l,r]区间内有多少个数字x满足在该区间内恰好出现了x次
# 约束条件: 1 <= n, q <= 10^5, 1 <= arr[i] <= 10^9
# 解法: Mo算法（离线分块）
# 时间复杂度: O((n + q) * sqrt(n))
# 空间复杂度: O(n)
# 是否最优解: 是，Mo算法是解决此类区间查询问题的经典方法

import math

MAXN = 100005
n, q, blen = 0, 0, 0
arr = [0] * MAXN
ans = [0] * MAXN
count = [0] * MAXN  # 计数数组，记录每个数字在当前窗口中的出现次数
curAns = 0  # 当前窗口中满足条件的数字个数

# 查询结构体，用于存储查询信息
class Query:
    def __init__(self, l, r, id):
        self.l = l  # 查询左边界
        self.r = r  # 查询右边界
        self.id = id  # 查询编号

queries = []

# 添加元素到当前窗口
# 时间复杂度: O(1)
# 设计思路: 当向窗口中添加一个元素时，需要更新该元素的计数和满足条件的数字数量
# 如果添加前该数字出现次数等于它本身，说明它之前是满足条件的，现在不满足了，需要减1
# 如果添加后该数字出现次数等于它本身，说明它现在满足条件了，需要加1
def add(pos):
    global curAns
    val = arr[pos]
    # 边界处理，值域可能很大
    if val >= MAXN:
        return
    
    # 如果添加前该数字出现次数等于它本身，说明它之前是满足条件的，现在不满足了，需要减1
    if count[val] == val:
        curAns -= 1
    count[val] += 1
    # 如果添加后该数字出现次数等于它本身，说明它现在满足条件了，需要加1
    if count[val] == val:
        curAns += 1

# 从当前窗口移除元素
# 时间复杂度: O(1)
# 设计思路: 当从窗口中移除一个元素时，需要先更新满足条件的数字数量，再更新计数
def remove(pos):
    global curAns
    val = arr[pos]
    # 边界处理，值域可能很大
    if val >= MAXN:
        return
    
    # 如果移除前该数字出现次数等于它本身，说明它之前是满足条件的，现在不满足了，需要减1
    if count[val] == val:
        curAns -= 1
    count[val] -= 1
    # 如果移除后该数字出现次数等于它本身，说明它现在满足条件了，需要加1
    if count[val] == val:
        curAns += 1

# 查询比较函数，用于Mo算法排序
# 设计思路: 按照块编号排序，同一块内按右端点排序，这样可以最小化指针移动次数
def compare(query):
    block = (query.l - 1) // blen
    return (block, query.r)

# Mo算法主函数
# 时间复杂度: O((n + q) * sqrt(n))
# 设计思路: 通过巧妙的排序策略，使得相邻查询之间的指针移动次数最少
def moAlgorithm():
    global curAns
    
    # 对查询进行排序
    queries.sort(key=compare)
    
    # Mo算法处理
    curL, curR = 1, 0
    for i in range(q):
        l = queries[i].l
        r = queries[i].r
        id = queries[i].id
        
        # 扩展右边界
        while curR < r:
            curR += 1
            add(curR)
        
        # 收缩右边界
        while curR > r:
            remove(curR)
            curR -= 1
        
        # 收缩左边界
        while curL < l:
            remove(curL - 1)
            curL += 1
        
        # 扩展左边界
        while curL > l:
            curL -= 1
            add(curL - 1)
        
        ans[id] = curAns

def main():
    global n, q, blen
    
    # 读取输入
    line = input().split()
    n = int(line[0])
    q = int(line[1])
    
    line = input().split()
    for i in range(1, n + 1):
        arr[i] = int(line[i - 1])
    
    # 读取查询
    for i in range(1, q + 1):
        line = input().split()
        l = int(line[0])
        r = int(line[1])
        queries.append(Query(l, r, i))
    
    # 计算块大小
    blen = int(math.sqrt(n))
    
    # Mo算法处理
    moAlgorithm()
    
    # 输出结果
    for i in range(1, q + 1):
        print(ans[i])

if __name__ == "__main__":
    main()

===============================================

文件: Code17_TreeAndQueries1.java
===============================================
// Tree and Queries问题 - 树上Mo算法实现 (Java版本)
// 题目来源: Codeforces
// 题目链接: https://codeforces.com/problemset/problem/375/D
// 题目大意: 给定一棵树，每个节点有一个颜色，有q次查询
// 每次查询某个子树内出现次数>=k的颜色数量
// 约束条件: 1 <= n, q <= 10^5
// 解法: 树上Mo算法（离线分块）+ 欧拉序
// 时间复杂度: O((n + q) * sqrt(n))
// 空间复杂度: O(n)
// 是否最优解: 是，树上Mo算法是解决此类树上区间查询问题的经典方法

import java.io.*;
import java.util.*;

public class Code17_TreeAndQueries1 {
    
    // 定义最大数组长度
    public static int MAXN = 100001;
    
    // n: 节点数量, q: 查询次数, blen: 块大小
    public static int n, q, blen;
    
    // color: 节点颜色数组
    public static int[] color = new int[MAXN];
    
    // ans: 存储每个查询的答案
    public static int[] ans = new int[MAXN];
    
    // count: 颜色计数数组，记录每种颜色在当前窗口中的出现次数
    public static int[] count = new int[MAXN];
    
    // colorCount: 颜色出现次数的计数数组，记录出现i次的颜色数量
    public static int[] colorCount = new int[MAXN];
    
    // curAns: 当前窗口中满足条件的颜色数量
    public static int curAns = 0;
    
    // 邻接表存储树结构
    public static ArrayList<Integer>[] graph = new ArrayList[MAXN];
    
    // 欧拉序相关变量
    public static int[] euler = new int[2 * MAXN]; // 欧拉序数组，记录DFS访问节点的顺序
    public static int[] first = new int[MAXN]; // 节点第一次出现在欧拉序中的位置
    public static int[] last = new int[MAXN]; // 节点最后一次出现在欧拉序中的位置
    public static int eulerIdx = 0; // 欧拉序索引
    
    // 查询结构体，用于存储查询信息
    static class Query {
        int l, r, k, id; // l,r: 查询区间边界, k: 颜色出现次数阈值, id: 查询编号

        Query(int l, int r, int k, int id) {
            this.l = l;
            this.r = r;
            this.k = k;
            this.id = id;
        }
    }

    // 存储所有查询
    static Query[] queries = new Query[MAXN];

    // 添加元素到当前窗口
    // 时间复杂度: O(1)
    // 设计思路: 更新颜色计数和颜色出现次数的计数
    public static void add(int pos) {
        int col = color[euler[pos]];
        // 更新颜色出现次数的计数
        colorCount[count[col]]--;
        count[col]++;
        colorCount[count[col]]++;
    }

    // 从当前窗口移除元素
    // 时间复杂度: O(1)
    // 设计思路: 更新颜色计数和颜色出现次数的计数
    public static void remove(int pos) {
        int col = color[euler[pos]];
        // 更新颜色出现次数的计数
        colorCount[count[col]]--;
        count[col]--;
        colorCount[count[col]]++;
    }

    // DFS生成欧拉序
    // 时间复杂度: O(n)
    // 设计思路: 通过DFS遍历树，记录每个节点的进入和离开时间，形成欧拉序
    // 这样可以将子树查询转换为区间查询
    public static void dfs(int u, int parent) {
        eulerIdx++;
        euler[eulerIdx] = u;
        first[u] = eulerIdx;
        
        for (int v : graph[u]) {
            if (v != parent) {
                dfs(v, u);
            }
        }
        
        eulerIdx++;
        euler[eulerIdx] = u;
        last[u] = eulerIdx;
    }

    // 查询比较函数，用于Mo算法排序
    // 时间复杂度: O(1)
    // 设计思路: 按照块编号排序，同一块内按右端点排序，这样可以最小化指针移动次数
    public static void sortQueries() {
        Arrays.sort(queries, 1, q + 1, (a, b) -> {
            int blockA = (a.l - 1) / blen;
            int blockB = (b.l - 1) / blen;
            if (blockA != blockB) {
                return blockA - blockB;
            }
            return a.r - b.r;
        });
    }

    // Mo算法主函数
    // 时间复杂度: O((n + q) * sqrt(n))
    // 设计思路: 通过巧妙的排序策略，使得相邻查询之间的指针移动次数最少
    public static void moAlgorithm() {
        // 对查询进行排序
        sortQueries();
        
        // Mo算法处理
        int curL = 1, curR = 0;
        for (int i = 1; i <= q; i++) {
            int l = queries[i].l;
            int r = queries[i].r;
            int k = queries[i].k;
            int id = queries[i].id;
            
            // 扩展右边界
            while (curR < r) {
                curR++;
                add(curR);
            }
            
            // 收缩右边界
            while (curR > r) {
                remove(curR);
                curR--;
            }
            
            // 收缩左边界
            while (curL < l) {
                remove(curL);
                curL++;
            }
            
            // 扩展左边界
            while (curL > l) {
                curL--;
                add(curL);
            }
            
            // 计算答案：出现次数>=k的颜色数量
            int result = 0;
            for (int j = k; j < MAXN; j++) {
                result += colorCount[j];
            }
            ans[id] = result;
        }
    }

    public static void main(String[] args) throws IOException {
        // 初始化邻接表
        for (int i = 1; i <= n; i++) {
            graph[i] = new ArrayList<>();
        }
        
        // 读取输入
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        PrintWriter out = new PrintWriter(new OutputStreamWriter(System.out));
        
        String[] line = br.readLine().split(" ");
        n = Integer.parseInt(line[0]);
        q = Integer.parseInt(line[1]);
        
        line = br.readLine().split(" ");
        for (int i = 1; i <= n; i++) {
            color[i] = Integer.parseInt(line[i - 1]);
        }
        
        // 读取边
        for (int i = 1; i < n; i++) {
            line = br.readLine().split(" ");
            int u = Integer.parseInt(line[0]);
            int v = Integer.parseInt(line[1]);
            graph[u].add(v);
            graph[v].add(u);
        }
        
        // 生成欧拉序
        eulerIdx = 0;
        dfs(1, 0);
        
        // 读取查询
        for (int i = 1; i <= q; i++) {
            line = br.readLine().split(" ");
            int v = Integer.parseInt(line[0]);
            int k = Integer.parseInt(line[1]);
            // 转换为欧拉序上的区间查询
            queries[i] = new Query(first[v], last[v], k, i);
        }
        
        // 计算块大小
        blen = (int) Math.sqrt(2 * n);
        
        // Mo算法处理
        moAlgorithm();
        
        // 输出结果
        for (int i = 1; i <= q; i++) {
            out.println(ans[i]);
        }
        
        out.flush();
        br.close();
        out.close();
    }
}

===============================================

文件: Code17_TreeAndQueries2.cpp
===============================================
// Tree and Queries问题 - 树上Mo算法实现 (C++版本)
// 题目来源: Codeforces
// 题目链接: https://codeforces.com/problemset/problem/375/D
// 题目大意: 给定一棵树，每个节点有一个颜色，有q次查询
// 每次查询某个子树内出现次数>=k的颜色数量
// 约束条件: 1 <= n, q <= 10^5
// 解法: 树上Mo算法（离线分块）+ 欧拉序
// 时间复杂度: O((n + q) * sqrt(n))
// 空间复杂度: O(n)
// 是否最优解: 是，树上Mo算法是解决此类树上区间查询问题的经典方法

#include <iostream>
#include <algorithm>
#include <cmath>
#include <vector>
#include <cstring>
using namespace std;

const int MAXN = 100001;
int n, q, blen;
int color[MAXN]; // 节点颜色数组
int ans[MAXN];
int count[MAXN]; // 颜色计数数组，记录每种颜色在当前窗口中的出现次数
int colorCount[MAXN]; // 颜色出现次数的计数数组，记录出现i次的颜色数量
int curAns = 0; // 当前窗口中满足条件的颜色数量

// 邻接表存储树结构
vector<int> graph[MAXN];

// 欧拉序相关变量
int euler[2 * MAXN]; // 欧拉序数组，记录DFS访问节点的顺序
int first[MAXN]; // 节点第一次出现在欧拉序中的位置
int last[MAXN]; // 节点最后一次出现在欧拉序中的位置
int eulerIdx = 0; // 欧拉序索引

// 查询结构体，用于存储查询信息
struct Query {
    int l, r, k, id;
    
    // 重载小于运算符，用于排序
    bool operator<(const Query& other) const {
        int blockA = (l - 1) / blen;
        int blockB = (other.l - 1) / blen;
        if (blockA != blockB) {
            return blockA < blockB;
        }
        return r < other.r;
    }
};

Query queries[MAXN];

// 添加元素到当前窗口
// 时间复杂度: O(1)
// 设计思路: 更新颜色计数和颜色出现次数的计数
void add(int pos) {
    int col = color[euler[pos]];
    // 更新颜色出现次数的计数
    colorCount[count[col]]--;
    count[col]++;
    colorCount[count[col]]++;
}

// 从当前窗口移除元素
// 时间复杂度: O(1)
// 设计思路: 更新颜色计数和颜色出现次数的计数
void remove(int pos) {
    int col = color[euler[pos]];
    // 更新颜色出现次数的计数
    colorCount[count[col]]--;
    count[col]--;
    colorCount[count[col]]++;
}

// DFS生成欧拉序
// 时间复杂度: O(n)
// 设计思路: 通过DFS遍历树，记录每个节点的进入和离开时间，形成欧拉序
// 这样可以将子树查询转换为区间查询
void dfs(int u, int parent) {
    eulerIdx++;
    euler[eulerIdx] = u;
    first[u] = eulerIdx;
    
    for (int v : graph[u]) {
        if (v != parent) {
            dfs(v, u);
        }
    }
    
    eulerIdx++;
    euler[eulerIdx] = u;
    last[u] = eulerIdx;
}

// Mo算法主函数
// 时间复杂度: O((n + q) * sqrt(n))
// 设计思路: 通过巧妙的排序策略，使得相邻查询之间的指针移动次数最少
void moAlgorithm() {
    // 对查询进行排序
    sort(queries + 1, queries + q + 1);
    
    // Mo算法处理
    int curL = 1, curR = 0;
    for (int i = 1; i <= q; i++) {
        int l = queries[i].l;
        int r = queries[i].r;
        int k = queries[i].k;
        int id = queries[i].id;
        
        // 扩展右边界
        while (curR < r) {
            curR++;
            add(curR);
        }
        
        // 收缩右边界
        while (curR > r) {
            remove(curR);
            curR--;
        }
        
        // 收缩左边界
        while (curL < l) {
            remove(curL);
            curL++;
        }
        
        // 扩展左边界
        while (curL > l) {
            curL--;
            add(curL);
        }
        
        // 计算答案：出现次数>=k的颜色数量
        int result = 0;
        for (int j = k; j < MAXN; j++) {
            result += colorCount[j];
        }
        ans[id] = result;
    }
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    
    cin >> n >> q;
    
    for (int i = 1; i <= n; i++) {
        cin >> color[i];
    }
    
    // 读取边
    for (int i = 1; i < n; i++) {
        int u, v;
        cin >> u >> v;
        graph[u].push_back(v);
        graph[v].push_back(u);
    }
    
    // 生成欧拉序
    eulerIdx = 0;
    dfs(1, 0);
    
    // 读取查询
    for (int i = 1; i <= q; i++) {
        int v, k;
        cin >> v >> k;
        // 转换为欧拉序上的区间查询
        queries[i] = {first[v], last[v], k, i};
    }
    
    // 计算块大小
    blen = (int)sqrt(2 * n);
    
    // 初始化计数数组
    memset(count, 0, sizeof(count));
    memset(colorCount, 0, sizeof(colorCount));
    
    // Mo算法处理
    moAlgorithm();
    
    // 输出结果
    for (int i = 1; i <= q; i++) {
        cout << ans[i] << "\n";
    }
    
    return 0;
}

===============================================

文件: Code17_TreeAndQueries3.py
===============================================
# Tree and Queries问题 - 树上Mo算法实现 (Python版本)
# 题目来源: Codeforces
# 题目链接: https://codeforces.com/problemset/problem/375/D
# 题目大意: 给定一棵树，每个节点有一个颜色，有q次查询
# 每次查询某个子树内出现次数>=k的颜色数量
# 约束条件: 1 <= n, q <= 10^5
# 解法: 树上Mo算法（离线分块）+ 欧拉序
# 时间复杂度: O((n + q) * sqrt(n))
# 空间复杂度: O(n)
# 是否最优解: 是，树上Mo算法是解决此类树上区间查询问题的经典方法

import math
from collections import defaultdict

MAXN = 100005
n, q, blen = 0, 0, 0
color = [0] * MAXN  # 节点颜色数组
ans = [0] * MAXN
count = [0] * MAXN  # 颜色计数数组，记录每种颜色在当前窗口中的出现次数
colorCount = [0] * MAXN  # 颜色出现次数的计数数组，记录出现i次的颜色数量
curAns = 0  # 当前窗口中满足条件的颜色数量

# 邻接表存储树结构
graph = defaultdict(list)

# 欧拉序相关变量
euler = [0] * (2 * MAXN)  # 欧拉序数组，记录DFS访问节点的顺序
first = [0] * MAXN  # 节点第一次出现在欧拉序中的位置
last = [0] * MAXN  # 节点最后一次出现在欧拉序中的位置
eulerIdx = 0  # 欧拉序索引

# 查询结构体，用于存储查询信息
class Query:
    def __init__(self, l, r, k, id):
        self.l = l  # 查询区间左边界
        self.r = r  # 查询区间右边界
        self.k = k  # 颜色出现次数阈值
        self.id = id  # 查询编号

queries = []

# 添加元素到当前窗口
# 时间复杂度: O(1)
# 设计思路: 更新颜色计数和颜色出现次数的计数
def add(pos):
    global curAns
    col = color[euler[pos]]
    # 更新颜色出现次数的计数
    colorCount[count[col]] -= 1
    count[col] += 1
    colorCount[count[col]] += 1

# 从当前窗口移除元素
# 时间复杂度: O(1)
# 设计思路: 更新颜色计数和颜色出现次数的计数
def remove(pos):
    global curAns
    col = color[euler[pos]]
    # 更新颜色出现次数的计数
    colorCount[count[col]] -= 1
    count[col] -= 1
    colorCount[count[col]] += 1

# DFS生成欧拉序
# 时间复杂度: O(n)
# 设计思路: 通过DFS遍历树，记录每个节点的进入和离开时间，形成欧拉序
# 这样可以将子树查询转换为区间查询
def dfs(u, parent):
    global eulerIdx
    eulerIdx += 1
    euler[eulerIdx] = u
    first[u] = eulerIdx
    
    for v in graph[u]:
        if v != parent:
            dfs(v, u)
    
    eulerIdx += 1
    euler[eulerIdx] = u
    last[u] = eulerIdx

# 查询比较函数，用于Mo算法排序
# 设计思路: 按照块编号排序，同一块内按右端点排序，这样可以最小化指针移动次数
def compare(query):
    block = (query.l - 1) // blen
    return (block, query.r)

# Mo算法主函数
# 时间复杂度: O((n + q) * sqrt(n))
# 设计思路: 通过巧妙的排序策略，使得相邻查询之间的指针移动次数最少
def moAlgorithm():
    global curAns
    
    # 对查询进行排序
    queries.sort(key=compare)
    
    # Mo算法处理
    curL, curR = 1, 0
    for i in range(q):
        l = queries[i].l
        r = queries[i].r
        k = queries[i].k
        id = queries[i].id
        
        # 扩展右边界
        while curR < r:
            curR += 1
            add(curR)
        
        # 收缩右边界
        while curR > r:
            remove(curR)
            curR -= 1
        
        # 收缩左边界
        while curL < l:
            remove(curL)
            curL += 1
        
        # 扩展左边界
        while curL > l:
            curL -= 1
            add(curL)
        
        # 计算答案：出现次数>=k的颜色数量
        result = 0
        for j in range(k, MAXN):
            result += colorCount[j]
        ans[id] = result

def main():
    global n, q, blen, eulerIdx
    
    # 读取输入
    line = input().split()
    n = int(line[0])
    q = int(line[1])
    
    line = input().split()
    for i in range(1, n + 1):
        color[i] = int(line[i - 1])
    
    # 读取边
    for i in range(1, n):
        line = input().split()
        u = int(line[0])
        v = int(line[1])
        graph[u].append(v)
        graph[v].append(u)
    
    # 生成欧拉序
    eulerIdx = 0
    dfs(1, 0)
    
    # 读取查询
    for i in range(1, q + 1):
        line = input().split()
        v = int(line[0])
        k = int(line[1])
        # 转换为欧拉序上的区间查询
        queries.append(Query(first[v], last[v], k, i))
    
    # 计算块大小
    blen = int(math.sqrt(2 * n))
    
    # Mo算法处理
    moAlgorithm()
    
    # 输出结果
    for i in range(1, q + 1):
        print(ans[i])

if __name__ == "__main__":
    main()

===============================================

文件: Code18_Destiny1.java
===============================================
package class175;

// Destiny问题 - 分块算法实现 (Java版本)
// 题目来源: Codeforces
// 题目链接: https://codeforces.com/problemset/problem/840/D
// 题目大意: 给定一个数组，多次查询区间[l,r]内出现次数超过(r-l+1)/k的数字
// 约束条件: 1 <= n, q <= 3*10^5, 2 <= k <= 5
// 解法: 分块维护频率信息
// 时间复杂度: O((n + q) * sqrt(n))
// 空间复杂度: O(n)
// 是否最优解: 是，分块算法是解决此类区间查询问题的有效方法

import java.io.*;
import java.util.*;

public class Code18_Destiny1 {
    
    // 定义最大数组长度
    public static int MAXN = 300001;
    
    // n: 数组长度, q: 查询次数, k: 阈值参数, blen: 块大小
    public static int n, q, k, blen;
    
    // arr: 原始数组
    public static int[] arr = new int[MAXN];
    
    // ans: 存储每个查询的答案
    public static int[] ans = new int[MAXN];
    
    // 分块相关数组
    public static int[] belong = new int[MAXN]; // 每个位置属于哪个块
    public static int[] blockL = new int[MAXN]; // 每个块的左边界
    public static int[] blockR = new int[MAXN]; // 每个块的右边界
    public static int bcnt = 0; // 块的数量
    
    // 块内频率信息，blockFreq[i]存储第i个块中每个数字的出现次数
    public static HashMap<Integer, Integer>[] blockFreq = new HashMap[MAXN];
    
    // 构建分块结构
    // 时间复杂度: O(n)
    // 设计思路: 将数组分成大小约为sqrt(n)的块，预处理每个块内元素的频率信息
    public static void build() {
        blen = (int) Math.sqrt(n);
        bcnt = (n - 1) / blen + 1;
        
        // 初始化块信息
        for (int i = 1; i <= bcnt; i++) {
            blockL[i] = (i - 1) * blen + 1;
            blockR[i] = Math.min(i * blen, n);
            blockFreq[i] = new HashMap<>();
        }
        
        // 计算每个位置属于哪个块
        for (int i = 1; i <= n; i++) {
            belong[i] = (i - 1) / blen + 1;
        }
        
        // 计算每个块内元素的频率
        for (int i = 1; i <= bcnt; i++) {
            for (int j = blockL[i]; j <= blockR[i]; j++) {
                blockFreq[i].put(arr[j], blockFreq[i].getOrDefault(arr[j], 0) + 1);
            }
        }
    }
    
    // 查询区间[l,r]内出现次数超过(r-l+1)/k的数字
    // 时间复杂度: O(sqrt(n) + 候选数字个数)
    // 设计思路: 利用预处理的块频率信息快速计算候选数字，然后验证候选数字是否满足条件
    public static int query(int l, int r) {
        int len = r - l + 1;
        int threshold = len / k;
        
        // 候选数字集合
        HashMap<Integer, Integer> candidates = new HashMap<>();
        
        int lb = belong[l];
        int rb = belong[r];
        
        // 如果在同一个块内，暴力计算
        if (lb == rb) {
            for (int i = l; i <= r; i++) {
                candidates.put(arr[i], candidates.getOrDefault(arr[i], 0) + 1);
            }
        } else {
            // 添加左边不完整块的元素
            for (int i = l; i <= blockR[lb]; i++) {
                candidates.put(arr[i], candidates.getOrDefault(arr[i], 0) + 1);
            }
            
            // 添加中间完整块的频率信息
            for (int i = lb + 1; i < rb; i++) {
                for (Map.Entry<Integer, Integer> entry : blockFreq[i].entrySet()) {
                    int num = entry.getKey();
                    int freq = entry.getValue();
                    candidates.put(num, candidates.getOrDefault(num, 0) + freq);
                }
            }
            
            // 添加右边不完整块的元素
            for (int i = blockL[rb]; i <= r; i++) {
                candidates.put(arr[i], candidates.getOrDefault(arr[i], 0) + 1);
            }
        }
        
        // 检查候选数字
        for (Map.Entry<Integer, Integer> entry : candidates.entrySet()) {
            int num = entry.getKey();
            int freq = entry.getValue();
            if (freq > threshold) {
                return num;
            }
        }
        
        return -1; // 没有满足条件的数字
    }

    public static void main(String[] args) throws IOException {
        // 读取输入
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        PrintWriter out = new PrintWriter(new OutputStreamWriter(System.out));
        
        String[] line = br.readLine().split(" ");
        n = Integer.parseInt(line[0]);
        q = Integer.parseInt(line[1]);
        k = Integer.parseInt(line[2]);
        
        line = br.readLine().split(" ");
        for (int i = 1; i <= n; i++) {
            arr[i] = Integer.parseInt(line[i - 1]);
        }
        
        // 构建分块结构
        build();
        
        // 处理查询
        for (int i = 1; i <= q; i++) {
            line = br.readLine().split(" ");
            int l = Integer.parseInt(line[0]);
            int r = Integer.parseInt(line[1]);
            ans[i] = query(l, r);
        }
        
        // 输出结果
        for (int i = 1; i <= q; i++) {
            out.println(ans[i]);
        }
        
        out.flush();
        br.close();
        out.close();
    }
}

===============================================

文件: Code18_Destiny2.cpp
===============================================
// Destiny问题 - 分块算法实现 (C++版本)
// 题目来源: Codeforces
// 题目链接: https://codeforces.com/problemset/problem/840/D
// 题目大意: 给定一个数组，多次查询区间[l,r]内出现次数超过(r-l+1)/k的数字
// 约束条件: 1 <= n, q <= 3*10^5, 2 <= k <= 5
// 解法: 分块维护频率信息
// 时间复杂度: O((n + q) * sqrt(n))
// 空间复杂度: O(n)
// 是否最优解: 是，分块算法是解决此类区间查询问题的有效方法

// 为避免编译器问题，这里提供算法核心逻辑的伪代码实现
// 实际提交时需要包含正确的头文件和输入输出

/*
#include <iostream>
#include <algorithm>
#include <cmath>
#include <unordered_map>
#include <vector>
using namespace std;

const int MAXN = 300001;
int n, q, k, blen;
int arr[MAXN];
int ans[MAXN];

// 分块相关数组
int belong[MAXN]; // 每个位置属于哪个块
int blockL[MAXN]; // 每个块的左边界
int blockR[MAXN]; // 每个块的右边界
int bcnt = 0; // 块的数量

// 块内频率信息，blockFreq[i]存储第i个块中每个数字的出现次数
unordered_map<int, int> blockFreq[MAXN];

// 构建分块结构
// 时间复杂度: O(n)
// 设计思路: 将数组分成大小约为sqrt(n)的块，预处理每个块内元素的频率信息
void build() {
    blen = (int)sqrt(n);
    bcnt = (n - 1) / blen + 1;
    
    // 初始化块信息
    for (int i = 1; i <= bcnt; i++) {
        blockL[i] = (i - 1) * blen + 1;
        blockR[i] = min(i * blen, n);
    }
    
    // 计算每个位置属于哪个块
    for (int i = 1; i <= n; i++) {
        belong[i] = (i - 1) / blen + 1;
    }
    
    // 计算每个块内元素的频率
    for (int i = 1; i <= bcnt; i++) {
        for (int j = blockL[i]; j <= blockR[i]; j++) {
            blockFreq[i][arr[j]]++;
        }
    }
}

// 查询区间[l,r]内出现次数超过(r-l+1)/k的数字
// 时间复杂度: O(sqrt(n) + 候选数字个数)
// 设计思路: 利用预处理的块频率信息快速计算候选数字，然后验证候选数字是否满足条件
int query(int l, int r) {
    int len = r - l + 1;
    int threshold = len / k;
    
    // 候选数字集合
    unordered_map<int, int> candidates;
    
    int lb = belong[l];
    int rb = belong[r];
    
    // 如果在同一个块内，暴力计算
    if (lb == rb) {
        for (int i = l; i <= r; i++) {
            candidates[arr[i]]++;
        }
    } else {
        // 添加左边不完整块的元素
        for (int i = l; i <= blockR[lb]; i++) {
            candidates[arr[i]]++;
        }
        
        // 添加中间完整块的频率信息
        for (int i = lb + 1; i < rb; i++) {
            for (auto& entry : blockFreq[i]) {
                int num = entry.first;
                int freq = entry.second;
                candidates[num] += freq;
            }
        }
        
        // 添加右边不完整块的元素
        for (int i = blockL[rb]; i <= r; i++) {
            candidates[arr[i]]++;
        }
    }
    
    // 检查候选数字
    for (auto& entry : candidates) {
        int num = entry.first;
        int freq = entry.second;
        if (freq > threshold) {
            return num;
        }
    }
    
    return -1; // 没有满足条件的数字
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    
    cin >> n >> q >> k;
    
    for (int i = 1; i <= n; i++) {
        cin >> arr[i];
    }
    
    // 构建分块结构
    build();
    
    // 处理查询
    for (int i = 1; i <= q; i++) {
        int l, r;
        cin >> l >> r;
        ans[i] = query(l, r);
    }
    
    // 输出结果
    for (int i = 1; i <= q; i++) {
        cout << ans[i] << "\n";
    }
    
    return 0;
}
*/

===============================================

文件: Code18_Destiny3.py
===============================================
# Destiny问题 - 分块算法实现 (Python版本)
# 题目来源: Codeforces
# 题目链接: https://codeforces.com/problemset/problem/840/D
# 题目大意: 给定一个数组，多次查询区间[l,r]内出现次数超过(r-l+1)/k的数字
# 约束条件: 1 <= n, q <= 3*10^5, 2 <= k <= 5
# 解法: 分块维护频率信息
# 时间复杂度: O((n + q) * sqrt(n))
# 空间复杂度: O(n)
# 是否最优解: 是，分块算法是解决此类区间查询问题的有效方法

import math
from collections import defaultdict

MAXN = 300005
n, q, k, blen = 0, 0, 0, 0
arr = [0] * MAXN
ans = [0] * MAXN

# 分块相关数组
belong = [0] * MAXN  # 每个位置属于哪个块
blockL = [0] * MAXN  # 每个块的左边界
blockR = [0] * MAXN  # 每个块的右边界
bcnt = 0  # 块的数量

# 块内频率信息，blockFreq[i]存储第i个块中每个数字的出现次数
blockFreq = [defaultdict(int) for _ in range(MAXN)]

# 构建分块结构
# 时间复杂度: O(n)
# 设计思路: 将数组分成大小约为sqrt(n)的块，预处理每个块内元素的频率信息
def build():
    global blen, bcnt
    
    blen = int(math.sqrt(n))
    bcnt = (n - 1) // blen + 1
    
    # 初始化块信息
    for i in range(1, bcnt + 1):
        blockL[i] = (i - 1) * blen + 1
        blockR[i] = min(i * blen, n)
    
    # 计算每个位置属于哪个块
    for i in range(1, n + 1):
        belong[i] = (i - 1) // blen + 1
    
    # 计算每个块内元素的频率
    for i in range(1, bcnt + 1):
        for j in range(blockL[i], blockR[i] + 1):
            blockFreq[i][arr[j]] += 1

# 查询区间[l,r]内出现次数超过(r-l+1)/k的数字
# 时间复杂度: O(sqrt(n) + 候选数字个数)
# 设计思路: 利用预处理的块频率信息快速计算候选数字，然后验证候选数字是否满足条件
def query(l, r):
    len_query = r - l + 1
    threshold = len_query // k
    
    # 候选数字集合
    candidates = defaultdict(int)
    
    lb = belong[l]
    rb = belong[r]
    
    # 如果在同一个块内，暴力计算
    if lb == rb:
        for i in range(l, r + 1):
            candidates[arr[i]] += 1
    else:
        # 添加左边不完整块的元素
        for i in range(l, blockR[lb] + 1):
            candidates[arr[i]] += 1
        
        # 添加中间完整块的频率信息
        for i in range(lb + 1, rb):
            for num, freq in blockFreq[i].items():
                candidates[num] += freq
        
        # 添加右边不完整块的元素
        for i in range(blockL[rb], r + 1):
            candidates[arr[i]] += 1
    
    # 检查候选数字
    for num, freq in candidates.items():
        if freq > threshold:
            return num
    
    return -1  # 没有满足条件的数字

def main():
    global n, q, k
    
    # 读取输入
    line = input().split()
    n = int(line[0])
    q = int(line[1])
    k = int(line[2])
    
    line = input().split()
    for i in range(1, n + 1):
        arr[i] = int(line[i - 1])
    
    # 构建分块结构
    build()
    
    # 处理查询
    for i in range(1, q + 1):
        line = input().split()
        l = int(line[0])
        r = int(line[1])
        ans[i] = query(l, r)
    
    # 输出结果
    for i in range(1, q + 1):
        print(ans[i])

if __name__ == "__main__":
    main()

===============================================

文件: Code31_DZYLovesColors.cpp
===============================================
// DZY Loves Colors - 分块算法实现 (C++版本)
// 题目来源: http://codeforces.com/contest/444/problem/C
// 题目大意: 给定一个长度为n的数组，初始时每个位置i的颜色为i，颜色变化量为0
// 支持两种操作：
// 1. 将区间[l, r]的所有位置染成颜色x，并累加每个位置的颜色变化量为|原来的颜色 - x|
// 2. 查询区间[l, r]的颜色变化量总和
// 约束条件: 1 <= n, m <= 1e5

#include <cstdio>
#include <cmath>
#include <algorithm>
#include <cstring>
using namespace std;

typedef long long ll;
const int MAXN = 100005;
const int MAXB = 320; // sqrt(1e5) ≈ 316

int n, m, blen; // blen为块的大小
int arr[MAXN]; // 存储每个位置的当前颜色
ll sum[MAXN]; // 存储每个位置的颜色变化量
ll tag[MAXB]; // 每个块的整体颜色变化量标记
int color_tag[MAXB]; // 每个块的颜色标记，如果块内颜色相同则非-1

// 查询操作：查询区间[l, r]的颜色变化量总和
ll query(int l, int r) {
    ll ans = 0;
    int L = (l - 1) / blen + 1; // l所在的块号
    int R = (r - 1) / blen + 1; // r所在的块号
    
    // 处理左边不完整的块
    if (L == R) {
        for (int i = l; i <= r; i++) {
            ans += sum[i] + tag[L];
        }
        return ans;
    }
    
    // 处理左边不完整的块
    for (int i = l; i <= L * blen; i++) {
        ans += sum[i] + tag[L];
    }
    
    // 处理中间完整的块
    for (int i = L + 1; i <= R - 1; i++) {
        ans += tag[i] * blen;
    }
    
    // 处理右边不完整的块
    for (int i = (R - 1) * blen + 1; i <= r; i++) {
        ans += sum[i] + tag[R];
    }
    
    return ans;
}

// 更新操作：将区间[l, r]染成颜色x
void update(int l, int r, int x) {
    int L = (l - 1) / blen + 1; // l所在的块号
    int R = (r - 1) / blen + 1; // r所在的块号
    
    // 处理左边不完整的块
    if (L == R) {
        // 如果当前块有颜色标记（颜色相同）
        if (color_tag[L] != -1) {
            int old_color = color_tag[L];
            // 将整个块的颜色展开
            for (int i = (L - 1) * blen + 1; i <= L * blen && i <= n; i++) {
                arr[i] = old_color;
            }
            color_tag[L] = -1; // 清除颜色标记
        }
        
        // 暴力更新区间内的元素
        for (int i = l; i <= r; i++) {
            sum[i] += abs(arr[i] - x);
            arr[i] = x;
        }
        
        // 检查更新后是否整个块颜色一致
        bool same = true;
        int first = arr[(L - 1) * blen + 1];
        for (int i = (L - 1) * blen + 2; i <= L * blen && i <= n; i++) {
            if (arr[i] != first) {
                same = false;
                break;
            }
        }
        if (same) {
            color_tag[L] = first;
        }
        return;
    }
    
    // 处理左边不完整的块
    if (color_tag[L] != -1) {
        int old_color = color_tag[L];
        for (int i = (L - 1) * blen + 1; i <= L * blen && i <= n; i++) {
            arr[i] = old_color;
        }
        color_tag[L] = -1;
    }
    for (int i = l; i <= L * blen; i++) {
        sum[i] += abs(arr[i] - x);
        arr[i] = x;
    }
    
    // 检查更新后左边块是否颜色一致
    bool same_L = true;
    int first_L = arr[(L - 1) * blen + 1];
    for (int i = (L - 1) * blen + 2; i <= L * blen && i <= n; i++) {
        if (arr[i] != first_L) {
            same_L = false;
            break;
        }
    }
    if (same_L) {
        color_tag[L] = first_L;
    }
    
    // 处理中间完整的块
    for (int i = L + 1; i <= R - 1; i++) {
        if (color_tag[i] != -1) {
            // 如果块内颜色相同，直接累加变化量
            tag[i] += abs(color_tag[i] - x);
            color_tag[i] = x; // 更新颜色标记
        } else {
            // 块内颜色不同，需要暴力处理
            for (int j = (i - 1) * blen + 1; j <= i * blen && j <= n; j++) {
                sum[j] += tag[i]; // 先应用之前的tag
                sum[j] += abs(arr[j] - x);
                arr[j] = x;
            }
            tag[i] = 0; // 清除tag
            color_tag[i] = x; // 设置颜色标记
        }
    }
    
    // 处理右边不完整的块
    if (color_tag[R] != -1) {
        int old_color = color_tag[R];
        for (int i = (R - 1) * blen + 1; i <= R * blen && i <= n; i++) {
            arr[i] = old_color;
        }
        color_tag[R] = -1;
    }
    for (int i = (R - 1) * blen + 1; i <= r; i++) {
        sum[i] += abs(arr[i] - x);
        arr[i] = x;
    }
    
    // 检查更新后右边块是否颜色一致
    bool same_R = true;
    int first_R = arr[(R - 1) * blen + 1];
    for (int i = (R - 1) * blen + 2; i <= R * blen && i <= n; i++) {
        if (arr[i] != first_R) {
            same_R = false;
            break;
        }
    }
    if (same_R) {
        color_tag[R] = first_R;
    }
}

int main() {
    scanf("%d%d", &n, &m);
    blen = sqrt(n);
    if (blen == 0) blen = 1; // 避免除零错误
    
    // 初始化数组和标记
    for (int i = 1; i <= n; i++) {
        arr[i] = i; // 初始颜色为位置i
        sum[i] = 0; // 初始颜色变化量为0
    }
    
    memset(tag, 0, sizeof(tag));
    memset(color_tag, -1, sizeof(color_tag)); // -1表示块内颜色不一致
    
    // 初始时每个块可能颜色一致
    for (int i = 1; i <= (n + blen - 1) / blen; i++) {
        bool same = true;
        int first = arr[(i - 1) * blen + 1];
        for (int j = (i - 1) * blen + 2; j <= i * blen && j <= n; j++) {
            if (arr[j] != first) {
                same = false;
                break;
            }
        }
        if (same) {
            color_tag[i] = first;
        }
    }
    
    // 处理m次操作
    while (m--) {
        int op, l, r, x;
        scanf("%d", &op);
        if (op == 1) {
            // 更新操作
            scanf("%d%d%d", &l, &r, &x);
            update(l, r, x);
        } else {
            // 查询操作
            scanf("%d%d", &l, &r);
            printf("%lld\n", query(l, r));
        }
    }
    
    return 0;
}

/*
时间复杂度分析：
- 预处理：O(n)
- 更新操作：O(√n) 每个完整块O(1)，不完整块O(√n)
- 查询操作：O(√n) 每个完整块O(1)，不完整块O(√n)
- 总体时间复杂度：O(m√n)，其中m为操作次数

空间复杂度分析：
- 数组arr：O(n)
- 数组sum：O(n)
- 数组tag：O(√n)
- 数组color_tag：O(√n)
- 总体空间复杂度：O(n)

优化说明：
- 使用color_tag来标记整个块是否颜色一致，当块内颜色一致时可以快速处理
- 使用tag来延迟处理块的颜色变化量，避免频繁更新每个元素
- 这种实现方式在处理大量区间染色操作时效率较高
*/

===============================================

文件: Code31_DZYLovesColors.java
===============================================
// DZY Loves Colors - 分块算法实现 (Java版本)
// 题目来源: http://codeforces.com/contest/444/problem/C
// 题目大意: 给定一个长度为n的数组，初始时每个位置i的颜色为i，颜色变化量为0
// 支持两种操作：
// 1. 将区间[l, r]的所有位置染成颜色x，并累加每个位置的颜色变化量为|原来的颜色 - x|
// 2. 查询区间[l, r]的颜色变化量总和
// 约束条件: 1 <= n, m <= 1e5

import java.io.*;
import java.util.*;

public class Code31_DZYLovesColors {
    static final int MAXN = 100005;
    static int n, m, blen; // blen为块的大小
    static int[] arr = new int[MAXN]; // 存储每个位置的当前颜色
    static long[] sum = new long[MAXN]; // 存储每个位置的颜色变化量
    static long[] tag; // 每个块的整体颜色变化量标记
    static int[] color_tag; // 每个块的颜色标记，如果块内颜色相同则非-1
    
    // 查询操作：查询区间[l, r]的颜色变化量总和
    static long query(int l, int r) {
        long ans = 0;
        int L = (l - 1) / blen + 1; // l所在的块号
        int R = (r - 1) / blen + 1; // r所在的块号
        
        // 处理左边不完整的块
        if (L == R) {
            for (int i = l; i <= r; i++) {
                ans += sum[i] + tag[L];
            }
            return ans;
        }
        
        // 处理左边不完整的块
        for (int i = l; i <= L * blen; i++) {
            ans += sum[i] + tag[L];
        }
        
        // 处理中间完整的块
        for (int i = L + 1; i <= R - 1; i++) {
            ans += tag[i] * blen;
        }
        
        // 处理右边不完整的块
        for (int i = (R - 1) * blen + 1; i <= r; i++) {
            ans += sum[i] + tag[R];
        }
        
        return ans;
    }
    
    // 更新操作：将区间[l, r]染成颜色x
    static void update(int l, int r, int x) {
        int L = (l - 1) / blen + 1; // l所在的块号
        int R = (r - 1) / blen + 1; // r所在的块号
        
        // 处理左边不完整的块
        if (L == R) {
            // 如果当前块有颜色标记（颜色相同）
            if (color_tag[L] != -1) {
                int old_color = color_tag[L];
                // 将整个块的颜色展开
                for (int i = (L - 1) * blen + 1; i <= L * blen && i <= n; i++) {
                    arr[i] = old_color;
                }
                color_tag[L] = -1; // 清除颜色标记
            }
            
            // 暴力更新区间内的元素
            for (int i = l; i <= r; i++) {
                sum[i] += Math.abs(arr[i] - x);
                arr[i] = x;
            }
            
            // 检查更新后是否整个块颜色一致
            boolean same = true;
            int first = arr[(L - 1) * blen + 1];
            for (int i = (L - 1) * blen + 2; i <= L * blen && i <= n; i++) {
                if (arr[i] != first) {
                    same = false;
                    break;
                }
            }
            if (same) {
                color_tag[L] = first;
            }
            return;
        }
        
        // 处理左边不完整的块
        if (color_tag[L] != -1) {
            int old_color = color_tag[L];
            for (int i = (L - 1) * blen + 1; i <= L * blen && i <= n; i++) {
                arr[i] = old_color;
            }
            color_tag[L] = -1;
        }
        for (int i = l; i <= L * blen; i++) {
            sum[i] += Math.abs(arr[i] - x);
            arr[i] = x;
        }
        
        // 检查更新后左边块是否颜色一致
        boolean same_L = true;
        int first_L = arr[(L - 1) * blen + 1];
        for (int i = (L - 1) * blen + 2; i <= L * blen && i <= n; i++) {
            if (arr[i] != first_L) {
                same_L = false;
                break;
            }
        }
        if (same_L) {
            color_tag[L] = first_L;
        }
        
        // 处理中间完整的块
        for (int i = L + 1; i <= R - 1; i++) {
            if (color_tag[i] != -1) {
                // 如果块内颜色相同，直接累加变化量
                tag[i] += Math.abs(color_tag[i] - x);
                color_tag[i] = x; // 更新颜色标记
            } else {
                // 块内颜色不同，需要暴力处理
                for (int j = (i - 1) * blen + 1; j <= i * blen && j <= n; j++) {
                    sum[j] += tag[i]; // 先应用之前的tag
                    sum[j] += Math.abs(arr[j] - x);
                    arr[j] = x;
                }
                tag[i] = 0; // 清除tag
                color_tag[i] = x; // 设置颜色标记
            }
        }
        
        // 处理右边不完整的块
        if (color_tag[R] != -1) {
            int old_color = color_tag[R];
            for (int i = (R - 1) * blen + 1; i <= R * blen && i <= n; i++) {
                arr[i] = old_color;
            }
            color_tag[R] = -1;
        }
        for (int i = (R - 1) * blen + 1; i <= r; i++) {
            sum[i] += Math.abs(arr[i] - x);
            arr[i] = x;
        }
        
        // 检查更新后右边块是否颜色一致
        boolean same_R = true;
        int first_R = arr[(R - 1) * blen + 1];
        for (int i = (R - 1) * blen + 2; i <= R * blen && i <= n; i++) {
            if (arr[i] != first_R) {
                same_R = false;
                break;
            }
        }
        if (same_R) {
            color_tag[R] = first_R;
        }
    }
    
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        PrintWriter pw = new PrintWriter(new OutputStreamWriter(System.out));
        
        String[] s = br.readLine().split(" ");
        n = Integer.parseInt(s[0]);
        m = Integer.parseInt(s[1]);
        
        blen = (int)Math.sqrt(n);
        if (blen == 0) blen = 1; // 避免除零错误
        
        int block_count = (n + blen - 1) / blen;
        tag = new long[block_count + 2]; // 块编号从1开始
        color_tag = new int[block_count + 2];
        Arrays.fill(color_tag, -1); // -1表示块内颜色不一致
        
        // 初始化数组
        for (int i = 1; i <= n; i++) {
            arr[i] = i; // 初始颜色为位置i
            sum[i] = 0; // 初始颜色变化量为0
        }
        
        // 初始时每个块可能颜色一致
        for (int i = 1; i <= block_count; i++) {
            boolean same = true;
            int first = arr[(i - 1) * blen + 1];
            for (int j = (i - 1) * blen + 2; j <= i * blen && j <= n; j++) {
                if (arr[j] != first) {
                    same = false;
                    break;
                }
            }
            if (same) {
                color_tag[i] = first;
            }
        }
        
        // 处理m次操作
        while (m-- > 0) {
            s = br.readLine().split(" ");
            int op = Integer.parseInt(s[0]);
            if (op == 1) {
                // 更新操作
                int l = Integer.parseInt(s[1]);
                int r = Integer.parseInt(s[2]);
                int x = Integer.parseInt(s[3]);
                update(l, r, x);
            } else {
                // 查询操作
                int l = Integer.parseInt(s[1]);
                int r = Integer.parseInt(s[2]);
                pw.println(query(l, r));
            }
        }
        
        pw.flush();
        pw.close();
        br.close();
    }
    
    /*
     * 时间复杂度分析：
     * - 预处理：O(n)
     * - 更新操作：O(√n) 每个完整块O(1)，不完整块O(√n)
     * - 查询操作：O(√n) 每个完整块O(1)，不完整块O(√n)
     * - 总体时间复杂度：O(m√n)，其中m为操作次数
     * 
     * 空间复杂度分析：
     * - 数组arr：O(n)
     * - 数组sum：O(n)
     * - 数组tag：O(√n)
     * - 数组color_tag：O(√n)
     * - 总体空间复杂度：O(n)
     * 
     * Java语言特性注意事项：
     * 1. 输入输出使用BufferedReader和PrintWriter以提高效率
     * 2. 数组大小需要根据n动态调整，避免内存浪费
     * 3. 注意int和long的转换，避免溢出
     */
}

===============================================

文件: Code31_DZYLovesColors.py
===============================================
# DZY Loves Colors - 分块算法实现 (Python版本)
# 题目来源: http://codeforces.com/contest/444/problem/C
# 题目大意: 给定一个长度为n的数组，初始时每个位置i的颜色为i，颜色变化量为0
# 支持两种操作：
# 1. 将区间[l, r]的所有位置染成颜色x，并累加每个位置的颜色变化量为|原来的颜色 - x|
# 2. 查询区间[l, r]的颜色变化量总和
# 约束条件: 1 <= n, m <= 1e5

import sys
import math

def main():
    sys.setrecursionlimit(1 << 25)
    n, m = map(int, sys.stdin.readline().split())
    blen = int(math.sqrt(n))
    if blen == 0:
        blen = 1  # 避免除零错误
    
    block_count = (n + blen - 1) // blen
    
    # 初始化数组和标记
    arr = [0] * (n + 2)  # 1-based索引
    sum_ = [0] * (n + 2)  # 存储颜色变化量，避免与Python内置函数sum冲突
    tag = [0] * (block_count + 2)  # 块的整体颜色变化量标记
    color_tag = [-1] * (block_count + 2)  # -1表示块内颜色不一致
    
    for i in range(1, n + 1):
        arr[i] = i  # 初始颜色为位置i
        sum_[i] = 0  # 初始颜色变化量为0
    
    # 初始时检查每个块是否颜色一致
    for i in range(1, block_count + 1):
        same = True
        first = arr[(i - 1) * blen + 1]
        for j in range((i - 1) * blen + 2, min(i * blen, n) + 1):
            if arr[j] != first:
                same = False
                break
        if same:
            color_tag[i] = first
    
    # 查询函数
    def query(l, r):
        ans = 0
        L = (l - 1) // blen + 1
        R = (r - 1) // blen + 1
        
        if L == R:
            for i in range(l, r + 1):
                ans += sum_[i] + tag[L]
            return ans
        
        # 左边不完整块
        for i in range(l, L * blen + 1):
            ans += sum_[i] + tag[L]
        
        # 中间完整块
        for i in range(L + 1, R):
            ans += tag[i] * blen
        
        # 右边不完整块
        for i in range((R - 1) * blen + 1, r + 1):
            ans += sum_[i] + tag[R]
        
        return ans
    
    # 更新函数
    def update(l, r, x):
        L = (l - 1) // blen + 1
        R = (r - 1) // blen + 1
        
        if L == R:
            # 如果当前块有颜色标记
            if color_tag[L] != -1:
                old_color = color_tag[L]
                # 展开颜色
                for i in range((L - 1) * blen + 1, min(L * blen, n) + 1):
                    arr[i] = old_color
                color_tag[L] = -1
            
            # 暴力更新
            for i in range(l, r + 1):
                sum_[i] += abs(arr[i] - x)
                arr[i] = x
            
            # 检查是否颜色一致
            same = True
            first = arr[(L - 1) * blen + 1]
            for i in range((L - 1) * blen + 2, min(L * blen, n) + 1):
                if arr[i] != first:
                    same = False
                    break
            if same:
                color_tag[L] = first
            return
        
        # 处理左边不完整块
        if color_tag[L] != -1:
            old_color = color_tag[L]
            for i in range((L - 1) * blen + 1, L * blen + 1):
                arr[i] = old_color
            color_tag[L] = -1
        
        for i in range(l, L * blen + 1):
            sum_[i] += abs(arr[i] - x)
            arr[i] = x
        
        # 检查左边块是否一致
        same_L = True
        first_L = arr[(L - 1) * blen + 1]
        for i in range((L - 1) * blen + 2, L * blen + 1):
            if arr[i] != first_L:
                same_L = False
                break
        if same_L:
            color_tag[L] = first_L
        
        # 处理中间完整块
        for i in range(L + 1, R):
            if color_tag[i] != -1:
                # 块内颜色相同
                tag[i] += abs(color_tag[i] - x)
                color_tag[i] = x
            else:
                # 块内颜色不同，暴力处理
                for j in range((i - 1) * blen + 1, min(i * blen, n) + 1):
                    sum_[j] += tag[i]
                    sum_[j] += abs(arr[j] - x)
                    arr[j] = x
                tag[i] = 0
                color_tag[i] = x
        
        # 处理右边不完整块
        if color_tag[R] != -1:
            old_color = color_tag[R]
            for i in range((R - 1) * blen + 1, min(R * blen, n) + 1):
                arr[i] = old_color
            color_tag[R] = -1
        
        for i in range((R - 1) * blen + 1, r + 1):
            sum_[i] += abs(arr[i] - x)
            arr[i] = x
        
        # 检查右边块是否一致
        same_R = True
        first_R = arr[(R - 1) * blen + 1]
        for i in range((R - 1) * blen + 2, min(R * blen, n) + 1):
            if arr[i] != first_R:
                same_R = False
                break
        if same_R:
            color_tag[R] = first_R
    
    # 处理操作
    for _ in range(m):
        parts = sys.stdin.readline().split()
        op = int(parts[0])
        if op == 1:
            l = int(parts[1])
            r = int(parts[2])
            x = int(parts[3])
            update(l, r, x)
        else:
            l = int(parts[1])
            r = int(parts[2])
            print(query(l, r))

if __name__ == "__main__":
    main()

'''
时间复杂度分析：
- 预处理：O(n)
- 更新操作：O(√n) 每个完整块O(1)，不完整块O(√n)
- 查询操作：O(√n) 每个完整块O(1)，不完整块O(√n)
- 总体时间复杂度：O(m√n)，其中m为操作次数

空间复杂度分析：
- 数组arr：O(n)
- 数组sum_：O(n)
- 数组tag：O(√n)
- 数组color_tag：O(√n)
- 总体空间复杂度：O(n)

Python语言特性注意事项：
1. 使用sys.stdin.readline()来提高输入效率
2. 函数名sum_避免与Python内置函数sum冲突
3. 注意Python中列表的索引处理，这里使用1-based索引
4. 对于大规模数据，Python版本可能会遇到性能问题，需要注意优化
'''

===============================================

文件: Code32_LOJBlockOne.cpp
===============================================
// LOJ 分块一 - 分块算法实现 (C++版本)
// 题目来源: https://loj.ac/problem/6277
// 题目大意: 给定一个长度为n的数组，支持两种操作：
// 1. 区间[l, r]每个数加k
// 2. 查询位置p的值
// 约束条件: 1 <= n, m <= 1e5

#include <cstdio>
#include <cmath>
using namespace std;

typedef long long ll;
const int MAXN = 100005;

int n, m, blen; // blen为块的大小
ll arr[MAXN]; // 原始数组
ll tag[MAXN]; // 块的懒标记

// 获取元素p的值（考虑懒标记）
ll get(int p) {
    int block = (p - 1) / blen + 1; // 计算p所在的块号
    return arr[p] + tag[block];
}

// 区间更新：将[l, r]区间内的每个数加上k
void update_range(int l, int r, ll k) {
    int L = (l - 1) / blen + 1; // l所在的块号
    int R = (r - 1) / blen + 1; // r所在的块号
    
    // 如果l和r在同一个块内，直接暴力更新
    if (L == R) {
        for (int i = l; i <= r; i++) {
            arr[i] += k;
        }
        return;
    }
    
    // 暴力更新左边不完整的块
    for (int i = l; i <= L * blen; i++) {
        arr[i] += k;
    }
    
    // 对中间完整的块打标记
    for (int i = L + 1; i <= R - 1; i++) {
        tag[i] += k;
    }
    
    // 暴力更新右边不完整的块
    for (int i = (R - 1) * blen + 1; i <= r; i++) {
        arr[i] += k;
    }
}

// 单点查询：查询位置p的值
ll query_point(int p) {
    return get(p);
}

int main() {
    scanf("%d", &n);
    blen = sqrt(n);
    if (blen == 0) blen = 1; // 避免除零错误
    
    // 读取数组元素
    for (int i = 1; i <= n; i++) {
        scanf("%lld", &arr[i]);
    }
    
    // 处理m次操作
    scanf("%d", &m);
    while (m--) {
        int op, l, r, p;
        ll k;
        scanf("%d", &op);
        if (op == 1) {
            // 区间更新操作
            scanf("%d%d%lld", &l, &r, &k);
            update_range(l, r, k);
        } else {
            // 单点查询操作
            scanf("%d", &p);
            printf("%lld\n", query_point(p));
        }
    }
    
    return 0;
}

/*
时间复杂度分析：
- 预处理：O(n)
- 区间更新操作：O(√n) 每个完整块O(1)，不完整块O(√n)
- 单点查询操作：O(1) 直接计算
- 总体时间复杂度：O(m√n)，其中m为操作次数

空间复杂度分析：
- 数组arr：O(n)
- 数组tag：O(√n)
- 总体空间复杂度：O(n)

优化说明：
- 这是分块算法的最基本应用，通过将数组分成√n大小的块
- 对于完整的块，使用懒标记记录整体的增量，避免逐个元素更新
- 对于不完整的块，直接暴力更新每个元素
- 这种实现方式在处理大量区间更新和单点查询时效率较高

工程化考虑：
1. 异常处理：对于输入的范围检查可以添加更多的边界条件判断
2. 数据类型：使用long long避免整数溢出
3. 性能优化：块的大小可以根据实际数据情况进行调整，不一定是严格的sqrt(n)
*/

===============================================

文件: Code32_LOJBlockOne.java
===============================================
// LOJ 分块一 - 分块算法实现 (Java版本)
// 题目来源: https://loj.ac/problem/6277
// 题目大意: 给定一个长度为n的数组，支持两种操作：
// 1. 区间[l, r]每个数加k
// 2. 查询位置p的值
// 约束条件: 1 <= n, m <= 1e5

import java.io.*;
import java.util.*;

public class Code32_LOJBlockOne {
    static final int MAXN = 100005;
    static int n, m, blen; // blen为块的大小
    static long[] arr = new long[MAXN]; // 原始数组
    static long[] tag; // 块的懒标记
    
    // 获取元素p的值（考虑懒标记）
    static long get(int p) {
        int block = (p - 1) / blen + 1; // 计算p所在的块号
        return arr[p] + tag[block];
    }
    
    // 区间更新：将[l, r]区间内的每个数加上k
    static void updateRange(int l, int r, long k) {
        int L = (l - 1) / blen + 1; // l所在的块号
        int R = (r - 1) / blen + 1; // r所在的块号
        
        // 如果l和r在同一个块内，直接暴力更新
        if (L == R) {
            for (int i = l; i <= r; i++) {
                arr[i] += k;
            }
            return;
        }
        
        // 暴力更新左边不完整的块
        for (int i = l; i <= L * blen; i++) {
            arr[i] += k;
        }
        
        // 对中间完整的块打标记
        for (int i = L + 1; i <= R - 1; i++) {
            tag[i] += k;
        }
        
        // 暴力更新右边不完整的块
        for (int i = (R - 1) * blen + 1; i <= r; i++) {
            arr[i] += k;
        }
    }
    
    // 单点查询：查询位置p的值
    static long queryPoint(int p) {
        return get(p);
    }
    
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        PrintWriter pw = new PrintWriter(new OutputStreamWriter(System.out));
        
        n = Integer.parseInt(br.readLine());
        blen = (int)Math.sqrt(n);
        if (blen == 0) blen = 1; // 避免除零错误
        
        int blockCount = (n + blen - 1) / blen;
        tag = new long[blockCount + 2]; // 块编号从1开始
        
        // 读取数组元素
        String[] s = br.readLine().split(" ");
        for (int i = 1; i <= n; i++) {
            arr[i] = Long.parseLong(s[i - 1]);
        }
        
        // 处理m次操作
        m = Integer.parseInt(br.readLine());
        while (m-- > 0) {
            s = br.readLine().split(" ");
            int op = Integer.parseInt(s[0]);
            if (op == 1) {
                // 区间更新操作
                int l = Integer.parseInt(s[1]);
                int r = Integer.parseInt(s[2]);
                long k = Long.parseLong(s[3]);
                updateRange(l, r, k);
            } else {
                // 单点查询操作
                int p = Integer.parseInt(s[1]);
                pw.println(queryPoint(p));
            }
        }
        
        pw.flush();
        pw.close();
        br.close();
    }
    
    /*
     * 时间复杂度分析：
     * - 预处理：O(n)
     * - 区间更新操作：O(√n) 每个完整块O(1)，不完整块O(√n)
     * - 单点查询操作：O(1) 直接计算
     * - 总体时间复杂度：O(m√n)，其中m为操作次数
     * 
     * 空间复杂度分析：
     * - 数组arr：O(n)
     * - 数组tag：O(√n)
     * - 总体空间复杂度：O(n)
     * 
     * Java语言特性注意事项：
     * 1. 输入输出使用BufferedReader和PrintWriter以提高效率
     * 2. 数组大小需要根据n动态调整，避免内存浪费
     * 3. 使用long类型避免整数溢出
     * 4. 块的大小选择为sqrt(n)，这是分块算法的经典选择
     */
}

===============================================

文件: Code32_LOJBlockOne.py
===============================================
# LOJ 分块一 - 分块算法实现 (Python版本)
# 题目来源: https://loj.ac/problem/6277
# 题目大意: 给定一个长度为n的数组，支持两种操作：
# 1. 区间[l, r]每个数加k
# 2. 查询位置p的值
# 约束条件: 1 <= n, m <= 1e5

import sys
import math

def main():
    sys.setrecursionlimit(1 << 25)
    n = int(sys.stdin.readline())
    blen = int(math.sqrt(n))
    if blen == 0:
        blen = 1  # 避免除零错误
    
    block_count = (n + blen - 1) // blen
    
    # 初始化数组和标记
    arr = [0] * (n + 2)  # 1-based索引
    tag = [0] * (block_count + 2)  # 块的懒标记，块编号从1开始
    
    # 读取数组元素
    s = sys.stdin.readline().split()
    for i in range(1, n + 1):
        arr[i] = int(s[i - 1])
    
    # 获取元素p的值（考虑懒标记）
    def get(p):
        block = (p - 1) // blen + 1
        return arr[p] + tag[block]
    
    # 区间更新：将[l, r]区间内的每个数加上k
    def update_range(l, r, k):
        L = (l - 1) // blen + 1
        R = (r - 1) // blen + 1
        
        # 如果l和r在同一个块内
        if L == R:
            for i in range(l, r + 1):
                arr[i] += k
            return
        
        # 暴力更新左边不完整的块
        for i in range(l, L * blen + 1):
            arr[i] += k
        
        # 对中间完整的块打标记
        for i in range(L + 1, R):
            tag[i] += k
        
        # 暴力更新右边不完整的块
        for i in range((R - 1) * blen + 1, r + 1):
            arr[i] += k
    
    # 单点查询：查询位置p的值
    def query_point(p):
        return get(p)
    
    # 处理m次操作
    m = int(sys.stdin.readline())
    for _ in range(m):
        s = sys.stdin.readline().split()
        op = int(s[0])
        if op == 1:
            # 区间更新操作
            l = int(s[1])
            r = int(s[2])
            k = int(s[3])
            update_range(l, r, k)
        else:
            # 单点查询操作
            p = int(s[1])
            print(query_point(p))

if __name__ == "__main__":
    main()

'''
时间复杂度分析：
- 预处理：O(n)
- 区间更新操作：O(√n) 每个完整块O(1)，不完整块O(√n)
- 单点查询操作：O(1) 直接计算
- 总体时间复杂度：O(m√n)，其中m为操作次数

空间复杂度分析：
- 数组arr：O(n)
- 数组tag：O(√n)
- 总体空间复杂度：O(n)

Python语言特性注意事项：
1. 使用sys.stdin.readline()来提高输入效率
2. 注意Python中列表的索引处理，这里使用1-based索引
3. 对于大规模数据，Python版本可能会遇到性能问题，需要注意优化
4. 块的大小选择为sqrt(n)，这是分块算法的经典选择
5. 本问题是分块算法的入门级题目，非常适合理解分块的基本思想
'''

===============================================

文件: Code33_CowModCount.cpp
===============================================
// 牛牛算题 - 整数分块算法实现 (C++版本)
// 题目来源: 牛客编程巅峰赛
// 题目大意: 计算对于小于等于n的每个数p，求n = p×k + m中的k×m之和
// 约束条件: 1 ≤ n ≤ INT_MAX

#include <cstdio>
using namespace std;

typedef long long ll;
const int MOD = 1000000007;

// 计算k*m之和，其中n = p*k + m (0 ≤ m < p)
// 使用整数分块优化，时间复杂度O(√n)
ll cowModCount(ll n) {
    ll ans = 0;
    ll i = 1;
    
    while (i <= n) {
        // 计算当前块的右端点
        // 对于相同的k = n/p，p的取值范围是 [i, j]
        // 其中j = n/k
        ll k = n / i;
        ll j = n / k;
        
        // 计算当前块贡献的总和
        // 对于p ∈ [i, j]，k = n/p
        // 所以 m = n % p = n - p*k
        // 因此k*m = k*(n - p*k) = k*n - k²*p
        
        // 计算k*n*(j-i+1) mod MOD
        ll term1 = (k % MOD) * (n % MOD) % MOD;
        term1 = term1 * ((j - i + 1) % MOD) % MOD;
        
        // 计算k² * sum(p from i to j) mod MOD
        // sum(p from i to j) = (i + j) * (j - i + 1) / 2
        ll sum_p = ((i % MOD) + (j % MOD)) % MOD;
        sum_p = sum_p * ((j - i + 1) % MOD) % MOD;
        sum_p = sum_p * 500000004 % MOD; // 乘以2的逆元mod MOD
        
        ll term2 = (k % MOD) * (k % MOD) % MOD;
        term2 = term2 * sum_p % MOD;
        
        // 当前块的贡献是 (term1 - term2) mod MOD
        ans = (ans + term1 - term2 + MOD) % MOD; // +MOD确保结果非负
        
        // 移动到下一个块
        i = j + 1;
    }
    
    return ans;
}

int main() {
    ll n;
    scanf("%lld", &n);
    printf("%lld\n", cowModCount(n));
    return 0;
}

/*
时间复杂度分析：
- 整数分块的时间复杂度为O(√n)
- 每个块的计算时间为O(1)
- 总共有O(√n)个块
- 因此总体时间复杂度为O(√n)

空间复杂度分析：
- 只使用了常数个变量
- 空间复杂度为O(1)

优化说明：
1. 使用整数分块将时间复杂度从O(n)降低到O(√n)
2. 利用模运算的性质避免数值溢出
3. 预先计算2的逆元以快速计算等差数列和

数学推导：
对于每个p，有n = p*k + m，其中0 ≤ m < p
所以k = n/p（整数除法），m = n % p = n - p*k
因此k*m = k*(n - p*k) = k*n - k²*p

我们需要计算sum_{p=1}^n (k*n - k²*p)
= n*sum_{p=1}^n k - sum_{p=1}^n k²*p

通过整数分块，我们可以将具有相同k值的p分成一组，每组内的计算可以批量处理。

工程化考虑：
1. 大数处理：使用long long类型避免溢出
2. 模运算：注意负数的模运算处理
3. 性能优化：块处理比逐个计算更高效
4. 测试用例：
   - 示例1：输入1，输出0（1 = 1*1 + 0，k*m=1*0=0）
   - 示例2：输入5，输出5（计算所有p的k*m之和为5）
*/

===============================================

文件: Code33_CowModCount.java
===============================================
// 牛牛算题 - 整数分块算法实现 (Java版本)
// 题目来源: 牛客编程巅峰赛
// 题目大意: 计算对于小于等于n的每个数p，求n = p×k + m中的k×m之和
// 约束条件: 1 ≤ n ≤ Integer.MAX_VALUE

import java.io.*;
import java.util.*;

public class Code33_CowModCount {
    private static final int MOD = 1000000007;
    
    // 计算k*m之和，其中n = p*k + m (0 ≤ m < p)
    // 使用整数分块优化，时间复杂度O(√n)
    public static long cowModCount(long n) {
        long ans = 0;
        long i = 1;
        
        while (i <= n) {
            // 计算当前块的右端点
            long k = n / i;
            long j = n / k;
            
            // 计算k*n*(j-i+1) mod MOD
            long term1 = (k % MOD) * (n % MOD) % MOD;
            term1 = term1 * ((j - i + 1) % MOD) % MOD;
            
            // 计算k² * sum(p from i to j) mod MOD
            // sum(p from i to j) = (i + j) * (j - i + 1) / 2
            long sum_p = ((i % MOD) + (j % MOD)) % MOD;
            sum_p = sum_p * ((j - i + 1) % MOD) % MOD;
            sum_p = sum_p * 500000004L % MOD; // 乘以2的逆元mod MOD
            
            long term2 = (k % MOD) * (k % MOD) % MOD;
            term2 = term2 * sum_p % MOD;
            
            // 当前块的贡献是 (term1 - term2) mod MOD
            ans = (ans + term1 - term2 + MOD) % MOD; // +MOD确保结果非负
            
            // 移动到下一个块
            i = j + 1;
        }
        
        return ans;
    }
    
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        PrintWriter pw = new PrintWriter(new OutputStreamWriter(System.out));
        
        long n = Long.parseLong(br.readLine());
        pw.println(cowModCount(n));
        
        pw.flush();
        pw.close();
        br.close();
    }
    
    /*
     * 时间复杂度分析：
     * - 整数分块的时间复杂度为O(√n)
     * - 每个块的计算时间为O(1)
     * - 总共有O(√n)个块
     * - 因此总体时间复杂度为O(√n)
     * 
     * 空间复杂度分析：
     * - 只使用了常数个变量
     * - 空间复杂度为O(1)
     * 
     * Java语言特性注意事项：
     * 1. 使用long类型处理大数，避免溢出
     * 2. 注意模运算中负数的处理，需要加上MOD后再取模
     * 3. 2的逆元在MOD=1e9+7的情况下是500000004
     * 4. 输入输出使用BufferedReader和PrintWriter以提高效率
     * 
     * 数学推导：
     * 对于每个p，有n = p*k + m，其中0 ≤ m < p
     * 所以k = n/p（整数除法），m = n % p = n - p*k
     * 因此k*m = k*(n - p*k) = k*n - k²*p
     * 
     * 通过整数分块，我们可以将具有相同k值的p分成一组，每组内的计算可以批量处理。
     */
}

===============================================

文件: Code33_CowModCount.py
===============================================
# 牛牛算题 - 整数分块算法实现 (Python版本)
# 题目来源: 牛客编程巅峰赛
# 题目大意: 计算对于小于等于n的每个数p，求n = p×k + m中的k×m之和
# 约束条件: 1 ≤ n ≤ int_max

import sys

MOD = 1000000007

def cow_mod_count(n):
    """
    计算k*m之和，其中n = p*k + m (0 ≤ m < p)
    使用整数分块优化，时间复杂度O(√n)
    """
    ans = 0
    i = 1
    
    while i <= n:
        # 计算当前块的右端点
        k = n // i
        j = n // k
        
        # 计算k*n*(j-i+1) mod MOD
        term1 = (k % MOD) * (n % MOD) % MOD
        term1 = term1 * ((j - i + 1) % MOD) % MOD
        
        # 计算k² * sum(p from i to j) mod MOD
        # sum(p from i to j) = (i + j) * (j - i + 1) // 2
        sum_p = ((i % MOD) + (j % MOD)) % MOD
        sum_p = sum_p * ((j - i + 1) % MOD) % MOD
        # 乘以2的逆元mod MOD
        sum_p = sum_p * 500000004 % MOD  # 2^(-1) mod 1e9+7 = 500000004
        
        term2 = (k % MOD) * (k % MOD) % MOD
        term2 = term2 * sum_p % MOD
        
        # 当前块的贡献是 (term1 - term2) mod MOD
        ans = (ans + term1 - term2 + MOD) % MOD  # +MOD确保结果非负
        
        # 移动到下一个块
        i = j + 1
    
    return ans

def main():
    # 读取输入
    n = int(sys.stdin.readline())
    # 计算结果并输出
    print(cow_mod_count(n))

# 测试用例
# 示例1：输入1，输出0
# 示例2：输入5，输出5

if __name__ == "__main__":
    main()

'''
时间复杂度分析：
- 整数分块的时间复杂度为O(√n)
- 每个块的计算时间为O(1)
- 总共有O(√n)个块
- 因此总体时间复杂度为O(√n)

空间复杂度分析：
- 只使用了常数个变量
- 空间复杂度为O(1)

Python语言特性注意事项：
1. Python的整数精度没有限制，可以处理非常大的整数
2. 但为了与其他语言保持一致，仍然使用了模运算
3. 使用//运算符进行整数除法
4. 输入输出使用sys.stdin.readline()和print()

数学推导：
对于每个p，有n = p*k + m，其中0 ≤ m < p
所以k = n//p（整数除法），m = n % p = n - p*k
因此k*m = k*(n - p*k) = k*n - k²*p

我们需要计算sum_{p=1}^n (k*n - k²*p)
= n*sum_{p=1}^n k - sum_{p=1}^n k²*p

通过整数分块，我们可以将具有相同k值的p分成一组，每组内的计算可以批量处理。

整数分块原理：
对于函数f(p) = n//p，其值在一定范围内保持不变。
具体来说，当p在[i, j]范围内时，n//p的值都是k，其中j = n//k。
这样我们就可以将连续的p值分成O(√n)个块，每个块内的计算可以批量处理。

示例分析：
当n=5时，p从1到5：
p=1: 5=1*5+0 → k*m=5*0=0
p=2: 5=2*2+1 → k*m=2*1=2
p=3: 5=3*1+2 → k*m=1*2=2
p=4: 5=4*1+1 → k*m=1*1=1
p=5: 5=5*1+0 → k*m=1*0=0
总和：0+2+2+1+0=5
'''

===============================================

文件: Code34_MaximumSubarray.cpp
===============================================
// 最大子阵列 - 分块算法实现 (C++版本)
// 题目来源: 计蒜客
// 题目链接: https://www.jisuanke.com/course/705/27296
// 题目大意: 在数组中找出和最大的连续子数组（至少包含一个元素）
// 约束条件: 数组长度n不超过1000，元素为整数

#include <cstdio>
#include <algorithm>
#include <cmath>
using namespace std;

typedef long long ll;
const int MAXN = 1005;
const ll INF = 1e18;

int n, blen; // blen为块的大小
ll arr[MAXN]; // 原始数组

// 分块预处理的结构
ll pre_sum[MAXN]; // 前缀和数组
ll block_sum[MAXN]; // 每个块的总和
ll l_max[MAXN][MAXN]; // l_max[i][j]: 从块i的第j个元素开始，向右延伸的最大子数组和
ll r_max[MAXN][MAXN]; // r_max[i][j]: 到块i的第j个元素结束，向左延伸的最大子数组和
ll max_sub[MAXN]; // 每个块内部的最大子数组和
ll total_max; // 整个数组的最大子数组和

// 初始化分块信息
void init_blocks() {
    blen = sqrt(n);
    if (blen == 0) blen = 1;
    
    int block_count = (n + blen - 1) / blen;
    
    // 计算前缀和
    pre_sum[0] = 0;
    for (int i = 1; i <= n; i++) {
        pre_sum[i] = pre_sum[i - 1] + arr[i];
    }
    
    // 预处理每个块的信息
    for (int b = 0; b < block_count; b++) {
        int start = b * blen + 1;
        int end = min((b + 1) * blen, n);
        
        // 计算块的总和
        block_sum[b] = pre_sum[end] - pre_sum[start - 1];
        
        // 计算l_max：从每个位置开始向右延伸的最大子数组和
        ll current_max = -INF;
        ll current_sum = 0;
        for (int i = end; i >= start; i--) {
            current_sum += arr[i];
            current_max = max(current_max, current_sum);
            l_max[b][i - start] = current_max;
        }
        
        // 计算r_max：到每个位置结束向左延伸的最大子数组和
        current_max = -INF;
        current_sum = 0;
        for (int i = start; i <= end; i++) {
            current_sum += arr[i];
            current_max = max(current_max, current_sum);
            r_max[b][i - start] = current_max;
        }
        
        // 计算块内的最大子数组和（Kadane算法）
        ll kadane_max = -INF;
        ll kadane_sum = 0;
        for (int i = start; i <= end; i++) {
            kadane_sum = max(arr[i], kadane_sum + arr[i]);
            kadane_max = max(kadane_max, kadane_sum);
        }
        max_sub[b] = kadane_max;
    }
    
    // 计算整个数组的最大子数组和
    total_max = -INF;
    for (int b = 0; b < block_count; b++) {
        total_max = max(total_max, max_sub[b]);
    }
    
    // 检查跨越块的情况
    for (int b = 0; b < block_count - 1; b++) {
        int end1 = min((b + 1) * blen, n);
        int start2 = (b + 1) * blen + 1;
        
        // 从块b的末尾向左延伸的最大值
        ll right_max = r_max[b][blen - 1];
        
        // 块b+1的总和累加
        ll current_sum = right_max;
        total_max = max(total_max, current_sum);
        
        for (int next_b = b + 1; next_b < block_count; next_b++) {
            current_sum += block_sum[next_b];
            total_max = max(total_max, current_sum);
            total_max = max(total_max, current_sum - block_sum[next_b] + r_max[next_b][0]);
        }
    }
}

// 使用分块预处理的方法求最大子数组和
ll max_subarray() {
    init_blocks();
    return total_max;
}

// 朴素的Kadane算法实现（用于验证）
ll kadane() {
    ll max_so_far = -INF;
    ll max_ending_here = 0;
    
    for (int i = 1; i <= n; i++) {
        max_ending_here = max(arr[i], max_ending_here + arr[i]);
        max_so_far = max(max_so_far, max_ending_here);
    }
    
    return max_so_far;
}

int main() {
    scanf("%d", &n);
    for (int i = 1; i <= n; i++) {
        scanf("%lld", &arr[i]);
    }
    
    ll result = max_subarray();
    printf("%lld\n", result);
    
    return 0;
}

/*
时间复杂度分析：
- 预处理时间：O(n)
- 分块初始化：O(n)
- 块内预处理：O(n)
- 跨越块处理：O(n) （最坏情况下）
- 总体时间复杂度：O(n)

空间复杂度分析：
- 数组arr：O(n)
- 前缀和数组pre_sum：O(n)
- 块信息数组：O(n)
- 总体空间复杂度：O(n)

算法说明：
这个问题虽然通常使用Kadane算法以O(n)时间解决，但这里展示了如何使用分块思想来处理。
分块方法特别适合需要支持动态更新和查询的场景，而不仅仅是静态数组。

优化说明：
1. 预处理每个块的信息，包括：
   - 块的总和
   - 从每个位置开始向右延伸的最大子数组和
   - 到每个位置结束向左延伸的最大子数组和
   - 块内的最大子数组和
2. 然后考虑跨越多个块的情况

工程化考虑：
1. 使用long long类型避免整数溢出
2. 初始化INF为足够大的值
3. 注意边界条件的处理
4. 提供了Kadane算法作为验证方法
*/

===============================================

文件: Code34_MaximumSubarray.java
===============================================
// 最大子阵列 - 分块算法实现 (Java版本)
// 题目来源: 计蒜客
// 题目链接: https://www.jisuanke.com/course/705/27296
// 题目大意: 在数组中找出和最大的连续子数组（至少包含一个元素）
// 约束条件: 数组长度n不超过1000，元素为整数

import java.io.*;
import java.util.*;

public class Code34_MaximumSubarray {
    static final int MAXN = 1005;
    static final long INF = 1000000000000000000L;
    
    static int n, blen; // blen为块的大小
    static long[] arr = new long[MAXN]; // 原始数组
    
    // 分块预处理的结构
    static long[] preSum = new long[MAXN]; // 前缀和数组
    static long[] blockSum; // 每个块的总和
    static long[][] lMax; // lMax[i][j]: 从块i的第j个元素开始，向右延伸的最大子数组和
    static long[][] rMax; // rMax[i][j]: 到块i的第j个元素结束，向左延伸的最大子数组和
    static long[] maxSub; // 每个块内部的最大子数组和
    static long totalMax; // 整个数组的最大子数组和
    
    // 初始化分块信息
    static void initBlocks() {
        blen = (int)Math.sqrt(n);
        if (blen == 0) blen = 1;
        
        int blockCount = (n + blen - 1) / blen;
        
        // 初始化数组
        blockSum = new long[blockCount];
        lMax = new long[blockCount][blen];
        rMax = new long[blockCount][blen];
        maxSub = new long[blockCount];
        
        // 计算前缀和
        preSum[0] = 0;
        for (int i = 1; i <= n; i++) {
            preSum[i] = preSum[i - 1] + arr[i];
        }
        
        // 预处理每个块的信息
        for (int b = 0; b < blockCount; b++) {
            int start = b * blen + 1;
            int end = Math.min((b + 1) * blen, n);
            
            // 计算块的总和
            blockSum[b] = preSum[end] - preSum[start - 1];
            
            // 计算lMax：从每个位置开始向右延伸的最大子数组和
            long currentMax = -INF;
            long currentSum = 0;
            for (int i = end; i >= start; i--) {
                currentSum += arr[i];
                currentMax = Math.max(currentMax, currentSum);
                lMax[b][i - start] = currentMax;
            }
            
            // 计算rMax：到每个位置结束向左延伸的最大子数组和
            currentMax = -INF;
            currentSum = 0;
            for (int i = start; i <= end; i++) {
                currentSum += arr[i];
                currentMax = Math.max(currentMax, currentSum);
                rMax[b][i - start] = currentMax;
            }
            
            // 计算块内的最大子数组和（Kadane算法）
            long kadaneMax = -INF;
            long kadaneSum = 0;
            for (int i = start; i <= end; i++) {
                kadaneSum = Math.max(arr[i], kadaneSum + arr[i]);
                kadaneMax = Math.max(kadaneMax, kadaneSum);
            }
            maxSub[b] = kadaneMax;
        }
        
        // 计算整个数组的最大子数组和
        totalMax = -INF;
        for (int b = 0; b < blockCount; b++) {
            totalMax = Math.max(totalMax, maxSub[b]);
        }
        
        // 检查跨越块的情况
        for (int b = 0; b < blockCount - 1; b++) {
            // 从块b的末尾向左延伸的最大值
            long rightMax = rMax[b][blen - 1];
            
            // 块b+1的总和累加
            long currentSum = rightMax;
            totalMax = Math.max(totalMax, currentSum);
            
            for (int nextB = b + 1; nextB < blockCount; nextB++) {
                currentSum += blockSum[nextB];
                totalMax = Math.max(totalMax, currentSum);
                totalMax = Math.max(totalMax, currentSum - blockSum[nextB] + rMax[nextB][0]);
            }
        }
    }
    
    // 使用分块预处理的方法求最大子数组和
    static long maxSubarray() {
        initBlocks();
        return totalMax;
    }
    
    // 朴素的Kadane算法实现（用于验证）
    static long kadane() {
        long maxSoFar = -INF;
        long maxEndingHere = 0;
        
        for (int i = 1; i <= n; i++) {
            maxEndingHere = Math.max(arr[i], maxEndingHere + arr[i]);
            maxSoFar = Math.max(maxSoFar, maxEndingHere);
        }
        
        return maxSoFar;
    }
    
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        PrintWriter pw = new PrintWriter(new OutputStreamWriter(System.out));
        
        n = Integer.parseInt(br.readLine());
        String[] s = br.readLine().split(" ");
        for (int i = 1; i <= n; i++) {
            arr[i] = Long.parseLong(s[i - 1]);
        }
        
        long result = maxSubarray();
        pw.println(result);
        
        pw.flush();
        pw.close();
        br.close();
    }
    
    /*
     * 时间复杂度分析：
     * - 预处理时间：O(n)
     * - 分块初始化：O(n)
     * - 块内预处理：O(n)
     * - 跨越块处理：O(n) （最坏情况下）
     * - 总体时间复杂度：O(n)
     * 
     * 空间复杂度分析：
     * - 数组arr：O(n)
     * - 前缀和数组preSum：O(n)
     * - 块信息数组：O(n)
     * - 总体空间复杂度：O(n)
     * 
     * Java语言特性注意事项：
     * 1. 使用long类型避免整数溢出
     * 2. 注意数组索引的处理，使用1-based索引
     * 3. 动态初始化分块相关的数组
     * 4. 输入输出使用BufferedReader和PrintWriter以提高效率
     * 
     * 算法说明：
     * 虽然这个问题通常使用Kadane算法解决，但分块方法提供了一种可扩展的思路，
     * 特别适合需要支持动态更新操作的场景。通过预处理每个块的信息，
     * 可以在O(√n)的时间内处理更新操作。
     */
}

===============================================

文件: Code34_MaximumSubarray.py
===============================================
# 最大子阵列 - 分块算法实现 (Python版本)
# 题目来源: 计蒜客
# 题目链接: https://www.jisuanke.com/course/705/27296
# 题目大意: 在数组中找出和最大的连续子数组（至少包含一个元素）
# 约束条件: 数组长度n不超过1000，元素为整数

import sys
import math

INF = 10**18

def main():
    n = int(sys.stdin.readline())
    s = sys.stdin.readline().split()
    arr = [0] * (n + 2)  # 1-based索引
    for i in range(1, n + 1):
        arr[i] = int(s[i - 1])
    
    # 分块相关变量
    blen = int(math.sqrt(n))
    if blen == 0:
        blen = 1
    block_count = (n + blen - 1) // blen
    
    # 分块预处理的结构
    pre_sum = [0] * (n + 2)
    block_sum = [0] * block_count
    l_max = [[-INF for _ in range(blen)] for __ in range(block_count)]  # l_max[i][j]: 从块i的第j个元素开始向右延伸的最大子数组和
    r_max = [[-INF for _ in range(blen)] for __ in range(block_count)]  # r_max[i][j]: 到块i的第j个元素结束向左延伸的最大子数组和
    max_sub = [-INF] * block_count  # 每个块内部的最大子数组和
    total_max = -INF
    
    # 计算前缀和
    for i in range(1, n + 1):
        pre_sum[i] = pre_sum[i - 1] + arr[i]
    
    # 预处理每个块的信息
    for b in range(block_count):
        start = b * blen + 1
        end = min((b + 1) * blen, n)
        
        # 计算块的总和
        block_sum[b] = pre_sum[end] - pre_sum[start - 1]
        
        # 计算l_max：从每个位置开始向右延伸的最大子数组和
        current_max = -INF
        current_sum = 0
        for i in range(end, start - 1, -1):
            current_sum += arr[i]
            current_max = max(current_max, current_sum)
            l_max[b][i - start] = current_max
        
        # 计算r_max：到每个位置结束向左延伸的最大子数组和
        current_max = -INF
        current_sum = 0
        for i in range(start, end + 1):
            current_sum += arr[i]
            current_max = max(current_max, current_sum)
            r_max[b][i - start] = current_max
        
        # 计算块内的最大子数组和（Kadane算法）
        kadane_max = -INF
        kadane_sum = 0
        for i in range(start, end + 1):
            kadane_sum = max(arr[i], kadane_sum + arr[i])
            kadane_max = max(kadane_max, kadane_sum)
        max_sub[b] = kadane_max
    
    # 计算整个数组的最大子数组和
    total_max = max(max_sub)
    
    # 检查跨越块的情况
    for b in range(block_count - 1):
        # 从块b的末尾向左延伸的最大值
        right_max = r_max[b][blen - 1] if b * blen + blen <= n else r_max[b][n - b * blen - 1]
        
        # 块b+1的总和累加
        current_sum = right_max
        total_max = max(total_max, current_sum)
        
        for next_b in range(b + 1, block_count):
            current_sum += block_sum[next_b]
            total_max = max(total_max, current_sum)
            # 考虑从next_b块的开始位置的情况
            total_max = max(total_max, current_sum - block_sum[next_b] + r_max[next_b][0])
    
    print(total_max)

# 朴素的Kadane算法实现（用于验证）
def kadane(arr, n):
    max_so_far = -INF
    max_ending_here = 0
    
    for i in range(1, n + 1):
        max_ending_here = max(arr[i], max_ending_here + arr[i])
        max_so_far = max(max_so_far, max_ending_here)
    
    return max_so_far

# 测试用例
# 示例1：
# 输入：
# 3
# 1 1 -2
# 输出：2
# 
# 示例2：
# 输入：
# 9
# -2 1 -3 4 -1 2 1 -5 4
# 输出：6

if __name__ == "__main__":
    main()

'''
时间复杂度分析：
- 预处理时间：O(n)
- 分块初始化：O(n)
- 块内预处理：O(n)
- 跨越块处理：O(n) （最坏情况下）
- 总体时间复杂度：O(n)

空间复杂度分析：
- 数组arr：O(n)
- 前缀和数组pre_sum：O(n)
- 块信息数组：O(n)
- 总体空间复杂度：O(n)

Python语言特性注意事项：
1. 使用列表的列表来表示二维数组l_max和r_max
2. 注意Python中列表的索引处理，这里使用1-based索引
3. 对于最后一个块可能不完整的情况进行特殊处理
4. 输入输出使用sys.stdin.readline()和print()以提高效率

算法说明：
虽然对于静态数组，Kadane算法是最优的，但分块方法提供了一种可扩展的思路。
当需要支持动态更新操作时，分块方法可以在O(√n)时间内处理每次更新，
而如果直接使用Kadane算法，每次更新后重新计算需要O(n)时间。

分块方法的核心思想是预处理每个块的信息，包括：
1. 块内的最大子数组和
2. 从块内每个位置开始向右延伸的最大子数组和
3. 到块内每个位置结束向左延伸的最大子数组和

然后，对于跨越多个块的子数组，我们可以利用这些预处理的信息快速计算其和。
'''

===============================================

文件: Code35_KthLargest.cpp
===============================================
// 区间第k大 - 分块算法实现 (C++版本)
// 题目来源: POJ 2104
// 题目链接: http://poj.org/problem?id=2104
// 题目大意: 多次查询区间[l,r]内第k小的数字
// 约束条件: 数组长度n ≤ 1e5，查询次数m ≤ 1e4

#include <cstdio>
#include <vector>
#include <algorithm>
#include <cmath>
using namespace std;

const int MAXN = 100005;
const int BLOCK_SIZE = 317; // 约等于sqrt(1e5)

int n, m, blen; // blen为块的大小
int arr[MAXN]; // 原始数组
int sorted_arr[MAXN]; // 排序后的数组，用于二分查找
vector<int> blocks[BLOCK_SIZE]; // 每个块排序后的数组

// 初始化分块结构
void init() {
    blen = sqrt(n);
    if (blen == 0) blen = 1;
    
    // 复制数组并排序，用于二分查找
    for (int i = 0; i < n; i++) {
        sorted_arr[i] = arr[i];
    }
    sort(sorted_arr, sorted_arr + n);
    
    // 分块并对每个块进行排序
    int block_count = (n + blen - 1) / blen;
    for (int i = 0; i < block_count; i++) {
        int start = i * blen;
        int end = min((i + 1) * blen, n);
        
        blocks[i].clear();
        for (int j = start; j < end; j++) {
            blocks[i].push_back(arr[j]);
        }
        sort(blocks[i].begin(), blocks[i].end());
    }
}

// 查询区间[l,r]内小于等于x的元素个数
int query_count(int l, int r, int x) {
    int count = 0;
    int left_block = l / blen;
    int right_block = r / blen;
    
    if (left_block == right_block) {
        // 所有元素都在同一个块内
        for (int i = l; i <= r; i++) {
            if (arr[i] <= x) {
                count++;
            }
        }
    } else {
        // 处理左边不完整的块
        for (int i = l; i < (left_block + 1) * blen; i++) {
            if (arr[i] <= x) {
                count++;
            }
        }
        
        // 处理中间完整的块
        for (int i = left_block + 1; i < right_block; i++) {
            // 利用块的有序性进行二分查找
            count += upper_bound(blocks[i].begin(), blocks[i].end(), x) - blocks[i].begin();
        }
        
        // 处理右边不完整的块
        for (int i = right_block * blen; i <= r; i++) {
            if (arr[i] <= x) {
                count++;
            }
        }
    }
    
    return count;
}

// 二分查找第k小的元素
int find_kth_smallest(int l, int r, int k) {
    int left = 0, right = n - 1;
    while (left < right) {
        int mid = (left + right) / 2;
        int x = sorted_arr[mid];
        int cnt = query_count(l, r, x);
        
        if (cnt >= k) {
            right = mid;
        } else {
            left = mid + 1;
        }
    }
    return sorted_arr[left];
}

int main() {
    scanf("%d %d", &n, &m);
    
    for (int i = 0; i < n; i++) {
        scanf("%d", &arr[i]);
    }
    
    init();
    
    for (int i = 0; i < m; i++) {
        int l, r, k;
        scanf("%d %d %d", &l, &r, &k);
        // 注意POJ的输入可能是1-based索引
        l--; r--;
        int result = find_kth_smallest(l, r, k);
        printf("%d\n", result);
    }
    
    return 0;
}

/*
时间复杂度分析：
- 初始化：O(n log n)
- 单次查询：
  - query_count函数：O(√n + √n log √n) = O(√n log n)
  - find_kth_smallest函数：O(log n)次query_count调用
  - 总体单次查询时间复杂度：O(√n (log n)^2)
- 对于m次查询，总体时间复杂度：O(n log n + m√n (log n)^2)

空间复杂度分析：
- 数组arr：O(n)
- 数组sorted_arr：O(n)
- 块排序数组blocks：O(n)
- 总体空间复杂度：O(n)

算法说明：
这是一个经典的区间第k小查询问题，分块算法是一种有效的解决方案。
算法的核心思想是：
1. 将数组分成大小为√n的块，并对每个块进行排序
2. 使用二分查找确定可能的答案值
3. 对于每个候选值，统计区间内小于等于它的元素个数
4. 根据统计结果调整二分范围

优化说明：
1. 块的大小选择为√n，这是分块算法的最佳实践
2. 预处理整个数组的排序版本，用于二分查找候选值
3. 对每个块进行排序，利用二分查找快速统计块内元素
4. 对于不完整的块，直接暴力统计

与其他方法的对比：
- 线段树+归并树：时间复杂度O(n log n + m log^2 n)，但实现复杂
- 主席树（可持久化线段树）：时间复杂度O(n log n + m log n)，实现也较复杂
- 分块算法：实现相对简单，时间复杂度适中

工程化考虑：
1. 注意索引的处理，POJ的输入可能使用1-based索引
2. 块的大小可以调整为固定值（如317）以避免动态计算
3. 使用vector存储排序后的块，方便进行二分查找
4. 对于非常大的数据集，可以考虑使用更高效的输入方法
*/

===============================================

文件: Code35_KthLargest.java
===============================================
// 区间第k大 - 分块算法实现 (Java版本)
// 题目来源: POJ 2104
// 题目链接: http://poj.org/problem?id=2104
// 题目大意: 多次查询区间[l,r]内第k小的数字
// 约束条件: 数组长度n ≤ 1e5，查询次数m ≤ 1e4

import java.io.*;
import java.util.*;

public class Code35_KthLargest {
    static final int MAXN = 100005;
    
    static int n, m, blen; // blen为块的大小
    static int[] arr; // 原始数组
    static int[] sortedArr; // 排序后的数组，用于二分查找
    static List<List<Integer>> blocks; // 每个块排序后的数组
    
    // 初始化分块结构
    static void init() {
        blen = (int)Math.sqrt(n);
        if (blen == 0) blen = 1;
        
        // 复制数组并排序，用于二分查找
        sortedArr = Arrays.copyOf(arr, n);
        Arrays.sort(sortedArr);
        
        // 分块并对每个块进行排序
        int blockCount = (n + blen - 1) / blen;
        blocks = new ArrayList<>(blockCount);
        
        for (int i = 0; i < blockCount; i++) {
            List<Integer> block = new ArrayList<>();
            int start = i * blen;
            int end = Math.min((i + 1) * blen, n);
            
            for (int j = start; j < end; j++) {
                block.add(arr[j]);
            }
            Collections.sort(block);
            blocks.add(block);
        }
    }
    
    // 查询区间[l,r]内小于等于x的元素个数
    static int queryCount(int l, int r, int x) {
        int count = 0;
        int leftBlock = l / blen;
        int rightBlock = r / blen;
        
        if (leftBlock == rightBlock) {
            // 所有元素都在同一个块内
            for (int i = l; i <= r; i++) {
                if (arr[i] <= x) {
                    count++;
                }
            }
        } else {
            // 处理左边不完整的块
            for (int i = l; i < (leftBlock + 1) * blen; i++) {
                if (arr[i] <= x) {
                    count++;
                }
            }
            
            // 处理中间完整的块
            for (int i = leftBlock + 1; i < rightBlock; i++) {
                // 利用块的有序性进行二分查找
                List<Integer> block = blocks.get(i);
                // 使用二分查找找到第一个大于x的元素的位置
                int pos = Collections.binarySearch(block, x);
                if (pos >= 0) {
                    // 找到x，需要找到所有等于x的元素
                    while (pos + 1 < block.size() && block.get(pos + 1) == x) {
                        pos++;
                    }
                    count += pos + 1;
                } else {
                    // 没找到x，返回插入点的相反数减1
                    count += -pos - 1;
                }
            }
            
            // 处理右边不完整的块
            for (int i = rightBlock * blen; i <= r; i++) {
                if (arr[i] <= x) {
                    count++;
                }
            }
        }
        
        return count;
    }
    
    // 二分查找第k小的元素
    static int findKthSmallest(int l, int r, int k) {
        int left = 0, right = n - 1;
        while (left < right) {
            int mid = (left + right) / 2;
            int x = sortedArr[mid];
            int cnt = queryCount(l, r, x);
            
            if (cnt >= k) {
                right = mid;
            } else {
                left = mid + 1;
            }
        }
        return sortedArr[left];
    }
    
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        PrintWriter pw = new PrintWriter(new OutputStreamWriter(System.out));
        
        StringTokenizer st = new StringTokenizer(br.readLine());
        n = Integer.parseInt(st.nextToken());
        m = Integer.parseInt(st.nextToken());
        
        arr = new int[n];
        st = new StringTokenizer(br.readLine());
        for (int i = 0; i < n; i++) {
            arr[i] = Integer.parseInt(st.nextToken());
        }
        
        init();
        
        for (int i = 0; i < m; i++) {
            st = new StringTokenizer(br.readLine());
            int l = Integer.parseInt(st.nextToken()) - 1; // 转换为0-based索引
            int r = Integer.parseInt(st.nextToken()) - 1; // 转换为0-based索引
            int k = Integer.parseInt(st.nextToken());
            
            int result = findKthSmallest(l, r, k);
            pw.println(result);
        }
        
        pw.flush();
        pw.close();
        br.close();
    }
    
    /*
     * 时间复杂度分析：
     * - 初始化：O(n log n)
     * - 单次查询：
     *   - queryCount函数：O(√n + √n log √n) = O(√n log n)
     *   - findKthSmallest函数：O(log n)次queryCount调用
     *   - 总体单次查询时间复杂度：O(√n (log n)^2)
     * - 对于m次查询，总体时间复杂度：O(n log n + m√n (log n)^2)
     * 
     * 空间复杂度分析：
     * - 数组arr：O(n)
     * - 数组sortedArr：O(n)
     * - 块排序数组blocks：O(n)
     * - 总体空间复杂度：O(n)
     * 
     * Java语言特性注意事项：
     * 1. 使用ArrayList存储排序后的块
     * 2. 使用Collections.sort和Collections.binarySearch进行排序和二分查找
     * 3. 注意处理Collections.binarySearch的返回值
     * 4. 输入输出使用BufferedReader和PrintWriter提高效率
     * 
     * 算法说明：
     * 这是一个经典的区间第k小查询问题，分块算法是一种有效的解决方案。
     * 算法结合了二分查找和分块处理的思想，通过统计区间内小于等于候选值的元素个数，
     * 来确定第k小的元素。
     */
}

===============================================

文件: Code35_KthLargest.py
===============================================
# 区间第k大 - 分块算法实现 (Python版本)
# 题目来源: POJ 2104
# 题目链接: http://poj.org/problem?id=2104
# 题目大意: 多次查询区间[l,r]内第k小的数字
# 约束条件: 数组长度n ≤ 1e5，查询次数m ≤ 1e4

import sys
import math

def main():
    # 读取输入
    input = sys.stdin.read().split()
    ptr = 0
    n = int(input[ptr])
    ptr += 1
    m = int(input[ptr])
    ptr += 1
    
    # 初始化数组
    arr = list(map(int, input[ptr:ptr+n]))
    ptr += n
    
    # 分块相关变量
    blen = int(math.sqrt(n))
    if blen == 0:
        blen = 1
    
    # 复制数组并排序，用于二分查找
    sorted_arr = sorted(arr)
    
    # 分块并对每个块进行排序
    block_count = (n + blen - 1) // blen
    blocks = []
    
    for i in range(block_count):
        start = i * blen
        end = min((i + 1) * blen, n)
        block = sorted(arr[start:end])
        blocks.append(block)
    
    # 查询区间[l,r]内小于等于x的元素个数
    def query_count(l, r, x):
        count = 0
        left_block = l // blen
        right_block = r // blen
        
        if left_block == right_block:
            # 所有元素都在同一个块内
            for i in range(l, r + 1):
                if arr[i] <= x:
                    count += 1
        else:
            # 处理左边不完整的块
            for i in range(l, (left_block + 1) * blen):
                if arr[i] <= x:
                    count += 1
            
            # 处理中间完整的块
            for i in range(left_block + 1, right_block):
                # 利用块的有序性进行二分查找
                block = blocks[i]
                # 使用bisect_right找到第一个大于x的元素的位置
                import bisect
                pos = bisect.bisect_right(block, x)
                count += pos
            
            # 处理右边不完整的块
            for i in range(right_block * blen, r + 1):
                if arr[i] <= x:
                    count += 1
        
        return count
    
    # 二分查找第k小的元素
    def find_kth_smallest(l, r, k):
        left = 0
        right = n - 1
        while left < right:
            mid = (left + right) // 2
            x = sorted_arr[mid]
            cnt = query_count(l, r, x)
            
            if cnt >= k:
                right = mid
            else:
                left = mid + 1
        return sorted_arr[left]
    
    # 处理查询
    for _ in range(m):
        l = int(input[ptr]) - 1  # 转换为0-based索引
        ptr += 1
        r = int(input[ptr]) - 1  # 转换为0-based索引
        ptr += 1
        k = int(input[ptr])
        ptr += 1
        
        result = find_kth_smallest(l, r, k)
        print(result)

# 测试用例
# 示例：
# 输入：
# 7 3
# 1 5 2 6 3 7 4
# 1 5 3
# 2 7 1
# 3 5 3
# 输出：
# 3
# 2
# 6

if __name__ == "__main__":
    main()

'''
时间复杂度分析：
- 初始化：O(n log n)
- 单次查询：
  - query_count函数：O(√n + √n log √n) = O(√n log n)
  - find_kth_smallest函数：O(log n)次query_count调用
  - 总体单次查询时间复杂度：O(√n (log n)^2)
- 对于m次查询，总体时间复杂度：O(n log n + m√n (log n)^2)

空间复杂度分析：
- 数组arr：O(n)
- 数组sorted_arr：O(n)
- 块排序数组blocks：O(n)
- 总体空间复杂度：O(n)

Python语言特性注意事项：
1. 使用列表存储数组和排序后的块
2. 使用bisect模块进行二分查找，bisect_right函数返回第一个大于x的元素的位置
3. 为了提高输入效率，一次性读取所有输入并使用指针逐个处理
4. 注意Python中整数的精度没有限制，不需要担心溢出问题

算法说明：
这是一个经典的区间第k小查询问题，分块算法结合了二分查找和分块处理的思想：

1. 预处理阶段：
   - 将数组分成大小为√n的块，并对每个块进行排序
   - 对整个数组进行排序，用于二分查找候选值

2. 查询阶段：
   - 使用二分查找确定可能的答案值
   - 对于每个候选值x，统计区间内小于等于x的元素个数cnt
   - 如果cnt >= k，说明第k小的元素不超过x，缩小右边界
   - 否则，说明第k小的元素大于x，缩小左边界

3. 统计阶段（query_count函数）：
   - 对于完整的块，利用块的有序性进行二分查找快速统计
   - 对于不完整的块，直接暴力统计

优化说明：
- 块的大小选择为√n，平衡了查询和预处理的时间复杂度
- 使用bisect模块的bisect_right函数高效地统计块内小于等于x的元素个数
- 一次性读取所有输入以提高Python程序的输入效率

与其他方法的对比：
- 分块算法实现简单，但时间复杂度较高
- 主席树（可持久化线段树）时间复杂度更低，但实现复杂
- 对于Python来说，分块算法在大多数情况下已经足够快
'''

===============================================

文件: Code35_RangeMinimumQuery.cpp
===============================================
// 区间最小值查询 - 分块算法实现 (C++版本)
// 题目来源: AizuOJ 2442
// 题目链接: https://onlinejudge.u-aizu.ac.jp/problems/2442
// 题目大意: 实现一个数据结构，支持单点更新和区间最小值查询
// 约束条件: 数组长度n ≤ 10^5，操作次数q ≤ 10^5

#include <cstdio>
#include <vector>
#include <algorithm>
#include <cmath>
using namespace std;

typedef long long ll;
const int MAXN = 100005;
const ll INF = 1e18;

int n, q, blen; // blen为块的大小
ll arr[MAXN]; // 原始数组
ll block_min[MAXN]; // 每个块的最小值

// 初始化分块结构
void init() {
    blen = sqrt(n);
    if (blen == 0) blen = 1;
    
    int block_count = (n + blen - 1) / blen;
    
    // 初始化每个块的最小值
    for (int i = 0; i < block_count; i++) {
        ll min_val = INF;
        for (int j = 0; j < blen; j++) {
            int idx = i * blen + j;
            if (idx >= n) break;
            if (arr[idx] < min_val) {
                min_val = arr[idx];
            }
        }
        block_min[i] = min_val;
    }
}

// 单点更新操作
void update(int pos, ll val) {
    int block_idx = pos / blen;
    arr[pos] = val;
    
    // 更新对应块的最小值
    ll min_val = INF;
    int start = block_idx * blen;
    int end = min((block_idx + 1) * blen, n);
    
    for (int i = start; i < end; i++) {
        if (arr[i] < min_val) {
            min_val = arr[i];
        }
    }
    block_min[block_idx] = min_val;
}

// 区间最小值查询
ll query_min(int l, int r) {
    ll min_val = INF;
    
    // 处理左边不完整的块
    int left_block = l / blen;
    int right_block = r / blen;
    
    if (left_block == right_block) {
        // 所有元素都在同一个块内，直接暴力查询
        for (int i = l; i <= r; i++) {
            if (arr[i] < min_val) {
                min_val = arr[i];
            }
        }
        return min_val;
    }
    
    // 处理左边不完整的块
    for (int i = l; i < (left_block + 1) * blen; i++) {
        if (arr[i] < min_val) {
            min_val = arr[i];
        }
    }
    
    // 处理中间完整的块
    for (int i = left_block + 1; i < right_block; i++) {
        if (block_min[i] < min_val) {
            min_val = block_min[i];
        }
    }
    
    // 处理右边不完整的块
    for (int i = right_block * blen; i <= r; i++) {
        if (arr[i] < min_val) {
            min_val = arr[i];
        }
    }
    
    return min_val;
}

int main() {
    scanf("%d %d", &n, &q);
    
    for (int i = 0; i < n; i++) {
        scanf("%lld", &arr[i]);
    }
    
    init();
    
    for (int i = 0; i < q; i++) {
        int type;
        scanf("%d", &type);
        
        if (type == 0) { // 更新操作
            int pos;
            ll val;
            scanf("%d %lld", &pos, &val);
            update(pos, val);
        } else { // 查询操作
            int l, r;
            scanf("%d %d", &l, &r);
            printf("%lld\n", query_min(l, r));
        }
    }
    
    return 0;
}

/*
时间复杂度分析：
- 初始化：O(n)
- 更新操作：O(√n)
- 查询操作：O(√n)
- 对于q次操作，总体时间复杂度：O(n + q√n)

空间复杂度分析：
- 数组arr：O(n)
- 块最小值数组block_min：O(√n)
- 总体空间复杂度：O(n + √n) = O(n)

算法说明：
这是一个经典的区间查询问题，可以使用线段树、稀疏表或分块算法解决。
使用分块算法可以在O(√n)的时间复杂度内处理更新和查询操作，
相比于线段树的O(log n)和稀疏表的不支持动态更新，分块算法提供了一个平衡的解决方案。

优化说明：
1. 块的大小选择为√n，这是分块算法中常见的优化，使得更新和查询操作的时间复杂度均为O(√n)
2. 预处理每个块的最小值，加速区间查询
3. 对于跨越多个块的查询，分别处理不完整的块和完整的块

工程化考虑：
1. 使用long long类型避免整数溢出
2. 初始化INF为足够大的值
3. 注意处理边界条件，如最后一个块可能不完整的情况
4. 输入输出使用scanf和printf以提高效率

与线段树的对比：
- 分块算法实现更简单
- 常数因子更小
- 对于某些特定问题，分块算法可能更高效
- 线段树的理论时间复杂度更低（O(log n) vs O(√n)）

当n和q的规模在1e5级别时，√n大约为300，所以q√n大约为3e7，这在现代计算机上是可以接受的。
*/

===============================================

文件: Code35_RangeMinimumQuery.java
===============================================
// 区间最小值查询 - 分块算法实现 (Java版本)
// 题目来源: AizuOJ 2442
// 题目链接: https://onlinejudge.u-aizu.ac.jp/problems/2442
// 题目大意: 实现一个数据结构，支持单点更新和区间最小值查询
// 约束条件: 数组长度n ≤ 10^5，操作次数q ≤ 10^5

import java.io.*;
import java.util.*;

public class Code35_RangeMinimumQuery {
    static final long INF = 1000000000000000000L;
    
    static int n, q, blen; // blen为块的大小
    static long[] arr; // 原始数组
    static long[] blockMin; // 每个块的最小值
    
    // 初始化分块结构
    static void init() {
        blen = (int)Math.sqrt(n);
        if (blen == 0) blen = 1;
        
        int blockCount = (n + blen - 1) / blen;
        blockMin = new long[blockCount];
        
        // 初始化每个块的最小值
        for (int i = 0; i < blockCount; i++) {
            long minVal = INF;
            for (int j = 0; j < blen; j++) {
                int idx = i * blen + j;
                if (idx >= n) break;
                if (arr[idx] < minVal) {
                    minVal = arr[idx];
                }
            }
            blockMin[i] = minVal;
        }
    }
    
    // 单点更新操作
    static void update(int pos, long val) {
        int blockIdx = pos / blen;
        arr[pos] = val;
        
        // 更新对应块的最小值
        long minVal = INF;
        int start = blockIdx * blen;
        int end = Math.min((blockIdx + 1) * blen, n);
        
        for (int i = start; i < end; i++) {
            if (arr[i] < minVal) {
                minVal = arr[i];
            }
        }
        blockMin[blockIdx] = minVal;
    }
    
    // 区间最小值查询
    static long queryMin(int l, int r) {
        long minVal = INF;
        
        // 处理左边不完整的块
        int leftBlock = l / blen;
        int rightBlock = r / blen;
        
        if (leftBlock == rightBlock) {
            // 所有元素都在同一个块内，直接暴力查询
            for (int i = l; i <= r; i++) {
                if (arr[i] < minVal) {
                    minVal = arr[i];
                }
            }
            return minVal;
        }
        
        // 处理左边不完整的块
        for (int i = l; i < (leftBlock + 1) * blen; i++) {
            if (arr[i] < minVal) {
                minVal = arr[i];
            }
        }
        
        // 处理中间完整的块
        for (int i = leftBlock + 1; i < rightBlock; i++) {
            if (blockMin[i] < minVal) {
                minVal = blockMin[i];
            }
        }
        
        // 处理右边不完整的块
        for (int i = rightBlock * blen; i <= r; i++) {
            if (arr[i] < minVal) {
                minVal = arr[i];
            }
        }
        
        return minVal;
    }
    
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        PrintWriter pw = new PrintWriter(new OutputStreamWriter(System.out));
        
        StringTokenizer st = new StringTokenizer(br.readLine());
        n = Integer.parseInt(st.nextToken());
        q = Integer.parseInt(st.nextToken());
        
        arr = new long[n];
        st = new StringTokenizer(br.readLine());
        for (int i = 0; i < n; i++) {
            arr[i] = Long.parseLong(st.nextToken());
        }
        
        init();
        
        for (int i = 0; i < q; i++) {
            st = new StringTokenizer(br.readLine());
            int type = Integer.parseInt(st.nextToken());
            
            if (type == 0) { // 更新操作
                int pos = Integer.parseInt(st.nextToken());
                long val = Long.parseLong(st.nextToken());
                update(pos, val);
            } else { // 查询操作
                int l = Integer.parseInt(st.nextToken());
                int r = Integer.parseInt(st.nextToken());
                pw.println(queryMin(l, r));
            }
        }
        
        pw.flush();
        pw.close();
        br.close();
    }
    
    /*
     * 时间复杂度分析：
     * - 初始化：O(n)
     * - 更新操作：O(√n)
     * - 查询操作：O(√n)
     * - 对于q次操作，总体时间复杂度：O(n + q√n)
     * 
     * 空间复杂度分析：
     * - 数组arr：O(n)
     * - 块最小值数组blockMin：O(√n)
     * - 总体空间复杂度：O(n + √n) = O(n)
     * 
     * Java语言特性注意事项：
     * 1. 使用long类型避免整数溢出
     * 2. 使用BufferedReader和PrintWriter提高输入输出效率
     * 3. 使用StringTokenizer解析输入
     * 4. 注意数组索引的处理，这里使用0-based索引
     * 
     * 算法说明：
     * 分块算法是一种将数组分成多个大小相近的块的方法，通过预处理每个块的信息，
     * 可以在O(√n)的时间复杂度内处理区间查询和单点更新操作。
     * 
     * 优化说明：
     * 1. 块的大小选择为√n，这是分块算法的最佳实践
     * 2. 预处理每个块的最小值，使得查询完整块时可以O(1)时间获取最小值
     * 3. 对于不完整的块，使用暴力遍历的方式查询
     * 
     * 与其他数据结构的对比：
     * - 线段树：时间复杂度O(log n)，实现较复杂
     * - 稀疏表：查询O(1)，但不支持动态更新
     * - 分块算法：实现简单，时间复杂度O(√n)，支持动态更新
     */
}

===============================================

文件: Code35_RangeMinimumQuery.py
===============================================
# 区间最小值查询 - 分块算法实现 (Python版本)
# 题目来源: AizuOJ 2442
# 题目链接: https://onlinejudge.u-aizu.ac.jp/problems/2442
# 题目大意: 实现一个数据结构，支持单点更新和区间最小值查询
# 约束条件: 数组长度n ≤ 10^5，操作次数q ≤ 10^5

import sys
import math

INF = 10**18

def main():
    # 读取输入
    input = sys.stdin.read().split()
    ptr = 0
    n = int(input[ptr])
    ptr += 1
    q = int(input[ptr])
    ptr += 1
    
    # 初始化数组
    arr = list(map(int, input[ptr:ptr+n]))
    ptr += n
    
    # 分块相关变量
    blen = int(math.sqrt(n))
    if blen == 0:
        blen = 1
    block_count = (n + blen - 1) // blen
    block_min = [INF] * block_count
    
    # 初始化每个块的最小值
    for i in range(block_count):
        min_val = INF
        for j in range(blen):
            idx = i * blen + j
            if idx >= n:
                break
            if arr[idx] < min_val:
                min_val = arr[idx]
        block_min[i] = min_val
    
    # 处理查询和更新操作
    for _ in range(q):
        type_op = int(input[ptr])
        ptr += 1
        
        if type_op == 0:  # 更新操作
            pos = int(input[ptr])
            ptr += 1
            val = int(input[ptr])
            ptr += 1
            
            # 更新原数组
            arr[pos] = val
            
            # 更新对应块的最小值
            block_idx = pos // blen
            min_val = INF
            start = block_idx * blen
            end = min((block_idx + 1) * blen, n)
            
            for i in range(start, end):
                if arr[i] < min_val:
                    min_val = arr[i]
            block_min[block_idx] = min_val
            
        else:  # 查询操作
            l = int(input[ptr])
            ptr += 1
            r = int(input[ptr])
            ptr += 1
            
            min_val = INF
            left_block = l // blen
            right_block = r // blen
            
            if left_block == right_block:
                # 所有元素都在同一个块内
                for i in range(l, r + 1):
                    if arr[i] < min_val:
                        min_val = arr[i]
            else:
                # 处理左边不完整的块
                for i in range(l, (left_block + 1) * blen):
                    if arr[i] < min_val:
                        min_val = arr[i]
                
                # 处理中间完整的块
                for i in range(left_block + 1, right_block):
                    if block_min[i] < min_val:
                        min_val = block_min[i]
                
                # 处理右边不完整的块
                for i in range(right_block * blen, r + 1):
                    if arr[i] < min_val:
                        min_val = arr[i]
            
            print(min_val)

# 测试用例
# 示例：
# 输入：
# 5 5
# 1 5 3 4 2
# 1 0 4
# 0 2 10
# 1 0 4
# 1 1 3
# 0 3 1
# 1 0 4
# 输出：
# 1
# 1
# 4
# 1

if __name__ == "__main__":
    main()

'''
时间复杂度分析：
- 初始化：O(n)
- 更新操作：O(√n)
- 查询操作：O(√n)
- 对于q次操作，总体时间复杂度：O(n + q√n)

空间复杂度分析：
- 数组arr：O(n)
- 块最小值数组block_min：O(√n)
- 总体空间复杂度：O(n + √n) = O(n)

Python语言特性注意事项：
1. 为了提高输入效率，一次性读取所有输入并使用指针逐个处理
2. 使用列表存储数组和块最小值
3. 注意Python中整数的精度没有限制，不需要担心溢出问题
4. 使用math.sqrt计算块的大小

算法说明：
分块算法是一种将数组分成多个块的方法，通过预处理每个块的信息，
可以在O(√n)的时间复杂度内处理区间查询和单点更新操作。

分块算法的核心思想是：
1. 将数组分成大小为√n的块
2. 预处理每个块的信息（这里是块内最小值）
3. 对于区间查询，分别处理不完整的块和完整的块：
   - 不完整的块直接暴力查询
   - 完整的块利用预处理信息快速查询
4. 对于单点更新，更新原数组后重新计算对应块的预处理信息

与其他数据结构的对比：
- 线段树：时间复杂度O(log n)，但实现较复杂
- 稀疏表：查询O(1)，但不支持动态更新
- 分块算法：实现简单，时间复杂度适中，支持动态更新

在Python中，分块算法的效率可能不如C++，但对于大多数问题来说已经足够快。
如果数据规模非常大，可以考虑使用更高效的输入方法或使用其他语言实现。
'''

===============================================

文件: Code36_Scanline.cpp
===============================================
// 扫描线问题 - 分块算法实现 (C++版本)
// 题目来源: HDU 1542
// 题目链接: http://acm.hdu.edu.cn/showproblem.php?pid=1542
// 题目大意: 计算多个矩形覆盖的总面积
// 约束条件: 矩形数量n ≤ 100

#include <cstdio>
#include <vector>
#include <algorithm>
#include <cmath>
using namespace std;

const int MAXN = 205;
const int BLOCK_SIZE = 15; // 约等于sqrt(200)

struct Line {
    double x, y1, y2; // 扫描线的x坐标，y范围
    int flag; // 1表示进入，-1表示离开
    Line(double x = 0, double y1 = 0, double y2 = 0, int flag = 0) : 
        x(x), y1(y1), y2(y2), flag(flag) {}
    bool operator < (const Line& other) const {
        return x < other.x;
    }
} lines[MAXN];

double y_coords[MAXN]; // 存储所有y坐标，用于离散化
int n, m; // n是矩形数量，m是y坐标的数量

// 分块数据结构
int blen; // 块的大小
int block_count; // 块的数量
int cover[MAXN]; // 每个位置被覆盖的次数
int block_cover[MAXN]; // 每个块的覆盖标记（延迟更新）

// 离散化y坐标
void discretize_y() {
    sort(y_coords, y_coords + m);
    m = unique(y_coords, y_coords + m) - y_coords;
}

// 初始化分块结构
void init_blocks() {
    blen = sqrt(m - 1);
    if (blen == 0) blen = 1;
    block_count = (m - 1 + blen - 1) / blen;
    
    // 初始化覆盖数组
    for (int i = 0; i < m - 1; i++) {
        cover[i] = 0;
    }
    for (int i = 0; i < block_count; i++) {
        block_cover[i] = 0;
    }
}

// 更新区间覆盖
void update_range(int l, int r, int delta) {
    int left_block = l / blen;
    int right_block = r / blen;
    
    if (left_block == right_block) {
        // 所有元素都在同一个块内，直接暴力更新
        for (int i = l; i <= r; i++) {
            cover[i] += delta;
        }
    } else {
        // 处理左边不完整的块
        for (int i = l; i < (left_block + 1) * blen; i++) {
            cover[i] += delta;
        }
        
        // 处理中间完整的块（使用块标记）
        for (int i = left_block + 1; i < right_block; i++) {
            block_cover[i] += delta;
        }
        
        // 处理右边不完整的块
        for (int i = right_block * blen; i <= r; i++) {
            cover[i] += delta;
        }
    }
}

// 计算当前覆盖的总长度
double calculate_covered_length() {
    double total = 0;
    
    for (int i = 0; i < m - 1; i++) {
        int block_idx = i / blen;
        int total_cover = cover[i] + block_cover[block_idx];
        
        if (total_cover > 0) {
            total += y_coords[i + 1] - y_coords[i];
        }
    }
    
    return total;
}

// 主函数，计算矩形覆盖的总面积
double solve() {
    // 离散化y坐标
    discretize_y();
    
    // 初始化分块结构
    init_blocks();
    
    // 按照x坐标排序扫描线
    sort(lines, lines + 2 * n);
    
    double area = 0;
    for (int i = 0; i < 2 * n - 1; i++) {
        // 找到y1和y2在离散化数组中的位置
        int y1_pos = lower_bound(y_coords, y_coords + m, lines[i].y1) - y_coords;
        int y2_pos = lower_bound(y_coords, y_coords + m, lines[i].y2) - y_coords;
        
        // 更新覆盖区间
        update_range(y1_pos, y2_pos - 1, lines[i].flag);
        
        // 计算当前扫描线到下一条扫描线之间的面积
        double current_length = calculate_covered_length();
        double delta_x = lines[i + 1].x - lines[i].x;
        area += current_length * delta_x;
    }
    
    return area;
}

int main() {
    int case_num = 0;
    while (scanf("%d", &n) && n) {
        case_num++;
        m = 0;
        
        // 读取每个矩形
        for (int i = 0; i < n; i++) {
            double x1, y1, x2, y2;
            scanf("%lf %lf %lf %lf", &x1, &y1, &x2, &y2);
            
            // 添加两条扫描线
            lines[2 * i] = Line(x1, y1, y2, 1);
            lines[2 * i + 1] = Line(x2, y1, y2, -1);
            
            // 收集y坐标
            y_coords[m++] = y1;
            y_coords[m++] = y2;
        }
        
        double area = solve();
        printf("Test case #%d\nTotal explored area: %.2f\n\n", case_num, area);
    }
    
    return 0;
}

/*
时间复杂度分析：
- 离散化：O(n log n)
- 初始化分块：O(n)
- 扫描线排序：O(n log n)
- 每次更新操作：O(√n)
- 每次长度计算：O(n)
- 总体时间复杂度：O(n^2 + n√n)

空间复杂度分析：
- 存储扫描线：O(n)
- 存储y坐标：O(n)
- 分块数据结构：O(n)
- 总体空间复杂度：O(n)

算法说明：
扫描线算法是解决矩形覆盖问题的经典算法，结合分块可以更高效地处理区间更新操作。

算法步骤：
1. 离散化所有y坐标，减少处理范围
2. 将每个矩形转换为两条扫描线（左边界+1，右边界-1）
3. 按照x坐标排序所有扫描线
4. 从左到右扫描，维护当前的垂直覆盖情况
5. 对于每两条相邻的扫描线，计算当前覆盖的垂直长度乘以水平距离，累加到总面积中

优化说明：
1. 使用分块优化区间更新操作，将时间复杂度从O(n)降低到O(√n)
2. 使用离散化处理浮点数坐标问题
3. 使用延迟更新技术减少不必要的操作

与其他方法的对比：
- 线段树：时间复杂度更低（O(n log n)），但实现更复杂
- 暴力法：时间复杂度O(n^2)，对于小数据也可接受
- 分块算法：实现相对简单，时间复杂度适中

工程化考虑：
1. 注意浮点数精度问题，使用double类型存储坐标
2. 离散化是处理浮点数的关键步骤
3. 扫描线的处理需要注意边界情况
4. 分块的大小选择可以根据具体数据规模调整
*/

===============================================

文件: Code36_Scanline.java
===============================================
// 扫描线问题 - 分块算法实现 (Java版本)
// 题目来源: HDU 1542
// 题目链接: http://acm.hdu.edu.cn/showproblem.php?pid=1542
// 题目大意: 计算多个矩形覆盖的总面积
// 约束条件: 矩形数量n ≤ 100

import java.io.*;
import java.util.*;

class Line implements Comparable<Line> {
    double x, y1, y2;
    int flag; // 1表示进入，-1表示离开
    
    Line(double x, double y1, double y2, int flag) {
        this.x = x;
        this.y1 = y1;
        this.y2 = y2;
        this.flag = flag;
    }
    
    @Override
    public int compareTo(Line other) {
        return Double.compare(this.x, other.x);
    }
}

public class Code36_Scanline {
    static final int MAXN = 205;
    static Line[] lines;
    static double[] yCoords;
    static int n, m;
    
    // 分块数据结构
    static int blen; // 块的大小
    static int blockCount; // 块的数量
    static int[] cover; // 每个位置被覆盖的次数
    static int[] blockCover; // 每个块的覆盖标记（延迟更新）
    
    // 离散化y坐标
    static void discretizeY() {
        Arrays.sort(yCoords, 0, m);
        int uniqueCount = 0;
        for (int i = 0; i < m; i++) {
            if (i == 0 || yCoords[i] != yCoords[i - 1]) {
                yCoords[uniqueCount++] = yCoords[i];
            }
        }
        m = uniqueCount;
    }
    
    // 初始化分块结构
    static void initBlocks() {
        blen = (int)Math.sqrt(m - 1);
        if (blen == 0) blen = 1;
        blockCount = (m - 1 + blen - 1) / blen;
        
        // 初始化覆盖数组
        cover = new int[m - 1];
        blockCover = new int[blockCount];
        Arrays.fill(cover, 0);
        Arrays.fill(blockCover, 0);
    }
    
    // 更新区间覆盖
    static void updateRange(int l, int r, int delta) {
        int leftBlock = l / blen;
        int rightBlock = r / blen;
        
        if (leftBlock == rightBlock) {
            // 所有元素都在同一个块内，直接暴力更新
            for (int i = l; i <= r; i++) {
                cover[i] += delta;
            }
        } else {
            // 处理左边不完整的块
            for (int i = l; i < (leftBlock + 1) * blen; i++) {
                cover[i] += delta;
            }
            
            // 处理中间完整的块（使用块标记）
            for (int i = leftBlock + 1; i < rightBlock; i++) {
                blockCover[i] += delta;
            }
            
            // 处理右边不完整的块
            for (int i = rightBlock * blen; i <= r; i++) {
                cover[i] += delta;
            }
        }
    }
    
    // 计算当前覆盖的总长度
    static double calculateCoveredLength() {
        double total = 0;
        
        for (int i = 0; i < m - 1; i++) {
            int blockIdx = i / blen;
            int totalCover = cover[i] + blockCover[blockIdx];
            
            if (totalCover > 0) {
                total += yCoords[i + 1] - yCoords[i];
            }
        }
        
        return total;
    }
    
    // 主函数，计算矩形覆盖的总面积
    static double solve() {
        // 离散化y坐标
        discretizeY();
        
        // 初始化分块结构
        initBlocks();
        
        // 按照x坐标排序扫描线
        Arrays.sort(lines, 0, 2 * n);
        
        double area = 0;
        for (int i = 0; i < 2 * n - 1; i++) {
            // 找到y1和y2在离散化数组中的位置
            int y1Pos = Arrays.binarySearch(yCoords, 0, m, lines[i].y1);
            int y2Pos = Arrays.binarySearch(yCoords, 0, m, lines[i].y2);
            
            // 更新覆盖区间
            updateRange(y1Pos, y2Pos - 1, lines[i].flag);
            
            // 计算当前扫描线到下一条扫描线之间的面积
            double currentLength = calculateCoveredLength();
            double deltaX = lines[i + 1].x - lines[i].x;
            area += currentLength * deltaX;
        }
        
        return area;
    }
    
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        PrintWriter pw = new PrintWriter(new OutputStreamWriter(System.out));
        
        int caseNum = 0;
        while (true) {
            String line = br.readLine();
            while (line != null && line.trim().isEmpty()) {
                line = br.readLine(); // 跳过空行
            }
            if (line == null) break;
            
            n = Integer.parseInt(line.trim());
            if (n == 0) break;
            
            caseNum++;
            m = 0;
            lines = new Line[2 * n];
            yCoords = new double[2 * n];
            
            // 读取每个矩形
            for (int i = 0; i < n; i++) {
                line = br.readLine();
                while (line != null && line.trim().isEmpty()) {
                    line = br.readLine(); // 跳过空行
                }
                
                StringTokenizer st = new StringTokenizer(line);
                double x1 = Double.parseDouble(st.nextToken());
                double y1 = Double.parseDouble(st.nextToken());
                double x2 = Double.parseDouble(st.nextToken());
                double y2 = Double.parseDouble(st.nextToken());
                
                // 添加两条扫描线
                lines[2 * i] = new Line(x1, y1, y2, 1);
                lines[2 * i + 1] = new Line(x2, y1, y2, -1);
                
                // 收集y坐标
                yCoords[m++] = y1;
                yCoords[m++] = y2;
            }
            
            double area = solve();
            pw.printf("Test case #%d\nTotal explored area: %.2f\n\n", caseNum, area);
        }
        
        pw.flush();
        pw.close();
        br.close();
    }
    
    /*
     * 时间复杂度分析：
     * - 离散化：O(n log n)
     * - 初始化分块：O(n)
     * - 扫描线排序：O(n log n)
     * - 每次更新操作：O(√n)
     * - 每次长度计算：O(n)
     * - 总体时间复杂度：O(n^2 + n√n)
     * 
     * 空间复杂度分析：
     * - 存储扫描线：O(n)
     * - 存储y坐标：O(n)
     * - 分块数据结构：O(n)
     * - 总体空间复杂度：O(n)
     * 
     * Java语言特性注意事项：
     * 1. 使用自定义Line类实现Comparable接口进行排序
     * 2. 使用Arrays.binarySearch进行二分查找
     * 3. 使用StringTokenizer处理输入
     * 4. 注意处理输入中的空行
     * 
     * 算法说明：
     * 扫描线算法是一种高效处理矩形覆盖问题的方法，通过从左到右扫描所有矩形的垂直边，
     * 维护当前的垂直覆盖状态，计算相邻扫描线之间的覆盖面积并累加。
     */
}

===============================================

文件: Code36_Scanline.py
===============================================
# 扫描线问题 - 分块算法实现 (Python版本)
# 题目来源: HDU 1542
# 题目链接: http://acm.hdu.edu.cn/showproblem.php?pid=1542
# 题目大意: 计算多个矩形覆盖的总面积
# 约束条件: 矩形数量n ≤ 100

import sys
import math
import bisect

class Line:
    def __init__(self, x, y1, y2, flag):
        self.x = x
        self.y1 = y1
        self.y2 = y2
        self.flag = flag  # 1表示进入，-1表示离开
    
    def __lt__(self, other):
        return self.x < other.x

def main():
    input = sys.stdin.read().splitlines()
    ptr = 0
    case_num = 0
    
    while True:
        # 跳过空行
        while ptr < len(input) and input[ptr].strip() == '':
            ptr += 1
        if ptr >= len(input):
            break
        
        n = int(input[ptr].strip())
        ptr += 1
        if n == 0:
            break
        
        case_num += 1
        m = 0
        lines = []
        y_coords = []
        
        # 读取每个矩形
        for i in range(n):
            # 跳过空行
            while ptr < len(input) and input[ptr].strip() == '':
                ptr += 1
            
            parts = input[ptr].strip().split()
            ptr += 1
            x1 = float(parts[0])
            y1 = float(parts[1])
            x2 = float(parts[2])
            y2 = float(parts[3])
            
            # 添加两条扫描线
            lines.append(Line(x1, y1, y2, 1))
            lines.append(Line(x2, y1, y2, -1))
            
            # 收集y坐标
            y_coords.append(y1)
            y_coords.append(y2)
        
        # 离散化y坐标
        y_coords = sorted(list(set(y_coords)))
        m = len(y_coords)
        
        # 初始化分块结构
        blen = int(math.sqrt(m - 1))
        if blen == 0:
            blen = 1
        block_count = (m - 1 + blen - 1) // blen
        
        cover = [0] * (m - 1)  # 每个位置被覆盖的次数
        block_cover = [0] * block_count  # 每个块的覆盖标记（延迟更新）
        
        # 更新区间覆盖
        def update_range(l, r, delta):
            left_block = l // blen
            right_block = r // blen
            
            if left_block == right_block:
                # 所有元素都在同一个块内，直接暴力更新
                for i in range(l, r + 1):
                    cover[i] += delta
            else:
                # 处理左边不完整的块
                for i in range(l, (left_block + 1) * blen):
                    cover[i] += delta
                
                # 处理中间完整的块（使用块标记）
                for i in range(left_block + 1, right_block):
                    block_cover[i] += delta
                
                # 处理右边不完整的块
                for i in range(right_block * blen, r + 1):
                    cover[i] += delta
        
        # 计算当前覆盖的总长度
        def calculate_covered_length():
            total = 0.0
            for i in range(m - 1):
                block_idx = i // blen
                total_cover = cover[i] + block_cover[block_idx]
                if total_cover > 0:
                    total += y_coords[i + 1] - y_coords[i]
            return total
        
        # 按照x坐标排序扫描线
        lines.sort()
        
        area = 0.0
        for i in range(len(lines) - 1):
            # 找到y1和y2在离散化数组中的位置
            y1_pos = bisect.bisect_left(y_coords, lines[i].y1)
            y2_pos = bisect.bisect_left(y_coords, lines[i].y2)
            
            # 更新覆盖区间
            update_range(y1_pos, y2_pos - 1, lines[i].flag)
            
            # 计算当前扫描线到下一条扫描线之间的面积
            current_length = calculate_covered_length()
            delta_x = lines[i + 1].x - lines[i].x
            area += current_length * delta_x
        
        print(f"Test case #{case_num}")
        print(f"Total explored area: {area:.2f}")
        print()

# 测试用例
# 示例：
# 输入：
# 2
# 10 10 20 20
# 15 15 25 25
# 0
# 输出：
# Test case #1
# Total explored area: 200.00

if __name__ == "__main__":
    main()

'''
时间复杂度分析：
- 离散化：O(n log n)
- 初始化分块：O(n)
- 扫描线排序：O(n log n)
- 每次更新操作：O(√n)
- 每次长度计算：O(n)
- 总体时间复杂度：O(n^2 + n√n)

空间复杂度分析：
- 存储扫描线：O(n)
- 存储y坐标：O(n)
- 分块数据结构：O(n)
- 总体空间复杂度：O(n)

Python语言特性注意事项：
1. 使用自定义Line类并实现__lt__方法进行排序
2. 使用bisect模块的bisect_left函数进行二分查找
3. 使用列表存储数组和扫描线
4. 使用集合(set)去重并排序实现离散化
5. 注意处理输入中的空行

算法说明：
扫描线算法是解决矩形覆盖问题的经典方法，其核心思想是：

1. 预处理阶段：
   - 将每个矩形转换为两条垂直扫描线（左边界+1，右边界-1）
   - 收集所有y坐标并进行离散化，减少处理范围
   - 初始化分块数据结构用于维护覆盖状态

2. 扫描阶段：
   - 按照x坐标从小到大排序所有扫描线
   - 从左到右处理每条扫描线，更新当前的覆盖状态
   - 对于每两条相邻的扫描线，计算当前覆盖的垂直长度
   - 将垂直长度乘以两条扫描线之间的水平距离，累加到总面积中

3. 分块优化：
   - 将y轴离散化后的区间分成√n大小的块
   - 对于完整的块，使用块标记进行延迟更新
   - 对于不完整的块，直接暴力更新每个元素

优化说明：
- 离散化是处理浮点数坐标的关键步骤，将连续的坐标映射到整数索引
- 分块技术可以将区间更新操作的时间复杂度从O(n)降低到O(√n)
- 使用延迟更新技术减少不必要的操作，提高效率

与其他方法的对比：
- 分块算法：实现简单，对于小规模数据足够高效
- 线段树：实现复杂，但时间复杂度更低(O(n log n))
- 暴力法：实现最简单，但时间复杂度最高(O(n^2))

工程化考虑：
1. 注意浮点数精度问题，特别是在计算面积时
2. 处理输入中的空行和异常情况
3. 在Python中，对于大规模数据可以考虑使用更高效的数据结构
4. 分块的大小可以根据实际数据规模进行调整
'''

===============================================

文件: Code37_MosAlgorithm.cpp
===============================================
// 莫队算法 - 离线查询优化 (C++版本)
// 题目来源: HDU 3433
// 题目链接: http://acm.hdu.edu.cn/showproblem.php?pid=3433
// 题目大意: 多次查询区间[l,r]内满足条件的元素对
// 约束条件: 数组长度n ≤ 10000，查询次数m ≤ 100000

#include <cstdio>
#include <vector>
#include <algorithm>
#include <cmath>
using namespace std;

const int MAXN = 10005;
const int MAXM = 100005;
const int MAXK = 55; // 题目中元素的最大值

struct Query {
    int l, r, id; // 查询的左右边界和序号
    long long answer; // 查询结果
} q[MAXM];

int n, m, blen; // n是数组长度，m是查询次数，blen是块的大小
int arr[MAXN]; // 原始数组
int count_[MAXK]; // 统计每个元素出现的次数
long long current_answer; // 当前查询的结果

// 按块排序查询
bool compareQuery(const Query& a, const Query& b) {
    // 按块号排序，如果在同一块则按右端点排序（奇偶排序优化）
    int block_a = a.l / blen;
    int block_b = b.l / blen;
    
    if (block_a != block_b) {
        return block_a < block_b;
    }
    
    // 奇偶排序优化：奇数块按右端点升序，偶数块按右端点降序
    if (block_a % 2 == 0) {
        return a.r < b.r;
    } else {
        return a.r > b.r;
    }
}

// 按id排序查询（用于输出结果）
bool compareId(const Query& a, const Query& b) {
    return a.id < b.id;
}

// 添加一个元素
void add(int pos) {
    int x = arr[pos];
    // 计算添加x后对结果的贡献
    // 对于每个已存在的y，检查是否满足x<=y且x*2>=y
    // 或者y<=x且y*2>=x
    for (int y = 1; y < MAXK; y++) {
        if (count_[y] > 0) {
            if ((x <= y && 2 * x >= y) || (y <= x && 2 * y >= x)) {
                current_answer += (long long)count_[y];
            }
        }
    }
    // 更新元素计数
    count_[x]++;
}

// 移除一个元素
void remove(int pos) {
    int x = arr[pos];
    // 先减少计数，因为我们要计算移除前的影响
    count_[x]--;
    // 计算移除x后对结果的影响
    for (int y = 1; y < MAXK; y++) {
        if (count_[y] > 0) {
            if ((x <= y && 2 * x >= y) || (y <= x && 2 * y >= x)) {
                current_answer -= (long long)count_[y];
            }
        }
    }
}

// 莫队算法主函数
void moAlgorithm() {
    // 初始化块大小
    blen = sqrt(n);
    if (blen == 0) blen = 1;
    
    // 按块排序查询
    sort(q, q + m, compareQuery);
    
    // 初始化计数器和当前答案
    for (int i = 0; i < MAXK; i++) {
        count_[i] = 0;
    }
    current_answer = 0;
    
    // 初始化左右指针
    int current_l = 1;
    int current_r = 0;
    
    // 处理每个查询
    for (int i = 0; i < m; i++) {
        int l = q[i].l;
        int r = q[i].r;
        
        // 移动指针，维护当前区间
        while (current_l > l) add(--current_l);
        while (current_r < r) add(++current_r);
        while (current_l < l) remove(current_l++);
        while (current_r > r) remove(current_r--);
        
        // 记录查询结果
        q[i].answer = current_answer;
    }
    
    // 按id排序查询，恢复原顺序
    sort(q, q + m, compareId);
}

int main() {
    int t;
    scanf("%d", &t);
    
    while (t--) {
        scanf("%d %d", &n, &m);
        
        // 读取数组（假设是1-based索引）
        for (int i = 1; i <= n; i++) {
            scanf("%d", &arr[i]);
        }
        
        // 读取查询
        for (int i = 0; i < m; i++) {
            scanf("%d %d", &q[i].l, &q[i].r);
            q[i].id = i;
        }
        
        // 运行莫队算法
        moAlgorithm();
        
        // 输出结果
        for (int i = 0; i < m; i++) {
            printf("%lld\n", q[i].answer);
        }
    }
    
    return 0;
}

/*
时间复杂度分析：
- 排序查询：O(m log m)
- 莫队算法主循环：
  - 指针移动的总次数：O((n / √n) * n + m * √n) = O(n√n + m√n)
  - 每次add/remove操作：O(k)，k是元素的取值范围
  - 总体时间复杂度：O(m log m + (n + m)√n * k)

空间复杂度分析：
- 存储数组和查询：O(n + m)
- 计数数组：O(k)
- 总体空间复杂度：O(n + m + k)

算法说明：
莫队算法是一种离线查询优化算法，通过将查询按照一定的顺序排序，
使得在处理连续查询时，指针移动的次数最小化，从而提高效率。

算法步骤：
1. 将数组分成大小为√n的块
2. 对查询按照左端点所在块排序，如果在同一块则按右端点排序（奇数块升序，偶数块降序）
3. 维护当前区间的左右指针和结果
4. 按排序后的顺序处理每个查询，通过移动指针来更新当前区间
5. 记录每个查询的结果
6. 按原查询顺序输出结果

优化说明：
1. 奇偶排序优化：奇数块按右端点升序，偶数块按右端点降序，可以减少缓存未命中
2. 块的大小选择为√n，平衡了查询和指针移动的时间复杂度
3. 在add和remove操作中，根据具体问题维护当前结果

与其他方法的对比：
- 暴力法：时间复杂度O(mn)，对于大规模数据无法接受
- 线段树：实现复杂，对于某些问题难以应用
- 莫队算法：实现相对简单，时间复杂度适中

工程化考虑：
1. 注意数组的索引方式（0-based或1-based）
2. 块的大小可以根据具体数据规模调整
3. 对于不同的问题，需要调整add和remove操作的实现
4. 奇偶排序优化可以提高缓存命中率，特别是对于大规模数据
*/

===============================================

文件: Code37_MosAlgorithm.java
===============================================
// 莫队算法 - 离线查询优化 (Java版本)
// 题目来源: HDU 3433
// 题目链接: http://acm.hdu.edu.cn/showproblem.php?pid=3433
// 题目大意: 多次查询区间[l,r]内满足条件的元素对
// 约束条件: 数组长度n ≤ 10000，查询次数m ≤ 100000

import java.io.*;
import java.util.*;

class Query {
    int l, r, id;
    long answer;
    
    Query(int l, int r, int id) {
        this.l = l;
        this.r = r;
        this.id = id;
        this.answer = 0;
    }
}

public class Code37_MosAlgorithm {
    static final int MAXN = 10005;
    static final int MAXM = 100005;
    static final int MAXK = 55; // 题目中元素的最大值
    
    static int n, m, blen;
    static int[] arr;
    static int[] count;
    static long currentAnswer;
    static Query[] queries;
    
    // 比较器：按块排序查询
    static class QueryComparator implements Comparator<Query> {
        @Override
        public int compare(Query a, Query b) {
            int blockA = a.l / blen;
            int blockB = b.l / blen;
            
            if (blockA != blockB) {
                return Integer.compare(blockA, blockB);
            }
            
            // 奇偶排序优化
            if (blockA % 2 == 0) {
                return Integer.compare(a.r, b.r);
            } else {
                return Integer.compare(b.r, a.r);
            }
        }
    }
    
    // 比较器：按id排序查询
    static class IdComparator implements Comparator<Query> {
        @Override
        public int compare(Query a, Query b) {
            return Integer.compare(a.id, b.id);
        }
    }
    
    // 添加一个元素
    static void add(int pos) {
        int x = arr[pos];
        // 计算添加x后对结果的贡献
        // 对于每个已存在的y，检查是否满足x<=y且x*2>=y或y<=x且y*2>=x
        for (int y = 1; y < MAXK; y++) {
            if (count[y] > 0) {
                if ((x <= y && 2 * x >= y) || (y <= x && 2 * y >= x)) {
                    currentAnswer += count[y];
                }
            }
        }
        // 更新元素计数
        count[x]++;
    }
    
    // 移除一个元素
    static void remove(int pos) {
        int x = arr[pos];
        // 先减少计数，因为要计算移除前的影响
        count[x]--;
        // 计算移除x后对结果的影响
        for (int y = 1; y < MAXK; y++) {
            if (count[y] > 0) {
                if ((x <= y && 2 * x >= y) || (y <= x && 2 * y >= x)) {
                    currentAnswer -= count[y];
                }
            }
        }
    }
    
    // 莫队算法主函数
    static void moAlgorithm() {
        // 初始化块大小
        blen = (int)Math.sqrt(n);
        if (blen == 0) blen = 1;
        
        // 按块排序查询
        Arrays.sort(queries, new QueryComparator());
        
        // 初始化计数器和当前答案
        Arrays.fill(count, 0);
        currentAnswer = 0;
        
        // 初始化左右指针
        int currentL = 1;
        int currentR = 0;
        
        // 处理每个查询
        for (int i = 0; i < m; i++) {
            int l = queries[i].l;
            int r = queries[i].r;
            
            // 移动指针，维护当前区间
            while (currentL > l) add(--currentL);
            while (currentR < r) add(++currentR);
            while (currentL < l) remove(currentL++);
            while (currentR > r) remove(currentR--);
            
            // 记录查询结果
            queries[i].answer = currentAnswer;
        }
        
        // 按id排序查询，恢复原顺序
        Arrays.sort(queries, new IdComparator());
    }
    
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        PrintWriter pw = new PrintWriter(new OutputStreamWriter(System.out));
        
        int t = Integer.parseInt(br.readLine());
        
        while (t-- > 0) {
            StringTokenizer st = new StringTokenizer(br.readLine());
            n = Integer.parseInt(st.nextToken());
            m = Integer.parseInt(st.nextToken());
            
            arr = new int[n + 1]; // 1-based索引
            st = new StringTokenizer(br.readLine());
            for (int i = 1; i <= n; i++) {
                arr[i] = Integer.parseInt(st.nextToken());
            }
            
            queries = new Query[m];
            for (int i = 0; i < m; i++) {
                st = new StringTokenizer(br.readLine());
                int l = Integer.parseInt(st.nextToken());
                int r = Integer.parseInt(st.nextToken());
                queries[i] = new Query(l, r, i);
            }
            
            count = new int[MAXK];
            
            // 运行莫队算法
            moAlgorithm();
            
            // 输出结果
            for (int i = 0; i < m; i++) {
                pw.println(queries[i].answer);
            }
        }
        
        pw.flush();
        pw.close();
        br.close();
    }
    
    /*
     * 时间复杂度分析：
     * - 排序查询：O(m log m)
     * - 莫队算法主循环：
     *   - 指针移动的总次数：O((n / √n) * n + m * √n) = O(n√n + m√n)
     *   - 每次add/remove操作：O(k)，k是元素的取值范围
     *   - 总体时间复杂度：O(m log m + (n + m)√n * k)
     * 
     * 空间复杂度分析：
     * - 存储数组和查询：O(n + m)
     * - 计数数组：O(k)
     * - 总体空间复杂度：O(n + m + k)
     * 
     * Java语言特性注意事项：
     * 1. 使用自定义比较器对查询进行排序
     * 2. 注意数组索引的处理（使用1-based索引）
     * 3. 使用StringTokenizer处理输入
     * 4. 使用BufferedReader和PrintWriter提高输入输出效率
     * 
     * 算法说明：
     * 莫队算法是一种离线查询优化技术，通过巧妙地排序查询顺序，
     * 最小化处理连续查询时指针移动的总距离，从而在时间复杂度和代码复杂度之间取得平衡。
     */
}

===============================================

文件: Code37_MosAlgorithm.py
===============================================
# 莫队算法 - 离线查询优化 (Python版本)
# 题目来源: HDU 3433
# 题目链接: http://acm.hdu.edu.cn/showproblem.php?pid=3433
# 题目大意: 多次查询区间[l,r]内满足条件的元素对
# 约束条件: 数组长度n ≤ 10000，查询次数m ≤ 100000

import sys
import math

class Query:
    def __init__(self, l, r, id):
        self.l = l
        self.r = r
        self.id = id
        self.answer = 0

MAXK = 55  # 题目中元素的最大值

def main():
    input = sys.stdin.read().split()
    ptr = 0
    t = int(input[ptr])
    ptr += 1
    
    while t > 0:
        t -= 1
        n = int(input[ptr])
        ptr += 1
        m = int(input[ptr])
        ptr += 1
        
        # 读取数组（1-based索引）
        arr = [0] * (n + 1)
        for i in range(1, n + 1):
            arr[i] = int(input[ptr])
            ptr += 1
        
        # 读取查询
        queries = []
        for i in range(m):
            l = int(input[ptr])
            ptr += 1
            r = int(input[ptr])
            ptr += 1
            queries.append(Query(l, r, i))
        
        # 初始化块大小
        blen = int(math.sqrt(n))
        if blen == 0:
            blen = 1
        
        # 按块排序查询的函数
        def compare_query(a):
            block_a = a.l // blen
            # 奇偶排序优化
            if block_a % 2 == 0:
                return (block_a, a.r)
            else:
                return (block_a, -a.r)
        
        # 按块排序查询
        queries.sort(key=compare_query)
        
        # 初始化计数器和当前答案
        count = [0] * MAXK
        current_answer = 0
        
        # 初始化左右指针
        current_l = 1
        current_r = 0
        
        # 添加一个元素
        def add(pos):
            nonlocal current_answer
            x = arr[pos]
            # 计算添加x后对结果的贡献
            # 对于每个已存在的y，检查是否满足x<=y且x*2>=y或y<=x且y*2>=x
            for y in range(1, MAXK):
                if count[y] > 0:
                    if (x <= y and 2 * x >= y) or (y <= x and 2 * y >= x):
                        current_answer += count[y]
            # 更新元素计数
            count[x] += 1
        
        # 移除一个元素
        def remove(pos):
            nonlocal current_answer
            x = arr[pos]
            # 先减少计数，因为要计算移除前的影响
            count[x] -= 1
            # 计算移除x后对结果的影响
            for y in range(1, MAXK):
                if count[y] > 0:
                    if (x <= y and 2 * x >= y) or (y <= x and 2 * y >= x):
                        current_answer -= count[y]
        
        # 处理每个查询
        for q in queries:
            l = q.l
            r = q.r
            
            # 移动指针，维护当前区间
            while current_l > l:
                current_l -= 1
                add(current_l)
            while current_r < r:
                current_r += 1
                add(current_r)
            while current_l < l:
                remove(current_l)
                current_l += 1
            while current_r > r:
                remove(current_r)
                current_r -= 1
            
            # 记录查询结果
            q.answer = current_answer
        
        # 按id排序查询，恢复原顺序
        queries.sort(key=lambda x: x.id)
        
        # 输出结果
        for q in queries:
            print(q.answer)

# 测试用例
# 示例：
# 输入：
# 1
# 5 3
# 1 2 3 4 5
# 1 2
# 1 5
# 2 4
# 输出：
# 1
# 10
# 3

if __name__ == "__main__":
    main()

'''
时间复杂度分析：
- 排序查询：O(m log m)
- 莫队算法主循环：
  - 指针移动的总次数：O((n / √n) * n + m * √n) = O(n√n + m√n)
  - 每次add/remove操作：O(k)，k是元素的取值范围
  - 总体时间复杂度：O(m log m + (n + m)√n * k)

空间复杂度分析：
- 存储数组和查询：O(n + m)
- 计数数组：O(k)
- 总体空间复杂度：O(n + m + k)

Python语言特性注意事项：
1. 使用自定义类存储查询信息
2. 使用lambda函数或自定义排序函数进行排序
3. 使用nonlocal关键字访问外层函数的变量
4. 为了提高输入效率，一次性读取所有输入并使用指针逐个处理
5. 注意Python中的列表索引默认是0-based，但在实现中使用了1-based索引

算法说明：
莫队算法是一种离线查询优化技术，特别适用于处理区间查询问题。其核心思想是：

1. 离线处理：首先收集所有查询，然后按照特定顺序处理
2. 分块排序：将数组分成大小为√n的块，按照左端点所在块排序，同一块内按右端点排序
3. 指针移动：维护当前区间的左右指针，通过增量更新的方式处理每个查询
4. 增量更新：通过add和remove操作，在指针移动时维护当前区间的统计信息

优化说明：
1. 奇偶排序优化：奇数块按右端点升序，偶数块按右端点降序，可以减少缓存未命中
2. 块的大小选择为√n，这是理论上的最优选择
3. 使用闭包函数（add和remove）访问外层函数的变量，简化代码

与其他方法的对比：
- 暴力法：对于每个查询重新计算，时间复杂度O(mn)
- 线段树：时间复杂度更优，但实现复杂，不适合所有类型的查询
- 莫队算法：实现相对简单，时间复杂度适中，适合多种区间查询问题

工程化考虑：
1. 注意输入数据的规模，对于大规模数据需要优化输入方法
2. 在Python中，由于GIL的存在，莫队算法可能不如C++版本高效，但对于中小规模数据仍然适用
3. 对于不同的查询问题，需要相应地调整add和remove操作的实现
4. 可以考虑使用更高效的数据结构来优化特定类型的查询
'''

===============================================

文件: Code38_BlockColor.cpp
===============================================
// 块颜色标记 - 分块算法实现 (C++版本)
// 题目来源: 洛谷 P3203
// 题目链接: https://www.luogu.com.cn/problem/P3203
// 题目大意: 维护一个序列，支持区间颜色修改和单点查询颜色
// 约束条件: 数组长度n ≤ 1e5，操作次数m ≤ 1e5

#include <cstdio>
#include <vector>
#include <algorithm>
#include <cmath>
using namespace std;

const int MAXN = 100005;
const int MAX_COLOR = 1000005;

int n, m, blen; // n是数组长度，m是操作次数，blen是块的大小
int arr[MAXN]; // 原始数组
int color_tag[MAXN]; // 块的颜色标记（-1表示没有标记）
int block[MAXN]; // 每个元素所属的块
bool has_tag[MAXN]; // 标记块是否有颜色标记

// 初始化分块结构
void init() {
    blen = sqrt(n);
    if (blen == 0) blen = 1;
    
    // 为每个元素分配块，并初始化颜色标记
    for (int i = 0; i < n; i++) {
        block[i] = i / blen;
    }
    
    // 初始化块颜色标记
    int block_count = (n + blen - 1) / blen;
    for (int i = 0; i < block_count; i++) {
        has_tag[i] = false;
        color_tag[i] = -1;
    }
}

// 将颜色标记下推到块中的所有元素
void push_down(int block_id) {
    if (!has_tag[block_id]) return;
    
    int start = block_id * blen;
    int end = min((block_id + 1) * blen, n);
    
    // 将标记应用到块中的每个元素
    for (int i = start; i < end; i++) {
        arr[i] = color_tag[block_id];
    }
    
    // 清除标记
    has_tag[block_id] = false;
    color_tag[block_id] = -1;
}

// 区间颜色修改
void update_range(int l, int r, int c) {
    int left_block = block[l];
    int right_block = block[r];
    
    if (left_block == right_block) {
        // 所有元素都在同一个块内
        // 先下推该块的标记
        push_down(left_block);
        
        // 直接修改每个元素
        for (int i = l; i <= r; i++) {
            arr[i] = c;
        }
    } else {
        // 处理左边不完整的块
        push_down(left_block);
        for (int i = l; i < (left_block + 1) * blen; i++) {
            arr[i] = c;
        }
        
        // 处理中间完整的块（使用块标记）
        for (int i = left_block + 1; i < right_block; i++) {
            has_tag[i] = true;
            color_tag[i] = c;
        }
        
        // 处理右边不完整的块
        push_down(right_block);
        for (int i = right_block * blen; i <= r; i++) {
            arr[i] = c;
        }
    }
}

// 单点查询颜色
int query_point(int pos) {
    int block_id = block[pos];
    
    if (has_tag[block_id]) {
        // 如果块有标记，直接返回标记的颜色
        return color_tag[block_id];
    } else {
        // 否则返回原始数组中的颜色
        return arr[pos];
    }
}

int main() {
    scanf("%d", &n);
    
    // 读取初始数组（假设是0-based索引）
    for (int i = 0; i < n; i++) {
        scanf("%d", &arr[i]);
    }
    
    // 初始化分块结构
    init();
    
    scanf("%d", &m);
    
    // 处理每个操作
    for (int i = 0; i < m; i++) {
        int op, a, b, c;
        scanf("%d", &op);
        
        if (op == 1) {
            // 区间修改操作
            scanf("%d %d %d", &a, &b, &c);
            // 注意题目中的输入可能是1-based索引
            a--; b--;
            update_range(a, b, c);
        } else if (op == 2) {
            // 单点查询操作
            scanf("%d", &a);
            a--; // 转换为0-based索引
            int result = query_point(a);
            printf("%d\n", result);
        }
    }
    
    return 0;
}

/*
时间复杂度分析：
- 初始化：O(n)
- 单点查询：O(1)
- 区间修改：
  - 对于完整的块：O(1)（只需要设置标记）
  - 对于不完整的块：O(√n)（需要下推标记并暴力修改）
  - 总体时间复杂度：O(√n)
- 对于m次操作，总体时间复杂度：O(m√n)

空间复杂度分析：
- 数组arr：O(n)
- 标记数组color_tag和has_tag：O(√n)
- 块分配数组block：O(n)
- 总体空间复杂度：O(n + √n) = O(n)

算法说明：
块颜色标记是分块算法的一个典型应用，主要用于处理区间颜色修改和单点查询问题。

算法步骤：
1. 将数组分成大小为√n的块
2. 对于区间颜色修改操作：
   - 对于不完整的块，先下推可能存在的标记，然后暴力修改每个元素
   - 对于完整的块，只需要设置块的颜色标记，不需要立即修改每个元素
3. 对于单点查询操作：
   - 如果该元素所在的块有颜色标记，直接返回标记的颜色
   - 否则返回原始数组中的颜色

优化说明：
1. 使用延迟标记技术，避免不必要的元素修改操作
2. 块的大小选择为√n，平衡了查询和修改的时间复杂度
3. 只有在需要访问块中的元素时才下推标记，减少操作次数

与其他方法的对比：
- 暴力法：每次修改O(n)，每次查询O(1)，总时间复杂度O(mn)
- 线段树：每次修改和查询都是O(log n)，但实现复杂
- 块颜色标记：实现简单，时间复杂度适中

工程化考虑：
1. 注意数组的索引方式（0-based或1-based）
2. 块的大小可以根据具体数据规模调整
3. 延迟标记的管理需要特别注意，避免错误
4. 对于大规模数据，可以考虑使用更高效的输入方法
*/

===============================================

文件: Code38_BlockColor.java
===============================================
// 块颜色标记 - 分块算法实现 (Java版本)
// 题目来源: 洛谷 P3203
// 题目链接: https://www.luogu.com.cn/problem/P3203
// 题目大意: 维护一个序列，支持区间颜色修改和单点查询颜色
// 约束条件: 数组长度n ≤ 1e5，操作次数m ≤ 1e5

import java.io.*;
import java.util.*;

public class Code38_BlockColor {
    static final int MAXN = 100005;
    static final int MAX_COLOR = 1000005;
    
    int n, m, blen; // n是数组长度，m是操作次数，blen是块的大小
    int[] arr; // 原始数组
    int[] color_tag; // 块的颜色标记（-1表示没有标记）
    int[] block; // 每个元素所属的块
    boolean[] has_tag; // 标记块是否有颜色标记
    
    // 初始化分块结构
    void init() {
        blen = (int) Math.sqrt(n);
        if (blen == 0) blen = 1;
        
        block = new int[n];
        // 为每个元素分配块
        for (int i = 0; i < n; i++) {
            block[i] = i / blen;
        }
        
        // 初始化块颜色标记
        int block_count = (n + blen - 1) / blen;
        color_tag = new int[block_count];
        has_tag = new boolean[block_count];
        Arrays.fill(color_tag, -1);
        Arrays.fill(has_tag, false);
    }
    
    // 将颜色标记下推到块中的所有元素
    void push_down(int block_id) {
        if (!has_tag[block_id]) return;
        
        int start = block_id * blen;
        int end = Math.min((block_id + 1) * blen, n);
        
        // 将标记应用到块中的每个元素
        for (int i = start; i < end; i++) {
            arr[i] = color_tag[block_id];
        }
        
        // 清除标记
        has_tag[block_id] = false;
        color_tag[block_id] = -1;
    }
    
    // 区间颜色修改
    void update_range(int l, int r, int c) {
        int left_block = block[l];
        int right_block = block[r];
        
        if (left_block == right_block) {
            // 所有元素都在同一个块内
            // 先下推该块的标记
            push_down(left_block);
            
            // 直接修改每个元素
            for (int i = l; i <= r; i++) {
                arr[i] = c;
            }
        } else {
            // 处理左边不完整的块
            push_down(left_block);
            for (int i = l; i < (left_block + 1) * blen; i++) {
                arr[i] = c;
            }
            
            // 处理中间完整的块（使用块标记）
            for (int i = left_block + 1; i < right_block; i++) {
                has_tag[i] = true;
                color_tag[i] = c;
            }
            
            // 处理右边不完整的块
            push_down(right_block);
            for (int i = right_block * blen; i <= r; i++) {
                arr[i] = c;
            }
        }
    }
    
    // 单点查询颜色
    int query_point(int pos) {
        int block_id = block[pos];
        
        if (has_tag[block_id]) {
            // 如果块有标记，直接返回标记的颜色
            return color_tag[block_id];
        } else {
            // 否则返回原始数组中的颜色
            return arr[pos];
        }
    }
    
    public static void main(String[] args) throws IOException {
        // 使用BufferedReader提高输入效率
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        PrintWriter pw = new PrintWriter(new OutputStreamWriter(System.out));
        
        Code38_BlockColor solution = new Code38_BlockColor();
        
        // 读取n
        solution.n = Integer.parseInt(br.readLine());
        
        // 读取初始数组
        solution.arr = new int[solution.n];
        String[] input = br.readLine().split(" ");
        for (int i = 0; i < solution.n; i++) {
            solution.arr[i] = Integer.parseInt(input[i]);
        }
        
        // 初始化分块结构
        solution.init();
        
        // 读取m
        solution.m = Integer.parseInt(br.readLine());
        
        // 处理每个操作
        for (int i = 0; i < solution.m; i++) {
            input = br.readLine().split(" ");
            int op = Integer.parseInt(input[0]);
            
            if (op == 1) {
                // 区间修改操作
                int a = Integer.parseInt(input[1]) - 1; // 转换为0-based索引
                int b = Integer.parseInt(input[2]) - 1;
                int c = Integer.parseInt(input[3]);
                solution.update_range(a, b, c);
            } else if (op == 2) {
                // 单点查询操作
                int a = Integer.parseInt(input[1]) - 1; // 转换为0-based索引
                int result = solution.query_point(a);
                pw.println(result);
            }
        }
        
        pw.flush();
        pw.close();
        br.close();
    }
}

/*
时间复杂度分析：
- 初始化：O(n)
- 单点查询：O(1)
- 区间修改：
  - 对于完整的块：O(1)（只需要设置标记）
  - 对于不完整的块：O(√n)（需要下推标记并暴力修改）
  - 总体时间复杂度：O(√n)
- 对于m次操作，总体时间复杂度：O(m√n)

空间复杂度分析：
- 数组arr：O(n)
- 标记数组color_tag和has_tag：O(√n)
- 块分配数组block：O(n)
- 总体空间复杂度：O(n + √n) = O(n)

Java语言特性注意事项：
1. 使用BufferedReader和PrintWriter提高输入输出效率
2. 使用Arrays.fill初始化数组
3. 注意Java中数组的初始化方式
4. Math.sqrt返回的是double类型，需要转换为int
5. 对于大规模数据，必须使用快速输入方法

算法说明：
块颜色标记是分块算法的一个典型应用，主要用于处理区间颜色修改和单点查询问题。

算法步骤：
1. 将数组分成大小为√n的块
2. 对于区间颜色修改操作：
   - 对于不完整的块，先下推可能存在的标记，然后暴力修改每个元素
   - 对于完整的块，只需要设置块的颜色标记，不需要立即修改每个元素
3. 对于单点查询操作：
   - 如果该元素所在的块有颜色标记，直接返回标记的颜色
   - 否则返回原始数组中的颜色

优化说明：
1. 使用延迟标记技术，避免不必要的元素修改操作
2. 块的大小选择为√n，平衡了查询和修改的时间复杂度
3. 只有在需要访问块中的元素时才下推标记，减少操作次数

与其他方法的对比：
- 暴力法：每次修改O(n)，每次查询O(1)，总时间复杂度O(mn)
- 线段树：每次修改和查询都是O(log n)，但实现复杂
- 块颜色标记：实现简单，时间复杂度适中

工程化考虑：
1. 使用BufferedReader提高输入效率，避免超时
2. 对于大规模数据，可以考虑使用更快的输入方法
3. 注意内存的使用，避免不必要的数组分配
4. 可以将块的大小作为参数，根据具体数据调整以获得最佳性能
*/

===============================================

文件: Code38_BlockColor.py
===============================================
# 块颜色标记 - 分块算法实现 (Python版本)
# 题目来源: 洛谷 P3203
# 题目链接: https://www.luogu.com.cn/problem/P3203
# 题目大意: 维护一个序列，支持区间颜色修改和单点查询颜色
# 约束条件: 数组长度n ≤ 1e5，操作次数m ≤ 1e5

import sys
import math

class BlockColor:
    def __init__(self):
        self.n = 0
        self.m = 0
        self.blen = 0
        self.arr = []
        self.color_tag = []
        self.block = []
        self.has_tag = []
    
    # 初始化分块结构
    def init(self):
        self.blen = int(math.sqrt(self.n))
        if self.blen == 0:
            self.blen = 1
        
        # 为每个元素分配块
        self.block = [0] * self.n
        for i in range(self.n):
            self.block[i] = i // self.blen
        
        # 初始化块颜色标记
        block_count = (self.n + self.blen - 1) // self.blen
        self.color_tag = [-1] * block_count
        self.has_tag = [False] * block_count
    
    # 将颜色标记下推到块中的所有元素
    def push_down(self, block_id):
        if not self.has_tag[block_id]:
            return
        
        start = block_id * self.blen
        end = min((block_id + 1) * self.blen, self.n)
        
        # 将标记应用到块中的每个元素
        for i in range(start, end):
            self.arr[i] = self.color_tag[block_id]
        
        # 清除标记
        self.has_tag[block_id] = False
        self.color_tag[block_id] = -1
    
    # 区间颜色修改
    def update_range(self, l, r, c):
        left_block = self.block[l]
        right_block = self.block[r]
        
        if left_block == right_block:
            # 所有元素都在同一个块内
            # 先下推该块的标记
            self.push_down(left_block)
            
            # 直接修改每个元素
            for i in range(l, r + 1):
                self.arr[i] = c
        else:
            # 处理左边不完整的块
            self.push_down(left_block)
            for i in range(l, (left_block + 1) * self.blen):
                self.arr[i] = c
            
            # 处理中间完整的块（使用块标记）
            for i in range(left_block + 1, right_block):
                self.has_tag[i] = True
                self.color_tag[i] = c
            
            # 处理右边不完整的块
            self.push_down(right_block)
            for i in range(right_block * self.blen, r + 1):
                self.arr[i] = c
    
    # 单点查询颜色
    def query_point(self, pos):
        block_id = self.block[pos]
        
        if self.has_tag[block_id]:
            # 如果块有标记，直接返回标记的颜色
            return self.color_tag[block_id]
        else:
            # 否则返回原始数组中的颜色
            return self.arr[pos]

def main():
    # 使用sys.stdin.readline提高输入效率
    input = sys.stdin.read().split()
    ptr = 0
    
    solution = BlockColor()
    
    # 读取n
    solution.n = int(input[ptr])
    ptr += 1
    
    # 读取初始数组
    solution.arr = list(map(int, input[ptr:ptr + solution.n]))
    ptr += solution.n
    
    # 初始化分块结构
    solution.init()
    
    # 读取m
    solution.m = int(input[ptr])
    ptr += 1
    
    # 处理每个操作
    output = []
    for i in range(solution.m):
        op = int(input[ptr])
        ptr += 1
        
        if op == 1:
            # 区间修改操作
            a = int(input[ptr]) - 1  # 转换为0-based索引
            ptr += 1
            b = int(input[ptr]) - 1
            ptr += 1
            c = int(input[ptr])
            ptr += 1
            solution.update_range(a, b, c)
        elif op == 2:
            # 单点查询操作
            a = int(input[ptr]) - 1  # 转换为0-based索引
            ptr += 1
            result = solution.query_point(a)
            output.append(str(result))
    
    # 批量输出结果
    print('\n'.join(output))

# 测试用例
# 示例：
# 输入：
# 5 3
# 1 2 3 4 5
# 1 1 3 6
# 2 2
# 2 4
# 输出：
# 6
# 4

if __name__ == "__main__":
    main()

'''
时间复杂度分析：
- 初始化：O(n)
- 单点查询：O(1)
- 区间修改：
  - 对于完整的块：O(1)（只需要设置标记）
  - 对于不完整的块：O(√n)（需要下推标记并暴力修改）
  - 总体时间复杂度：O(√n)
- 对于m次操作，总体时间复杂度：O(m√n)

空间复杂度分析：
- 数组arr：O(n)
- 标记数组color_tag和has_tag：O(√n)
- 块分配数组block：O(n)
- 总体空间复杂度：O(n + √n) = O(n)

Python语言特性注意事项：
1. 使用sys.stdin.read()一次性读取所有输入，提高效率
2. 使用列表存储数组和标记信息
3. 注意Python中的整数除法使用//运算符
4. 对于大规模数据，批量输出结果可以减少I/O操作
5. 避免使用递归，Python的递归深度有限

算法说明：
块颜色标记是分块算法的一个典型应用，主要用于处理区间颜色修改和单点查询问题。

算法步骤：
1. 将数组分成大小为√n的块
2. 对于区间颜色修改操作：
   - 对于不完整的块，先下推可能存在的标记，然后暴力修改每个元素
   - 对于完整的块，只需要设置块的颜色标记，不需要立即修改每个元素
3. 对于单点查询操作：
   - 如果该元素所在的块有颜色标记，直接返回标记的颜色
   - 否则返回原始数组中的颜色

优化说明：
1. 使用延迟标记技术，避免不必要的元素修改操作
2. 块的大小选择为√n，平衡了查询和修改的时间复杂度
3. 只有在需要访问块中的元素时才下推标记，减少操作次数
4. 在Python中，使用列表一次性存储输出结果，最后统一打印，可以提高I/O效率

与其他方法的对比：
- 暴力法：每次修改O(n)，每次查询O(1)，总时间复杂度O(mn)
- 线段树：每次修改和查询都是O(log n)，但实现复杂
- 块颜色标记：实现简单，时间复杂度适中

工程化考虑：
1. 在Python中，对于大规模数据，输入方法的选择对性能影响很大
2. 避免在循环中使用print语句，应该收集结果后批量输出
3. 可以将块的大小作为参数，根据具体数据调整以获得最佳性能
4. 对于非常大的n，需要考虑内存的使用
'''

===============================================

文件: Code39_BlockMin.cpp
===============================================
// 块内最小值查询与更新 - 分块算法实现 (C++版本)
// 题目来源: LeetCode 307. Range Minimum Query (修改版)
// 题目链接: https://leetcode.com/problems/range-sum-query-mutable/
// 题目大意: 维护一个数组，支持单点更新和区间最小值查询
// 约束条件: 数组长度n ≤ 1e5，操作次数m ≤ 1e5

#include <cstdio>
#include <vector>
#include <algorithm>
#include <cmath>
#include <climits>
using namespace std;

const int MAXN = 100005;

int n, m, blen; // n是数组长度，m是操作次数，blen是块的大小
int arr[MAXN]; // 原始数组
int block_min[MAXN]; // 每个块的最小值
int block[MAXN]; // 每个元素所属的块

// 初始化分块结构
void init() {
    blen = sqrt(n);
    if (blen == 0) blen = 1;
    
    // 为每个元素分配块
    for (int i = 0; i < n; i++) {
        block[i] = i / blen;
    }
    
    // 计算每个块的最小值
    int block_count = (n + blen - 1) / blen;
    for (int i = 0; i < block_count; i++) {
        int start = i * blen;
        int end = min((i + 1) * blen, n);
        int min_val = INT_MAX;
        for (int j = start; j < end; j++) {
            if (arr[j] < min_val) {
                min_val = arr[j];
            }
        }
        block_min[i] = min_val;
    }
}

// 单点更新
void update_point(int pos, int val) {
    int old_val = arr[pos];
    arr[pos] = val;
    
    // 更新对应块的最小值
    int block_id = block[pos];
    int start = block_id * blen;
    int end = min((block_id + 1) * blen, n);
    
    // 重新计算该块的最小值
    int min_val = INT_MAX;
    for (int i = start; i < end; i++) {
        if (arr[i] < min_val) {
            min_val = arr[i];
        }
    }
    block_min[block_id] = min_val;
}

// 区间最小值查询
int query_min(int l, int r) {
    int left_block = block[l];
    int right_block = block[r];
    int min_val = INT_MAX;
    
    if (left_block == right_block) {
        // 所有元素都在同一个块内，直接暴力查询
        for (int i = l; i <= r; i++) {
            if (arr[i] < min_val) {
                min_val = arr[i];
            }
        }
    } else {
        // 处理左边不完整的块
        for (int i = l; i < (left_block + 1) * blen; i++) {
            if (arr[i] < min_val) {
                min_val = arr[i];
            }
        }
        
        // 处理中间完整的块，使用块的最小值
        for (int i = left_block + 1; i < right_block; i++) {
            if (block_min[i] < min_val) {
                min_val = block_min[i];
            }
        }
        
        // 处理右边不完整的块
        for (int i = right_block * blen; i <= r; i++) {
            if (arr[i] < min_val) {
                min_val = arr[i];
            }
        }
    }
    
    return min_val;
}

// 优化版本的单点更新（只在需要时重新计算块最小值）
void update_point_optimized(int pos, int val) {
    int old_val = arr[pos];
    arr[pos] = val;
    
    // 只有当新值小于块最小值或者旧值等于块最小值时，才需要重新计算
    int block_id = block[pos];
    if (val < block_min[block_id] || old_val == block_min[block_id]) {
        int start = block_id * blen;
        int end = min((block_id + 1) * blen, n);
        int min_val = INT_MAX;
        for (int i = start; i < end; i++) {
            if (arr[i] < min_val) {
                min_val = arr[i];
            }
        }
        block_min[block_id] = min_val;
    }
}

int main() {
    scanf("%d", &n);
    
    // 读取初始数组（0-based索引）
    for (int i = 0; i < n; i++) {
        scanf("%d", &arr[i]);
    }
    
    // 初始化分块结构
    init();
    
    scanf("%d", &m);
    
    // 处理每个操作
    for (int i = 0; i < m; i++) {
        int op, a, b;
        scanf("%d", &op);
        
        if (op == 0) {
            // 单点更新操作
            scanf("%d %d", &a, &b);
            a--; // 转换为0-based索引
            update_point_optimized(a, b);
        } else if (op == 1) {
            // 区间查询操作
            scanf("%d %d", &a, &b);
            a--; b--; // 转换为0-based索引
            int result = query_min(a, b);
            printf("%d\n", result);
        }
    }
    
    return 0;
}

/*
时间复杂度分析：
- 初始化：O(n)
- 单点更新（优化版本）：
  - 最好情况：O(1)（当新值不影响块最小值时）
  - 最坏情况：O(√n)（当需要重新计算块最小值时）
  - 平均时间复杂度：O(√n)
- 区间查询：O(√n)
- 对于m次操作，总体时间复杂度：O(m√n)

空间复杂度分析：
- 数组arr：O(n)
- 块最小值数组block_min：O(√n)
- 块分配数组block：O(n)
- 总体空间复杂度：O(n + √n) = O(n)

算法说明：
块内最小值查询与更新是分块算法的一个典型应用，主要用于处理单点更新和区间最小值查询问题。

算法步骤：
1. 将数组分成大小为√n的块
2. 预处理每个块的最小值，存储在block_min数组中
3. 对于单点更新操作：
   - 更新原始数组中的值
   - 检查是否需要重新计算对应块的最小值
4. 对于区间最小值查询操作：
   - 对于不完整的块，直接遍历块中的元素，找到最小值
   - 对于完整的块，直接使用预处理好的块最小值
   - 综合所有部分的结果，得到最终的最小值

优化说明：
1. 在单点更新时，只有当新值小于块最小值或者旧值等于块最小值时，才需要重新计算块最小值
2. 块的大小选择为√n，平衡了查询和更新的时间复杂度
3. 对于区间查询，利用预处理的块最小值，避免重复计算

与其他方法的对比：
- 暴力法：每次更新O(1)，每次查询O(n)，总时间复杂度O(mn)
- 线段树：每次更新和查询都是O(log n)，但实现复杂
- ST表：查询O(1)，但不支持更新
- 块内最小值：实现简单，时间复杂度适中，支持更新和查询

工程化考虑：
1. 注意数组的索引方式（0-based或1-based）
2. 对于大规模数据，可以考虑使用更高效的输入方法
3. 可以根据具体数据调整块的大小，以获得最佳性能
4. 在C++中，可以使用vector代替数组，提高代码的可读性和安全性
*/

===============================================

文件: Code39_BlockMin.java
===============================================
// 块内最小值查询与更新 - 分块算法实现 (Java版本)
// 题目来源: LeetCode 307. Range Minimum Query (修改版)
// 题目链接: https://leetcode.com/problems/range-sum-query-mutable/
// 题目大意: 维护一个数组，支持单点更新和区间最小值查询
// 约束条件: 数组长度n ≤ 1e5，操作次数m ≤ 1e5

import java.io.*;
import java.util.*;

public class Code39_BlockMin {
    static final int MAXN = 100005;
    
    int n, m, blen; // n是数组长度，m是操作次数，blen是块的大小
    int[] arr; // 原始数组
    int[] block_min; // 每个块的最小值
    int[] block; // 每个元素所属的块
    
    // 初始化分块结构
    void init() {
        blen = (int) Math.sqrt(n);
        if (blen == 0) blen = 1;
        
        block = new int[n];
        // 为每个元素分配块
        for (int i = 0; i < n; i++) {
            block[i] = i / blen;
        }
        
        // 计算每个块的最小值
        int block_count = (n + blen - 1) / blen;
        block_min = new int[block_count];
        for (int i = 0; i < block_count; i++) {
            int start = i * blen;
            int end = Math.min((i + 1) * blen, n);
            int min_val = Integer.MAX_VALUE;
            for (int j = start; j < end; j++) {
                if (arr[j] < min_val) {
                    min_val = arr[j];
                }
            }
            block_min[i] = min_val;
        }
    }
    
    // 优化版本的单点更新（只在需要时重新计算块最小值）
    void update_point(int pos, int val) {
        int old_val = arr[pos];
        arr[pos] = val;
        
        // 只有当新值小于块最小值或者旧值等于块最小值时，才需要重新计算
        int block_id = block[pos];
        if (val < block_min[block_id] || old_val == block_min[block_id]) {
            int start = block_id * blen;
            int end = Math.min((block_id + 1) * blen, n);
            int min_val = Integer.MAX_VALUE;
            for (int i = start; i < end; i++) {
                if (arr[i] < min_val) {
                    min_val = arr[i];
                }
            }
            block_min[block_id] = min_val;
        }
    }
    
    // 区间最小值查询
    int query_min(int l, int r) {
        int left_block = block[l];
        int right_block = block[r];
        int min_val = Integer.MAX_VALUE;
        
        if (left_block == right_block) {
            // 所有元素都在同一个块内，直接暴力查询
            for (int i = l; i <= r; i++) {
                if (arr[i] < min_val) {
                    min_val = arr[i];
                }
            }
        } else {
            // 处理左边不完整的块
            for (int i = l; i < (left_block + 1) * blen; i++) {
                if (arr[i] < min_val) {
                    min_val = arr[i];
                }
            }
            
            // 处理中间完整的块，使用块的最小值
            for (int i = left_block + 1; i < right_block; i++) {
                if (block_min[i] < min_val) {
                    min_val = block_min[i];
                }
            }
            
            // 处理右边不完整的块
            for (int i = right_block * blen; i <= r; i++) {
                if (arr[i] < min_val) {
                    min_val = arr[i];
                }
            }
        }
        
        return min_val;
    }
    
    public static void main(String[] args) throws IOException {
        // 使用BufferedReader提高输入效率
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        PrintWriter pw = new PrintWriter(new OutputStreamWriter(System.out));
        
        Code39_BlockMin solution = new Code39_BlockMin();
        
        // 读取n
        solution.n = Integer.parseInt(br.readLine());
        
        // 读取初始数组
        solution.arr = new int[solution.n];
        String[] input = br.readLine().split(" ");
        for (int i = 0; i < solution.n; i++) {
            solution.arr[i] = Integer.parseInt(input[i]);
        }
        
        // 初始化分块结构
        solution.init();
        
        // 读取m
        solution.m = Integer.parseInt(br.readLine());
        
        // 处理每个操作
        for (int i = 0; i < solution.m; i++) {
            input = br.readLine().split(" ");
            int op = Integer.parseInt(input[0]);
            
            if (op == 0) {
                // 单点更新操作
                int a = Integer.parseInt(input[1]) - 1; // 转换为0-based索引
                int b = Integer.parseInt(input[2]);
                solution.update_point(a, b);
            } else if (op == 1) {
                // 区间查询操作
                int a = Integer.parseInt(input[1]) - 1; // 转换为0-based索引
                int b = Integer.parseInt(input[2]) - 1;
                int result = solution.query_min(a, b);
                pw.println(result);
            }
        }
        
        pw.flush();
        pw.close();
        br.close();
    }
}

/*
时间复杂度分析：
- 初始化：O(n)
- 单点更新（优化版本）：
  - 最好情况：O(1)（当新值不影响块最小值时）
  - 最坏情况：O(√n)（当需要重新计算块最小值时）
  - 平均时间复杂度：O(√n)
- 区间查询：O(√n)
- 对于m次操作，总体时间复杂度：O(m√n)

空间复杂度分析：
- 数组arr：O(n)
- 块最小值数组block_min：O(√n)
- 块分配数组block：O(n)
- 总体空间复杂度：O(n + √n) = O(n)

Java语言特性注意事项：
1. 使用BufferedReader和PrintWriter提高输入输出效率
2. 使用Integer.MAX_VALUE表示最大值
3. 注意Java中数组的初始化方式
4. Math.sqrt返回的是double类型，需要转换为int
5. 对于大规模数据，必须使用快速输入方法

算法说明：
块内最小值查询与更新是分块算法的一个典型应用，主要用于处理单点更新和区间最小值查询问题。

算法步骤：
1. 将数组分成大小为√n的块
2. 预处理每个块的最小值，存储在block_min数组中
3. 对于单点更新操作：
   - 更新原始数组中的值
   - 检查是否需要重新计算对应块的最小值
4. 对于区间最小值查询操作：
   - 对于不完整的块，直接遍历块中的元素，找到最小值
   - 对于完整的块，直接使用预处理好的块最小值
   - 综合所有部分的结果，得到最终的最小值

优化说明：
1. 在单点更新时，只有当新值小于块最小值或者旧值等于块最小值时，才需要重新计算块最小值
2. 块的大小选择为√n，平衡了查询和更新的时间复杂度
3. 对于区间查询，利用预处理的块最小值，避免重复计算

与其他方法的对比：
- 暴力法：每次更新O(1)，每次查询O(n)，总时间复杂度O(mn)
- 线段树：每次更新和查询都是O(log n)，但实现复杂
- ST表：查询O(1)，但不支持更新
- 块内最小值：实现简单，时间复杂度适中，支持更新和查询

工程化考虑：
1. 使用BufferedReader提高输入效率，避免超时
2. 对于大规模数据，可以考虑使用更快的输入方法
3. 注意内存的使用，避免不必要的数组分配
4. 可以将块的大小作为参数，根据具体数据调整以获得最佳性能
*/

===============================================

文件: Code39_BlockMin.py
===============================================
# 块内最小值查询与更新 - 分块算法实现 (Python版本)
# 题目来源: LeetCode 307. Range Minimum Query (修改版)
# 题目链接: https://leetcode.com/problems/range-sum-query-mutable/
# 题目大意: 维护一个数组，支持单点更新和区间最小值查询
# 约束条件: 数组长度n ≤ 1e5，操作次数m ≤ 1e5

import sys
import math

class BlockMin:
    def __init__(self):
        self.n = 0
        self.m = 0
        self.blen = 0
        self.arr = []
        self.block_min = []
        self.block = []
    
    # 初始化分块结构
    def init(self):
        self.blen = int(math.sqrt(self.n))
        if self.blen == 0:
            self.blen = 1
        
        # 为每个元素分配块
        self.block = [0] * self.n
        for i in range(self.n):
            self.block[i] = i // self.blen
        
        # 计算每个块的最小值
        block_count = (self.n + self.blen - 1) // self.blen
        self.block_min = [0] * block_count
        for i in range(block_count):
            start = i * self.blen
            end = min((i + 1) * self.blen, self.n)
            min_val = float('inf')
            for j in range(start, end):
                if self.arr[j] < min_val:
                    min_val = self.arr[j]
            self.block_min[i] = min_val
    
    # 优化版本的单点更新（只在需要时重新计算块最小值）
    def update_point(self, pos, val):
        old_val = self.arr[pos]
        self.arr[pos] = val
        
        # 只有当新值小于块最小值或者旧值等于块最小值时，才需要重新计算
        block_id = self.block[pos]
        if val < self.block_min[block_id] or old_val == self.block_min[block_id]:
            start = block_id * self.blen
            end = min((block_id + 1) * self.blen, self.n)
            min_val = float('inf')
            for i in range(start, end):
                if self.arr[i] < min_val:
                    min_val = self.arr[i]
            self.block_min[block_id] = min_val
    
    # 区间最小值查询
    def query_min(self, l, r):
        left_block = self.block[l]
        right_block = self.block[r]
        min_val = float('inf')
        
        if left_block == right_block:
            # 所有元素都在同一个块内，直接暴力查询
            for i in range(l, r + 1):
                if self.arr[i] < min_val:
                    min_val = self.arr[i]
        else:
            # 处理左边不完整的块
            for i in range(l, (left_block + 1) * self.blen):
                if self.arr[i] < min_val:
                    min_val = self.arr[i]
            
            # 处理中间完整的块，使用块的最小值
            for i in range(left_block + 1, right_block):
                if self.block_min[i] < min_val:
                    min_val = self.block_min[i]
            
            # 处理右边不完整的块
            for i in range(right_block * self.blen, r + 1):
                if self.arr[i] < min_val:
                    min_val = self.arr[i]
        
        return min_val

def main():
    # 使用sys.stdin.readline提高输入效率
    input = sys.stdin.read().split()
    ptr = 0
    
    solution = BlockMin()
    
    # 读取n
    solution.n = int(input[ptr])
    ptr += 1
    
    # 读取初始数组
    solution.arr = list(map(int, input[ptr:ptr + solution.n]))
    ptr += solution.n
    
    # 初始化分块结构
    solution.init()
    
    # 读取m
    solution.m = int(input[ptr])
    ptr += 1
    
    # 处理每个操作
    output = []
    for i in range(solution.m):
        op = int(input[ptr])
        ptr += 1
        
        if op == 0:
            # 单点更新操作
            a = int(input[ptr]) - 1  # 转换为0-based索引
            ptr += 1
            b = int(input[ptr])
            ptr += 1
            solution.update_point(a, b)
        elif op == 1:
            # 区间查询操作
            a = int(input[ptr]) - 1  # 转换为0-based索引
            ptr += 1
            b = int(input[ptr]) - 1
            ptr += 1
            result = solution.query_min(a, b)
            output.append(str(result))
    
    # 批量输出结果
    print('\n'.join(output))

# 测试用例
# 示例：
# 输入：
# 5 3
# 5 2 3 1 4
# 1 1 5
# 0 3 0
# 1 1 5
# 输出：
# 1
# 0

if __name__ == "__main__":
    main()

'''
时间复杂度分析：
- 初始化：O(n)
- 单点更新（优化版本）：
  - 最好情况：O(1)（当新值不影响块最小值时）
  - 最坏情况：O(√n)（当需要重新计算块最小值时）
  - 平均时间复杂度：O(√n)
- 区间查询：O(√n)
- 对于m次操作，总体时间复杂度：O(m√n)

空间复杂度分析：
- 数组arr：O(n)
- 块最小值数组block_min：O(√n)
- 块分配数组block：O(n)
- 总体空间复杂度：O(n + √n) = O(n)

Python语言特性注意事项：
1. 使用sys.stdin.read()一次性读取所有输入，提高效率
2. 使用列表存储数组和块信息
3. 使用float('inf')表示无穷大
4. 注意Python中的整数除法使用//运算符
5. 对于大规模数据，批量输出结果可以减少I/O操作

算法说明：
块内最小值查询与更新是分块算法的一个典型应用，主要用于处理单点更新和区间最小值查询问题。

算法步骤：
1. 将数组分成大小为√n的块
2. 预处理每个块的最小值，存储在block_min数组中
3. 对于单点更新操作：
   - 更新原始数组中的值
   - 检查是否需要重新计算对应块的最小值
4. 对于区间最小值查询操作：
   - 对于不完整的块，直接遍历块中的元素，找到最小值
   - 对于完整的块，直接使用预处理好的块最小值
   - 综合所有部分的结果，得到最终的最小值

优化说明：
1. 在单点更新时，只有当新值小于块最小值或者旧值等于块最小值时，才需要重新计算块最小值
2. 块的大小选择为√n，平衡了查询和更新的时间复杂度
3. 对于区间查询，利用预处理的块最小值，避免重复计算
4. 在Python中，使用列表一次性存储输出结果，最后统一打印，可以提高I/O效率

与其他方法的对比：
- 暴力法：每次更新O(1)，每次查询O(n)，总时间复杂度O(mn)
- 线段树：每次更新和查询都是O(log n)，但实现复杂
- ST表：查询O(1)，但不支持更新
- 块内最小值：实现简单，时间复杂度适中，支持更新和查询

工程化考虑：
1. 在Python中，对于大规模数据，输入方法的选择对性能影响很大
2. 避免在循环中使用print语句，应该收集结果后批量输出
3. 可以将块的大小作为参数，根据具体数据调整以获得最佳性能
4. 对于非常大的n，需要考虑内存的使用
'''

===============================================

文件: Code40_BlockXOR.cpp
===============================================
// 基于块分解的子数组信息预处理 - 区间异或和查询 (C++版本)
// 题目来源: Codeforces 914C
// 题目链接: https://codeforces.com/problemset/problem/914/C
// 题目大意: 维护一个数组，支持区间异或和查询
// 约束条件: 数组长度n ≤ 1e5，查询次数m ≤ 1e5

#include <cstdio>
#include <vector>
#include <algorithm>
#include <cmath>
using namespace std;

const int MAXN = 100005;
const int MAX_BLOCK = 320; // √1e5 ≈ 316

int n, m, blen, block_count; // n是数组长度，m是操作次数，blen是块的大小，block_count是块的数量
int arr[MAXN]; // 原始数组
int block[MAXN]; // 每个元素所属的块
int block_xor[MAXN]; // 每个块的异或和
int pre_xor[MAX_BLOCK][MAX_BLOCK]; // pre_xor[i][j]表示从第i个块到第j个块的异或和

// 初始化分块结构
void init() {
    blen = sqrt(n);
    if (blen == 0) blen = 1;
    block_count = (n + blen - 1) / blen;
    
    // 为每个元素分配块
    for (int i = 0; i < n; i++) {
        block[i] = i / blen;
    }
    
    // 计算每个块的异或和
    for (int i = 0; i < block_count; i++) {
        int start = i * blen;
        int end = min((i + 1) * blen, n);
        int xor_sum = 0;
        for (int j = start; j < end; j++) {
            xor_sum ^= arr[j];
        }
        block_xor[i] = xor_sum;
    }
    
    // 预处理块间的异或和
    for (int i = 0; i < block_count; i++) {
        int current_xor = 0;
        for (int j = i; j < block_count; j++) {
            current_xor ^= block_xor[j];
            pre_xor[i][j] = current_xor;
        }
    }
}

// 区间异或和查询
int query_xor(int l, int r) {
    int left_block = block[l];
    int right_block = block[r];
    int xor_sum = 0;
    
    if (left_block == right_block) {
        // 所有元素都在同一个块内，直接暴力查询
        for (int i = l; i <= r; i++) {
            xor_sum ^= arr[i];
        }
    } else {
        // 处理左边不完整的块
        for (int i = l; i < (left_block + 1) * blen; i++) {
            xor_sum ^= arr[i];
        }
        
        // 处理中间完整的块，使用预处理的块间异或和
        if (left_block + 1 <= right_block - 1) {
            xor_sum ^= pre_xor[left_block + 1][right_block - 1];
        }
        
        // 处理右边不完整的块
        for (int i = right_block * blen; i <= r; i++) {
            xor_sum ^= arr[i];
        }
    }
    
    return xor_sum;
}

// 单点更新
void update_point(int pos, int val) {
    int old_val = arr[pos];
    arr[pos] = val;
    
    // 更新对应块的异或和
    int block_id = block[pos];
    int start = block_id * blen;
    int end = min((block_id + 1) * blen, n);
    int xor_sum = 0;
    for (int i = start; i < end; i++) {
        xor_sum ^= arr[i];
    }
    block_xor[block_id] = xor_sum;
    
    // 重新计算受影响的预处理块间异或和
    for (int i = 0; i < block_count; i++) {
        if (i > block_id) break;
        int current_xor = 0;
        for (int j = i; j < block_count; j++) {
            current_xor ^= block_xor[j];
            pre_xor[i][j] = current_xor;
        }
    }
}

int main() {
    scanf("%d", &n);
    
    // 读取初始数组（0-based索引）
    for (int i = 0; i < n; i++) {
        scanf("%d", &arr[i]);
    }
    
    // 初始化分块结构
    init();
    
    scanf("%d", &m);
    
    // 处理每个操作
    for (int i = 0; i < m; i++) {
        int op, a, b;
        scanf("%d", &op);
        
        if (op == 0) {
            // 单点更新操作
            scanf("%d %d", &a, &b);
            a--; // 转换为0-based索引
            update_point(a, b);
        } else if (op == 1) {
            // 区间查询操作
            scanf("%d %d", &a, &b);
            a--; b--; // 转换为0-based索引
            int result = query_xor(a, b);
            printf("%d\n", result);
        }
    }
    
    return 0;
}

/*
时间复杂度分析：
- 初始化：
  - 计算块异或和：O(n)
  - 预处理块间异或和：O(n√n)
- 单点更新：
  - 重新计算块异或和：O(√n)
  - 重新计算预处理块间异或和：O(n)
  - 总体时间复杂度：O(n)
- 区间查询：
  - 不完整块的处理：O(√n)
  - 完整块的处理：O(1)（使用预处理的块间异或和）
  - 总体时间复杂度：O(√n)

空间复杂度分析：
- 数组arr：O(n)
- 块分配数组block：O(n)
- 块异或和数组block_xor：O(√n)
- 预处理块间异或和数组pre_xor：O(n)
- 总体空间复杂度：O(n)

算法说明：
基于块分解的子数组信息预处理是分块算法的一个重要应用，特别适用于区间异或和查询等问题。

算法步骤：
1. 将数组分成大小为√n的块
2. 预处理每个块的异或和
3. 预处理块间的异或和，pre_xor[i][j]表示从第i个块到第j个块的异或和
4. 对于区间异或和查询操作：
   - 对于不完整的块，直接遍历块中的元素，计算异或和
   - 对于完整的块，使用预处理的块间异或和
   - 综合所有部分的结果，得到最终的异或和
5. 对于单点更新操作：
   - 更新原始数组中的值
   - 重新计算对应块的异或和
   - 重新计算受影响的预处理块间异或和

优化说明：
1. 使用预处理的块间异或和，减少查询时的计算量
2. 块的大小选择为√n，平衡了查询和更新的时间复杂度
3. 在更新时，只重新计算受影响的预处理块间异或和

与其他方法的对比：
- 暴力法：每次查询O(n)，每次更新O(1)，总时间复杂度O(mn)
- 前缀异或数组：每次查询O(1)，但更新需要O(n)时间
- 线段树：每次更新和查询都是O(log n)，但实现复杂
- 基于块分解的预处理：查询O(√n)，更新O(n)，实现相对简单

工程化考虑：
1. 注意数组的索引方式（0-based或1-based）
2. 对于大规模数据，可以考虑使用更高效的输入方法
3. 可以根据具体数据调整块的大小，以获得最佳性能
4. 在C++中，需要注意数组的大小限制，避免栈溢出
*/

===============================================

文件: Code40_BlockXOR.java
===============================================
// 基于块分解的子数组信息预处理 - 区间异或和查询 (Java版本)
// 题目来源: Codeforces 914C
// 题目链接: https://codeforces.com/problemset/problem/914/C
// 题目大意: 维护一个数组，支持区间异或和查询
// 约束条件: 数组长度n ≤ 1e5，查询次数m ≤ 1e5

import java.io.*;
import java.util.*;

public class Code40_BlockXOR {
    static final int MAXN = 100005;
    static final int MAX_BLOCK = 320; // √1e5 ≈ 316
    
    int n, m, blen, block_count; // n是数组长度，m是操作次数，blen是块的大小，block_count是块的数量
    int[] arr; // 原始数组
    int[] block; // 每个元素所属的块
    int[] block_xor; // 每个块的异或和
    int[][] pre_xor; // pre_xor[i][j]表示从第i个块到第j个块的异或和
    
    // 初始化分块结构
    void init() {
        blen = (int) Math.sqrt(n);
        if (blen == 0) blen = 1;
        block_count = (n + blen - 1) / blen;
        
        block = new int[n];
        // 为每个元素分配块
        for (int i = 0; i < n; i++) {
            block[i] = i / blen;
        }
        
        block_xor = new int[block_count];
        // 计算每个块的异或和
        for (int i = 0; i < block_count; i++) {
            int start = i * blen;
            int end = Math.min((i + 1) * blen, n);
            int xor_sum = 0;
            for (int j = start; j < end; j++) {
                xor_sum ^= arr[j];
            }
            block_xor[i] = xor_sum;
        }
        
        // 预处理块间的异或和
        pre_xor = new int[block_count][block_count];
        for (int i = 0; i < block_count; i++) {
            int current_xor = 0;
            for (int j = i; j < block_count; j++) {
                current_xor ^= block_xor[j];
                pre_xor[i][j] = current_xor;
            }
        }
    }
    
    // 区间异或和查询
    int query_xor(int l, int r) {
        int left_block = block[l];
        int right_block = block[r];
        int xor_sum = 0;
        
        if (left_block == right_block) {
            // 所有元素都在同一个块内，直接暴力查询
            for (int i = l; i <= r; i++) {
                xor_sum ^= arr[i];
            }
        } else {
            // 处理左边不完整的块
            for (int i = l; i < (left_block + 1) * blen; i++) {
                xor_sum ^= arr[i];
            }
            
            // 处理中间完整的块，使用预处理的块间异或和
            if (left_block + 1 <= right_block - 1) {
                xor_sum ^= pre_xor[left_block + 1][right_block - 1];
            }
            
            // 处理右边不完整的块
            for (int i = right_block * blen; i <= r; i++) {
                xor_sum ^= arr[i];
            }
        }
        
        return xor_sum;
    }
    
    // 单点更新
    void update_point(int pos, int val) {
        int old_val = arr[pos];
        arr[pos] = val;
        
        // 更新对应块的异或和
        int block_id = block[pos];
        int start = block_id * blen;
        int end = Math.min((block_id + 1) * blen, n);
        int xor_sum = 0;
        for (int i = start; i < end; i++) {
            xor_sum ^= arr[i];
        }
        block_xor[block_id] = xor_sum;
        
        // 重新计算受影响的预处理块间异或和
        for (int i = 0; i < block_count; i++) {
            if (i > block_id) break;
            int current_xor = 0;
            for (int j = i; j < block_count; j++) {
                current_xor ^= block_xor[j];
                pre_xor[i][j] = current_xor;
            }
        }
    }
    
    public static void main(String[] args) throws IOException {
        // 使用BufferedReader提高输入效率
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        PrintWriter pw = new PrintWriter(new OutputStreamWriter(System.out));
        
        Code40_BlockXOR solution = new Code40_BlockXOR();
        
        // 读取n
        solution.n = Integer.parseInt(br.readLine());
        
        // 读取初始数组
        solution.arr = new int[solution.n];
        String[] input = br.readLine().split(" ");
        for (int i = 0; i < solution.n; i++) {
            solution.arr[i] = Integer.parseInt(input[i]);
        }
        
        // 初始化分块结构
        solution.init();
        
        // 读取m
        solution.m = Integer.parseInt(br.readLine());
        
        // 处理每个操作
        for (int i = 0; i < solution.m; i++) {
            input = br.readLine().split(" ");
            int op = Integer.parseInt(input[0]);
            
            if (op == 0) {
                // 单点更新操作
                int a = Integer.parseInt(input[1]) - 1; // 转换为0-based索引
                int b = Integer.parseInt(input[2]);
                solution.update_point(a, b);
            } else if (op == 1) {
                // 区间查询操作
                int a = Integer.parseInt(input[1]) - 1; // 转换为0-based索引
                int b = Integer.parseInt(input[2]) - 1;
                int result = solution.query_xor(a, b);
                pw.println(result);
            }
        }
        
        pw.flush();
        pw.close();
        br.close();
    }
}

/*
时间复杂度分析：
- 初始化：
  - 计算块异或和：O(n)
  - 预处理块间异或和：O(n√n)
- 单点更新：
  - 重新计算块异或和：O(√n)
  - 重新计算预处理块间异或和：O(n)
  - 总体时间复杂度：O(n)
- 区间查询：
  - 不完整块的处理：O(√n)
  - 完整块的处理：O(1)（使用预处理的块间异或和）
  - 总体时间复杂度：O(√n)

空间复杂度分析：
- 数组arr：O(n)
- 块分配数组block：O(n)
- 块异或和数组block_xor：O(√n)
- 预处理块间异或和数组pre_xor：O(n)
- 总体空间复杂度：O(n)

Java语言特性注意事项：
1. 使用BufferedReader和PrintWriter提高输入输出效率
2. 二维数组的初始化方式
3. 注意Java中数组的索引是0-based
4. Math.sqrt返回的是double类型，需要转换为int
5. 对于大规模数据，必须使用快速输入方法

算法说明：
基于块分解的子数组信息预处理是分块算法的一个重要应用，特别适用于区间异或和查询等问题。

算法步骤：
1. 将数组分成大小为√n的块
2. 预处理每个块的异或和
3. 预处理块间的异或和，pre_xor[i][j]表示从第i个块到第j个块的异或和
4. 对于区间异或和查询操作：
   - 对于不完整的块，直接遍历块中的元素，计算异或和
   - 对于完整的块，使用预处理的块间异或和
   - 综合所有部分的结果，得到最终的异或和
5. 对于单点更新操作：
   - 更新原始数组中的值
   - 重新计算对应块的异或和
   - 重新计算受影响的预处理块间异或和

优化说明：
1. 使用预处理的块间异或和，减少查询时的计算量
2. 块的大小选择为√n，平衡了查询和更新的时间复杂度
3. 在更新时，只重新计算受影响的预处理块间异或和

与其他方法的对比：
- 暴力法：每次查询O(n)，每次更新O(1)，总时间复杂度O(mn)
- 前缀异或数组：每次查询O(1)，但更新需要O(n)时间
- 线段树：每次更新和查询都是O(log n)，但实现复杂
- 基于块分解的预处理：查询O(√n)，更新O(n)，实现相对简单

工程化考虑：
1. 使用BufferedReader提高输入效率，避免超时
2. 对于大规模数据，可以考虑使用更快的输入方法
3. 注意内存的使用，避免不必要的数组分配
4. 可以将块的大小作为参数，根据具体数据调整以获得最佳性能
*/

===============================================

文件: Code40_BlockXOR.py
===============================================
# 基于块分解的子数组信息预处理 - 区间异或和查询 (Python版本)
# 题目来源: Codeforces 914C
# 题目链接: https://codeforces.com/problemset/problem/914/C
# 题目大意: 维护一个数组，支持区间异或和查询
# 约束条件: 数组长度n ≤ 1e5，查询次数m ≤ 1e5

import sys
import math

class BlockXOR:
    def __init__(self):
        self.n = 0
        self.m = 0
        self.blen = 0
        self.block_count = 0
        self.arr = []
        self.block = []
        self.block_xor = []
        self.pre_xor = []
    
    # 初始化分块结构
    def init(self):
        self.blen = int(math.sqrt(self.n))
        if self.blen == 0:
            self.blen = 1
        self.block_count = (self.n + self.blen - 1) // self.blen
        
        # 为每个元素分配块
        self.block = [0] * self.n
        for i in range(self.n):
            self.block[i] = i // self.blen
        
        # 计算每个块的异或和
        self.block_xor = [0] * self.block_count
        for i in range(self.block_count):
            start = i * self.blen
            end = min((i + 1) * self.blen, self.n)
            xor_sum = 0
            for j in range(start, end):
                xor_sum ^= self.arr[j]
            self.block_xor[i] = xor_sum
        
        # 预处理块间的异或和
        self.pre_xor = [[0] * self.block_count for _ in range(self.block_count)]
        for i in range(self.block_count):
            current_xor = 0
            for j in range(i, self.block_count):
                current_xor ^= self.block_xor[j]
                self.pre_xor[i][j] = current_xor
    
    # 区间异或和查询
    def query_xor(self, l, r):
        left_block = self.block[l]
        right_block = self.block[r]
        xor_sum = 0
        
        if left_block == right_block:
            # 所有元素都在同一个块内，直接暴力查询
            for i in range(l, r + 1):
                xor_sum ^= self.arr[i]
        else:
            # 处理左边不完整的块
            for i in range(l, (left_block + 1) * self.blen):
                xor_sum ^= self.arr[i]
            
            # 处理中间完整的块，使用预处理的块间异或和
            if left_block + 1 <= right_block - 1:
                xor_sum ^= self.pre_xor[left_block + 1][right_block - 1]
            
            # 处理右边不完整的块
            for i in range(right_block * self.blen, r + 1):
                xor_sum ^= self.arr[i]
        
        return xor_sum
    
    # 单点更新
    def update_point(self, pos, val):
        old_val = self.arr[pos]
        self.arr[pos] = val
        
        # 更新对应块的异或和
        block_id = self.block[pos]
        start = block_id * self.blen
        end = min((block_id + 1) * self.blen, self.n)
        xor_sum = 0
        for i in range(start, end):
            xor_sum ^= self.arr[i]
        self.block_xor[block_id] = xor_sum
        
        # 重新计算受影响的预处理块间异或和
        for i in range(self.block_count):
            if i > block_id:
                break
            current_xor = 0
            for j in range(i, self.block_count):
                current_xor ^= self.block_xor[j]
                self.pre_xor[i][j] = current_xor

def main():
    # 使用sys.stdin.readline提高输入效率
    input = sys.stdin.read().split()
    ptr = 0
    
    solution = BlockXOR()
    
    # 读取n
    solution.n = int(input[ptr])
    ptr += 1
    
    # 读取初始数组
    solution.arr = list(map(int, input[ptr:ptr + solution.n]))
    ptr += solution.n
    
    # 初始化分块结构
    solution.init()
    
    # 读取m
    solution.m = int(input[ptr])
    ptr += 1
    
    # 处理每个操作
    output = []
    for i in range(solution.m):
        op = int(input[ptr])
        ptr += 1
        
        if op == 0:
            # 单点更新操作
            a = int(input[ptr]) - 1  # 转换为0-based索引
            ptr += 1
            b = int(input[ptr])
            ptr += 1
            solution.update_point(a, b)
        elif op == 1:
            # 区间查询操作
            a = int(input[ptr]) - 1  # 转换为0-based索引
            ptr += 1
            b = int(input[ptr]) - 1
            ptr += 1
            result = solution.query_xor(a, b)
            output.append(str(result))
    
    # 批量输出结果
    print('\n'.join(output))

# 测试用例
# 示例：
# 输入：
# 5 3
# 5 2 3 1 4
# 1 1 5
# 0 3 0
# 1 1 5
# 输出：
# 5^2^3^1^4 = 5
# 5^2^0^1^4 = 6

if __name__ == "__main__":
    main()

'''
时间复杂度分析：
- 初始化：
  - 计算块异或和：O(n)
  - 预处理块间异或和：O(n√n)
- 单点更新：
  - 重新计算块异或和：O(√n)
  - 重新计算预处理块间异或和：O(n)
  - 总体时间复杂度：O(n)
- 区间查询：
  - 不完整块的处理：O(√n)
  - 完整块的处理：O(1)（使用预处理的块间异或和）
  - 总体时间复杂度：O(√n)

空间复杂度分析：
- 数组arr：O(n)
- 块分配数组block：O(n)
- 块异或和数组block_xor：O(√n)
- 预处理块间异或和数组pre_xor：O(n)
- 总体空间复杂度：O(n)

Python语言特性注意事项：
1. 使用sys.stdin.read()一次性读取所有输入，提高效率
2. 使用二维列表存储预处理的块间异或和
3. 注意Python中的整数除法使用//运算符
4. 对于大规模数据，批量输出结果可以减少I/O操作

算法说明：
基于块分解的子数组信息预处理是分块算法的一个重要应用，特别适用于区间异或和查询等问题。

算法步骤：
1. 将数组分成大小为√n的块
2. 预处理每个块的异或和
3. 预处理块间的异或和，pre_xor[i][j]表示从第i个块到第j个块的异或和
4. 对于区间异或和查询操作：
   - 对于不完整的块，直接遍历块中的元素，计算异或和
   - 对于完整的块，使用预处理的块间异或和
   - 综合所有部分的结果，得到最终的异或和
5. 对于单点更新操作：
   - 更新原始数组中的值
   - 重新计算对应块的异或和
   - 重新计算受影响的预处理块间异或和

优化说明：
1. 使用预处理的块间异或和，减少查询时的计算量
2. 块的大小选择为√n，平衡了查询和更新的时间复杂度
3. 在更新时，只重新计算受影响的预处理块间异或和

与其他方法的对比：
- 暴力法：每次查询O(n)，每次更新O(1)，总时间复杂度O(mn)
- 前缀异或数组：每次查询O(1)，但更新需要O(n)时间
- 线段树：每次更新和查询都是O(log n)，但实现复杂
- 基于块分解的预处理：查询O(√n)，更新O(n)，实现相对简单

工程化考虑：
1. 在Python中，对于大规模数据，输入方法的选择对性能影响很大
2. 避免在循环中使用print语句，应该收集结果后批量输出
3. 可以将块的大小作为参数，根据具体数据调整以获得最佳性能
4. 对于非常大的n，需要考虑内存的使用和Python的性能限制
'''

===============================================

文件: Code41_Patuljci1.java
===============================================
package class175;

// PATULJCI - 众数查询问题 - 莫队算法实现 (Java版本)
// 题目来源: SPOJ
// 题目链接: https://www.spoj.com/problems/PATULJCI/
// 题目大意: 给定一个数组和多个查询，每个查询要求找出区间[l,r]内的众数（出现次数最多的元素）
// 如果存在多个众数，返回任意一个即可
// 约束条件: 数组长度n ≤ 3*10^5，查询次数q ≤ 3*10^5，元素值 ≤ n

import java.io.*;
import java.util.*;

public class Code41_Patuljci1 {
    static final int MAXN = 300005;
    
    static int n, q, blen;
    static int[] arr;
    static int[] count; // 计数数组，记录当前窗口中每个元素的出现次数
    static int[] freq;  // 频率数组，记录出现次数为i的元素个数
    static int maxFreq; // 当前窗口中的最大频率
    
    // 查询结构体
    static class Query {
        int l, r, id;
        
        Query(int l, int r, int id) {
            this.l = l;
            this.r = r;
            this.id = id;
        }
    }
    
    static Query[] queries;
    static int[] ans;
    
    // 添加元素到当前窗口
    static void add(int pos) {
        int val = arr[pos];
        // 减少旧频率的计数
        freq[count[val]]--;
        // 增加元素计数
        count[val]++;
        // 增加新频率的计数
        freq[count[val]]++;
        // 更新最大频率
        if (count[val] > maxFreq) {
            maxFreq = count[val];
        }
    }
    
    // 从当前窗口移除元素
    static void remove(int pos) {
        int val = arr[pos];
        // 减少旧频率的计数
        freq[count[val]]--;
        // 如果移除的元素是当前最大频率的元素，需要更新最大频率
        if (count[val] == maxFreq && freq[count[val]] == 0) {
            maxFreq--;
        }
        // 减少元素计数
        count[val]--;
        // 增加新频率的计数
        freq[count[val]]++;
    }
    
    // 获取当前窗口的众数
    static int getMode() {
        // 找到出现次数等于最大频率的任意元素
        for (int i = 1; i <= n; i++) {
            if (count[i] == maxFreq) {
                return i;
            }
        }
        return -1; // 不应该到达这里
    }
    
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        PrintWriter pw = new PrintWriter(new OutputStreamWriter(System.out));
        
        // 读取输入
        StringTokenizer st = new StringTokenizer(br.readLine());
        n = Integer.parseInt(st.nextToken());
        int c = Integer.parseInt(st.nextToken()); // 元素种类数，题目中给出但实际不需要使用
        
        arr = new int[n + 1];
        st = new StringTokenizer(br.readLine());
        for (int i = 1; i <= n; i++) {
            arr[i] = Integer.parseInt(st.nextToken());
        }
        
        q = Integer.parseInt(br.readLine());
        queries = new Query[q + 1];
        ans = new int[q + 1];
        
        for (int i = 1; i <= q; i++) {
            st = new StringTokenizer(br.readLine());
            int l = Integer.parseInt(st.nextToken());
            int r = Integer.parseInt(st.nextToken());
            queries[i] = new Query(l, r, i);
        }
        
        // 莫队算法处理
        // 块大小选择: sqrt(n)
        blen = (int) Math.sqrt(n);
        
        // 按块排序查询
        Arrays.sort(queries, 1, q + 1, (a, b) -> {
            int blockA = (a.l - 1) / blen;
            int blockB = (b.l - 1) / blen;
            if (blockA != blockB) {
                return Integer.compare(blockA, blockB);
            }
            return Integer.compare(a.r, b.r);
        });
        
        // 初始化数据结构
        count = new int[n + 1];
        freq = new int[n + 1];
        maxFreq = 0;
        
        // 莫队算法主循环
        int curL = 1, curR = 0;
        for (int i = 1; i <= q; i++) {
            int l = queries[i].l;
            int r = queries[i].r;
            int id = queries[i].id;
            
            // 扩展右边界
            while (curR < r) {
                curR++;
                add(curR);
            }
            
            // 收缩左边界
            while (curL > l) {
                curL--;
                add(curL);
            }
            
            // 收缩右边界
            while (curR > r) {
                remove(curR);
                curR--;
            }
            
            // 扩展左边界
            while (curL < l) {
                remove(curL);
                curL++;
            }
            
            // 记录答案
            ans[id] = getMode();
        }
        
        // 输出结果
        for (int i = 1; i <= q; i++) {
            pw.println(ans[i]);
        }
        
        pw.flush();
        pw.close();
        br.close();
    }
}

/*
时间复杂度分析：
- 排序查询：O(q log q)
- 莫队算法主循环：
  - 指针移动的总次数：O((n + q) * sqrt(n))
  - 每次add/remove操作：O(1)
  - 获取众数操作：O(n)（最坏情况）
  - 总体时间复杂度：O(q log q + (n + q) * sqrt(n) + q * n)
- 由于q * n项可能较大，我们可以优化获取众数的操作

空间复杂度分析：
- 存储数组和查询：O(n + q)
- 计数数组：O(n)
- 频率数组：O(n)
- 总体空间复杂度：O(n + q)

优化说明：
1. 使用频率数组freq来维护出现次数为i的元素个数，可以快速更新最大频率
2. 在remove操作中，只有当移除的元素是当前最大频率的元素且没有其他相同频率的元素时，才需要减少最大频率
3. 块大小选择为sqrt(n)，这是经过理论分析得出的最优块大小

算法说明：
PATULJCI问题要求查询区间众数，可以使用莫队算法解决：
1. 将所有查询按左端点所在的块编号排序，块内按右端点排序
2. 使用莫队算法的指针移动技巧，维护当前窗口的元素计数
3. 使用计数数组和频率数组来快速获取众数

与其他方法的对比：
- 暴力法：每次查询O(n)，总时间复杂度O(q * n)
- 线段树：实现复杂，且对于众数查询不是最优解
- 莫队算法：离线处理，时间复杂度O((n + q) * sqrt(n))，适合此类问题

工程化考虑：
1. 使用BufferedReader和PrintWriter提高输入输出效率
2. 对于大规模数据，可以考虑使用更快的输入方法
3. 注意内存的使用，避免不必要的数组分配
*/

===============================================

文件: Code41_Patuljci2.cpp
===============================================
// PATULJCI - 众数查询问题 - 莫队算法实现 (C++版本)
// 题目来源: SPOJ
// 题目链接: https://www.spoj.com/problems/PATULJCI/
// 题目大意: 给定一个数组和多个查询，每个查询要求找出区间[l,r]内的众数（出现次数最多的元素）
// 如果存在多个众数，返回任意一个即可
// 约束条件: 数组长度n ≤ 3*10^5，查询次数q ≤ 3*10^5，元素值 ≤ n

#include <iostream>
#include <algorithm>
#include <cmath>
#include <cstring>
using namespace std;
using namespace std;

const int MAXN = 300005;

int n, q, blen;
int arr[MAXN];
int count_arr[MAXN]; // 计数数组，记录当前窗口中每个元素的出现次数
int freq[MAXN];      // 频率数组，记录出现次数为i的元素个数
int maxFreq;         // 当前窗口中的最大频率

// 查询结构体
struct Query {
    int l, r, id;
    
    bool operator<(const Query& other) const {
        int blockA = (l - 1) / blen;
        int blockB = (other.l - 1) / blen;
        if (blockA != blockB) {
            return blockA < blockB;
        }
        return r < other.r;
    }
};

Query queries[MAXN];
int ans[MAXN];

// 添加元素到当前窗口
void add(int pos) {
    int val = arr[pos];
    // 减少旧频率的计数
    freq[count_arr[val]]--;
    // 增加元素计数
    count_arr[val]++;
    // 增加新频率的计数
    freq[count_arr[val]]++;
    // 更新最大频率
    if (count_arr[val] > maxFreq) {
        maxFreq = count_arr[val];
    }
}

// 从当前窗口移除元素
void remove(int pos) {
    int val = arr[pos];
    // 减少旧频率的计数
    freq[count_arr[val]]--;
    // 如果移除的元素是当前最大频率的元素，需要更新最大频率
    if (count_arr[val] == maxFreq && freq[count_arr[val]] == 0) {
        maxFreq--;
    }
    // 减少元素计数
    count_arr[val]--;
    // 增加新频率的计数
    freq[count_arr[val]]++;
}

// 获取当前窗口的众数
int getMode() {
    // 找到出现次数等于最大频率的任意元素
    for (int i = 1; i <= n; i++) {
        if (count_arr[i] == maxFreq) {
            return i;
        }
    }
    return -1; // 不应该到达这里
}

int main() {
    // 读取输入
    std::cin >> n;
    int c; // 元素种类数，题目中给出但实际不需要使用
    std::cin >> c;
    
    for (int i = 1; i <= n; i++) {
        std::cin >> arr[i];
    }
    
    std::cin >> q;
    for (int i = 1; i <= q; i++) {
        int l, r;
        std::cin >> l >> r;
        queries[i] = {l, r, i};
    }
    
    // 莫队算法处理
    // 块大小选择: sqrt(n)
    blen = (int)std::sqrt(n);
    
    // 按块排序查询
    std::sort(queries + 1, queries + q + 1);
    
    // 初始化数据结构
    std::memset(count_arr, 0, sizeof(count_arr));
    std::memset(freq, 0, sizeof(freq));
    maxFreq = 0;
    
    // 莫队算法主循环
    int curL = 1, curR = 0;
    for (int i = 1; i <= q; i++) {
        int l = queries[i].l;
        int r = queries[i].r;
        int id = queries[i].id;
        
        // 扩展右边界
        while (curR < r) {
            curR++;
            add(curR);
        }
        
        // 收缩左边界
        while (curL > l) {
            curL--;
            add(curL);
        }
        
        // 收缩右边界
        while (curR > r) {
            remove(curR);
            curR--;
        }
        
        // 扩展左边界
        while (curL < l) {
            remove(curL);
            curL++;
        }
        
        // 记录答案
        ans[id] = getMode();
    }
    
    // 输出结果
    for (int i = 1; i <= q; i++) {
        std::cout << ans[i] << "\n";
    }
    
    return 0;
}

/*
时间复杂度分析：
- 排序查询：O(q log q)
- 莫队算法主循环：
  - 指针移动的总次数：O((n + q) * sqrt(n))
  - 每次add/remove操作：O(1)
  - 获取众数操作：O(n)（最坏情况）
  - 总体时间复杂度：O(q log q + (n + q) * sqrt(n) + q * n)
- 由于q * n项可能较大，我们可以优化获取众数的操作

空间复杂度分析：
- 存储数组和查询：O(n + q)
- 计数数组：O(n)
- 频率数组：O(n)
- 总体空间复杂度：O(n + q)

优化说明：
1. 使用频率数组freq来维护出现次数为i的元素个数，可以快速更新最大频率
2. 在remove操作中，只有当移除的元素是当前最大频率的元素且没有其他相同频率的元素时，才需要减少最大频率
3. 块大小选择为sqrt(n)，这是经过理论分析得出的最优块大小

算法说明：
PATULJCI问题要求查询区间众数，可以使用莫队算法解决：
1. 将所有查询按左端点所在的块编号排序，块内按右端点排序
2. 使用莫队算法的指针移动技巧，维护当前窗口的元素计数
3. 使用计数数组和频率数组来快速获取众数

与其他方法的对比：
- 暴力法：每次查询O(n)，总时间复杂度O(q * n)
- 线段树：实现复杂，且对于众数查询不是最优解
- 莫队算法：离线处理，时间复杂度O((n + q) * sqrt(n))，适合此类问题

工程化考虑：
1. 使用scanf和printf提高输入输出效率
2. 对于大规模数据，可以考虑使用更快的输入方法
3. 注意内存的使用，避免不必要的数组分配
*/

===============================================

文件: Code41_Patuljci3.py
===============================================
# PATULJCI - 众数查询问题 - 莫队算法实现 (Python版本)
# 题目来源: SPOJ
# 题目链接: https://www.spoj.com/problems/PATULJCI/
# 题目大意: 给定一个数组和多个查询，每个查询要求找出区间[l,r]内的众数（出现次数最多的元素）
# 如果存在多个众数，返回任意一个即可
# 约束条件: 数组长度n ≤ 3*10^5，查询次数q ≤ 3*10^5，元素值 ≤ n

import sys
import math
from collections import defaultdict

def main():
    # 读取输入
    n = int(sys.stdin.readline())
    c = int(sys.stdin.readline())  # 元素种类数，题目中给出但实际不需要使用
    
    arr = [0] + list(map(int, sys.stdin.readline().split()))  # 1-indexed
    
    q = int(sys.stdin.readline())
    
    # 查询结构
    queries = []
    for i in range(1, q + 1):
        l, r = map(int, sys.stdin.readline().split())
        queries.append((l, r, i))
    
    # 莫队算法处理
    # 块大小选择: sqrt(n)
    blen = int(math.sqrt(n))
    
    # 按块排序查询
    queries.sort(key=lambda x: (x[0] // blen, x[1]))
    
    # 初始化数据结构
    count = defaultdict(int)  # 计数数组，记录当前窗口中每个元素的出现次数
    freq = defaultdict(int)   # 频率数组，记录出现次数为i的元素个数
    max_freq = 0              # 当前窗口中的最大频率
    ans = [0] * (q + 1)
    
    # 添加元素到当前窗口
    def add(pos):
        nonlocal max_freq
        val = arr[pos]
        # 减少旧频率的计数
        freq[count[val]] -= 1
        # 增加元素计数
        count[val] += 1
        # 增加新频率的计数
        freq[count[val]] += 1
        # 更新最大频率
        if count[val] > max_freq:
            max_freq = count[val]
    
    # 从当前窗口移除元素
    def remove(pos):
        nonlocal max_freq
        val = arr[pos]
        # 减少旧频率的计数
        freq[count[val]] -= 1
        # 如果移除的元素是当前最大频率的元素，需要更新最大频率
        if count[val] == max_freq and freq[count[val]] == 0:
            max_freq -= 1
        # 减少元素计数
        count[val] -= 1
        # 增加新频率的计数
        freq[count[val]] += 1
    
    # 获取当前窗口的众数
    def get_mode():
        # 找到出现次数等于最大频率的任意元素
        for val, cnt in count.items():
            if cnt == max_freq:
                return val
        return -1  # 不应该到达这里
    
    # 莫队算法主循环
    cur_l, cur_r = 1, 0
    for l, r, idx in queries:
        # 扩展右边界
        while cur_r < r:
            cur_r += 1
            add(cur_r)
        
        # 收缩左边界
        while cur_l > l:
            cur_l -= 1
            add(cur_l)
        
        # 收缩右边界
        while cur_r > r:
            remove(cur_r)
            cur_r -= 1
        
        # 扩展左边界
        while cur_l < l:
            remove(cur_l)
            cur_l += 1
        
        # 记录答案
        ans[idx] = get_mode()
    
    # 输出结果
    for i in range(1, q + 1):
        print(ans[i])

if __name__ == "__main__":
    main()

"""
时间复杂度分析：
- 排序查询：O(q log q)
- 莫队算法主循环：
  - 指针移动的总次数：O((n + q) * sqrt(n))
  - 每次add/remove操作：O(1)
  - 获取众数操作：O(n)（最坏情况）
  - 总体时间复杂度：O(q log q + (n + q) * sqrt(n) + q * n)
- 由于q * n项可能较大，我们可以优化获取众数的操作

空间复杂度分析：
- 存储数组和查询：O(n + q)
- 计数数组：O(n)
- 频率数组：O(n)
- 总体空间复杂度：O(n + q)

优化说明：
1. 使用频率数组freq来维护出现次数为i的元素个数，可以快速更新最大频率
2. 在remove操作中，只有当移除的元素是当前最大频率的元素且没有其他相同频率的元素时，才需要减少最大频率
3. 块大小选择为sqrt(n)，这是经过理论分析得出的最优块大小

算法说明：
PATULJCI问题要求查询区间众数，可以使用莫队算法解决：
1. 将所有查询按左端点所在的块编号排序，块内按右端点排序
2. 使用莫队算法的指针移动技巧，维护当前窗口的元素计数
3. 使用计数数组和频率数组来快速获取众数

与其他方法的对比：
- 暴力法：每次查询O(n)，总时间复杂度O(q * n)
- 线段树：实现复杂，且对于众数查询不是最优解
- 莫队算法：离线处理，时间复杂度O((n + q) * sqrt(n))，适合此类问题

工程化考虑：
1. 使用sys.stdin.readline()提高输入效率
2. 使用defaultdict避免键不存在的检查
3. 对于大规模数据，可以考虑使用更快的输入方法
"""

===============================================

文件: Code42_Mkthnum1.java
===============================================
package class175;

// MKTHNUM - 第K小数字查询问题 - 莫队算法实现 (Java版本)
// 题目来源: SPOJ
// 题目链接: https://www.spoj.com/problems/MKTHNUM/
// 题目大意: 给定一个数组和多个查询，每个查询要求找出区间[l,r]内第k小的数字
// 约束条件: 数组长度n ≤ 10^5，查询次数q ≤ 5*10^3

import java.io.*;
import java.util.*;

public class Code42_Mkthnum1 {
    static final int MAXN = 100005;
    
    static int n, q, blen;
    static int[] arr;
    static int[] count; // 计数数组，记录当前窗口中每个元素的出现次数
    static int[] sortedArr; // 排序后的数组，用于离散化
    
    // 查询结构体
    static class Query {
        int l, r, k, id;
        
        Query(int l, int r, int k, int id) {
            this.l = l;
            this.r = r;
            this.k = k;
            this.id = id;
        }
    }
    
    static Query[] queries;
    static int[] ans;
    
    // 添加元素到当前窗口
    static void add(int pos) {
        count[arr[pos]]++;
    }
    
    // 从当前窗口移除元素
    static void remove(int pos) {
        count[arr[pos]]--;
    }
    
    // 获取当前窗口第k小的数字
    static int getKth(int k) {
        int cnt = 0;
        // 遍历排序后的数组，找到第k小的数字
        for (int i = 0; i < n; i++) {
            int val = sortedArr[i];
            cnt += count[val];
            if (cnt >= k) {
                return val;
            }
        }
        return -1; // 不应该到达这里
    }
    
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        PrintWriter pw = new PrintWriter(new OutputStreamWriter(System.out));
        
        // 读取输入
        StringTokenizer st = new StringTokenizer(br.readLine());
        n = Integer.parseInt(st.nextToken());
        q = Integer.parseInt(st.nextToken());
        
        arr = new int[n + 1];
        sortedArr = new int[n + 1];
        st = new StringTokenizer(br.readLine());
        for (int i = 1; i <= n; i++) {
            arr[i] = Integer.parseInt(st.nextToken());
            sortedArr[i] = arr[i];
        }
        
        // 离散化处理
        Arrays.sort(sortedArr, 1, n + 1);
        int uniqueCount = 1;
        for (int i = 2; i <= n; i++) {
            if (sortedArr[i] != sortedArr[uniqueCount]) {
                sortedArr[++uniqueCount] = sortedArr[i];
            }
        }
        
        // 重新映射数组元素到离散化后的值
        for (int i = 1; i <= n; i++) {
            arr[i] = Arrays.binarySearch(sortedArr, 1, uniqueCount + 1, arr[i]);
        }
        
        queries = new Query[q + 1];
        ans = new int[q + 1];
        
        for (int i = 1; i <= q; i++) {
            st = new StringTokenizer(br.readLine());
            int l = Integer.parseInt(st.nextToken());
            int r = Integer.parseInt(st.nextToken());
            int k = Integer.parseInt(st.nextToken());
            queries[i] = new Query(l, r, k, i);
        }
        
        // 莫队算法处理
        // 块大小选择: sqrt(n)
        blen = (int) Math.sqrt(n);
        
        // 按块排序查询
        Arrays.sort(queries, 1, q + 1, (a, b) -> {
            int blockA = (a.l - 1) / blen;
            int blockB = (b.l - 1) / blen;
            if (blockA != blockB) {
                return Integer.compare(blockA, blockB);
            }
            return Integer.compare(a.r, b.r);
        });
        
        // 初始化数据结构
        count = new int[uniqueCount + 1];
        
        // 莫队算法主循环
        int curL = 1, curR = 0;
        for (int i = 1; i <= q; i++) {
            int l = queries[i].l;
            int r = queries[i].r;
            int k = queries[i].k;
            int id = queries[i].id;
            
            // 扩展右边界
            while (curR < r) {
                curR++;
                add(curR);
            }
            
            // 收缩左边界
            while (curL > l) {
                curL--;
                add(curL);
            }
            
            // 收缩右边界
            while (curR > r) {
                remove(curR);
                curR--;
            }
            
            // 扩展左边界
            while (curL < l) {
                remove(curL);
                curL++;
            }
            
            // 记录答案
            ans[id] = sortedArr[getKth(k)];
        }
        
        // 输出结果
        for (int i = 1; i <= q; i++) {
            pw.println(ans[i]);
        }
        
        pw.flush();
        pw.close();
        br.close();
    }
}

/*
时间复杂度分析：
- 排序查询：O(q log q)
- 离散化：O(n log n)
- 莫队算法主循环：
  - 指针移动的总次数：O((n + q) * sqrt(n))
  - 每次add/remove操作：O(1)
  - 获取第k小数字操作：O(n)（最坏情况）
  - 总体时间复杂度：O(q log q + n log n + (n + q) * sqrt(n) + q * n)

空间复杂度分析：
- 存储数组和查询：O(n + q)
- 计数数组：O(n)
- 总体空间复杂度：O(n + q)

优化说明：
1. 使用离散化技术减少值域大小，提高效率
2. 块大小选择为sqrt(n)，这是经过理论分析得出的最优块大小

算法说明：
MKTHNUM问题要求查询区间第k小数字，可以使用莫队算法解决：
1. 将所有查询按左端点所在的块编号排序，块内按右端点排序
2. 使用莫队算法的指针移动技巧，维护当前窗口的元素计数
3. 通过遍历离散化后的数组来获取第k小数字

与其他方法的对比：
- 暴力法：每次查询O(n log n)，总时间复杂度O(q * n log n)
- 主席树：在线查询，每次查询O(log n)，预处理O(n log n)
- 莫队算法：离线处理，时间复杂度O((n + q) * sqrt(n) + q * n)，适合此类问题

工程化考虑：
1. 使用BufferedReader和PrintWriter提高输入输出效率
2. 使用离散化减少值域，提高查询效率
3. 对于大规模数据，可以考虑使用更快的输入方法
*/

===============================================

文件: Code42_Mkthnum2.cpp
===============================================
// MKTHNUM - 第K小数字查询问题 - 莫队算法实现 (C++版本)
// 题目来源: SPOJ
// 题目链接: https://www.spoj.com/problems/MKTHNUM/
// 题目大意: 给定一个数组和多个查询，每个查询要求找出区间[l,r]内第k小的数字
// 约束条件: 数组长度n ≤ 10^5，查询次数q ≤ 5*10^3

#include <cstdio>
#include <algorithm>
#include <cmath>
#include <cstring>
using namespace std;

const int MAXN = 100005;

int n, q, blen;
int arr[MAXN];
int count_arr[MAXN]; // 计数数组，记录当前窗口中每个元素的出现次数
int sortedArr[MAXN]; // 排序后的数组，用于离散化

// 查询结构体
struct Query {
    int l, r, k, id;
    
    bool operator<(const Query& other) const {
        int blockA = (l - 1) / blen;
        int blockB = (other.l - 1) / blen;
        if (blockA != blockB) {
            return blockA < blockB;
        }
        return r < other.r;
    }
};

Query queries[MAXN];
int ans[MAXN];

// 添加元素到当前窗口
void add(int pos) {
    count_arr[arr[pos]]++;
}

// 从当前窗口移除元素
void remove(int pos) {
    count_arr[arr[pos]]--;
}

// 获取当前窗口第k小的数字
int getKth(int k) {
    int cnt = 0;
    // 遍历排序后的数组，找到第k小的数字
    for (int i = 1; i <= n; i++) {
        int val = sortedArr[i];
        cnt += count_arr[val];
        if (cnt >= k) {
            return val;
        }
    }
    return -1; // 不应该到达这里
}

int main() {
    // 读取输入
    scanf("%d%d", &n, &q);
    
    for (int i = 1; i <= n; i++) {
        scanf("%d", &arr[i]);
        sortedArr[i] = arr[i];
    }
    
    // 离散化处理
    sort(sortedArr + 1, sortedArr + n + 1);
    int uniqueCount = 1;
    for (int i = 2; i <= n; i++) {
        if (sortedArr[i] != sortedArr[uniqueCount]) {
            sortedArr[++uniqueCount] = sortedArr[i];
        }
    }
    
    // 重新映射数组元素到离散化后的值
    for (int i = 1; i <= n; i++) {
        arr[i] = lower_bound(sortedArr + 1, sortedArr + uniqueCount + 1, arr[i]) - sortedArr;
    }
    
    for (int i = 1; i <= q; i++) {
        int l, r, k;
        scanf("%d%d%d", &l, &r, &k);
        queries[i] = {l, r, k, i};
    }
    
    // 莫队算法处理
    // 块大小选择: sqrt(n)
    blen = (int)sqrt(n);
    
    // 按块排序查询
    sort(queries + 1, queries + q + 1);
    
    // 初始化数据结构
    memset(count_arr, 0, sizeof(count_arr));
    
    // 莫队算法主循环
    int curL = 1, curR = 0;
    for (int i = 1; i <= q; i++) {
        int l = queries[i].l;
        int r = queries[i].r;
        int k = queries[i].k;
        int id = queries[i].id;
        
        // 扩展右边界
        while (curR < r) {
            curR++;
            add(curR);
        }
        
        // 收缩左边界
        while (curL > l) {
            curL--;
            add(curL);
        }
        
        // 收缩右边界
        while (curR > r) {
            remove(curR);
            curR--;
        }
        
        // 扩展左边界
        while (curL < l) {
            remove(curL);
            curL++;
        }
        
        // 记录答案
        ans[id] = sortedArr[getKth(k)];
    }
    
    // 输出结果
    for (int i = 1; i <= q; i++) {
        printf("%d\n", ans[i]);
    }
    
    return 0;
}

/*
时间复杂度分析：
- 排序查询：O(q log q)
- 离散化：O(n log n)
- 莫队算法主循环：
  - 指针移动的总次数：O((n + q) * sqrt(n))
  - 每次add/remove操作：O(1)
  - 获取第k小数字操作：O(n)（最坏情况）
  - 总体时间复杂度：O(q log q + n log n + (n + q) * sqrt(n) + q * n)

空间复杂度分析：
- 存储数组和查询：O(n + q)
- 计数数组：O(n)
- 总体空间复杂度：O(n + q)

优化说明：
1. 使用离散化技术减少值域大小，提高效率
2. 块大小选择为sqrt(n)，这是经过理论分析得出的最优块大小

算法说明：
MKTHNUM问题要求查询区间第k小数字，可以使用莫队算法解决：
1. 将所有查询按左端点所在的块编号排序，块内按右端点排序
2. 使用莫队算法的指针移动技巧，维护当前窗口的元素计数
3. 通过遍历离散化后的数组来获取第k小数字

与其他方法的对比：
- 暴力法：每次查询O(n log n)，总时间复杂度O(q * n log n)
- 主席树：在线查询，每次查询O(log n)，预处理O(n log n)
- 莫队算法：离线处理，时间复杂度O((n + q) * sqrt(n) + q * n)，适合此类问题

工程化考虑：
1. 使用std::cin和std::cout提高输入输出效率
2. 使用离散化减少值域，提高查询效率
3. 对于大规模数据，可以考虑使用更快的输入方法
*/

===============================================

文件: Code42_Mkthnum3.py
===============================================
# MKTHNUM - 第K小数字查询问题 - 莫队算法实现 (Python版本)
# 题目来源: SPOJ
# 题目链接: https://www.spoj.com/problems/MKTHNUM/
# 题目大意: 给定一个数组和多个查询，每个查询要求找出区间[l,r]内第k小的数字
# 约束条件: 数组长度n ≤ 10^5，查询次数q ≤ 5*10^3

import sys
import math
from collections import defaultdict

def main():
    # 读取输入
    n, q = map(int, sys.stdin.readline().split())
    
    arr = [0] + list(map(int, sys.stdin.readline().split()))  # 1-indexed
    sorted_arr = sorted(set(arr[1:]))  # 去重并排序用于离散化
    unique_count = len(sorted_arr)
    
    # 创建值到索引的映射
    value_to_index = {val: idx for idx, val in enumerate(sorted_arr, 1)}
    
    # 重新映射数组元素到离散化后的值
    for i in range(1, n + 1):
        arr[i] = value_to_index[arr[i]]
    
    # 查询结构
    queries = []
    for i in range(1, q + 1):
        l, r, k = map(int, sys.stdin.readline().split())
        queries.append((l, r, k, i))
    
    # 莫队算法处理
    # 块大小选择: sqrt(n)
    blen = int(math.sqrt(n))
    
    # 按块排序查询
    queries.sort(key=lambda x: (x[0] // blen, x[1]))
    
    # 初始化数据结构
    count = defaultdict(int)  # 计数数组，记录当前窗口中每个元素的出现次数
    ans = [0] * (q + 1)
    
    # 添加元素到当前窗口
    def add(pos):
        count[arr[pos]] += 1
    
    # 从当前窗口移除元素
    def remove(pos):
        count[arr[pos]] -= 1
        if count[arr[pos]] == 0:
            del count[arr[pos]]
    
    # 获取当前窗口第k小的数字
    def get_kth(k):
        cnt = 0
        # 按照离散化后的顺序遍历，找到第k小的数字
        for idx in range(1, unique_count + 1):
            cnt += count.get(idx, 0)
            if cnt >= k:
                return sorted_arr[idx - 1]  # 返回原始值
        return -1  # 不应该到达这里
    
    # 莫队算法主循环
    cur_l, cur_r = 1, 0
    for l, r, k, idx in queries:
        # 扩展右边界
        while cur_r < r:
            cur_r += 1
            add(cur_r)
        
        # 收缩左边界
        while cur_l > l:
            cur_l -= 1
            add(cur_l)
        
        # 收缩右边界
        while cur_r > r:
            remove(cur_r)
            cur_r -= 1
        
        # 扩展左边界
        while cur_l < l:
            remove(cur_l)
            cur_l += 1
        
        # 记录答案
        ans[idx] = get_kth(k)
    
    # 输出结果
    for i in range(1, q + 1):
        print(ans[i])

if __name__ == "__main__":
    main()

"""
时间复杂度分析：
- 排序查询：O(q log q)
- 离散化：O(n log n)
- 莫队算法主循环：
  - 指针移动的总次数：O((n + q) * sqrt(n))
  - 每次add/remove操作：O(1)
  - 获取第k小数字操作：O(n)（最坏情况）
  - 总体时间复杂度：O(q log q + n log n + (n + q) * sqrt(n) + q * n)

空间复杂度分析：
- 存储数组和查询：O(n + q)
- 计数数组：O(n)
- 总体空间复杂度：O(n + q)

优化说明：
1. 使用离散化技术减少值域大小，提高效率
2. 块大小选择为sqrt(n)，这是经过理论分析得出的最优块大小

算法说明：
MKTHNUM问题要求查询区间第k小数字，可以使用莫队算法解决：
1. 将所有查询按左端点所在的块编号排序，块内按右端点排序
2. 使用莫队算法的指针移动技巧，维护当前窗口的元素计数
3. 通过遍历离散化后的数组来获取第k小数字

与其他方法的对比：
- 暴力法：每次查询O(n log n)，总时间复杂度O(q * n log n)
- 主席树：在线查询，每次查询O(log n)，预处理O(n log n)
- 莫队算法：离线处理，时间复杂度O((n + q) * sqrt(n) + q * n)，适合此类问题

工程化考虑：
1. 使用sys.stdin.readline()提高输入效率
2. 使用defaultdict避免键不存在的检查
3. 使用set去重和排序进行离散化
4. 对于大规模数据，可以考虑使用更快的输入方法
"""

===============================================

文件: Code43_Giveaway1.java
===============================================
package class175;

// GIVEAWAY - 区间查询与更新问题 - 分块算法实现 (Java版本)
// 题目来源: SPOJ
// 题目链接: https://www.spoj.com/problems/GIVEAWAY/
// 题目大意: 维护一个数组，支持两种操作：
// 1. C x y: 将位置x的值更新为y
// 2. Q l r k: 查询区间[l,r]内大于等于k的元素个数
// 约束条件: 数组长度n ≤ 5*10^5，操作次数q ≤ 10^5

import java.io.*;
import java.util.*;

public class Code43_Giveaway1 {
    static final int MAXN = 500005;
    static final int MAXQ = 100005;
    
    static int n, q, blen, blockCount;
    static int[] arr;           // 原始数组
    static int[] block;         // 每个元素所属的块
    static List<Integer>[] blockElements; // 每个块中排序后的元素
    
    // 初始化分块结构
    static void init() {
        blen = (int) Math.sqrt(n);
        if (blen == 0) blen = 1;
        blockCount = (n + blen - 1) / blen;
        
        block = new int[n + 1];
        blockElements = new ArrayList[blockCount];
        
        // 为每个元素分配块
        for (int i = 1; i <= n; i++) {
            block[i] = (i - 1) / blen;
        }
        
        // 初始化每个块的元素列表
        for (int i = 0; i < blockCount; i++) {
            blockElements[i] = new ArrayList<>();
        }
        
        // 将元素分配到对应的块中并排序
        for (int i = 1; i <= n; i++) {
            blockElements[block[i]].add(arr[i]);
        }
        
        // 对每个块中的元素进行排序
        for (int i = 0; i < blockCount; i++) {
            Collections.sort(blockElements[i]);
        }
    }
    
    // 更新操作：将位置pos的值更新为val
    static void update(int pos, int val) {
        int blockId = block[pos];
        int oldVal = arr[pos];
        arr[pos] = val;
        
        // 从块中移除旧值
        blockElements[blockId].remove(Integer.valueOf(oldVal));
        // 向块中添加新值
        blockElements[blockId].add(val);
        // 重新排序
        Collections.sort(blockElements[blockId]);
    }
    
    // 查询操作：查询区间[l,r]内大于等于k的元素个数
    static int query(int l, int r, int k) {
        int leftBlock = block[l];
        int rightBlock = block[r];
        int result = 0;
        
        if (leftBlock == rightBlock) {
            // 所有元素都在同一个块内，直接暴力查询
            for (int i = l; i <= r; i++) {
                if (arr[i] >= k) {
                    result++;
                }
            }
        } else {
            // 处理左边不完整的块
            for (int i = l; i < (leftBlock + 1) * blen + 1 && i <= n; i++) {
                if (arr[i] >= k) {
                    result++;
                }
            }
            
            // 处理中间完整的块，使用二分查找
            for (int i = leftBlock + 1; i < rightBlock; i++) {
                // 使用二分查找找到第一个大于等于k的位置
                int idx = Collections.binarySearch(blockElements[i], k);
                if (idx < 0) {
                    idx = -idx - 1;  // 转换为插入位置
                }
                // 计算大于等于k的元素个数
                result += blockElements[i].size() - idx;
            }
            
            // 处理右边不完整的块
            for (int i = rightBlock * blen + 1; i <= r; i++) {
                if (arr[i] >= k) {
                    result++;
                }
            }
        }
        
        return result;
    }
    
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        PrintWriter pw = new PrintWriter(new OutputStreamWriter(System.out));
        
        // 读取输入
        n = Integer.parseInt(br.readLine());
        
        arr = new int[n + 1];
        StringTokenizer st = new StringTokenizer(br.readLine());
        for (int i = 1; i <= n; i++) {
            arr[i] = Integer.parseInt(st.nextToken());
        }
        
        // 初始化分块结构
        init();
        
        q = Integer.parseInt(br.readLine());
        
        for (int i = 0; i < q; i++) {
            st = new StringTokenizer(br.readLine());
            String op = st.nextToken();
            
            if (op.equals("C")) {
                // 更新操作
                int x = Integer.parseInt(st.nextToken());
                int y = Integer.parseInt(st.nextToken());
                update(x, y);
            } else if (op.equals("Q")) {
                // 查询操作
                int l = Integer.parseInt(st.nextToken());
                int r = Integer.parseInt(st.nextToken());
                int k = Integer.parseInt(st.nextToken());
                int result = query(l, r, k);
                pw.println(result);
            }
        }
        
        pw.flush();
        pw.close();
        br.close();
    }
}

/*
时间复杂度分析：
- 初始化：O(n * sqrt(n))，因为需要对每个块进行排序
- 更新操作：
  - 对于不完整的块：O(1)（直接修改原始数组）
  - 对于完整块的排序：O(sqrt(n))（需要重新排序）
  - 总体时间复杂度：O(sqrt(n))
- 查询操作：
  - 对于不完整的块：O(sqrt(n))（直接遍历）
  - 对于完整块：O(log(sqrt(n)))（二分查找）
  - 总体时间复杂度：O(sqrt(n) * log(sqrt(n)))

空间复杂度分析：
- 原始数组：O(n)
- 块分配数组：O(n)
- 块元素列表：O(n)
- 总体空间复杂度：O(n)

优化说明：
1. 使用分块算法将数组分成大小为sqrt(n)的块
2. 对每个块中的元素进行排序，便于二分查找
3. 更新操作时，需要重新排序对应的块
4. 查询操作时，对不完整的块直接遍历，对完整的块使用二分查找

算法说明：
GIVEAWAY问题要求支持区间更新和区间查询，可以使用分块算法解决：
1. 将数组分成大小为sqrt(n)的块
2. 对每个块中的元素进行排序
3. 更新操作时，修改原始数组并重新排序对应的块
4. 查询操作时，对不完整的块直接遍历，对完整的块使用二分查找统计大于等于k的元素个数

与其他方法的对比：
- 暴力法：更新O(1)，查询O(n)，总时间复杂度O(q * n)
- 线段树：更新O(log n)，查询O(log n)，但实现复杂
- 分块算法：更新O(sqrt(n))，查询O(sqrt(n) * log(sqrt(n)))，实现相对简单

工程化考虑：
1. 使用BufferedReader和PrintWriter提高输入输出效率
2. 使用Collections.binarySearch进行二分查找
3. 对于频繁更新的场景，可以考虑使用懒惰重建策略
4. 注意边界条件的处理
*/

===============================================

文件: Code43_Giveaway2.cpp
===============================================
// GIVEAWAY - 区间查询与更新问题 - 分块算法实现 (C++版本)
// 题目来源: SPOJ
// 题目链接: https://www.spoj.com/problems/GIVEAWAY/
// 题目大意: 维护一个数组，支持两种操作：
// 1. C x y: 将位置x的值更新为y
// 2. Q l r k: 查询区间[l,r]内大于等于k的元素个数
// 约束条件: 数组长度n ≤ 5*10^5，操作次数q ≤ 10^5

#include <algorithm>
#include <cmath>
#include <vector>
using namespace std;

const int MAXN = 500005;

int n, q, blen, blockCount;
int arr[MAXN];           // 原始数组
int block[MAXN];         // 每个元素所属的块
vector<int> blockElements[MAXN]; // 每个块中排序后的元素

// 初始化分块结构
void init() {
    blen = (int)sqrt(n);
    if (blen == 0) blen = 1;
    blockCount = (n + blen - 1) / blen;
    
    // 为每个元素分配块
    for (int i = 1; i <= n; i++) {
        block[i] = (i - 1) / blen;
    }
    
    // 将元素分配到对应的块中并排序
    for (int i = 1; i <= n; i++) {
        blockElements[block[i]].push_back(arr[i]);
    }
    
    // 对每个块中的元素进行排序
    for (int i = 0; i < blockCount; i++) {
        sort(blockElements[i].begin(), blockElements[i].end());
    }
}

// 更新操作：将位置pos的值更新为val
void update(int pos, int val) {
    int blockId = block[pos];
    int oldVal = arr[pos];
    arr[pos] = val;
    
    // 从块中移除旧值
    for (auto it = blockElements[blockId].begin(); it != blockElements[blockId].end(); ++it) {
        if (*it == oldVal) {
            blockElements[blockId].erase(it);
            break;
        }
    }
    // 向块中添加新值
    blockElements[blockId].push_back(val);
    // 重新排序
    sort(blockElements[blockId].begin(), blockElements[blockId].end());
}

// 查询操作：查询区间[l,r]内大于等于k的元素个数
int query(int l, int r, int k) {
    int leftBlock = block[l];
    int rightBlock = block[r];
    int result = 0;
    
    if (leftBlock == rightBlock) {
        // 所有元素都在同一个块内，直接暴力查询
        for (int i = l; i <= r; i++) {
            if (arr[i] >= k) {
                result++;
            }
        }
    } else {
        // 处理左边不完整的块
        for (int i = l; i < (leftBlock + 1) * blen + 1 && i <= n; i++) {
            if (arr[i] >= k) {
                result++;
            }
        }
        
        // 处理中间完整的块，使用二分查找
        for (int i = leftBlock + 1; i < rightBlock; i++) {
            // 使用二分查找找到第一个大于等于k的位置
            auto it = lower_bound(blockElements[i].begin(), blockElements[i].end(), k);
            // 计算大于等于k的元素个数
            result += blockElements[i].end() - it;
        }
        
        // 处理右边不完整的块
        for (int i = rightBlock * blen + 1; i <= r; i++) {
            if (arr[i] >= k) {
                result++;
            }
        }
    }
    
    return result;
}

int main() {
    // 读取输入
    scanf("%d", &n);
    
    for (int i = 1; i <= n; i++) {
        scanf("%d", &arr[i]);
    }
    
    // 初始化分块结构
    init();
    
    scanf("%d", &q);
    
    for (int i = 0; i < q; i++) {
        char op[2];
        scanf("%s", op);
        
        if (op[0] == 'C') {
            // 更新操作
            int x, y;
            scanf("%d%d", &x, &y);
            update(x, y);
        } else if (op[0] == 'Q') {
            // 查询操作
            int l, r, k;
            scanf("%d%d%d", &l, &r, &k);
            int result = query(l, r, k);
            printf("%d\n", result);
        }
    }
    
    return 0;
}

/*
时间复杂度分析：
- 初始化：O(n * sqrt(n))，因为需要对每个块进行排序
- 更新操作：
  - 对于不完整的块：O(1)（直接修改原始数组）
  - 对于完整块的排序：O(sqrt(n))（需要重新排序）
  - 总体时间复杂度：O(sqrt(n))
- 查询操作：
  - 对于不完整的块：O(sqrt(n))（直接遍历）
  - 对于完整块：O(log(sqrt(n)))（二分查找）
  - 总体时间复杂度：O(sqrt(n) * log(sqrt(n)))

空间复杂度分析：
- 原始数组：O(n)
- 块分配数组：O(n)
- 块元素列表：O(n)
- 总体空间复杂度：O(n)

优化说明：
1. 使用分块算法将数组分成大小为sqrt(n)的块
2. 对每个块中的元素进行排序，便于二分查找
3. 更新操作时，需要重新排序对应的块
4. 查询操作时，对不完整的块直接遍历，对完整的块使用二分查找

算法说明：
GIVEAWAY问题要求支持区间更新和区间查询，可以使用分块算法解决：
1. 将数组分成大小为sqrt(n)的块
2. 对每个块中的元素进行排序
3. 更新操作时，修改原始数组并重新排序对应的块
4. 查询操作时，对不完整的块直接遍历，对完整的块使用二分查找统计大于等于k的元素个数

与其他方法的对比：
- 暴力法：更新O(1)，查询O(n)，总时间复杂度O(q * n)
- 线段树：更新O(log n)，查询O(log n)，但实现复杂
- 分块算法：更新O(sqrt(n))，查询O(sqrt(n) * log(sqrt(n)))，实现相对简单

工程化考虑：
1. 使用scanf和printf提高输入输出效率
2. 使用lower_bound进行二分查找
3. 对于频繁更新的场景，可以考虑使用懒惰重建策略
4. 注意边界条件的处理
*/

===============================================

文件: Code43_Giveaway3.py
===============================================
# GIVEAWAY - 区间查询与更新问题 - 分块算法实现 (Python版本)
# 题目来源: SPOJ
# 题目链接: https://www.spoj.com/problems/GIVEAWAY/
# 题目大意: 维护一个数组，支持两种操作：
# 1. C x y: 将位置x的值更新为y
# 2. Q l r k: 查询区间[l,r]内大于等于k的元素个数
# 约束条件: 数组长度n ≤ 5*10^5，操作次数q ≤ 10^5

import sys
import math
import bisect

def main():
    # 读取输入
    n = int(sys.stdin.readline())
    
    arr = [0] + list(map(int, sys.stdin.readline().split()))  # 1-indexed
    
    # 初始化分块结构
    blen = int(math.sqrt(n))
    if blen == 0:
        blen = 1
    block_count = (n + blen - 1) // blen
    
    # 为每个元素分配块
    block = [0] * (n + 1)
    for i in range(1, n + 1):
        block[i] = (i - 1) // blen
    
    # 每个块中排序后的元素
    block_elements = [[] for _ in range(block_count)]
    
    # 将元素分配到对应的块中并排序
    for i in range(1, n + 1):
        block_elements[block[i]].append(arr[i])
    
    # 对每个块中的元素进行排序
    for i in range(block_count):
        block_elements[i].sort()
    
    # 更新操作：将位置pos的值更新为val
    def update(pos, val):
        block_id = block[pos]
        old_val = arr[pos]
        arr[pos] = val
        
        # 从块中移除旧值
        block_elements[block_id].remove(old_val)
        # 向块中添加新值
        block_elements[block_id].append(val)
        # 重新排序
        block_elements[block_id].sort()
    
    # 查询操作：查询区间[l,r]内大于等于k的元素个数
    def query(l, r, k):
        left_block = block[l]
        right_block = block[r]
        result = 0
        
        if left_block == right_block:
            # 所有元素都在同一个块内，直接暴力查询
            for i in range(l, r + 1):
                if arr[i] >= k:
                    result += 1
        else:
            # 处理左边不完整的块
            for i in range(l, min((left_block + 1) * blen + 1, n + 1)):
                if arr[i] >= k:
                    result += 1
            
            # 处理中间完整的块，使用二分查找
            for i in range(left_block + 1, right_block):
                # 使用二分查找找到第一个大于等于k的位置
                idx = bisect.bisect_left(block_elements[i], k)
                # 计算大于等于k的元素个数
                result += len(block_elements[i]) - idx
            
            # 处理右边不完整的块
            for i in range(right_block * blen + 1, r + 1):
                if arr[i] >= k:
                    result += 1
        
        return result
    
    q = int(sys.stdin.readline())
    
    for _ in range(q):
        op, *args = sys.stdin.readline().split()
        
        if op == "C":
            # 更新操作
            x, y = map(int, args)
            update(x, y)
        elif op == "Q":
            # 查询操作
            l, r, k = map(int, args)
            result = query(l, r, k)
            print(result)

if __name__ == "__main__":
    main()

"""
时间复杂度分析：
- 初始化：O(n * sqrt(n))，因为需要对每个块进行排序
- 更新操作：
  - 对于不完整的块：O(1)（直接修改原始数组）
  - 对于完整块的排序：O(sqrt(n))（需要重新排序）
  - 总体时间复杂度：O(sqrt(n))
- 查询操作：
  - 对于不完整的块：O(sqrt(n))（直接遍历）
  - 对于完整块：O(log(sqrt(n)))（二分查找）
  - 总体时间复杂度：O(sqrt(n) * log(sqrt(n)))

空间复杂度分析：
- 原始数组：O(n)
- 块分配数组：O(n)
- 块元素列表：O(n)
- 总体空间复杂度：O(n)

优化说明：
1. 使用分块算法将数组分成大小为sqrt(n)的块
2. 对每个块中的元素进行排序，便于二分查找
3. 更新操作时，需要重新排序对应的块
4. 查询操作时，对不完整的块直接遍历，对完整的块使用二分查找

算法说明：
GIVEAWAY问题要求支持区间更新和区间查询，可以使用分块算法解决：
1. 将数组分成大小为sqrt(n)的块
2. 对每个块中的元素进行排序
3. 更新操作时，修改原始数组并重新排序对应的块
4. 查询操作时，对不完整的块直接遍历，对完整的块使用二分查找统计大于等于k的元素个数

与其他方法的对比：
- 暴力法：更新O(1)，查询O(n)，总时间复杂度O(q * n)
- 线段树：更新O(log n)，查询O(log n)，但实现复杂
- 分块算法：更新O(sqrt(n))，查询O(sqrt(n) * log(sqrt(n)))，实现相对简单

工程化考虑：
1. 使用sys.stdin.readline()提高输入效率
2. 使用bisect模块进行二分查找
3. 对于频繁更新的场景，可以考虑使用懒惰重建策略
4. 注意边界条件的处理
"""

===============================================

文件: Codeforces_343D_WaterTree.java
===============================================
/**
 * Codeforces 343D - Water Tree - Java实现
 * 
 * 题目描述：
 * 给定一棵树，支持以下操作：
 * 1. 将节点v及其所有祖先节点填满水
 * 2. 将节点v及其子树清空水
 * 3. 查询节点v是否有水
 * 
 * 时间复杂度：
 * - 预处理：O(n)
 * - 操作1：O(log²n)
 * - 操作2：O(log n)
 * - 操作3：O(log n)
 * 
 * 空间复杂度：O(n)
 * 
 * 题目链接：https://codeforces.com/problemset/problem/343/D
 */

import java.util.*;
import java.io.*;

public class Codeforces_343D_WaterTree {
    static int n, m;
    static List<Integer>[] tree;
    
    // 树链剖分相关数组
    static int[] parent, depth, size, heavy, head, pos, inTime, outTime;
    static int curPos, timer;
    
    // 线段树用于记录填水时间
    static int[] segTree, lazy;
    static int[] fillTime; // 记录每个节点最后一次被填水的时间
    static int[] emptyTime; // 记录每个节点最后一次被清空的时间
    
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        PrintWriter pw = new PrintWriter(System.out);
        
        n = Integer.parseInt(br.readLine());
        tree = new ArrayList[n + 1];
        for (int i = 0; i <= n; i++) {
            tree[i] = new ArrayList<>();
        }
        
        for (int i = 1; i < n; i++) {
            StringTokenizer st = new StringTokenizer(br.readLine());
            int u = Integer.parseInt(st.nextToken());
            int v = Integer.parseInt(st.nextToken());
            tree[u].add(v);
            tree[v].add(u);
        }
        
        initHLD();
        
        m = Integer.parseInt(br.readLine());
        for (int i = 1; i <= m; i++) {
            StringTokenizer st = new StringTokenizer(br.readLine());
            int op = Integer.parseInt(st.nextToken());
            int v = Integer.parseInt(st.nextToken());
            
            if (op == 1) {
                // 填满节点v及其所有祖先
                fillWater(v, i);
            } else if (op == 2) {
                // 清空节点v及其子树
                emptyWater(v, i);
            } else {
                // 查询节点v是否有水
                pw.println(queryWater(v) ? "1" : "0");
            }
        }
        
        pw.flush();
    }
    
    static void initHLD() {
        parent = new int[n + 1];
        depth = new int[n + 1];
        size = new int[n + 1];
        heavy = new int[n + 1];
        head = new int[n + 1];
        pos = new int[n + 1];
        inTime = new int[n + 1];
        outTime = new int[n + 1];
        curPos = 0;
        timer = 0;
        
        segTree = new int[4 * n];
        lazy = new int[4 * n];
        fillTime = new int[n + 1];
        emptyTime = new int[n + 1];
        
        Arrays.fill(heavy, -1);
        Arrays.fill(head, -1);
        
        dfs1(1, 0);
        dfs2(1, 1);
        
        buildSegTree(1, 0, n - 1);
    }
    
    static void dfs1(int u, int p) {
        parent[u] = p;
        depth[u] = depth[p] + 1;
        size[u] = 1;
        inTime[u] = timer++;
        
        int maxSize = 0;
        for (int v : tree[u]) {
            if (v == p) continue;
            dfs1(v, u);
            size[u] += size[v];
            if (size[v] > maxSize) {
                maxSize = size[v];
                heavy[u] = v;
            }
        }
        outTime[u] = timer - 1;
    }
    
    static void dfs2(int u, int h) {
        head[u] = h;
        pos[u] = curPos++;
        
        if (heavy[u] != -1) {
            dfs2(heavy[u], h);
        }
        
        for (int v : tree[u]) {
            if (v == parent[u] || v == heavy[u]) continue;
            dfs2(v, v);
        }
    }
    
    static void buildSegTree(int idx, int l, int r) {
        if (l == r) {
            segTree[idx] = 0;
            return;
        }
        int mid = (l + r) / 2;
        buildSegTree(2 * idx, l, mid);
        buildSegTree(2 * idx + 1, mid + 1, r);
        segTree[idx] = Math.max(segTree[2 * idx], segTree[2 * idx + 1]);
    }
    
    static void fillWater(int v, int time) {
        // 填满节点v及其所有祖先
        while (v != 0) {
            updateSegTree(1, 0, n - 1, pos[v], pos[v], time);
            v = parent[v];
        }
    }
    
    static void emptyWater(int v, int time) {
        // 清空节点v及其子树
        emptyTime[v] = time;
        updateSubtree(v, 0);
    }
    
    static boolean queryWater(int v) {
        // 查询节点v是否有水
        int lastFill = queryPathMax(v);
        int lastEmpty = emptyTime[v];
        
        // 如果最后一次填水时间晚于最后一次清空时间，则有水
        return lastFill > lastEmpty;
    }
    
    static int queryPathMax(int v) {
        int maxTime = 0;
        while (v != 0) {
            maxTime = Math.max(maxTime, querySegTree(1, 0, n - 1, pos[v], pos[v]));
            v = parent[v];
        }
        return maxTime;
    }
    
    static void updateSegTree(int idx, int segL, int segR, int l, int r, int val) {
        if (lazy[idx] != 0) {
            segTree[idx] = Math.max(segTree[idx], lazy[idx]);
            if (segL != segR) {
                lazy[2 * idx] = Math.max(lazy[2 * idx], lazy[idx]);
                lazy[2 * idx + 1] = Math.max(lazy[2 * idx + 1], lazy[idx]);
            }
            lazy[idx] = 0;
        }
        if (l > segR || r < segL) return;
        if (l <= segL && segR <= r) {
            segTree[idx] = Math.max(segTree[idx], val);
            if (segL != segR) {
                lazy[2 * idx] = Math.max(lazy[2 * idx], val);
                lazy[2 * idx + 1] = Math.max(lazy[2 * idx + 1], val);
            }
            return;
        }
        int mid = (segL + segR) / 2;
        updateSegTree(2 * idx, segL, mid, l, r, val);
        updateSegTree(2 * idx + 1, mid + 1, segR, l, r, val);
        segTree[idx] = Math.max(segTree[2 * idx], segTree[2 * idx + 1]);
    }
    
    static void updateSubtree(int u, int val) {
        updateSegTree(1, 0, n - 1, pos[u], pos[u] + size[u] - 1, val);
    }
    
    static int querySegTree(int idx, int segL, int segR, int l, int r) {
        if (lazy[idx] != 0) {
            segTree[idx] = Math.max(segTree[idx], lazy[idx]);
            if (segL != segR) {
                lazy[2 * idx] = Math.max(lazy[2 * idx], lazy[idx]);
                lazy[2 * idx + 1] = Math.max(lazy[2 * idx + 1], lazy[idx]);
            }
            lazy[idx] = 0;
        }
        if (l > segR || r < segL) return 0;
        if (l <= segL && segR <= r) {
            return segTree[idx];
        }
        int mid = (segL + segR) / 2;
        int leftRes = querySegTree(2 * idx, segL, mid, l, r);
        int rightRes = querySegTree(2 * idx + 1, mid + 1, segR, l, r);
        return Math.max(leftRes, rightRes);
    }
}

===============================================

文件: DecisionTree.java
===============================================
package class175.决策树;

import java.util.*;
import java.util.stream.Collectors;

/**
 * 决策树（Decision Tree）实现
 * 决策树是一种用于分类和回归的监督学习算法
 * 它通过从数据特征中学习决策规则，构建树状模型进行预测
 * 
 * 常见应用场景：
 * 1. 分类问题（如疾病诊断、客户流失预测）
 * 2. 回归问题（如房价预测、销售量预测）
 * 3. 特征重要性分析
 * 4. 规则提取（从树结构中提取业务规则）
 * 5. 数据分析和数据挖掘
 * 6. 风险评估和信用评分
 * 
 * 相关算法题目：
 * - LeetCode 222. 完全二叉树的节点个数 https://leetcode.cn/problems/count-complete-tree-nodes/
 * - LeetCode 637. 二叉树的层平均值 https://leetcode.cn/problems/average-of-levels-in-binary-tree/
 * - LeetCode 572. 另一棵树的子树 https://leetcode.cn/problems/subtree-of-another-tree/
 * - LintCode 95. 验证二叉查找树 https://www.lintcode.com/problem/95/
 * - 洛谷 P3379 【模板】最近公共祖先 https://www.luogu.com.cn/problem/P3379
 * - 牛客 NC119 最小的K个数 https://www.nowcoder.com/practice/6a296eb82cf844ca8539b57c23e6e9bf
 * - HackerRank Tree: Huffman Decoding https://www.hackerrank.com/challenges/tree-huffman-decoding/problem
 * - CodeChef DECMTREE https://www.codechef.com/problems/DECMTREE
 * - USACO Section 3.4 Raucous Rockers https://usaco.org/index.php?page=viewproblem2&cpid=348
 * - AtCoder ABC177 F - I hate Shortest Path Problem https://atcoder.jp/contests/abc177/tasks/abc177_f
 * - 杭电 OJ 2544 最短路 https://acm.hdu.edu.cn/showproblem.php?pid=2544
 * - SPOJ PT07Z - Longest path in a tree https://www.spoj.com/problems/PT07Z/
 * - Codeforces 1327C - Game with Chips https://codeforces.com/problemset/problem/1327/C
 */

/**
 * 决策树节点类
 */
class TreeNode {
    private boolean isLeaf;         // 是否为叶节点
    private String attribute;       // 用于分裂的属性
    private Map<String, TreeNode> children;  // 子节点映射
    private String classification;  // 叶节点的分类结果
    private double value;           // 回归树的预测值（用于回归问题）
    private double informationGain; // 分裂时的信息增益
    private int depth;              // 节点深度
    
    /**
     * 构造内部节点（用于属性分裂）
     * @param attribute 分裂属性
     * @param informationGain 信息增益
     * @param depth 节点深度
     */
    public TreeNode(String attribute, double informationGain, int depth) {
        this.isLeaf = false;
        this.attribute = attribute;
        this.informationGain = informationGain;
        this.depth = depth;
        this.children = new HashMap<>();
    }
    
    /**
     * 构造叶节点（分类树）
     * @param classification 分类结果
     * @param depth 节点深度
     */
    public TreeNode(String classification, int depth) {
        this.isLeaf = true;
        this.classification = classification;
        this.depth = depth;
        this.children = new HashMap<>();
    }
    
    /**
     * 构造叶节点（回归树）
     * @param value 回归预测值
     * @param depth 节点深度
     */
    public TreeNode(double value, int depth) {
        this.isLeaf = true;
        this.value = value;
        this.depth = depth;
        this.children = new HashMap<>();
    }
    
    // Getter和Setter方法
    public boolean isLeaf() { return isLeaf; }
    public String getAttribute() { return attribute; }
    public Map<String, TreeNode> getChildren() { return children; }
    public String getClassification() { return classification; }
    public double getValue() { return value; }
    public double getInformationGain() { return informationGain; }
    public int getDepth() { return depth; }
    
    /**
     * 添加子节点
     * @param attributeValue 属性值
     * @param child 子节点
     */
    public void addChild(String attributeValue, TreeNode child) {
        children.put(attributeValue, child);
    }
    
    @Override
    public String toString() {
        if (isLeaf) {
            return classification != null ? 
                   "叶节点(分类=" + classification + ", 深度=" + depth + ")" : 
                   "叶节点(值=" + value + ", 深度=" + depth + ")";
        } else {
            return "内部节点(属性=" + attribute + ", 信息增益=" + 
                   String.format("%.4f", informationGain) + ", 深度=" + depth + ")";
        }
    }
}

/**
 * 数据集行类，用于表示数据集中的一行数据
 */
class DataRow {
    private Map<String, Object> attributes;  // 属性及其值
    private String label;                    // 分类标签
    private Double value;                    // 回归目标值
    
    /**
     * 构造分类数据行
     * @param attributes 属性映射
     * @param label 分类标签
     */
    public DataRow(Map<String, Object> attributes, String label) {
        this.attributes = new HashMap<>(attributes);
        this.label = label;
        this.value = null;
    }
    
    /**
     * 构造回归数据行
     * @param attributes 属性映射
     * @param value 回归目标值
     */
    public DataRow(Map<String, Object> attributes, double value) {
        this.attributes = new HashMap<>(attributes);
        this.label = null;
        this.value = value;
    }
    
    /**
     * 获取属性值
     * @param attribute 属性名
     * @return 属性值
     */
    public Object getAttributeValue(String attribute) {
        return attributes.get(attribute);
    }
    
    /**
     * 获取所有属性
     * @return 属性映射
     */
    public Map<String, Object> getAllAttributes() {
        return new HashMap<>(attributes);
    }
    
    /**
     * 获取分类标签
     * @return 分类标签
     */
    public String getLabel() {
        return label;
    }
    
    /**
     * 获取回归目标值
     * @return 目标值
     */
    public Double getValue() {
        return value;
    }
    
    /**
     * 判断是否为分类数据
     * @return 是否为分类数据
     */
    public boolean isClassification() {
        return label != null;
    }
    
    @Override
    public String toString() {
        if (isClassification()) {
            return "DataRow{attributes=" + attributes + ", label='" + label + "'}";
        } else {
            return "DataRow{attributes=" + attributes + ", value=" + value + "}";
        }
    }
}

/**
 * 决策树类
 */
public class DecisionTree {
    private TreeNode root;           // 根节点
    private List<String> attributes; // 特征列表
    private int maxDepth;            // 最大深度
    private int minSamplesSplit;     // 最小分裂样本数
    private boolean isRegression;    // 是否为回归树
    
    /**
     * 构造函数
     * @param maxDepth 最大深度
     * @param minSamplesSplit 最小分裂样本数
     * @param isRegression 是否为回归树
     */
    public DecisionTree(int maxDepth, int minSamplesSplit, boolean isRegression) {
        this.maxDepth = maxDepth;
        this.minSamplesSplit = minSamplesSplit;
        this.isRegression = isRegression;
        this.root = null;
    }
    
    /**
     * 默认构造函数（分类树）
     */
    public DecisionTree() {
        this.maxDepth = 10;           // 默认最大深度
        this.minSamplesSplit = 2;     // 默认最小分裂样本数
        this.isRegression = false;    // 默认分类树
        this.root = null;
    }
    
    /**
     * 训练决策树
     * @param dataSet 数据集
     * @param attributes 属性列表
     */
    public void fit(List<DataRow> dataSet, List<String> attributes) {
        this.attributes = new ArrayList<>(attributes);
        this.root = buildTree(dataSet, attributes, 0);
    }
    
    /**
     * 递归构建决策树
     * @param dataSet 当前数据集
     * @param availableAttributes 可用属性列表
     * @param depth 当前深度
     * @return 构建的节点
     */
    private TreeNode buildTree(List<DataRow> dataSet, List<String> availableAttributes, int depth) {
        // 检查是否满足终止条件
        if (shouldStop(dataSet, availableAttributes, depth)) {
            return createLeafNode(dataSet, depth);
        }
        
        // 选择最佳分裂属性
        String bestAttribute = selectBestAttribute(dataSet, availableAttributes);
        double bestGain = calculateGain(dataSet, bestAttribute);
        
        // 创建内部节点
        TreeNode node = new TreeNode(bestAttribute, bestGain, depth);
        
        // 根据最佳属性的值分割数据集
        Map<Object, List<DataRow>> partitions = partitionByAttribute(dataSet, bestAttribute);
        
        // 为每个属性值创建子树
        for (Map.Entry<Object, List<DataRow>> entry : partitions.entrySet()) {
            Object value = entry.getKey();
            List<DataRow> subset = entry.getValue();
            
            // 如果子集为空，创建叶节点
            if (subset.isEmpty()) {
                node.addChild(value.toString(), createLeafNode(dataSet, depth + 1));
            } else {
                // 递归构建子树
                List<String> newAttributes = new ArrayList<>(availableAttributes);
                newAttributes.remove(bestAttribute);
                node.addChild(value.toString(), buildTree(subset, newAttributes, depth + 1));
            }
        }
        
        return node;
    }
    
    /**
     * 判断是否应该停止树的生长
     * @param dataSet 当前数据集
     * @param availableAttributes 可用属性列表
     * @param depth 当前深度
     * @return 是否应该停止
     */
    private boolean shouldStop(List<DataRow> dataSet, List<String> availableAttributes, int depth) {
        // 1. 数据集为空
        if (dataSet.isEmpty()) {
            return true;
        }
        
        // 2. 达到最大深度
        if (depth >= maxDepth) {
            return true;
        }
        
        // 3. 没有可用属性
        if (availableAttributes.isEmpty()) {
            return true;
        }
        
        // 4. 样本数小于最小分裂样本数
        if (dataSet.size() < minSamplesSplit) {
            return true;
        }
        
        // 5. 所有样本属于同一类别（分类树）
        if (!isRegression) {
            String firstLabel = dataSet.get(0).getLabel();
            boolean allSame = dataSet.stream().allMatch(row -> row.getLabel().equals(firstLabel));
            if (allSame) {
                return true;
            }
        } 
        // 5. 所有样本的目标值相同（回归树）
        else {
            double firstValue = dataSet.get(0).getValue();
            boolean allSame = dataSet.stream().allMatch(row -> Math.abs(row.getValue() - firstValue) < 1e-9);
            if (allSame) {
                return true;
            }
        }
        
        return false;
    }
    
    /**
     * 创建叶节点
     * @param dataSet 数据集
     * @param depth 深度
     * @return 叶节点
     */
    private TreeNode createLeafNode(List<DataRow> dataSet, int depth) {
        if (dataSet.isEmpty()) {
            return isRegression ? new TreeNode(0.0, depth) : new TreeNode("Unknown", depth);
        }
        
        if (!isRegression) {
            // 分类树：返回最常见的类别
            Map<String, Long> labelCounts = dataSet.stream()
                    .collect(Collectors.groupingBy(DataRow::getLabel, Collectors.counting()));
            
            String mostCommonLabel = labelCounts.entrySet().stream()
                    .max(Map.Entry.comparingByValue())
                    .map(Map.Entry::getKey)
                    .orElse("Unknown");
            
            return new TreeNode(mostCommonLabel, depth);
        } else {
            // 回归树：返回平均值
            double average = dataSet.stream()
                    .mapToDouble(DataRow::getValue)
                    .average()
                    .orElse(0.0);
            
            return new TreeNode(average, depth);
        }
    }
    
    /**
     * 选择最佳分裂属性
     * @param dataSet 数据集
     * @param availableAttributes 可用属性列表
     * @return 最佳属性名
     */
    private String selectBestAttribute(List<DataRow> dataSet, List<String> availableAttributes) {
        String bestAttribute = null;
        double bestGain = -Double.MAX_VALUE;
        
        for (String attribute : availableAttributes) {
            double gain = calculateGain(dataSet, attribute);
            if (gain > bestGain) {
                bestGain = gain;
                bestAttribute = attribute;
            }
        }
        
        return bestAttribute;
    }
    
    /**
     * 计算信息增益（分类树）或方差减少（回归树）
     * @param dataSet 数据集
     * @param attribute 属性名
     * @return 信息增益或方差减少量
     */
    private double calculateGain(List<DataRow> dataSet, String attribute) {
        if (dataSet.isEmpty()) {
            return 0.0;
        }
        
        if (!isRegression) {
            // 计算信息增益（使用熵）
            double parentEntropy = calculateEntropy(dataSet);
            Map<Object, List<DataRow>> partitions = partitionByAttribute(dataSet, attribute);
            
            double weightedEntropy = 0.0;
            for (List<DataRow> subset : partitions.values()) {
                double weight = (double) subset.size() / dataSet.size();
                weightedEntropy += weight * calculateEntropy(subset);
            }
            
            return parentEntropy - weightedEntropy;
        } else {
            // 计算方差减少
            double parentVariance = calculateVariance(dataSet);
            Map<Object, List<DataRow>> partitions = partitionByAttribute(dataSet, attribute);
            
            double weightedVariance = 0.0;
            for (List<DataRow> subset : partitions.values()) {
                double weight = (double) subset.size() / dataSet.size();
                weightedVariance += weight * calculateVariance(subset);
            }
            
            return parentVariance - weightedVariance;
        }
    }
    
    /**
     * 计算数据集的熵
     * @param dataSet 数据集
     * @return 熵值
     */
    private double calculateEntropy(List<DataRow> dataSet) {
        if (dataSet.isEmpty()) {
            return 0.0;
        }
        
        Map<String, Long> labelCounts = dataSet.stream()
                .collect(Collectors.groupingBy(DataRow::getLabel, Collectors.counting()));
        
        double entropy = 0.0;
        double total = dataSet.size();
        
        for (long count : labelCounts.values()) {
            double probability = count / total;
            entropy -= probability * Math.log(probability) / Math.log(2);
        }
        
        return entropy;
    }
    
    /**
     * 计算数据集的方差
     * @param dataSet 数据集
     * @return 方差
     */
    private double calculateVariance(List<DataRow> dataSet) {
        if (dataSet.isEmpty()) {
            return 0.0;
        }
        
        double mean = dataSet.stream().mapToDouble(DataRow::getValue).average().orElse(0.0);
        
        return dataSet.stream()
                .mapToDouble(row -> Math.pow(row.getValue() - mean, 2))
                .average()
                .orElse(0.0);
    }
    
    /**
     * 根据属性值分割数据集
     * @param dataSet 数据集
     * @param attribute 属性名
     * @return 分割后的数据集映射
     */
    private Map<Object, List<DataRow>> partitionByAttribute(List<DataRow> dataSet, String attribute) {
        return dataSet.stream()
                .collect(Collectors.groupingBy(row -> row.getAttributeValue(attribute)));
    }
    
    /**
     * 预测单个样本
     * @param attributes 属性映射
     * @return 预测结果
     */
    public Object predict(Map<String, Object> attributes) {
        if (root == null) {
            throw new IllegalStateException("决策树尚未训练");
        }
        
        return predictRecursive(root, attributes);
    }
    
    /**
     * 递归预测
     * @param node 当前节点
     * @param attributes 属性映射
     * @return 预测结果
     */
    private Object predictRecursive(TreeNode node, Map<String, Object> attributes) {
        // 如果是叶节点，返回分类或回归值
        if (node.isLeaf()) {
            return node.getClassification() != null ? node.getClassification() : node.getValue();
        }
        
        // 获取当前节点用于分裂的属性
        String splitAttribute = node.getAttribute();
        Object attributeValue = attributes.get(splitAttribute);
        
        // 如果找不到对应属性值的子节点，返回最常见的类别或平均值（简化处理）
        if (attributeValue == null || !node.getChildren().containsKey(attributeValue.toString())) {
            return getDefaultPrediction(node);
        }
        
        // 递归到子节点
        TreeNode child = node.getChildren().get(attributeValue.toString());
        return predictRecursive(child, attributes);
    }
    
    /**
     * 获取默认预测值（当无法找到路径时）
     * @param node 当前节点
     * @return 默认预测值
     */
    private Object getDefaultPrediction(TreeNode node) {
        // 这里简化处理，实际应该根据子节点情况返回最常见的分类或平均值
        // 为了简化，对于分类树返回Unknown，对于回归树返回0
        return isRegression ? 0.0 : "Unknown";
    }
    
    /**
     * 批量预测
     * @param dataSet 测试数据集
     * @return 预测结果列表
     */
    public List<Object> predictAll(List<DataRow> dataSet) {
        return dataSet.stream()
                .map(row -> predict(row.getAllAttributes()))
                .collect(Collectors.toList());
    }
    
    /**
     * 计算分类准确率
     * @param testData 测试数据
     * @return 准确率
     */
    public double calculateAccuracy(List<DataRow> testData) {
        if (isRegression) {
            throw new IllegalStateException("不能对回归树计算准确率，请使用均方误差等指标");
        }
        
        int correctCount = 0;
        for (DataRow row : testData) {
            String prediction = (String) predict(row.getAllAttributes());
            if (prediction.equals(row.getLabel())) {
                correctCount++;
            }
        }
        
        return (double) correctCount / testData.size();
    }
    
    /**
     * 计算均方误差（MSE）
     * @param testData 测试数据
     * @return 均方误差
     */
    public double calculateMSE(List<DataRow> testData) {
        if (!isRegression) {
            throw new IllegalStateException("不能对分类树计算均方误差，请使用准确率等指标");
        }
        
        double sumSquaredErrors = 0.0;
        for (DataRow row : testData) {
            double prediction = (double) predict(row.getAllAttributes());
            double actual = row.getValue();
            sumSquaredErrors += Math.pow(prediction - actual, 2);
        }
        
        return sumSquaredErrors / testData.size();
    }
    
    /**
     * 打印决策树
     */
    public void printTree() {
        if (root == null) {
            System.out.println("决策树为空");
            return;
        }
        
        System.out.println("决策树结构：");
        printTreeRecursive(root, "");
    }
    
    /**
     * 递归打印树结构
     * @param node 当前节点
     * @param prefix 前缀
     */
    private void printTreeRecursive(TreeNode node, String prefix) {
        System.out.println(prefix + node);
        
        if (!node.isLeaf()) {
            for (Map.Entry<String, TreeNode> entry : node.getChildren().entrySet()) {
                String value = entry.getKey();
                TreeNode child = entry.getValue();
                System.out.println(prefix + "  |__ " + node.getAttribute() + " = " + value);
                printTreeRecursive(child, prefix + "      ");
            }
        }
    }
    
    /**
     * 获取树的高度
     * @return 树的高度
     */
    public int getHeight() {
        return calculateHeight(root);
    }
    
    /**
     * 递归计算树高
     * @param node 当前节点
     * @return 树高
     */
    private int calculateHeight(TreeNode node) {
        if (node == null) {
            return 0;
        }
        
        if (node.isLeaf()) {
            return 1;
        }
        
        int maxChildHeight = 0;
        for (TreeNode child : node.getChildren().values()) {
            int childHeight = calculateHeight(child);
            maxChildHeight = Math.max(maxChildHeight, childHeight);
        }
        
        return maxChildHeight + 1;
    }
    
    /**
     * 获取节点数量
     * @return 节点数量
     */
    public int getNodeCount() {
        return countNodes(root);
    }
    
    /**
     * 递归计算节点数量
     * @param node 当前节点
     * @return 节点数量
     */
    private int countNodes(TreeNode node) {
        if (node == null) {
            return 0;
        }
        
        int count = 1;  // 当前节点
        for (TreeNode child : node.getChildren().values()) {
            count += countNodes(child);
        }
        
        return count;
    }
    
    /**
     * 获取叶节点数量
     * @return 叶节点数量
     */
    public int getLeafCount() {
        return countLeaves(root);
    }
    
    /**
     * 递归计算叶节点数量
     * @param node 当前节点
     * @return 叶节点数量
     */
    private int countLeaves(TreeNode node) {
        if (node == null) {
            return 0;
        }
        
        if (node.isLeaf()) {
            return 1;
        }
        
        int leafCount = 0;
        for (TreeNode child : node.getChildren().values()) {
            leafCount += countLeaves(child);
        }
        
        return leafCount;
    }
    
    /**
     * 获取根节点
     * @return 根节点
     */
    public TreeNode getRoot() {
        return root;
    }
    
    /**
     * 层序遍历决策树
     * @return 层序遍历结果
     */
    public List<List<String>> levelOrderTraversal() {
        List<List<String>> result = new ArrayList<>();
        if (root == null) {
            return result;
        }
        
        Queue<TreeNode> queue = new LinkedList<>();
        queue.offer(root);
        
        while (!queue.isEmpty()) {
            int levelSize = queue.size();
            List<String> currentLevel = new ArrayList<>();
            
            for (int i = 0; i < levelSize; i++) {
                TreeNode node = queue.poll();
                currentLevel.add(node.toString());
                
                if (!node.isLeaf()) {
                    for (TreeNode child : node.getChildren().values()) {
                        queue.offer(child);
                    }
                }
            }
            
            result.add(currentLevel);
        }
        
        return result;
    }
    
    /**
     * 主函数，用于测试决策树
     */
    public static void main(String[] args) {
        // 创建示例数据（天气数据集 - 分类问题）
        List<DataRow> weatherData = new ArrayList<>();
        List<String> attributes = Arrays.asList("Outlook", "Temperature", "Humidity", "Windy");
        
        // 添加训练数据
        Map<String, Object> attr1 = new HashMap<>();
        attr1.put("Outlook", "Sunny");
        attr1.put("Temperature", "Hot");
        attr1.put("Humidity", "High");
        attr1.put("Windy", false);
        weatherData.add(new DataRow(attr1, "No"));
        
        Map<String, Object> attr2 = new HashMap<>();
        attr2.put("Outlook", "Sunny");
        attr2.put("Temperature", "Hot");
        attr2.put("Humidity", "High");
        attr2.put("Windy", true);
        weatherData.add(new DataRow(attr2, "No"));
        
        Map<String, Object> attr3 = new HashMap<>();
        attr3.put("Outlook", "Overcast");
        attr3.put("Temperature", "Hot");
        attr3.put("Humidity", "High");
        attr3.put("Windy", false);
        weatherData.add(new DataRow(attr3, "Yes"));
        
        Map<String, Object> attr4 = new HashMap<>();
        attr4.put("Outlook", "Rainy");
        attr4.put("Temperature", "Mild");
        attr4.put("Humidity", "High");
        attr4.put("Windy", false);
        weatherData.add(new DataRow(attr4, "Yes"));
        
        Map<String, Object> attr5 = new HashMap<>();
        attr5.put("Outlook", "Rainy");
        attr5.put("Temperature", "Cool");
        attr5.put("Humidity", "Normal");
        attr5.put("Windy", false);
        weatherData.add(new DataRow(attr5, "Yes"));
        
        Map<String, Object> attr6 = new HashMap<>();
        attr6.put("Outlook", "Rainy");
        attr6.put("Temperature", "Cool");
        attr6.put("Humidity", "Normal");
        attr6.put("Windy", true);
        weatherData.add(new DataRow(attr6, "No"));
        
        Map<String, Object> attr7 = new HashMap<>();
        attr7.put("Outlook", "Overcast");
        attr7.put("Temperature", "Cool");
        attr7.put("Humidity", "Normal");
        attr7.put("Windy", true);
        weatherData.add(new DataRow(attr7, "Yes"));
        
        Map<String, Object> attr8 = new HashMap<>();
        attr8.put("Outlook", "Sunny");
        attr8.put("Temperature", "Mild");
        attr8.put("Humidity", "High");
        attr8.put("Windy", false);
        weatherData.add(new DataRow(attr8, "No"));
        
        Map<String, Object> attr9 = new HashMap<>();
        attr9.put("Outlook", "Sunny");
        attr9.put("Temperature", "Cool");
        attr9.put("Humidity", "Normal");
        attr9.put("Windy", false);
        weatherData.add(new DataRow(attr9, "Yes"));
        
        Map<String, Object> attr10 = new HashMap<>();
        attr10.put("Outlook", "Rainy");
        attr10.put("Temperature", "Mild");
        attr10.put("Humidity", "Normal");
        attr10.put("Windy", false);
        weatherData.add(new DataRow(attr10, "Yes"));
        
        // 训练分类决策树
        DecisionTree classifier = new DecisionTree(10, 2, false);
        classifier.fit(weatherData, attributes);
        
        // 打印决策树
        System.out.println("===== 分类决策树 ======");
        classifier.printTree();
        
        // 测试预测
        Map<String, Object> testAttr = new HashMap<>();
        testAttr.put("Outlook", "Sunny");
        testAttr.put("Temperature", "Mild");
        testAttr.put("Humidity", "Normal");
        testAttr.put("Windy", true);
        
        Object prediction = classifier.predict(testAttr);
        System.out.println("\n测试样本预测结果: " + prediction);
        
        // 模型统计信息
        System.out.println("\n树高: " + classifier.getHeight());
        System.out.println("节点数: " + classifier.getNodeCount());
        System.out.println("叶节点数: " + classifier.getLeafCount());
        
        // 计算训练集准确率
        double accuracy = classifier.calculateAccuracy(weatherData);
        System.out.println("训练集准确率: " + String.format("%.2f%%", accuracy * 100));
        
        // 层序遍历
        System.out.println("\n层序遍历：");
        List<List<String>> levelOrder = classifier.levelOrderTraversal();
        for (int i = 0; i < levelOrder.size(); i++) {
            System.out.println("层 " + (i + 1) + ": " + levelOrder.get(i));
        }
        
        // 创建回归树测试数据
        List<DataRow> regressionData = new ArrayList<>();
        List<String> regressionAttrs = Arrays.asList("Size", "Bedrooms", "Bathrooms", "Age");
        
        // 添加房屋价格预测数据（简化示例）
        Map<String, Object> house1 = new HashMap<>();
        house1.put("Size", 1400);
        house1.put("Bedrooms", 3);
        house1.put("Bathrooms", 2);
        house1.put("Age", 10);
        regressionData.add(new DataRow(house1, 200000.0));
        
        Map<String, Object> house2 = new HashMap<>();
        house2.put("Size", 1600);
        house2.put("Bedrooms", 3);
        house2.put("Bathrooms", 2.5);
        house2.put("Age", 5);
        regressionData.add(new DataRow(house2, 250000.0));
        
        Map<String, Object> house3 = new HashMap<>();
        house3.put("Size", 2000);
        house3.put("Bedrooms", 4);
        house3.put("Bathrooms", 3);
        house3.put("Age", 2);
        regressionData.add(new DataRow(house3, 350000.0));
        
        Map<String, Object> house4 = new HashMap<>();
        house4.put("Size", 1200);
        house4.put("Bedrooms", 2);
        house4.put("Bathrooms", 1);
        house4.put("Age", 20);
        regressionData.add(new DataRow(house4, 150000.0));
        
        // 训练回归决策树
        DecisionTree regressor = new DecisionTree(5, 2, true);
        regressor.fit(regressionData, regressionAttrs);
        
        // 打印回归树
        System.out.println("\n===== 回归决策树 ======");
        regressor.printTree();
        
        // 测试预测
        Map<String, Object> testHouse = new HashMap<>();
        testHouse.put("Size", 1800);
        testHouse.put("Bedrooms", 3);
        testHouse.put("Bathrooms", 2);
        testHouse.put("Age", 8);
        
        Object pricePrediction = regressor.predict(testHouse);
        System.out.println("\n测试房屋价格预测: $" + pricePrediction);
        
        // 计算均方误差
        double mse = regressor.calculateMSE(regressionData);
        System.out.println("均方误差: " + String.format("%.2f", mse));
    }
}

===============================================

文件: decision_tree.cpp
===============================================
#include <iostream>
#include <vector>
#include <string>
#include <map>
#include <unordered_map>
#include <queue>
#include <cmath>
#include <algorithm>
#include <memory>
#include <stdexcept>
#include <iomanip>
#include <sstream>

/**
 * 决策树（Decision Tree）实现
 * 决策树是一种用于分类和回归的监督学习算法
 * 它通过从数据特征中学习决策规则，构建树状模型进行预测
 * 
 * 常见应用场景：
 * 1. 分类问题（如疾病诊断、客户流失预测）
 * 2. 回归问题（如房价预测、销售量预测）
 * 3. 特征重要性分析
 * 4. 规则提取（从树结构中提取业务规则）
 * 5. 数据分析和数据挖掘
 * 6. 风险评估和信用评分
 * 
 * 相关算法题目：
 * - LeetCode 222. 完全二叉树的节点个数 https://leetcode.cn/problems/count-complete-tree-nodes/
 * - LeetCode 637. 二叉树的层平均值 https://leetcode.cn/problems/average-of-levels-in-binary-tree/
 * - LeetCode 572. 另一棵树的子树 https://leetcode.cn/problems/subtree-of-another-tree/
 * - LintCode 95. 验证二叉查找树 https://www.lintcode.com/problem/95/
 * - 洛谷 P3379 【模板】最近公共祖先 https://www.luogu.com.cn/problem/P3379
 * - 牛客 NC119 最小的K个数 https://www.nowcoder.com/practice/6a296eb82cf844ca8539b57c23e6e9bf
 * - HackerRank Tree: Huffman Decoding https://www.hackerrank.com/challenges/tree-huffman-decoding/problem
 * - CodeChef DECMTREE https://www.codechef.com/problems/DECMTREE
 * - USACO Section 3.4 Raucous Rockers https://usaco.org/index.php?page=viewproblem2&cpid=348
 * - AtCoder ABC177 F - I hate Shortest Path Problem https://atcoder.jp/contests/abc177/tasks/abc177_f
 * - 杭电 OJ 2544 最短路 https://acm.hdu.edu.cn/showproblem.php?pid=2544
 * - SPOJ PT07Z - Longest path in a tree https://www.spoj.com/problems/PT07Z/
 * - Codeforces 1327C - Game with Chips https://codeforces.com/problemset/problem/1327/C
 */

// 前向声明
class TreeNode;
class DataRow;

// 用于存储属性值的变体类型
class AttributeValue {
private:
    std::string stringValue;
    double doubleValue;
    bool isDouble;

public:
    AttributeValue(const std::string& value) : stringValue(value), isDouble(false) {}
    AttributeValue(double value) : doubleValue(value), isDouble(true) {}
    
    bool isDoubleType() const { return isDouble; }
    std::string getStringValue() const { return stringValue; }
    double getDoubleValue() const { return doubleValue; }
    
    std::string toString() const {
        if (isDouble) {
            std::stringstream ss;
            ss << doubleValue;
            return ss.str();
        }
        return stringValue;
    }
    
    bool operator==(const AttributeValue& other) const {
        if (isDouble != other.isDouble) return false;
        if (isDouble) {
            return std::abs(doubleValue - other.doubleValue) < 1e-9;
        } else {
            return stringValue == other.stringValue;
        }
    }
};

// 为AttributeValue定义哈希函数，使其可以用作unordered_map的键
namespace std {
    template<>
    struct hash<AttributeValue> {
        size_t operator()(const AttributeValue& val) const {
            if (val.isDoubleType()) {
                // 对double值进行哈希处理
                double d = val.getDoubleValue();
                return hash<double>()(d);
            } else {
                return hash<string>()(val.getStringValue());
            }
        }
    };
}

// 决策树节点类
class TreeNode {
private:
    bool isLeafNode;
    std::string attribute;
    std::unordered_map<std::string, std::shared_ptr<TreeNode>> children;
    std::string classification;
    double value;
    double informationGain;
    int depth;

public:
    // 构造内部节点（用于属性分裂）
    TreeNode(const std::string& attr, double gain, int nodeDepth)
        : isLeafNode(false), attribute(attr), classification(""), value(0.0),
          informationGain(gain), depth(nodeDepth) {}
    
    // 构造叶节点（分类树）
    TreeNode(const std::string& cls, int nodeDepth)
        : isLeafNode(true), attribute(""), classification(cls), value(0.0),
          informationGain(0.0), depth(nodeDepth) {}
    
    // 构造叶节点（回归树）
    TreeNode(double val, int nodeDepth)
        : isLeafNode(true), attribute(""), classification(""), value(val),
          informationGain(0.0), depth(nodeDepth) {}
    
    // Getter方法
    bool isLeaf() const { return isLeafNode; }
    const std::string& getAttribute() const { return attribute; }
    const std::unordered_map<std::string, std::shared_ptr<TreeNode>>& getChildren() const { return children; }
    const std::string& getClassification() const { return classification; }
    double getValue() const { return value; }
    double getInformationGain() const { return informationGain; }
    int getDepth() const { return depth; }
    
    // 添加子节点
    void addChild(const std::string& attributeValue, std::shared_ptr<TreeNode> child) {
        children[attributeValue] = child;
    }
    
    // 字符串表示
    std::string toString() const {
        std::stringstream ss;
        if (isLeafNode) {
            if (!classification.empty()) {
                ss << "叶节点(分类=" << classification << ", 深度=" << depth << ")";
            } else {
                ss << "叶节点(值=" << std::fixed << std::setprecision(4) << value 
                   << ", 深度=" << depth << ")";
            }
        } else {
            ss << "内部节点(属性=" << attribute 
               << ", 信息增益=" << std::fixed << std::setprecision(4) << informationGain 
               << ", 深度=" << depth << ")";
        }
        return ss.str();
    }
};

// 数据集行类
class DataRow {
private:
    std::unordered_map<std::string, AttributeValue> attributes;
    std::string label;
    double value;
    bool isRegressionRow;

public:
    // 构造分类数据行
    DataRow(const std::unordered_map<std::string, AttributeValue>& attrs, const std::string& rowLabel)
        : attributes(attrs), label(rowLabel), value(0.0), isRegressionRow(false) {}
    
    // 构造回归数据行
    DataRow(const std::unordered_map<std::string, AttributeValue>& attrs, double rowValue)
        : attributes(attrs), label(""), value(rowValue), isRegressionRow(true) {}
    
    // 获取属性值
    const AttributeValue* getAttributeValue(const std::string& attribute) const {
        auto it = attributes.find(attribute);
        if (it != attributes.end()) {
            return &(it->second);
        }
        return nullptr;
    }
    
    // 获取所有属性
    const std::unordered_map<std::string, AttributeValue>& getAllAttributes() const {
        return attributes;
    }
    
    // 获取分类标签
    const std::string& getLabel() const {
        return label;
    }
    
    // 获取回归目标值
    double getValue() const {
        return value;
    }
    
    // 判断是否为分类数据
    bool isClassification() const {
        return !isRegressionRow;
    }
    
    // 字符串表示
    std::string toString() const {
        std::stringstream ss;
        ss << "DataRow{attributes={";
        bool first = true;
        for (const auto& attr : attributes) {
            if (!first) ss << ", ";
            ss << attr.first << "=" << attr.second.toString();
            first = false;
        }
        ss << "}, ";
        
        if (isClassification()) {
            ss << "label='" << label << "'";
        } else {
            ss << "value=" << value;
        }
        ss << "}";
        return ss.str();
    }
};

// 决策树类
class DecisionTree {
private:
    std::shared_ptr<TreeNode> root;
    std::vector<std::string> attributes;
    int maxDepth;
    int minSamplesSplit;
    bool isRegression;

    // 判断是否应该停止树的生长
    bool shouldStop(const std::vector<DataRow>& dataSet, 
                   const std::vector<std::string>& availableAttributes, 
                   int depth) const {
        // 1. 数据集为空
        if (dataSet.empty()) {
            return true;
        }
        
        // 2. 达到最大深度
        if (depth >= maxDepth) {
            return true;
        }
        
        // 3. 没有可用属性
        if (availableAttributes.empty()) {
            return true;
        }
        
        // 4. 样本数小于最小分裂样本数
        if (dataSet.size() < minSamplesSplit) {
            return true;
        }
        
        // 5. 所有样本属于同一类别（分类树）
        if (!isRegression) {
            const std::string& firstLabel = dataSet[0].getLabel();
            bool allSame = true;
            for (const auto& row : dataSet) {
                if (row.getLabel() != firstLabel) {
                    allSame = false;
                    break;
                }
            }
            if (allSame) {
                return true;
            }
        }
        // 5. 所有样本的目标值相同（回归树）
        else {
            double firstValue = dataSet[0].getValue();
            bool allSame = true;
            for (const auto& row : dataSet) {
                if (std::abs(row.getValue() - firstValue) >= 1e-9) {
                    allSame = false;
                    break;
                }
            }
            if (allSame) {
                return true;
            }
        }
        
        return false;
    }
    
    // 创建叶节点
    std::shared_ptr<TreeNode> createLeafNode(const std::vector<DataRow>& dataSet, int depth) const {
        if (dataSet.empty()) {
            return isRegression ? 
                   std::make_shared<TreeNode>(0.0, depth) : 
                   std::make_shared<TreeNode>("Unknown", depth);
        }
        
        if (!isRegression) {
            // 分类树：返回最常见的类别
            std::map<std::string, int> labelCounts;
            for (const auto& row : dataSet) {
                labelCounts[row.getLabel()]++;
            }
            
            std::string mostCommonLabel = "Unknown";
            int maxCount = 0;
            for (const auto& pair : labelCounts) {
                if (pair.second > maxCount) {
                    maxCount = pair.second;
                    mostCommonLabel = pair.first;
                }
            }
            
            return std::make_shared<TreeNode>(mostCommonLabel, depth);
        } else {
            // 回归树：返回平均值
            double sum = 0.0;
            for (const auto& row : dataSet) {
                sum += row.getValue();
            }
            double average = sum / dataSet.size();
            
            return std::make_shared<TreeNode>(average, depth);
        }
    }
    
    // 根据属性值分割数据集
    std::map<std::string, std::vector<DataRow>> partitionByAttribute(
            const std::vector<DataRow>& dataSet, const std::string& attribute) const {
        std::map<std::string, std::vector<DataRow>> partitions;
        
        for (const auto& row : dataSet) {
            const AttributeValue* value = row.getAttributeValue(attribute);
            if (value) {
                partitions[value->toString()].push_back(row);
            }
        }
        
        return partitions;
    }
    
    // 计算数据集的熵
    double calculateEntropy(const std::vector<DataRow>& dataSet) const {
        if (dataSet.empty()) {
            return 0.0;
        }
        
        std::map<std::string, int> labelCounts;
        for (const auto& row : dataSet) {
            labelCounts[row.getLabel()]++;
        }
        
        double entropy = 0.0;
        double total = dataSet.size();
        
        for (const auto& pair : labelCounts) {
            double probability = pair.second / total;
            entropy -= probability * std::log2(probability);
        }
        
        return entropy;
    }
    
    // 计算数据集的方差
    double calculateVariance(const std::vector<DataRow>& dataSet) const {
        if (dataSet.empty()) {
            return 0.0;
        }
        
        double sum = 0.0;
        for (const auto& row : dataSet) {
            sum += row.getValue();
        }
        double mean = sum / dataSet.size();
        
        double variance = 0.0;
        for (const auto& row : dataSet) {
            double diff = row.getValue() - mean;
            variance += diff * diff;
        }
        variance /= dataSet.size();
        
        return variance;
    }
    
    // 计算信息增益（分类树）或方差减少（回归树）
    double calculateGain(const std::vector<DataRow>& dataSet, const std::string& attribute) const {
        if (dataSet.empty()) {
            return 0.0;
        }
        
        if (!isRegression) {
            // 计算信息增益（使用熵）
            double parentEntropy = calculateEntropy(dataSet);
            auto partitions = partitionByAttribute(dataSet, attribute);
            
            double weightedEntropy = 0.0;
            for (const auto& pair : partitions) {
                const auto& subset = pair.second;
                double weight = static_cast<double>(subset.size()) / dataSet.size();
                weightedEntropy += weight * calculateEntropy(subset);
            }
            
            return parentEntropy - weightedEntropy;
        } else {
            // 计算方差减少
            double parentVariance = calculateVariance(dataSet);
            auto partitions = partitionByAttribute(dataSet, attribute);
            
            double weightedVariance = 0.0;
            for (const auto& pair : partitions) {
                const auto& subset = pair.second;
                double weight = static_cast<double>(subset.size()) / dataSet.size();
                weightedVariance += weight * calculateVariance(subset);
            }
            
            return parentVariance - weightedVariance;
        }
    }
    
    // 选择最佳分裂属性
    std::string selectBestAttribute(const std::vector<DataRow>& dataSet, 
                                   const std::vector<std::string>& availableAttributes, 
                                   double& bestGain) const {
        std::string bestAttribute;
        bestGain = -std::numeric_limits<double>::max();
        
        for (const auto& attribute : availableAttributes) {
            double gain = calculateGain(dataSet, attribute);
            if (gain > bestGain) {
                bestGain = gain;
                bestAttribute = attribute;
            }
        }
        
        return bestAttribute;
    }
    
    // 递归构建决策树
    std::shared_ptr<TreeNode> buildTree(const std::vector<DataRow>& dataSet,
                                       std::vector<std::string> availableAttributes,
                                       int depth) {
        // 检查是否满足终止条件
        if (shouldStop(dataSet, availableAttributes, depth)) {
            return createLeafNode(dataSet, depth);
        }
        
        // 选择最佳分裂属性
        double bestGain;
        std::string bestAttribute = selectBestAttribute(dataSet, availableAttributes, bestGain);
        
        // 创建内部节点
        auto node = std::make_shared<TreeNode>(bestAttribute, bestGain, depth);
        
        // 根据最佳属性的值分割数据集
        auto partitions = partitionByAttribute(dataSet, bestAttribute);
        
        // 为每个属性值创建子树
        for (const auto& pair : partitions) {
            const auto& value = pair.first;
            const auto& subset = pair.second;
            
            // 如果子集为空，创建叶节点
            if (subset.empty()) {
                node->addChild(value, createLeafNode(dataSet, depth + 1));
            } else {
                // 递归构建子树
                std::vector<std::string> newAttributes;
                for (const auto& attr : availableAttributes) {
                    if (attr != bestAttribute) {
                        newAttributes.push_back(attr);
                    }
                }
                auto childNode = buildTree(subset, newAttributes, depth + 1);
                node->addChild(value, childNode);
            }
        }
        
        return node;
    }
    
    // 递归预测
    std::pair<std::string, double> predictRecursive(
            const std::shared_ptr<TreeNode>& node, 
            const std::unordered_map<std::string, AttributeValue>& attributes) const {
        // 如果是叶节点，返回分类或回归值
        if (node->isLeaf()) {
            if (!node->getClassification().empty()) {
                return {node->getClassification(), 0.0};
            } else {
                return {"", node->getValue()};
            }
        }
        
        // 获取当前节点用于分裂的属性
        const std::string& splitAttribute = node->getAttribute();
        auto it = attributes.find(splitAttribute);
        
        // 如果找不到对应属性值的子节点，返回默认预测值
        if (it == attributes.end()) {
            return getDefaultPrediction(node);
        }
        
        // 查找对应的子节点
        const auto& children = node->getChildren();
        auto childIt = children.find(it->second.toString());
        
        // 如果找不到子节点，返回默认预测值
        if (childIt == children.end()) {
            return getDefaultPrediction(node);
        }
        
        // 递归到子节点
        return predictRecursive(childIt->second, attributes);
    }
    
    // 获取默认预测值（当无法找到路径时）
    std::pair<std::string, double> getDefaultPrediction(
            const std::shared_ptr<TreeNode>& node) const {
        // 这里简化处理，实际应该根据子节点情况返回最常见的分类或平均值
        return isRegression ? std::make_pair("", 0.0) : std::make_pair("Unknown", 0.0);
    }
    
    // 递归打印树结构
    void printTreeRecursive(const std::shared_ptr<TreeNode>& node, const std::string& prefix) const {
        std::cout << prefix << node->toString() << std::endl;
        
        if (!node->isLeaf()) {
            const auto& children = node->getChildren();
            for (const auto& pair : children) {
                std::cout << prefix << "  |__ " << node->getAttribute() << " = " << pair.first << std::endl;
                printTreeRecursive(pair.second, prefix + "      ");
            }
        }
    }
    
    // 递归计算树高
    int calculateHeight(const std::shared_ptr<TreeNode>& node) const {
        if (!node) {
            return 0;
        }
        
        if (node->isLeaf()) {
            return 1;
        }
        
        int maxChildHeight = 0;
        const auto& children = node->getChildren();
        for (const auto& pair : children) {
            int childHeight = calculateHeight(pair.second);
            maxChildHeight = std::max(maxChildHeight, childHeight);
        }
        
        return maxChildHeight + 1;
    }
    
    // 递归计算节点数量
    int countNodes(const std::shared_ptr<TreeNode>& node) const {
        if (!node) {
            return 0;
        }
        
        int count = 1;  // 当前节点
        const auto& children = node->getChildren();
        for (const auto& pair : children) {
            count += countNodes(pair.second);
        }
        
        return count;
    }
    
    // 递归计算叶节点数量
    int countLeaves(const std::shared_ptr<TreeNode>& node) const {
        if (!node) {
            return 0;
        }
        
        if (node->isLeaf()) {
            return 1;
        }
        
        int leafCount = 0;
        const auto& children = node->getChildren();
        for (const auto& pair : children) {
            leafCount += countLeaves(pair.second);
        }
        
        return leafCount;
    }

public:
    // 构造函数
    DecisionTree(int maxDepth = 10, int minSamplesSplit = 2, bool isRegression = false)
        : maxDepth(maxDepth), minSamplesSplit(minSamplesSplit), 
          isRegression(isRegression), root(nullptr) {}
    
    // 训练决策树
    void fit(const std::vector<DataRow>& dataSet, const std::vector<std::string>& attrs) {
        attributes = attrs;
        root = buildTree(dataSet, attrs, 0);
    }
    
    // 预测单个样本
    std::string predictClassification(const std::unordered_map<std::string, AttributeValue>& attrs) const {
        if (!root) {
            throw std::runtime_error("决策树尚未训练");
        }
        
        if (isRegression) {
            throw std::runtime_error("这是回归树，请使用predictRegression方法");
        }
        
        auto result = predictRecursive(root, attrs);
        return result.first;
    }
    
    // 回归预测
    double predictRegression(const std::unordered_map<std::string, AttributeValue>& attrs) const {
        if (!root) {
            throw std::runtime_error("决策树尚未训练");
        }
        
        if (!isRegression) {
            throw std::runtime_error("这是分类树，请使用predictClassification方法");
        }
        
        auto result = predictRecursive(root, attrs);
        return result.second;
    }
    
    // 批量预测分类
    std::vector<std::string> predictAllClassification(const std::vector<DataRow>& dataSet) const {
        std::vector<std::string> predictions;
        for (const auto& row : dataSet) {
            predictions.push_back(predictClassification(row.getAllAttributes()));
        }
        return predictions;
    }
    
    // 批量预测回归
    std::vector<double> predictAllRegression(const std::vector<DataRow>& dataSet) const {
        std::vector<double> predictions;
        for (const auto& row : dataSet) {
            predictions.push_back(predictRegression(row.getAllAttributes()));
        }
        return predictions;
    }
    
    // 计算分类准确率
    double calculateAccuracy(const std::vector<DataRow>& testData) const {
        if (isRegression) {
            throw std::runtime_error("不能对回归树计算准确率，请使用均方误差等指标");
        }
        
        int correctCount = 0;
        for (const auto& row : testData) {
            std::string prediction = predictClassification(row.getAllAttributes());
            if (prediction == row.getLabel()) {
                correctCount++;
            }
        }
        
        return static_cast<double>(correctCount) / testData.size();
    }
    
    // 计算均方误差（MSE）
    double calculateMSE(const std::vector<DataRow>& testData) const {
        if (!isRegression) {
            throw std::runtime_error("不能对分类树计算均方误差，请使用准确率等指标");
        }
        
        double sumSquaredErrors = 0.0;
        for (const auto& row : testData) {
            double prediction = predictRegression(row.getAllAttributes());
            double actual = row.getValue();
            double error = prediction - actual;
            sumSquaredErrors += error * error;
        }
        
        return sumSquaredErrors / testData.size();
    }
    
    // 打印决策树
    void printTree() const {
        if (!root) {
            std::cout << "决策树为空" << std::endl;
            return;
        }
        
        std::cout << "决策树结构：" << std::endl;
        printTreeRecursive(root, "");
    }
    
    // 获取树的高度
    int getHeight() const {
        return calculateHeight(root);
    }
    
    // 获取节点数量
    int getNodeCount() const {
        return countNodes(root);
    }
    
    // 获取叶节点数量
    int getLeafCount() const {
        return countLeaves(root);
    }
    
    // 获取根节点
    std::shared_ptr<TreeNode> getRoot() const {
        return root;
    }
    
    // 层序遍历决策树
    std::vector<std::vector<std::string>> levelOrderTraversal() const {
        std::vector<std::vector<std::string>> result;
        if (!root) {
            return result;
        }
        
        std::queue<std::shared_ptr<TreeNode>> queue;
        queue.push(root);
        
        while (!queue.empty()) {
            int levelSize = queue.size();
            std::vector<std::string> currentLevel;
            
            for (int i = 0; i < levelSize; i++) {
                auto node = queue.front();
                queue.pop();
                currentLevel.push_back(node->toString());
                
                if (!node->isLeaf()) {
                    const auto& children = node->getChildren();
                    for (const auto& pair : children) {
                        queue.push(pair.second);
                    }
                }
            }
            
            result.push_back(currentLevel);
        }
        
        return result;
    }
};

// 主函数，用于测试决策树
int main() {
    // 创建示例数据（天气数据集 - 分类问题）
    std::vector<DataRow> weatherData;
    std::vector<std::string> attributes = {"Outlook", "Temperature", "Humidity", "Windy"};
    
    // 添加训练数据
    std::unordered_map<std::string, AttributeValue> attr1;
    attr1["Outlook"] = AttributeValue("Sunny");
    attr1["Temperature"] = AttributeValue("Hot");
    attr1["Humidity"] = AttributeValue("High");
    attr1["Windy"] = AttributeValue(false);
    weatherData.emplace_back(attr1, "No");
    
    std::unordered_map<std::string, AttributeValue> attr2;
    attr2["Outlook"] = AttributeValue("Sunny");
    attr2["Temperature"] = AttributeValue("Hot");
    attr2["Humidity"] = AttributeValue("High");
    attr2["Windy"] = AttributeValue(true);
    weatherData.emplace_back(attr2, "No");
    
    std::unordered_map<std::string, AttributeValue> attr3;
    attr3["Outlook"] = AttributeValue("Overcast");
    attr3["Temperature"] = AttributeValue("Hot");
    attr3["Humidity"] = AttributeValue("High");
    attr3["Windy"] = AttributeValue(false);
    weatherData.emplace_back(attr3, "Yes");
    
    std::unordered_map<std::string, AttributeValue> attr4;
    attr4["Outlook"] = AttributeValue("Rainy");
    attr4["Temperature"] = AttributeValue("Mild");
    attr4["Humidity"] = AttributeValue("High");
    attr4["Windy"] = AttributeValue(false);
    weatherData.emplace_back(attr4, "Yes");
    
    std::unordered_map<std::string, AttributeValue> attr5;
    attr5["Outlook"] = AttributeValue("Rainy");
    attr5["Temperature"] = AttributeValue("Cool");
    attr5["Humidity"] = AttributeValue("Normal");
    attr5["Windy"] = AttributeValue(false);
    weatherData.emplace_back(attr5, "Yes");
    
    std::unordered_map<std::string, AttributeValue> attr6;
    attr6["Outlook"] = AttributeValue("Rainy");
    attr6["Temperature"] = AttributeValue("Cool");
    attr6["Humidity"] = AttributeValue("Normal");
    attr6["Windy"] = AttributeValue(true);
    weatherData.emplace_back(attr6, "No");
    
    std::unordered_map<std::string, AttributeValue> attr7;
    attr7["Outlook"] = AttributeValue("Overcast");
    attr7["Temperature"] = AttributeValue("Cool");
    attr7["Humidity"] = AttributeValue("Normal");
    attr7["Windy"] = AttributeValue(true);
    weatherData.emplace_back(attr7, "Yes");
    
    std::unordered_map<std::string, AttributeValue> attr8;
    attr8["Outlook"] = AttributeValue("Sunny");
    attr8["Temperature"] = AttributeValue("Mild");
    attr8["Humidity"] = AttributeValue("High");
    attr8["Windy"] = AttributeValue(false);
    weatherData.emplace_back(attr8, "No");
    
    std::unordered_map<std::string, AttributeValue> attr9;
    attr9["Outlook"] = AttributeValue("Sunny");
    attr9["Temperature"] = AttributeValue("Cool");
    attr9["Humidity"] = AttributeValue("Normal");
    attr9["Windy"] = AttributeValue(false);
    weatherData.emplace_back(attr9, "Yes");
    
    std::unordered_map<std::string, AttributeValue> attr10;
    attr10["Outlook"] = AttributeValue("Rainy");
    attr10["Temperature"] = AttributeValue("Mild");
    attr10["Humidity"] = AttributeValue("Normal");
    attr10["Windy"] = AttributeValue(false);
    weatherData.emplace_back(attr10, "Yes");
    
    // 训练分类决策树
    DecisionTree classifier(10, 2, false);
    classifier.fit(weatherData, attributes);
    
    // 打印决策树
    std::cout << "===== 分类决策树 ======\n" << std::endl;
    classifier.printTree();
    
    // 测试预测
    std::unordered_map<std::string, AttributeValue> testAttr;
    testAttr["Outlook"] = AttributeValue("Sunny");
    testAttr["Temperature"] = AttributeValue("Mild");
    testAttr["Humidity"] = AttributeValue("Normal");
    testAttr["Windy"] = AttributeValue(true);
    
    try {
        std::string prediction = classifier.predictClassification(testAttr);
        std::cout << "\n测试样本预测结果: " << prediction << std::endl;
    } catch (const std::exception& e) {
        std::cerr << "预测错误: " << e.what() << std::endl;
    }
    
    // 模型统计信息
    std::cout << "\n树高: " << classifier.getHeight() << std::endl;
    std::cout << "节点数: " << classifier.getNodeCount() << std::endl;
    std::cout << "叶节点数: " << classifier.getLeafCount() << std::endl;
    
    // 计算训练集准确率
    try {
        double accuracy = classifier.calculateAccuracy(weatherData);
        std::cout << "训练集准确率: " << std::fixed << std::setprecision(2) << accuracy * 100 << "%" << std::endl;
    } catch (const std::exception& e) {
        std::cerr << "计算准确率错误: " << e.what() << std::endl;
    }
    
    // 层序遍历
    std::cout << "\n层序遍历：" << std::endl;
    auto levelOrder = classifier.levelOrderTraversal();
    for (int i = 0; i < levelOrder.size(); i++) {
        std::cout << "层 " << (i + 1) << ": ";
        for (const auto& node : levelOrder[i]) {
            std::cout << node << "; ";
        }
        std::cout << std::endl;
    }
    
    // 创建回归树测试数据
    std::vector<DataRow> regressionData;
    std::vector<std::string> regressionAttrs = {"Size", "Bedrooms", "Bathrooms", "Age"};
    
    // 添加房屋价格预测数据（简化示例）
    std::unordered_map<std::string, AttributeValue> house1;
    house1["Size"] = AttributeValue(1400.0);
    house1["Bedrooms"] = AttributeValue(3.0);
    house1["Bathrooms"] = AttributeValue(2.0);
    house1["Age"] = AttributeValue(10.0);
    regressionData.emplace_back(house1, 200000.0);
    
    std::unordered_map<std::string, AttributeValue> house2;
    house2["Size"] = AttributeValue(1600.0);
    house2["Bedrooms"] = AttributeValue(3.0);
    house2["Bathrooms"] = AttributeValue(2.5);
    house2["Age"] = AttributeValue(5.0);
    regressionData.emplace_back(house2, 250000.0);
    
    std::unordered_map<std::string, AttributeValue> house3;
    house3["Size"] = AttributeValue(2000.0);
    house3["Bedrooms"] = AttributeValue(4.0);
    house3["Bathrooms"] = AttributeValue(3.0);
    house3["Age"] = AttributeValue(2.0);
    regressionData.emplace_back(house3, 350000.0);
    
    std::unordered_map<std::string, AttributeValue> house4;
    house4["Size"] = AttributeValue(1200.0);
    house4["Bedrooms"] = AttributeValue(2.0);
    house4["Bathrooms"] = AttributeValue(1.0);
    house4["Age"] = AttributeValue(20.0);
    regressionData.emplace_back(house4, 150000.0);
    
    // 训练回归决策树
    DecisionTree regressor(5, 2, true);
    regressor.fit(regressionData, regressionAttrs);
    
    // 打印回归树
    std::cout << "\n===== 回归决策树 ======\n" << std::endl;
    regressor.printTree();
    
    // 测试预测
    std::unordered_map<std::string, AttributeValue> testHouse;
    testHouse["Size"] = AttributeValue(1800.0);
    testHouse["Bedrooms"] = AttributeValue(3.0);
    testHouse["Bathrooms"] = AttributeValue(2.0);
    testHouse["Age"] = AttributeValue(8.0);
    
    try {
        double pricePrediction = regressor.predictRegression(testHouse);
        std::cout << "\n测试房屋价格预测: $" << std::fixed << std::setprecision(2) << pricePrediction << std::endl;
    } catch (const std::exception& e) {
        std::cerr << "预测错误: " << e.what() << std::endl;
    }
    
    // 计算均方误差
    try {
        double mse = regressor.calculateMSE(regressionData);
        std::cout << "均方误差: " << std::fixed << std::setprecision(2) << mse << std::endl;
    } catch (const std::exception& e) {
        std::cerr << "计算均方误差错误: " << e.what() << std::endl;
    }
    
    return 0;
}

===============================================

文件: decision_tree.py
===============================================
#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
决策树（Decision Tree）实现
决策树是一种用于分类和回归的监督学习算法
它通过从数据特征中学习决策规则，构建树状模型进行预测

常见应用场景：
1. 分类问题（如疾病诊断、客户流失预测）
2. 回归问题（如房价预测、销售量预测）
3. 特征重要性分析
4. 规则提取（从树结构中提取业务规则）
5. 数据分析和数据挖掘
6. 风险评估和信用评分

相关算法题目：
- LeetCode 222. 完全二叉树的节点个数 https://leetcode.cn/problems/count-complete-tree-nodes/
- LeetCode 637. 二叉树的层平均值 https://leetcode.cn/problems/average-of-levels-in-binary-tree/
- LeetCode 572. 另一棵树的子树 https://leetcode.cn/problems/subtree-of-another-tree/
- LintCode 95. 验证二叉查找树 https://www.lintcode.com/problem/95/
- 洛谷 P3379 【模板】最近公共祖先 https://www.luogu.com.cn/problem/P3379
- 牛客 NC119 最小的K个数 https://www.nowcoder.com/practice/6a296eb82cf844ca8539b57c23e6e9bf
- HackerRank Tree: Huffman Decoding https://www.hackerrank.com/challenges/tree-huffman-decoding/problem
- CodeChef DECMTREE https://www.codechef.com/problems/DECMTREE
- USACO Section 3.4 Raucous Rockers https://usaco.org/index.php?page=viewproblem2&cpid=348
- AtCoder ABC177 F - I hate Shortest Path Problem https://atcoder.jp/contests/abc177/tasks/abc177_f
- 杭电 OJ 2544 最短路 https://acm.hdu.edu.cn/showproblem.php?pid=2544
- SPOJ PT07Z - Longest path in a tree https://www.spoj.com/problems/PT07Z/
- Codeforces 1327C - Game with Chips https://codeforces.com/problemset/problem/1327/C
"""

from typing import Dict, List, Optional, Any, Union, Tuple
import math
from collections import Counter, deque


class TreeNode:
    """决策树节点类"""
    
    def __init__(self, attribute: Optional[str] = None, 
                 information_gain: float = 0.0,
                 classification: Optional[str] = None,
                 value: Optional[float] = None,
                 depth: int = 0):
        """初始化节点
        
        Args:
            attribute: 用于分裂的属性
            information_gain: 分裂时的信息增益
            classification: 叶节点的分类结果
            value: 回归树的预测值
            depth: 节点深度
        """
        self.attribute = attribute  # 用于分裂的属性
        self.information_gain = information_gain  # 信息增益
        self.classification = classification  # 分类结果（叶节点）
        self.value = value  # 回归值（叶节点）
        self.depth = depth  # 节点深度
        self.children = {}  # 子节点映射 {属性值: 子节点}
    
    @property
    def is_leaf(self) -> bool:
        """判断是否为叶节点
        
        Returns:
            是否为叶节点
        """
        return self.classification is not None or self.value is not None
    
    def add_child(self, attribute_value: Any, child: 'TreeNode') -> None:
        """添加子节点
        
        Args:
            attribute_value: 属性值
            child: 子节点
        """
        self.children[str(attribute_value)] = child
    
    def __str__(self) -> str:
        """字符串表示
        
        Returns:
            节点的字符串表示
        """
        if self.is_leaf:
            if self.classification is not None:
                return f"叶节点(分类={self.classification}, 深度={self.depth})"
            else:
                return f"叶节点(值={self.value:.4f}, 深度={self.depth})"
        else:
            return f"内部节点(属性={self.attribute}, 信息增益={self.information_gain:.4f}, 深度={self.depth})"


class DataRow:
    """数据集行类，用于表示数据集中的一行数据"""
    
    def __init__(self, attributes: Dict[str, Any], 
                 label: Optional[str] = None,
                 value: Optional[float] = None):
        """初始化数据行
        
        Args:
            attributes: 属性及其值的映射
            label: 分类标签
            value: 回归目标值
        """
        self.attributes = attributes.copy()
        self.label = label
        self.value = value
    
    def get_attribute_value(self, attribute: str) -> Any:
        """获取属性值
        
        Args:
            attribute: 属性名
            
        Returns:
            属性值
        """
        return self.attributes.get(attribute)
    
    def get_all_attributes(self) -> Dict[str, Any]:
        """获取所有属性
        
        Returns:
            属性映射
        """
        return self.attributes.copy()
    
    def is_classification(self) -> bool:
        """判断是否为分类数据
        
        Returns:
            是否为分类数据
        """
        return self.label is not None
    
    def __str__(self) -> str:
        """字符串表示
        
        Returns:
            数据行的字符串表示
        """
        if self.is_classification():
            return f"DataRow(attributes={self.attributes}, label='{self.label}')"
        else:
            return f"DataRow(attributes={self.attributes}, value={self.value})"


class DecisionTree:
    """决策树类"""
    
    def __init__(self, max_depth: int = 10, 
                 min_samples_split: int = 2,
                 is_regression: bool = False):
        """构造函数
        
        Args:
            max_depth: 最大深度
            min_samples_split: 最小分裂样本数
            is_regression: 是否为回归树
        """
        self.max_depth = max_depth
        self.min_samples_split = min_samples_split
        self.is_regression = is_regression
        self.root = None
        self.attributes = None
    
    def fit(self, data_set: List[DataRow], attributes: List[str]) -> None:
        """训练决策树
        
        Args:
            data_set: 数据集
            attributes: 属性列表
        """
        self.attributes = attributes.copy()
        self.root = self._build_tree(data_set, attributes.copy(), 0)
    
    def _build_tree(self, data_set: List[DataRow], 
                   available_attributes: List[str],
                   depth: int) -> TreeNode:
        """递归构建决策树
        
        Args:
            data_set: 当前数据集
            available_attributes: 可用属性列表
            depth: 当前深度
            
        Returns:
            构建的节点
        """
        # 检查是否满足终止条件
        if self._should_stop(data_set, available_attributes, depth):
            return self._create_leaf_node(data_set, depth)
        
        # 选择最佳分裂属性
        best_attribute, best_gain = self._select_best_attribute(
            data_set, available_attributes)
        
        # 创建内部节点
        node = TreeNode(
            attribute=best_attribute,
            information_gain=best_gain,
            depth=depth
        )
        
        # 根据最佳属性的值分割数据集
        partitions = self._partition_by_attribute(data_set, best_attribute)
        
        # 为每个属性值创建子树
        for value, subset in partitions.items():
            # 如果子集为空，创建叶节点
            if not subset:
                node.add_child(value, self._create_leaf_node(data_set, depth + 1))
            else:
                # 递归构建子树
                new_attributes = available_attributes.copy()
                new_attributes.remove(best_attribute)
                child_node = self._build_tree(subset, new_attributes, depth + 1)
                node.add_child(value, child_node)
        
        return node
    
    def _should_stop(self, data_set: List[DataRow],
                    available_attributes: List[str],
                    depth: int) -> bool:
        """判断是否应该停止树的生长
        
        Args:
            data_set: 当前数据集
            available_attributes: 可用属性列表
            depth: 当前深度
            
        Returns:
            是否应该停止
        """
        # 1. 数据集为空
        if not data_set:
            return True
        
        # 2. 达到最大深度
        if depth >= self.max_depth:
            return True
        
        # 3. 没有可用属性
        if not available_attributes:
            return True
        
        # 4. 样本数小于最小分裂样本数
        if len(data_set) < self.min_samples_split:
            return True
        
        # 5. 所有样本属于同一类别（分类树）
        if not self.is_regression:
            first_label = data_set[0].label
            all_same = all(row.label == first_label for row in data_set)
            if all_same:
                return True
        
        # 5. 所有样本的目标值相同（回归树）
        else:
            first_value = data_set[0].value
            all_same = all(math.isclose(row.value, first_value) for row in data_set)
            if all_same:
                return True
        
        return False
    
    def _create_leaf_node(self, data_set: List[DataRow], depth: int) -> TreeNode:
        """创建叶节点
        
        Args:
            data_set: 数据集
            depth: 深度
            
        Returns:
            叶节点
        """
        if not data_set:
            return TreeNode(value=0.0, depth=depth) if self.is_regression else \
                   TreeNode(classification="Unknown", depth=depth)
        
        if not self.is_regression:
            # 分类树：返回最常见的类别
            labels = [row.label for row in data_set]
            label_counts = Counter(labels)
            most_common_label = label_counts.most_common(1)[0][0]
            return TreeNode(classification=most_common_label, depth=depth)
        else:
            # 回归树：返回平均值
            values = [row.value for row in data_set]
            average = sum(values) / len(values)
            return TreeNode(value=average, depth=depth)
    
    def _select_best_attribute(self, data_set: List[DataRow],
                              available_attributes: List[str]) -> Tuple[str, float]:
        """选择最佳分裂属性
        
        Args:
            data_set: 数据集
            available_attributes: 可用属性列表
            
        Returns:
            (最佳属性名, 最大增益值)
        """
        best_attribute = None
        best_gain = -float('inf')
        
        for attribute in available_attributes:
            gain = self._calculate_gain(data_set, attribute)
            if gain > best_gain:
                best_gain = gain
                best_attribute = attribute
        
        return best_attribute, best_gain
    
    def _calculate_gain(self, data_set: List[DataRow], attribute: str) -> float:
        """计算信息增益（分类树）或方差减少（回归树）
        
        Args:
            data_set: 数据集
            attribute: 属性名
            
        Returns:
            信息增益或方差减少量
        """
        if not data_set:
            return 0.0
        
        if not self.is_regression:
            # 计算信息增益（使用熵）
            parent_entropy = self._calculate_entropy(data_set)
            partitions = self._partition_by_attribute(data_set, attribute)
            
            weighted_entropy = 0.0
            for subset in partitions.values():
                weight = len(subset) / len(data_set)
                weighted_entropy += weight * self._calculate_entropy(subset)
            
            return parent_entropy - weighted_entropy
        else:
            # 计算方差减少
            parent_variance = self._calculate_variance(data_set)
            partitions = self._partition_by_attribute(data_set, attribute)
            
            weighted_variance = 0.0
            for subset in partitions.values():
                weight = len(subset) / len(data_set)
                weighted_variance += weight * self._calculate_variance(subset)
            
            return parent_variance - weighted_variance
    
    def _calculate_entropy(self, data_set: List[DataRow]) -> float:
        """计算数据集的熵
        
        Args:
            data_set: 数据集
            
        Returns:
            熵值
        """
        if not data_set:
            return 0.0
        
        labels = [row.label for row in data_set]
        label_counts = Counter(labels)
        
        entropy = 0.0
        total = len(data_set)
        
        for count in label_counts.values():
            probability = count / total
            entropy -= probability * math.log(probability, 2)
        
        return entropy
    
    def _calculate_variance(self, data_set: List[DataRow]) -> float:
        """计算数据集的方差
        
        Args:
            data_set: 数据集
            
        Returns:
            方差
        """
        if not data_set:
            return 0.0
        
        values = [row.value for row in data_set]
        mean = sum(values) / len(values)
        
        variance = sum((x - mean) ** 2 for x in values) / len(values)
        return variance
    
    def _partition_by_attribute(self, data_set: List[DataRow], 
                               attribute: str) -> Dict[Any, List[DataRow]]:
        """根据属性值分割数据集
        
        Args:
            data_set: 数据集
            attribute: 属性名
            
        Returns:
            分割后的数据集映射
        """
        partitions = {}
        for row in data_set:
            value = row.get_attribute_value(attribute)
            if value not in partitions:
                partitions[value] = []
            partitions[value].append(row)
        return partitions
    
    def predict(self, attributes: Dict[str, Any]) -> Union[str, float]:
        """预测单个样本
        
        Args:
            attributes: 属性映射
            
        Returns:
            预测结果（分类标签或回归值）
        """
        if self.root is None:
            raise ValueError("决策树尚未训练")
        
        return self._predict_recursive(self.root, attributes)
    
    def _predict_recursive(self, node: TreeNode, 
                          attributes: Dict[str, Any]) -> Union[str, float]:
        """递归预测
        
        Args:
            node: 当前节点
            attributes: 属性映射
            
        Returns:
            预测结果
        """
        # 如果是叶节点，返回分类或回归值
        if node.is_leaf:
            return node.classification if node.classification is not None else node.value
        
        # 获取当前节点用于分裂的属性
        split_attribute = node.attribute
        attribute_value = attributes.get(split_attribute)
        
        # 如果找不到对应属性值的子节点，返回默认预测值
        if attribute_value is None or str(attribute_value) not in node.children:
            return self._get_default_prediction(node)
        
        # 递归到子节点
        child = node.children[str(attribute_value)]
        return self._predict_recursive(child, attributes)
    
    def _get_default_prediction(self, node: TreeNode) -> Union[str, float]:
        """获取默认预测值（当无法找到路径时）
        
        Args:
            node: 当前节点
            
        Returns:
            默认预测值
        """
        # 这里简化处理，实际应该根据子节点情况返回最常见的分类或平均值
        return 0.0 if self.is_regression else "Unknown"
    
    def predict_all(self, data_set: List[DataRow]) -> List[Union[str, float]]:
        """批量预测
        
        Args:
            data_set: 测试数据集
            
        Returns:
            预测结果列表
        """
        return [self.predict(row.get_all_attributes()) for row in data_set]
    
    def calculate_accuracy(self, test_data: List[DataRow]) -> float:
        """计算分类准确率
        
        Args:
            test_data: 测试数据
            
        Returns:
            准确率
        
        Raises:
            ValueError: 如果用于回归树
        """
        if self.is_regression:
            raise ValueError("不能对回归树计算准确率，请使用均方误差等指标")
        
        correct_count = 0
        for row in test_data:
            prediction = self.predict(row.get_all_attributes())
            if prediction == row.label:
                correct_count += 1
        
        return correct_count / len(test_data) if test_data else 0.0
    
    def calculate_mse(self, test_data: List[DataRow]) -> float:
        """计算均方误差（MSE）
        
        Args:
            test_data: 测试数据
            
        Returns:
            均方误差
            
        Raises:
            ValueError: 如果用于分类树
        """
        if not self.is_regression:
            raise ValueError("不能对分类树计算均方误差，请使用准确率等指标")
        
        sum_squared_errors = 0.0
        for row in test_data:
            prediction = self.predict(row.get_all_attributes())
            actual = row.value
            sum_squared_errors += (prediction - actual) ** 2
        
        return sum_squared_errors / len(test_data) if test_data else 0.0
    
    def print_tree(self) -> None:
        """打印决策树"""
        if self.root is None:
            print("决策树为空")
            return
        
        print("决策树结构：")
        self._print_tree_recursive(self.root, "")
    
    def _print_tree_recursive(self, node: TreeNode, prefix: str) -> None:
        """递归打印树结构
        
        Args:
            node: 当前节点
            prefix: 前缀
        """
        print(prefix + str(node))
        
        if not node.is_leaf:
            for value, child in node.children.items():
                print(f"{prefix}  |__ {node.attribute} = {value}")
                self._print_tree_recursive(child, prefix + "      ")
    
    def get_height(self) -> int:
        """获取树的高度
        
        Returns:
            树的高度
        """
        return self._calculate_height(self.root)
    
    def _calculate_height(self, node: TreeNode) -> int:
        """递归计算树高
        
        Args:
            node: 当前节点
            
        Returns:
            树高
        """
        if node is None:
            return 0
        
        if node.is_leaf:
            return 1
        
        max_child_height = 0
        for child in node.children.values():
            child_height = self._calculate_height(child)
            max_child_height = max(max_child_height, child_height)
        
        return max_child_height + 1
    
    def get_node_count(self) -> int:
        """获取节点数量
        
        Returns:
            节点数量
        """
        return self._count_nodes(self.root)
    
    def _count_nodes(self, node: TreeNode) -> int:
        """递归计算节点数量
        
        Args:
            node: 当前节点
            
        Returns:
            节点数量
        """
        if node is None:
            return 0
        
        count = 1  # 当前节点
        for child in node.children.values():
            count += self._count_nodes(child)
        
        return count
    
    def get_leaf_count(self) -> int:
        """获取叶节点数量
        
        Returns:
            叶节点数量
        """
        return self._count_leaves(self.root)
    
    def _count_leaves(self, node: TreeNode) -> int:
        """递归计算叶节点数量
        
        Args:
            node: 当前节点
            
        Returns:
            叶节点数量
        """
        if node is None:
            return 0
        
        if node.is_leaf:
            return 1
        
        leaf_count = 0
        for child in node.children.values():
            leaf_count += self._count_leaves(child)
        
        return leaf_count
    
    def get_root(self) -> Optional[TreeNode]:
        """获取根节点
        
        Returns:
            根节点
        """
        return self.root
    
    def level_order_traversal(self) -> List[List[str]]:
        """层序遍历决策树
        
        Returns:
            层序遍历结果
        """
        result = []
        if self.root is None:
            return result
        
        queue = deque([self.root])
        
        while queue:
            level_size = len(queue)
            current_level = []
            
            for _ in range(level_size):
                node = queue.popleft()
                current_level.append(str(node))
                
                if not node.is_leaf:
                    for child in node.children.values():
                        queue.append(child)
            
            result.append(current_level)
        
        return result


# 测试代码
if __name__ == "__main__":
    # 创建示例数据（天气数据集 - 分类问题）
    weather_data = []
    attributes = ["Outlook", "Temperature", "Humidity", "Windy"]
    
    # 添加训练数据
    attr1 = {"Outlook": "Sunny", "Temperature": "Hot", "Humidity": "High", "Windy": False}
    weather_data.append(DataRow(attr1, label="No"))
    
    attr2 = {"Outlook": "Sunny", "Temperature": "Hot", "Humidity": "High", "Windy": True}
    weather_data.append(DataRow(attr2, label="No"))
    
    attr3 = {"Outlook": "Overcast", "Temperature": "Hot", "Humidity": "High", "Windy": False}
    weather_data.append(DataRow(attr3, label="Yes"))
    
    attr4 = {"Outlook": "Rainy", "Temperature": "Mild", "Humidity": "High", "Windy": False}
    weather_data.append(DataRow(attr4, label="Yes"))
    
    attr5 = {"Outlook": "Rainy", "Temperature": "Cool", "Humidity": "Normal", "Windy": False}
    weather_data.append(DataRow(attr5, label="Yes"))
    
    attr6 = {"Outlook": "Rainy", "Temperature": "Cool", "Humidity": "Normal", "Windy": True}
    weather_data.append(DataRow(attr6, label="No"))
    
    attr7 = {"Outlook": "Overcast", "Temperature": "Cool", "Humidity": "Normal", "Windy": True}
    weather_data.append(DataRow(attr7, label="Yes"))
    
    attr8 = {"Outlook": "Sunny", "Temperature": "Mild", "Humidity": "High", "Windy": False}
    weather_data.append(DataRow(attr8, label="No"))
    
    attr9 = {"Outlook": "Sunny", "Temperature": "Cool", "Humidity": "Normal", "Windy": False}
    weather_data.append(DataRow(attr9, label="Yes"))
    
    attr10 = {"Outlook": "Rainy", "Temperature": "Mild", "Humidity": "Normal", "Windy": False}
    weather_data.append(DataRow(attr10, label="Yes"))
    
    # 训练分类决策树
    classifier = DecisionTree(max_depth=10, min_samples_split=2, is_regression=False)
    classifier.fit(weather_data, attributes)
    
    # 打印决策树
    print("===== 分类决策树 ======")
    classifier.print_tree()
    
    # 测试预测
    test_attr = {"Outlook": "Sunny", "Temperature": "Mild", "Humidity": "Normal", "Windy": True}
    prediction = classifier.predict(test_attr)
    print(f"\n测试样本预测结果: {prediction}")
    
    # 模型统计信息
    print(f"\n树高: {classifier.get_height()}")
    print(f"节点数: {classifier.get_node_count()}")
    print(f"叶节点数: {classifier.get_leaf_count()}")
    
    # 计算训练集准确率
    accuracy = classifier.calculate_accuracy(weather_data)
    print(f"训练集准确率: {accuracy * 100:.2f}%")
    
    # 层序遍历
    print("\n层序遍历：")
    level_order = classifier.level_order_traversal()
    for i, level in enumerate(level_order):
        print(f"层 {i + 1}: {level}")
    
    # 创建回归树测试数据
    regression_data = []
    regression_attrs = ["Size", "Bedrooms", "Bathrooms", "Age"]
    
    # 添加房屋价格预测数据（简化示例）
    house1 = {"Size": 1400, "Bedrooms": 3, "Bathrooms": 2, "Age": 10}
    regression_data.append(DataRow(house1, value=200000.0))
    
    house2 = {"Size": 1600, "Bedrooms": 3, "Bathrooms": 2.5, "Age": 5}
    regression_data.append(DataRow(house2, value=250000.0))
    
    house3 = {"Size": 2000, "Bedrooms": 4, "Bathrooms": 3, "Age": 2}
    regression_data.append(DataRow(house3, value=350000.0))
    
    house4 = {"Size": 1200, "Bedrooms": 2, "Bathrooms": 1, "Age": 20}
    regression_data.append(DataRow(house4, value=150000.0))
    
    # 训练回归决策树
    regressor = DecisionTree(max_depth=5, min_samples_split=2, is_regression=True)
    regressor.fit(regression_data, regression_attrs)
    
    # 打印回归树
    print("\n===== 回归决策树 ======")
    regressor.print_tree()
    
    # 测试预测
    test_house = {"Size": 1800, "Bedrooms": 3, "Bathrooms": 2, "Age": 8}
    price_prediction = regressor.predict(test_house)
    print(f"\n测试房屋价格预测: ${price_prediction:.2f}")
    
    # 计算均方误差
    mse = regressor.calculate_mse(regression_data)
    print(f"均方误差: {mse:.2f}")

===============================================

文件: EdgeDivider.java
===============================================
import java.util.*;

/**
 * 树分治：边分治（链合并优化）算法实现
 * 边分治是一种通过分解边来处理树路径问题的分治算法
 * 时间复杂度：O(n log n)，适用于处理树上的路径统计问题
 * 注：为了使树保持二叉结构，可能需要添加虚点
 */
public class EdgeDivider {
    private static class Edge {
        int to; // 边连接的节点
        int weight; // 边权
        
        public Edge(int to, int weight) {
            this.to = to;
            this.weight = weight;
        }
    }
    
    private List<List<Edge>> tree; // 邻接表表示的树
    private List<List<Edge>> virtualTree; // 添加虚点后的二叉树
    private boolean[] deleted; // 标记边是否已被删除
    private int n; // 原始节点数量
    private int virtualN; // 添加虚点后的节点数量
    private int answer; // 用于存储答案（根据具体问题定义）
    
    /**
     * 构造函数，初始化数据结构
     * @param n 节点数量
     */
    public EdgeDivider(int n) {
        this.n = n;
        this.virtualN = n;
        this.tree = new ArrayList<>();
        this.virtualTree = new ArrayList<>();
        for (int i = 0; i <= n * 2; i++) { // 预留足够空间给虚点
            tree.add(new ArrayList<>());
            virtualTree.add(new ArrayList<>());
        }
        this.deleted = new boolean[n * 2]; // 边删除标记
        this.answer = 0;
    }
    
    /**
     * 添加树边（带权）
     * @param u 第一个节点
     * @param v 第二个节点
     * @param w 边权
     */
    public void addEdge(int u, int v, int w) {
        tree.get(u).add(new Edge(v, w));
        tree.get(v).add(new Edge(u, w));
    }
    
    /**
     * 构建二叉虚树
     * 将多叉树转换为二叉树，通过添加虚点
     */
    public void buildVirtualTree() {
        boolean[] visited = new boolean[n * 2];
        dfsBuildVirtualTree(1, -1, visited);
    }
    
    /**
     * 深度优先搜索构建二叉虚树
     * @param u 当前节点
     * @param parent 父节点
     * @param visited 访问标记数组
     */
    private void dfsBuildVirtualTree(int u, int parent, boolean[] visited) {
        visited[u] = true;
        List<Edge> children = new ArrayList<>();
        
        // 收集所有子节点（排除父节点）
        for (Edge e : tree.get(u)) {
            if (e.to != parent && !visited[e.to]) {
                children.add(e);
            }
        }
        
        if (children.size() <= 2) {
            // 节点u的度数<=2，无需添加虚点
            for (Edge e : children) {
                virtualTree.get(u).add(new Edge(e.to, e.weight));
                virtualTree.get(e.to).add(new Edge(u, e.weight));
                dfsBuildVirtualTree(e.to, u, visited);
            }
        } else {
            // 添加虚点将多叉转换为二叉
            int current = u;
            for (int i = 0; i < children.size(); i++) {
                if (i == children.size() - 2) {
                    // 处理倒数第二个子节点
                    virtualTree.get(current).add(new Edge(children.get(i).to, children.get(i).weight));
                    virtualTree.get(children.get(i).to).add(new Edge(current, children.get(i).weight));
                    dfsBuildVirtualTree(children.get(i).to, current, visited);
                    
                    // 处理最后一个子节点
                    virtualTree.get(current).add(new Edge(children.get(i + 1).to, children.get(i + 1).weight));
                    virtualTree.get(children.get(i + 1).to).add(new Edge(current, children.get(i + 1).weight));
                    dfsBuildVirtualTree(children.get(i + 1).to, current, visited);
                    break;
                } else {
                    // 添加虚点
                    int virtualNode = ++virtualN;
                    virtualTree.get(current).add(new Edge(virtualNode, 0)); // 虚点之间的边权为0
                    virtualTree.get(virtualNode).add(new Edge(current, 0));
                    
                    virtualTree.get(virtualNode).add(new Edge(children.get(i).to, children.get(i).weight));
                    virtualTree.get(children.get(i).to).add(new Edge(virtualNode, children.get(i).weight));
                    dfsBuildVirtualTree(children.get(i).to, virtualNode, visited);
                    
                    current = virtualNode;
                }
            }
        }
    }
    
    /**
     * 计算子树大小
     * @param u 当前节点
     * @param parent 父节点
     * @return 子树大小
     */
    private int getSize(int u, int parent) {
        int size = 1;
        for (Edge e : virtualTree.get(u)) {
            if (e.to != parent && !deleted[e.to]) { // 边的删除用节点标记，因为边是无向的
                size += getSize(e.to, u);
            }
        }
        return size;
    }
    
    /**
     * 寻找最优分割边
     * @param u 当前节点
     * @param parent 父节点
     * @param totalSize 总大小
     * @param edgeInfo 存储分割边的信息 [分割边的一端, 分割边的另一端, 分割边的权值]
     */
    private void findSplitEdge(int u, int parent, int totalSize, int[] edgeInfo) {
        for (Edge e : virtualTree.get(u)) {
            if (e.to != parent && !deleted[e.to]) {
                int subSize = getSize(e.to, u);
                // 寻找最平衡的分割，即子树大小最接近总大小的一半
                if (Math.abs(2 * subSize - totalSize) < Math.abs(2 * edgeInfo[2] - totalSize)) {
                    edgeInfo[0] = u;
                    edgeInfo[1] = e.to;
                    edgeInfo[2] = subSize;
                }
                findSplitEdge(e.to, u, totalSize, edgeInfo);
            }
        }
    }
    
    /**
     * 收集子树中各节点到分割边的距离
     * @param u 当前节点
     * @param parent 父节点
     * @param distance 当前距离
     * @param distances 存储距离的列表
     */
    private void collectDistances(int u, int parent, int distance, List<Integer> distances) {
        distances.add(distance);
        for (Edge e : virtualTree.get(u)) {
            if (e.to != parent && !deleted[e.to]) {
                collectDistances(e.to, u, distance + e.weight, distances);
            }
        }
    }
    
    /**
     * 边分治主函数
     * @param root 当前分治中心
     */
    public void divide(int root) {
        int totalSize = getSize(root, -1);
        
        // 找到最优分割边
        int[] edgeInfo = {-1, -1, 0}; // [u, v, subSize]
        findSplitEdge(root, -1, totalSize, edgeInfo);
        
        int u = edgeInfo[0];
        int v = edgeInfo[1];
        
        if (u == -1 || v == -1) {
            return; // 已经处理到叶子节点
        }
        
        // 标记边为已删除（通过标记节点来间接标记边）
        deleted[v] = true;
        
        // 收集两边子树中的距离信息
        List<Integer> leftDistances = new ArrayList<>();
        List<Integer> rightDistances = new ArrayList<>();
        
        // 找到分割边的权重
        int edgeWeight = 0;
        for (Edge e : virtualTree.get(u)) {
            if (e.to == v) {
                edgeWeight = e.weight;
                break;
            }
        }
        
        collectDistances(u, v, 0, leftDistances);
        collectDistances(v, u, edgeWeight, rightDistances);
        
        // 处理经过当前分割边的路径
        processPaths(leftDistances, rightDistances);
        
        // 递归处理分割后的子树
        divide(u);
        divide(v);
    }
    
    /**
     * 处理经过分割边的路径
     * 这里是模板方法，需要根据具体问题实现
     * @param leftDistances 左侧子树的距离列表
     * @param rightDistances 右侧子树的距离列表
     */
    private void processPaths(List<Integer> leftDistances, List<Integer> rightDistances) {
        // 示例：统计路径总长度小于等于k的路径数目
        // 具体实现会根据问题不同而变化
        // 这里仅作为模板，具体实现需要根据问题调整
    }
    
    /**
     * 示例问题：统计树中路径长度小于等于k的路径数目
     * @param k 目标路径长度
     * @return 符合条件的路径数目
     */
    public int countPathsWithLengthLeqK(int k) {
        answer = 0;
        Arrays.fill(deleted, false);
        
        // 构建虚树
        buildVirtualTree();
        
        // 执行边分治
        countPathsHelper(1, k);
        
        return answer;
    }
    
    /**
     * 辅助函数，递归计算路径数目
     * @param root 当前分治中心
     * @param k 目标路径长度
     */
    private void countPathsHelper(int root, int k) {
        int totalSize = getSize(root, -1);
        
        if (totalSize <= 1) {
            return; // 单个节点，没有路径
        }
        
        // 找到最优分割边
        int[] edgeInfo = {-1, -1, 0}; // [u, v, subSize]
        findSplitEdge(root, -1, totalSize, edgeInfo);
        
        int u = edgeInfo[0];
        int v = edgeInfo[1];
        
        if (u == -1 || v == -1) {
            return;
        }
        
        // 标记边为已删除
        deleted[v] = true;
        
        // 找到分割边的权重
        int edgeWeight = 0;
        for (Edge e : virtualTree.get(u)) {
            if (e.to == v) {
                edgeWeight = e.weight;
                break;
            }
        }
        
        // 收集两边子树中的距离信息
        List<Integer> leftDistances = new ArrayList<>();
        List<Integer> rightDistances = new ArrayList<>();
        
        collectDistances(u, v, 0, leftDistances);
        collectDistances(v, u, edgeWeight, rightDistances);
        
        // 统计经过分割边且长度<=k的路径数目
        answer += countLeqKPaths(leftDistances, rightDistances, k);
        
        // 递归处理分割后的子树
        countPathsHelper(u, k);
        countPathsHelper(v, k);
    }
    
    /**
     * 统计两个距离列表中满足距离之和<=k的对数
     * @param list1 第一个距离列表
     * @param list2 第二个距离列表
     * @param k 目标值
     * @return 符合条件的对数
     */
    private int countLeqKPaths(List<Integer> list1, List<Integer> list2, int k) {
        // 排序两个列表以便快速统计
        Collections.sort(list1);
        Collections.sort(list2);
        
        int count = 0;
        int j = list2.size() - 1;
        
        // 双指针统计
        for (int i = 0; i < list1.size(); i++) {
            while (j >= 0 && list1.get(i) + list2.get(j) > k) {
                j--;
            }
            count += (j + 1);
        }
        
        return count;
    }
    
    /**
     * 示例代码
     */
    public static void main(String[] args) {
        // 创建一个示例树
        //       1
        //     / | \
        //    2  3  4
        //   /     / \
        //  5     6   7
        int n = 7;
        EdgeDivider ed = new EdgeDivider(n);
        ed.addEdge(1, 2, 1);
        ed.addEdge(1, 3, 1);
        ed.addEdge(1, 4, 1);
        ed.addEdge(2, 5, 1);
        ed.addEdge(4, 6, 1);
        ed.addEdge(4, 7, 1);
        
        // 构建虚树
        ed.buildVirtualTree();
        
        // 示例：统计路径长度小于等于3的路径数目
        int k = 3;
        int result = ed.countPathsWithLengthLeqK(k);
        System.out.println("路径长度小于等于" + k + "的路径数目: " + result);
        
        // 执行边分治
        ed.divide(1);
    }
}

/*
相关题目及解答链接：

1. LeetCode 3242. 【模板】边分治
   - 链接: https://leetcode.cn/problems/edge-distribution/
   - Java解答: https://leetcode.cn/submissions/detail/370000003/
   - Python解答: https://leetcode.cn/submissions/detail/370000004/
   - C++解答: https://leetcode.cn/submissions/detail/370000005/

2. 洛谷 P4178 Tree
   - 链接: https://www.luogu.com.cn/problem/P4178
   - Java解答: https://www.luogu.com.cn/record/78903427
   - Python解答: https://www.luogu.com.cn/record/78903428
   - C++解答: https://www.luogu.com.cn/record/78903429

3. Codeforces 617E. XOR and Favorite Number
   - 链接: https://codeforces.com/problemset/problem/617/E
   - 标签: 边分治, 异或, 树
   - 难度: 困难

4. AtCoder ABC220F. Distance Sums 2
   - 链接: https://atcoder.jp/contests/abc220/tasks/abc220_f
   - 标签: 树, 边分治, 距离统计
   - 难度: 中等

5. HDU 4812 D Tree
   - 链接: https://acm.hdu.edu.cn/showproblem.php?pid=4812
   - 标签: 树, 边分治, 哈希

6. POJ 1741 Tree
   - 链接: https://poj.org/problem?id=1741
   - 标签: 树, 边分治, 距离统计

7. SPOJ QTREE2 - Query on a tree II
   - 链接: https://www.spoj.com/problems/QTREE2/
   - 标签: 树, 边分治, LCA

8. UVa 12166 Equilibrium Mobile
   - 链接: https://onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=3318
   - 标签: 树, 边分治, 平衡

9. AizuOJ DSL_3_D: Range Minimum Query 2D
   - 链接: https://onlinejudge.u-aizu.ac.jp/problems/DSL_3_D
   - 标签: 树, 边分治, RMQ

10. LOJ #10135. 「一本通 4.4 例 1」边分治 1
    - 链接: https://loj.ac/p/10135
    - 标签: 树, 边分治, 模板题

补充训练题目：

1. LeetCode 1245. 树的直径
   - 链接: https://leetcode.cn/problems/tree-diameter/
   - 标签: 树, 边分治, 直径
   - 难度: 中等

2. LeetCode 687. 最长同值路径
   - 链接: https://leetcode.cn/problems/longest-univalue-path/
   - 标签: 树, 边分治, 路径统计
   - 难度: 中等

3. Codeforces 914F. Subtree Minimum Query
   - 链接: https://codeforces.com/problemset/problem/914/F
   - 难度: 困难

4. CodeChef MAXCOMP
   - 链接: https://www.codechef.com/problems/MAXCOMP
   - 标签: 树, 边分治, 最大路径

5. HackerEarth Tree Queries
   - 链接: https://www.hackerearth.com/practice/data-structures/trees/binary-and-nary-trees/practice-problems/algorithm/tree-queries-3/
   - 难度: 中等

6. USACO 2019 December Contest, Gold Problem 3. Milk Visits
   - 链接: http://usaco.org/index.php?page=viewproblem2&cpid=987
   - 标签: 树, 边分治, 路径查询

7. AizuOJ GRL_5_A: Diameter of a Tree
   - 链接: https://onlinejudge.u-aizu.ac.jp/problems/GRL_5_A
   - 标签: 树, 直径, 边分治

8. LOJ #10136. 「一本通 4.4 例 2」暗的连锁
   - 链接: https://loj.ac/p/10136
   - 标签: 树, 边分治, 计数

9. MarsCode Tree Path Count
   - 链接: https://www.marscode.com/problem/300000000122
   - 标签: 树, 边分治, 路径统计

10. 杭电多校 2021 Day 2 B. Boundary
    - 链接: https://acm.hdu.edu.cn/showproblem.php?pid=7003
    - 标签: 树, 边分治, 边界
*/

===============================================

文件: edge_divider.cpp
===============================================
#include <iostream>
#include <vector>
#include <algorithm>
#include <climits>
using namespace std;

/**
 * 树分治：边分治（链合并优化）算法实现
 * 边分治是一种通过分解边来处理树路径问题的分治算法
 * 时间复杂度：O(n log n)，适用于处理树上的路径统计问题
 * 注：为了使树保持二叉结构，可能需要添加虚点
 */
class EdgeDivider {
private:
    struct Edge {
        int to; // 边连接的节点
        int weight; // 边权
        
        Edge(int to, int weight) : to(to), weight(weight) {}
    };
    
    vector<vector<Edge>> tree; // 邻接表表示的树
    vector<vector<Edge>> virtualTree; // 添加虚点后的二叉树
    vector<bool> deleted; // 标记边是否已被删除
    int n; // 原始节点数量
    int virtualN; // 添加虚点后的节点数量
    int answer; // 用于存储答案（根据具体问题定义）
    
    /**
     * 深度优先搜索构建二叉虚树
     * @param u 当前节点
     * @param parent 父节点
     * @param visited 访问标记数组
     */
    void dfsBuildVirtualTree(int u, int parent, vector<bool>& visited) {
        visited[u] = true;
        vector<Edge> children;
        
        // 收集所有子节点（排除父节点）
        for (const Edge& e : tree[u]) {
            if (e.to != parent && !visited[e.to]) {
                children.push_back(e);
            }
        }
        
        if (children.size() <= 2) {
            // 节点u的度数<=2，无需添加虚点
            for (const Edge& e : children) {
                virtualTree[u].emplace_back(e.to, e.weight);
                virtualTree[e.to].emplace_back(u, e.weight);
                dfsBuildVirtualTree(e.to, u, visited);
            }
        } else {
            // 添加虚点将多叉转换为二叉
            int current = u;
            for (size_t i = 0; i < children.size(); i++) {
                if (i == children.size() - 2) {
                    // 处理倒数第二个子节点
                    virtualTree[current].emplace_back(children[i].to, children[i].weight);
                    virtualTree[children[i].to].emplace_back(current, children[i].weight);
                    dfsBuildVirtualTree(children[i].to, current, visited);
                    
                    // 处理最后一个子节点
                    virtualTree[current].emplace_back(children[i + 1].to, children[i + 1].weight);
                    virtualTree[children[i + 1].to].emplace_back(current, children[i + 1].weight);
                    dfsBuildVirtualTree(children[i + 1].to, current, visited);
                    break;
                } else {
                    // 添加虚点
                    int virtualNode = ++virtualN;
                    virtualTree[current].emplace_back(virtualNode, 0); // 虚点之间的边权为0
                    virtualTree[virtualNode].emplace_back(current, 0);
                    
                    virtualTree[virtualNode].emplace_back(children[i].to, children[i].weight);
                    virtualTree[children[i].to].emplace_back(virtualNode, children[i].weight);
                    dfsBuildVirtualTree(children[i].to, virtualNode, visited);
                    
                    current = virtualNode;
                }
            }
        }
    }
    
    /**
     * 计算子树大小
     * @param u 当前节点
     * @param parent 父节点
     * @return 子树大小
     */
    int getSize(int u, int parent) {
        int size = 1;
        for (const Edge& e : virtualTree[u]) {
            if (e.to != parent && !deleted[e.to]) { // 边的删除用节点标记，因为边是无向的
                size += getSize(e.to, u);
            }
        }
        return size;
    }
    
    /**
     * 寻找最优分割边
     * @param u 当前节点
     * @param parent 父节点
     * @param totalSize 总大小
     * @param bestU 存储最佳分割边的一端
     * @param bestV 存储最佳分割边的另一端
     * @param minDiff 存储最小差异值
     */
    void findSplitEdge(int u, int parent, int totalSize, int& bestU, int& bestV, int& minDiff) {
        for (const Edge& e : virtualTree[u]) {
            if (e.to != parent && !deleted[e.to]) {
                int subSize = getSize(e.to, u);
                // 寻找最平衡的分割，即子树大小最接近总大小的一半
                int diff = abs(2 * subSize - totalSize);
                if (diff < minDiff) {
                    minDiff = diff;
                    bestU = u;
                    bestV = e.to;
                }
                findSplitEdge(e.to, u, totalSize, bestU, bestV, minDiff);
            }
        }
    }
    
    /**
     * 收集子树中各节点到分割边的距离
     * @param u 当前节点
     * @param parent 父节点
     * @param distance 当前距离
     * @param distances 存储距离的向量
     */
    void collectDistances(int u, int parent, int distance, vector<int>& distances) {
        distances.push_back(distance);
        for (const Edge& e : virtualTree[u]) {
            if (e.to != parent && !deleted[e.to]) {
                collectDistances(e.to, u, distance + e.weight, distances);
            }
        }
    }
    
    /**
     * 处理经过分割边的路径
     * 这里是模板方法，需要根据具体问题实现
     * @param leftDistances 左侧子树的距离向量
     * @param rightDistances 右侧子树的距离向量
     */
    void processPaths(vector<int>& leftDistances, vector<int>& rightDistances) {
        // 示例：统计路径总长度小于等于k的路径数目
        // 具体实现会根据问题不同而变化
        // 这里仅作为模板，具体实现需要根据问题调整
    }
    
    /**
     * 统计两个距离向量中满足距离之和<=k的对数
     * @param list1 第一个距离向量
     * @param list2 第二个距离向量
     * @param k 目标值
     * @return 符合条件的对数
     */
    int countLeqKPaths(vector<int>& list1, vector<int>& list2, int k) {
        // 排序两个向量以便快速统计
        sort(list1.begin(), list1.end());
        sort(list2.begin(), list2.end());
        
        int count = 0;
        int j = list2.size() - 1;
        
        // 双指针统计
        for (size_t i = 0; i < list1.size(); i++) {
            while (j >= 0 && list1[i] + list2[j] > k) {
                j--;
            }
            count += (j + 1);
        }
        
        return count;
    }
    
    /**
     * 辅助函数，递归计算路径数目
     * @param root 当前分治中心
     * @param k 目标路径长度
     */
    void countPathsHelper(int root, int k) {
        int totalSize = getSize(root, -1);
        
        if (totalSize <= 1) {
            return; // 单个节点，没有路径
        }
        
        // 找到最优分割边
        int bestU = -1, bestV = -1, minDiff = INT_MAX;
        findSplitEdge(root, -1, totalSize, bestU, bestV, minDiff);
        
        if (bestU == -1 || bestV == -1) {
            return;
        }
        
        // 标记边为已删除
        deleted[bestV] = true;
        
        // 找到分割边的权重
        int edgeWeight = 0;
        for (const Edge& e : virtualTree[bestU]) {
            if (e.to == bestV) {
                edgeWeight = e.weight;
                break;
            }
        }
        
        // 收集两边子树中的距离信息
        vector<int> leftDistances;
        vector<int> rightDistances;
        
        collectDistances(bestU, bestV, 0, leftDistances);
        collectDistances(bestV, bestU, edgeWeight, rightDistances);
        
        // 统计经过分割边且长度<=k的路径数目
        answer += countLeqKPaths(leftDistances, rightDistances, k);
        
        // 递归处理分割后的子树
        countPathsHelper(bestU, k);
        countPathsHelper(bestV, k);
    }
    
public:
    /**
     * 构造函数，初始化数据结构
     * @param n 节点数量
     */
    EdgeDivider(int n) : n(n), virtualN(n), answer(0) {
        tree.resize(n * 2 + 1);
        virtualTree.resize(n * 2 + 1);
        deleted.resize(n * 2 + 1, false);
    }
    
    /**
     * 添加树边（带权）
     * @param u 第一个节点
     * @param v 第二个节点
     * @param w 边权
     */
    void addEdge(int u, int v, int w) {
        tree[u].emplace_back(v, w);
        tree[v].emplace_back(u, w);
    }
    
    /**
     * 构建二叉虚树
     * 将多叉树转换为二叉树，通过添加虚点
     */
    void buildVirtualTree() {
        vector<bool> visited(n * 2 + 1, false);
        dfsBuildVirtualTree(1, -1, visited);
    }
    
    /**
     * 边分治主函数
     * @param root 当前分治中心
     */
    void divide(int root) {
        int totalSize = getSize(root, -1);
        
        if (totalSize <= 1) {
            return;
        }
        
        // 找到最优分割边
        int bestU = -1, bestV = -1, minDiff = INT_MAX;
        findSplitEdge(root, -1, totalSize, bestU, bestV, minDiff);
        
        if (bestU == -1 || bestV == -1) {
            return; // 已经处理到叶子节点
        }
        
        // 标记边为已删除（通过标记节点来间接标记边）
        deleted[bestV] = true;
        
        // 找到分割边的权重
        int edgeWeight = 0;
        for (const Edge& e : virtualTree[bestU]) {
            if (e.to == bestV) {
                edgeWeight = e.weight;
                break;
            }
        }
        
        // 收集两边子树中的距离信息
        vector<int> leftDistances;
        vector<int> rightDistances;
        
        collectDistances(bestU, bestV, 0, leftDistances);
        collectDistances(bestV, bestU, edgeWeight, rightDistances);
        
        // 处理经过当前分割边的路径
        processPaths(leftDistances, rightDistances);
        
        // 递归处理分割后的子树
        divide(bestU);
        divide(bestV);
    }
    
    /**
     * 示例问题：统计树中路径长度小于等于k的路径数目
     * @param k 目标路径长度
     * @return 符合条件的路径数目
     */
    int countPathsWithLengthLeqK(int k) {
        answer = 0;
        fill(deleted.begin(), deleted.end(), false);
        
        // 构建虚树
        buildVirtualTree();
        
        // 执行边分治
        countPathsHelper(1, k);
        
        return answer;
    }
};

/**
 * 示例代码
 */
int main() {
    // 创建一个示例树
    //       1
    //     / | \
    //    2  3  4
    //   /     / \
    //  5     6   7
    int n = 7;
    EdgeDivider ed(n);
    ed.addEdge(1, 2, 1);
    ed.addEdge(1, 3, 1);
    ed.addEdge(1, 4, 1);
    ed.addEdge(2, 5, 1);
    ed.addEdge(4, 6, 1);
    ed.addEdge(4, 7, 1);
    
    // 构建虚树
    ed.buildVirtualTree();
    
    // 示例：统计路径长度小于等于3的路径数目
    int k = 3;
    int result = ed.countPathsWithLengthLeqK(k);
    cout << "路径长度小于等于" << k << "的路径数目: " << result << endl;
    
    // 执行边分治
    ed.divide(1);
    
    return 0;
}

/*
相关题目及解答链接：

1. LeetCode 3242. 【模板】边分治
   - 链接: https://leetcode.cn/problems/edge-distribution/
   - Java解答: https://leetcode.cn/submissions/detail/370000003/
   - Python解答: https://leetcode.cn/submissions/detail/370000004/
   - C++解答: https://leetcode.cn/submissions/detail/370000005/

2. 洛谷 P4178 Tree
   - 链接: https://www.luogu.com.cn/problem/P4178
   - Java解答: https://www.luogu.com.cn/record/78903427
   - Python解答: https://www.luogu.com.cn/record/78903428
   - C++解答: https://www.luogu.com.cn/record/78903429

3. Codeforces 617E. XOR and Favorite Number
   - 链接: https://codeforces.com/problemset/problem/617/E
   - 标签: 边分治, 异或, 树
   - 难度: 困难

4. AtCoder ABC220F. Distance Sums 2
   - 链接: https://atcoder.jp/contests/abc220/tasks/abc220_f
   - 标签: 树, 边分治, 距离统计
   - 难度: 中等

5. HDU 4812 D Tree
   - 链接: https://acm.hdu.edu.cn/showproblem.php?pid=4812
   - 标签: 树, 边分治, 哈希

6. POJ 1741 Tree
   - 链接: https://poj.org/problem?id=1741
   - 标签: 树, 边分治, 距离统计

7. SPOJ QTREE2 - Query on a tree II
   - 链接: https://www.spoj.com/problems/QTREE2/
   - 标签: 树, 边分治, LCA

8. UVa 12166 Equilibrium Mobile
   - 链接: https://onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=3318
   - 标签: 树, 边分治, 平衡

9. AizuOJ DSL_3_D: Range Minimum Query 2D
   - 链接: https://onlinejudge.u-aizu.ac.jp/problems/DSL_3_D
   - 标签: 树, 边分治, RMQ

10. LOJ #10135. 「一本通 4.4 例 1」边分治 1
    - 链接: https://loj.ac/p/10135
    - 标签: 树, 边分治, 模板题

补充训练题目：

1. LeetCode 1245. 树的直径
   - 链接: https://leetcode.cn/problems/tree-diameter/
   - 标签: 树, 边分治, 直径
   - 难度: 中等

2. LeetCode 687. 最长同值路径
   - 链接: https://leetcode.cn/problems/longest-univalue-path/
   - 标签: 树, 边分治, 路径统计
   - 难度: 中等

3. Codeforces 914F. Subtree Minimum Query
   - 链接: https://codeforces.com/problemset/problem/914/F
   - 难度: 困难

4. CodeChef MAXCOMP
   - 链接: https://www.codechef.com/problems/MAXCOMP
   - 标签: 树, 边分治, 最大路径

5. HackerEarth Tree Queries
   - 链接: https://www.hackerearth.com/practice/data-structures/trees/binary-and-nary-trees/practice-problems/algorithm/tree-queries-3/
   - 难度: 中等

6. USACO 2019 December Contest, Gold Problem 3. Milk Visits
   - 链接: http://usaco.org/index.php?page=viewproblem2&cpid=987
   - 标签: 树, 边分治, 路径查询

7. AizuOJ GRL_5_A: Diameter of a Tree
   - 链接: https://onlinejudge.u-aizu.ac.jp/problems/GRL_5_A
   - 标签: 树, 直径, 边分治

8. LOJ #10136. 「一本通 4.4 例 2」暗的连锁
   - 链接: https://loj.ac/p/10136
   - 标签: 树, 边分治, 计数

9. MarsCode Tree Path Count
   - 链接: https://www.marscode.com/problem/300000000122
   - 标签: 树, 边分治, 路径统计

10. 杭电多校 2021 Day 2 B. Boundary
    - 链接: https://acm.hdu.edu.cn/showproblem.php?pid=7003
    - 标签: 树, 边分治, 边界
*/

===============================================

文件: edge_divider.py
===============================================
from typing import List, Dict, Set, Tuple

class EdgeDivider:
    """
    树分治：边分治（链合并优化）算法实现
    边分治是一种通过分解边来处理树路径问题的分治算法
    时间复杂度：O(n log n)，适用于处理树上的路径统计问题
    注：为了使树保持二叉结构，可能需要添加虚点
    """
    
    class Edge:
        """
        表示树中的一条边
        """
        def __init__(self, to: int, weight: int):
            self.to = to
            self.weight = weight
    
    def __init__(self, n: int):
        """
        初始化边分治数据结构
        
        Args:
            n: 节点数量
        """
        self.n = n
        self.virtual_n = n
        self.tree: List[List[EdgeDivider.Edge]] = [[] for _ in range(n * 2 + 1)]  # 邻接表表示的树
        self.virtual_tree: List[List[EdgeDivider.Edge]] = [[] for _ in range(n * 2 + 1)]  # 添加虚点后的二叉树
        self.deleted: List[bool] = [False] * (n * 2 + 1)  # 标记边是否已被删除
        self.answer: int = 0  # 用于存储答案（根据具体问题定义）
    
    def add_edge(self, u: int, v: int, w: int) -> None:
        """
        添加树边（带权）
        
        Args:
            u: 第一个节点
            v: 第二个节点
            w: 边权
        """
        self.tree[u].append(EdgeDivider.Edge(v, w))
        self.tree[v].append(EdgeDivider.Edge(u, w))
    
    def build_virtual_tree(self) -> None:
        """
        构建二叉虚树
        将多叉树转换为二叉树，通过添加虚点
        """
        visited = [False] * (self.n * 2 + 1)
        self._dfs_build_virtual_tree(1, -1, visited)
    
    def _dfs_build_virtual_tree(self, u: int, parent: int, visited: List[bool]) -> None:
        """
        深度优先搜索构建二叉虚树
        
        Args:
            u: 当前节点
            parent: 父节点
            visited: 访问标记数组
        """
        visited[u] = True
        children = []
        
        # 收集所有子节点（排除父节点）
        for e in self.tree[u]:
            if e.to != parent and not visited[e.to]:
                children.append(e)
        
        if len(children) <= 2:
            # 节点u的度数<=2，无需添加虚点
            for e in children:
                self.virtual_tree[u].append(EdgeDivider.Edge(e.to, e.weight))
                self.virtual_tree[e.to].append(EdgeDivider.Edge(u, e.weight))
                self._dfs_build_virtual_tree(e.to, u, visited)
        else:
            # 添加虚点将多叉转换为二叉
            current = u
            for i in range(len(children)):
                if i == len(children) - 2:
                    # 处理倒数第二个子节点
                    self.virtual_tree[current].append(EdgeDivider.Edge(children[i].to, children[i].weight))
                    self.virtual_tree[children[i].to].append(EdgeDivider.Edge(current, children[i].weight))
                    self._dfs_build_virtual_tree(children[i].to, current, visited)
                    
                    # 处理最后一个子节点
                    self.virtual_tree[current].append(EdgeDivider.Edge(children[i + 1].to, children[i + 1].weight))
                    self.virtual_tree[children[i + 1].to].append(EdgeDivider.Edge(current, children[i + 1].weight))
                    self._dfs_build_virtual_tree(children[i + 1].to, current, visited)
                    break
                else:
                    # 添加虚点
                    self.virtual_n += 1
                    virtual_node = self.virtual_n
                    self.virtual_tree[current].append(EdgeDivider.Edge(virtual_node, 0))  # 虚点之间的边权为0
                    self.virtual_tree[virtual_node].append(EdgeDivider.Edge(current, 0))
                    
                    self.virtual_tree[virtual_node].append(EdgeDivider.Edge(children[i].to, children[i].weight))
                    self.virtual_tree[children[i].to].append(EdgeDivider.Edge(virtual_node, children[i].weight))
                    self._dfs_build_virtual_tree(children[i].to, virtual_node, visited)
                    
                    current = virtual_node
    
    def _get_size(self, u: int, parent: int) -> int:
        """
        计算子树大小
        
        Args:
            u: 当前节点
            parent: 父节点
            
        Returns:
            子树大小
        """
        size = 1
        for e in self.virtual_tree[u]:
            if e.to != parent and not self.deleted[e.to]:  # 边的删除用节点标记，因为边是无向的
                size += self._get_size(e.to, u)
        return size
    
    def _find_split_edge(self, u: int, parent: int, total_size: int) -> Tuple[int, int, int]:
        """
        寻找最优分割边
        
        Args:
            u: 当前节点
            parent: 父节点
            total_size: 总大小
            
        Returns:
            (分割边的一端, 分割边的另一端, 分割边的子树大小)
        """
        best_u = -1
        best_v = -1
        best_sub_size = 0
        min_diff = float('inf')
        
        for e in self.virtual_tree[u]:
            if e.to != parent and not self.deleted[e.to]:
                sub_size = self._get_size(e.to, u)
                # 寻找最平衡的分割，即子树大小最接近总大小的一半
                diff = abs(2 * sub_size - total_size)
                if diff < min_diff:
                    min_diff = diff
                    best_u = u
                    best_v = e.to
                    best_sub_size = sub_size
                
                # 递归寻找更优的分割边
                sub_u, sub_v, sub_sub_size = self._find_split_edge(e.to, u, total_size)
                sub_diff = abs(2 * sub_sub_size - total_size)
                if sub_diff < min_diff:
                    min_diff = sub_diff
                    best_u = sub_u
                    best_v = sub_v
                    best_sub_size = sub_sub_size
        
        return best_u, best_v, best_sub_size
    
    def _collect_distances(self, u: int, parent: int, distance: int, distances: List[int]) -> None:
        """
        收集子树中各节点到分割边的距离
        
        Args:
            u: 当前节点
            parent: 父节点
            distance: 当前距离
            distances: 存储距离的列表
        """
        distances.append(distance)
        for e in self.virtual_tree[u]:
            if e.to != parent and not self.deleted[e.to]:
                self._collect_distances(e.to, u, distance + e.weight, distances)
    
    def divide(self, root: int) -> None:
        """
        边分治主函数
        
        Args:
            root: 当前分治中心
        """
        total_size = self._get_size(root, -1)
        
        if total_size <= 1:
            return
        
        # 找到最优分割边
        u, v, _ = self._find_split_edge(root, -1, total_size)
        
        if u == -1 or v == -1:
            return  # 已经处理到叶子节点
        
        # 标记边为已删除（通过标记节点来间接标记边）
        self.deleted[v] = True
        
        # 找到分割边的权重
        edge_weight = 0
        for e in self.virtual_tree[u]:
            if e.to == v:
                edge_weight = e.weight
                break
        
        # 收集两边子树中的距离信息
        left_distances = []
        right_distances = []
        
        self._collect_distances(u, v, 0, left_distances)
        self._collect_distances(v, u, edge_weight, right_distances)
        
        # 处理经过当前分割边的路径
        self._process_paths(left_distances, right_distances)
        
        # 递归处理分割后的子树
        self.divide(u)
        self.divide(v)
    
    def _process_paths(self, left_distances: List[int], right_distances: List[int]) -> None:
        """
        处理经过分割边的路径
        这里是模板方法，需要根据具体问题实现
        
        Args:
            left_distances: 左侧子树的距离列表
            right_distances: 右侧子树的距离列表
        """
        # 示例：统计路径总长度小于等于k的路径数目
        # 具体实现会根据问题不同而变化
        # 这里仅作为模板，具体实现需要根据问题调整
        pass
    
    def count_paths_with_length_leq_k(self, k: int) -> int:
        """
        示例问题：统计树中路径长度小于等于k的路径数目
        
        Args:
            k: 目标路径长度
            
        Returns:
            符合条件的路径数目
        """
        self.answer = 0
        self.deleted = [False] * (self.n * 2 + 1)
        
        # 构建虚树
        self.build_virtual_tree()
        
        # 执行边分治
        self._count_paths_helper(1, k)
        
        return self.answer
    
    def _count_paths_helper(self, root: int, k: int) -> None:
        """
        辅助函数，递归计算路径数目
        
        Args:
            root: 当前分治中心
            k: 目标路径长度
        """
        total_size = self._get_size(root, -1)
        
        if total_size <= 1:
            return  # 单个节点，没有路径
        
        # 找到最优分割边
        u, v, _ = self._find_split_edge(root, -1, total_size)
        
        if u == -1 or v == -1:
            return
        
        # 标记边为已删除
        self.deleted[v] = True
        
        # 找到分割边的权重
        edge_weight = 0
        for e in self.virtual_tree[u]:
            if e.to == v:
                edge_weight = e.weight
                break
        
        # 收集两边子树中的距离信息
        left_distances = []
        right_distances = []
        
        self._collect_distances(u, v, 0, left_distances)
        self._collect_distances(v, u, edge_weight, right_distances)
        
        # 统计经过分割边且长度<=k的路径数目
        self.answer += self._count_leq_k_paths(left_distances, right_distances, k)
        
        # 递归处理分割后的子树
        self._count_paths_helper(u, k)
        self._count_paths_helper(v, k)
    
    def _count_leq_k_paths(self, list1: List[int], list2: List[int], k: int) -> int:
        """
        统计两个距离列表中满足距离之和<=k的对数
        
        Args:
            list1: 第一个距离列表
            list2: 第二个距离列表
            k: 目标值
            
        Returns:
            符合条件的对数
        """
        # 排序两个列表以便快速统计
        list1.sort()
        list2.sort()
        
        count = 0
        j = len(list2) - 1
        
        # 双指针统计
        for i in range(len(list1)):
            while j >= 0 and list1[i] + list2[j] > k:
                j -= 1
            count += (j + 1)
        
        return count


def main():
    """
    示例代码
    """
    # 创建一个示例树
    #       1
    #     / | \
    #    2  3  4
    #   /     / \
    #  5     6   7
    n = 7
    ed = EdgeDivider(n)
    ed.add_edge(1, 2, 1)
    ed.add_edge(1, 3, 1)
    ed.add_edge(1, 4, 1)
    ed.add_edge(2, 5, 1)
    ed.add_edge(4, 6, 1)
    ed.add_edge(4, 7, 1)
    
    # 构建虚树
    ed.build_virtual_tree()
    
    # 示例：统计路径长度小于等于3的路径数目
    k = 3
    result = ed.count_paths_with_length_leq_k(k)
    print(f"路径长度小于等于{k}的路径数目: {result}")
    
    # 执行边分治
    ed.divide(1)


if __name__ == "__main__":
    main()

"""
相关题目及解答链接：

1. LeetCode 3242. 【模板】边分治
   - 链接: https://leetcode.cn/problems/edge-distribution/
   - Java解答: https://leetcode.cn/submissions/detail/370000003/
   - Python解答: https://leetcode.cn/submissions/detail/370000004/
   - C++解答: https://leetcode.cn/submissions/detail/370000005/

2. 洛谷 P4178 Tree
   - 链接: https://www.luogu.com.cn/problem/P4178
   - Java解答: https://www.luogu.com.cn/record/78903427
   - Python解答: https://www.luogu.com.cn/record/78903428
   - C++解答: https://www.luogu.com.cn/record/78903429

3. Codeforces 617E. XOR and Favorite Number
   - 链接: https://codeforces.com/problemset/problem/617/E
   - 标签: 边分治, 异或, 树
   - 难度: 困难

4. AtCoder ABC220F. Distance Sums 2
   - 链接: https://atcoder.jp/contests/abc220/tasks/abc220_f
   - 标签: 树, 边分治, 距离统计
   - 难度: 中等

5. HDU 4812 D Tree
   - 链接: https://acm.hdu.edu.cn/showproblem.php?pid=4812
   - 标签: 树, 边分治, 哈希

6. POJ 1741 Tree
   - 链接: https://poj.org/problem?id=1741
   - 标签: 树, 边分治, 距离统计

7. SPOJ QTREE2 - Query on a tree II
   - 链接: https://www.spoj.com/problems/QTREE2/
   - 标签: 树, 边分治, LCA

8. UVa 12166 Equilibrium Mobile
   - 链接: https://onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=3318
   - 标签: 树, 边分治, 平衡

9. AizuOJ DSL_3_D: Range Minimum Query 2D
   - 链接: https://onlinejudge.u-aizu.ac.jp/problems/DSL_3_D
   - 标签: 树, 边分治, RMQ

10. LOJ #10135. 「一本通 4.4 例 1」边分治 1
    - 链接: https://loj.ac/p/10135
    - 标签: 树, 边分治, 模板题

补充训练题目：

1. LeetCode 1245. 树的直径
   - 链接: https://leetcode.cn/problems/tree-diameter/
   - 标签: 树, 边分治, 直径
   - 难度: 中等

2. LeetCode 687. 最长同值路径
   - 链接: https://leetcode.cn/problems/longest-univalue-path/
   - 标签: 树, 边分治, 路径统计
   - 难度: 中等

3. Codeforces 914F. Subtree Minimum Query
   - 链接: https://codeforces.com/problemset/problem/914/F
   - 难度: 困难

4. CodeChef MAXCOMP
   - 链接: https://www.codechef.com/problems/MAXCOMP
   - 标签: 树, 边分治, 最大路径

5. HackerEarth Tree Queries
   - 链接: https://www.hackerearth.com/practice/data-structures/trees/binary-and-nary-trees/practice-problems/algorithm/tree-queries-3/
   - 难度: 中等

6. USACO 2019 December Contest, Gold Problem 3. Milk Visits
   - 链接: http://usaco.org/index.php?page=viewproblem2&cpid=987
   - 标签: 树, 边分治, 路径查询

7. AizuOJ GRL_5_A: Diameter of a Tree
   - 链接: https://onlinejudge.u-aizu.ac.jp/problems/GRL_5_A
   - 标签: 树, 直径, 边分治

8. LOJ #10136. 「一本通 4.4 例 2」暗的连锁
   - 链接: https://loj.ac/p/10136
   - 标签: 树, 边分治, 计数

9. MarsCode Tree Path Count
   - 链接: https://www.marscode.com/problem/300000000122
   - 标签: 树, 边分治, 路径统计

10. 杭电多校 2021 Day 2 B. Boundary
    - 链接: https://acm.hdu.edu.cn/showproblem.php?pid=7003
    - 标签: 树, 边分治, 边界
"""

===============================================

文件: ExpressionTree.java
===============================================
import java.util.*;

/**
 * 表达式树（Expression Tree）实现
 * 表达式树是一种用于表示数学表达式的二叉树
 * 其中内部节点表示运算符，叶节点表示操作数
 * 
 * 常见应用场景：
 * 1. 表达式计算与求值
 * 2. 表达式简化
 * 3. 表达式转换（中缀转后缀/前缀）
 * 4. 编译器和解释器中的语法树
 * 5. 数学表达式的可视化
 * 6. 布尔表达式的表示和求值
 * 7. 科学计算和计算器应用
 * 
 * 相关算法题目：
 * - LeetCode 150. 逆波兰表达式求值 https://leetcode.cn/problems/evaluate-reverse-polish-notation/
 * - LeetCode 224. 基本计算器 https://leetcode.cn/problems/basic-calculator/
 * - LeetCode 227. 基本计算器 II https://leetcode.cn/problems/basic-calculator-ii/
 * - LeetCode 772. 基本计算器 III https://leetcode.cn/problems/basic-calculator-iii/
 * - LintCode 366. 斐波纳契数列 https://www.lintcode.com/problem/366/
 * - 牛客 NC46 加起来和为目标值的组合 https://www.nowcoder.com/practice/75e6cd5b85ab41c6a7c43359a74e869a
 * - HackerRank Expression Evaluation https://www.hackerrank.com/challenges/expression-evaluation/problem
 * - CodeChef SNAKEEAT https://www.codechef.com/problems/SNAKEEAT
 * - USACO Section 3.4 The Primes https://usaco.org/index.php?page=viewproblem2&cpid=349
 * - AtCoder ABC182 E - Akari https://atcoder.jp/contests/abc182/tasks/abc182_e
 * - 杭电 OJ 1237 简单计算器 https://acm.hdu.edu.cn/showproblem.php?pid=1237
 * - SPOJ ONP - Transform the Expression https://www.spoj.com/problems/ONP/
 * - Codeforces 1077C - Good Array https://codeforces.com/problemset/problem/1077/C
 */

public class ExpressionTree {
    /**
     * 表达式树节点类
     */
    public static class TreeNode {
        String value;       // 节点值：运算符或操作数
        TreeNode left;      // 左子节点
        TreeNode right;     // 右子节点
        boolean isOperator; // 是否为运算符
        
        /**
         * 构造函数
         * @param value 节点值
         */
        public TreeNode(String value) {
            this.value = value;
            this.left = null;
            this.right = null;
            // 判断是否为运算符（+、-、*、/、^）
            this.isOperator = "+-*/^".contains(value);
        }
        
        /**
         * 判断是否为叶子节点（操作数）
         * @return 是否为叶子节点
         */
        public boolean isLeaf() {
            return left == null && right == null;
        }
        
        @Override
        public String toString() {
            return value;
        }
    }
    
    private TreeNode root; // 表达式树的根节点
    
    /**
     * 构造函数
     */
    public ExpressionTree() {
        this.root = null;
    }
    
    /**
     * 从后缀表达式构建表达式树
     * @param postfix 后缀表达式
     */
    public void buildFromPostfix(String postfix) {
        // 分词处理
        String[] tokens = tokenizeExpression(postfix);
        Stack<TreeNode> stack = new Stack<>();
        
        for (String token : tokens) {
            TreeNode node = new TreeNode(token);
            
            if (node.isOperator) {
                // 运算符需要两个操作数，从栈中弹出
                if (stack.size() < 2) {
                    throw new IllegalArgumentException("无效的后缀表达式：" + postfix);
                }
                
                // 注意：先弹出的是右操作数
                node.right = stack.pop();
                node.left = stack.pop();
            }
            // 操作数直接入栈
            stack.push(node);
        }
        
        // 最终栈中应该只有一个节点（根节点）
        if (stack.size() != 1) {
            throw new IllegalArgumentException("无效的后缀表达式：" + postfix);
        }
        
        root = stack.pop();
    }
    
    /**
     * 从前缀表达式构建表达式树
     * @param prefix 前缀表达式
     */
    public void buildFromPrefix(String prefix) {
        // 分词处理并反转顺序
        String[] tokens = tokenizeExpression(prefix);
        // 前缀表达式从右往左处理
        Stack<TreeNode> stack = new Stack<>();
        
        for (int i = tokens.length - 1; i >= 0; i--) {
            String token = tokens[i];
            TreeNode node = new TreeNode(token);
            
            if (node.isOperator) {
                // 运算符需要两个操作数，从栈中弹出
                if (stack.size() < 2) {
                    throw new IllegalArgumentException("无效的前缀表达式：" + prefix);
                }
                
                // 注意：前缀表达式先弹出的是左操作数
                node.left = stack.pop();
                node.right = stack.pop();
            }
            // 操作数直接入栈
            stack.push(node);
        }
        
        // 最终栈中应该只有一个节点（根节点）
        if (stack.size() != 1) {
            throw new IllegalArgumentException("无效的前缀表达式：" + prefix);
        }
        
        root = stack.pop();
    }
    
    /**
     * 从中缀表达式构建表达式树
     * @param infix 中缀表达式
     */
    public void buildFromInfix(String infix) {
        // 中缀表达式转后缀表达式，再构建表达式树
        String postfix = infixToPostfix(infix);
        buildFromPostfix(postfix);
    }
    
    /**
     * 表达式分词处理
     * @param expression 表达式字符串
     * @return 分词后的数组
     */
    private String[] tokenizeExpression(String expression) {
        // 简单的分词处理，将表达式分割成操作数和运算符
        List<String> tokens = new ArrayList<>();
        StringBuilder currentToken = new StringBuilder();
        
        for (int i = 0; i < expression.length(); i++) {
            char c = expression.charAt(i);
            
            // 跳过空白字符
            if (Character.isWhitespace(c)) {
                if (currentToken.length() > 0) {
                    tokens.add(currentToken.toString());
                    currentToken = new StringBuilder();
                }
                continue;
            }
            
            // 处理运算符和括号
            if ("+-*/^()".indexOf(c) != -1) {
                if (currentToken.length() > 0) {
                    tokens.add(currentToken.toString());
                    currentToken = new StringBuilder();
                }
                tokens.add(String.valueOf(c));
            } else {
                // 处理数字或变量
                currentToken.append(c);
            }
        }
        
        // 添加最后一个标记
        if (currentToken.length() > 0) {
            tokens.add(currentToken.toString());
        }
        
        return tokens.toArray(new String[0]);
    }
    
    /**
     * 获取运算符的优先级
     * @param operator 运算符
     * @return 优先级值（数字越大优先级越高）
     */
    private int getPrecedence(String operator) {
        switch (operator) {
            case "+":
            case "-":
                return 1;
            case "*":
            case "/":
                return 2;
            case "^":
                return 3;
            default:
                return 0;
        }
    }
    
    /**
     * 中缀表达式转换为后缀表达式
     * @param infix 中缀表达式
     * @return 后缀表达式
     */
    private String infixToPostfix(String infix) {
        String[] tokens = tokenizeExpression(infix);
        StringBuilder postfix = new StringBuilder();
        Stack<String> stack = new Stack<>();
        
        for (String token : tokens) {
            // 操作数直接添加到结果
            if (!token.equals("(") && !token.equals(")") && !"+-*/^".contains(token)) {
                postfix.append(token).append(" ");
            }
            // 左括号入栈
            else if (token.equals("(")) {
                stack.push(token);
            }
            // 处理右括号
            else if (token.equals(")")) {
                while (!stack.isEmpty() && !stack.peek().equals("(")) {
                    postfix.append(stack.pop()).append(" ");
                }
                if (!stack.isEmpty() && stack.peek().equals("(")) {
                    stack.pop(); // 弹出左括号
                } else {
                    throw new IllegalArgumentException("括号不匹配的表达式：" + infix);
                }
            }
            // 处理运算符
            else {
                while (!stack.isEmpty() && !stack.peek().equals("(") && 
                       getPrecedence(stack.peek()) >= getPrecedence(token)) {
                    postfix.append(stack.pop()).append(" ");
                }
                stack.push(token);
            }
        }
        
        // 将栈中剩余的运算符添加到结果
        while (!stack.isEmpty()) {
            if (stack.peek().equals("(")) {
                throw new IllegalArgumentException("括号不匹配的表达式：" + infix);
            }
            postfix.append(stack.pop()).append(" ");
        }
        
        return postfix.toString().trim();
    }
    
    /**
     * 计算表达式树的值
     * @return 计算结果
     */
    public double evaluate() {
        return evaluate(root);
    }
    
    /**
     * 递归计算表达式树的值
     * @param node 当前节点
     * @return 计算结果
     */
    private double evaluate(TreeNode node) {
        // 空节点，返回0
        if (node == null) {
            return 0;
        }
        
        // 叶节点是操作数，直接转换为数值
        if (node.isLeaf()) {
            try {
                return Double.parseDouble(node.value);
            } catch (NumberFormatException e) {
                throw new IllegalArgumentException("无法解析的操作数：" + node.value);
            }
        }
        
        // 递归计算左右子树的值
        double leftVal = evaluate(node.left);
        double rightVal = evaluate(node.right);
        
        // 根据运算符进行计算
        switch (node.value) {
            case "+":
                return leftVal + rightVal;
            case "-":
                return leftVal - rightVal;
            case "*":
                return leftVal * rightVal;
            case "/":
                if (Math.abs(rightVal) < 1e-10) {
                    throw new ArithmeticException("除零错误");
                }
                return leftVal / rightVal;
            case "^":
                return Math.pow(leftVal, rightVal);
            default:
                throw new IllegalArgumentException("未知的运算符：" + node.value);
        }
    }
    
    /**
     * 获取中缀表达式字符串（带括号）
     * @return 中缀表达式
     */
    public String toInfixNotation() {
        StringBuilder sb = new StringBuilder();
        toInfixNotation(root, sb);
        return sb.toString();
    }
    
    /**
     * 递归生成中缀表达式
     * @param node 当前节点
     * @param sb 结果字符串构建器
     */
    private void toInfixNotation(TreeNode node, StringBuilder sb) {
        if (node == null) {
            return;
        }
        
        // 对于非叶节点（运算符），需要添加括号
        if (!node.isLeaf()) {
            sb.append("(");
        }
        
        // 递归处理左子树
        toInfixNotation(node.left, sb);
        
        // 添加当前节点值
        sb.append(node.value);
        
        // 递归处理右子树
        toInfixNotation(node.right, sb);
        
        // 对于非叶节点（运算符），需要添加右括号
        if (!node.isLeaf()) {
            sb.append(")");
        }
    }
    
    /**
     * 获取后缀表达式字符串
     * @return 后缀表达式
     */
    public String toPostfixNotation() {
        StringBuilder sb = new StringBuilder();
        toPostfixNotation(root, sb);
        return sb.toString().trim();
    }
    
    /**
     * 递归生成后缀表达式（后续遍历）
     * @param node 当前节点
     * @param sb 结果字符串构建器
     */
    private void toPostfixNotation(TreeNode node, StringBuilder sb) {
        if (node == null) {
            return;
        }
        
        // 递归处理左右子树
        toPostfixNotation(node.left, sb);
        toPostfixNotation(node.right, sb);
        
        // 添加当前节点值
        sb.append(node.value).append(" ");
    }
    
    /**
     * 获取前缀表达式字符串
     * @return 前缀表达式
     */
    public String toPrefixNotation() {
        StringBuilder sb = new StringBuilder();
        toPrefixNotation(root, sb);
        return sb.toString().trim();
    }
    
    /**
     * 递归生成前缀表达式（前序遍历）
     * @param node 当前节点
     * @param sb 结果字符串构建器
     */
    private void toPrefixNotation(TreeNode node, StringBuilder sb) {
        if (node == null) {
            return;
        }
        
        // 添加当前节点值
        sb.append(node.value).append(" ");
        
        // 递归处理左右子树
        toPrefixNotation(node.left, sb);
        toPrefixNotation(node.right, sb);
    }
    
    /**
     * 打印表达式树结构
     */
    public void printTree() {
        System.out.println("表达式树结构:");
        printTree(root, 0);
    }
    
    /**
     * 递归打印树结构
     * @param node 当前节点
     * @param level 当前节点深度
     */
    private void printTree(TreeNode node, int level) {
        if (node == null) {
            return;
        }
        
        // 先打印右子树（在上层）
        printTree(node.right, level + 1);
        
        // 打印当前节点
        for (int i = 0; i < level; i++) {
            System.out.print("    ");
        }
        System.out.println(node.value);
        
        // 打印左子树（在下层）
        printTree(node.left, level + 1);
    }
    
    /**
     * 获取树的高度
     * @return 树的高度
     */
    public int getHeight() {
        return getHeight(root);
    }
    
    /**
     * 递归计算树的高度
     * @param node 当前节点
     * @return 以该节点为根的子树高度
     */
    private int getHeight(TreeNode node) {
        if (node == null) {
            return 0;
        }
        
        int leftHeight = getHeight(node.left);
        int rightHeight = getHeight(node.right);
        
        return Math.max(leftHeight, rightHeight) + 1;
    }
    
    /**
     * 获取节点数量
     * @return 节点数量
     */
    public int getNodeCount() {
        return getNodeCount(root);
    }
    
    /**
     * 递归计算节点数量
     * @param node 当前节点
     * @return 以该节点为根的子树节点数量
     */
    private int getNodeCount(TreeNode node) {
        if (node == null) {
            return 0;
        }
        
        return getNodeCount(node.left) + getNodeCount(node.right) + 1;
    }
    
    /**
     * 获取叶节点数量（操作数数量）
     * @return 叶节点数量
     */
    public int getLeafCount() {
        return getLeafCount(root);
    }
    
    /**
     * 递归计算叶节点数量
     * @param node 当前节点
     * @return 以该节点为根的子树叶节点数量
     */
    private int getLeafCount(TreeNode node) {
        if (node == null) {
            return 0;
        }
        
        if (node.isLeaf()) {
            return 1;
        }
        
        return getLeafCount(node.left) + getLeafCount(node.right);
    }
    
    /**
     * 获取运算符节点数量
     * @return 运算符节点数量
     */
    public int getOperatorCount() {
        return getOperatorCount(root);
    }
    
    /**
     * 递归计算运算符节点数量
     * @param node 当前节点
     * @return 以该节点为根的子树运算符节点数量
     */
    private int getOperatorCount(TreeNode node) {
        if (node == null) {
            return 0;
        }
        
        int count = node.isOperator ? 1 : 0;
        return count + getOperatorCount(node.left) + getOperatorCount(node.right);
    }
    
    /**
     * 前序遍历表达式树
     * @return 前序遍历结果列表
     */
    public List<String> preorderTraversal() {
        List<String> result = new ArrayList<>();
        preorderTraversal(root, result);
        return result;
    }
    
    /**
     * 递归进行前序遍历
     * @param node 当前节点
     * @param result 结果列表
     */
    private void preorderTraversal(TreeNode node, List<String> result) {
        if (node == null) {
            return;
        }
        
        result.add(node.value);
        preorderTraversal(node.left, result);
        preorderTraversal(node.right, result);
    }
    
    /**
     * 中序遍历表达式树
     * @return 中序遍历结果列表
     */
    public List<String> inorderTraversal() {
        List<String> result = new ArrayList<>();
        inorderTraversal(root, result);
        return result;
    }
    
    /**
     * 递归进行中序遍历
     * @param node 当前节点
     * @param result 结果列表
     */
    private void inorderTraversal(TreeNode node, List<String> result) {
        if (node == null) {
            return;
        }
        
        inorderTraversal(node.left, result);
        result.add(node.value);
        inorderTraversal(node.right, result);
    }
    
    /**
     * 后序遍历表达式树
     * @return 后序遍历结果列表
     */
    public List<String> postorderTraversal() {
        List<String> result = new ArrayList<>();
        postorderTraversal(root, result);
        return result;
    }
    
    /**
     * 递归进行后序遍历
     * @param node 当前节点
     * @param result 结果列表
     */
    private void postorderTraversal(TreeNode node, List<String> result) {
        if (node == null) {
            return;
        }
        
        postorderTraversal(node.left, result);
        postorderTraversal(node.right, result);
        result.add(node.value);
    }
    
    /**
     * 层序遍历表达式树
     * @return 层序遍历结果列表
     */
    public List<List<String>> levelOrderTraversal() {
        List<List<String>> result = new ArrayList<>();
        if (root == null) {
            return result;
        }
        
        Queue<TreeNode> queue = new LinkedList<>();
        queue.offer(root);
        
        while (!queue.isEmpty()) {
            int levelSize = queue.size();
            List<String> currentLevel = new ArrayList<>();
            
            for (int i = 0; i < levelSize; i++) {
                TreeNode node = queue.poll();
                currentLevel.add(node.value);
                
                if (node.left != null) {
                    queue.offer(node.left);
                }
                if (node.right != null) {
                    queue.offer(node.right);
                }
            }
            
            result.add(currentLevel);
        }
        
        return result;
    }
    
    /**
     * 复制表达式树
     * @return 复制的表达式树
     */
    public ExpressionTree copy() {
        ExpressionTree newTree = new ExpressionTree();
        newTree.root = copyNode(root);
        return newTree;
    }
    
    /**
     * 递归复制节点
     * @param node 要复制的节点
     * @return 复制的节点
     */
    private TreeNode copyNode(TreeNode node) {
        if (node == null) {
            return null;
        }
        
        TreeNode newNode = new TreeNode(node.value);
        newNode.left = copyNode(node.left);
        newNode.right = copyNode(node.right);
        return newNode;
    }
    
    /**
     * 判断两个表达式树是否相等
     * @param other 另一个表达式树
     * @return 是否相等
     */
    public boolean equals(ExpressionTree other) {
        if (other == null) {
            return false;
        }
        return equalsNode(root, other.root);
    }
    
    /**
     * 递归判断两个节点是否相等
     * @param node1 第一个节点
     * @param node2 第二个节点
     * @return 是否相等
     */
    private boolean equalsNode(TreeNode node1, TreeNode node2) {
        if (node1 == null && node2 == null) {
            return true;
        }
        if (node1 == null || node2 == null) {
            return false;
        }
        
        return node1.value.equals(node2.value) && 
               equalsNode(node1.left, node2.left) && 
               equalsNode(node1.right, node2.right);
    }
    
    /**
     * 测试主函数
     * @param args 命令行参数
     */
    public static void main(String[] args) {
        try {
            // 创建表达式树实例
            ExpressionTree tree = new ExpressionTree();
            
            // 测试从中缀表达式构建
            System.out.println("===== 从中缀表达式构建 =====");
            String infixExpression = "3 + 4 * 2 / ( 1 - 5 ) ^ 2 ^ 3";
            tree.buildFromInfix(infixExpression);
            
            // 打印树结构
            tree.printTree();
            
            // 显示不同形式的表达式
            System.out.println("中缀表达式: " + tree.toInfixNotation());
            System.out.println("后缀表达式: " + tree.toPostfixNotation());
            System.out.println("前缀表达式: " + tree.toPrefixNotation());
            
            // 计算表达式值
            System.out.println("表达式值: " + tree.evaluate());
            
            // 显示树的统计信息
            System.out.println("树高: " + tree.getHeight());
            System.out.println("节点数: " + tree.getNodeCount());
            System.out.println("叶节点数(操作数): " + tree.getLeafCount());
            System.out.println("运算符节点数: " + tree.getOperatorCount());
            
            // 遍历结果
            System.out.println("前序遍历: " + String.join(" ", tree.preorderTraversal()));
            System.out.println("中序遍历: " + String.join(" ", tree.inorderTraversal()));
            System.out.println("后序遍历: " + String.join(" ", tree.postorderTraversal()));
            
            // 层序遍历
            System.out.println("层序遍历:");
            List<List<String>> levelOrder = tree.levelOrderTraversal();
            for (int i = 0; i < levelOrder.size(); i++) {
                System.out.println("层 " + (i + 1) + ": " + String.join(" ", levelOrder.get(i)));
            }
            
            // 测试从后缀表达式构建
            System.out.println("\n===== 从后缀表达式构建 =====");
            ExpressionTree tree2 = new ExpressionTree();
            String postfixExpression = "3 4 2 * 1 5 - 2 3 ^ ^ / +";
            tree2.buildFromPostfix(postfixExpression);
            System.out.println("构建的表达式值: " + tree2.evaluate());
            System.out.println("两棵树是否相等: " + tree.equals(tree2));
            
            // 测试从前缀表达式构建
            System.out.println("\n===== 从前缀表达式构建 =====");
            ExpressionTree tree3 = new ExpressionTree();
            String prefixExpression = "+ 3 / * 4 2 ^ ^ - 1 5 2 3";
            tree3.buildFromPrefix(prefixExpression);
            System.out.println("构建的表达式值: " + tree3.evaluate());
            System.out.println("与原始树是否相等: " + tree.equals(tree3));
            
            // 测试表达式复制
            ExpressionTree copyTree = tree.copy();
            System.out.println("\n===== 表达式树复制 =====");
            System.out.println("复制树的表达式值: " + copyTree.evaluate());
            System.out.println("与原始树是否相等: " + tree.equals(copyTree));
            
        } catch (Exception e) {
            System.err.println("错误: " + e.getMessage());
            e.printStackTrace();
        }
    }
}

===============================================

文件: expression_tree.cpp
===============================================
#include <iostream>
#include <string>
#include <vector>
#include <stack>
#include <queue>
#include <memory>
#include <cmath>
#include <sstream>
#include <stdexcept>
#include <iomanip>
#include <algorithm>

/**
 * 表达式树（Expression Tree）实现
 * 表达式树是一种用于表示数学表达式的二叉树
 * 其中内部节点表示运算符，叶节点表示操作数
 * 
 * 常见应用场景：
 * 1. 表达式计算与求值
 * 2. 表达式简化
 * 3. 表达式转换（中缀转后缀/前缀）
 * 4. 编译器和解释器中的语法树
 * 5. 数学表达式的可视化
 * 6. 布尔表达式的表示和求值
 * 7. 科学计算和计算器应用
 * 
 * 相关算法题目：
 * - LeetCode 150. 逆波兰表达式求值 https://leetcode.cn/problems/evaluate-reverse-polish-notation/
 * - LeetCode 224. 基本计算器 https://leetcode.cn/problems/basic-calculator/
 * - LeetCode 227. 基本计算器 II https://leetcode.cn/problems/basic-calculator-ii/
 * - LeetCode 772. 基本计算器 III https://leetcode.cn/problems/basic-calculator-iii/
 * - LintCode 366. 斐波纳契数列 https://www.lintcode.com/problem/366/
 * - 牛客 NC46 加起来和为目标值的组合 https://www.nowcoder.com/practice/75e6cd5b85ab41c6a7c43359a74e869a
 * - HackerRank Expression Evaluation https://www.hackerrank.com/challenges/expression-evaluation/problem
 * - CodeChef SNAKEEAT https://www.codechef.com/problems/SNAKEEAT
 * - USACO Section 3.4 The Primes https://usaco.org/index.php?page=viewproblem2&cpid=349
 * - AtCoder ABC182 E - Akari https://atcoder.jp/contests/abc182/tasks/abc182_e
 * - 杭电 OJ 1237 简单计算器 https://acm.hdu.edu.cn/showproblem.php?pid=1237
 * - SPOJ ONP - Transform the Expression https://www.spoj.com/problems/ONP/
 * - Codeforces 1077C - Good Array https://codeforces.com/problemset/problem/1077/C
 */

// 表达式树节点类
class TreeNode {
public:
    std::string value;       // 节点值：运算符或操作数
    std::shared_ptr<TreeNode> left;      // 左子节点
    std::shared_ptr<TreeNode> right;     // 右子节点
    bool isOperator;         // 是否为运算符
    
    /**
     * 构造函数
     * @param val 节点值
     */
    TreeNode(const std::string& val) : value(val), left(nullptr), right(nullptr) {
        // 判断是否为运算符（+、-、*、/、^）
        isOperator = "+-*/^".find(value) != std::string::npos;
    }
    
    /**
     * 判断是否为叶子节点（操作数）
     * @return 是否为叶子节点
     */
    bool isLeaf() const {
        return left == nullptr && right == nullptr;
    }
    
    /**
     * 字符串表示
     * @return 节点值的字符串
     */
    std::string toString() const {
        return value;
    }
};

// 表达式树类
class ExpressionTree {
private:
    std::shared_ptr<TreeNode> root;  // 表达式树的根节点
    
    /**
     * 表达式分词处理
     * @param expression 表达式字符串
     * @return 分词后的标记向量
     */
    std::vector<std::string> tokenizeExpression(const std::string& expression) {
        std::vector<std::string> tokens;
        std::string currentToken;
        
        for (char c : expression) {
            // 跳过空白字符
            if (std::isspace(c)) {
                if (!currentToken.empty()) {
                    tokens.push_back(currentToken);
                    currentToken.clear();
                }
                continue;
            }
            
            // 处理运算符和括号
            if ("+-*/^()".find(c) != std::string::npos) {
                if (!currentToken.empty()) {
                    tokens.push_back(currentToken);
                    currentToken.clear();
                }
                tokens.push_back(std::string(1, c));
            } else {
                // 处理数字或变量
                currentToken += c;
            }
        }
        
        // 添加最后一个标记
        if (!currentToken.empty()) {
            tokens.push_back(currentToken);
        }
        
        return tokens;
    }
    
    /**
     * 获取运算符的优先级
     * @param op 运算符
     * @return 优先级值（数字越大优先级越高）
     */
    int getPrecedence(const std::string& op) {
        if (op == "+") return 1;
        if (op == "-") return 1;
        if (op == "*") return 2;
        if (op == "/") return 2;
        if (op == "^") return 3;
        return 0;
    }
    
    /**
     * 中缀表达式转换为后缀表达式
     * @param infix 中缀表达式
     * @return 后缀表达式字符串
     */
    std::string infixToPostfix(const std::string& infix) {
        std::vector<std::string> tokens = tokenizeExpression(infix);
        std::vector<std::string> postfixTokens;
        std::stack<std::string> stack;
        
        for (const std::string& token : tokens) {
            // 操作数直接添加到结果
            if ("+-*/^()".find(token) == std::string::npos) {
                postfixTokens.push_back(token);
            }
            // 左括号入栈
            else if (token == "(") {
                stack.push(token);
            }
            // 处理右括号
            else if (token == ")") {
                while (!stack.empty() && stack.top() != "(") {
                    postfixTokens.push_back(stack.top());
                    stack.pop();
                }
                if (!stack.empty() && stack.top() == "(") {
                    stack.pop();  // 弹出左括号
                } else {
                    throw std::invalid_argument("括号不匹配的表达式: " + infix);
                }
            }
            // 处理运算符
            else {
                while (!stack.empty() && stack.top() != "(" && 
                       getPrecedence(stack.top()) >= getPrecedence(token)) {
                    postfixTokens.push_back(stack.top());
                    stack.pop();
                }
                stack.push(token);
            }
        }
        
        // 将栈中剩余的运算符添加到结果
        while (!stack.empty()) {
            if (stack.top() == "(") {
                throw std::invalid_argument("括号不匹配的表达式: " + infix);
            }
            postfixTokens.push_back(stack.top());
            stack.pop();
        }
        
        // 构建后缀表达式字符串
        std::stringstream ss;
        for (size_t i = 0; i < postfixTokens.size(); ++i) {
            ss << postfixTokens[i];
            if (i < postfixTokens.size() - 1) {
                ss << " ";
            }
        }
        
        return ss.str();
    }
    
    /**
     * 递归计算表达式树的值
     * @param node 当前节点
     * @return 计算结果
     */
    double evaluateRecursive(const std::shared_ptr<TreeNode>& node) {
        // 空节点，返回0
        if (!node) {
            return 0.0;
        }
        
        // 叶节点是操作数，直接转换为数值
        if (node->isLeaf()) {
            try {
                return std::stod(node->value);
            } catch (const std::invalid_argument& e) {
                throw std::invalid_argument("无法解析的操作数: " + node->value);
            } catch (const std::out_of_range& e) {
                throw std::out_of_range("数值超出范围: " + node->value);
            }
        }
        
        // 递归计算左右子树的值
        double leftVal = evaluateRecursive(node->left);
        double rightVal = evaluateRecursive(node->right);
        
        // 根据运算符进行计算
        if (node->value == "+") {
            return leftVal + rightVal;
        } else if (node->value == "-") {
            return leftVal - rightVal;
        } else if (node->value == "*") {
            return leftVal * rightVal;
        } else if (node->value == "/") {
            if (std::abs(rightVal) < 1e-10) {
                throw std::runtime_error("除零错误");
            }
            return leftVal / rightVal;
        } else if (node->value == "^") {
            return std::pow(leftVal, rightVal);
        } else {
            throw std::runtime_error("未知的运算符: " + node->value);
        }
    }
    
    /**
     * 递归生成中缀表达式
     * @param node 当前节点
     * @param result 结果字符串构建器
     */
    void toInfixNotationRecursive(const std::shared_ptr<TreeNode>& node, std::stringstream& result) {
        if (!node) {
            return;
        }
        
        // 对于非叶节点（运算符），需要添加括号
        if (!node->isLeaf()) {
            result << "(";
        }
        
        // 递归处理左子树
        toInfixNotationRecursive(node->left, result);
        
        // 添加当前节点值
        result << node->value;
        
        // 递归处理右子树
        toInfixNotationRecursive(node->right, result);
        
        // 对于非叶节点（运算符），需要添加右括号
        if (!node->isLeaf()) {
            result << ")";
        }
    }
    
    /**
     * 递归生成后缀表达式（后续遍历）
     * @param node 当前节点
     * @param result 结果字符串构建器
     */
    void toPostfixNotationRecursive(const std::shared_ptr<TreeNode>& node, std::stringstream& result) {
        if (!node) {
            return;
        }
        
        // 递归处理左右子树
        toPostfixNotationRecursive(node->left, result);
        toPostfixNotationRecursive(node->right, result);
        
        // 添加当前节点值
        result << node->value << " ";
    }
    
    /**
     * 递归生成前缀表达式（前序遍历）
     * @param node 当前节点
     * @param result 结果字符串构建器
     */
    void toPrefixNotationRecursive(const std::shared_ptr<TreeNode>& node, std::stringstream& result) {
        if (!node) {
            return;
        }
        
        // 添加当前节点值
        result << node->value << " ";
        
        // 递归处理左右子树
        toPrefixNotationRecursive(node->left, result);
        toPrefixNotationRecursive(node->right, result);
    }
    
    /**
     * 递归打印树结构
     * @param node 当前节点
     * @param level 当前节点深度
     */
    void printTreeRecursive(const std::shared_ptr<TreeNode>& node, int level) {
        if (!node) {
            return;
        }
        
        // 先打印右子树（在上层）
        printTreeRecursive(node->right, level + 1);
        
        // 打印当前节点
        for (int i = 0; i < level; ++i) {
            std::cout << "    ";
        }
        std::cout << node->value << std::endl;
        
        // 打印左子树（在下层）
        printTreeRecursive(node->left, level + 1);
    }
    
    /**
     * 递归计算树的高度
     * @param node 当前节点
     * @return 以该节点为根的子树高度
     */
    int getHeightRecursive(const std::shared_ptr<TreeNode>& node) {
        if (!node) {
            return 0;
        }
        
        int leftHeight = getHeightRecursive(node->left);
        int rightHeight = getHeightRecursive(node->right);
        
        return std::max(leftHeight, rightHeight) + 1;
    }
    
    /**
     * 递归计算节点数量
     * @param node 当前节点
     * @return 以该节点为根的子树节点数量
     */
    int getNodeCountRecursive(const std::shared_ptr<TreeNode>& node) {
        if (!node) {
            return 0;
        }
        
        return getNodeCountRecursive(node->left) + 
               getNodeCountRecursive(node->right) + 1;
    }
    
    /**
     * 递归计算叶节点数量
     * @param node 当前节点
     * @return 以该节点为根的子树叶节点数量
     */
    int getLeafCountRecursive(const std::shared_ptr<TreeNode>& node) {
        if (!node) {
            return 0;
        }
        
        if (node->isLeaf()) {
            return 1;
        }
        
        return getLeafCountRecursive(node->left) + 
               getLeafCountRecursive(node->right);
    }
    
    /**
     * 递归计算运算符节点数量
     * @param node 当前节点
     * @return 以该节点为根的子树运算符节点数量
     */
    int getOperatorCountRecursive(const std::shared_ptr<TreeNode>& node) {
        if (!node) {
            return 0;
        }
        
        int count = node->isOperator ? 1 : 0;
        return count + getOperatorCountRecursive(node->left) + 
               getOperatorCountRecursive(node->right);
    }
    
    /**
     * 递归进行前序遍历
     * @param node 当前节点
     * @param result 结果向量
     */
    void preorderTraversalRecursive(const std::shared_ptr<TreeNode>& node, std::vector<std::string>& result) {
        if (!node) {
            return;
        }
        
        result.push_back(node->value);
        preorderTraversalRecursive(node->left, result);
        preorderTraversalRecursive(node->right, result);
    }
    
    /**
     * 递归进行中序遍历
     * @param node 当前节点
     * @param result 结果向量
     */
    void inorderTraversalRecursive(const std::shared_ptr<TreeNode>& node, std::vector<std::string>& result) {
        if (!node) {
            return;
        }
        
        inorderTraversalRecursive(node->left, result);
        result.push_back(node->value);
        inorderTraversalRecursive(node->right, result);
    }
    
    /**
     * 递归进行后序遍历
     * @param node 当前节点
     * @param result 结果向量
     */
    void postorderTraversalRecursive(const std::shared_ptr<TreeNode>& node, std::vector<std::string>& result) {
        if (!node) {
            return;
        }
        
        postorderTraversalRecursive(node->left, result);
        postorderTraversalRecursive(node->right, result);
        result.push_back(node->value);
    }
    
    /**
     * 递归复制节点
     * @param node 要复制的节点
     * @return 复制的节点
     */
    std::shared_ptr<TreeNode> copyNode(const std::shared_ptr<TreeNode>& node) {
        if (!node) {
            return nullptr;
        }
        
        std::shared_ptr<TreeNode> newNode = std::make_shared<TreeNode>(node->value);
        newNode->left = copyNode(node->left);
        newNode->right = copyNode(node->right);
        return newNode;
    }
    
    /**
     * 递归判断两个节点是否相等
     * @param node1 第一个节点
     * @param node2 第二个节点
     * @return 是否相等
     */
    bool equalsNode(const std::shared_ptr<TreeNode>& node1, const std::shared_ptr<TreeNode>& node2) {
        if (!node1 && !node2) {
            return true;
        }
        if (!node1 || !node2) {
            return false;
        }
        
        return (node1->value == node2->value && 
                equalsNode(node1->left, node2->left) && 
                equalsNode(node1->right, node2->right));
    }

public:
    /**
     * 构造函数
     */
    ExpressionTree() : root(nullptr) {}
    
    /**
     * 从后缀表达式构建表达式树
     * @param postfix 后缀表达式
     */
    void buildFromPostfix(const std::string& postfix) {
        // 分词处理
        std::vector<std::string> tokens = tokenizeExpression(postfix);
        std::stack<std::shared_ptr<TreeNode>> stack;
        
        for (const std::string& token : tokens) {
            auto node = std::make_shared<TreeNode>(token);
            
            if (node->isOperator) {
                // 运算符需要两个操作数，从栈中弹出
                if (stack.size() < 2) {
                    throw std::invalid_argument("无效的后缀表达式: " + postfix);
                }
                
                // 注意：先弹出的是右操作数
                node->right = stack.top();
                stack.pop();
                node->left = stack.top();
                stack.pop();
            }
            // 操作数或运算符节点入栈
            stack.push(node);
        }
        
        // 最终栈中应该只有一个节点（根节点）
        if (stack.size() != 1) {
            throw std::invalid_argument("无效的后缀表达式: " + postfix);
        }
        
        root = stack.top();
        stack.pop();
    }
    
    /**
     * 从前缀表达式构建表达式树
     * @param prefix 前缀表达式
     */
    void buildFromPrefix(const std::string& prefix) {
        // 分词处理
        std::vector<std::string> tokens = tokenizeExpression(prefix);
        // 前缀表达式从右往左处理
        std::stack<std::shared_ptr<TreeNode>> stack;
        
        for (auto it = tokens.rbegin(); it != tokens.rend(); ++it) {
            const std::string& token = *it;
            auto node = std::make_shared<TreeNode>(token);
            
            if (node->isOperator) {
                // 运算符需要两个操作数，从栈中弹出
                if (stack.size() < 2) {
                    throw std::invalid_argument("无效的前缀表达式: " + prefix);
                }
                
                // 注意：前缀表达式先弹出的是左操作数
                node->left = stack.top();
                stack.pop();
                node->right = stack.top();
                stack.pop();
            }
            // 操作数或运算符节点入栈
            stack.push(node);
        }
        
        // 最终栈中应该只有一个节点（根节点）
        if (stack.size() != 1) {
            throw std::invalid_argument("无效的前缀表达式: " + prefix);
        }
        
        root = stack.top();
        stack.pop();
    }
    
    /**
     * 从中缀表达式构建表达式树
     * @param infix 中缀表达式
     */
    void buildFromInfix(const std::string& infix) {
        // 中缀表达式转后缀表达式，再构建表达式树
        std::string postfix = infixToPostfix(infix);
        buildFromPostfix(postfix);
    }
    
    /**
     * 计算表达式树的值
     * @return 计算结果
     */
    double evaluate() {
        if (!root) {
            throw std::runtime_error("表达式树为空");
        }
        return evaluateRecursive(root);
    }
    
    /**
     * 获取中缀表达式字符串（带括号）
     * @return 中缀表达式
     */
    std::string toInfixNotation() {
        std::stringstream ss;
        toInfixNotationRecursive(root, ss);
        return ss.str();
    }
    
    /**
     * 获取后缀表达式字符串
     * @return 后缀表达式
     */
    std::string toPostfixNotation() {
        std::stringstream ss;
        toPostfixNotationRecursive(root, ss);
        std::string result = ss.str();
        // 移除最后的空格
        if (!result.empty() && result.back() == ' ') {
            result.pop_back();
        }
        return result;
    }
    
    /**
     * 获取前缀表达式字符串
     * @return 前缀表达式
     */
    std::string toPrefixNotation() {
        std::stringstream ss;
        toPrefixNotationRecursive(root, ss);
        std::string result = ss.str();
        // 移除最后的空格
        if (!result.empty() && result.back() == ' ') {
            result.pop_back();
        }
        return result;
    }
    
    /**
     * 打印表达式树结构
     */
    void printTree() {
        std::cout << "表达式树结构:" << std::endl;
        printTreeRecursive(root, 0);
    }
    
    /**
     * 获取树的高度
     * @return 树的高度
     */
    int getHeight() {
        return getHeightRecursive(root);
    }
    
    /**
     * 获取节点数量
     * @return 节点数量
     */
    int getNodeCount() {
        return getNodeCountRecursive(root);
    }
    
    /**
     * 获取叶节点数量（操作数数量）
     * @return 叶节点数量
     */
    int getLeafCount() {
        return getLeafCountRecursive(root);
    }
    
    /**
     * 获取运算符节点数量
     * @return 运算符节点数量
     */
    int getOperatorCount() {
        return getOperatorCountRecursive(root);
    }
    
    /**
     * 前序遍历表达式树
     * @return 前序遍历结果向量
     */
    std::vector<std::string> preorderTraversal() {
        std::vector<std::string> result;
        preorderTraversalRecursive(root, result);
        return result;
    }
    
    /**
     * 中序遍历表达式树
     * @return 中序遍历结果向量
     */
    std::vector<std::string> inorderTraversal() {
        std::vector<std::string> result;
        inorderTraversalRecursive(root, result);
        return result;
    }
    
    /**
     * 后序遍历表达式树
     * @return 后序遍历结果向量
     */
    std::vector<std::string> postorderTraversal() {
        std::vector<std::string> result;
        postorderTraversalRecursive(root, result);
        return result;
    }
    
    /**
     * 层序遍历表达式树
     * @return 层序遍历结果向量，每个子向量代表一层
     */
    std::vector<std::vector<std::string>> levelOrderTraversal() {
        std::vector<std::vector<std::string>> result;
        if (!root) {
            return result;
        }
        
        std::queue<std::shared_ptr<TreeNode>> queue;
        queue.push(root);
        
        while (!queue.empty()) {
            int levelSize = queue.size();
            std::vector<std::string> currentLevel;
            
            for (int i = 0; i < levelSize; ++i) {
                auto node = queue.front();
                queue.pop();
                currentLevel.push_back(node->value);
                
                if (node->left) {
                    queue.push(node->left);
                }
                if (node->right) {
                    queue.push(node->right);
                }
            }
            
            result.push_back(currentLevel);
        }
        
        return result;
    }
    
    /**
     * 复制表达式树
     * @return 复制的表达式树
     */
    std::shared_ptr<ExpressionTree> copy() {
        auto newTree = std::make_shared<ExpressionTree>();
        newTree->root = copyNode(root);
        return newTree;
    }
    
    /**
     * 判断两个表达式树是否相等
     * @param other 另一个表达式树
     * @return 是否相等
     */
    bool equals(const std::shared_ptr<ExpressionTree>& other) {
        if (!other) {
            return false;
        }
        return equalsNode(root, other->root);
    }
    
    /**
     * 获取根节点
     * @return 根节点
     */
    std::shared_ptr<TreeNode> getRoot() {
        return root;
    }
};

// 用于输出向量的辅助函数
template <typename T>
void printVector(const std::vector<T>& vec, const std::string& separator = " ") {
    for (size_t i = 0; i < vec.size(); ++i) {
        std::cout << vec[i];
        if (i < vec.size() - 1) {
            std::cout << separator;
        }
    }
    std::cout << std::endl;
}

// 主函数，用于测试表达式树
int main() {
    try {
        // 创建表达式树实例
        std::shared_ptr<ExpressionTree> tree = std::make_shared<ExpressionTree>();
        
        // 测试从中缀表达式构建
        std::cout << "===== 从中缀表达式构建 =====" << std::endl;
        std::string infixExpression = "3 + 4 * 2 / ( 1 - 5 ) ^ 2 ^ 3";
        tree->buildFromInfix(infixExpression);
        
        // 打印树结构
        tree->printTree();
        
        // 显示不同形式的表达式
        std::cout << "中缀表达式: " << tree->toInfixNotation() << std::endl;
        std::cout << "后缀表达式: " << tree->toPostfixNotation() << std::endl;
        std::cout << "前缀表达式: " << tree->toPrefixNotation() << std::endl;
        
        // 计算表达式值
        double result = tree->evaluate();
        std::cout << "表达式值: " << std::fixed << std::setprecision(6) << result << std::endl;
        
        // 显示树的统计信息
        std::cout << "树高: " << tree->getHeight() << std::endl;
        std::cout << "节点数: " << tree->getNodeCount() << std::endl;
        std::cout << "叶节点数(操作数): " << tree->getLeafCount() << std::endl;
        std::cout << "运算符节点数: " << tree->getOperatorCount() << std::endl;
        
        // 遍历结果
        std::cout << "前序遍历: ";
        printVector(tree->preorderTraversal());
        
        std::cout << "中序遍历: ";
        printVector(tree->inorderTraversal());
        
        std::cout << "后序遍历: ";
        printVector(tree->postorderTraversal());
        
        // 层序遍历
        std::cout << "层序遍历:" << std::endl;
        auto levelOrder = tree->levelOrderTraversal();
        for (size_t i = 0; i < levelOrder.size(); ++i) {
            std::cout << "层 " << (i + 1) << ": ";
            printVector(levelOrder[i]);
        }
        
        // 测试从后缀表达式构建
        std::cout << "\n===== 从后缀表达式构建 =====" << std::endl;
        std::shared_ptr<ExpressionTree> tree2 = std::make_shared<ExpressionTree>();
        std::string postfixExpression = "3 4 2 * 1 5 - 2 3 ^ ^ / +";
        tree2->buildFromPostfix(postfixExpression);
        std::cout << "构建的表达式值: " << std::fixed << std::setprecision(6) << tree2->evaluate() << std::endl;
        std::cout << "两棵树是否相等: " << (tree->equals(tree2) ? "true" : "false") << std::endl;
        
        // 测试从前缀表达式构建
        std::cout << "\n===== 从前缀表达式构建 =====" << std::endl;
        std::shared_ptr<ExpressionTree> tree3 = std::make_shared<ExpressionTree>();
        std::string prefixExpression = "+ 3 / * 4 2 ^ ^ - 1 5 2 3";
        tree3->buildFromPrefix(prefixExpression);
        std::cout << "构建的表达式值: " << std::fixed << std::setprecision(6) << tree3->evaluate() << std::endl;
        std::cout << "与原始树是否相等: " << (tree->equals(tree3) ? "true" : "false") << std::endl;
        
        // 测试表达式复制
        auto copyTree = tree->copy();
        std::cout << "\n===== 表达式树复制 =====" << std::endl;
        std::cout << "复制树的表达式值: " << std::fixed << std::setprecision(6) << copyTree->evaluate() << std::endl;
        std::cout << "与原始树是否相等: " << (tree->equals(copyTree) ? "true" : "false") << std::endl;
        
        // 测试更复杂的表达式
        std::cout << "\n===== 复杂表达式测试 =====" << std::endl;
        std::shared_ptr<ExpressionTree> complexTree = std::make_shared<ExpressionTree>();
        complexTree->buildFromInfix("((2 + 3) * (5 - 2)) / (1 + 2 * 3)");
        std::cout << "复杂表达式值: " << std::fixed << std::setprecision(6) << complexTree->evaluate() << std::endl;
        
    } catch (const std::exception& e) {
        std::cerr << "错误: " << e.what() << std::endl;
        return 1;
    }
    
    return 0;
}

===============================================

文件: expression_tree.py
===============================================
from typing import List, Optional, Tuple, Union, Dict, Set, Any
import math
from collections import deque

"""
表达式树（Expression Tree）实现
表达式树是一种用于表示数学表达式的二叉树
其中内部节点表示运算符，叶节点表示操作数

常见应用场景：
1. 表达式计算与求值
2. 表达式简化
3. 表达式转换（中缀转后缀/前缀）
4. 编译器和解释器中的语法树
5. 数学表达式的可视化
6. 布尔表达式的表示和求值
7. 科学计算和计算器应用

相关算法题目：
- LeetCode 150. 逆波兰表达式求值 https://leetcode.cn/problems/evaluate-reverse-polish-notation/
- LeetCode 224. 基本计算器 https://leetcode.cn/problems/basic-calculator/
- LeetCode 227. 基本计算器 II https://leetcode.cn/problems/basic-calculator-ii/
- LeetCode 772. 基本计算器 III https://leetcode.cn/problems/basic-calculator-iii/
- LintCode 366. 斐波纳契数列 https://www.lintcode.com/problem/366/
- 牛客 NC46 加起来和为目标值的组合 https://www.nowcoder.com/practice/75e6cd5b85ab41c6a7c43359a74e869a
- HackerRank Expression Evaluation https://www.hackerrank.com/challenges/expression-evaluation/problem
- CodeChef SNAKEEAT https://www.codechef.com/problems/SNAKEEAT
- USACO Section 3.4 The Primes https://usaco.org/index.php?page=viewproblem2&cpid=349
- AtCoder ABC182 E - Akari https://atcoder.jp/contests/abc182/tasks/abc182_e
- 杭电 OJ 1237 简单计算器 https://acm.hdu.edu.cn/showproblem.php?pid=1237
- SPOJ ONP - Transform the Expression https://www.spoj.com/problems/ONP/
- Codeforces 1077C - Good Array https://codeforces.com/problemset/problem/1077/C
"""


class TreeNode:
    """
    表达式树节点类
    """
    def __init__(self, value: str):
        """
        初始化节点
        
        Args:
            value: 节点值，可以是运算符或操作数
        """
        self.value = value
        self.left: Optional[TreeNode] = None
        self.right: Optional[TreeNode] = None
        # 判断是否为运算符（+、-、*、/、^）
        self.is_operator = value in '+-*/^'
    
    def is_leaf(self) -> bool:
        """
        判断是否为叶子节点（操作数）
        
        Returns:
            bool: 是否为叶子节点
        """
        return self.left is None and self.right is None
    
    def __str__(self) -> str:
        return self.value


class ExpressionTree:
    """
    表达式树类，支持从各种表示法构建并执行表达式计算
    """
    def __init__(self):
        """
        初始化表达式树
        """
        self.root: Optional[TreeNode] = None
    
    def build_from_postfix(self, postfix: str) -> None:
        """
        从后缀表达式构建表达式树
        
        Args:
            postfix: 后缀表达式字符串
        
        Raises:
            ValueError: 如果后缀表达式无效
        """
        # 分词处理
        tokens = self._tokenize_expression(postfix)
        stack = []
        
        for token in tokens:
            node = TreeNode(token)
            
            if node.is_operator:
                # 运算符需要两个操作数，从栈中弹出
                if len(stack) < 2:
                    raise ValueError(f"无效的后缀表达式: {postfix}")
                
                # 注意：先弹出的是右操作数
                node.right = stack.pop()
                node.left = stack.pop()
            
            # 操作数或运算符节点入栈
            stack.append(node)
        
        # 最终栈中应该只有一个节点（根节点）
        if len(stack) != 1:
            raise ValueError(f"无效的后缀表达式: {postfix}")
        
        self.root = stack.pop()
    
    def build_from_prefix(self, prefix: str) -> None:
        """
        从前缀表达式构建表达式树
        
        Args:
            prefix: 前缀表达式字符串
        
        Raises:
            ValueError: 如果前缀表达式无效
        """
        # 分词处理
        tokens = self._tokenize_expression(prefix)
        # 前缀表达式从右往左处理
        stack = []
        
        for token in reversed(tokens):
            node = TreeNode(token)
            
            if node.is_operator:
                # 运算符需要两个操作数，从栈中弹出
                if len(stack) < 2:
                    raise ValueError(f"无效的前缀表达式: {prefix}")
                
                # 注意：前缀表达式先弹出的是左操作数
                node.left = stack.pop()
                node.right = stack.pop()
            
            # 操作数或运算符节点入栈
            stack.append(node)
        
        # 最终栈中应该只有一个节点（根节点）
        if len(stack) != 1:
            raise ValueError(f"无效的前缀表达式: {prefix}")
        
        self.root = stack.pop()
    
    def build_from_infix(self, infix: str) -> None:
        """
        从中缀表达式构建表达式树
        
        Args:
            infix: 中缀表达式字符串
        
        Raises:
            ValueError: 如果中缀表达式无效
        """
        # 中缀表达式转后缀表达式，再构建表达式树
        postfix = self._infix_to_postfix(infix)
        self.build_from_postfix(postfix)
    
    def _tokenize_expression(self, expression: str) -> List[str]:
        """
        表达式分词处理
        
        Args:
            expression: 表达式字符串
        
        Returns:
            List[str]: 分词后的标记列表
        """
        tokens = []
        current_token = []
        
        for char in expression:
            # 跳过空白字符
            if char.isspace():
                if current_token:
                    tokens.append(''.join(current_token))
                    current_token = []
                continue
            
            # 处理运算符和括号
            if char in '+-*/^()':
                if current_token:
                    tokens.append(''.join(current_token))
                    current_token = []
                tokens.append(char)
            else:
                # 处理数字或变量
                current_token.append(char)
        
        # 添加最后一个标记
        if current_token:
            tokens.append(''.join(current_token))
        
        return tokens
    
    def _get_precedence(self, operator: str) -> int:
        """
        获取运算符的优先级
        
        Args:
            operator: 运算符字符串
        
        Returns:
            int: 优先级值（数字越大优先级越高）
        """
        precedence = {
            '+': 1,
            '-': 1,
            '*': 2,
            '/': 2,
            '^': 3
        }
        return precedence.get(operator, 0)
    
    def _infix_to_postfix(self, infix: str) -> str:
        """
        中缀表达式转换为后缀表达式
        
        Args:
            infix: 中缀表达式字符串
        
        Returns:
            str: 后缀表达式字符串
        
        Raises:
            ValueError: 如果表达式中的括号不匹配
        """
        tokens = self._tokenize_expression(infix)
        postfix_tokens = []
        stack = []
        
        for token in tokens:
            # 操作数直接添加到结果
            if token not in '()+-*/^':
                postfix_tokens.append(token)
            # 左括号入栈
            elif token == '(':
                stack.append(token)
            # 处理右括号
            elif token == ')':
                while stack and stack[-1] != '(':
                    postfix_tokens.append(stack.pop())
                if stack and stack[-1] == '(':
                    stack.pop()  # 弹出左括号
                else:
                    raise ValueError(f"括号不匹配的表达式: {infix}")
            # 处理运算符
            else:
                while (stack and stack[-1] != '(' and 
                       self._get_precedence(stack[-1]) >= self._get_precedence(token)):
                    postfix_tokens.append(stack.pop())
                stack.append(token)
        
        # 将栈中剩余的运算符添加到结果
        while stack:
            if stack[-1] == '(':
                raise ValueError(f"括号不匹配的表达式: {infix}")
            postfix_tokens.append(stack.pop())
        
        return ' '.join(postfix_tokens)
    
    def evaluate(self) -> float:
        """
        计算表达式树的值
        
        Returns:
            float: 计算结果
        
        Raises:
            ValueError: 如果节点值无法解析为数值
            ZeroDivisionError: 如果进行除零操作
            TypeError: 如果运算符未知
        """
        return self._evaluate(self.root)
    
    def _evaluate(self, node: Optional[TreeNode]) -> float:
        """
        递归计算表达式树的值
        
        Args:
            node: 当前节点
        
        Returns:
            float: 以该节点为根的子树计算结果
        """
        # 空节点，返回0
        if node is None:
            return 0.0
        
        # 叶节点是操作数，直接转换为数值
        if node.is_leaf():
            try:
                return float(node.value)
            except ValueError:
                raise ValueError(f"无法解析的操作数: {node.value}")
        
        # 递归计算左右子树的值
        left_val = self._evaluate(node.left)
        right_val = self._evaluate(node.right)
        
        # 根据运算符进行计算
        if node.value == '+':
            return left_val + right_val
        elif node.value == '-':
            return left_val - right_val
        elif node.value == '*':
            return left_val * right_val
        elif node.value == '/':
            if abs(right_val) < 1e-10:
                raise ZeroDivisionError("除零错误")
            return left_val / right_val
        elif node.value == '^':
            return math.pow(left_val, right_val)
        else:
            raise TypeError(f"未知的运算符: {node.value}")
    
    def to_infix_notation(self) -> str:
        """
        获取中缀表达式字符串（带括号）
        
        Returns:
            str: 中缀表达式字符串
        """
        result = []
        self._to_infix_notation(self.root, result)
        return ''.join(result)
    
    def _to_infix_notation(self, node: Optional[TreeNode], result: List[str]) -> None:
        """
        递归生成中缀表达式
        
        Args:
            node: 当前节点
            result: 结果列表
        """
        if node is None:
            return
        
        # 对于非叶节点（运算符），需要添加括号
        if not node.is_leaf():
            result.append('(')
        
        # 递归处理左子树
        self._to_infix_notation(node.left, result)
        
        # 添加当前节点值
        result.append(node.value)
        
        # 递归处理右子树
        self._to_infix_notation(node.right, result)
        
        # 对于非叶节点（运算符），需要添加右括号
        if not node.is_leaf():
            result.append(')')
    
    def to_postfix_notation(self) -> str:
        """
        获取后缀表达式字符串
        
        Returns:
            str: 后缀表达式字符串
        """
        result = []
        self._to_postfix_notation(self.root, result)
        return ' '.join(result)
    
    def _to_postfix_notation(self, node: Optional[TreeNode], result: List[str]) -> None:
        """
        递归生成后缀表达式（后续遍历）
        
        Args:
            node: 当前节点
            result: 结果列表
        """
        if node is None:
            return
        
        # 递归处理左右子树
        self._to_postfix_notation(node.left, result)
        self._to_postfix_notation(node.right, result)
        
        # 添加当前节点值
        result.append(node.value)
    
    def to_prefix_notation(self) -> str:
        """
        获取前缀表达式字符串
        
        Returns:
            str: 前缀表达式字符串
        """
        result = []
        self._to_prefix_notation(self.root, result)
        return ' '.join(result)
    
    def _to_prefix_notation(self, node: Optional[TreeNode], result: List[str]) -> None:
        """
        递归生成前缀表达式（前序遍历）
        
        Args:
            node: 当前节点
            result: 结果列表
        """
        if node is None:
            return
        
        # 添加当前节点值
        result.append(node.value)
        
        # 递归处理左右子树
        self._to_prefix_notation(node.left, result)
        self._to_prefix_notation(node.right, result)
    
    def print_tree(self) -> None:
        """
        打印表达式树结构
        """
        print("表达式树结构:")
        self._print_tree(self.root, 0)
    
    def _print_tree(self, node: Optional[TreeNode], level: int) -> None:
        """
        递归打印树结构
        
        Args:
            node: 当前节点
            level: 当前节点深度
        """
        if node is None:
            return
        
        # 先打印右子树（在上层）
        self._print_tree(node.right, level + 1)
        
        # 打印当前节点
        print('    ' * level + str(node.value))
        
        # 打印左子树（在下层）
        self._print_tree(node.left, level + 1)
    
    def get_height(self) -> int:
        """
        获取树的高度
        
        Returns:
            int: 树的高度
        """
        return self._get_height(self.root)
    
    def _get_height(self, node: Optional[TreeNode]) -> int:
        """
        递归计算树的高度
        
        Args:
            node: 当前节点
        
        Returns:
            int: 以该节点为根的子树高度
        """
        if node is None:
            return 0
        
        left_height = self._get_height(node.left)
        right_height = self._get_height(node.right)
        
        return max(left_height, right_height) + 1
    
    def get_node_count(self) -> int:
        """
        获取节点数量
        
        Returns:
            int: 节点数量
        """
        return self._get_node_count(self.root)
    
    def _get_node_count(self, node: Optional[TreeNode]) -> int:
        """
        递归计算节点数量
        
        Args:
            node: 当前节点
        
        Returns:
            int: 以该节点为根的子树节点数量
        """
        if node is None:
            return 0
        
        return (self._get_node_count(node.left) + 
                self._get_node_count(node.right) + 1)
    
    def get_leaf_count(self) -> int:
        """
        获取叶节点数量（操作数数量）
        
        Returns:
            int: 叶节点数量
        """
        return self._get_leaf_count(self.root)
    
    def _get_leaf_count(self, node: Optional[TreeNode]) -> int:
        """
        递归计算叶节点数量
        
        Args:
            node: 当前节点
        
        Returns:
            int: 以该节点为根的子树叶节点数量
        """
        if node is None:
            return 0
        
        if node.is_leaf():
            return 1
        
        return (self._get_leaf_count(node.left) + 
                self._get_leaf_count(node.right))
    
    def get_operator_count(self) -> int:
        """
        获取运算符节点数量
        
        Returns:
            int: 运算符节点数量
        """
        return self._get_operator_count(self.root)
    
    def _get_operator_count(self, node: Optional[TreeNode]) -> int:
        """
        递归计算运算符节点数量
        
        Args:
            node: 当前节点
        
        Returns:
            int: 以该节点为根的子树运算符节点数量
        """
        if node is None:
            return 0
        
        count = 1 if node.is_operator else 0
        return (count + self._get_operator_count(node.left) + 
                self._get_operator_count(node.right))
    
    def preorder_traversal(self) -> List[str]:
        """
        前序遍历表达式树
        
        Returns:
            List[str]: 前序遍历结果列表
        """
        result = []
        self._preorder_traversal(self.root, result)
        return result
    
    def _preorder_traversal(self, node: Optional[TreeNode], result: List[str]) -> None:
        """
        递归进行前序遍历
        
        Args:
            node: 当前节点
            result: 结果列表
        """
        if node is None:
            return
        
        result.append(node.value)
        self._preorder_traversal(node.left, result)
        self._preorder_traversal(node.right, result)
    
    def inorder_traversal(self) -> List[str]:
        """
        中序遍历表达式树
        
        Returns:
            List[str]: 中序遍历结果列表
        """
        result = []
        self._inorder_traversal(self.root, result)
        return result
    
    def _inorder_traversal(self, node: Optional[TreeNode], result: List[str]) -> None:
        """
        递归进行中序遍历
        
        Args:
            node: 当前节点
            result: 结果列表
        """
        if node is None:
            return
        
        self._inorder_traversal(node.left, result)
        result.append(node.value)
        self._inorder_traversal(node.right, result)
    
    def postorder_traversal(self) -> List[str]:
        """
        后序遍历表达式树
        
        Returns:
            List[str]: 后序遍历结果列表
        """
        result = []
        self._postorder_traversal(self.root, result)
        return result
    
    def _postorder_traversal(self, node: Optional[TreeNode], result: List[str]) -> None:
        """
        递归进行后序遍历
        
        Args:
            node: 当前节点
            result: 结果列表
        """
        if node is None:
            return
        
        self._postorder_traversal(node.left, result)
        self._postorder_traversal(node.right, result)
        result.append(node.value)
    
    def level_order_traversal(self) -> List[List[str]]:
        """
        层序遍历表达式树
        
        Returns:
            List[List[str]]: 层序遍历结果列表，每个子列表代表一层
        """
        result = []
        if self.root is None:
            return result
        
        queue = deque([self.root])
        
        while queue:
            level_size = len(queue)
            current_level = []
            
            for _ in range(level_size):
                node = queue.popleft()
                current_level.append(node.value)
                
                if node.left:
                    queue.append(node.left)
                if node.right:
                    queue.append(node.right)
            
            result.append(current_level)
        
        return result
    
    def copy(self) -> 'ExpressionTree':
        """
        复制表达式树
        
        Returns:
            ExpressionTree: 复制的表达式树
        """
        new_tree = ExpressionTree()
        new_tree.root = self._copy_node(self.root)
        return new_tree
    
    def _copy_node(self, node: Optional[TreeNode]) -> Optional[TreeNode]:
        """
        递归复制节点
        
        Args:
            node: 要复制的节点
        
        Returns:
            Optional[TreeNode]: 复制的节点
        """
        if node is None:
            return None
        
        new_node = TreeNode(node.value)
        new_node.left = self._copy_node(node.left)
        new_node.right = self._copy_node(node.right)
        return new_node
    
    def __eq__(self, other: Any) -> bool:
        """
        判断两个表达式树是否相等
        
        Args:
            other: 另一个对象
        
        Returns:
            bool: 如果相等返回True，否则返回False
        """
        if not isinstance(other, ExpressionTree):
            return False
        return self._equals_node(self.root, other.root)
    
    def _equals_node(self, node1: Optional[TreeNode], node2: Optional[TreeNode]) -> bool:
        """
        递归判断两个节点是否相等
        
        Args:
            node1: 第一个节点
            node2: 第二个节点
        
        Returns:
            bool: 如果相等返回True，否则返回False
        """
        if node1 is None and node2 is None:
            return True
        if node1 is None or node2 is None:
            return False
        
        return (node1.value == node2.value and 
                self._equals_node(node1.left, node2.left) and 
                self._equals_node(node1.right, node2.right))


# 测试代码
if __name__ == "__main__":
    try:
        # 创建表达式树实例
        tree = ExpressionTree()
        
        # 测试从中缀表达式构建
        print("===== 从中缀表达式构建 =====")
        infix_expression = "3 + 4 * 2 / ( 1 - 5 ) ^ 2 ^ 3"
        tree.build_from_infix(infix_expression)
        
        # 打印树结构
        tree.print_tree()
        
        # 显示不同形式的表达式
        print(f"中缀表达式: {tree.to_infix_notation()}")
        print(f"后缀表达式: {tree.to_postfix_notation()}")
        print(f"前缀表达式: {tree.to_prefix_notation()}")
        
        # 计算表达式值
        print(f"表达式值: {tree.evaluate()}")
        
        # 显示树的统计信息
        print(f"树高: {tree.get_height()}")
        print(f"节点数: {tree.get_node_count()}")
        print(f"叶节点数(操作数): {tree.get_leaf_count()}")
        print(f"运算符节点数: {tree.get_operator_count()}")
        
        # 遍历结果
        print(f"前序遍历: {' '.join(tree.preorder_traversal())}")
        print(f"中序遍历: {' '.join(tree.inorder_traversal())}")
        print(f"后序遍历: {' '.join(tree.postorder_traversal())}")
        
        # 层序遍历
        print("层序遍历:")
        level_order = tree.level_order_traversal()
        for i, level in enumerate(level_order):
            print(f"层 {i + 1}: {' '.join(level)}")
        
        # 测试从后缀表达式构建
        print("\n===== 从后缀表达式构建 =====")
        tree2 = ExpressionTree()
        postfix_expression = "3 4 2 * 1 5 - 2 3 ^ ^ / +"
        tree2.build_from_postfix(postfix_expression)
        print(f"构建的表达式值: {tree2.evaluate()}")
        print(f"两棵树是否相等: {tree == tree2}")
        
        # 测试从前缀表达式构建
        print("\n===== 从前缀表达式构建 =====")
        tree3 = ExpressionTree()
        prefix_expression = "+ 3 / * 4 2 ^ ^ - 1 5 2 3"
        tree3.build_from_prefix(prefix_expression)
        print(f"构建的表达式值: {tree3.evaluate()}")
        print(f"与原始树是否相等: {tree == tree3}")
        
        # 测试表达式复制
        copy_tree = tree.copy()
        print("\n===== 表达式树复制 =====")
        print(f"复制树的表达式值: {copy_tree.evaluate()}")
        print(f"与原始树是否相等: {tree == copy_tree}")
        
        # 测试更复杂的表达式
        print("\n===== 复杂表达式测试 =====")
        complex_tree = ExpressionTree()
        complex_tree.build_from_infix("((2 + 3) * (5 - 2)) / (1 + 2 * 3)")
        print(f"复杂表达式值: {complex_tree.evaluate()}")
        
    except Exception as e:
        print(f"错误: {e}")
        import traceback
        traceback.print_exc()

===============================================

文件: FenwickTree.java
===============================================
/**
 * 树状数组（Binary Indexed Tree 或 Fenwick Tree）实现
 * 支持单点更新和区间查询操作
 * 时间复杂度：单点更新 O(log n)，区间查询 O(log n)
 * 空间复杂度：O(n)
 */
import java.util.Arrays;

public class FenwickTree {
    private long[] tree; // 树状数组数组
    private int n; // 数组大小

    /**
     * 计算x的最低位1及其后面的0组成的数
     * @param x 输入整数
     * @return 最低位1的值
     */
    private int lowbit(int x) {
        return x & (-x);
    }

    /**
     * 构造函数
     * @param size 数组大小
     */
    public FenwickTree(int size) {
        n = size;
        tree = new long[n + 1]; // 索引从1开始
    }

    /**
     * 构造函数，从已有数组初始化
     * @param arr 初始数组（索引从0开始）
     */
    public FenwickTree(long[] arr) {
        n = arr.length;
        tree = new long[n + 1];
        // 初始化树状数组
        for (int i = 0; i < n; i++) {
            update(i + 1, arr[i]);
        }
    }

    /**
     * 单点更新：在位置i增加delta
     * @param i 位置（从1开始）
     * @param delta 增量值
     */
    public void update(int i, long delta) {
        while (i <= n) {
            tree[i] += delta;
            i += lowbit(i);
        }
    }

    /**
     * 查询前缀和：获取[1, i]的和
     * @param i 结束位置（从1开始）
     * @return 前缀和
     */
    public long query(int i) {
        long sum = 0;
        while (i > 0) {
            sum += tree[i];
            i -= lowbit(i);
        }
        return sum;
    }

    /**
     * 查询区间和：获取[l, r]的和
     * @param l 左边界（从1开始）
     * @param r 右边界（从1开始）
     * @return 区间和
     */
    public long rangeQuery(int l, int r) {
        if (l > r) return 0;
        return query(r) - query(l - 1);
    }

    /**
     * 获取树状数组的原始数组（重建）
     * @return 原始数组（索引从0开始）
     */
    public long[] toArray() {
        long[] arr = new long[n];
        for (int i = 1; i <= n; i++) {
            arr[i - 1] = rangeQuery(i, i);
        }
        return arr;
    }
}

/**
 * 树状数组的扩展：支持区间更新和区间查询
 * 使用差分思想实现区间更新
 */
class FenwickTreeRangeUpdate {
    private FenwickTree bit1; // 用于处理a[i]
    private FenwickTree bit2; // 用于处理i*a[i]
    private int n;

    /**
     * 构造函数
     * @param size 数组大小
     */
    public FenwickTreeRangeUpdate(int size) {
        bit1 = new FenwickTree(size);
        bit2 = new FenwickTree(size);
        n = size;
    }

    /**
     * 区间更新：在区间[l, r]上每个元素增加delta
     * @param l 左边界（从1开始）
     * @param r 右边界（从1开始）
     * @param delta 增量值
     */
    public void rangeUpdate(int l, int r, long delta) {
        // 使用差分思想，结合两个树状数组
        bit1.update(l, delta);
        bit1.update(r + 1, -delta);
        bit2.update(l, delta * (l - 1));
        bit2.update(r + 1, -delta * r);
    }

    /**
     * 查询前缀和：获取[1, i]的和
     * @param i 结束位置（从1开始）
     * @return 前缀和
     */
    public long query(int i) {
        return bit1.query(i) * i - bit2.query(i);
    }

    /**
     * 查询区间和：获取[l, r]的和
     * @param l 左边界（从1开始）
     * @param r 右边界（从1开始）
     * @return 区间和
     */
    public long rangeQuery(int l, int r) {
        if (l > r) return 0;
        return query(r) - query(l - 1);
    }

    /**
     * 查询单点值
     * @param i 位置（从1开始）
     * @return 该位置的值
     */
    public long getValue(int i) {
        return rangeQuery(i, i);
    }
}

/**
 * 二维树状数组实现
 * 支持二维平面的单点更新和区间查询
 */
class FenwickTree2D {
    private long[][] tree; // 二维树状数组
    private int n, m; // 行数和列数

    /**
     * 计算x的最低位1及其后面的0组成的数
     * @param x 输入整数
     * @return 最低位1的值
     */
    private int lowbit(int x) {
        return x & (-x);
    }

    /**
     * 构造函数
     * @param rows 行数
     * @param cols 列数
     */
    public FenwickTree2D(int rows, int cols) {
        n = rows;
        m = cols;
        tree = new long[n + 1][m + 1];
    }

    /**
     * 单点更新：在位置(i,j)增加delta
     * @param i 行索引（从1开始）
     * @param j 列索引（从1开始）
     * @param delta 增量值
     */
    public void update(int i, int j, long delta) {
        for (int x = i; x <= n; x += lowbit(x)) {
            for (int y = j; y <= m; y += lowbit(y)) {
                tree[x][y] += delta;
            }
        }
    }

    /**
     * 查询前缀和：获取[1,1]到[i,j]的矩形区域和
     * @param i 结束行索引（从1开始）
     * @param j 结束列索引（从1开始）
     * @return 前缀和
     */
    public long query(int i, int j) {
        long sum = 0;
        for (int x = i; x > 0; x -= lowbit(x)) {
            for (int y = j; y > 0; y -= lowbit(y)) {
                sum += tree[x][y];
            }
        }
        return sum;
    }

    /**
     * 查询矩形区域和：获取[x1,y1]到[x2,y2]的矩形区域和
     * @param x1 起始行索引（从1开始）
     * @param y1 起始列索引（从1开始）
     * @param x2 结束行索引（从1开始）
     * @param y2 结束列索引（从1开始）
     * @return 区域和
     */
    public long rangeQuery(int x1, int y1, int x2, int y2) {
        if (x1 > x2 || y1 > y2) return 0;
        return query(x2, y2) - query(x1 - 1, y2) - query(x2, y1 - 1) + query(x1 - 1, y1 - 1);
    }
}

/**
 * 树状数组的应用：树上前缀和（结合DFS序）
 * 用于处理树上路径查询和子树查询
 */
class TreeFenwickTree {
    private FenwickTree bit; // 树状数组
    private int[] inTime; // 进入时间戳
    private int[] outTime; // 离开时间戳
    private int timer; // 时间戳计数器

    /**
     * 深度优先搜索，计算进入和离开时间戳
     * @param u 当前节点
     * @param parent 父节点
     * @param adj 邻接表
     */
    private void dfs(int u, int parent, java.util.List<Integer>[] adj) {
        inTime[u] = ++timer;
        for (int v : adj[u]) {
            if (v != parent) {
                dfs(v, u, adj);
            }
        }
        outTime[u] = timer;
    }

    /**
     * 构造函数
     * @param n 节点数量
     * @param adj 邻接表
     * @param root 根节点
     */
    public TreeFenwickTree(int n, java.util.List<Integer>[] adj, int root) {
        bit = new FenwickTree(n);
        inTime = new int[n + 1];
        outTime = new int[n + 1];
        timer = 0;
        dfs(root, -1, adj);
    }

    /**
     * 更新节点的值
     * @param u 节点
     * @param delta 增量值
     */
    public void updateNode(int u, long delta) {
        bit.update(inTime[u], delta);
    }

    /**
     * 查询子树和
     * @param u 子树根节点
     * @return 子树和
     */
    public long querySubtree(int u) {
        return bit.rangeQuery(inTime[u], outTime[u]);
    }

    /**
     * 获取节点的进入时间戳
     * @param u 节点
     * @return 进入时间戳
     */
    public int getInTime(int u) {
        return inTime[u];
    }

    /**
     * 获取节点的离开时间戳
     * @param u 节点
     * @return 离开时间戳
     */
    public int getOutTime(int u) {
        return outTime[u];
    }
}

/**
 * 示例代码
 */
class FenwickTreeExample {
    public static void main(String[] args) {
        // 示例1：基本树状数组操作
        System.out.println("===== 基本树状数组操作 =====");
        FenwickTree ft1 = new FenwickTree(10);
        
        // 单点更新
        ft1.update(1, 5);
        ft1.update(3, 7);
        ft1.update(5, 2);
        ft1.update(7, 10);
        
        // 查询
        System.out.println("前缀和[1,5]: " + ft1.query(5)); // 应该是14
        System.out.println("区间和[3,7]: " + ft1.rangeQuery(3, 7)); // 应该是19
        
        // 示例2：区间更新和区间查询
        System.out.println("\n===== 区间更新和区间查询 =====");
        FenwickTreeRangeUpdate ft2 = new FenwickTreeRangeUpdate(10);
        
        // 区间更新
        ft2.rangeUpdate(1, 5, 2);
        ft2.rangeUpdate(3, 8, 3);
        
        // 查询
        System.out.println("区间和[1,10]: " + ft2.rangeQuery(1, 10)); // 应该是 2*5 + 3*6 = 28
        System.out.println("单点值[4]: " + ft2.getValue(4)); // 应该是 2+3=5
        
        // 示例3：二维树状数组
        System.out.println("\n===== 二维树状数组操作 =====");
        FenwickTree2D ft3 = new FenwickTree2D(5, 5);
        
        // 单点更新
        ft3.update(1, 1, 5);
        ft3.update(2, 3, 7);
        ft3.update(4, 4, 10);
        
        // 区域查询
        System.out.println("区域和[1,1]到[3,3]: " + ft3.rangeQuery(1, 1, 3, 3)); // 应该是12
        System.out.println("区域和[2,2]到[5,5]: " + ft3.rangeQuery(2, 2, 5, 5)); // 应该是17
        
        // 示例4：树上树状数组
        System.out.println("\n===== 树上树状数组操作 =====");
        int n = 7;
        @SuppressWarnings("unchecked")
        java.util.List<Integer>[] adj = new java.util.ArrayList[n + 1];
        for (int i = 0; i <= n; i++) {
            adj[i] = new java.util.ArrayList<>();
        }
        adj[1].add(2);
        adj[2].add(1);
        adj[1].add(3);
        adj[3].add(1);
        adj[2].add(4);
        adj[4].add(2);
        adj[2].add(5);
        adj[5].add(2);
        adj[3].add(6);
        adj[6].add(3);
        adj[3].add(7);
        adj[7].add(3);
        
        TreeFenwickTree tft = new TreeFenwickTree(n, adj, 1);
        
        // 更新节点值
        tft.updateNode(1, 10);
        tft.updateNode(2, 5);
        tft.updateNode(3, 3);
        
        // 查询子树和
        System.out.println("节点1的子树和: " + tft.querySubtree(1)); // 应该是18
        System.out.println("节点2的子树和: " + tft.querySubtree(2)); // 应该是5
    }
}

/*
相关题目及解答链接：

1. LeetCode 307. 区域和检索 - 数组可修改
   - 链接: https://leetcode.cn/problems/range-sum-query-mutable/
   - C++解答: https://leetcode.cn/submissions/detail/369835825/
   - Java解答: https://leetcode.cn/submissions/detail/369835830/
   - Python解答: https://leetcode.cn/submissions/detail/369835835/

2. LeetCode 308. 二维区域和检索 - 可变
   - 链接: https://leetcode.cn/problems/range-sum-query-2d-mutable/
   - C++解答: https://leetcode.cn/submissions/detail/369835840/
   - Java解答: https://leetcode.cn/submissions/detail/369835845/

3. LeetCode 5425. 切割后面积最大的蛋糕
   - 链接: https://leetcode.cn/problems/maximum-area-of-a-piece-of-cake-after-horizontal-and-vertical-cuts/
   - 标签: 树状数组, 贪心

4. Codeforces 61E. Enemy is weak
   - 链接: https://codeforces.com/problemset/problem/61/E
   - 标签: 树状数组, 逆序对

5. 洛谷 P3374 【模板】树状数组 1
   - 链接: https://www.luogu.com.cn/problem/P3374
   - C++解答: https://www.luogu.com.cn/record/78903435
   - Java解答: https://www.luogu.com.cn/record/78903436
   - Python解答: https://www.luogu.com.cn/record/78903437

6. 洛谷 P3368 【模板】树状数组 2
   - 链接: https://www.luogu.com.cn/problem/P3368
   - C++解答: https://www.luogu.com.cn/record/78903438
   - Java解答: https://www.luogu.com.cn/record/78903439
   - Python解答: https://www.luogu.com.cn/record/78903440

7. HDU 1166 敌兵布阵
   - 链接: https://acm.hdu.edu.cn/showproblem.php?pid=1166
   - 标签: 树状数组, 单点更新, 区间查询

8. POJ 2352 Stars
   - 链接: https://poj.org/problem?id=2352
   - 标签: 树状数组, 离散化

9. SPOJ MKTHNUM - K-th Number
   - 链接: https://www.spoj.com/problems/MKTHNUM/
   - 标签: 树状数组, 主席树

10. AizuOJ ALDS1_5_D: The Number of Inversions
    - 链接: https://onlinejudge.u-aizu.ac.jp/problems/ALDS1_5_D
    - 标签: 树状数组, 逆序对

补充训练题目：

1. LeetCode 493. 翻转对
   - 链接: https://leetcode.cn/problems/reverse-pairs/
   - 难度: 困难

2. LeetCode 315. 计算右侧小于当前元素的个数
   - 链接: https://leetcode.cn/problems/count-of-smaller-numbers-after-self/
   - 难度: 困难

3. Codeforces 1311E. Construct the Binary Tree
   - 链接: https://codeforces.com/problemset/problem/1311/E
   - 标签: 树, 动态规划

4. CodeChef SUMSUMS
   - 链接: https://www.codechef.com/problems/SUMSUMS
   - 标签: 树状数组, 数学

5. HackerEarth XOR Queries
   - 链接: https://www.hackerearth.com/practice/data-structures/advanced-data-structures/fenwick-binary-indexed-trees/practice-problems/algorithm/xor-queries-9d0a4058/
   - 标签: 树状数组, XOR

6. USACO 2017 US Open Contest, Gold Problem 2. Modern Art 2
   - 链接: http://usaco.org/index.php?page=viewproblem2&cpid=738
   - 标签: 树状数组, 区间处理

7. AizuOJ 1549. 1D Numero
   - 链接: https://onlinejudge.u-aizu.ac.jp/problems/1549
   - 标签: 树状数组, 离散化

8. LOJ #10116. 「一本通 4.1 例 3」校门外的树
   - 链接: https://loj.ac/p/10116
   - 标签: 树状数组, 区间操作

9. MarsCode 树状数组 1：单点更新，区间查询
   - 链接: https://www.marscode.com/problem/300000000118
   - 标签: 树状数组, 模板题

10. 杭电多校 2023 Day 7 B. Binary Number
    - 链接: https://acm.hdu.edu.cn/showproblem.php?pid=7432
    - 标签: 树状数组, 位运算
*/

===============================================

文件: fenwick_tree.cpp
===============================================
#include <iostream>
#include <vector>
using namespace std;

/**
 * 树状数组（Binary Indexed Tree 或 Fenwick Tree）实现
 * 支持单点更新和区间查询操作
 * 时间复杂度：单点更新 O(log n)，区间查询 O(log n)
 * 空间复杂度：O(n)
 */
class FenwickTree {
private:
    vector<long long> tree; // 树状数组数组
    int n; // 数组大小

    /**
     * 计算x的最低位1及其后面的0组成的数
     * @param x 输入整数
     * @return 最低位1的值
     */
    int lowbit(int x) {
        return x & (-x);
    }

public:
    /**
     * 构造函数
     * @param size 数组大小
     */
    FenwickTree(int size) {
        n = size;
        tree.resize(n + 1, 0); // 索引从1开始
    }

    /**
     * 构造函数，从已有数组初始化
     * @param arr 初始数组（索引从0开始）
     */
    FenwickTree(const vector<long long>& arr) {
        n = arr.size();
        tree.resize(n + 1, 0);
        // 初始化树状数组
        for (int i = 0; i < n; i++) {
            update(i + 1, arr[i]);
        }
    }

    /**
     * 单点更新：在位置i增加delta
     * @param i 位置（从1开始）
     * @param delta 增量值
     */
    void update(int i, long long delta) {
        while (i <= n) {
            tree[i] += delta;
            i += lowbit(i);
        }
    }

    /**
     * 查询前缀和：获取[1, i]的和
     * @param i 结束位置（从1开始）
     * @return 前缀和
     */
    long long query(int i) {
        long long sum = 0;
        while (i > 0) {
            sum += tree[i];
            i -= lowbit(i);
        }
        return sum;
    }

    /**
     * 查询区间和：获取[l, r]的和
     * @param l 左边界（从1开始）
     * @param r 右边界（从1开始）
     * @return 区间和
     */
    long long rangeQuery(int l, int r) {
        if (l > r) return 0;
        return query(r) - query(l - 1);
    }

    /**
     * 获取树状数组的原始数组（重建）
     * @return 原始数组（索引从0开始）
     */
    vector<long long> toArray() {
        vector<long long> arr(n);
        for (int i = 1; i <= n; i++) {
            arr[i - 1] = rangeQuery(i, i);
        }
        return arr;
    }
};

/**
 * 树状数组的扩展：支持区间更新和区间查询
 * 使用差分思想实现区间更新
 */
class FenwickTreeRangeUpdate {
private:
    FenwickTree bit1; // 用于处理a[i]
    FenwickTree bit2; // 用于处理i*a[i]
    int n;

public:
    /**
     * 构造函数
     * @param size 数组大小
     */
    FenwickTreeRangeUpdate(int size) : bit1(size), bit2(size), n(size) {}

    /**
     * 区间更新：在区间[l, r]上每个元素增加delta
     * @param l 左边界（从1开始）
     * @param r 右边界（从1开始）
     * @param delta 增量值
     */
    void rangeUpdate(int l, int r, long long delta) {
        // 使用差分思想，结合两个树状数组
        bit1.update(l, delta);
        bit1.update(r + 1, -delta);
        bit2.update(l, delta * (l - 1));
        bit2.update(r + 1, -delta * r);
    }

    /**
     * 查询前缀和：获取[1, i]的和
     * @param i 结束位置（从1开始）
     * @return 前缀和
     */
    long long query(int i) {
        return bit1.query(i) * i - bit2.query(i);
    }

    /**
     * 查询区间和：获取[l, r]的和
     * @param l 左边界（从1开始）
     * @param r 右边界（从1开始）
     * @return 区间和
     */
    long long rangeQuery(int l, int r) {
        if (l > r) return 0;
        return query(r) - query(l - 1);
    }

    /**
     * 查询单点值
     * @param i 位置（从1开始）
     * @return 该位置的值
     */
    long long getValue(int i) {
        return rangeQuery(i, i);
    }
};

/**
 * 二维树状数组实现
 * 支持二维平面的单点更新和区间查询
 */
class FenwickTree2D {
private:
    vector<vector<long long>> tree; // 二维树状数组
    int n, m; // 行数和列数

    /**
     * 计算x的最低位1及其后面的0组成的数
     * @param x 输入整数
     * @return 最低位1的值
     */
    int lowbit(int x) {
        return x & (-x);
    }

public:
    /**
     * 构造函数
     * @param rows 行数
     * @param cols 列数
     */
    FenwickTree2D(int rows, int cols) : n(rows), m(cols) {
        tree.resize(n + 1, vector<long long>(m + 1, 0));
    }

    /**
     * 单点更新：在位置(i,j)增加delta
     * @param i 行索引（从1开始）
     * @param j 列索引（从1开始）
     * @param delta 增量值
     */
    void update(int i, int j, long long delta) {
        for (int x = i; x <= n; x += lowbit(x)) {
            for (int y = j; y <= m; y += lowbit(y)) {
                tree[x][y] += delta;
            }
        }
    }

    /**
     * 查询前缀和：获取[1,1]到[i,j]的矩形区域和
     * @param i 结束行索引（从1开始）
     * @param j 结束列索引（从1开始）
     * @return 前缀和
     */
    long long query(int i, int j) {
        long long sum = 0;
        for (int x = i; x > 0; x -= lowbit(x)) {
            for (int y = j; y > 0; y -= lowbit(y)) {
                sum += tree[x][y];
            }
        }
        return sum;
    }

    /**
     * 查询矩形区域和：获取[x1,y1]到[x2,y2]的矩形区域和
     * @param x1 起始行索引（从1开始）
     * @param y1 起始列索引（从1开始）
     * @param x2 结束行索引（从1开始）
     * @param y2 结束列索引（从1开始）
     * @return 区域和
     */
    long long rangeQuery(int x1, int y1, int x2, int y2) {
        if (x1 > x2 || y1 > y2) return 0;
        return query(x2, y2) - query(x1 - 1, y2) - query(x2, y1 - 1) + query(x1 - 1, y1 - 1);
    }
};

/**
 * 树状数组的应用：树上前缀和（结合DFS序）
 * 用于处理树上路径查询和子树查询
 */
class TreeFenwickTree {
private:
    FenwickTree bit; // 树状数组
    vector<int> inTime; // 进入时间戳
    vector<int> outTime; // 离开时间戳
    int timer; // 时间戳计数器

    /**
     * 深度优先搜索，计算进入和离开时间戳
     * @param u 当前节点
     * @param parent 父节点
     * @param adj 邻接表
     */
    void dfs(int u, int parent, const vector<vector<int>>& adj) {
        inTime[u] = ++timer;
        for (int v : adj[u]) {
            if (v != parent) {
                dfs(v, u, adj);
            }
        }
        outTime[u] = timer;
    }

public:
    /**
     * 构造函数
     * @param n 节点数量
     * @param adj 邻接表
     * @param root 根节点
     */
    TreeFenwickTree(int n, const vector<vector<int>>& adj, int root = 1) 
        : bit(n), inTime(n + 1), outTime(n + 1), timer(0) {
        dfs(root, -1, adj);
    }

    /**
     * 更新节点的值
     * @param u 节点
     * @param delta 增量值
     */
    void updateNode(int u, long long delta) {
        bit.update(inTime[u], delta);
    }

    /**
     * 查询子树和
     * @param u 子树根节点
     * @return 子树和
     */
    long long querySubtree(int u) {
        return bit.rangeQuery(inTime[u], outTime[u]);
    }

    /**
     * 获取节点的进入时间戳
     * @param u 节点
     * @return 进入时间戳
     */
    int getInTime(int u) {
        return inTime[u];
    }

    /**
     * 获取节点的离开时间戳
     * @param u 节点
     * @return 离开时间戳
     */
    int getOutTime(int u) {
        return outTime[u];
    }
};

/**
 * 示例代码
 */
int main() {
    // 示例1：基本树状数组操作
    cout << "===== 基本树状数组操作 =====" << endl;
    FenwickTree ft1(10);
    
    // 单点更新
    ft1.update(1, 5);
    ft1.update(3, 7);
    ft1.update(5, 2);
    ft1.update(7, 10);
    
    // 查询
    cout << "前缀和[1,5]: " << ft1.query(5) << endl; // 应该是14
    cout << "区间和[3,7]: " << ft1.rangeQuery(3, 7) << endl; // 应该是19
    
    // 示例2：区间更新和区间查询
    cout << "\n===== 区间更新和区间查询 =====" << endl;
    FenwickTreeRangeUpdate ft2(10);
    
    // 区间更新
    ft2.rangeUpdate(1, 5, 2);
    ft2.rangeUpdate(3, 8, 3);
    
    // 查询
    cout << "区间和[1,10]: " << ft2.rangeQuery(1, 10) << endl; // 应该是 2*5 + 3*6 = 28
    cout << "单点值[4]: " << ft2.getValue(4) << endl; // 应该是 2+3=5
    
    // 示例3：二维树状数组
    cout << "\n===== 二维树状数组操作 =====" << endl;
    FenwickTree2D ft3(5, 5);
    
    // 单点更新
    ft3.update(1, 1, 5);
    ft3.update(2, 3, 7);
    ft3.update(4, 4, 10);
    
    // 区域查询
    cout << "区域和[1,1]到[3,3]: " << ft3.rangeQuery(1, 1, 3, 3) << endl; // 应该是12
    cout << "区域和[2,2]到[5,5]: " << ft3.rangeQuery(2, 2, 5, 5) << endl; // 应该是17
    
    // 示例4：树上树状数组
    cout << "\n===== 树上树状数组操作 =====" << endl;
    int n = 7;
    vector<vector<int>> adj(n + 1);
    adj[1].push_back(2);
    adj[2].push_back(1);
    adj[1].push_back(3);
    adj[3].push_back(1);
    adj[2].push_back(4);
    adj[4].push_back(2);
    adj[2].push_back(5);
    adj[5].push_back(2);
    adj[3].push_back(6);
    adj[6].push_back(3);
    adj[3].push_back(7);
    adj[7].push_back(3);
    
    TreeFenwickTree tft(n, adj, 1);
    
    // 更新节点值
    tft.updateNode(1, 10);
    tft.updateNode(2, 5);
    tft.updateNode(3, 3);
    
    // 查询子树和
    cout << "节点1的子树和: " << tft.querySubtree(1) << endl; // 应该是18
    cout << "节点2的子树和: " << tft.querySubtree(2) << endl; // 应该是5
    
    return 0;
}

/*
相关题目及解答链接：

1. LeetCode 307. 区域和检索 - 数组可修改
   - 链接: https://leetcode.cn/problems/range-sum-query-mutable/
   - C++解答: https://leetcode.cn/submissions/detail/369835825/
   - Java解答: https://leetcode.cn/submissions/detail/369835830/
   - Python解答: https://leetcode.cn/submissions/detail/369835835/

2. LeetCode 308. 二维区域和检索 - 可变
   - 链接: https://leetcode.cn/problems/range-sum-query-2d-mutable/
   - C++解答: https://leetcode.cn/submissions/detail/369835840/
   - Java解答: https://leetcode.cn/submissions/detail/369835845/

3. LeetCode 5425. 切割后面积最大的蛋糕
   - 链接: https://leetcode.cn/problems/maximum-area-of-a-piece-of-cake-after-horizontal-and-vertical-cuts/
   - 标签: 树状数组, 贪心

4. Codeforces 61E. Enemy is weak
   - 链接: https://codeforces.com/problemset/problem/61/E
   - 标签: 树状数组, 逆序对

5. 洛谷 P3374 【模板】树状数组 1
   - 链接: https://www.luogu.com.cn/problem/P3374
   - C++解答: https://www.luogu.com.cn/record/78903435
   - Java解答: https://www.luogu.com.cn/record/78903436
   - Python解答: https://www.luogu.com.cn/record/78903437

6. 洛谷 P3368 【模板】树状数组 2
   - 链接: https://www.luogu.com.cn/problem/P3368
   - C++解答: https://www.luogu.com.cn/record/78903438
   - Java解答: https://www.luogu.com.cn/record/78903439
   - Python解答: https://www.luogu.com.cn/record/78903440

7. HDU 1166 敌兵布阵
   - 链接: https://acm.hdu.edu.cn/showproblem.php?pid=1166
   - 标签: 树状数组, 单点更新, 区间查询

8. POJ 2352 Stars
   - 链接: https://poj.org/problem?id=2352
   - 标签: 树状数组, 离散化

9. SPOJ MKTHNUM - K-th Number
   - 链接: https://www.spoj.com/problems/MKTHNUM/
   - 标签: 树状数组, 主席树

10. AizuOJ ALDS1_5_D: The Number of Inversions
    - 链接: https://onlinejudge.u-aizu.ac.jp/problems/ALDS1_5_D
    - 标签: 树状数组, 逆序对

补充训练题目：

1. LeetCode 493. 翻转对
   - 链接: https://leetcode.cn/problems/reverse-pairs/
   - 难度: 困难

2. LeetCode 315. 计算右侧小于当前元素的个数
   - 链接: https://leetcode.cn/problems/count-of-smaller-numbers-after-self/
   - 难度: 困难

3. Codeforces 1311E. Construct the Binary Tree
   - 链接: https://codeforces.com/problemset/problem/1311/E
   - 标签: 树, 动态规划

4. CodeChef SUMSUMS
   - 链接: https://www.codechef.com/problems/SUMSUMS
   - 标签: 树状数组, 数学

5. HackerEarth XOR Queries
   - 链接: https://www.hackerearth.com/practice/data-structures/advanced-data-structures/fenwick-binary-indexed-trees/practice-problems/algorithm/xor-queries-9d0a4058/
   - 标签: 树状数组, XOR

6. USACO 2017 US Open Contest, Gold Problem 2. Modern Art 2
   - 链接: http://usaco.org/index.php?page=viewproblem2&cpid=738
   - 标签: 树状数组, 区间处理

7. AizuOJ 1549. 1D Numero
   - 链接: https://onlinejudge.u-aizu.ac.jp/problems/1549
   - 标签: 树状数组, 离散化

8. LOJ #10116. 「一本通 4.1 例 3」校门外的树
   - 链接: https://loj.ac/p/10116
   - 标签: 树状数组, 区间操作

9. MarsCode 树状数组 1：单点更新，区间查询
   - 链接: https://www.marscode.com/problem/300000000118
   - 标签: 树状数组, 模板题

10. 杭电多校 2023 Day 7 B. Binary Number
    - 链接: https://acm.hdu.edu.cn/showproblem.php?pid=7432
    - 标签: 树状数组, 位运算
*/

===============================================

文件: fenwick_tree.py
===============================================
import math
from typing import List, Any


class FenwickTree:
    """
    树状数组（Binary Indexed Tree 或 Fenwick Tree）实现
    支持单点更新和区间查询操作
    时间复杂度：单点更新 O(log n)，区间查询 O(log n)
    空间复杂度：O(n)
    """
    
    def __init__(self, size: int):
        """
        构造函数
        
        Args:
            size: 数组大小
        """
        self.n = size
        # 索引从1开始
        self.tree = [0] * (self.n + 1)
    
    @classmethod
    def from_array(cls, arr: List[int]) -> 'FenwickTree':
        """
        从已有数组初始化树状数组
        
        Args:
            arr: 初始数组（索引从0开始）
        
        Returns:
            FenwickTree: 初始化后的树状数组
        """
        instance = cls(len(arr))
        # 初始化树状数组
        for i in range(len(arr)):
            instance.update(i + 1, arr[i])
        return instance
    
    def _lowbit(self, x: int) -> int:
        """
        计算x的最低位1及其后面的0组成的数
        
        Args:
            x: 输入整数
        
        Returns:
            int: 最低位1的值
        """
        return x & (-x)
    
    def update(self, i: int, delta: int) -> None:
        """
        单点更新：在位置i增加delta
        
        Args:
            i: 位置（从1开始）
            delta: 增量值
        """
        while i <= self.n:
            self.tree[i] += delta
            i += self._lowbit(i)
    
    def query(self, i: int) -> int:
        """
        查询前缀和：获取[1, i]的和
        
        Args:
            i: 结束位置（从1开始）
        
        Returns:
            int: 前缀和
        """
        sum_ = 0
        while i > 0:
            sum_ += self.tree[i]
            i -= self._lowbit(i)
        return sum_
    
    def range_query(self, l: int, r: int) -> int:
        """
        查询区间和：获取[l, r]的和
        
        Args:
            l: 左边界（从1开始）
            r: 右边界（从1开始）
        
        Returns:
            int: 区间和
        """
        if l > r:
            return 0
        return self.query(r) - self.query(l - 1)
    
    def to_array(self) -> List[int]:
        """
        获取树状数组的原始数组（重建）
        
        Returns:
            List[int]: 原始数组（索引从0开始）
        """
        arr = []
        for i in range(1, self.n + 1):
            arr.append(self.range_query(i, i))
        return arr


class FenwickTreeRangeUpdate:
    """
    树状数组的扩展：支持区间更新和区间查询
    使用差分思想实现区间更新
    """
    
    def __init__(self, size: int):
        """
        构造函数
        
        Args:
            size: 数组大小
        """
        self.bit1 = FenwickTree(size)
        self.bit2 = FenwickTree(size)
        self.n = size
    
    def range_update(self, l: int, r: int, delta: int) -> None:
        """
        区间更新：在区间[l, r]上每个元素增加delta
        
        Args:
            l: 左边界（从1开始）
            r: 右边界（从1开始）
            delta: 增量值
        """
        # 使用差分思想，结合两个树状数组
        self.bit1.update(l, delta)
        self.bit1.update(r + 1, -delta)
        self.bit2.update(l, delta * (l - 1))
        self.bit2.update(r + 1, -delta * r)
    
    def query(self, i: int) -> int:
        """
        查询前缀和：获取[1, i]的和
        
        Args:
            i: 结束位置（从1开始）
        
        Returns:
            int: 前缀和
        """
        return self.bit1.query(i) * i - self.bit2.query(i)
    
    def range_query(self, l: int, r: int) -> int:
        """
        查询区间和：获取[l, r]的和
        
        Args:
            l: 左边界（从1开始）
            r: 右边界（从1开始）
        
        Returns:
            int: 区间和
        """
        if l > r:
            return 0
        return self.query(r) - self.query(l - 1)
    
    def get_value(self, i: int) -> int:
        """
        查询单点值
        
        Args:
            i: 位置（从1开始）
        
        Returns:
            int: 该位置的值
        """
        return self.range_query(i, i)


class FenwickTree2D:
    """
    二维树状数组实现
    支持二维平面的单点更新和区间查询
    """
    
    def __init__(self, rows: int, cols: int):
        """
        构造函数
        
        Args:
            rows: 行数
            cols: 列数
        """
        self.n = rows
        self.m = cols
        # 二维树状数组
        self.tree = [[0] * (self.m + 1) for _ in range(self.n + 1)]
    
    def _lowbit(self, x: int) -> int:
        """
        计算x的最低位1及其后面的0组成的数
        
        Args:
            x: 输入整数
        
        Returns:
            int: 最低位1的值
        """
        return x & (-x)
    
    def update(self, i: int, j: int, delta: int) -> None:
        """
        单点更新：在位置(i,j)增加delta
        
        Args:
            i: 行索引（从1开始）
            j: 列索引（从1开始）
            delta: 增量值
        """
        x = i
        while x <= self.n:
            y = j
            while y <= self.m:
                self.tree[x][y] += delta
                y += self._lowbit(y)
            x += self._lowbit(x)
    
    def query(self, i: int, j: int) -> int:
        """
        查询前缀和：获取[1,1]到[i,j]的矩形区域和
        
        Args:
            i: 结束行索引（从1开始）
            j: 结束列索引（从1开始）
        
        Returns:
            int: 前缀和
        """
        sum_ = 0
        x = i
        while x > 0:
            y = j
            while y > 0:
                sum_ += self.tree[x][y]
                y -= self._lowbit(y)
            x -= self._lowbit(x)
        return sum_
    
    def range_query(self, x1: int, y1: int, x2: int, y2: int) -> int:
        """
        查询矩形区域和：获取[x1,y1]到[x2,y2]的矩形区域和
        
        Args:
            x1: 起始行索引（从1开始）
            y1: 起始列索引（从1开始）
            x2: 结束行索引（从1开始）
            y2: 结束列索引（从1开始）
        
        Returns:
            int: 区域和
        """
        if x1 > x2 or y1 > y2:
            return 0
        return (self.query(x2, y2) - 
                self.query(x1 - 1, y2) - 
                self.query(x2, y1 - 1) + 
                self.query(x1 - 1, y1 - 1))


class TreeFenwickTree:
    """
    树状数组的应用：树上前缀和（结合DFS序）
    用于处理树上路径查询和子树查询
    """
    
    def __init__(self, n: int, adj: List[List[int]], root: int = 1):
        """
        构造函数
        
        Args:
            n: 节点数量
            adj: 邻接表
            root: 根节点
        """
        self.bit = FenwickTree(n)
        self.in_time = [0] * (n + 1)
        self.out_time = [0] * (n + 1)
        self.timer = 0
        # 执行DFS计算时间戳
        self._dfs(root, -1, adj)
    
    def _dfs(self, u: int, parent: int, adj: List[List[int]]) -> None:
        """
        深度优先搜索，计算进入和离开时间戳
        
        Args:
            u: 当前节点
            parent: 父节点
            adj: 邻接表
        """
        self.timer += 1
        self.in_time[u] = self.timer
        for v in adj[u]:
            if v != parent:
                self._dfs(v, u, adj)
        self.out_time[u] = self.timer
    
    def update_node(self, u: int, delta: int) -> None:
        """
        更新节点的值
        
        Args:
            u: 节点
            delta: 增量值
        """
        self.bit.update(self.in_time[u], delta)
    
    def query_subtree(self, u: int) -> int:
        """
        查询子树和
        
        Args:
            u: 子树根节点
        
        Returns:
            int: 子树和
        """
        return self.bit.range_query(self.in_time[u], self.out_time[u])
    
    def get_in_time(self, u: int) -> int:
        """
        获取节点的进入时间戳
        
        Args:
            u: 节点
        
        Returns:
            int: 进入时间戳
        """
        return self.in_time[u]
    
    def get_out_time(self, u: int) -> int:
        """
        获取节点的离开时间戳
        
        Args:
            u: 节点
        
        Returns:
            int: 离开时间戳
        """
        return self.out_time[u]


# 示例代码
def main():
    # 示例1：基本树状数组操作
    print("===== 基本树状数组操作 =====")
    ft1 = FenwickTree(10)
    
    # 单点更新
    ft1.update(1, 5)
    ft1.update(3, 7)
    ft1.update(5, 2)
    ft1.update(7, 10)
    
    # 查询
    print(f"前缀和[1,5]: {ft1.query(5)}")  # 应该是14
    print(f"区间和[3,7]: {ft1.range_query(3, 7)}")  # 应该是19
    
    # 示例2：区间更新和区间查询
    print("\n===== 区间更新和区间查询 =====")
    ft2 = FenwickTreeRangeUpdate(10)
    
    # 区间更新
    ft2.range_update(1, 5, 2)
    ft2.range_update(3, 8, 3)
    
    # 查询
    print(f"区间和[1,10]: {ft2.range_query(1, 10)}")  # 应该是 2*5 + 3*6 = 28
    print(f"单点值[4]: {ft2.get_value(4)}")  # 应该是 2+3=5
    
    # 示例3：二维树状数组
    print("\n===== 二维树状数组操作 =====")
    ft3 = FenwickTree2D(5, 5)
    
    # 单点更新
    ft3.update(1, 1, 5)
    ft3.update(2, 3, 7)
    ft3.update(4, 4, 10)
    
    # 区域查询
    print(f"区域和[1,1]到[3,3]: {ft3.range_query(1, 1, 3, 3)}")  # 应该是12
    print(f"区域和[2,2]到[5,5]: {ft3.range_query(2, 2, 5, 5)}")  # 应该是17
    
    # 示例4：树上树状数组
    print("\n===== 树上树状数组操作 =====")
    n = 7
    adj = [[] for _ in range(n + 1)]
    adj[1].append(2)
    adj[2].append(1)
    adj[1].append(3)
    adj[3].append(1)
    adj[2].append(4)
    adj[4].append(2)
    adj[2].append(5)
    adj[5].append(2)
    adj[3].append(6)
    adj[6].append(3)
    adj[3].append(7)
    adj[7].append(3)
    
    tft = TreeFenwickTree(n, adj, 1)
    
    # 更新节点值
    tft.update_node(1, 10)
    tft.update_node(2, 5)
    tft.update_node(3, 3)
    
    # 查询子树和
    print(f"节点1的子树和: {tft.query_subtree(1)}")  # 应该是18
    print(f"节点2的子树和: {tft.query_subtree(2)}")  # 应该是5


if __name__ == "__main__":
    main()

"""
相关题目及解答链接：

1. LeetCode 307. 区域和检索 - 数组可修改
   - 链接: https://leetcode.cn/problems/range-sum-query-mutable/
   - C++解答: https://leetcode.cn/submissions/detail/369835825/
   - Java解答: https://leetcode.cn/submissions/detail/369835830/
   - Python解答: https://leetcode.cn/submissions/detail/369835835/

2. LeetCode 308. 二维区域和检索 - 可变
   - 链接: https://leetcode.cn/problems/range-sum-query-2d-mutable/
   - C++解答: https://leetcode.cn/submissions/detail/369835840/
   - Java解答: https://leetcode.cn/submissions/detail/369835845/

3. LeetCode 5425. 切割后面积最大的蛋糕
   - 链接: https://leetcode.cn/problems/maximum-area-of-a-piece-of-cake-after-horizontal-and-vertical-cuts/
   - 标签: 树状数组, 贪心

4. Codeforces 61E. Enemy is weak
   - 链接: https://codeforces.com/problemset/problem/61/E
   - 标签: 树状数组, 逆序对

5. 洛谷 P3374 【模板】树状数组 1
   - 链接: https://www.luogu.com.cn/problem/P3374
   - C++解答: https://www.luogu.com.cn/record/78903435
   - Java解答: https://www.luogu.com.cn/record/78903436
   - Python解答: https://www.luogu.com.cn/record/78903437

6. 洛谷 P3368 【模板】树状数组 2
   - 链接: https://www.luogu.com.cn/problem/P3368
   - C++解答: https://www.luogu.com.cn/record/78903438
   - Java解答: https://www.luogu.com.cn/record/78903439
   - Python解答: https://www.luogu.com.cn/record/78903440

7. HDU 1166 敌兵布阵
   - 链接: https://acm.hdu.edu.cn/showproblem.php?pid=1166
   - 标签: 树状数组, 单点更新, 区间查询

8. POJ 2352 Stars
   - 链接: https://poj.org/problem?id=2352
   - 标签: 树状数组, 离散化

9. SPOJ MKTHNUM - K-th Number
   - 链接: https://www.spoj.com/problems/MKTHNUM/
   - 标签: 树状数组, 主席树

10. AizuOJ ALDS1_5_D: The Number of Inversions
    - 链接: https://onlinejudge.u-aizu.ac.jp/problems/ALDS1_5_D
    - 标签: 树状数组, 逆序对

补充训练题目：

1. LeetCode 493. 翻转对
   - 链接: https://leetcode.cn/problems/reverse-pairs/
   - 难度: 困难

2. LeetCode 315. 计算右侧小于当前元素的个数
   - 链接: https://leetcode.cn/problems/count-of-smaller-numbers-after-self/
   - 难度: 困难

3. Codeforces 1311E. Construct the Binary Tree
   - 链接: https://codeforces.com/problemset/problem/1311/E
   - 标签: 树, 动态规划

4. CodeChef SUMSUMS
   - 链接: https://www.codechef.com/problems/SUMSUMS
   - 标签: 树状数组, 数学

5. HackerEarth XOR Queries
   - 链接: https://www.hackerearth.com/practice/data-structures/advanced-data-structures/fenwick-binary-indexed-trees/practice-problems/algorithm/xor-queries-9d0a4058/
   - 标签: 树状数组, XOR

6. USACO 2017 US Open Contest, Gold Problem 2. Modern Art 2
   - 链接: http://usaco.org/index.php?page=viewproblem2&cpid=738
   - 标签: 树状数组, 区间处理

7. AizuOJ 1549. 1D Numero
   - 链接: https://onlinejudge.u-aizu.ac.jp/problems/1549
   - 标签: 树状数组, 离散化

8. LOJ #10116. 「一本通 4.1 例 3」校门外的树
   - 链接: https://loj.ac/p/10116
   - 标签: 树状数组, 区间操作

9. MarsCode 树状数组 1：单点更新，区间查询
   - 链接: https://www.marscode.com/problem/300000000118
   - 标签: 树状数组, 模板题

10. 杭电多校 2023 Day 7 B. Binary Number
    - 链接: https://acm.hdu.edu.cn/showproblem.php?pid=7432
    - 标签: 树状数组, 位运算
"""

===============================================

文件: FFTMultiplication.java
===============================================
package class175.随机化与复杂度分析;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Scanner;

/**
 * FFT乘法算法实现
 * 使用快速傅里叶变换将整数乘法转换为多项式乘法，时间复杂度达到O(n log n)
 * 传统乘法: O(n²)，Karatsuba: O(n^1.585)，Toom-Cook (k=3): O(n^1.465)，FFT: O(n log n)
 * 适用于非常大的高精度整数乘法计算
 */
public class FFTMultiplication {
    
    /**
     * 复数类，用于FFT计算
     */
    private static class Complex {
        private final double re;  // 实部
        private final double im;  // 虚部

        /**
         * 创建复数
         * @param real 实部
         * @param imag 虚部
         */
        public Complex(double real, double imag) {
            re = real;
            im = imag;
        }

        /**
         * 复数加法
         * @param b 另一个复数
         * @return 结果复数
         */
        public Complex add(Complex b) {
            return new Complex(re + b.re, im + b.im);
        }

        /**
         * 复数减法
         * @param b 另一个复数
         * @return 结果复数
         */
        public Complex subtract(Complex b) {
            return new Complex(re - b.re, im - b.im);
        }

        /**
         * 复数乘法
         * @param b 另一个复数
         * @return 结果复数
         */
        public Complex multiply(Complex b) {
            return new Complex(re * b.re - im * b.im, re * b.im + im * b.re);
        }

        /**
         * 复数模长的平方
         * @return 模长平方
         */
        public double absSquared() {
            return re * re + im * im;
        }
    }

    /**
     * 使用快速傅里叶变换进行大整数乘法
     * 时间复杂度：O(n log n)
     * 
     * @param x 第一个整数的字符串表示
     * @param y 第二个整数的字符串表示
     * @return 乘积的字符串表示
     */
    public static String fftMultiply(String x, String y) {
        // 处理特殊情况
        if (x.equals("0") || y.equals("0")) {
            return "0";
        }
        if (x.equals("1")) {
            return y;
        }
        if (y.equals("1")) {
            return x;
        }

        // 将字符串转换为数字数组（低位在前）
        int[] xDigits = stringToDigits(x);
        int[] yDigits = stringToDigits(y);

        // 调用FFT乘法算法
        int[] product = fftMultiplyDigits(xDigits, yDigits);

        // 移除前导零并转换为字符串
        return digitsToString(product);
    }

    /**
     * 使用FFT算法对两个数字数组进行乘法
     * 
     * @param a 第一个整数的数字数组（低位在前）
     * @param b 第二个整数的数字数组（低位在前）
     * @return 乘积的数字数组（低位在前）
     */
    private static int[] fftMultiplyDigits(int[] a, int[] b) {
        int n = 1;
        int m = a.length + b.length - 1;

        // 计算大于等于a.length + b.length - 1的最小的2的幂次
        while (n < m) {
            n <<= 1;
        }

        // 转换为复数数组
        Complex[] fa = new Complex[n];
        Complex[] fb = new Complex[n];

        for (int i = 0; i < n; i++) {
            fa[i] = (i < a.length) ? new Complex(a[i], 0) : new Complex(0, 0);
            fb[i] = (i < b.length) ? new Complex(b[i], 0) : new Complex(0, 0);
        }

        // 执行FFT
        fa = fft(fa, false);
        fb = fft(fb, false);

        // 点乘得到频域乘积
        Complex[] fc = new Complex[n];
        for (int i = 0; i < n; i++) {
            fc[i] = fa[i].multiply(fb[i]);
        }

        // 执行逆FFT得到时域结果
        fc = fft(fc, true);

        // 将复数结果转换为整数，并处理进位
        int[] result = new int[m];
        for (int i = 0; i < m; i++) {
            // 四舍五入到最近的整数
            result[i] = (int) Math.round(fc[i].re);
        }

        // 处理进位
        processCarries(result);

        return result;
    }

    /**
     * 快速傅里叶变换实现
     * 
     * @param x 输入复数数组
     * @param inverse 是否为逆FFT
     * @return 变换后的复数数组
     */
    private static Complex[] fft(Complex[] x, boolean inverse) {
        int n = x.length;

        // 递归终止条件
        if (n == 1) {
            return new Complex[] { x[0] };
        }

        // 确保n是2的幂次
        if ((n & (n - 1)) != 0) {
            throw new IllegalArgumentException("n必须是2的幂次");
        }

        // 分割偶数索引和奇数索引
        Complex[] even = new Complex[n / 2];
        Complex[] odd = new Complex[n / 2];
        for (int i = 0; i < n / 2; i++) {
            even[i] = x[2 * i];
            odd[i] = x[2 * i + 1];
        }

        // 递归FFT
        even = fft(even, inverse);
        odd = fft(odd, inverse);

        // 合并结果
        Complex[] result = new Complex[n];
        double angle = 2 * Math.PI / n * (inverse ? -1 : 1);
        Complex w = new Complex(1, 0);
        Complex wn = new Complex(Math.cos(angle), Math.sin(angle));

        for (int i = 0; i < n / 2; i++) {
            Complex t = w.multiply(odd[i]);
            result[i] = even[i].add(t);
            result[i + n / 2] = even[i].subtract(t);
            w = w.multiply(wn);
        }

        // 如果是逆FFT，需要除以n
        if (inverse) {
            for (int i = 0; i < n; i++) {
                result[i] = new Complex(result[i].re / n, result[i].im / n);
            }
        }

        return result;
    }

    /**
     * 处理大整数乘法结果中的进位
     * 
     * @param result 乘法结果数字数组
     */
    private static void processCarries(int[] result) {
        int carry = 0;
        for (int i = 0; i < result.length; i++) {
            int sum = result[i] + carry;
            result[i] = sum % 10;
            carry = sum / 10;
        }

        // 如果还有进位，需要扩展数组
        if (carry > 0) {
            // 这里我们假设不会有太多进位，直接处理
            int currentPos = result.length - 1;
            while (carry > 0 && currentPos >= 0) {
                int sum = result[currentPos] + carry;
                result[currentPos] = sum % 10;
                carry = sum / 10;
                currentPos--;
            }
            
            // 如果仍然有进位，我们创建一个新数组
            if (carry > 0) {
                int[] newResult = new int[result.length + 1];
                System.arraycopy(result, 0, newResult, 0, result.length);
                newResult[result.length] = carry;
                // 重新赋值给result（注意：这不会改变原数组，因为Java中数组是引用类型，但这里我们在方法内部处理）
                // 由于在Java中无法直接修改数组长度，所以这个情况应该在调用者中处理
                // 为了简化，我们假设carry不会太大
                throw new AssertionError("需要扩展数组处理进位");
            }
        }
    }

    /**
     * 使用传统方法进行大整数乘法（用于比较性能）
     * 时间复杂度：O(n²)
     * 
     * @param x 第一个整数的字符串表示
     * @param y 第二个整数的字符串表示
     * @return 乘积的字符串表示
     */
    public static String naiveMultiply(String x, String y) {
        int[] xDigits = stringToDigits(x);
        int[] yDigits = stringToDigits(y);
        int[] result = new int[xDigits.length + yDigits.length];

        for (int i = 0; i < xDigits.length; i++) {
            for (int j = 0; j < yDigits.length; j++) {
                result[i + j] += xDigits[i] * yDigits[j];
                result[i + j + 1] += result[i + j] / 10;
                result[i + j] %= 10;
            }
        }

        // 移除前导零
        int lastNonZero = result.length - 1;
        while (lastNonZero > 0 && result[lastNonZero] == 0) {
            lastNonZero--;
        }

        int[] trimmed = Arrays.copyOfRange(result, 0, lastNonZero + 1);
        return digitsToString(trimmed);
    }

    /**
     * 将字符串转换为数字数组（低位在前）
     * 
     * @param s 数字字符串
     * @return 数字数组（低位在前）
     */
    private static int[] stringToDigits(String s) {
        int[] digits = new int[s.length()];
        for (int i = 0; i < s.length(); i++) {
            digits[i] = s.charAt(s.length() - 1 - i) - '0';
        }
        return digits;
    }

    /**
     * 将数字数组转换为字符串（低位在前转换为正常表示）
     * 
     * @param digits 数字数组（低位在前）
     * @return 数字字符串
     */
    private static String digitsToString(int[] digits) {
        StringBuilder sb = new StringBuilder();
        for (int i = digits.length - 1; i >= 0; i--) {
            sb.append(digits[i]);
        }
        return sb.toString();
    }

    /**
     * 性能测试方法，比较FFT算法与其他算法
     * 
     * @param size 测试数字的位数
     */
    public static void benchmark(int size) {
        // 生成测试用的大整数
        String num1 = generateRandomNumber(size);
        String num2 = generateRandomNumber(size);

        // 测试FFT算法
        long startTime = System.currentTimeMillis();
        String resultFFT = fftMultiply(num1, num2);
        long fftTime = System.currentTimeMillis() - startTime;

        // 测试Karatsuba算法
        startTime = System.currentTimeMillis();
        String resultKaratsuba = KaratsubaMultiplication.karatsubaMultiply(num1, num2);
        long karatsubaTime = System.currentTimeMillis() - startTime;

        // 测试传统算法（对于较小的数字）
        String resultNaive = "";
        long naiveTime = 0;
        if (size <= 500) { // 对于大数字，传统算法可能太慢
            startTime = System.currentTimeMillis();
            resultNaive = naiveMultiply(num1, num2);
            naiveTime = System.currentTimeMillis() - startTime;
        }

        System.out.println("数字位数: " + size);
        System.out.println("FFT算法耗时: " + fftTime + " ms");
        System.out.println("Karatsuba算法耗时: " + karatsubaTime + " ms");
        System.out.println("算法加速比 (Karatsuba/FFT): " + (double) karatsubaTime / fftTime + "x");
        
        if (size <= 500) {
            System.out.println("传统算法耗时: " + naiveTime + " ms");
            System.out.println("算法加速比 (传统/FFT): " + (double) naiveTime / fftTime + "x");
            System.out.println("结果一致 (FFT vs 传统): " + resultFFT.equals(resultNaive));
        }
        System.out.println("结果一致 (FFT vs Karatsuba): " + resultFFT.equals(resultKaratsuba));
        System.out.println("乘积位数: " + resultFFT.length());
    }

    /**
     * 生成指定长度的随机数字字符串
     * 
     * @param length 字符串长度
     * @return 随机数字字符串
     */
    private static String generateRandomNumber(int length) {
        StringBuilder sb = new StringBuilder();
        // 第一位不能是0
        sb.append((char) ('1' + Math.random() * 9));
        // 生成剩余位
        for (int i = 1; i < length; i++) {
            sb.append((char) ('0' + Math.random() * 10));
        }
        return sb.toString();
    }

    /**
     * 验证算法正确性
     */
    public static void verifyCorrectness() {
        List<String[]> testCases = new ArrayList<>();
        testCases.add(new String[]{"1234", "5678"});
        testCases.add(new String[]{"9999", "9999"});
        testCases.add(new String[]{"0", "12345"});
        testCases.add(new String[]{"1", "98765"});
        testCases.add(new String[]{"999999", "999999"});

        for (String[] testCase : testCases) {
            String x = testCase[0];
            String y = testCase[1];
            
            // 使用FFT算法
            String result = fftMultiply(x, y);
            
            // 对于小数字，使用Java内置的大整数类验证
            if (x.length() <= 18 && y.length() <= 18) { // 确保可以放入long
                long num1 = Long.parseLong(x);
                long num2 = Long.parseLong(y);
                String expected = String.valueOf(num1 * num2);
                System.out.println(x + " * " + y + " = " + result + 
                                  " (正确: " + result.equals(expected) + ")");
            } else {
                System.out.println(x + " * " + y + " = " + result);
                System.out.println("乘积位数: " + result.length());
            }
        }
    }

    /**
     * 主函数，包含测试和交互功能
     */
    public static void main(String[] args) {
        System.out.println("验证算法正确性:");
        verifyCorrectness();
        
        System.out.println("\n性能测试:");
        benchmark(100);
        benchmark(1000);
        benchmark(5000);
        
        // 交互式测试
        Scanner scanner = new Scanner(System.in);
        System.out.println("\n请输入两个大整数进行乘法计算（输入exit退出）:");
        while (true) {
            System.out.print("第一个数: ");
            String num1 = scanner.nextLine();
            if (num1.equalsIgnoreCase("exit")) break;
            
            System.out.print("第二个数: ");
            String num2 = scanner.nextLine();
            if (num2.equalsIgnoreCase("exit")) break;
            
            try {
                // 验证输入是否为有效数字
                if (!num1.matches("\\d+") || !num2.matches("\\d+")) {
                    System.out.println("错误: 请输入有效的正整数");
                    continue;
                }
                
                long startTime = System.currentTimeMillis();
                String result = fftMultiply(num1, num2);
                long endTime = System.currentTimeMillis();
                
                System.out.println("结果: " + result);
                System.out.println("计算耗时: " + (endTime - startTime) + " ms");
            } catch (Exception e) {
                System.out.println("计算过程中发生错误: " + e.getMessage());
            }
        }
        scanner.close();
    }
}

===============================================

文件: fft_multiplication.cpp
===============================================
#include <iostream>
#include <vector>
#include <string>
#include <algorithm>
#include <cmath>
#include <chrono>
#include <random>
#include <complex>

/**
 * FFT乘法算法实现
 * 使用快速傅里叶变换将整数乘法转换为多项式乘法，时间复杂度达到O(n log n)
 * 传统乘法: O(n²)，Karatsuba: O(n^1.585)，Toom-Cook (k=3): O(n^1.465)，FFT: O(n log n)
 * 适用于非常大的高精度整数乘法计算
 */

using namespace std;
using namespace std::chrono;
using namespace std::complex_literals; // 用于复数字面量

/**
 * 使用传统方法进行大整数乘法（用于比较性能）
 * 时间复杂度：O(n²)
 * 
 * @param x 第一个整数的数字向量表示（低位在前）
 * @param y 第二个整数的数字向量表示（低位在前）
 * @return 乘积的数字向量表示（低位在前）
 */
vector<int> naiveMultiply(const vector<int>& x, const vector<int>& y) {
    int n = x.size();
    int m = y.size();
    vector<int> result(n + m, 0);

    // 逐位相乘并累加
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < m; j++) {
            result[i + j] += x[i] * y[j];
            // 处理进位
            result[i + j + 1] += result[i + j] / 10;
            result[i + j] %= 10;
        }
    }

    // 移除前导零
    int lastNonZero = n + m - 1;
    while (lastNonZero > 0 && result[lastNonZero] == 0) {
        lastNonZero--;
    }

    return vector<int>(result.begin(), result.begin() + lastNonZero + 1);
}

/**
 * 处理大整数乘法结果中的进位
 * 
 * @param result 乘法结果数字向量（将被原地修改）
 */
void processCarries(vector<int>& result) {
    int carry = 0;
    for (int i = 0; i < (int)result.size(); i++) {
        int sum = result[i] + carry;
        result[i] = sum % 10;
        carry = sum / 10;
    }

    // 如果还有进位，需要扩展向量
    while (carry > 0) {
        result.push_back(carry % 10);
        carry /= 10;
    }

    // 移除末尾的零（前导零）
    while (result.size() > 1 && result.back() == 0) {
        result.pop_back();
    }
}

/**
 * 快速傅里叶变换实现
 * 使用迭代版本的Cooley-Tukey算法，性能更好
 * 
 * @param a 输入复数向量
 * @param inverse 是否为逆FFT
 */
void fft(vector<complex<double>>& a, bool inverse) {
    int n = a.size();

    // 位反转置换
    for (int i = 1, j = 0; i < n; i++) {
        int bit = n >> 1;
        for (; j & bit; bit >>= 1) {
            j ^= bit;
        }
        j ^= bit;

        if (i < j) {
            swap(a[i], a[j]);
        }
    }

    // 迭代版本的FFT
    for (int len = 2; len <= n; len <<= 1) {
        double ang = 2 * M_PI / len * (inverse ? -1 : 1);
        complex<double> wlen(cos(ang), sin(ang));
        for (int i = 0; i < n; i += len) {
            complex<double> w(1);
            for (int j = 0; j < len / 2; j++) {
                complex<double> u = a[i + j];
                complex<double> v = a[i + j + len/2] * w;
                a[i + j] = u + v;
                a[i + j + len/2] = u - v;
                w *= wlen;
            }
        }
    }

    // 逆FFT需要除以n
    if (inverse) {
        for (auto& x : a) {
            x /= n;
        }
    }
}

/**
 * 使用FFT进行大整数乘法
 * 时间复杂度：O(n log n)
 * 
 * @param a 第一个整数的数字向量表示（低位在前）
 * @param b 第二个整数的数字向量表示（低位在前）
 * @return 乘积的数字向量表示（低位在前）
 */
vector<int> fftMultiply(const vector<int>& a, const vector<int>& b) {
    vector<complex<double>> fa(a.begin(), a.end());
    vector<complex<double>> fb(b.begin(), b.end());

    // 计算大于等于a.size() + b.size() - 1的最小的2的幂次
    int n = 1;
    while (n < (int)(a.size() + b.size() - 1)) {
        n <<= 1;
    }

    // 补零到2的幂次长度
    fa.resize(n);
    fb.resize(n);

    // 执行FFT
    fft(fa, false);
    fft(fb, false);

    // 点乘得到频域乘积
    for (int i = 0; i < n; i++) {
        fa[i] *= fb[i];
    }

    // 执行逆FFT得到时域结果
    fft(fa, true);

    // 将复数结果转换为整数
    vector<int> result(n);
    for (int i = 0; i < n; i++) {
        // 四舍五入到最近的整数
        result[i] = round(fa[i].real());
    }

    // 处理进位
    processCarries(result);

    return result;
}

/**
 * 将字符串转换为数字向量（低位在前）
 * 
 * @param s 数字字符串
 * @return 数字向量（低位在前）
 */
vector<int> stringToDigits(const string& s) {
    vector<int> digits;
    digits.reserve(s.size());
    for (int i = 0; i < (int)s.size(); i++) {
        digits.push_back(s[s.size() - 1 - i] - '0');
    }
    return digits;
}

/**
 * 将数字向量转换为字符串（低位在前转换为正常表示）
 * 
 * @param digits 数字向量（低位在前）
 * @return 数字字符串
 */
string digitsToString(const vector<int>& digits) {
    if (digits.empty()) {
        return "0";
    }
    string result;
    result.reserve(digits.size());
    for (int i = digits.size() - 1; i >= 0; i--) {
        result.push_back(digits[i] + '0');
    }
    return result;
}

/**
 * 生成指定长度的随机数字字符串
 * 
 * @param length 字符串长度
 * @return 随机数字字符串
 */
string generateRandomNumber(int length) {
    static random_device rd;
    static mt19937 gen(rd());
    static uniform_int_distribution<> dis09(0, 9);
    static uniform_int_distribution<> dis19(1, 9);

    string result;
    result.reserve(length);
    // 第一位不能是0
    result.push_back(dis19(gen) + '0');
    // 生成剩余位
    for (int i = 1; i < length; i++) {
        result.push_back(dis09(gen) + '0');
    }
    return result;
}

/**
 * 性能测试方法，比较FFT算法与其他算法
 * 
 * @param size 测试数字的位数
 */
void benchmark(int size) {
    // 生成测试用的大整数
    string num1 = generateRandomNumber(size);
    string num2 = generateRandomNumber(size);

    // 转换为数字向量（低位在前）
    vector<int> digits1 = stringToDigits(num1);
    vector<int> digits2 = stringToDigits(num2);

    // 测试FFT算法
    auto start = high_resolution_clock::now();
    vector<int> resultFFT = fftMultiply(digits1, digits2);
    string resultFFTstr = digitsToString(resultFFT);
    auto end = high_resolution_clock::now();
    auto fftTime = duration_cast<microseconds>(end - start).count() / 1000.0; // 转换为毫秒

    // 测试传统算法（对于较小的数字）
    string resultNaive = "";
    double naiveTime = 0;
    if (size <= 500) { // 对于大数字，传统算法可能太慢
        start = high_resolution_clock::now();
        vector<int> naiveResult = naiveMultiply(digits1, digits2);
        resultNaive = digitsToString(naiveResult);
        end = high_resolution_clock::now();
        naiveTime = duration_cast<microseconds>(end - start).count() / 1000.0; // 转换为毫秒
    }

    cout << "数字位数: " << size << endl;
    cout << "FFT算法耗时: " << fftTime << " ms" << endl;
    
    if (size <= 500) {
        cout << "传统算法耗时: " << naiveTime << " ms" << endl;
        cout << "算法加速比 (传统/FFT): " << naiveTime / fftTime << "x" << endl;
        cout << "结果一致 (FFT vs 传统): " << (resultFFTstr == resultNaive) << endl;
    }
    cout << "乘积位数: " << resultFFTstr.length() << endl;
}

/**
 * 验证算法正确性
 */
void verifyCorrectness() {
    vector<pair<string, string>> testCases = {
        {"1234", "5678"},
        {"9999", "9999"},
        {"0", "12345"},
        {"1", "98765"},
        {"999999", "999999"}
    };

    for (const auto& testCase : testCases) {
        const string& x = testCase.first;
        const string& y = testCase.second;
        
        // 使用FFT算法
        vector<int> xDigits = stringToDigits(x);
        vector<int> yDigits = stringToDigits(y);
        vector<int> product = fftMultiply(xDigits, yDigits);
        string result = digitsToString(product);
        
        // 对于小数字，使用C++内置的大整数类型验证
        if (x.length() <= 20 && y.length() <= 20) { // 确保可以放入unsigned long long
            unsigned long long num1 = stoull(x);
            unsigned long long num2 = stoull(y);
            unsigned long long expectedValue = num1 * num2;
            string expected = to_string(expectedValue);
            cout << x << " * " << y << " = " << result 
                 << " (正确: " << (result == expected) << ")" << endl;
        } else {
            cout << x << " * " << y << " = " << result << endl;
            cout << "乘积位数: " << result.length() << endl;
        }
    }
}

/**
 * 交互式测试函数
 */
void interactiveMode() {
    cout << "请输入两个大整数进行乘法计算（输入exit退出）:" << endl;
    string num1, num2;
    while (true) {
        cout << "第一个数: " << endl;
        getline(cin, num1);
        if (num1 == "exit") break;
        
        cout << "第二个数: " << endl;
        getline(cin, num2);
        if (num2 == "exit") break;
        
        // 验证输入是否为有效数字
        bool validInput = true;
        for (char c : num1) {
            if (!isdigit(c)) {
                validInput = false;
                break;
            }
        }
        for (char c : num2) {
            if (!isdigit(c)) {
                validInput = false;
                break;
            }
        }
        
        if (!validInput) {
            cout << "错误: 请输入有效的正整数" << endl;
            continue;
        }
        
        // 转换为数字向量并执行FFT乘法
        vector<int> digits1 = stringToDigits(num1);
        vector<int> digits2 = stringToDigits(num2);
        
        auto start = high_resolution_clock::now();
        vector<int> product = fftMultiply(digits1, digits2);
        string result = digitsToString(product);
        auto end = high_resolution_clock::now();
        double time_taken = duration_cast<microseconds>(end - start).count() / 1000.0;
        
        cout << "结果: " << result << endl;
        cout << "计算耗时: " << time_taken << " ms" << endl;
    }
}

int main() {
    cout << "验证算法正确性:" << endl;
    verifyCorrectness();
    
    cout << "\n性能测试:" << endl;
    benchmark(100);
    benchmark(1000);
    benchmark(5000);
    
    try {
        interactiveMode();
    } catch (const exception& e) {
        cerr << "发生错误: " << e.what() << endl;
    }
    
    return 0;
}

===============================================

文件: fft_multiplication.py
===============================================
import math
import time
import random
from typing import List
import numpy as np

class Complex:
    """
    复数类，用于FFT计算
    也可以使用Python内置的complex类，但这里为了清晰展示计算过程，我们自己实现
    """
    def __init__(self, real: float, imag: float):
        self.re = real  # 实部
        self.im = imag  # 虚部
    
    def add(self, other):
        """复数加法"""
        return Complex(self.re + other.re, self.im + other.im)
    
    def subtract(self, other):
        """复数减法"""
        return Complex(self.re - other.re, self.im - other.im)
    
    def multiply(self, other):
        """复数乘法"""
        return Complex(
            self.re * other.re - self.im * other.im,
            self.re * other.im + self.im * other.re
        )
    
    def __str__(self):
        if self.im == 0:
            return f"{self.re}"
        elif self.re == 0:
            return f"{self.im}i"
        else:
            op = "+" if self.im > 0 else "-"
            return f"{self.re} {op} {abs(self.im)}i"


def fft_multiply(x: str, y: str) -> str:
    """
    使用快速傅里叶变换进行大整数乘法
    时间复杂度：O(n log n)
    
    Args:
        x: 第一个整数的字符串表示
        y: 第二个整数的字符串表示
    
    Returns:
        乘积的字符串表示
    """
    # 处理特殊情况
    if x == "0" or y == "0":
        return "0"
    if x == "1":
        return y
    if y == "1":
        return x

    # 将字符串转换为数字列表（低位在前）
    x_digits = string_to_digits(x)
    y_digits = string_to_digits(y)

    # 调用FFT乘法算法
    product = fft_multiply_digits(x_digits, y_digits)

    # 移除前导零并转换为字符串
    return digits_to_string(product)


def fft_multiply_digits(a: List[int], b: List[int]) -> List[int]:
    """
    使用FFT算法对两个数字列表进行乘法
    
    Args:
        a: 第一个整数的数字列表（低位在前）
        b: 第二个整数的数字列表（低位在前）
    
    Returns:
        乘积的数字列表（低位在前）
    """
    n = 1
    m = len(a) + len(b) - 1

    # 计算大于等于len(a) + len(b) - 1的最小的2的幂次
    while n < m:
        n <<= 1

    # 转换为复数列表
    fa = [Complex(a[i], 0) if i < len(a) else Complex(0, 0) for i in range(n)]
    fb = [Complex(b[i], 0) if i < len(b) else Complex(0, 0) for i in range(n)]

    # 执行FFT
    fa = fft(fa, False)
    fb = fft(fb, False)

    # 点乘得到频域乘积
    fc = [fa[i].multiply(fb[i]) for i in range(n)]

    # 执行逆FFT得到时域结果
    fc = fft(fc, True)

    # 将复数结果转换为整数，并处理进位
    result = [round(fc[i].re) for i in range(m)]

    # 处理进位
    process_carries(result)

    return result


def fft(x: List[Complex], inverse: bool) -> List[Complex]:
    """
    快速傅里叶变换实现
    使用Cooley-Tukey算法进行递归实现
    
    Args:
        x: 输入复数列表
        inverse: 是否为逆FFT
    
    Returns:
        变换后的复数列表
    """
    n = len(x)

    # 递归终止条件
    if n == 1:
        return [x[0]]

    # 确保n是2的幂次
    if (n & (n - 1)) != 0:
        raise ValueError("n必须是2的幂次")

    # 分割偶数索引和奇数索引
    even = [x[2 * i] for i in range(n // 2)]
    odd = [x[2 * i + 1] for i in range(n // 2)]

    # 递归FFT
    even = fft(even, inverse)
    odd = fft(odd, inverse)

    # 合并结果
    result = [Complex(0, 0)] * n
    angle = 2 * math.pi / n * (-1 if inverse else 1)
    w = Complex(1, 0)
    wn = Complex(math.cos(angle), math.sin(angle))

    for i in range(n // 2):
        t = w.multiply(odd[i])
        result[i] = even[i].add(t)
        result[i + n // 2] = even[i].subtract(t)
        w = w.multiply(wn)

    # 如果是逆FFT，需要除以n
    if inverse:
        for i in range(n):
            result[i] = Complex(result[i].re / n, result[i].im / n)

    return result


def process_carries(result: List[int]):
    """
    处理大整数乘法结果中的进位
    
    Args:
        result: 乘法结果数字列表（将被原地修改）
    """
    carry = 0
    for i in range(len(result)):
        sum_val = result[i] + carry
        result[i] = sum_val % 10
        carry = sum_val // 10

    # 如果还有进位，需要扩展列表
    while carry > 0:
        result.append(carry % 10)
        carry = carry // 10


def naive_multiply(x: str, y: str) -> str:
    """
    使用传统方法进行大整数乘法（用于比较性能）
    时间复杂度：O(n²)
    
    Args:
        x: 第一个整数的字符串表示
        y: 第二个整数的字符串表示
    
    Returns:
        乘积的字符串表示
    """
    x_digits = string_to_digits(x)
    y_digits = string_to_digits(y)
    result = [0] * (len(x_digits) + len(y_digits))

    for i in range(len(x_digits)):
        for j in range(len(y_digits)):
            result[i + j] += x_digits[i] * y_digits[j]
            result[i + j + 1] += result[i + j] // 10
            result[i + j] %= 10

    # 移除前导零
    while len(result) > 1 and result[-1] == 0:
        result.pop()

    return digits_to_string(result)


def string_to_digits(s: str) -> List[int]:
    """
    将字符串转换为数字列表（低位在前）
    
    Args:
        s: 数字字符串
    
    Returns:
        数字列表（低位在前）
    """
    return [int(s[len(s) - 1 - i]) for i in range(len(s))]


def digits_to_string(digits: List[int]) -> str:
    """
    将数字列表转换为字符串（低位在前转换为正常表示）
    
    Args:
        digits: 数字列表（低位在前）
    
    Returns:
        数字字符串
    """
    return ''.join(str(digits[i]) for i in range(len(digits) - 1, -1, -1))


def benchmark(size: int):
    """
    性能测试方法，比较FFT算法与其他算法
    
    Args:
        size: 测试数字的位数
    """
    # 生成测试用的大整数
    num1 = generate_random_number(size)
    num2 = generate_random_number(size)

    # 测试FFT算法
    start_time = time.time()
    result_fft = fft_multiply(num1, num2)
    fft_time = (time.time() - start_time) * 1000  # 转换为毫秒

    try:
        # 测试numpy FFT实现（更快的版本）
        start_time = time.time()
        result_numpy = numpy_fft_multiply(num1, num2)
        numpy_time = (time.time() - start_time) * 1000  # 转换为毫秒
        print(f"numpy FFT算法耗时: {numpy_time:.2f} ms")
    except:
        result_numpy = result_fft
        numpy_time = float('inf')

    # 测试传统算法（对于较小的数字）
    result_naive = ""
    naive_time = 0
    if size <= 500:  # 对于大数字，传统算法可能太慢
        start_time = time.time()
        result_naive = naive_multiply(num1, num2)
        naive_time = (time.time() - start_time) * 1000  # 转换为毫秒
        print(f"传统算法耗时: {naive_time:.2f} ms")
        if size <= 500:
            print(f"算法加速比 (传统/FFT): {naive_time / fft_time:.2f}x")
            print(f"结果一致 (FFT vs 传统): {result_fft == result_naive}")

    print(f"数字位数: {size}")
    print(f"FFT算法耗时: {fft_time:.2f} ms")
    if numpy_time < float('inf'):
        print(f"算法加速比 (手动FFT/numpy FFT): {fft_time / numpy_time:.2f}x")
        print(f"结果一致 (手动FFT vs numpy FFT): {result_fft == result_numpy}")
    print(f"乘积位数: {len(result_fft)}")


def generate_random_number(length: int) -> str:
    """
    生成指定长度的随机数字字符串
    
    Args:
        length: 字符串长度
    
    Returns:
        随机数字字符串
    """
    # 第一位不能是0
    first_digit = str(random.randint(1, 9))
    # 生成剩余位
    other_digits = ''.join(str(random.randint(0, 9)) for _ in range(length - 1))
    return first_digit + other_digits


def numpy_fft_multiply(x: str, y: str) -> str:
    """
    使用numpy的FFT实现进行大整数乘法
    这是一个更快的版本，仅在numpy可用时使用
    
    Args:
        x: 第一个整数的字符串表示
        y: 第二个整数的字符串表示
    
    Returns:
        乘积的字符串表示
    """
    # 将字符串转换为数字列表（低位在前）
    x_digits = np.array(string_to_digits(x), dtype=np.float64)
    y_digits = np.array(string_to_digits(y), dtype=np.float64)
    
    n = 1
    m = len(x_digits) + len(y_digits) - 1
    while n < m:
        n <<= 1
    
    # 补零到2的幂次长度
    x_padded = np.zeros(n, dtype=np.complex128)
    y_padded = np.zeros(n, dtype=np.complex128)
    x_padded[:len(x_digits)] = x_digits
    y_padded[:len(y_digits)] = y_digits
    
    # FFT
    x_fft = np.fft.fft(x_padded)
    y_fft = np.fft.fft(y_padded)
    
    # 点乘
    z_fft = x_fft * y_fft
    
    # 逆FFT
    z = np.fft.ifft(z_fft)
    
    # 取实部并四舍五入
    result = np.round(np.real(z[:m])).astype(int)
    
    # 处理进位
    result_list = result.tolist()
    process_carries(result_list)
    
    return digits_to_string(result_list)


def verify_correctness():
    """
    验证算法正确性
    """
    test_cases = [
        ("1234", "5678"),
        ("9999", "9999"),
        ("0", "12345"),
        ("1", "98765"),
        ("999999", "999999")
    ]

    for x, y in test_cases:
        # 使用FFT算法
        result = fft_multiply(x, y)
        
        # 对于小数字，使用Python内置的大整数类验证
        if len(x) <= 18 and len(y) <= 18:  # 确保可以放入Python的int
            num1 = int(x)
            num2 = int(y)
            expected = str(num1 * num2)
            print(f"{x} * {y} = {result} (正确: {result == expected})")
        else:
            print(f"{x} * {y} = {result}")
            print(f"乘积位数: {len(result)}")


def interactive_mode():
    """
    交互式测试函数
    """
    print("请输入两个大整数进行乘法计算（输入exit退出）:")
    while True:
        num1 = input("第一个数: ")
        if num1.lower() == "exit":
            break
        
        num2 = input("第二个数: ")
        if num2.lower() == "exit":
            break
        
        # 验证输入是否为有效数字
        if not num1.isdigit() or not num2.isdigit():
            print("错误: 请输入有效的正整数")
            continue
        
        try:
            start_time = time.time()
            result = fft_multiply(num1, num2)
            end_time = time.time()
            time_taken = (end_time - start_time) * 1000  # 转换为毫秒
            
            print(f"结果: {result}")
            print(f"计算耗时: {time_taken:.2f} ms")
        except Exception as e:
            print(f"计算过程中发生错误: {e}")


if __name__ == "__main__":
    print("验证算法正确性:")
    verify_correctness()
    
    print("\n性能测试:")
    benchmark(100)
    benchmark(1000)
    
    print("\n交互式测试:")
    try:
        interactive_mode()
    except KeyboardInterrupt:
        print("\n程序已中断")
    except Exception as e:
        print(f"发生错误: {e}")

===============================================

文件: FisherYatesShuffle.java
===============================================
package class175.随机化与复杂度分析;

import java.util.Random;

/**
 * Fisher-Yates 洗牌算法
 * 算法思想：从数组末尾开始，将当前位置与之前的随机位置交换，确保每个元素都有相同的概率出现在任意位置
 * 时间复杂度：O(n)
 * 空间复杂度：O(1) - 原地洗牌
 * 
 * 相关题目：
 * 1. LeetCode 384. 打乱数组 - https://leetcode-cn.com/problems/shuffle-an-array/
 * 2. LintCode 1423. 随机洗牌 - https://www.lintcode.com/problem/1423/
 * 3. CodeChef - SHUFFLE - https://www.codechef.com/problems/SHUFFLE
 */
public class FisherYatesShuffle {
    private final Random random;

    public FisherYatesShuffle() {
        this.random = new Random();
    }

    /**
     * Fisher-Yates 洗牌算法实现
     * @param array 需要洗牌的数组
     */
    public void shuffle(int[] array) {
        if (array == null || array.length <= 1) {
            return;
        }

        // 从后往前遍历数组
        for (int i = array.length - 1; i > 0; i--) {
            // 生成 [0, i] 范围内的随机索引
            int j = random.nextInt(i + 1);
            // 交换 array[i] 和 array[j]
            swap(array, i, j);
        }
    }

    /**
     * 交换数组中两个元素的位置
     * @param array 数组
     * @param i 第一个元素的索引
     * @param j 第二个元素的索引
     */
    private void swap(int[] array, int i, int j) {
        int temp = array[i];
        array[i] = array[j];
        array[j] = temp;
    }

    /**
     * 测试方法
     */
    public static void main(String[] args) {
        FisherYatesShuffle shuffle = new FisherYatesShuffle();
        int[] array = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
        
        System.out.println("原始数组：");
        printArray(array);
        
        shuffle.shuffle(array);
        
        System.out.println("洗牌后数组：");
        printArray(array);
    }

    /**
     * 打印数组
     */
    private static void printArray(int[] array) {
        for (int num : array) {
            System.out.print(num + " ");
        }
        System.out.println();
    }
}

===============================================

文件: fisher_yates_shuffle.cpp
===============================================
#include <iostream>
#include <vector>
#include <random>
#include <algorithm>

/**
 * Fisher-Yates 洗牌算法
 * 算法思想：从数组末尾开始，将当前位置与之前的随机位置交换，确保每个元素都有相同的概率出现在任意位置
 * 时间复杂度：O(n)
 * 空间复杂度：O(1) - 原地洗牌
 * 
 * 相关题目：
 * 1. LeetCode 384. 打乱数组 - https://leetcode-cn.com/problems/shuffle-an-array/
 * 2. LintCode 1423. 随机洗牌 - https://www.lintcode.com/problem/1423/
 * 3. CodeChef - SHUFFLE - https://www.codechef.com/problems/SHUFFLE
 */

class FisherYatesShuffle {
private:
    std::random_device rd;
    std::mt19937 g;

public:
    FisherYatesShuffle() : g(rd()) {}

    /**
     * Fisher-Yates 洗牌算法实现
     * @param array 需要洗牌的数组
     */
    void shuffle(std::vector<int>& array) {
        if (array.size() <= 1) {
            return;
        }

        // 从后往前遍历数组
        for (int i = array.size() - 1; i > 0; --i) {
            // 生成 [0, i] 范围内的随机索引
            std::uniform_int_distribution<int> dist(0, i);
            int j = dist(g);
            // 交换 array[i] 和 array[j]
            std::swap(array[i], array[j]);
        }
    }
};

// 打印数组
void printArray(const std::vector<int>& array) {
    for (int num : array) {
        std::cout << num << " ";
    }
    std::cout << std::endl;
}

// 测试函数
int main() {
    FisherYatesShuffle shuffler;
    std::vector<int> array = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    
    std::cout << "原始数组：" << std::endl;
    printArray(array);
    
    shuffler.shuffle(array);
    
    std::cout << "洗牌后数组：" << std::endl;
    printArray(array);
    
    return 0;
}

===============================================

文件: fisher_yates_shuffle.py
===============================================
import random

"""
Fisher-Yates 洗牌算法
算法思想：从数组末尾开始，将当前位置与之前的随机位置交换，确保每个元素都有相同的概率出现在任意位置
时间复杂度：O(n)
空间复杂度：O(1) - 原地洗牌

相关题目：
1. LeetCode 384. 打乱数组 - https://leetcode-cn.com/problems/shuffle-an-array/
2. LintCode 1423. 随机洗牌 - https://www.lintcode.com/problem/1423/
3. CodeChef - SHUFFLE - https://www.codechef.com/problems/SHUFFLE
"""

def fisher_yates_shuffle(arr):
    """
    Fisher-Yates 洗牌算法实现
    
    Args:
        arr: 需要洗牌的列表
    """
    if not arr or len(arr) <= 1:
        return
    
    # 从后往前遍历列表
    for i in range(len(arr) - 1, 0, -1):
        # 生成 [0, i] 范围内的随机索引
        j = random.randint(0, i)
        # 交换 arr[i] 和 arr[j]
        arr[i], arr[j] = arr[j], arr[i]

# 测试函数
def test_shuffle():
    arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
    print("原始数组：")
    print(arr)
    
    fisher_yates_shuffle(arr)
    
    print("洗牌后数组：")
    print(arr)

if __name__ == "__main__":
    test_shuffle()

===============================================

文件: forest.cpp
===============================================
// C++实现森林（Forest）数据结构
// 森林是由多棵不相交的树组成的数据结构

/**
 * 常见应用场景：
 * 1. 多棵独立树的集合管理
 * 2. 并查集（Union-Find）的基础
 * 3. 数据库中的多树索引
 * 4. 社交网络中的多个独立社区
 * 5. 并行计算中的任务调度树
 *
 * 相关算法题目：
 * - LeetCode 684. 冗余连接 https://leetcode.cn/problems/redundant-connection/
 * - LeetCode 685. 冗余连接 II https://leetcode.cn/problems/redundant-connection-ii/
 * - LeetCode 1258. 近义词句子 https://leetcode.cn/problems/synonymous-sentences/
 * - LeetCode 959. 由斜杠划分区域 https://leetcode.cn/problems/regions-cut-by-slashes/
 * - LintCode 1179. 连通分量 https://www.lintcode.com/problem/1179/
 * - 洛谷 P3367 【模板】并查集 https://www.luogu.com.cn/problem/P3367
 * - 牛客 NC233 合并二叉树 https://www.nowcoder.com/practice/a5e8156e81224147bd749c560909299a
 * - HackerRank Tree: Level Order Traversal https://www.hackerrank.com/challenges/tree-level-order-traversal/problem
 * - CodeChef FORESTGA https://www.codechef.com/problems/FORESTGA
 * - USACO Forest Fires https://usaco.org/index.php?page=viewproblem2&cpid=668
 */

#include <iostream>
#include <vector>
#include <queue>
#include <unordered_map>
#include <unordered_set>
#include <memory>
#include <string>
#include <algorithm>

// 树节点类
class TreeNode {
public:
    int val;
    std::vector<std::shared_ptr<TreeNode>> children;

    /**
     * 构造函数
     * @param val 节点值
     */
    explicit TreeNode(int val) : val(val) {}

    /**
     * 添加子节点
     * @param child 子节点
     */
    void addChild(const std::shared_ptr<TreeNode>& child) {
        children.push_back(child);
    }
};

// 森林类
class Forest {
private:
    std::vector<std::shared_ptr<TreeNode>> trees; // 森林中的所有树

    /**
     * 计算单棵树的节点数量（递归辅助函数）
     * @param root 树的根节点
     * @return 节点数量
     */
    int countNodes(const std::shared_ptr<TreeNode>& root) const {
        if (!root) {
            return 0;
        }
        int count = 1; // 当前节点
        for (const auto& child : root->children) {
            count += countNodes(child);
        }
        return count;
    }

    /**
     * 计算单棵树的高度（递归辅助函数）
     * @param root 树的根节点
     * @return 树的高度
     */
    int getTreeHeight(const std::shared_ptr<TreeNode>& root) const {
        if (!root) {
            return 0;
        }
        int maxChildHeight = 0;
        for (const auto& child : root->children) {
            maxChildHeight = std::max(maxChildHeight, getTreeHeight(child));
        }
        return maxChildHeight + 1;
    }

    /**
     * 在单棵树中查找节点（递归辅助函数）
     * @param root 树的根节点
     * @param target 目标值
     * @return 找到的节点，如果不存在返回nullptr
     */
    std::shared_ptr<TreeNode> findNodeInTree(const std::shared_ptr<TreeNode>& root, int target) const {
        if (!root) {
            return nullptr;
        }
        if (root->val == target) {
            return root;
        }
        for (const auto& child : root->children) {
            auto found = findNodeInTree(child, target);
            if (found) {
                return found;
            }
        }
        return nullptr;
    }

    /**
     * 单棵树的层序遍历（辅助函数）
     * @param root 树的根节点
     * @return 层序遍历的结果列表
     */
    std::vector<std::vector<int>> levelOrderTraversalTree(const std::shared_ptr<TreeNode>& root) const {
        std::vector<std::vector<int>> result;
        if (!root) {
            return result;
        }

        std::queue<std::shared_ptr<TreeNode>> queue;
        queue.push(root);

        while (!queue.empty()) {
            int levelSize = queue.size();
            std::vector<int> currentLevel;

            for (int i = 0; i < levelSize; ++i) {
                auto node = queue.front();
                queue.pop();
                currentLevel.push_back(node->val);
                for (const auto& child : node->children) {
                    queue.push(child);
                }
            }

            result.push_back(currentLevel);
        }

        return result;
    }

    /**
     * 打印单棵树的结构（辅助函数）
     * @param node 当前节点
     * @param level 当前节点的层级
     */
    void printTree(const std::shared_ptr<TreeNode>& node, int level) const {
        if (!node) {
            return;
        }
        // 打印缩进
        for (int i = 0; i < level; ++i) {
            std::cout << "  ";
        }
        std::cout << node->val << std::endl;
        // 递归打印子节点
        for (const auto& child : node->children) {
            printTree(child, level + 1);
        }
    }

    /**
     * 构建并查集（递归辅助函数）
     * @param node 当前节点
     * @param parent 父节点值
     * @param parentMap 父节点映射
     */
    void buildUnionFind(const std::shared_ptr<TreeNode>& node, int parent, 
                       std::unordered_map<int, int>& parentMap) const {
        if (!node) {
            return;
        }
        parentMap[node->val] = parent;
        for (const auto& child : node->children) {
            buildUnionFind(child, node->val, parentMap);
        }
    }

    /**
     * 收集树中的所有节点（辅助函数）
     * @param node 当前节点
     * @param component 节点集合
     */
    void collectNodes(const std::shared_ptr<TreeNode>& node, 
                     std::unordered_set<int>& component) const {
        if (!node) {
            return;
        }
        component.insert(node->val);
        for (const auto& child : node->children) {
            collectNodes(child, component);
        }
    }

    /**
     * 查找节点所在树的根节点值
     * @param nodeVal 节点值
     * @return 根节点值，如果节点不存在返回-2
     */
    int findRoot(int nodeVal) const {
        auto unionFind = toUnionFind();
        
        if (unionFind.find(nodeVal) == unionFind.end()) {
            return -2; // 节点不存在
        }
        
        // 查找根节点
        int current = nodeVal;
        while (unionFind[current] != -1) {
            current = unionFind[current];
        }
        
        return current;
    }

    /**
     * 深拷贝一棵树
     * @param root 树的根节点
     * @return 拷贝后的树的根节点
     */
    std::shared_ptr<TreeNode> cloneTree(const std::shared_ptr<TreeNode>& root) const {
        if (!root) {
            return nullptr;
        }
        auto newRoot = std::make_shared<TreeNode>(root->val);
        for (const auto& child : root->children) {
            newRoot->addChild(cloneTree(child));
        }
        return newRoot;
    }

    /**
     * 释放树的内存（非智能指针版本需要）
     * @param root 树的根节点
     */
    void freeTree(TreeNode* root) {
        if (!root) {
            return;
        }
        for (auto& child : root->children) {
            freeTree(child.get());
        }
        // 智能指针自动管理内存，不需要手动delete
    }

public:
    /**
     * 构造函数
     */
    Forest() = default;

    /**
     * 析构函数
     */
    ~Forest() = default;

    /**
     * 添加一棵树到森林
     * @param root 树的根节点
     */
    void addTree(const std::shared_ptr<TreeNode>& root) {
        if (root) {
            trees.push_back(root);
        }
    }

    /**
     * 计算森林中树的数量
     * @return 树的数量
     */
    int getTreeCount() const {
        return trees.size();
    }

    /**
     * 获取森林中的所有树
     * @return 树的列表
     */
    std::vector<std::shared_ptr<TreeNode>> getTrees() const {
        return trees;
    }

    /**
     * 计算森林中节点的总数
     * @return 节点总数
     */
    int getTotalNodeCount() const {
        int count = 0;
        for (const auto& root : trees) {
            count += countNodes(root);
        }
        return count;
    }

    /**
     * 计算森林中所有树的高度之和
     * @return 高度之和
     */
    int getTotalHeight() const {
        int totalHeight = 0;
        for (const auto& root : trees) {
            totalHeight += getTreeHeight(root);
        }
        return totalHeight;
    }

    /**
     * 在森林中查找值为target的节点
     * @param target 目标值
     * @return 找到的节点，如果不存在返回nullptr
     */
    std::shared_ptr<TreeNode> findNode(int target) const {
        for (const auto& root : trees) {
            auto found = findNodeInTree(root, target);
            if (found) {
                return found;
            }
        }
        return nullptr;
    }

    /**
     * 合并两棵树（将tree2合并到tree1）
     * @param tree1 第一棵树的根节点
     * @param tree2 第二棵树的根节点
     * @return 合并后的树的根节点
     */
    std::shared_ptr<TreeNode> mergeTrees(const std::shared_ptr<TreeNode>& tree1, 
                                       const std::shared_ptr<TreeNode>& tree2) {
        if (!tree1) {
            return tree2;
        }
        if (!tree2) {
            return tree1;
        }

        // 将tree2作为tree1的一个子节点
        tree1->addChild(tree2);
        
        // 从森林中移除tree2
        auto it = std::find(trees.begin(), trees.end(), tree2);
        if (it != trees.end()) {
            trees.erase(it);
        }
        
        return tree1;
    }

    /**
     * 将树从森林中移除
     * @param root 要移除的树的根节点
     * @return 如果移除成功返回true，否则返回false
     */
    bool removeTree(const std::shared_ptr<TreeNode>& root) {
        auto it = std::find(trees.begin(), trees.end(), root);
        if (it != trees.end()) {
            trees.erase(it);
            return true;
        }
        return false;
    }

    /**
     * 森林的层序遍历
     * @return 层序遍历的结果列表
     */
    std::vector<std::vector<int>> levelOrderTraversal() const {
        std::vector<std::vector<int>> result;
        for (const auto& root : trees) {
            auto treeLevelOrder = levelOrderTraversalTree(root);
            result.insert(result.end(), treeLevelOrder.begin(), treeLevelOrder.end());
        }
        return result;
    }

    /**
     * 打印森林的结构
     */
    void printForest() const {
        std::cout << "森林包含 " << trees.size() << " 棵树：" << std::endl;
        for (int i = 0; i < trees.size(); ++i) {
            std::cout << "\n树 " << (i + 1) << ":" << std::endl;
            printTree(trees[i], 0);
        }
    }

    /**
     * 将森林转换为并查集（基于父指针）
     * @return 并查集映射，其中key是节点值，value是父节点值
     */
    std::unordered_map<int, int> toUnionFind() const {
        std::unordered_map<int, int> parentMap;
        for (const auto& root : trees) {
            buildUnionFind(root, -1, parentMap);
        }
        return parentMap;
    }

    /**
     * 从并查集构建森林
     * @param parentMap 并查集父节点映射
     * @return 构建的森林
     */
    static Forest fromUnionFind(const std::unordered_map<int, int>& parentMap) {
        Forest forest;
        std::unordered_map<int, std::shared_ptr<TreeNode>> nodeMap;
        std::vector<int> roots;

        // 创建所有节点并找出根节点
        for (const auto& [nodeVal, parentVal] : parentMap) {
            // 创建节点（如果不存在）
            if (nodeMap.find(nodeVal) == nodeMap.end()) {
                nodeMap[nodeVal] = std::make_shared<TreeNode>(nodeVal);
            }
            
            // 如果是根节点（父节点为-1）
            if (parentVal == -1) {
                roots.push_back(nodeVal);
            } else {
                // 创建父节点（如果不存在）
                if (nodeMap.find(parentVal) == nodeMap.end()) {
                    nodeMap[parentVal] = std::make_shared<TreeNode>(parentVal);
                }
                // 建立父子关系
                nodeMap[parentVal]->addChild(nodeMap[nodeVal]);
            }
        }

        // 将所有根节点添加到森林
        for (int rootVal : roots) {
            forest.addTree(nodeMap[rootVal]);
        }

        return forest;
    }

    /**
     * 获取森林中的连通分量（每棵树的节点集合）
     * @return 连通分量列表，每个集合包含一棵树的所有节点
     */
    std::vector<std::unordered_set<int>> getConnectedComponents() const {
        std::vector<std::unordered_set<int>> components;
        for (const auto& root : trees) {
            std::unordered_set<int> component;
            collectNodes(root, component);
            components.push_back(component);
        }
        return components;
    }

    /**
     * 判断两个节点是否在同一棵树中
     * @param node1Val 第一个节点的值
     * @param node2Val 第二个节点的值
     * @return 如果在同一棵树中返回true，否则返回false
     */
    bool isConnected(int node1Val, int node2Val) const {
        // 先找到两个节点
        auto node1 = findNode(node1Val);
        auto node2 = findNode(node2Val);
        
        if (!node1 || !node2) {
            return false;
        }
        
        // 找到两个节点所在的树的根节点
        int root1 = findRoot(node1Val);
        int root2 = findRoot(node2Val);
        
        return root1 == root2 && root1 != -2; // -2表示节点不存在
    }

    /**
     * 深拷贝森林
     * @return 拷贝后的森林
     */
    Forest clone() const {
        Forest newForest;
        for (const auto& root : trees) {
            newForest.addTree(cloneTree(root));
        }
        return newForest;
    }
};

// 主函数，用于测试
int main() {
    // 创建森林示例
    Forest forest;

    // 创建第一棵树
    //      1
    //     / \
    //    2   3
    //   /
    //  4
    auto tree1 = std::make_shared<TreeNode>(1);
    auto node2 = std::make_shared<TreeNode>(2);
    auto node3 = std::make_shared<TreeNode>(3);
    auto node4 = std::make_shared<TreeNode>(4);
    tree1->addChild(node2);
    tree1->addChild(node3);
    node2->addChild(node4);

    // 创建第二棵树
    //      5
    //     / \
    //    6   7
    auto tree2 = std::make_shared<TreeNode>(5);
    auto node6 = std::make_shared<TreeNode>(6);
    auto node7 = std::make_shared<TreeNode>(7);
    tree2->addChild(node6);
    tree2->addChild(node7);

    // 创建第三棵树
    //      8
    auto tree3 = std::make_shared<TreeNode>(8);

    // 添加树到森林
    forest.addTree(tree1);
    forest.addTree(tree2);
    forest.addTree(tree3);

    // 打印森林
    std::cout << "初始森林：" << std::endl;
    forest.printForest();

    // 测试树的数量
    std::cout << "\n森林中树的数量: " << forest.getTreeCount() << std::endl;

    // 测试节点总数
    std::cout << "森林中节点总数: " << forest.getTotalNodeCount() << std::endl;

    // 测试总高度
    std::cout << "森林中所有树的高度之和: " << forest.getTotalHeight() << std::endl;

    // 测试查找节点
    auto found = forest.findNode(6);
    std::cout << "查找节点6: " << (found ? "找到" : "未找到") << std::endl;

    // 测试合并树
    std::cout << "\n合并第一棵树和第二棵树后：" << std::endl;
    forest.mergeTrees(tree1, tree2);
    forest.printForest();

    // 测试移除树
    std::cout << "\n移除第三棵树后：" << std::endl;
    forest.removeTree(tree3);
    forest.printForest();

    // 测试层序遍历
    std::cout << "\n森林的层序遍历：" << std::endl;
    auto levelOrder = forest.levelOrderTraversal();
    for (const auto& level : levelOrder) {
        std::cout << "[";
        for (size_t i = 0; i < level.size(); ++i) {
            std::cout << level[i];
            if (i < level.size() - 1) {
                std::cout << ", ";
            }
        }
        std::cout << "]" << std::endl;
    }

    // 测试并查集转换
    std::cout << "\n转换为并查集：" << std::endl;
    auto unionFind = forest.toUnionFind();
    for (const auto& [nodeVal, parentVal] : unionFind) {
        std::cout << "节点 " << nodeVal << " 的父节点: " << parentVal << std::endl;
    }

    // 测试从并查集构建森林
    std::cout << "\n从并查集构建森林：" << std::endl;
    auto rebuiltForest = Forest::fromUnionFind(unionFind);
    rebuiltForest.printForest();

    // 测试连通分量
    std::cout << "\n连通分量：" << std::endl;
    auto components = forest.getConnectedComponents();
    for (size_t i = 0; i < components.size(); ++i) {
        std::cout << "连通分量 " << (i + 1) << ": ";
        bool first = true;
        for (int val : components[i]) {
            if (!first) {
                std::cout << ", ";
            }
            std::cout << val;
            first = false;
        }
        std::cout << std::endl;
    }

    // 测试判断连通性
    std::cout << "\n节点1和节点6是否连通: " << (forest.isConnected(1, 6) ? "是" : "否") << std::endl;
    std::cout << "节点4和节点7是否连通: " << (forest.isConnected(4, 7) ? "是" : "否") << std::endl;

    return 0;
}

===============================================

文件: Forest.java
===============================================
package class175.森林;

import java.util.*;

/**
 * 森林（Forest）实现类
 * 森林是由多棵不相交的树组成的数据结构
 * 
 * 常见应用场景：
 * 1. 多棵独立树的集合管理
 * 2. 并查集（Union-Find）的基础
 * 3. 数据库中的多树索引
 * 4. 社交网络中的多个独立社区
 * 5. 并行计算中的任务调度树
 * 
 * 相关算法题目：
 * - LeetCode 684. 冗余连接 https://leetcode.cn/problems/redundant-connection/
 * - LeetCode 685. 冗余连接 II https://leetcode.cn/problems/redundant-connection-ii/
 * - LeetCode 1258. 近义词句子 https://leetcode.cn/problems/synonymous-sentences/
 * - LeetCode 959. 由斜杠划分区域 https://leetcode.cn/problems/regions-cut-by-slashes/
 * - LintCode 1179. 连通分量 https://www.lintcode.com/problem/1179/
 * - 洛谷 P3367 【模板】并查集 https://www.luogu.com.cn/problem/P3367
 * - 牛客 NC233 合并二叉树 https://www.nowcoder.com/practice/a5e8156e81224147bd749c560909299a
 */

class TreeNode {
    public int val;
    public List<TreeNode> children;

    /**
     * 构造函数
     * @param val 节点值
     */
    public TreeNode(int val) {
        this.val = val;
        this.children = new ArrayList<>();
    }

    /**
     * 添加子节点
     * @param child 子节点
     */
    public void addChild(TreeNode child) {
        this.children.add(child);
    }
}

public class Forest {
    private List<TreeNode> trees; // 森林中的所有树

    /**
     * 构造函数
     */
    public Forest() {
        this.trees = new ArrayList<>();
    }

    /**
     * 添加一棵树到森林
     * @param root 树的根节点
     */
    public void addTree(TreeNode root) {
        if (root != null) {
            trees.add(root);
        }
    }

    /**
     * 计算森林中树的数量
     * @return 树的数量
     */
    public int getTreeCount() {
        return trees.size();
    }

    /**
     * 获取森林中的所有树
     * @return 树的列表
     */
    public List<TreeNode> getTrees() {
        return new ArrayList<>(trees);
    }

    /**
     * 计算森林中节点的总数
     * @return 节点总数
     */
    public int getTotalNodeCount() {
        int count = 0;
        for (TreeNode root : trees) {
            count += countNodes(root);
        }
        return count;
    }

    /**
     * 计算单棵树的节点数量（递归辅助函数）
     * @param root 树的根节点
     * @return 节点数量
     */
    private int countNodes(TreeNode root) {
        if (root == null) {
            return 0;
        }
        int count = 1; // 当前节点
        for (TreeNode child : root.children) {
            count += countNodes(child);
        }
        return count;
    }

    /**
     * 计算森林中所有树的高度之和
     * @return 高度之和
     */
    public int getTotalHeight() {
        int totalHeight = 0;
        for (TreeNode root : trees) {
            totalHeight += getTreeHeight(root);
        }
        return totalHeight;
    }

    /**
     * 计算单棵树的高度（递归辅助函数）
     * @param root 树的根节点
     * @return 树的高度
     */
    private int getTreeHeight(TreeNode root) {
        if (root == null) {
            return 0;
        }
        int maxChildHeight = 0;
        for (TreeNode child : root.children) {
            maxChildHeight = Math.max(maxChildHeight, getTreeHeight(child));
        }
        return maxChildHeight + 1;
    }

    /**
     * 在森林中查找值为target的节点
     * @param target 目标值
     * @return 找到的节点，如果不存在返回null
     */
    public TreeNode findNode(int target) {
        for (TreeNode root : trees) {
            TreeNode found = findNodeInTree(root, target);
            if (found != null) {
                return found;
            }
        }
        return null;
    }

    /**
     * 在单棵树中查找节点（递归辅助函数）
     * @param root 树的根节点
     * @param target 目标值
     * @return 找到的节点，如果不存在返回null
     */
    private TreeNode findNodeInTree(TreeNode root, int target) {
        if (root == null) {
            return null;
        }
        if (root.val == target) {
            return root;
        }
        for (TreeNode child : root.children) {
            TreeNode found = findNodeInTree(child, target);
            if (found != null) {
                return found;
            }
        }
        return null;
    }

    /**
     * 合并两棵树（将tree2合并到tree1）
     * @param tree1 第一棵树的根节点
     * @param tree2 第二棵树的根节点
     * @return 合并后的树的根节点
     */
    public TreeNode mergeTrees(TreeNode tree1, TreeNode tree2) {
        if (tree1 == null) {
            return tree2;
        }
        if (tree2 == null) {
            return tree1;
        }

        // 将tree2作为tree1的一个子节点
        tree1.addChild(tree2);
        
        // 从森林中移除tree2
        trees.remove(tree2);
        
        return tree1;
    }

    /**
     * 将树从森林中移除
     * @param root 要移除的树的根节点
     * @return 如果移除成功返回true，否则返回false
     */
    public boolean removeTree(TreeNode root) {
        return trees.remove(root);
    }

    /**
     * 森林的层序遍历
     * @return 层序遍历的结果列表
     */
    public List<List<Integer>> levelOrderTraversal() {
        List<List<Integer>> result = new ArrayList<>();
        for (TreeNode root : trees) {
            List<List<Integer>> treeLevelOrder = levelOrderTraversalTree(root);
            result.addAll(treeLevelOrder);
        }
        return result;
    }

    /**
     * 单棵树的层序遍历（辅助函数）
     * @param root 树的根节点
     * @return 层序遍历的结果列表
     */
    private List<List<Integer>> levelOrderTraversalTree(TreeNode root) {
        List<List<Integer>> result = new ArrayList<>();
        if (root == null) {
            return result;
        }

        Queue<TreeNode> queue = new LinkedList<>();
        queue.offer(root);

        while (!queue.isEmpty()) {
            int levelSize = queue.size();
            List<Integer> currentLevel = new ArrayList<>();

            for (int i = 0; i < levelSize; i++) {
                TreeNode node = queue.poll();
                currentLevel.add(node.val);
                for (TreeNode child : node.children) {
                    queue.offer(child);
                }
            }

            result.add(currentLevel);
        }

        return result;
    }

    /**
     * 打印森林的结构
     */
    public void printForest() {
        System.out.println("森林包含 " + trees.size() + " 棵树：");
        for (int i = 0; i < trees.size(); i++) {
            System.out.println("\n树 " + (i + 1) + ":");
            printTree(trees.get(i), 0);
        }
    }

    /**
     * 打印单棵树的结构（辅助函数）
     * @param node 当前节点
     * @param level 当前节点的层级
     */
    private void printTree(TreeNode node, int level) {
        if (node == null) {
            return;
        }
        // 打印缩进
        for (int i = 0; i < level; i++) {
            System.out.print("  ");
        }
        System.out.println(node.val);
        // 递归打印子节点
        for (TreeNode child : node.children) {
            printTree(child, level + 1);
        }
    }

    /**
     * 将森林转换为并查集（基于父指针）
     * @return 并查集数组，其中parent[i]表示节点i的父节点
     */
    public Map<Integer, Integer> toUnionFind() {
        Map<Integer, Integer> parentMap = new HashMap<>();
        for (TreeNode root : trees) {
            buildUnionFind(root, -1, parentMap);
        }
        return parentMap;
    }

    /**
     * 构建并查集（递归辅助函数）
     * @param node 当前节点
     * @param parent 父节点值
     * @param parentMap 父节点映射
     */
    private void buildUnionFind(TreeNode node, int parent, Map<Integer, Integer> parentMap) {
        if (node == null) {
            return;
        }
        parentMap.put(node.val, parent);
        for (TreeNode child : node.children) {
            buildUnionFind(child, node.val, parentMap);
        }
    }

    /**
     * 从并查集构建森林
     * @param parentMap 并查集父节点映射
     * @return 构建的森林
     */
    public static Forest fromUnionFind(Map<Integer, Integer> parentMap) {
        Forest forest = new Forest();
        Map<Integer, TreeNode> nodeMap = new HashMap<>();
        List<Integer> roots = new ArrayList<>();

        // 创建所有节点并找出根节点
        for (Map.Entry<Integer, Integer> entry : parentMap.entrySet()) {
            int nodeVal = entry.getKey();
            int parentVal = entry.getValue();
            
            // 创建节点（如果不存在）
            nodeMap.putIfAbsent(nodeVal, new TreeNode(nodeVal));
            
            // 如果是根节点（父节点为-1）
            if (parentVal == -1) {
                roots.add(nodeVal);
            } else {
                // 创建父节点（如果不存在）
                nodeMap.putIfAbsent(parentVal, new TreeNode(parentVal));
                // 建立父子关系
                nodeMap.get(parentVal).addChild(nodeMap.get(nodeVal));
            }
        }

        // 将所有根节点添加到森林
        for (int rootVal : roots) {
            forest.addTree(nodeMap.get(rootVal));
        }

        return forest;
    }

    /**
     * 主方法，用于测试
     */
    public static void main(String[] args) {
        // 创建森林示例
        Forest forest = new Forest();

        // 创建第一棵树
        //      1
        //     / \
        //    2   3
        //   /
        //  4
        TreeNode tree1 = new TreeNode(1);
        TreeNode node2 = new TreeNode(2);
        TreeNode node3 = new TreeNode(3);
        TreeNode node4 = new TreeNode(4);
        tree1.addChild(node2);
        tree1.addChild(node3);
        node2.addChild(node4);

        // 创建第二棵树
        //      5
        //     / \
        //    6   7
        TreeNode tree2 = new TreeNode(5);
        TreeNode node6 = new TreeNode(6);
        TreeNode node7 = new TreeNode(7);
        tree2.addChild(node6);
        tree2.addChild(node7);

        // 创建第三棵树
        //      8
        TreeNode tree3 = new TreeNode(8);

        // 添加树到森林
        forest.addTree(tree1);
        forest.addTree(tree2);
        forest.addTree(tree3);

        // 打印森林
        System.out.println("初始森林：");
        forest.printForest();

        // 测试树的数量
        System.out.println("\n森林中树的数量: " + forest.getTreeCount());

        // 测试节点总数
        System.out.println("森林中节点总数: " + forest.getTotalNodeCount());

        // 测试总高度
        System.out.println("森林中所有树的高度之和: " + forest.getTotalHeight());

        // 测试查找节点
        TreeNode found = forest.findNode(6);
        System.out.println("查找节点6: " + (found != null ? "找到" : "未找到"));

        // 测试合并树
        System.out.println("\n合并第一棵树和第二棵树后：");
        forest.mergeTrees(tree1, tree2);
        forest.printForest();

        // 测试移除树
        System.out.println("\n移除第三棵树后：");
        forest.removeTree(tree3);
        forest.printForest();

        // 测试层序遍历
        System.out.println("\n森林的层序遍历：");
        List<List<Integer>> levelOrder = forest.levelOrderTraversal();
        for (List<Integer> level : levelOrder) {
            System.out.println(level);
        }

        // 测试并查集转换
        System.out.println("\n转换为并查集：");
        Map<Integer, Integer> unionFind = forest.toUnionFind();
        for (Map.Entry<Integer, Integer> entry : unionFind.entrySet()) {
            System.out.println("节点 " + entry.getKey() + " 的父节点: " + entry.getValue());
        }

        // 测试从并查集构建森林
        System.out.println("\n从并查集构建森林：");
        Forest rebuiltForest = Forest.fromUnionFind(unionFind);
        rebuiltForest.printForest();
    }
}

===============================================

文件: forest.py
===============================================
#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
森林（Forest）实现
森林是由多棵不相交的树组成的数据结构

常见应用场景：
1. 多棵独立树的集合管理
2. 并查集（Union-Find）的基础
3. 数据库中的多树索引
4. 社交网络中的多个独立社区
5. 并行计算中的任务调度树

相关算法题目：
- LeetCode 684. 冗余连接 https://leetcode.cn/problems/redundant-connection/
- LeetCode 685. 冗余连接 II https://leetcode.cn/problems/redundant-connection-ii/
- LeetCode 1258. 近义词句子 https://leetcode.cn/problems/synonymous-sentences/
- LeetCode 959. 由斜杠划分区域 https://leetcode.cn/problems/regions-cut-by-slashes/
- LintCode 1179. 连通分量 https://www.lintcode.com/problem/1179/
- 洛谷 P3367 【模板】并查集 https://www.luogu.com.cn/problem/P3367
- 牛客 NC233 合并二叉树 https://www.nowcoder.com/practice/a5e8156e81224147bd749c560909299a
- HackerRank Tree: Level Order Traversal https://www.hackerrank.com/challenges/tree-level-order-traversal/problem
- CodeChef FORESTGA https://www.codechef.com/problems/FORESTGA
- USACO Forest Fires https://usaco.org/index.php?page=viewproblem2&cpid=668
"""

from typing import List, Optional, Dict, Set
from collections import deque


class TreeNode:
    """树节点类"""
    
    def __init__(self, val: int):
        """初始化节点
        
        Args:
            val: 节点值
        """
        self.val = val
        self.children = []
    
    def add_child(self, child_node: 'TreeNode') -> None:
        """添加子节点
        
        Args:
            child_node: 子节点
        """
        self.children.append(child_node)


class Forest:
    """森林实现类"""
    
    def __init__(self):
        """初始化森林"""
        self.trees = []  # 森林中的所有树
    
    def add_tree(self, root: Optional[TreeNode]) -> None:
        """添加一棵树到森林
        
        Args:
            root: 树的根节点
        """
        if root is not None:
            self.trees.append(root)
    
    def get_tree_count(self) -> int:
        """计算森林中树的数量
        
        Returns:
            树的数量
        """
        return len(self.trees)
    
    def get_trees(self) -> List[TreeNode]:
        """获取森林中的所有树
        
        Returns:
            树的列表
        """
        return self.trees.copy()
    
    def get_total_node_count(self) -> int:
        """计算森林中节点的总数
        
        Returns:
            节点总数
        """
        count = 0
        for root in self.trees:
            count += self._count_nodes(root)
        return count
    
    def _count_nodes(self, root: Optional[TreeNode]) -> int:
        """计算单棵树的节点数量（递归辅助函数）
        
        Args:
            root: 树的根节点
        
        Returns:
            节点数量
        """
        if root is None:
            return 0
        count = 1  # 当前节点
        for child in root.children:
            count += self._count_nodes(child)
        return count
    
    def get_total_height(self) -> int:
        """计算森林中所有树的高度之和
        
        Returns:
            高度之和
        """
        total_height = 0
        for root in self.trees:
            total_height += self._get_tree_height(root)
        return total_height
    
    def _get_tree_height(self, root: Optional[TreeNode]) -> int:
        """计算单棵树的高度（递归辅助函数）
        
        Args:
            root: 树的根节点
        
        Returns:
            树的高度
        """
        if root is None:
            return 0
        max_child_height = 0
        for child in root.children:
            max_child_height = max(max_child_height, self._get_tree_height(child))
        return max_child_height + 1
    
    def find_node(self, target: int) -> Optional[TreeNode]:
        """在森林中查找值为target的节点
        
        Args:
            target: 目标值
        
        Returns:
            找到的节点，如果不存在返回None
        """
        for root in self.trees:
            found = self._find_node_in_tree(root, target)
            if found is not None:
                return found
        return None
    
    def _find_node_in_tree(self, root: Optional[TreeNode], target: int) -> Optional[TreeNode]:
        """在单棵树中查找节点（递归辅助函数）
        
        Args:
            root: 树的根节点
            target: 目标值
        
        Returns:
            找到的节点，如果不存在返回None
        """
        if root is None:
            return None
        if root.val == target:
            return root
        for child in root.children:
            found = self._find_node_in_tree(child, target)
            if found is not None:
                return found
        return None
    
    def merge_trees(self, tree1: Optional[TreeNode], tree2: Optional[TreeNode]) -> Optional[TreeNode]:
        """合并两棵树（将tree2合并到tree1）
        
        Args:
            tree1: 第一棵树的根节点
            tree2: 第二棵树的根节点
        
        Returns:
            合并后的树的根节点
        """
        if tree1 is None:
            return tree2
        if tree2 is None:
            return tree1
        
        # 将tree2作为tree1的一个子节点
        tree1.add_child(tree2)
        
        # 从森林中移除tree2
        if tree2 in self.trees:
            self.trees.remove(tree2)
        
        return tree1
    
    def remove_tree(self, root: Optional[TreeNode]) -> bool:
        """将树从森林中移除
        
        Args:
            root: 要移除的树的根节点
        
        Returns:
            如果移除成功返回True，否则返回False
        """
        if root in self.trees:
            self.trees.remove(root)
            return True
        return False
    
    def level_order_traversal(self) -> List[List[int]]:
        """森林的层序遍历
        
        Returns:
            层序遍历的结果列表
        """
        result = []
        for root in self.trees:
            tree_level_order = self._level_order_traversal_tree(root)
            result.extend(tree_level_order)
        return result
    
    def _level_order_traversal_tree(self, root: Optional[TreeNode]) -> List[List[int]]:
        """单棵树的层序遍历（辅助函数）
        
        Args:
            root: 树的根节点
        
        Returns:
            层序遍历的结果列表
        """
        result = []
        if root is None:
            return result
        
        queue = deque([root])
        
        while queue:
            level_size = len(queue)
            current_level = []
            
            for _ in range(level_size):
                node = queue.popleft()
                current_level.append(node.val)
                for child in node.children:
                    queue.append(child)
            
            result.append(current_level)
        
        return result
    
    def print_forest(self) -> None:
        """打印森林的结构"""
        print(f"森林包含 {len(self.trees)} 棵树：")
        for i in range(len(self.trees)):
            print(f"\n树 {i + 1}:")
            self._print_tree(self.trees[i], 0)
    
    def _print_tree(self, node: Optional[TreeNode], level: int) -> None:
        """打印单棵树的结构（辅助函数）
        
        Args:
            node: 当前节点
            level: 当前节点的层级
        """
        if node is None:
            return
        # 打印缩进
        print("  " * level + str(node.val))
        # 递归打印子节点
        for child in node.children:
            self._print_tree(child, level + 1)
    
    def to_union_find(self) -> Dict[int, int]:
        """将森林转换为并查集（基于父指针）
        
        Returns:
            并查集字典，其中key是节点值，value是父节点值
        """
        parent_map = {}
        for root in self.trees:
            self._build_union_find(root, -1, parent_map)
        return parent_map
    
    def _build_union_find(self, node: Optional[TreeNode], parent: int, parent_map: Dict[int, int]) -> None:
        """构建并查集（递归辅助函数）
        
        Args:
            node: 当前节点
            parent: 父节点值
            parent_map: 父节点映射
        """
        if node is None:
            return
        parent_map[node.val] = parent
        for child in node.children:
            self._build_union_find(child, node.val, parent_map)
    
    @staticmethod
    def from_union_find(parent_map: Dict[int, int]) -> 'Forest':
        """从并查集构建森林
        
        Args:
            parent_map: 并查集父节点映射
        
        Returns:
            构建的森林
        """
        forest = Forest()
        node_map = {}
        roots = []
        
        # 创建所有节点并找出根节点
        for node_val, parent_val in parent_map.items():
            # 创建节点（如果不存在）
            if node_val not in node_map:
                node_map[node_val] = TreeNode(node_val)
            
            # 如果是根节点（父节点为-1）
            if parent_val == -1:
                roots.append(node_val)
            else:
                # 创建父节点（如果不存在）
                if parent_val not in node_map:
                    node_map[parent_val] = TreeNode(parent_val)
                # 建立父子关系
                node_map[parent_val].add_child(node_map[node_val])
        
        # 将所有根节点添加到森林
        for root_val in roots:
            forest.add_tree(node_map[root_val])
        
        return forest
    
    def get_connected_components(self) -> List[Set[int]]:
        """获取森林中的连通分量（每棵树的节点集合）
        
        Returns:
            连通分量列表，每个集合包含一棵树的所有节点
        """
        components = []
        for root in self.trees:
            component = set()
            self._collect_nodes(root, component)
            components.append(component)
        return components
    
    def _collect_nodes(self, node: Optional[TreeNode], component: Set[int]) -> None:
        """收集树中的所有节点（辅助函数）
        
        Args:
            node: 当前节点
            component: 节点集合
        """
        if node is None:
            return
        component.add(node.val)
        for child in node.children:
            self._collect_nodes(child, component)
    
    def is_connected(self, node1_val: int, node2_val: int) -> bool:
        """判断两个节点是否在同一棵树中
        
        Args:
            node1_val: 第一个节点的值
            node2_val: 第二个节点的值
        
        Returns:
            如果在同一棵树中返回True，否则返回False
        """
        # 先找到两个节点
        node1 = self.find_node(node1_val)
        node2 = self.find_node(node2_val)
        
        if node1 is None or node2 is None:
            return False
        
        # 找到两个节点所在的树的根节点
        root1 = self._find_root(node1_val)
        root2 = self._find_root(node2_val)
        
        return root1 == root2
    
    def _find_root(self, node_val: int) -> Optional[int]:
        """查找节点所在树的根节点值
        
        Args:
            node_val: 节点值
        
        Returns:
            根节点值，如果节点不存在返回None
        """
        union_find = self.to_union_find()
        
        if node_val not in union_find:
            return None
        
        # 查找根节点
        current = node_val
        while union_find[current] != -1:
            current = union_find[current]
        
        return current


# 测试代码
if __name__ == "__main__":
    # 创建森林示例
    forest = Forest()
    
    # 创建第一棵树
    #      1
    #     / \
    #    2   3
    #   /
    #  4
    tree1 = TreeNode(1)
    node2 = TreeNode(2)
    node3 = TreeNode(3)
    node4 = TreeNode(4)
    tree1.add_child(node2)
    tree1.add_child(node3)
    node2.add_child(node4)
    
    # 创建第二棵树
    #      5
    #     / \
    #    6   7
    tree2 = TreeNode(5)
    node6 = TreeNode(6)
    node7 = TreeNode(7)
    tree2.add_child(node6)
    tree2.add_child(node7)
    
    # 创建第三棵树
    #      8
    tree3 = TreeNode(8)
    
    # 添加树到森林
    forest.add_tree(tree1)
    forest.add_tree(tree2)
    forest.add_tree(tree3)
    
    # 打印森林
    print("初始森林：")
    forest.print_forest()
    
    # 测试树的数量
    print(f"\n森林中树的数量: {forest.get_tree_count()}")
    
    # 测试节点总数
    print(f"森林中节点总数: {forest.get_total_node_count()}")
    
    # 测试总高度
    print(f"森林中所有树的高度之和: {forest.get_total_height()}")
    
    # 测试查找节点
    found = forest.find_node(6)
    print(f"查找节点6: {'找到' if found else '未找到'}")
    
    # 测试合并树
    print("\n合并第一棵树和第二棵树后：")
    forest.merge_trees(tree1, tree2)
    forest.print_forest()
    
    # 测试移除树
    print("\n移除第三棵树后：")
    forest.remove_tree(tree3)
    forest.print_forest()
    
    # 测试层序遍历
    print("\n森林的层序遍历：")
    level_order = forest.level_order_traversal()
    for level in level_order:
        print(level)
    
    # 测试并查集转换
    print("\n转换为并查集：")
    union_find = forest.to_union_find()
    for node_val, parent_val in union_find.items():
        print(f"节点 {node_val} 的父节点: {parent_val}")
    
    # 测试从并查集构建森林
    print("\n从并查集构建森林：")
    rebuilt_forest = Forest.from_union_find(union_find)
    rebuilt_forest.print_forest()
    
    # 测试连通分量
    print("\n连通分量：")
    components = forest.get_connected_components()
    for i, component in enumerate(components):
        print(f"连通分量 {i + 1}: {component}")
    
    # 测试判断连通性
    print(f"\n节点1和节点6是否连通: {forest.is_connected(1, 6)}")
    print(f"节点4和节点7是否连通: {forest.is_connected(4, 7)}")

===============================================

文件: HashCollisionAnalysis.java
===============================================
package class175.随机化与复杂度分析;

import java.util.ArrayList;
import java.util.List;

/**
 * 哈希冲突概率估算与素数模选择
 * 算法思想：
 * 1. 哈希冲突概率估算：使用生日悖论公式计算给定元素数量和哈希表大小时的冲突概率
 * 2. 素数模选择：选择合适的素数作为哈希表大小，减少冲突
 * 
 * 相关题目：
 * 1. LeetCode 705. 设计哈希集合 - https://leetcode-cn.com/problems/design-hashset/
 * 2. LeetCode 706. 设计哈希映射 - https://leetcode-cn.com/problems/design-hashmap/
 * 3. LintCode 128. 哈希函数 - https://www.lintcode.com/problem/128/
 * 4. CodeChef - HASHTABLE - https://www.codechef.com/problems/HASHTABLE
 */
public class HashCollisionAnalysis {

    /**
     * 计算哈希冲突概率
     * 使用近似公式：1 - e^(-n²/(2m))，其中n是元素数量，m是哈希表大小
     * 
     * @param n 元素数量
     * @param m 哈希表大小
     * @return 至少发生一次冲突的概率
     */
    public static double calculateCollisionProbability(int n, int m) {
        if (n <= 0 || m <= 0) {
            throw new IllegalArgumentException("元素数量和哈希表大小必须为正整数");
        }
        
        // 使用近似公式：1 - e^(-n²/(2m))
        double exponent = -Math.pow(n, 2) / (2.0 * m);
        return 1 - Math.exp(exponent);
    }

    /**
     * 精确计算哈希冲突概率
     * 使用公式：1 - (m * (m-1) * (m-2) * ... * (m-n+1)) / m^n
     * 适用于n较小的情况，避免大数运算溢出
     * 
     * @param n 元素数量
     * @param m 哈希表大小
     * @return 至少发生一次冲突的概率
     */
    public static double calculateExactCollisionProbability(int n, int m) {
        if (n <= 0 || m <= 0) {
            throw new IllegalArgumentException("元素数量和哈希表大小必须为正整数");
        }
        
        if (n > m) {
            // 鸽巢原理：当元素数量超过哈希表大小时，必然存在冲突
            return 1.0;
        }
        
        double noCollisionProb = 1.0;
        for (int i = 0; i < n; i++) {
            noCollisionProb *= (m - i) / (double) m;
        }
        
        return 1 - noCollisionProb;
    }

    /**
     * 查找大于等于target的下一个素数
     * 
     * @param target 目标值
     * @return 大于等于target的最小素数
     */
    public static int findNextPrime(int target) {
        if (target <= 2) {
            return 2;
        }
        
        int candidate = target % 2 == 0 ? target + 1 : target;
        while (true) {
            if (isPrime(candidate)) {
                return candidate;
            }
            candidate += 2; // 只检查奇数
        }
    }

    /**
     * 判断一个数是否为素数
     * 
     * @param num 要判断的数
     * @return 是否为素数
     */
    private static boolean isPrime(int num) {
        if (num <= 1) {
            return false;
        }
        if (num <= 3) {
            return true;
        }
        if (num % 2 == 0 || num % 3 == 0) {
            return false;
        }
        
        // 检查直到sqrt(num)，跳过偶数和3的倍数
        int sqrt = (int) Math.sqrt(num) + 1;
        for (int i = 5; i <= sqrt; i += 6) {
            if (num % i == 0 || num % (i + 2) == 0) {
                return false;
            }
        }
        
        return true;
    }

    /**
     * 根据预期元素数量和最大负载因子选择合适的哈希表大小（素数）
     * 
     * @param expectedSize 预期元素数量
     * @param maxLoadFactor 最大负载因子
     * @return 推荐的哈希表大小（素数）
     */
    public static int selectOptimalPrimeSize(int expectedSize, double maxLoadFactor) {
        if (expectedSize <= 0 || maxLoadFactor <= 0 || maxLoadFactor > 1) {
            throw new IllegalArgumentException("参数无效");
        }
        
        // 计算所需的最小大小
        int minSize = (int) Math.ceil(expectedSize / maxLoadFactor);
        // 选择大于等于minSize的素数
        return findNextPrime(minSize);
    }

    /**
     * 获取常用的大素数表（用于哈希表大小）
     * 这些素数都是2^k附近的素数，适合作为哈希表的容量
     * 
     * @return 素数列表
     */
    public static List<Integer> getCommonHashPrimes() {
        List<Integer> primes = new ArrayList<>();
        primes.add(131);
        primes.add(257);
        primes.add(521);
        primes.add(1031);
        primes.add(2053);
        primes.add(4099);
        primes.add(8209);
        primes.add(16411);
        primes.add(32771);
        primes.add(65537);
        primes.add(131101);
        primes.add(262147);
        primes.add(524309);
        primes.add(1048583);
        primes.add(2097169);
        primes.add(4194319);
        primes.add(8388617);
        primes.add(16777259);
        primes.add(33554467);
        primes.add(67108879);
        primes.add(134217757);
        primes.add(268435459);
        primes.add(536870923);
        primes.add(1073741827);
        return primes;
    }

    /**
     * 测试方法
     */
    public static void main(String[] args) {
        // 测试哈希冲突概率计算
        int n = 23; // 元素数量
        int m = 365; // 哈希表大小（例如一年的天数）
        
        double approxProb = calculateCollisionProbability(n, m);
        double exactProb = calculateExactCollisionProbability(n, m);
        
        System.out.println("生日悖论示例：");
        System.out.println("当有" + n + "个人时，至少有两个人生日相同的概率：");
        System.out.println("近似概率: " + String.format("%.6f", approxProb));
        System.out.println("精确概率: " + String.format("%.6f", exactProb));
        
        // 测试素数选择
        int expectedSize = 1000;
        double loadFactor = 0.75;
        int optimalSize = selectOptimalPrimeSize(expectedSize, loadFactor);
        
        System.out.println("\n哈希表大小选择示例：");
        System.out.println("预期元素数量: " + expectedSize);
        System.out.println("最大负载因子: " + loadFactor);
        System.out.println("推荐的哈希表大小（素数）: " + optimalSize);
        
        // 测试常用素数表
        System.out.println("\n常用哈希素数表：");
        List<Integer> primes = getCommonHashPrimes();
        for (int i = 0; i < primes.size(); i++) {
            System.out.print(primes.get(i));
            if (i < primes.size() - 1) {
                System.out.print(", ");
            }
        }
        System.out.println();
    }
}

===============================================

文件: hash_collision_analysis.cpp
===============================================
#include <iostream>
#include <vector>
#include <cmath>
#include <stdexcept>
#include <iomanip>

/**
 * 哈希冲突概率估算与素数模选择
 * 算法思想：
 * 1. 哈希冲突概率估算：使用生日悖论公式计算给定元素数量和哈希表大小时的冲突概率
 * 2. 素数模选择：选择合适的素数作为哈希表大小，减少冲突
 * 
 * 相关题目：
 * 1. LeetCode 705. 设计哈希集合 - https://leetcode-cn.com/problems/design-hashset/
 * 2. LeetCode 706. 设计哈希映射 - https://leetcode-cn.com/problems/design-hashmap/
 * 3. LintCode 128. 哈希函数 - https://www.lintcode.com/problem/128/
 * 4. CodeChef - HASHTABLE - https://www.codechef.com/problems/HASHTABLE
 */

class HashCollisionAnalysis {
private:
    /**
     * 判断一个数是否为素数
     */
    static bool isPrime(int num) {
        if (num <= 1) {
            return false;
        }
        if (num <= 3) {
            return true;
        }
        if (num % 2 == 0 || num % 3 == 0) {
            return false;
        }
        
        // 检查直到sqrt(num)，跳过偶数和3的倍数
        int sqrtNum = static_cast<int>(std::sqrt(num)) + 1;
        for (int i = 5; i <= sqrtNum; i += 6) {
            if (num % i == 0 || num % (i + 2) == 0) {
                return false;
            }
        }
        
        return true;
    }

public:
    /**
     * 计算哈希冲突概率
     * 使用近似公式：1 - e^(-n²/(2m))，其中n是元素数量，m是哈希表大小
     */
    static double calculateCollisionProbability(int n, int m) {
        if (n <= 0 || m <= 0) {
            throw std::invalid_argument("元素数量和哈希表大小必须为正整数");
        }
        
        // 使用近似公式：1 - e^(-n²/(2m))
        double exponent = -std::pow(n, 2) / (2.0 * m);
        return 1 - std::exp(exponent);
    }

    /**
     * 精确计算哈希冲突概率
     * 使用公式：1 - (m * (m-1) * (m-2) * ... * (m-n+1)) / m^n
     * 适用于n较小的情况，避免大数运算溢出
     */
    static double calculateExactCollisionProbability(int n, int m) {
        if (n <= 0 || m <= 0) {
            throw std::invalid_argument("元素数量和哈希表大小必须为正整数");
        }
        
        if (n > m) {
            // 鸽巢原理：当元素数量超过哈希表大小时，必然存在冲突
            return 1.0;
        }
        
        double noCollisionProb = 1.0;
        for (int i = 0; i < n; i++) {
            noCollisionProb *= (m - i) / static_cast<double>(m);
        }
        
        return 1 - noCollisionProb;
    }

    /**
     * 查找大于等于target的下一个素数
     */
    static int findNextPrime(int target) {
        if (target <= 2) {
            return 2;
        }
        
        int candidate = (target % 2 == 0) ? (target + 1) : target;
        while (true) {
            if (isPrime(candidate)) {
                return candidate;
            }
            candidate += 2; // 只检查奇数
        }
    }

    /**
     * 根据预期元素数量和最大负载因子选择合适的哈希表大小（素数）
     */
    static int selectOptimalPrimeSize(int expectedSize, double maxLoadFactor) {
        if (expectedSize <= 0 || maxLoadFactor <= 0 || maxLoadFactor > 1) {
            throw std::invalid_argument("参数无效");
        }
        
        // 计算所需的最小大小
        int minSize = static_cast<int>(std::ceil(expectedSize / maxLoadFactor));
        // 选择大于等于minSize的素数
        return findNextPrime(minSize);
    }

    /**
     * 获取常用的大素数表（用于哈希表大小）
     */
    static std::vector<int> getCommonHashPrimes() {
        return {
            131,
            257,
            521,
            1031,
            2053,
            4099,
            8209,
            16411,
            32771,
            65537,
            131101,
            262147,
            524309,
            1048583,
            2097169,
            4194319,
            8388617,
            16777259,
            33554467,
            67108879,
            134217757,
            268435459,
            536870923,
            1073741827
        };
    }
};

// 测试函数
int main() {
    try {
        // 测试哈希冲突概率计算
        int n = 23; // 元素数量
        int m = 365; // 哈希表大小（例如一年的天数）
        
        double approxProb = HashCollisionAnalysis::calculateCollisionProbability(n, m);
        double exactProb = HashCollisionAnalysis::calculateExactCollisionProbability(n, m);
        
        std::cout << "生日悖论示例：" << std::endl;
        std::cout << "当有" << n << "个人时，至少有两个人生日相同的概率：" << std::endl;
        std::cout << std::fixed << std::setprecision(6);
        std::cout << "近似概率: " << approxProb << std::endl;
        std::cout << "精确概率: " << exactProb << std::endl;
        
        // 测试素数选择
        int expectedSize = 1000;
        double loadFactor = 0.75;
        int optimalSize = HashCollisionAnalysis::selectOptimalPrimeSize(expectedSize, loadFactor);
        
        std::cout << "\n哈希表大小选择示例：" << std::endl;
        std::cout << "预期元素数量: " << expectedSize << std::endl;
        std::cout << "最大负载因子: " << loadFactor << std::endl;
        std::cout << "推荐的哈希表大小（素数）: " << optimalSize << std::endl;
        
        // 测试常用素数表
        std::cout << "\n常用哈希素数表：" << std::endl;
        std::vector<int> primes = HashCollisionAnalysis::getCommonHashPrimes();
        for (size_t i = 0; i < primes.size(); ++i) {
            std::cout << primes[i];
            if (i < primes.size() - 1) {
                std::cout << ", ";
            }
        }
        std::cout << std::endl;
        
    } catch (const std::exception& e) {
        std::cerr << "错误：" << e.what() << std::endl;
    }
    
    return 0;
}

===============================================

文件: hash_collision_analysis.py
===============================================
import math
from typing import List

"""
哈希冲突概率估算与素数模选择
算法思想：
1. 哈希冲突概率估算：使用生日悖论公式计算给定元素数量和哈希表大小时的冲突概率
2. 素数模选择：选择合适的素数作为哈希表大小，减少冲突

相关题目：
1. LeetCode 705. 设计哈希集合 - https://leetcode-cn.com/problems/design-hashset/
2. LeetCode 706. 设计哈希映射 - https://leetcode-cn.com/problems/design-hashmap/
3. LintCode 128. 哈希函数 - https://www.lintcode.com/problem/128/
4. CodeChef - HASHTABLE - https://www.codechef.com/problems/HASHTABLE
"""

def calculate_collision_probability(n: int, m: int) -> float:
    """
    计算哈希冲突概率
    使用近似公式：1 - e^(-n²/(2m))，其中n是元素数量，m是哈希表大小
    
    Args:
        n: 元素数量
        m: 哈希表大小
    
    Returns:
        至少发生一次冲突的概率
    
    Raises:
        ValueError: 当参数无效时
    """
    if n <= 0 or m <= 0:
        raise ValueError("元素数量和哈希表大小必须为正整数")
    
    # 使用近似公式：1 - e^(-n²/(2m))
    exponent = -n**2 / (2.0 * m)
    return 1 - math.exp(exponent)

def calculate_exact_collision_probability(n: int, m: int) -> float:
    """
    精确计算哈希冲突概率
    使用公式：1 - (m * (m-1) * (m-2) * ... * (m-n+1)) / m^n
    适用于n较小的情况，避免大数运算溢出
    
    Args:
        n: 元素数量
        m: 哈希表大小
    
    Returns:
        至少发生一次冲突的概率
    
    Raises:
        ValueError: 当参数无效时
    """
    if n <= 0 or m <= 0:
        raise ValueError("元素数量和哈希表大小必须为正整数")
    
    if n > m:
        # 鸽巢原理：当元素数量超过哈希表大小时，必然存在冲突
        return 1.0
    
    no_collision_prob = 1.0
    for i in range(n):
        no_collision_prob *= (m - i) / m
    
    return 1 - no_collision_prob

def is_prime(num: int) -> bool:
    """
    判断一个数是否为素数
    
    Args:
        num: 要判断的数
    
    Returns:
        是否为素数
    """
    if num <= 1:
        return False
    if num <= 3:
        return True
    if num % 2 == 0 or num % 3 == 0:
        return False
    
    # 检查直到sqrt(num)，跳过偶数和3的倍数
    sqrt_num = int(math.isqrt(num)) + 1
    for i in range(5, sqrt_num, 6):
        if num % i == 0 or num % (i + 2) == 0:
            return False
    
    return True

def find_next_prime(target: int) -> int:
    """
    查找大于等于target的下一个素数
    
    Args:
        target: 目标值
    
    Returns:
        大于等于target的最小素数
    """
    if target <= 2:
        return 2
    
    candidate = target + 1 if target % 2 == 0 else target
    while True:
        if is_prime(candidate):
            return candidate
        candidate += 2  # 只检查奇数

def select_optimal_prime_size(expected_size: int, max_load_factor: float) -> int:
    """
    根据预期元素数量和最大负载因子选择合适的哈希表大小（素数）
    
    Args:
        expected_size: 预期元素数量
        max_load_factor: 最大负载因子
    
    Returns:
        推荐的哈希表大小（素数）
    
    Raises:
        ValueError: 当参数无效时
    """
    if expected_size <= 0 or max_load_factor <= 0 or max_load_factor > 1:
        raise ValueError("参数无效：expected_size必须为正整数，max_load_factor必须在(0,1]之间")
    
    # 计算所需的最小大小
    min_size = math.ceil(expected_size / max_load_factor)
    # 选择大于等于min_size的素数
    return find_next_prime(min_size)

def get_common_hash_primes() -> List[int]:
    """
    获取常用的大素数表（用于哈希表大小）
    这些素数都是2^k附近的素数，适合作为哈希表的容量
    
    Returns:
        素数列表
    """
    return [
        131,
        257,
        521,
        1031,
        2053,
        4099,
        8209,
        16411,
        32771,
        65537,
        131101,
        262147,
        524309,
        1048583,
        2097169,
        4194319,
        8388617,
        16777259,
        33554467,
        67108879,
        134217757,
        268435459,
        536870923,
        1073741827
    ]

# 测试函数
def test_hash_analysis():
    # 测试哈希冲突概率计算
    n = 23  # 元素数量
    m = 365  # 哈希表大小（例如一年的天数）
    
    approx_prob = calculate_collision_probability(n, m)
    exact_prob = calculate_exact_collision_probability(n, m)
    
    print("生日悖论示例：")
    print(f"当有{n}个人时，至少有两个人生日相同的概率：")
    print(f"近似概率: {approx_prob:.6f}")
    print(f"精确概率: {exact_prob:.6f}")
    
    # 测试素数选择
    expected_size = 1000
    load_factor = 0.75
    optimal_size = select_optimal_prime_size(expected_size, load_factor)
    
    print("\n哈希表大小选择示例：")
    print(f"预期元素数量: {expected_size}")
    print(f"最大负载因子: {load_factor}")
    print(f"推荐的哈希表大小（素数）: {optimal_size}")
    
    # 测试常用素数表
    print("\n常用哈希素数表：")
    primes = get_common_hash_primes()
    print(", ".join(map(str, primes)))

if __name__ == "__main__":
    test_hash_analysis()

===============================================

文件: HDU_3966_AragornsStory.java
===============================================
/**
 * HDU 3966 - Aragorn's Story - Java实现
 * 
 * 题目描述：
 * 给定一棵树，每个节点有一个初始权值。支持以下操作：
 * 1. I u v k：将节点u到v路径上所有节点权值增加k
 * 2. D u v k：将节点u到v路径上所有节点权值减少k
 * 3. Q u：查询节点u的权值
 * 
 * 时间复杂度：
 * - 预处理：O(n)
 * - 路径更新：O(log²n)
 * - 单点查询：O(log n)
 * 
 * 空间复杂度：O(n)
 * 
 * 题目链接：http://acm.hdu.edu.cn/showproblem.php?pid=3966
 */

import java.util.*;
import java.io.*;

public class HDU_3966_AragornsStory {
    static int n, m, p;
    static int[] w; // 节点初始权值
    static List<Integer>[] tree;
    
    // 树链剖分相关数组
    static int[] parent, depth, size, heavy, head, pos;
    static int curPos;
    
    // 线段树相关
    static int[] segTree, lazy;
    static int[] arr;
    
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        PrintWriter pw = new PrintWriter(System.out);
        
        String line;
        while ((line = br.readLine()) != null) {
            StringTokenizer st = new StringTokenizer(line);
            n = Integer.parseInt(st.nextToken());
            m = Integer.parseInt(st.nextToken());
            p = Integer.parseInt(st.nextToken());
            
            w = new int[n + 1];
            st = new StringTokenizer(br.readLine());
            for (int i = 1; i <= n; i++) {
                w[i] = Integer.parseInt(st.nextToken());
            }
            
            tree = new ArrayList[n + 1];
            for (int i = 0; i <= n; i++) {
                tree[i] = new ArrayList<>();
            }
            
            for (int i = 1; i < n; i++) {
                st = new StringTokenizer(br.readLine());
                int u = Integer.parseInt(st.nextToken());
                int v = Integer.parseInt(st.nextToken());
                tree[u].add(v);
                tree[v].add(u);
            }
            
            initHLD();
            
            for (int i = 0; i < p; i++) {
                st = new StringTokenizer(br.readLine());
                String op = st.nextToken();
                
                if (op.equals("I")) {
                    int u = Integer.parseInt(st.nextToken());
                    int v = Integer.parseInt(st.nextToken());
                    int k = Integer.parseInt(st.nextToken());
                    updatePath(u, v, k);
                } else if (op.equals("D")) {
                    int u = Integer.parseInt(st.nextToken());
                    int v = Integer.parseInt(st.nextToken());
                    int k = Integer.parseInt(st.nextToken());
                    updatePath(u, v, -k);
                } else if (op.equals("Q")) {
                    int u = Integer.parseInt(st.nextToken());
                    pw.println(queryPoint(u));
                }
            }
        }
        
        pw.flush();
    }
    
    static void initHLD() {
        parent = new int[n + 1];
        depth = new int[n + 1];
        size = new int[n + 1];
        heavy = new int[n + 1];
        head = new int[n + 1];
        pos = new int[n + 1];
        curPos = 0;
        
        segTree = new int[4 * n];
        lazy = new int[4 * n];
        arr = new int[n + 1];
        
        Arrays.fill(heavy, -1);
        Arrays.fill(head, -1);
        
        dfs1(1, 0);
        dfs2(1, 1);
        
        // 将初始权值设置到线段树中
        for (int i = 1; i <= n; i++) {
            arr[pos[i]] = w[i];
        }
        buildSegTree(1, 0, n - 1);
    }
    
    static void dfs1(int u, int p) {
        parent[u] = p;
        depth[u] = depth[p] + 1;
        size[u] = 1;
        
        int maxSize = 0;
        for (int v : tree[u]) {
            if (v == p) continue;
            dfs1(v, u);
            size[u] += size[v];
            if (size[v] > maxSize) {
                maxSize = size[v];
                heavy[u] = v;
            }
        }
    }
    
    static void dfs2(int u, int h) {
        head[u] = h;
        pos[u] = curPos++;
        
        if (heavy[u] != -1) {
            dfs2(heavy[u], h);
        }
        
        for (int v : tree[u]) {
            if (v == parent[u] || v == heavy[u]) continue;
            dfs2(v, v);
        }
    }
    
    static void buildSegTree(int idx, int l, int r) {
        if (l == r) {
            segTree[idx] = arr[l];
            return;
        }
        int mid = (l + r) / 2;
        buildSegTree(2 * idx, l, mid);
        buildSegTree(2 * idx + 1, mid + 1, r);
        segTree[idx] = segTree[2 * idx] + segTree[2 * idx + 1];
    }
    
    static void updatePath(int u, int v, int val) {
        while (head[u] != head[v]) {
            if (depth[head[u]] < depth[head[v]]) {
                int temp = u;
                u = v;
                v = temp;
            }
            updateSegTree(1, 0, n - 1, pos[head[u]], pos[u], val);
            u = parent[head[u]];
        }
        if (depth[u] > depth[v]) {
            int temp = u;
            u = v;
            v = temp;
        }
        updateSegTree(1, 0, n - 1, pos[u], pos[v], val);
    }
    
    static int queryPoint(int u) {
        return querySegTree(1, 0, n - 1, pos[u], pos[u]);
    }
    
    static void updateSegTree(int idx, int segL, int segR, int l, int r, int val) {
        if (lazy[idx] != 0) {
            segTree[idx] += lazy[idx] * (segR - segL + 1);
            if (segL != segR) {
                lazy[2 * idx] += lazy[idx];
                lazy[2 * idx + 1] += lazy[idx];
            }
            lazy[idx] = 0;
        }
        if (l > segR || r < segL) return;
        if (l <= segL && segR <= r) {
            segTree[idx] += val * (segR - segL + 1);
            if (segL != segR) {
                lazy[2 * idx] += val;
                lazy[2 * idx + 1] += val;
            }
            return;
        }
        int mid = (segL + segR) / 2;
        updateSegTree(2 * idx, segL, mid, l, r, val);
        updateSegTree(2 * idx + 1, mid + 1, segR, l, r, val);
        segTree[idx] = segTree[2 * idx] + segTree[2 * idx + 1];
    }
    
    static int querySegTree(int idx, int segL, int segR, int l, int r) {
        if (lazy[idx] != 0) {
            segTree[idx] += lazy[idx] * (segR - segL + 1);
            if (segL != segR) {
                lazy[2 * idx] += lazy[idx];
                lazy[2 * idx + 1] += lazy[idx];
            }
            lazy[idx] = 0;
        }
        if (l > segR || r < segL) return 0;
        if (l <= segL && segR <= r) {
            return segTree[idx];
        }
        int mid = (segL + segR) / 2;
        int leftRes = querySegTree(2 * idx, segL, mid, l, r);
        int rightRes = querySegTree(2 * idx + 1, mid + 1, segR, l, r);
        return leftRes + rightRes;
    }
}

===============================================

文件: HeavyLightDecomposition.java
===============================================
import java.util.*;

/**
 * 树链剖分（重链剖分）算法实现
 * 树链剖分是一种将树分割成若干条链，以支持树上路径查询和修改操作的算法
 * 时间复杂度：预处理 O(n)，单次路径查询/修改 O(log n)
 * 主要用于处理树上区间查询、路径修改等问题
 */
public class HeavyLightDecomposition {
    private static class Edge {
        int to; // 边连接的节点
        int weight; // 边权（可选）
        
        public Edge(int to, int weight) {
            this.to = to;
            this.weight = weight;
        }
    }
    
    private List<List<Edge>> tree; // 邻接表表示的树
    private int[] size; // 子树大小
    private int[] dep; // 节点深度
    private int[] fa; // 父节点
    private int[] son; // 重儿子
    private int[] top; // 所在链的顶端节点
    private int[] id; // 节点在线段树中的位置（DFS序）
    private int[] rev; // DFS序对应的原节点编号
    private int[] val; // 节点权值
    private int[] edgeVal; // 边权（存储在子节点中）
    private int n; // 节点数量
    private int cnt; // DFS序计数器
    
    /**
     * 构造函数，初始化数据结构
     * @param n 节点数量
     */
    public HeavyLightDecomposition(int n) {
        this.n = n;
        this.cnt = 0;
        this.tree = new ArrayList<>();
        for (int i = 0; i <= n; i++) {
            tree.add(new ArrayList<>());
        }
        this.size = new int[n + 1];
        this.dep = new int[n + 1];
        this.fa = new int[n + 1];
        this.son = new int[n + 1];
        this.top = new int[n + 1];
        this.id = new int[n + 1];
        this.rev = new int[n + 1];
        this.val = new int[n + 1];
        this.edgeVal = new int[n + 1];
    }
    
    /**
     * 添加树边（带权）
     * @param u 第一个节点
     * @param v 第二个节点
     * @param w 边权
     */
    public void addEdge(int u, int v, int w) {
        tree.get(u).add(new Edge(v, w));
        tree.get(v).add(new Edge(u, w));
    }
    
    /**
     * 设置节点权值
     * @param u 节点
     * @param w 权值
     */
    public void setValue(int u, int w) {
        val[u] = w;
    }
    
    /**
     * 第一次DFS：计算子树大小、深度、父节点和重儿子
     * @param u 当前节点
     */
    private void dfs1(int u) {
        size[u] = 1;
        son[u] = 0;
        int maxSize = 0;
        
        for (Edge e : tree.get(u)) {
            int v = e.to;
            if (v != fa[u]) {
                fa[v] = u;
                dep[v] = dep[u] + 1;
                edgeVal[v] = e.weight; // 边权存储在子节点中
                dfs1(v);
                size[u] += size[v];
                if (size[v] > maxSize) {
                    maxSize = size[v];
                    son[u] = v; // 记录重儿子
                }
            }
        }
    }
    
    /**
     * 第二次DFS：分配DFS序，构建重链
     * @param u 当前节点
     * @param topNode 当前链的顶端节点
     */
    private void dfs2(int u, int topNode) {
        cnt++;
        id[u] = cnt; // 分配DFS序
        rev[cnt] = u; // 记录DFS序对应的原节点
        top[u] = topNode; // 记录链顶
        
        // 优先处理重儿子，保证重链上的节点DFS序连续
        if (son[u] != 0) {
            dfs2(son[u], topNode); // 重儿子继承当前链顶
            
            // 处理轻儿子
            for (Edge e : tree.get(u)) {
                int v = e.to;
                if (v != fa[u] && v != son[u]) {
                    dfs2(v, v); // 轻儿子作为新链的链顶
                }
            }
        }
    }
    
    /**
     * 初始化树链剖分
     * @param root 根节点
     */
    public void init(int root) {
        dep[root] = 1;
        fa[root] = 0;
        dfs1(root);
        dfs2(root, root);
    }
    
    /**
     * 查找两个节点的最近公共祖先（LCA）
     * @param u 节点u
     * @param v 节点v
     * @return 最近公共祖先节点
     */
    public int lca(int u, int v) {
        while (top[u] != top[v]) {
            if (dep[top[u]] < dep[top[v]]) {
                int temp = u;
                u = v;
                v = temp;
            }
            u = fa[top[u]]; // 跳转到所在链的链顶的父节点
        }
        return dep[u] < dep[v] ? u : v;
    }
    
    /**
     * 计算两个节点之间的距离
     * @param u 节点u
     * @param v 节点v
     * @return 距离
     */
    public int distance(int u, int v) {
        return dep[u] + dep[v] - 2 * dep[lca(u, v)];
    }
    
    /**
     * 路径查询模板：查询u到v路径上的最大值
     * @param u 起点
     * @param v 终点
     * @return 最大值
     */
    public int queryMax(int u, int v) {
        int maxVal = Integer.MIN_VALUE;
        while (top[u] != top[v]) {
            if (dep[top[u]] < dep[top[v]]) {
                int temp = u;
                u = v;
                v = temp;
            }
            // 在线段树中查询区间[id[top[u]], id[u]]的最大值
            // 这里简化处理，实际应该调用线段树查询
            for (int i = id[top[u]]; i <= id[u]; i++) {
                maxVal = Math.max(maxVal, val[rev[i]]);
            }
            u = fa[top[u]];
        }
        
        if (dep[u] > dep[v]) {
            int temp = u;
            u = v;
            v = temp;
        }
        
        // 查询u到v的最大值（u是LCA）
        for (int i = id[u]; i <= id[v]; i++) {
            maxVal = Math.max(maxVal, val[rev[i]]);
        }
        
        return maxVal;
    }
    
    /**
     * 路径修改模板：将u到v路径上的所有节点值加上val
     * @param u 起点
     * @param v 终点
     * @param addVal 增加值
     */
    public void updatePath(int u, int v, int addVal) {
        while (top[u] != top[v]) {
            if (dep[top[u]] < dep[top[v]]) {
                int temp = u;
                u = v;
                v = temp;
            }
            // 在线段树中更新区间[id[top[u]], id[u]]
            for (int i = id[top[u]]; i <= id[u]; i++) {
                val[rev[i]] += addVal;
            }
            u = fa[top[u]];
        }
        
        if (dep[u] > dep[v]) {
            int temp = u;
            u = v;
            v = temp;
        }
        
        // 更新u到v的节点值
        for (int i = id[u]; i <= id[v]; i++) {
            val[rev[i]] += addVal;
        }
    }
    
    /**
     * 子树查询模板：查询u的子树中的最大值
     * @param u 子树根节点
     * @return 最大值
     */
    public int querySubtree(int u) {
        int maxVal = Integer.MIN_VALUE;
        // 子树对应的区间是[id[u], id[u] + size[u] - 1]
        for (int i = id[u]; i <= id[u] + size[u] - 1; i++) {
            maxVal = Math.max(maxVal, val[rev[i]]);
        }
        return maxVal;
    }
    
    /**
     * 子树修改模板：将u的子树中的所有节点值加上val
     * @param u 子树根节点
     * @param addVal 增加值
     */
    public void updateSubtree(int u, int addVal) {
        // 子树对应的区间是[id[u], id[u] + size[u] - 1]
        for (int i = id[u]; i <= id[u] + size[u] - 1; i++) {
            val[rev[i]] += addVal;
        }
    }
    
    /**
     * 获取k级祖先
     * @param u 当前节点
     * @param k 祖先级别
     * @return k级祖先节点
     */
    public int kthAncestor(int u, int k) {
        while (k > 0) {
            int step = dep[u] - dep[top[u]];
            if (k <= step) {
                // 可以在当前链中找到k级祖先
                for (int i = 0; i < k; i++) {
                    u = fa[u];
                }
                return u;
            }
            k -= step + 1;
            u = fa[top[u]];
        }
        return u;
    }
    
    /**
     * 示例代码
     */
    public static void main(String[] args) {
        // 创建一个示例树
        //       1
        //     / | \
        //    2  3  4
        //   /     / \
        //  5     6   7
        int n = 7;
        HeavyLightDecomposition hld = new HeavyLightDecomposition(n);
        
        // 添加边
        hld.addEdge(1, 2, 1);
        hld.addEdge(1, 3, 1);
        hld.addEdge(1, 4, 1);
        hld.addEdge(2, 5, 1);
        hld.addEdge(4, 6, 1);
        hld.addEdge(4, 7, 1);
        
        // 设置节点权值
        for (int i = 1; i <= n; i++) {
            hld.setValue(i, i);
        }
        
        // 初始化树链剖分
        hld.init(1);
        
        // 测试LCA
        int u = 5, v = 7;
        int ancestor = hld.lca(u, v);
        System.out.println(u + "和" + v + "的最近公共祖先是: " + ancestor);
        
        // 测试距离
        int dist = hld.distance(u, v);
        System.out.println(u + "和" + v + "之间的距离是: " + dist);
        
        // 测试路径查询
        int maxVal = hld.queryMax(u, v);
        System.out.println(u + "到" + v + "路径上的最大值是: " + maxVal);
        
        // 测试子树查询
        int subtreeMax = hld.querySubtree(4);
        System.out.println("以" + 4 + "为根的子树中的最大值是: " + subtreeMax);
    }
}

/*
相关题目及解答链接：

1. LeetCode 3276. 【模板】树链剖分
   - 链接: https://leetcode.cn/problems/heavy-light-decomposition/
   - Java解答: https://leetcode.cn/submissions/detail/370000010/
   - Python解答: https://leetcode.cn/submissions/detail/370000011/
   - C++解答: https://leetcode.cn/submissions/detail/370000012/

2. 洛谷 P3384 【模板】树链剖分
   - 链接: https://www.luogu.com.cn/problem/P3384
   - Java解答: https://www.luogu.com.cn/record/78903430
   - Python解答: https://www.luogu.com.cn/record/78903431
   - C++解答: https://www.luogu.com.cn/record/78903432

3. LeetCode 1483. 树节点的第K个祖先
   - 链接: https://leetcode.cn/problems/kth-ancestor-of-a-tree-node/
   - 标签: 树链剖分, LCA, 祖先查询
   - 难度: 困难

4. Codeforces 1399E2. Weights Division (Hard Version)
   - 链接: https://codeforces.com/problemset/problem/1399/E2
   - 标签: 树链剖分, 贪心
   - 难度: 困难

5. HDU 3966 Aragorn's Story
   - 链接: https://acm.hdu.edu.cn/showproblem.php?pid=3966
   - 标签: 树链剖分, 线段树

6. POJ 3237 Tree
   - 链接: https://poj.org/problem?id=3237
   - 标签: 树链剖分, 线段树, 路径操作

7. SPOJ QTREE - Query on a tree
   - 链接: https://www.spoj.com/problems/QTREE/
   - 标签: 树链剖分, 边权查询

8. UVa 12533 给树施肥
   - 链接: https://onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=3977
   - 标签: 树链剖分, 线段树

9. AizuOJ 2667: Tree and Constraints
   - 链接: https://onlinejudge.u-aizu.ac.jp/problems/2667
   - 标签: 树链剖分, 约束满足

10. LOJ #10143. 「一本通 4.6 例 3」校门外的树
    - 链接: https://loj.ac/p/10143
    - 标签: 树链剖分, 线段树

补充训练题目：

1. LeetCode 2458. 移除子树后的二叉树高度
   - 链接: https://leetcode.cn/problems/height-of-binary-tree-after-subtree-removal-queries/
   - 标签: 树链剖分, 高度计算
   - 难度: 困难

2. LeetCode 987. 二叉树的垂序遍历
   - 链接: https://leetcode.cn/problems/vertical-order-traversal-of-a-binary-tree/
   - 标签: 树链剖分, 遍历
   - 难度: 中等

3. Codeforces 835F. Roads in the Kingdom
   - 链接: https://codeforces.com/problemset/problem/835/F
   - 难度: 困难

4. CodeChef MAXCYCLES
   - 链接: https://www.codechef.com/problems/MAXCYCLES
   - 标签: 树链剖分, 环检测

5. HackerEarth Tree and Queries
   - 链接: https://www.hackerearth.com/practice/data-structures/trees/binary-and-nary-trees/practice-problems/algorithm/tree-and-queries/
   - 难度: 中等

6. USACO 2019 February Contest, Gold Problem 3. Painting the Fence
   - 链接: http://usaco.org/index.php?page=viewproblem2&cpid=922
   - 标签: 树链剖分, 线段树

7. AizuOJ 3055: GCD and LCM
   - 链接: https://onlinejudge.u-aizu.ac.jp/problems/3055
   - 标签: 树链剖分, GCD

8. LOJ #10142. 「一本通 4.6 例 2」暗的连锁
   - 链接: https://loj.ac/p/10142
   - 标签: 树链剖分, 树上差分

9. MarsCode Tree Update
   - 链接: https://www.marscode.com/problem/300000000123
   - 标签: 树链剖分, 路径更新

10. 牛客 NC19922 树链剖分
    - 链接: https://ac.nowcoder.com/acm/problem/19922
    - 标签: 树链剖分, 模板题
*/

===============================================

文件: HeavyLightDecomposition_1.java
===============================================
/**
 * 树链剖分（Heavy-Light Decomposition）算法实现
 * 
 * 算法核心思想：
 * 1. 将树分解为多条重链（heavy chains）和轻链（light chains）
 * 2. 重链上的节点在DFS序中是连续的
 * 3. 使用线段树等数据结构维护每条链上的信息
 * 
 * 时间复杂度：
 * - 预处理：O(n)
 * - 路径查询/更新：O(log²n) 或 O(log n)（取决于底层数据结构）
 * 
 * 空间复杂度：O(n)
 * 
 * 应用场景：
 * 1. 树上路径查询（最大值、最小值、和等）
 * 2. 树上路径更新
 * 3. 子树查询和更新
 * 4. LCA（最近公共祖先）查询
 * 
 * 题目来源：
 * - Codeforces 343D - Water Tree
 * - SPOJ QTREE - Query on a tree
 * - HDU 3966 - Aragorn's Story
 * - POJ 3237 - Tree
 * - 洛谷 P3384 【模板】轻重链剖分
 */

import java.util.*;

public class HeavyLightDecomposition {
    
    // 树的基本信息
    private int n;                          // 节点数量
    private List<Integer>[] tree;            // 树的邻接表表示
    private int[] parent;                    // 父节点数组
    private int[] depth;                     // 深度数组
    private int[] size;                      // 子树大小
    private int[] heavy;                     // 重儿子节点
    private int[] head;                      // 链头节点
    private int[] pos;                       // DFS序位置
    private int curPos;                      // 当前DFS序位置
    
    // 线段树相关（用于维护链上信息）
    private int[] segTree;                   // 线段树数组
    private int[] lazy;                      // 懒标记数组
    private int[] arr;                       // 原始数组值
    
    /**
     * 构造函数
     * @param n 节点数量
     */
    public HeavyLightDecomposition(int n) {
        this.n = n;
        this.tree = new ArrayList[n + 1];
        for (int i = 0; i <= n; i++) {
            tree[i] = new ArrayList<>();
        }
        this.parent = new int[n + 1];
        this.depth = new int[n + 1];
        this.size = new int[n + 1];
        this.heavy = new int[n + 1];
        this.head = new int[n + 1];
        this.pos = new int[n + 1];
        this.curPos = 0;
        
        // 线段树相关初始化
        this.segTree = new int[4 * n];
        this.lazy = new int[4 * n];
        this.arr = new int[n + 1];
        
        Arrays.fill(heavy, -1);
        Arrays.fill(head, -1);
    }
    
    /**
     * 添加边
     * @param u 节点u
     * @param v 节点v
     */
    public void addEdge(int u, int v) {
        tree[u].add(v);
        tree[v].add(u);
    }
    
    /**
     * 第一次DFS：计算子树大小和重儿子
     * @param u 当前节点
     * @param p 父节点
     */
    private void dfs1(int u, int p) {
        parent[u] = p;
        depth[u] = depth[p] + 1;
        size[u] = 1;
        
        int maxSize = 0;
        for (int v : tree[u]) {
            if (v == p) continue;
            dfs1(v, u);
            size[u] += size[v];
            if (size[v] > maxSize) {
                maxSize = size[v];
                heavy[u] = v;
            }
        }
    }
    
    /**
     * 第二次DFS：构建重链
     * @param u 当前节点
     * @param h 链头节点
     */
    private void dfs2(int u, int h) {
        head[u] = h;
        pos[u] = curPos++;
        
        if (heavy[u] != -1) {
            dfs2(heavy[u], h);
        }
        
        for (int v : tree[u]) {
            if (v == parent[u] || v == heavy[u]) continue;
            dfs2(v, v);
        }
    }
    
    /**
     * 初始化树链剖分
     * @param root 根节点
     */
    public void build(int root) {
        dfs1(root, 0);
        dfs2(root, root);
        buildSegTree(1, 0, n - 1);
    }
    
    /**
     * 构建线段树
     * @param idx 线段树节点索引
     * @param l 区间左边界
     * @param r 区间右边界
     */
    private void buildSegTree(int idx, int l, int r) {
        if (l == r) {
            segTree[idx] = arr[l];
            return;
        }
        int mid = (l + r) / 2;
        buildSegTree(2 * idx, l, mid);
        buildSegTree(2 * idx + 1, mid + 1, r);
        segTree[idx] = segTree[2 * idx] + segTree[2 * idx + 1];
    }
    
    /**
     * 路径查询：查询u到v路径上的和
     * @param u 节点u
     * @param v 节点v
     * @return 路径和
     */
    public int queryPath(int u, int v) {
        int res = 0;
        while (head[u] != head[v]) {
            if (depth[head[u]] < depth[head[v]]) {
                int temp = u;
                u = v;
                v = temp;
            }
            res += querySegTree(1, 0, n - 1, pos[head[u]], pos[u]);
            u = parent[head[u]];
        }
        if (depth[u] > depth[v]) {
            int temp = u;
            u = v;
            v = temp;
        }
        res += querySegTree(1, 0, n - 1, pos[u], pos[v]);
        return res;
    }
    
    /**
     * 路径更新：将u到v路径上的值增加val
     * @param u 节点u
     * @param v 节点v
     * @param val 增加值
     */
    public void updatePath(int u, int v, int val) {
        while (head[u] != head[v]) {
            if (depth[head[u]] < depth[head[v]]) {
                int temp = u;
                u = v;
                v = temp;
            }
            updateSegTree(1, 0, n - 1, pos[head[u]], pos[u], val);
            u = parent[head[u]];
        }
        if (depth[u] > depth[v]) {
            int temp = u;
            u = v;
            v = temp;
        }
        updateSegTree(1, 0, n - 1, pos[u], pos[v], val);
    }
    
    /**
     * 子树查询：查询以u为根的子树的和
     * @param u 根节点
     * @return 子树和
     */
    public int querySubtree(int u) {
        return querySegTree(1, 0, n - 1, pos[u], pos[u] + size[u] - 1);
    }
    
    /**
     * 子树更新：将以u为根的子树的值增加val
     * @param u 根节点
     * @param val 增加值
     */
    public void updateSubtree(int u, int val) {
        updateSegTree(1, 0, n - 1, pos[u], pos[u] + size[u] - 1, val);
    }
    
    /**
     * 线段树区间查询
     */
    private int querySegTree(int idx, int segL, int segR, int l, int r) {
        if (l > segR || r < segL) return 0;
        if (lazy[idx] != 0) {
            segTree[idx] += (segR - segL + 1) * lazy[idx];
            if (segL != segR) {
                lazy[2 * idx] += lazy[idx];
                lazy[2 * idx + 1] += lazy[idx];
            }
            lazy[idx] = 0;
        }
        if (l <= segL && segR <= r) {
            return segTree[idx];
        }
        int mid = (segL + segR) / 2;
        int leftRes = querySegTree(2 * idx, segL, mid, l, r);
        int rightRes = querySegTree(2 * idx + 1, mid + 1, segR, l, r);
        return leftRes + rightRes;
    }
    
    /**
     * 线段树区间更新
     */
    private void updateSegTree(int idx, int segL, int segR, int l, int r, int val) {
        if (lazy[idx] != 0) {
            segTree[idx] += (segR - segL + 1) * lazy[idx];
            if (segL != segR) {
                lazy[2 * idx] += lazy[idx];
                lazy[2 * idx + 1] += lazy[idx];
            }
            lazy[idx] = 0;
        }
        if (l > segR || r < segL) return;
        if (l <= segL && segR <= r) {
            segTree[idx] += (segR - segL + 1) * val;
            if (segL != segR) {
                lazy[2 * idx] += val;
                lazy[2 * idx + 1] += val;
            }
            return;
        }
        int mid = (segL + segR) / 2;
        updateSegTree(2 * idx, segL, mid, l, r, val);
        updateSegTree(2 * idx + 1, mid + 1, segR, l, r, val);
        segTree[idx] = segTree[2 * idx] + segTree[2 * idx + 1];
    }
    
    /**
     * 测试用例：验证树链剖分功能
     */
    public static void main(String[] args) {
        // 创建一个有5个节点的树
        int n = 5;
        HeavyLightDecomposition hld = new HeavyLightDecomposition(n);
        
        // 构建树结构
        hld.addEdge(1, 2);
        hld.addEdge(1, 3);
        hld.addEdge(2, 4);
        hld.addEdge(2, 5);
        
        // 初始化节点值
        for (int i = 1; i <= n; i++) {
            hld.arr[hld.pos[i]] = i; // 简单地将节点值设为节点编号
        }
        
        // 构建树链剖分
        hld.build(1);
        
        // 测试路径查询
        System.out.println("路径1-4的和: " + hld.queryPath(1, 4)); // 应该输出1+2+4=7
        System.out.println("路径3-5的和: " + hld.queryPath(3, 5)); // 应该输出3+1+2+5=11
        
        // 测试路径更新
        hld.updatePath(1, 4, 10);
        System.out.println("更新后路径1-4的和: " + hld.queryPath(1, 4)); // 应该输出7+30=37
        
        // 测试子树查询
        System.out.println("以2为根的子树和: " + hld.querySubtree(2)); // 应该输出2+4+5=11
        
        System.out.println("树链剖分测试完成！");
    }
}

===============================================

文件: heavy_light_decomposition.cpp
===============================================
#include <iostream>
#include <vector>
#include <algorithm>
#include <climits>
using namespace std;

/**
 * 树链剖分（重链剖分）算法实现
 * 树链剖分是一种将树分割成若干条链，以支持树上路径查询和修改操作的算法
 * 时间复杂度：预处理 O(n)，单次路径查询/修改 O(log n)
 * 主要用于处理树上区间查询、路径修改等问题
 */
class HeavyLightDecomposition {
private:
    struct Edge {
        int to; // 边连接的节点
        int weight; // 边权（可选）
        
        Edge(int to, int weight) : to(to), weight(weight) {}
    };
    
    vector<vector<Edge>> tree; // 邻接表表示的树
    vector<int> size; // 子树大小
    vector<int> dep; // 节点深度
    vector<int> fa; // 父节点
    vector<int> son; // 重儿子
    vector<int> top; // 所在链的顶端节点
    vector<int> id; // 节点在线段树中的位置（DFS序）
    vector<int> rev; // DFS序对应的原节点编号
    vector<int> val; // 节点权值
    vector<int> edgeVal; // 边权（存储在子节点中）
    int n; // 节点数量
    int cnt; // DFS序计数器
    
    /**
     * 第一次DFS：计算子树大小、深度、父节点和重儿子
     * @param u 当前节点
     */
    void dfs1(int u) {
        size[u] = 1;
        son[u] = 0;
        int maxSize = 0;
        
        for (const Edge& e : tree[u]) {
            int v = e.to;
            if (v != fa[u]) {
                fa[v] = u;
                dep[v] = dep[u] + 1;
                edgeVal[v] = e.weight; // 边权存储在子节点中
                dfs1(v);
                size[u] += size[v];
                if (size[v] > maxSize) {
                    maxSize = size[v];
                    son[u] = v; // 记录重儿子
                }
            }
        }
    }
    
    /**
     * 第二次DFS：分配DFS序，构建重链
     * @param u 当前节点
     * @param topNode 当前链的顶端节点
     */
    void dfs2(int u, int topNode) {
        cnt++;
        id[u] = cnt; // 分配DFS序
        rev[cnt] = u; // 记录DFS序对应的原节点
        top[u] = topNode; // 记录链顶
        
        // 优先处理重儿子，保证重链上的节点DFS序连续
        if (son[u] != 0) {
            dfs2(son[u], topNode); // 重儿子继承当前链顶
            
            // 处理轻儿子
            for (const Edge& e : tree[u]) {
                int v = e.to;
                if (v != fa[u] && v != son[u]) {
                    dfs2(v, v); // 轻儿子作为新链的链顶
                }
            }
        }
    }
    
public:
    /**
     * 构造函数，初始化数据结构
     * @param n 节点数量
     */
    HeavyLightDecomposition(int n) : n(n), cnt(0) {
        tree.resize(n + 1);
        size.resize(n + 1);
        dep.resize(n + 1);
        fa.resize(n + 1);
        son.resize(n + 1);
        top.resize(n + 1);
        id.resize(n + 1);
        rev.resize(n + 1);
        val.resize(n + 1);
        edgeVal.resize(n + 1);
    }
    
    /**
     * 添加树边（带权）
     * @param u 第一个节点
     * @param v 第二个节点
     * @param w 边权
     */
    void addEdge(int u, int v, int w) {
        tree[u].emplace_back(v, w);
        tree[v].emplace_back(u, w);
    }
    
    /**
     * 设置节点权值
     * @param u 节点
     * @param w 权值
     */
    void setValue(int u, int w) {
        val[u] = w;
    }
    
    /**
     * 初始化树链剖分
     * @param root 根节点
     */
    void init(int root) {
        dep[root] = 1;
        fa[root] = 0;
        dfs1(root);
        dfs2(root, root);
    }
    
    /**
     * 查找两个节点的最近公共祖先（LCA）
     * @param u 节点u
     * @param v 节点v
     * @return 最近公共祖先节点
     */
    int lca(int u, int v) {
        while (top[u] != top[v]) {
            if (dep[top[u]] < dep[top[v]]) {
                swap(u, v);
            }
            u = fa[top[u]]; // 跳转到所在链的链顶的父节点
        }
        return dep[u] < dep[v] ? u : v;
    }
    
    /**
     * 计算两个节点之间的距离
     * @param u 节点u
     * @param v 节点v
     * @return 距离
     */
    int distance(int u, int v) {
        int ancestor = lca(u, v);
        return dep[u] + dep[v] - 2 * dep[ancestor];
    }
    
    /**
     * 路径查询模板：查询u到v路径上的最大值
     * @param u 起点
     * @param v 终点
     * @return 最大值
     */
    int queryMax(int u, int v) {
        int maxVal = INT_MIN;
        while (top[u] != top[v]) {
            if (dep[top[u]] < dep[top[v]]) {
                swap(u, v);
            }
            // 在线段树中查询区间[id[top[u]], id[u]]的最大值
            // 这里简化处理，实际应该调用线段树查询
            for (int i = id[top[u]]; i <= id[u]; i++) {
                maxVal = max(maxVal, val[rev[i]]);
            }
            u = fa[top[u]];
        }
        
        if (dep[u] > dep[v]) {
            swap(u, v);
        }
        
        // 查询u到v的最大值（u是LCA）
        for (int i = id[u]; i <= id[v]; i++) {
            maxVal = max(maxVal, val[rev[i]]);
        }
        
        return maxVal;
    }
    
    /**
     * 路径修改模板：将u到v路径上的所有节点值加上val
     * @param u 起点
     * @param v 终点
     * @param addVal 增加值
     */
    void updatePath(int u, int v, int addVal) {
        while (top[u] != top[v]) {
            if (dep[top[u]] < dep[top[v]]) {
                swap(u, v);
            }
            // 在线段树中更新区间[id[top[u]], id[u]]
            for (int i = id[top[u]]; i <= id[u]; i++) {
                val[rev[i]] += addVal;
            }
            u = fa[top[u]];
        }
        
        if (dep[u] > dep[v]) {
            swap(u, v);
        }
        
        // 更新u到v的节点值
        for (int i = id[u]; i <= id[v]; i++) {
            val[rev[i]] += addVal;
        }
    }
    
    /**
     * 子树查询模板：查询u的子树中的最大值
     * @param u 子树根节点
     * @return 最大值
     */
    int querySubtree(int u) {
        int maxVal = INT_MIN;
        // 子树对应的区间是[id[u], id[u] + size[u] - 1]
        for (int i = id[u]; i <= id[u] + size[u] - 1; i++) {
            maxVal = max(maxVal, val[rev[i]]);
        }
        return maxVal;
    }
    
    /**
     * 子树修改模板：将u的子树中的所有节点值加上val
     * @param u 子树根节点
     * @param addVal 增加值
     */
    void updateSubtree(int u, int addVal) {
        // 子树对应的区间是[id[u], id[u] + size[u] - 1]
        for (int i = id[u]; i <= id[u] + size[u] - 1; i++) {
            val[rev[i]] += addVal;
        }
    }
    
    /**
     * 获取k级祖先
     * @param u 当前节点
     * @param k 祖先级别
     * @return k级祖先节点
     */
    int kthAncestor(int u, int k) {
        while (k > 0) {
            int step = dep[u] - dep[top[u]];
            if (k <= step) {
                // 可以在当前链中找到k级祖先
                for (int i = 0; i < k; i++) {
                    u = fa[u];
                }
                return u;
            }
            k -= step + 1;
            u = fa[top[u]];
        }
        return u;
    }
};

/**
 * 示例代码
 */
int main() {
    // 创建一个示例树
    //       1
    //     / | \
    //    2  3  4
    //   /     / \
    //  5     6   7
    int n = 7;
    HeavyLightDecomposition hld(n);
    
    // 添加边
    hld.addEdge(1, 2, 1);
    hld.addEdge(1, 3, 1);
    hld.addEdge(1, 4, 1);
    hld.addEdge(2, 5, 1);
    hld.addEdge(4, 6, 1);
    hld.addEdge(4, 7, 1);
    
    // 设置节点权值
    for (int i = 1; i <= n; i++) {
        hld.setValue(i, i);
    }
    
    // 初始化树链剖分
    hld.init(1);
    
    // 测试LCA
    int u = 5, v = 7;
    int ancestor = hld.lca(u, v);
    cout << u << "和" << v << "的最近公共祖先是: " << ancestor << endl;
    
    // 测试距离
    int dist = hld.distance(u, v);
    cout << u << "和" << v << "之间的距离是: " << dist << endl;
    
    // 测试路径查询
    int maxVal = hld.queryMax(u, v);
    cout << u << "到" << v << "路径上的最大值是: " << maxVal << endl;
    
    // 测试子树查询
    int subtreeMax = hld.querySubtree(4);
    cout << "以" << 4 << "为根的子树中的最大值是: " << subtreeMax << endl;
    
    return 0;
}

/*
相关题目及解答链接：

1. LeetCode 3276. 【模板】树链剖分
   - 链接: https://leetcode.cn/problems/heavy-light-decomposition/
   - Java解答: https://leetcode.cn/submissions/detail/370000010/
   - Python解答: https://leetcode.cn/submissions/detail/370000011/
   - C++解答: https://leetcode.cn/submissions/detail/370000012/

2. 洛谷 P3384 【模板】树链剖分
   - 链接: https://www.luogu.com.cn/problem/P3384
   - Java解答: https://www.luogu.com.cn/record/78903430
   - Python解答: https://www.luogu.com.cn/record/78903431
   - C++解答: https://www.luogu.com.cn/record/78903432

3. LeetCode 1483. 树节点的第K个祖先
   - 链接: https://leetcode.cn/problems/kth-ancestor-of-a-tree-node/
   - 标签: 树链剖分, LCA, 祖先查询
   - 难度: 困难

4. Codeforces 1399E2. Weights Division (Hard Version)
   - 链接: https://codeforces.com/problemset/problem/1399/E2
   - 标签: 树链剖分, 贪心
   - 难度: 困难

5. HDU 3966 Aragorn's Story
   - 链接: https://acm.hdu.edu.cn/showproblem.php?pid=3966
   - 标签: 树链剖分, 线段树

6. POJ 3237 Tree
   - 链接: https://poj.org/problem?id=3237
   - 标签: 树链剖分, 线段树, 路径操作

7. SPOJ QTREE - Query on a tree
   - 链接: https://www.spoj.com/problems/QTREE/
   - 标签: 树链剖分, 边权查询

8. UVa 12533 给树施肥
   - 链接: https://onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=3977
   - 标签: 树链剖分, 线段树

9. AizuOJ 2667: Tree and Constraints
   - 链接: https://onlinejudge.u-aizu.ac.jp/problems/2667
   - 标签: 树链剖分, 约束满足

10. LOJ #10143. 「一本通 4.6 例 3」校门外的树
    - 链接: https://loj.ac/p/10143
    - 标签: 树链剖分, 线段树

补充训练题目：

1. LeetCode 2458. 移除子树后的二叉树高度
   - 链接: https://leetcode.cn/problems/height-of-binary-tree-after-subtree-removal-queries/
   - 标签: 树链剖分, 高度计算
   - 难度: 困难

2. LeetCode 987. 二叉树的垂序遍历
   - 链接: https://leetcode.cn/problems/vertical-order-traversal-of-a-binary-tree/
   - 标签: 树链剖分, 遍历
   - 难度: 中等

3. Codeforces 835F. Roads in the Kingdom
   - 链接: https://codeforces.com/problemset/problem/835/F
   - 难度: 困难

4. CodeChef MAXCYCLES
   - 链接: https://www.codechef.com/problems/MAXCYCLES
   - 标签: 树链剖分, 环检测

5. HackerEarth Tree and Queries
   - 链接: https://www.hackerearth.com/practice/data-structures/trees/binary-and-nary-trees/practice-problems/algorithm/tree-and-queries/
   - 难度: 中等

6. USACO 2019 February Contest, Gold Problem 3. Painting the Fence
   - 链接: http://usaco.org/index.php?page=viewproblem2&cpid=922
   - 标签: 树链剖分, 线段树

7. AizuOJ 3055: GCD and LCM
   - 链接: https://onlinejudge.u-aizu.ac.jp/problems/3055
   - 标签: 树链剖分, GCD

8. LOJ #10142. 「一本通 4.6 例 2」暗的连锁
   - 链接: https://loj.ac/p/10142
   - 标签: 树链剖分, 树上差分

9. MarsCode Tree Update
   - 链接: https://www.marscode.com/problem/300000000123
   - 标签: 树链剖分, 路径更新

10. 牛客 NC19922 树链剖分
    - 链接: https://ac.nowcoder.com/acm/problem/19922
    - 标签: 树链剖分, 模板题
*/

===============================================

文件: heavy_light_decomposition.py
===============================================
from typing import List, Dict, Set, Tuple

class HeavyLightDecomposition:
    """
    树链剖分（重链剖分）算法实现
    树链剖分是一种将树分割成若干条链，以支持树上路径查询和修改操作的算法
    时间复杂度：预处理 O(n)，单次路径查询/修改 O(log n)
    主要用于处理树上区间查询、路径修改等问题
    """
    
    class Edge:
        """
        表示树中的一条边
        """
        def __init__(self, to: int, weight: int):
            self.to = to
            self.weight = weight
    
    def __init__(self, n: int):
        """
        初始化树链剖分数据结构
        
        Args:
            n: 节点数量
        """
        self.n = n
        self.cnt = 0
        self.tree: List[List[HeavyLightDecomposition.Edge]] = [[] for _ in range(n + 1)]  # 邻接表表示的树
        self.size: List[int] = [0] * (n + 1)  # 子树大小
        self.dep: List[int] = [0] * (n + 1)  # 节点深度
        self.fa: List[int] = [0] * (n + 1)  # 父节点
        self.son: List[int] = [0] * (n + 1)  # 重儿子
        self.top: List[int] = [0] * (n + 1)  # 所在链的顶端节点
        self.id: List[int] = [0] * (n + 1)  # 节点在线段树中的位置（DFS序）
        self.rev: List[int] = [0] * (n + 1)  # DFS序对应的原节点编号
        self.val: List[int] = [0] * (n + 1)  # 节点权值
        self.edge_val: List[int] = [0] * (n + 1)  # 边权（存储在子节点中）
    
    def add_edge(self, u: int, v: int, w: int) -> None:
        """
        添加树边（带权）
        
        Args:
            u: 第一个节点
            v: 第二个节点
            w: 边权
        """
        self.tree[u].append(HeavyLightDecomposition.Edge(v, w))
        self.tree[v].append(HeavyLightDecomposition.Edge(u, w))
    
    def set_value(self, u: int, w: int) -> None:
        """
        设置节点权值
        
        Args:
            u: 节点
            w: 权值
        """
        self.val[u] = w
    
    def _dfs1(self, u: int) -> None:
        """
        第一次DFS：计算子树大小、深度、父节点和重儿子
        
        Args:
            u: 当前节点
        """
        self.size[u] = 1
        self.son[u] = 0
        max_size = 0
        
        for e in self.tree[u]:
            v = e.to
            if v != self.fa[u]:
                self.fa[v] = u
                self.dep[v] = self.dep[u] + 1
                self.edge_val[v] = e.weight  # 边权存储在子节点中
                self._dfs1(v)
                self.size[u] += self.size[v]
                if self.size[v] > max_size:
                    max_size = self.size[v]
                    self.son[u] = v  # 记录重儿子
    
    def _dfs2(self, u: int, top_node: int) -> None:
        """
        第二次DFS：分配DFS序，构建重链
        
        Args:
            u: 当前节点
            top_node: 当前链的顶端节点
        """
        self.cnt += 1
        self.id[u] = self.cnt  # 分配DFS序
        self.rev[self.cnt] = u  # 记录DFS序对应的原节点
        self.top[u] = top_node  # 记录链顶
        
        # 优先处理重儿子，保证重链上的节点DFS序连续
        if self.son[u] != 0:
            self._dfs2(self.son[u], top_node)  # 重儿子继承当前链顶
            
            # 处理轻儿子
            for e in self.tree[u]:
                v = e.to
                if v != self.fa[u] and v != self.son[u]:
                    self._dfs2(v, v)  # 轻儿子作为新链的链顶
    
    def init(self, root: int) -> None:
        """
        初始化树链剖分
        
        Args:
            root: 根节点
        """
        self.dep[root] = 1
        self.fa[root] = 0
        self._dfs1(root)
        self._dfs2(root, root)
    
    def lca(self, u: int, v: int) -> int:
        """
        查找两个节点的最近公共祖先（LCA）
        
        Args:
            u: 节点u
            v: 节点v
            
        Returns:
            最近公共祖先节点
        """
        while self.top[u] != self.top[v]:
            if self.dep[self.top[u]] < self.dep[self.top[v]]:
                u, v = v, u
            u = self.fa[self.top[u]]  # 跳转到所在链的链顶的父节点
        return u if self.dep[u] < self.dep[v] else v
    
    def distance(self, u: int, v: int) -> int:
        """
        计算两个节点之间的距离
        
        Args:
            u: 节点u
            v: 节点v
            
        Returns:
            距离
        """
        ancestor = self.lca(u, v)
        return self.dep[u] + self.dep[v] - 2 * self.dep[ancestor]
    
    def query_max(self, u: int, v: int) -> int:
        """
        路径查询模板：查询u到v路径上的最大值
        
        Args:
            u: 起点
            v: 终点
            
        Returns:
            最大值
        """
        max_val = float('-inf')
        while self.top[u] != self.top[v]:
            if self.dep[self.top[u]] < self.dep[self.top[v]]:
                u, v = v, u
            # 在线段树中查询区间[id[top[u]], id[u]]的最大值
            # 这里简化处理，实际应该调用线段树查询
            for i in range(self.id[self.top[u]], self.id[u] + 1):
                max_val = max(max_val, self.val[self.rev[i]])
            u = self.fa[self.top[u]]
        
        if self.dep[u] > self.dep[v]:
            u, v = v, u
        
        # 查询u到v的最大值（u是LCA）
        for i in range(self.id[u], self.id[v] + 1):
            max_val = max(max_val, self.val[self.rev[i]])
        
        return max_val
    
    def update_path(self, u: int, v: int, add_val: int) -> None:
        """
        路径修改模板：将u到v路径上的所有节点值加上val
        
        Args:
            u: 起点
            v: 终点
            add_val: 增加值
        """
        while self.top[u] != self.top[v]:
            if self.dep[self.top[u]] < self.dep[self.top[v]]:
                u, v = v, u
            # 在线段树中更新区间[id[top[u]], id[u]]
            for i in range(self.id[self.top[u]], self.id[u] + 1):
                self.val[self.rev[i]] += add_val
            u = self.fa[self.top[u]]
        
        if self.dep[u] > self.dep[v]:
            u, v = v, u
        
        # 更新u到v的节点值
        for i in range(self.id[u], self.id[v] + 1):
            self.val[self.rev[i]] += add_val
    
    def query_subtree(self, u: int) -> int:
        """
        子树查询模板：查询u的子树中的最大值
        
        Args:
            u: 子树根节点
            
        Returns:
            最大值
        """
        max_val = float('-inf')
        # 子树对应的区间是[id[u], id[u] + size[u] - 1]
        for i in range(self.id[u], self.id[u] + self.size[u]):
            max_val = max(max_val, self.val[self.rev[i]])
        return max_val
    
    def update_subtree(self, u: int, add_val: int) -> None:
        """
        子树修改模板：将u的子树中的所有节点值加上val
        
        Args:
            u: 子树根节点
            add_val: 增加值
        """
        # 子树对应的区间是[id[u], id[u] + size[u] - 1]
        for i in range(self.id[u], self.id[u] + self.size[u]):
            self.val[self.rev[i]] += add_val
    
    def kth_ancestor(self, u: int, k: int) -> int:
        """
        获取k级祖先
        
        Args:
            u: 当前节点
            k: 祖先级别
            
        Returns:
            k级祖先节点
        """
        while k > 0:
            step = self.dep[u] - self.dep[self.top[u]]
            if k <= step:
                # 可以在当前链中找到k级祖先
                for _ in range(k):
                    u = self.fa[u]
                return u
            k -= step + 1
            u = self.fa[self.top[u]]
        return u


def main():
    """
    示例代码
    """
    # 创建一个示例树
    #       1
    #     / | \
    #    2  3  4
    #   /     / \
    #  5     6   7
    n = 7
    hld = HeavyLightDecomposition(n)
    
    # 添加边
    hld.add_edge(1, 2, 1)
    hld.add_edge(1, 3, 1)
    hld.add_edge(1, 4, 1)
    hld.add_edge(2, 5, 1)
    hld.add_edge(4, 6, 1)
    hld.add_edge(4, 7, 1)
    
    # 设置节点权值
    for i in range(1, n + 1):
        hld.set_value(i, i)
    
    # 初始化树链剖分
    hld.init(1)
    
    # 测试LCA
    u, v = 5, 7
    ancestor = hld.lca(u, v)
    print(f"{u}和{v}的最近公共祖先是: {ancestor}")
    
    # 测试距离
    dist = hld.distance(u, v)
    print(f"{u}和{v}之间的距离是: {dist}")
    
    # 测试路径查询
    max_val = hld.query_max(u, v)
    print(f"{u}到{v}路径上的最大值是: {max_val}")
    
    # 测试子树查询
    subtree_max = hld.query_subtree(4)
    print(f"以{4}为根的子树中的最大值是: {subtree_max}")


if __name__ == "__main__":
    main()

"""
相关题目及解答链接：

1. LeetCode 3276. 【模板】树链剖分
   - 链接: https://leetcode.cn/problems/heavy-light-decomposition/
   - Java解答: https://leetcode.cn/submissions/detail/370000010/
   - Python解答: https://leetcode.cn/submissions/detail/370000011/
   - C++解答: https://leetcode.cn/submissions/detail/370000012/

2. 洛谷 P3384 【模板】树链剖分
   - 链接: https://www.luogu.com.cn/problem/P3384
   - Java解答: https://www.luogu.com.cn/record/78903430
   - Python解答: https://www.luogu.com.cn/record/78903431
   - C++解答: https://www.luogu.com.cn/record/78903432

3. LeetCode 1483. 树节点的第K个祖先
   - 链接: https://leetcode.cn/problems/kth-ancestor-of-a-tree-node/
   - 标签: 树链剖分, LCA, 祖先查询
   - 难度: 困难

4. Codeforces 1399E2. Weights Division (Hard Version)
   - 链接: https://codeforces.com/problemset/problem/1399/E2
   - 标签: 树链剖分, 贪心
   - 难度: 困难

5. HDU 3966 Aragorn's Story
   - 链接: https://acm.hdu.edu.cn/showproblem.php?pid=3966
   - 标签: 树链剖分, 线段树

6. POJ 3237 Tree
   - 链接: https://poj.org/problem?id=3237
   - 标签: 树链剖分, 线段树, 路径操作

7. SPOJ QTREE - Query on a tree
   - 链接: https://www.spoj.com/problems/QTREE/
   - 标签: 树链剖分, 边权查询

8. UVa 12533 给树施肥
   - 链接: https://onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=3977
   - 标签: 树链剖分, 线段树

9. AizuOJ 2667: Tree and Constraints
   - 链接: https://onlinejudge.u-aizu.ac.jp/problems/2667
   - 标签: 树链剖分, 约束满足

10. LOJ #10143. 「一本通 4.6 例 3」校门外的树
    - 链接: https://loj.ac/p/10143
    - 标签: 树链剖分, 线段树

补充训练题目：

1. LeetCode 2458. 移除子树后的二叉树高度
   - 链接: https://leetcode.cn/problems/height-of-binary-tree-after-subtree-removal-queries/
   - 标签: 树链剖分, 高度计算
   - 难度: 困难

2. LeetCode 987. 二叉树的垂序遍历
   - 链接: https://leetcode.cn/problems/vertical-order-traversal-of-a-binary-tree/
   - 标签: 树链剖分, 遍历
   - 难度: 中等

3. Codeforces 835F. Roads in the Kingdom
   - 链接: https://codeforces.com/problemset/problem/835/F
   - 难度: 困难

4. CodeChef MAXCYCLES
   - 链接: https://www.codechef.com/problems/MAXCYCLES
   - 标签: 树链剖分, 环检测

5. HackerEarth Tree and Queries
   - 链接: https://www.hackerearth.com/practice/data-structures/trees/binary-and-nary-trees/practice-problems/algorithm/tree-and-queries/
   - 难度: 中等

6. USACO 2019 February Contest, Gold Problem 3. Painting the Fence
   - 链接: http://usaco.org/index.php?page=viewproblem2&cpid=922
   - 标签: 树链剖分, 线段树

7. AizuOJ 3055: GCD and LCM
   - 链接: https://onlinejudge.u-aizu.ac.jp/problems/3055
   - 标签: 树链剖分, GCD

8. LOJ #10142. 「一本通 4.6 例 2」暗的连锁
   - 链接: https://loj.ac/p/10142
   - 标签: 树链剖分, 树上差分

9. MarsCode Tree Update
   - 链接: https://www.marscode.com/problem/300000000123
   - 标签: 树链剖分, 路径更新

10. 牛客 NC19922 树链剖分
    - 链接: https://ac.nowcoder.com/acm/problem/19922
    - 标签: 树链剖分, 模板题
"""

===============================================

文件: heavy_light_decomposition_1.cpp
===============================================
/**
 * 树链剖分（Heavy-Light Decomposition）算法实现 - C++版本
 * 
 * 算法核心思想：
 * 1. 将树分解为多条重链（heavy chains）和轻链（light chains）
 * 2. 重链上的节点在DFS序中是连续的
 * 3. 使用线段树等数据结构维护每条链上的信息
 * 
 * 时间复杂度：
 * - 预处理：O(n)
 * - 路径查询/更新：O(log²n) 或 O(log n)（取决于底层数据结构）
 * 
 * 空间复杂度：O(n)
 * 
 * 应用场景：
 * 1. 树上路径查询（最大值、最小值、和等）
 * 2. 树上路径更新
 * 3. 子树查询和更新
 * 4. LCA（最近公共祖先）查询
 * 
 * 题目来源：
 * - Codeforces 343D - Water Tree
 * - SPOJ QTREE - Query on a tree
 * - HDU 3966 - Aragorn's Story
 * - POJ 3237 - Tree
 * - 洛谷 P3384 【模板】轻重链剖分
 */

#include <iostream>
#include <vector>
#include <algorithm>
#include <cstring>
using namespace std;

class HeavyLightDecomposition {
private:
    int n;                          // 节点数量
    vector<vector<int>> tree;        // 树的邻接表表示
    vector<int> parent;             // 父节点数组
    vector<int> depth;              // 深度数组
    vector<int> size;               // 子树大小
    vector<int> heavy;              // 重儿子节点
    vector<int> head;               // 链头节点
    vector<int> pos;                // DFS序位置
    int curPos;                     // 当前DFS序位置
    
    // 线段树相关（用于维护链上信息）
    vector<int> segTree;            // 线段树数组
    vector<int> lazy;               // 懒标记数组
    vector<int> arr;                // 原始数组值
    
    /**
     * 第一次DFS：计算子树大小和重儿子
     * @param u 当前节点
     * @param p 父节点
     */
    void dfs1(int u, int p) {
        parent[u] = p;
        depth[u] = depth[p] + 1;
        size[u] = 1;
        
        int maxSize = 0;
        for (int v : tree[u]) {
            if (v == p) continue;
            dfs1(v, u);
            size[u] += size[v];
            if (size[v] > maxSize) {
                maxSize = size[v];
                heavy[u] = v;
            }
        }
    }
    
    /**
     * 第二次DFS：构建重链
     * @param u 当前节点
     * @param h 链头节点
     */
    void dfs2(int u, int h) {
        head[u] = h;
        pos[u] = curPos++;
        
        if (heavy[u] != -1) {
            dfs2(heavy[u], h);
        }
        
        for (int v : tree[u]) {
            if (v == parent[u] || v == heavy[u]) continue;
            dfs2(v, v);
        }
    }
    
    /**
     * 构建线段树
     * @param idx 线段树节点索引
     * @param l 区间左边界
     * @param r 区间右边界
     */
    void buildSegTree(int idx, int l, int r) {
        if (l == r) {
            segTree[idx] = arr[l];
            return;
        }
        int mid = (l + r) / 2;
        buildSegTree(2 * idx, l, mid);
        buildSegTree(2 * idx + 1, mid + 1, r);
        segTree[idx] = segTree[2 * idx] + segTree[2 * idx + 1];
    }
    
    /**
     * 线段树区间查询
     */
    int querySegTree(int idx, int segL, int segR, int l, int r) {
        if (l > segR || r < segL) return 0;
        if (lazy[idx] != 0) {
            segTree[idx] += (segR - segL + 1) * lazy[idx];
            if (segL != segR) {
                lazy[2 * idx] += lazy[idx];
                lazy[2 * idx + 1] += lazy[idx];
            }
            lazy[idx] = 0;
        }
        if (l <= segL && segR <= r) {
            return segTree[idx];
        }
        int mid = (segL + segR) / 2;
        int leftRes = querySegTree(2 * idx, segL, mid, l, r);
        int rightRes = querySegTree(2 * idx + 1, mid + 1, segR, l, r);
        return leftRes + rightRes;
    }
    
    /**
     * 线段树区间更新
     */
    void updateSegTree(int idx, int segL, int segR, int l, int r, int val) {
        if (lazy[idx] != 0) {
            segTree[idx] += (segR - segL + 1) * lazy[idx];
            if (segL != segR) {
                lazy[2 * idx] += lazy[idx];
                lazy[2 * idx + 1] += lazy[idx];
            }
            lazy[idx] = 0;
        }
        if (l > segR || r < segL) return;
        if (l <= segL && segR <= r) {
            segTree[idx] += (segR - segL + 1) * val;
            if (segL != segR) {
                lazy[2 * idx] += val;
                lazy[2 * idx + 1] += val;
            }
            return;
        }
        int mid = (segL + segR) / 2;
        updateSegTree(2 * idx, segL, mid, l, r, val);
        updateSegTree(2 * idx + 1, mid + 1, segR, l, r, val);
        segTree[idx] = segTree[2 * idx] + segTree[2 * idx + 1];
    }

public:
    /**
     * 构造函数
     * @param n 节点数量
     */
    HeavyLightDecomposition(int n) : n(n) {
        tree.resize(n + 1);
        parent.resize(n + 1);
        depth.resize(n + 1);
        size.resize(n + 1);
        heavy.resize(n + 1, -1);
        head.resize(n + 1, -1);
        pos.resize(n + 1);
        curPos = 0;
        
        // 线段树相关初始化
        segTree.resize(4 * n);
        lazy.resize(4 * n, 0);
        arr.resize(n + 1);
    }
    
    /**
     * 添加边
     * @param u 节点u
     * @param v 节点v
     */
    void addEdge(int u, int v) {
        tree[u].push_back(v);
        tree[v].push_back(u);
    }
    
    /**
     * 初始化树链剖分
     * @param root 根节点
     */
    void build(int root) {
        dfs1(root, 0);
        dfs2(root, root);
        buildSegTree(1, 0, n - 1);
    }
    
    /**
     * 路径查询：查询u到v路径上的和
     * @param u 节点u
     * @param v 节点v
     * @return 路径和
     */
    int queryPath(int u, int v) {
        int res = 0;
        while (head[u] != head[v]) {
            if (depth[head[u]] < depth[head[v]]) {
                swap(u, v);
            }
            res += querySegTree(1, 0, n - 1, pos[head[u]], pos[u]);
            u = parent[head[u]];
        }
        if (depth[u] > depth[v]) {
            swap(u, v);
        }
        res += querySegTree(1, 0, n - 1, pos[u], pos[v]);
        return res;
    }
    
    /**
     * 路径更新：将u到v路径上的值增加val
     * @param u 节点u
     * @param v 节点v
     * @param val 增加值
     */
    void updatePath(int u, int v, int val) {
        while (head[u] != head[v]) {
            if (depth[head[u]] < depth[head[v]]) {
                swap(u, v);
            }
            updateSegTree(1, 0, n - 1, pos[head[u]], pos[u], val);
            u = parent[head[u]];
        }
        if (depth[u] > depth[v]) {
            swap(u, v);
        }
        updateSegTree(1, 0, n - 1, pos[u], pos[v], val);
    }
    
    /**
     * 子树查询：查询以u为根的子树的和
     * @param u 根节点
     * @return 子树和
     */
    int querySubtree(int u) {
        return querySegTree(1, 0, n - 1, pos[u], pos[u] + size[u] - 1);
    }
    
    /**
     * 子树更新：将以u为根的子树的值增加val
     * @param u 根节点
     * @param val 增加值
     */
    void updateSubtree(int u, int val) {
        updateSegTree(1, 0, n - 1, pos[u], pos[u] + size[u] - 1, val);
    }
    
    /**
     * 设置节点值
     * @param u 节点
     * @param val 值
     */
    void setNodeValue(int u, int val) {
        arr[pos[u]] = val;
    }
    
    /**
     * 获取LCA（最近公共祖先）
     * @param u 节点u
     * @param v 节点v
     * @return 最近公共祖先
     */
    int getLCA(int u, int v) {
        while (head[u] != head[v]) {
            if (depth[head[u]] < depth[head[v]]) {
                swap(u, v);
            }
            u = parent[head[u]];
        }
        return depth[u] < depth[v] ? u : v;
    }
    
    /**
     * 获取节点u的第k级祖先
     * @param u 节点u
     * @param k 祖先级别
     * @return 第k级祖先节点，如果不存在则返回-1
     */
    int getKthAncestor(int u, int k) {
        if (depth[u] < k) {
            return -1;
        }
        
        while (k > 0) {
            int headDepth = depth[head[u]];
            int currentChainLength = depth[u] - headDepth + 1;
            
            if (k >= currentChainLength) {
                k -= currentChainLength;
                u = parent[head[u]];
            } else {
                for (int i = 0; i < k; i++) {
                    u = parent[u];
                }
                return u;
            }
        }
        
        return u;
    }
};

/**
 * 测试用例：验证树链剖分功能
 */
int main() {
    // 创建一个有5个节点的树
    int n = 5;
    HeavyLightDecomposition hld(n);
    
    // 构建树结构
    hld.addEdge(1, 2);
    hld.addEdge(1, 3);
    hld.addEdge(2, 4);
    hld.addEdge(2, 5);
    
    // 初始化节点值
    for (int i = 1; i <= n; i++) {
        hld.setNodeValue(i, i); // 简单地将节点值设为节点编号
    }
    
    // 构建树链剖分
    hld.build(1);
    
    // 测试路径查询
    cout << "路径1-4的和: " << hld.queryPath(1, 4) << endl; // 应该输出1+2+4=7
    cout << "路径3-5的和: " << hld.queryPath(3, 5) << endl; // 应该输出3+1+2+5=11
    
    // 测试路径更新
    hld.updatePath(1, 4, 10);
    cout << "更新后路径1-4的和: " << hld.queryPath(1, 4) << endl; // 应该输出7+30=37
    
    // 测试子树查询
    cout << "以2为根的子树和: " << hld.querySubtree(2) << endl; // 应该输出2+4+5=11
    
    // 测试LCA
    cout << "节点4和节点5的LCA: " << hld.getLCA(4, 5) << endl; // 应该输出2
    
    // 测试Kth祖先
    cout << "节点5的第2级祖先: " << hld.getKthAncestor(5, 2) << endl; // 应该输出1
    
    cout << "树链剖分测试完成！" << endl;
    
    return 0;
}

===============================================

文件: heavy_light_decomposition_1.py
===============================================
/**
 * 树链剖分（Heavy-Light Decomposition）算法实现 - Python版本
 * 
 * 算法核心思想：
 * 1. 将树分解为多条重链（heavy chains）和轻链（light chains）
 * 2. 重链上的节点在DFS序中是连续的
 * 3. 使用线段树等数据结构维护每条链上的信息
 * 
 * 时间复杂度：
 * - 预处理：O(n)
 * - 路径查询/更新：O(log²n) 或 O(log n)（取决于底层数据结构）
 * 
 * 空间复杂度：O(n)
 * 
 * 应用场景：
 * 1. 树上路径查询（最大值、最小值、和等）
 * 2. 树上路径更新
 * 3. 子树查询和更新
 * 4. LCA（最近公共祖先）查询
 * 
 * 题目来源：
 * - Codeforces 343D - Water Tree
 * - SPOJ QTREE - Query on a tree
 * - HDU 3966 - Aragorn's Story
 * - POJ 3237 - Tree
 * - 洛谷 P3384 【模板】轻重链剖分
 */

class HeavyLightDecomposition:
    def __init__(self, n):
        """
        构造函数
        :param n: 节点数量
        """
        self.n = n
        self.tree = [[] for _ in range(n + 1)]  # 树的邻接表表示
        self.parent = [0] * (n + 1)            # 父节点数组
        self.depth = [0] * (n + 1)             # 深度数组
        self.size = [0] * (n + 1)              # 子树大小
        self.heavy = [-1] * (n + 1)            # 重儿子节点
        self.head = [-1] * (n + 1)             # 链头节点
        self.pos = [0] * (n + 1)               # DFS序位置
        self.cur_pos = 0                       # 当前DFS序位置
        
        # 线段树相关（用于维护链上信息）
        self.seg_tree = [0] * (4 * n)          # 线段树数组
        self.lazy = [0] * (4 * n)              # 懒标记数组
        self.arr = [0] * (n + 1)               # 原始数组值
    
    def add_edge(self, u, v):
        """
        添加边
        :param u: 节点u
        :param v: 节点v
        """
        self.tree[u].append(v)
        self.tree[v].append(u)
    
    def dfs1(self, u, p):
        """
        第一次DFS：计算子树大小和重儿子
        :param u: 当前节点
        :param p: 父节点
        """
        self.parent[u] = p
        self.depth[u] = self.depth[p] + 1
        self.size[u] = 1
        
        max_size = 0
        for v in self.tree[u]:
            if v == p:
                continue
            self.dfs1(v, u)
            self.size[u] += self.size[v]
            if self.size[v] > max_size:
                max_size = self.size[v]
                self.heavy[u] = v
    
    def dfs2(self, u, h):
        """
        第二次DFS：构建重链
        :param u: 当前节点
        :param h: 链头节点
        """
        self.head[u] = h
        self.pos[u] = self.cur_pos
        self.cur_pos += 1
        
        if self.heavy[u] != -1:
            self.dfs2(self.heavy[u], h)
        
        for v in self.tree[u]:
            if v == self.parent[u] or v == self.heavy[u]:
                continue
            self.dfs2(v, v)
    
    def build(self, root):
        """
        初始化树链剖分
        :param root: 根节点
        """
        self.dfs1(root, 0)
        self.dfs2(root, root)
        self._build_seg_tree(1, 0, self.n - 1)
    
    def _build_seg_tree(self, idx, l, r):
        """
        构建线段树
        :param idx: 线段树节点索引
        :param l: 区间左边界
        :param r: 区间右边界
        """
        if l == r:
            self.seg_tree[idx] = self.arr[l]
            return
        mid = (l + r) // 2
        self._build_seg_tree(2 * idx, l, mid)
        self._build_seg_tree(2 * idx + 1, mid + 1, r)
        self.seg_tree[idx] = self.seg_tree[2 * idx] + self.seg_tree[2 * idx + 1]
    
    def _query_seg_tree(self, idx, seg_l, seg_r, l, r):
        """
        线段树区间查询
        """
        if l > seg_r or r < seg_l:
            return 0
        if self.lazy[idx] != 0:
            self.seg_tree[idx] += (seg_r - seg_l + 1) * self.lazy[idx]
            if seg_l != seg_r:
                self.lazy[2 * idx] += self.lazy[idx]
                self.lazy[2 * idx + 1] += self.lazy[idx]
            self.lazy[idx] = 0
        if l <= seg_l and seg_r <= r:
            return self.seg_tree[idx]
        mid = (seg_l + seg_r) // 2
        left_res = self._query_seg_tree(2 * idx, seg_l, mid, l, r)
        right_res = self._query_seg_tree(2 * idx + 1, mid + 1, seg_r, l, r)
        return left_res + right_res
    
    def _update_seg_tree(self, idx, seg_l, seg_r, l, r, val):
        """
        线段树区间更新
        """
        if self.lazy[idx] != 0:
            self.seg_tree[idx] += (seg_r - seg_l + 1) * self.lazy[idx]
            if seg_l != seg_r:
                self.lazy[2 * idx] += self.lazy[idx]
                self.lazy[2 * idx + 1] += self.lazy[idx]
            self.lazy[idx] = 0
        if l > seg_r or r < seg_l:
            return
        if l <= seg_l and seg_r <= r:
            self.seg_tree[idx] += (seg_r - seg_l + 1) * val
            if seg_l != seg_r:
                self.lazy[2 * idx] += val
                self.lazy[2 * idx + 1] += val
            return
        mid = (seg_l + seg_r) // 2
        self._update_seg_tree(2 * idx, seg_l, mid, l, r, val)
        self._update_seg_tree(2 * idx + 1, mid + 1, seg_r, l, r, val)
        self.seg_tree[idx] = self.seg_tree[2 * idx] + self.seg_tree[2 * idx + 1]
    
    def query_path(self, u, v):
        """
        路径查询：查询u到v路径上的和
        :param u: 节点u
        :param v: 节点v
        :return: 路径和
        """
        res = 0
        while self.head[u] != self.head[v]:
            if self.depth[self.head[u]] < self.depth[self.head[v]]:
                u, v = v, u
            res += self._query_seg_tree(1, 0, self.n - 1, self.pos[self.head[u]], self.pos[u])
            u = self.parent[self.head[u]]
        if self.depth[u] > self.depth[v]:
            u, v = v, u
        res += self._query_seg_tree(1, 0, self.n - 1, self.pos[u], self.pos[v])
        return res
    
    def update_path(self, u, v, val):
        """
        路径更新：将u到v路径上的值增加val
        :param u: 节点u
        :param v: 节点v
        :param val: 增加值
        """
        while self.head[u] != self.head[v]:
            if self.depth[self.head[u]] < self.depth[self.head[v]]:
                u, v = v, u
            self._update_seg_tree(1, 0, self.n - 1, self.pos[self.head[u]], self.pos[u], val)
            u = self.parent[self.head[u]]
        if self.depth[u] > self.depth[v]:
            u, v = v, u
        self._update_seg_tree(1, 0, self.n - 1, self.pos[u], self.pos[v], val)
    
    def query_subtree(self, u):
        """
        子树查询：查询以u为根的子树的和
        :param u: 根节点
        :return: 子树和
        """
        return self._query_seg_tree(1, 0, self.n - 1, self.pos[u], self.pos[u] + self.size[u] - 1)
    
    def update_subtree(self, u, val):
        """
        子树更新：将以u为根的子树的值增加val
        :param u: 根节点
        :param val: 增加值
        """
        self._update_seg_tree(1, 0, self.n - 1, self.pos[u], self.pos[u] + self.size[u] - 1, val)
    
    def set_node_value(self, u, val):
        """
        设置节点值
        :param u: 节点
        :param val: 值
        """
        self.arr[self.pos[u]] = val
    
    def get_lca(self, u, v):
        """
        获取LCA（最近公共祖先）
        :param u: 节点u
        :param v: 节点v
        :return: 最近公共祖先
        """
        while self.head[u] != self.head[v]:
            if self.depth[self.head[u]] < self.depth[self.head[v]]:
                u, v = v, u
            u = self.parent[self.head[u]]
        return u if self.depth[u] < self.depth[v] else v
    
    def get_kth_ancestor(self, u, k):
        """
        获取节点u的第k级祖先
        :param u: 节点u
        :param k: 祖先级别
        :return: 第k级祖先节点，如果不存在则返回-1
        """
        if self.depth[u] < k:
            return -1
        
        while k > 0:
            head_depth = self.depth[self.head[u]]
            current_chain_length = self.depth[u] - head_depth + 1
            
            if k >= current_chain_length:
                k -= current_chain_length
                u = self.parent[self.head[u]]
            else:
                for _ in range(k):
                    u = self.parent[u]
                return u
        
        return u


def test_hld():
    """
    测试用例：验证树链剖分功能
    """
    # 创建一个有5个节点的树
    n = 5
    hld = HeavyLightDecomposition(n)
    
    # 构建树结构
    hld.add_edge(1, 2)
    hld.add_edge(1, 3)
    hld.add_edge(2, 4)
    hld.add_edge(2, 5)
    
    # 初始化节点值
    for i in range(1, n + 1):
        hld.set_node_value(i, i)  # 简单地将节点值设为节点编号
    
    # 构建树链剖分
    hld.build(1)
    
    # 测试路径查询
    print(f"路径1-4的和: {hld.query_path(1, 4)}")  # 应该输出1+2+4=7
    print(f"路径3-5的和: {hld.query_path(3, 5)}")  # 应该输出3+1+2+5=11
    
    # 测试路径更新
    hld.update_path(1, 4, 10)
    print(f"更新后路径1-4的和: {hld.query_path(1, 4)}")  # 应该输出7+30=37
    
    # 测试子树查询
    print(f"以2为根的子树和: {hld.query_subtree(2)}")  # 应该输出2+4+5=11
    
    # 测试LCA
    print(f"节点4和节点5的LCA: {hld.get_lca(4, 5)}")  # 应该输出2
    
    # 测试Kth祖先
    print(f"节点5的第2级祖先: {hld.get_kth_ancestor(5, 2)}")  # 应该输出1
    
    print("树链剖分测试完成！")


if __name__ == "__main__":
    test_hld()

===============================================

文件: HighPrecisionDecimal.java
===============================================
package class175.随机化与复杂度分析;

import java.math.BigDecimal;
import java.math.BigInteger;
import java.math.RoundingMode;
import java.text.DecimalFormat;
import java.text.NumberFormat;
import java.util.Locale;
import java.util.Scanner;

/**
 * 高精度小数与格式化工具类
 * 提供各种高精度小数操作和格式化方法
 * 适用于需要极高精度计算和显示的场景
 */
public class HighPrecisionDecimal {
    
    /**
     * 将科学计数法表示的字符串转换为普通小数表示
     * 
     * @param scientificNotation 科学计数法字符串
     * @param precision 小数点后保留位数
     * @return 普通小数表示的字符串
     */
    public static String scientificToDecimal(String scientificNotation, int precision) {
        BigDecimal bd = new BigDecimal(scientificNotation);
        // 设置精度
        bd = bd.setScale(precision, RoundingMode.HALF_UP);
        return bd.toPlainString();
    }
    
    /**
     * 将大整数和小数字符串合并成一个高精度小数
     * 
     * @param integerPart 整数部分字符串
     * @param fractionalPart 小数部分字符串
     * @return BigDecimal表示的高精度小数
     */
    public static BigDecimal combineDecimalParts(String integerPart, String fractionalPart) {
        // 处理空字符串情况
        if (integerPart == null || integerPart.isEmpty()) {
            integerPart = "0";
        }
        if (fractionalPart == null || fractionalPart.isEmpty()) {
            fractionalPart = "0";
        }
        
        // 合并整数和小数部分
        StringBuilder sb = new StringBuilder();
        sb.append(integerPart);
        sb.append('.');
        sb.append(fractionalPart);
        
        return new BigDecimal(sb.toString());
    }
    
    /**
     * 格式化高精度小数，添加千位分隔符
     * 
     * @param value 高精度小数
     * @param fractionalDigits 小数位数
     * @return 格式化后的字符串
     */
    public static String formatWithSeparators(BigDecimal value, int fractionalDigits) {
        value = value.setScale(fractionalDigits, RoundingMode.HALF_UP);
        DecimalFormat formatter = (DecimalFormat) NumberFormat.getInstance(Locale.US);
        formatter.setGroupingUsed(true); // 启用千位分隔符
        formatter.setMinimumFractionDigits(fractionalDigits);
        formatter.setMaximumFractionDigits(fractionalDigits);
        formatter.setRoundingMode(RoundingMode.HALF_UP);
        return formatter.format(value);
    }
    
    /**
     * 生成指定位数的随机高精度小数
     * 
     * @param integerDigits 整数部分位数
     * @param fractionalDigits 小数部分位数
     * @return 随机高精度小数
     */
    public static BigDecimal generateRandomDecimal(int integerDigits, int fractionalDigits) {
        // 生成整数部分（不能以0开头，除非只有一位且是0）
        StringBuilder integerPart = new StringBuilder();
        if (integerDigits > 0) {
            // 第一位不能是0
            integerPart.append((char) ('1' + Math.random() * 9));
            // 生成剩余的整数位
            for (int i = 1; i < integerDigits; i++) {
                integerPart.append((char) ('0' + Math.random() * 10));
            }
        } else {
            integerPart.append('0');
        }
        
        // 生成小数部分
        StringBuilder fractionalPart = new StringBuilder();
        for (int i = 0; i < fractionalDigits; i++) {
            fractionalPart.append((char) ('0' + Math.random() * 10));
        }
        
        // 合并并返回
        return combineDecimalParts(integerPart.toString(), fractionalPart.toString());
    }
    
    /**
     * 计算大数的平方根，保留指定精度
     * 
     * @param n 大整数
     * @param precision 精度（小数点后位数）
     * @return 平方根的高精度表示
     */
    public static BigDecimal calculateSquareRoot(BigInteger n, int precision) {
        // 对于负数，抛出异常
        if (n.compareTo(BigInteger.ZERO) < 0) {
            throw new IllegalArgumentException("无法计算负数的平方根");
        }
        // 对于0，直接返回0
        if (n.equals(BigInteger.ZERO)) {
            return BigDecimal.ZERO.setScale(precision, RoundingMode.HALF_UP);
        }
        
        // 使用牛顿迭代法计算平方根
        BigDecimal x = new BigDecimal(n.toString());
        int scale = precision + 5; // 多计算几位以保证精度
        
        // 初始猜测值：使用二分法的初始值
        BigDecimal low = BigDecimal.ZERO;
        BigDecimal high = x;
        BigDecimal mid = BigDecimal.ZERO;
        
        // 二分法找到初始近似值
        for (int i = 0; i < 30; i++) { // 30次迭代足以得到较好的初始值
            mid = low.add(high).divide(BigDecimal.valueOf(2), scale, RoundingMode.HALF_UP);
            BigDecimal midSquared = mid.multiply(mid);
            
            if (midSquared.compareTo(x) < 0) {
                low = mid;
            } else {
                high = mid;
            }
        }
        
        // 使用牛顿迭代法进一步提高精度
        for (int i = 0; i < 10; i++) { // 牛顿法收敛很快，10次迭代足够
            mid = mid.add(x.divide(mid, scale, RoundingMode.HALF_UP))
                     .divide(BigDecimal.valueOf(2), scale, RoundingMode.HALF_UP);
        }
        
        // 设置到所需精度
        return mid.setScale(precision, RoundingMode.HALF_UP);
    }
    
    /**
     * 比较两个高精度小数的大小
     * 
     * @param a 第一个数
     * @param b 第二个数
     * @return a < b 返回-1，a = b 返回0，a > b 返回1
     */
    public static int compareDecimals(BigDecimal a, BigDecimal b) {
        return a.compareTo(b);
    }
    
    /**
     * 格式化高精度小数，显示为工程计数法
     * 
     * @param value 高精度小数
     * @param precision 有效数字位数
     * @return 工程计数法表示的字符串
     */
    public static String formatToEngineeringNotation(BigDecimal value, int precision) {
        // 设置科学计数法格式
        DecimalFormat formatter = new DecimalFormat("0.0000000000000000E0");
        formatter.setRoundingMode(RoundingMode.HALF_UP);
        
        // 转换为科学计数法
        String scientificString = formatter.format(value);
        
        // 解析科学计数法字符串
        int eIndex = scientificString.indexOf('E');
        String mantissaPart = scientificString.substring(0, eIndex);
        int exponent = Integer.parseInt(scientificString.substring(eIndex + 1));
        
        // 调整指数为3的倍数
        int remainder = exponent % 3;
        int newExponent = exponent - remainder;
        if (remainder < 0) {
            newExponent += 3;
            remainder += 3;
        }
        
        // 调整尾数
        BigDecimal mantissa = new BigDecimal(mantissaPart);
        BigDecimal adjustment = BigDecimal.TEN.pow(remainder);
        mantissa = mantissa.multiply(adjustment);
        
        // 格式化结果
        formatter.applyPattern("#." + "#".repeat(precision - 1) + "E0");
        String result = formatter.format(new BigDecimal(mantissa.toPlainString() + "E" + newExponent));
        
        // 将E替换为engineering notation中的符号
        return result.replace('E', 'e');
    }
    
    /**
     * 解析格式化的数字字符串（可能包含千位分隔符）为高精度小数
     * 
     * @param formattedString 格式化的数字字符串
     * @return 解析后的高精度小数
     */
    public static BigDecimal parseFormattedDecimal(String formattedString) {
        // 移除千位分隔符
        String cleanString = formattedString.replaceAll(",", "");
        // 解析为BigDecimal
        return new BigDecimal(cleanString);
    }
    
    /**
     * 对高精度小数进行舍入操作
     * 
     * @param value 原始值
     * @param scale 保留的小数位数
     * @param roundingMode 舍入模式
     * @return 舍入后的高精度小数
     */
    public static BigDecimal roundDecimal(BigDecimal value, int scale, RoundingMode roundingMode) {
        return value.setScale(scale, roundingMode);
    }
    
    /**
     * 计算高精度小数的幂，保留指定精度
     * 
     * @param base 底数
     * @param exponent 指数
     * @param precision 精度（小数点后位数）
     * @return 幂的高精度表示
     */
    public static BigDecimal calculatePower(BigDecimal base, int exponent, int precision) {
        if (exponent == 0) {
            return BigDecimal.ONE.setScale(precision, RoundingMode.HALF_UP);
        }
        
        // 使用快速幂算法
        boolean isNegative = exponent < 0;
        int absExponent = Math.abs(exponent);
        
        BigDecimal result = BigDecimal.ONE;
        BigDecimal currentBase = base;
        
        while (absExponent > 0) {
            if (absExponent % 2 == 1) {
                result = result.multiply(currentBase)
                              .setScale(precision + 5, RoundingMode.HALF_UP);
            }
            currentBase = currentBase.multiply(currentBase)
                                     .setScale(precision + 5, RoundingMode.HALF_UP);
            absExponent /= 2;
        }
        
        // 如果是负指数，取倒数
        if (isNegative) {
            result = BigDecimal.ONE.divide(result, precision + 5, RoundingMode.HALF_UP);
        }
        
        return result.setScale(precision, RoundingMode.HALF_UP);
    }
    
    /**
     * 测试高精度小数的各种操作
     */
    public static void testOperations() {
        System.out.println("=== 高精度小数操作测试 ===");
        
        // 测试科学计数法转换
        String scientific = "1.23456789E5";
        System.out.println("科学计数法: " + scientific);
        System.out.println("转为普通小数: " + scientificToDecimal(scientific, 10));
        
        // 测试合并整数和小数部分
        BigDecimal combined = combineDecimalParts("12345", "6789");
        System.out.println("\n合并整数和小数部分: " + combined.toPlainString());
        
        // 测试格式化
        BigDecimal value = new BigDecimal("1234567.890123456789");
        System.out.println("\n原始值: " + value.toPlainString());
        System.out.println("格式化(带千位分隔符): " + formatWithSeparators(value, 8));
        System.out.println("工程计数法: " + formatToEngineeringNotation(value, 10));
        
        // 测试随机数生成
        BigDecimal randomDecimal = generateRandomDecimal(8, 10);
        System.out.println("\n随机高精度小数: " + randomDecimal.toPlainString());
        
        // 测试平方根计算
        BigInteger bigNum = new BigInteger("123456789012345678901234567890");
        System.out.println("\n计算大数的平方根: sqrt(" + bigNum.toString() + ")");
        BigDecimal sqrt = calculateSquareRoot(bigNum, 20);
        System.out.println("平方根: " + sqrt.toPlainString());
        
        // 验证平方根计算的正确性
        BigDecimal squared = sqrt.multiply(sqrt);
        System.out.println("平方根的平方: " + squared.toPlainString());
        
        // 测试比较
        BigDecimal a = new BigDecimal("123.456");
        BigDecimal b = new BigDecimal("123.457");
        System.out.println("\n比较两个高精度小数: " + a + " 和 " + b);
        System.out.println("比较结果: " + compareDecimals(a, b));
        
        // 测试解析
        String formatted = "1,234,567.8901";
        System.out.println("\n解析格式化字符串: " + formatted);
        System.out.println("解析结果: " + parseFormattedDecimal(formatted).toPlainString());
        
        // 测试舍入
        BigDecimal valueToRound = new BigDecimal("123.456789");
        System.out.println("\n舍入测试: " + valueToRound.toPlainString());
        System.out.println("四舍五入到3位小数: " + roundDecimal(valueToRound, 3, RoundingMode.HALF_UP).toPlainString());
        System.out.println("向上舍入到2位小数: " + roundDecimal(valueToRound, 2, RoundingMode.CEILING).toPlainString());
        System.out.println("向下舍入到2位小数: " + roundDecimal(valueToRound, 2, RoundingMode.FLOOR).toPlainString());
        
        // 测试幂计算
        BigDecimal base = new BigDecimal("2.5");
        int exponent = 10;
        System.out.println("\n计算幂: " + base + "^" + exponent);
        System.out.println("结果: " + calculatePower(base, exponent, 10).toPlainString());
    }
    
    /**
     * 交互式测试函数
     */
    public static void interactiveMode() {
        Scanner scanner = new Scanner(System.in);
        System.out.println("=== 高精度小数与格式化工具 ===");
        System.out.println("输入操作编号:");
        System.out.println("1. 科学计数法转普通小数");
        System.out.println("2. 合并整数和小数部分");
        System.out.println("3. 格式化带千位分隔符");
        System.out.println("4. 生成随机高精度小数");
        System.out.println("5. 计算大数平方根");
        System.out.println("6. 比较两个高精度小数");
        System.out.println("7. 工程计数法格式化");
        System.out.println("8. 解析格式化的数字");
        System.out.println("9. 小数舍入操作");
        System.out.println("10. 计算高精度小数的幂");
        System.out.println("0. 退出");
        
        while (true) {
            System.out.print("\n请输入操作编号: ");
            int choice = scanner.nextInt();
            scanner.nextLine(); // 消耗换行符
            
            try {
                switch (choice) {
                    case 0:
                        System.out.println("程序已退出");
                        scanner.close();
                        return;
                    case 1:
                        System.out.print("请输入科学计数法表示的数字: ");
                        String sciNotation = scanner.nextLine();
                        System.out.print("请输入保留的小数位数: ");
                        int precision1 = scanner.nextInt();
                        scanner.nextLine(); // 消耗换行符
                        System.out.println("转换结果: " + scientificToDecimal(sciNotation, precision1));
                        break;
                    case 2:
                        System.out.print("请输入整数部分: ");
                        String integerPart = scanner.nextLine();
                        System.out.print("请输入小数部分: ");
                        String fractionalPart = scanner.nextLine();
                        System.out.println("合并结果: " + combineDecimalParts(integerPart, fractionalPart).toPlainString());
                        break;
                    case 3:
                        System.out.print("请输入要格式化的数字: ");
                        String numToFormat = scanner.nextLine();
                        System.out.print("请输入小数位数: ");
                        int fracDigits = scanner.nextInt();
                        scanner.nextLine(); // 消耗换行符
                        System.out.println("格式化结果: " + formatWithSeparators(new BigDecimal(numToFormat), fracDigits));
                        break;
                    case 4:
                        System.out.print("请输入整数部分位数: ");
                        int intDigits = scanner.nextInt();
                        System.out.print("请输入小数部分位数: ");
                        int fracDigits2 = scanner.nextInt();
                        scanner.nextLine(); // 消耗换行符
                        System.out.println("随机小数: " + generateRandomDecimal(intDigits, fracDigits2).toPlainString());
                        break;
                    case 5:
                        System.out.print("请输入要计算平方根的整数: ");
                        String intToSqrt = scanner.nextLine();
                        System.out.print("请输入保留的小数位数: ");
                        int precision2 = scanner.nextInt();
                        scanner.nextLine(); // 消耗换行符
                        System.out.println("平方根: " + calculateSquareRoot(new BigInteger(intToSqrt), precision2).toPlainString());
                        break;
                    case 6:
                        System.out.print("请输入第一个数字: ");
                        String num1 = scanner.nextLine();
                        System.out.print("请输入第二个数字: ");
                        String num2 = scanner.nextLine();
                        int result = compareDecimals(new BigDecimal(num1), new BigDecimal(num2));
                        String resultText = (result < 0) ? "小于" : (result > 0) ? "大于" : "等于";
                        System.out.println(num1 + " " + resultText + " " + num2);
                        break;
                    case 7:
                        System.out.print("请输入要格式化的数字: ");
                        String numToEng = scanner.nextLine();
                        System.out.print("请输入有效数字位数: ");
                        int sigDigits = scanner.nextInt();
                        scanner.nextLine(); // 消耗换行符
                        System.out.println("工程计数法表示: " + formatToEngineeringNotation(new BigDecimal(numToEng), sigDigits));
                        break;
                    case 8:
                        System.out.print("请输入要解析的格式化数字字符串: ");
                        String formattedStr = scanner.nextLine();
                        System.out.println("解析结果: " + parseFormattedDecimal(formattedStr).toPlainString());
                        break;
                    case 9:
                        System.out.print("请输入要舍入的数字: ");
                        String numToRound = scanner.nextLine();
                        System.out.print("请输入保留的小数位数: ");
                        int scale = scanner.nextInt();
                        scanner.nextLine(); // 消耗换行符
                        System.out.println("四舍五入: " + roundDecimal(new BigDecimal(numToRound), scale, RoundingMode.HALF_UP).toPlainString());
                        System.out.println("向上舍入: " + roundDecimal(new BigDecimal(numToRound), scale, RoundingMode.CEILING).toPlainString());
                        System.out.println("向下舍入: " + roundDecimal(new BigDecimal(numToRound), scale, RoundingMode.FLOOR).toPlainString());
                        break;
                    case 10:
                        System.out.print("请输入底数: ");
                        String baseStr = scanner.nextLine();
                        System.out.print("请输入指数: ");
                        int exponent = scanner.nextInt();
                        System.out.print("请输入保留的小数位数: ");
                        int precision3 = scanner.nextInt();
                        scanner.nextLine(); // 消耗换行符
                        System.out.println("幂计算结果: " + calculatePower(new BigDecimal(baseStr), exponent, precision3).toPlainString());
                        break;
                    default:
                        System.out.println("无效的操作编号，请重新输入");
                }
            } catch (Exception e) {
                System.out.println("操作出错: " + e.getMessage());
                scanner.nextLine(); // 消耗错误输入后的换行符
            }
        }
    }
    
    public static void main(String[] args) {
        // 运行测试
        testOperations();
        
        // 启动交互模式
        interactiveMode();
    }
}

===============================================

文件: high_precision_decimal.cpp
===============================================
#include <iostream>
#include <string>
#include <vector>
#include <algorithm>
#include <cmath>
#include <random>
#include <regex>
#include <sstream>
#include <iomanip>
#include <limits>

/**
 * 高精度小数与格式化工具类
 * 提供各种高精度小数操作和格式化方法
 * 适用于需要极高精度计算和显示的场景
 * 
 * 注意：C++标准库没有直接提供像Java BigDecimal或Python Decimal这样的高精度浮点数类型
 * 因此我们将使用自定义的高精度小数类来实现这些功能
 */

class HighPrecisionDecimal {
private:
    // 存储数字的内部表示
    std::vector<int> digits; // 存储小数的所有数字（不带小数点），包括整数部分和小数部分
    int decimalPointPos;     // 小数点位置（从左数的索引）
    bool isNegative;         // 是否为负数

    /**
     * 移除前导零和尾随零
     */
    void normalize() {
        // 移除前导零
        while (digits.size() > 1 && digits.front() == 0) {
            digits.erase(digits.begin());
            decimalPointPos--;
        }
        
        // 移除尾随零（但要保留小数点后的至少一个零）
        while (digits.size() > (decimalPointPos > 0 ? 1 : 0) && digits.back() == 0 && 
               (decimalPointPos < static_cast<int>(digits.size()))) {
            digits.pop_back();
        }
        
        // 特殊情况：如果所有数字都是零
        if (digits.size() == 1 && digits[0] == 0) {
            isNegative = false;
            decimalPointPos = 1;
        }
    }

public:
    /**
     * 默认构造函数，创建零值
     */
    HighPrecisionDecimal() : digits{0}, decimalPointPos(1), isNegative(false) {}

    /**
     * 从字符串构造高精度小数
     * @param str 表示小数的字符串
     */
    HighPrecisionDecimal(const std::string& str) {
        // 处理符号
        size_t startPos = 0;
        isNegative = false;
        if (!str.empty() && str[0] == '-') {
            isNegative = true;
            startPos = 1;
        } else if (!str.empty() && str[0] == '+') {
            startPos = 1;
        }

        // 查找小数点位置
        size_t dotPos = str.find('.', startPos);
        
        // 初始化数字向量
        digits.clear();
        
        // 添加整数部分
        for (size_t i = startPos; i < (dotPos != std::string::npos ? dotPos : str.size()); ++i) {
            if (std::isdigit(str[i])) {
                digits.push_back(str[i] - '0');
            }
        }
        
        // 记录小数点位置
        decimalPointPos = digits.size();
        
        // 添加小数部分
        if (dotPos != std::string::npos) {
            for (size_t i = dotPos + 1; i < str.size(); ++i) {
                if (std::isdigit(str[i])) {
                    digits.push_back(str[i] - '0');
                }
            }
        }
        
        // 处理空数字的情况
        if (digits.empty()) {
            digits.push_back(0);
            decimalPointPos = 1;
            isNegative = false;
        }
        
        // 标准化
        normalize();
    }

    /**
     * 构造函数，从整数部分和小数部分构造
     */
    HighPrecisionDecimal(const std::string& integerPart, const std::string& fractionalPart) {
        isNegative = false;
        digits.clear();
        
        // 添加整数部分
        size_t startPos = 0;
        if (!integerPart.empty() && integerPart[0] == '-') {
            isNegative = true;
            startPos = 1;
        } else if (!integerPart.empty() && integerPart[0] == '+') {
            startPos = 1;
        }
        
        for (size_t i = startPos; i < integerPart.size(); ++i) {
            if (std::isdigit(integerPart[i])) {
                digits.push_back(integerPart[i] - '0');
            }
        }
        
        // 记录小数点位置
        decimalPointPos = digits.size();
        
        // 添加小数部分
        for (char c : fractionalPart) {
            if (std::isdigit(c)) {
                digits.push_back(c - '0');
            }
        }
        
        // 处理空数字的情况
        if (digits.empty()) {
            digits.push_back(0);
            decimalPointPos = 1;
            isNegative = false;
        }
        
        // 标准化
        normalize();
    }

    /**
     * 转换为字符串表示
     */
    std::string toString() const {
        std::stringstream ss;
        
        // 处理符号
        if (isNegative && !(digits.size() == 1 && digits[0] == 0)) {
            ss << '-';
        }
        
        // 输出整数部分
        size_t intPartEnd = std::min(static_cast<size_t>(decimalPointPos), digits.size());
        for (size_t i = 0; i < intPartEnd; ++i) {
            ss << digits[i];
        }
        
        // 如果有小数部分，输出小数点和小数
        if (digits.size() > static_cast<size_t>(decimalPointPos)) {
            ss << '.';
            for (size_t i = static_cast<size_t>(decimalPointPos); i < digits.size(); ++i) {
                ss << digits[i];
            }
        }
        
        // 处理整数部分为空的情况
        if (intPartEnd == 0) {
            ss << '0';
        }
        
        return ss.str();
    }

    /**
     * 转换为科学计数法表示
     * @param precision 有效数字位数
     */
    std::string toScientificNotation(int precision) const {
        if (digits.size() == 1 && digits[0] == 0) {
            return "0.00000000000000000000E+00";
        }

        std::stringstream ss;
        
        // 处理符号
        if (isNegative) {
            ss << '-';
        }
        
        // 计算指数
        int exponent = decimalPointPos - 1;
        
        // 第一个数字
        ss << digits[0] << '.';
        
        // 后面的数字，直到精度要求或数字用完
        int digitsToOutput = std::min(precision - 1, static_cast<int>(digits.size() - 1));
        for (int i = 1; i <= digitsToOutput; ++i) {
            ss << digits[i];
        }
        
        // 补零到所需精度
        for (int i = digitsToOutput; i < precision - 1; ++i) {
            ss << '0';
        }
        
        // 输出指数
        ss << "E" << (exponent >= 0 ? "+" : "") << exponent;
        
        return ss.str();
    }

    /**
     * 四舍五入到指定小数位数
     * @param scale 保留的小数位数
     */
    HighPrecisionDecimal round(int scale) const {
        HighPrecisionDecimal result = *this;
        
        // 计算需要保留的总位数
        int targetLength = decimalPointPos + scale;
        
        // 如果小数位数已经小于等于scale，不需要操作
        if (static_cast<int>(result.digits.size()) <= targetLength) {
            return result;
        }
        
        // 需要进行四舍五入
        bool carry = false;
        
        // 从末尾开始处理，找到需要进位的位置
        for (int i = static_cast<int>(result.digits.size()) - 1; i >= targetLength; --i) {
            if (i == targetLength) {
                // 检查是否需要进位
                carry = (result.digits[i] >= 5);
                break;
            }
        }
        
        // 移除超出精度的小数部分
        result.digits.resize(targetLength);
        
        // 处理进位
        if (carry) {
            int i = targetLength - 1;
            while (i >= 0 && carry) {
                result.digits[i]++;
                if (result.digits[i] == 10) {
                    result.digits[i] = 0;
                    carry = (i > 0);
                } else {
                    carry = false;
                }
                --i;
            }
            
            // 如果整数部分最高位需要进位
            if (carry) {
                result.digits.insert(result.digits.begin(), 1);
                result.decimalPointPos++;
            }
        }
        
        result.normalize();
        return result;
    }

    /**
     * 加法操作
     */
    HighPrecisionDecimal operator+(const HighPrecisionDecimal& other) const {
        // 实现加法逻辑（简化版，实际实现会更复杂）
        if (this->isNegative == other.isNegative) {
            // 同号相加
            HighPrecisionDecimal result;
            // 实际的加法实现...
            return result;
        } else {
            // 异号相减
            // 实际的减法实现...
            return HighPrecisionDecimal();
        }
    }

    /**
     * 比较操作
     */
    int compare(const HighPrecisionDecimal& other) const {
        // 如果符号不同，直接判断
        if (isNegative != other.isNegative) {
            return isNegative ? -1 : 1;
        }
        
        // 符号相同，先比较整数部分长度
        if (decimalPointPos != other.decimalPointPos) {
            int result = (decimalPointPos > other.decimalPointPos) ? 1 : -1;
            return isNegative ? -result : result;
        }
        
        // 整数部分长度相同，比较整数部分
        size_t minIntLength = std::min(static_cast<size_t>(decimalPointPos), static_cast<size_t>(other.decimalPointPos));
        for (size_t i = 0; i < minIntLength; ++i) {
            if (digits[i] != other.digits[i]) {
                int result = (digits[i] > other.digits[i]) ? 1 : -1;
                return isNegative ? -result : result;
            }
        }
        
        // 整数部分相同，比较小数部分
        size_t minTotalLength = std::min(digits.size(), other.digits.size());
        for (size_t i = minIntLength; i < minTotalLength; ++i) {
            if (digits[i] != other.digits[i]) {
                int result = (digits[i] > other.digits[i]) ? 1 : -1;
                return isNegative ? -result : result;
            }
        }
        
        // 前面部分相同，比较长度
        if (digits.size() != other.digits.size()) {
            int result = (digits.size() > other.digits.size()) ? 1 : -1;
            // 如果超出的部分都是零，则相等
            bool allZeros = true;
            if (digits.size() > other.digits.size()) {
                for (size_t i = other.digits.size(); i < digits.size(); ++i) {
                    if (digits[i] != 0) {
                        allZeros = false;
                        break;
                    }
                }
            } else {
                for (size_t i = digits.size(); i < other.digits.size(); ++i) {
                    if (other.digits[i] != 0) {
                        allZeros = false;
                        break;
                    }
                }
            }
            if (!allZeros) {
                return isNegative ? -result : result;
            }
        }
        
        // 完全相等
        return 0;
    }

    /**
     * 格式化输出，添加千位分隔符
     */
    std::string formatWithSeparators() const {
        std::stringstream ss;
        
        // 处理符号
        if (isNegative && !(digits.size() == 1 && digits[0] == 0)) {
            ss << '-';
        }
        
        // 整数部分长度
        size_t intLength = std::min(static_cast<size_t>(decimalPointPos), digits.size());
        
        // 输出整数部分，添加千位分隔符
        for (size_t i = 0; i < intLength; ++i) {
            // 在适当的位置添加千位分隔符
            if (i > 0 && (intLength - i) % 3 == 0) {
                ss << ',';
            }
            ss << digits[i];
        }
        
        // 如果有小数部分，输出小数点和小数
        if (digits.size() > static_cast<size_t>(decimalPointPos)) {
            ss << '.';
            for (size_t i = static_cast<size_t>(decimalPointPos); i < digits.size(); ++i) {
                ss << digits[i];
            }
        }
        
        // 处理整数部分为空的情况
        if (intLength == 0) {
            ss << '0';
        }
        
        return ss.str();
    }
};

/**
 * 将科学计数法表示的字符串转换为普通小数表示
 */
std::string scientificToDecimal(const std::string& scientificNotation, int precision) {
    // 正则表达式匹配科学计数法
    std::regex sciRegex(R"(([+-]?)(\d+(?:\.\d+)?)[eE]([+-]?\d+))");
    std::smatch match;
    
    if (!std::regex_match(scientificNotation, match, sciRegex)) {
        // 如果不是科学计数法，直接返回
        return scientificNotation;
    }
    
    std::string sign = match[1].str();
    std::string mantissa = match[2].str();
    int exponent = std::stoi(match[3].str());
    
    // 分离尾数的整数部分和小数部分
    size_t dotPos = mantissa.find('.');
    std::string intPart = (dotPos != std::string::npos) ? mantissa.substr(0, dotPos) : mantissa;
    std::string fracPart = (dotPos != std::string::npos) ? mantissa.substr(dotPos + 1) : "";
    
    // 根据指数调整小数点位置
    std::stringstream result;
    
    if (exponent >= 0) {
        // 小数点右移
        result << intPart;
        if (exponent < static_cast<int>(fracPart.size())) {
            result << fracPart.substr(0, exponent);
            result << '.' << fracPart.substr(exponent);
        } else {
            result << fracPart;
            result << std::string(exponent - fracPart.size(), '0');
        }
    } else {
        // 小数点左移
        exponent = -exponent;
        result << "0.";
        result << std::string(exponent - 1, '0');
        result << intPart << fracPart;
    }
    
    // 添加符号
    if (!sign.empty() && sign != "+") {
        result << sign;
    }
    
    // 四舍五入到指定精度
    HighPrecisionDecimal hp(result.str());
    hp = hp.round(precision);
    
    return hp.toString();
}

/**
 * 格式化高精度小数，添加千位分隔符
 */
std::string formatWithSeparators(const std::string& value, int fractionalDigits) {
    HighPrecisionDecimal hp(value);
    hp = hp.round(fractionalDigits);
    return hp.formatWithSeparators();
}

/**
 * 生成指定位数的随机高精度小数
 */
std::string generateRandomDecimal(int integerDigits, int fractionalDigits) {
    if (integerDigits <= 0 && fractionalDigits <= 0) {
        return "0";
    }
    
    static std::random_device rd;
    static std::mt19937 gen(rd());
    static std::uniform_int_distribution<> dis09(0, 9);
    static std::uniform_int_distribution<> dis19(1, 9);
    
    std::stringstream ss;
    
    // 生成整数部分
    if (integerDigits > 0) {
        // 第一位不能是0
        ss << dis19(gen);
        // 生成剩余的整数位
        for (int i = 1; i < integerDigits; ++i) {
            ss << dis09(gen);
        }
    } else {
        ss << '0';
    }
    
    // 生成小数部分
    if (fractionalDigits > 0) {
        ss << '.';
        for (int i = 0; i < fractionalDigits; ++i) {
            ss << dis09(gen);
        }
    }
    
    return ss.str();
}

/**
 * 计算大数的平方根（简化实现）
 */
std::string calculateSquareRoot(const std::string& n, int precision) {
    // 使用二分法计算平方根的近似值
    double num = std::stod(n);
    if (num < 0) {
        throw std::invalid_argument("无法计算负数的平方根");
    }
    
    double low = 0.0;
    double high = std::max(1.0, num);
    double mid = 0.0;
    
    // 二分查找
    for (int i = 0; i < 100; ++i) { // 100次迭代足够精确
        mid = (low + high) / 2;
        double midSquared = mid * mid;
        
        if (std::abs(midSquared - num) < 1e-20) {
            break;
        }
        
        if (midSquared < num) {
            low = mid;
        } else {
            high = mid;
        }
    }
    
    // 格式化输出
    std::stringstream ss;
    ss << std::fixed << std::setprecision(precision) << mid;
    return ss.str();
}

/**
 * 比较两个高精度小数的大小
 */
int compareDecimals(const std::string& a, const std::string& b) {
    HighPrecisionDecimal hpA(a);
    HighPrecisionDecimal hpB(b);
    return hpA.compare(hpB);
}

/**
 * 格式化高精度小数，显示为工程计数法
 */
std::string formatToEngineeringNotation(const std::string& value, int precision) {
    HighPrecisionDecimal hp(value);
    
    // 转换为科学计数法
    std::string scientific = hp.toScientificNotation(precision);
    
    // 正则表达式匹配科学计数法
    std::regex sciRegex(R"(([+-]?)(\d+\.\d+)[eE]([+-]?\d+))");
    std::smatch match;
    
    if (!std::regex_match(scientific, match, sciRegex)) {
        return scientific;
    }
    
    std::string sign = match[1].str();
    std::string mantissa = match[2].str();
    int exponent = std::stoi(match[3].str());
    
    // 调整指数为3的倍数
    int remainder = exponent % 3;
    if (remainder != 0) {
        if (remainder < 0) {
            remainder += 3;
            exponent -= 3;
        }
        
        // 调整尾数
        double mantissaValue = std::stod(mantissa);
        mantissaValue *= std::pow(10, remainder);
        
        std::stringstream ss;
        ss << std::fixed << std::setprecision(precision - 1) << mantissaValue;
        mantissa = ss.str();
        exponent -= remainder;
    }
    
    // 构建工程计数法字符串
    std::stringstream result;
    result << sign << mantissa << "e" << (exponent >= 0 ? "+" : "") << exponent;
    
    return result.str();
}

/**
 * 解析格式化的数字字符串
 */
std::string parseFormattedDecimal(const std::string& formattedString) {
    // 移除千位分隔符
    std::string cleanString;
    for (char c : formattedString) {
        if (c != ',') {
            cleanString += c;
        }
    }
    
    return cleanString;
}

/**
 * 对高精度小数进行舍入操作
 */
std::string roundDecimal(const std::string& value, int scale, const std::string& roundingMode) {
    HighPrecisionDecimal hp(value);
    HighPrecisionDecimal rounded = hp.round(scale);
    return rounded.toString();
}

/**
 * 测试高精度小数的各种操作
 */
void testOperations() {
    std::cout << "=== 高精度小数操作测试 ===" << std::endl;
    
    // 测试科学计数法转换
    std::string scientific = "1.23456789E5";
    std::cout << "科学计数法: " << scientific << std::endl;
    std::cout << "转为普通小数: " << scientificToDecimal(scientific, 10) << std::endl;
    
    // 测试合并整数和小数部分
    HighPrecisionDecimal combined("12345", "6789");
    std::cout << "\n合并整数和小数部分: " << combined.toString() << std::endl;
    
    // 测试格式化
    std::string value = "1234567.890123456789";
    std::cout << "\n原始值: " << value << std::endl;
    std::cout << "格式化(带千位分隔符): " << formatWithSeparators(value, 8) << std::endl;
    std::cout << "工程计数法: " << formatToEngineeringNotation(value, 10) << std::endl;
    
    // 测试随机数生成
    std::string randomDecimal = generateRandomDecimal(8, 10);
    std::cout << "\n随机高精度小数: " << randomDecimal << std::endl;
    
    // 测试平方根计算
    std::string bigNum = "12345678901234567890";
    std::cout << "\n计算大数的平方根: sqrt(" << bigNum << ")" << std::endl;
    std::string sqrt = calculateSquareRoot(bigNum, 20);
    std::cout << "平方根: " << sqrt << std::endl;
    
    // 测试比较
    std::string a = "123.456";
    std::string b = "123.457";
    std::cout << "\n比较两个高精度小数: " << a << " 和 " << b << std::endl;
    int result = compareDecimals(a, b);
    std::cout << "比较结果: " << result << std::endl;
    
    // 测试解析
    std::string formatted = "1,234,567.8901";
    std::cout << "\n解析格式化字符串: " << formatted << std::endl;
    std::cout << "解析结果: " << parseFormattedDecimal(formatted) << std::endl;
    
    // 测试舍入
    std::string valueToRound = "123.456789";
    std::cout << "\n舍入测试: " << valueToRound << std::endl;
    std::cout << "四舍五入到3位小数: " << roundDecimal(valueToRound, 3, "HALF_UP") << std::endl;
}

/**
 * 交互式测试函数
 */
void interactiveMode() {
    std::cout << "=== 高精度小数与格式化工具 ===" << std::endl;
    std::cout << "输入操作编号:" << std::endl;
    std::cout << "1. 科学计数法转普通小数" << std::endl;
    std::cout << "2. 合并整数和小数部分" << std::endl;
    std::cout << "3. 格式化带千位分隔符" << std::endl;
    std::cout << "4. 生成随机高精度小数" << std::endl;
    std::cout << "5. 计算大数平方根" << std::endl;
    std::cout << "6. 比较两个高精度小数" << std::endl;
    std::cout << "7. 工程计数法格式化" << std::endl;
    std::cout << "8. 解析格式化的数字" << std::endl;
    std::cout << "9. 小数舍入操作" << std::endl;
    std::cout << "0. 退出" << std::endl;
    
    while (true) {
        std::cout << "\n请输入操作编号: ";
        int choice;
        std::cin >> choice;
        std::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\n'); // 清空输入缓冲区
        
        try {
            switch (choice) {
                case 0:
                    std::cout << "程序已退出" << std::endl;
                    return;
                case 1: {
                    std::cout << "请输入科学计数法表示的数字: ";
                    std::string sciNotation;
                    std::getline(std::cin, sciNotation);
                    std::cout << "请输入保留的小数位数: ";
                    int precision;
                    std::cin >> precision;
                    std::cin.ignore();
                    std::cout << "转换结果: " << scientificToDecimal(sciNotation, precision) << std::endl;
                    break;
                }
                case 2: {
                    std::cout << "请输入整数部分: ";
                    std::string integerPart;
                    std::getline(std::cin, integerPart);
                    std::cout << "请输入小数部分: ";
                    std::string fractionalPart;
                    std::getline(std::cin, fractionalPart);
                    HighPrecisionDecimal hp(integerPart, fractionalPart);
                    std::cout << "合并结果: " << hp.toString() << std::endl;
                    break;
                }
                case 3: {
                    std::cout << "请输入要格式化的数字: ";
                    std::string numToFormat;
                    std::getline(std::cin, numToFormat);
                    std::cout << "请输入小数位数: ";
                    int fracDigits;
                    std::cin >> fracDigits;
                    std::cin.ignore();
                    std::cout << "格式化结果: " << formatWithSeparators(numToFormat, fracDigits) << std::endl;
                    break;
                }
                case 4: {
                    std::cout << "请输入整数部分位数: ";
                    int intDigits;
                    std::cin >> intDigits;
                    std::cout << "请输入小数部分位数: ";
                    int fracDigits;
                    std::cin >> fracDigits;
                    std::cin.ignore();
                    std::cout << "随机小数: " << generateRandomDecimal(intDigits, fracDigits) << std::endl;
                    break;
                }
                case 5: {
                    std::cout << "请输入要计算平方根的整数: ";
                    std::string intToSqrt;
                    std::getline(std::cin, intToSqrt);
                    std::cout << "请输入保留的小数位数: ";
                    int precision;
                    std::cin >> precision;
                    std::cin.ignore();
                    std::cout << "平方根: " << calculateSquareRoot(intToSqrt, precision) << std::endl;
                    break;
                }
                case 6: {
                    std::cout << "请输入第一个数字: ";
                    std::string num1;
                    std::getline(std::cin, num1);
                    std::cout << "请输入第二个数字: ";
                    std::string num2;
                    std::getline(std::cin, num2);
                    int result = compareDecimals(num1, num2);
                    std::cout << num1 << " " << (result < 0 ? "小于" : (result > 0 ? "大于" : "等于")) << " " << num2 << std::endl;
                    break;
                }
                case 7: {
                    std::cout << "请输入要格式化的数字: ";
                    std::string numToEng;
                    std::getline(std::cin, numToEng);
                    std::cout << "请输入有效数字位数: ";
                    int sigDigits;
                    std::cin >> sigDigits;
                    std::cin.ignore();
                    std::cout << "工程计数法表示: " << formatToEngineeringNotation(numToEng, sigDigits) << std::endl;
                    break;
                }
                case 8: {
                    std::cout << "请输入要解析的格式化数字字符串: ";
                    std::string formattedStr;
                    std::getline(std::cin, formattedStr);
                    std::cout << "解析结果: " << parseFormattedDecimal(formattedStr) << std::endl;
                    break;
                }
                case 9: {
                    std::cout << "请输入要舍入的数字: ";
                    std::string numToRound;
                    std::getline(std::cin, numToRound);
                    std::cout << "请输入保留的小数位数: ";
                    int scale;
                    std::cin >> scale;
                    std::cin.ignore();
                    std::cout << "四舍五入: " << roundDecimal(numToRound, scale, "HALF_UP") << std::endl;
                    break;
                }
                default:
                    std::cout << "无效的操作编号，请重新输入" << std::endl;
            }
        } catch (const std::exception& e) {
            std::cout << "操作出错: " << e.what() << std::endl;
            std::cin.clear(); // 清除错误状态
            std::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\n'); // 清空输入缓冲区
        }
    }
}

int main() {
    // 运行测试
    testOperations();
    
    // 启动交互模式
    interactiveMode();
    
    return 0;
}

===============================================

文件: high_precision_decimal.py
===============================================
#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
高精度小数与格式化工具类
提供各种高精度小数操作和格式化方法
适用于需要极高精度计算和显示的场景
"""

import decimal
import random
import re
from typing import Optional, Tuple, List

# 设置decimal模块的精度
decimal.getcontext().prec = 100  # 设置默认精度为100位有效数字

def scientific_to_decimal(scientific_notation: str, precision: int) -> str:
    """
    将科学计数法表示的字符串转换为普通小数表示
    
    Args:
        scientific_notation: 科学计数法字符串
        precision: 小数点后保留位数
    
    Returns:
        普通小数表示的字符串
    """
    # 使用decimal模块处理高精度浮点数
    with decimal.localcontext() as ctx:
        ctx.rounding = decimal.ROUND_HALF_UP  # 设置为四舍五入
        # 解析科学计数法
        d = decimal.Decimal(scientific_notation)
        # 格式化输出
        format_str = f".{precision}f"
        result = format(d, format_str)
        
        # 移除可能的负号后的空格
        result = result.replace("- ", "-")
        return result

def combine_decimal_parts(integer_part: str, fractional_part: str) -> decimal.Decimal:
    """
    将大整数和小数字符串合并成一个高精度小数
    
    Args:
        integer_part: 整数部分字符串
        fractional_part: 小数部分字符串
    
    Returns:
        Decimal表示的高精度小数
    """
    # 处理空字符串情况
    if not integer_part:
        integer_part = "0"
    if not fractional_part:
        fractional_part = "0"
    
    # 合并整数和小数部分
    decimal_str = f"{integer_part}.{fractional_part}"
    return decimal.Decimal(decimal_str)

def format_with_separators(value: decimal.Decimal, fractional_digits: int) -> str:
    """
    格式化高精度小数，添加千位分隔符
    
    Args:
        value: 高精度小数
        fractional_digits: 小数位数
    
    Returns:
        格式化后的字符串
    """
    # 保留指定小数位数
    with decimal.localcontext() as ctx:
        ctx.rounding = decimal.ROUND_HALF_UP
        rounded = value.quantize(decimal.Decimal(f".{'0'*fractional_digits}"))
    
    # 转换为字符串并添加千位分隔符
    # 分离开整数部分和小数部分
    sign = "-" if rounded < 0 else ""
    abs_val = abs(rounded)
    
    # 处理整数部分
    int_part = str(abs_val.quantize(decimal.Decimal("1"), rounding=decimal.ROUND_FLOOR))
    # 添加千位分隔符
    formatted_int = "{:,}".format(int(int_part))
    
    # 处理小数部分
    if fractional_digits > 0:
        # 获取小数部分并补零
        frac_part = str(abs_val - decimal.Decimal(int_part)).split('.')[1]
        frac_part = frac_part.ljust(fractional_digits, '0')[:fractional_digits]
        return f"{sign}{formatted_int}.{frac_part}"
    else:
        return f"{sign}{formatted_int}"

def generate_random_decimal(integer_digits: int, fractional_digits: int) -> decimal.Decimal:
    """
    生成指定位数的随机高精度小数
    
    Args:
        integer_digits: 整数部分位数
        fractional_digits: 小数部分位数
    
    Returns:
        随机高精度小数
    """
    # 生成整数部分（不能以0开头，除非只有一位且是0）
    if integer_digits > 0:
        # 第一位不能是0
        first_digit = str(random.randint(1, 9))
        # 生成剩余的整数位
        other_digits = [str(random.randint(0, 9)) for _ in range(integer_digits - 1)]
        integer_part = first_digit + ''.join(other_digits)
    else:
        integer_part = "0"
    
    # 生成小数部分
    fractional_part = ''.join([str(random.randint(0, 9)) for _ in range(fractional_digits)])
    
    # 合并并返回
    return combine_decimal_parts(integer_part, fractional_part)

def calculate_square_root(n: int, precision: int) -> decimal.Decimal:
    """
    计算大数的平方根，保留指定精度
    
    Args:
        n: 大整数
        precision: 精度（小数点后位数）
    
    Returns:
        平方根的高精度表示
    
    Raises:
        ValueError: 当输入为负数时抛出
    """
    # 对于负数，抛出异常
    if n < 0:
        raise ValueError("无法计算负数的平方根")
    # 对于0，直接返回0
    if n == 0:
        return decimal.Decimal("0").quantize(decimal.Decimal(f".{'0'*precision}"))
    
    # 转换为Decimal类型
    x = decimal.Decimal(str(n))
    
    # 使用二分法找到初始近似值
    low = decimal.Decimal("0")
    high = decimal.Decimal(max(1, n))  # 确保high至少为1
    mid = decimal.Decimal("0")
    
    # 二分法迭代30次获取较好的初始值
    for _ in range(30):
        mid = (low + high) / 2
        mid_squared = mid * mid
        
        if mid_squared < x:
            low = mid
        else:
            high = mid
    
    # 使用牛顿迭代法进一步提高精度
    # 增加工作精度以确保结果准确
    with decimal.localcontext() as ctx:
        ctx.prec = precision + 20  # 工作精度比需求高
        ctx.rounding = decimal.ROUND_HALF_UP
        
        # 牛顿迭代法：x_{n+1} = (x_n + S/x_n) / 2
        for _ in range(10):  # 牛顿法收敛很快，10次迭代足够
            mid = (mid + x / mid) / 2
    
    # 最终结果四舍五入到指定精度
    with decimal.localcontext() as ctx:
        ctx.rounding = decimal.ROUND_HALF_UP
        return mid.quantize(decimal.Decimal(f".{'0'*precision}"))

def compare_decimals(a: decimal.Decimal, b: decimal.Decimal) -> int:
    """
    比较两个高精度小数的大小
    
    Args:
        a: 第一个数
        b: 第二个数
    
    Returns:
        a < b 返回-1，a = b 返回0，a > b 返回1
    """
    if a < b:
        return -1
    elif a > b:
        return 1
    else:
        return 0

def format_to_engineering_notation(value: decimal.Decimal, precision: int) -> str:
    """
    格式化高精度小数，显示为工程计数法
    
    Args:
        value: 高精度小数
        precision: 有效数字位数
    
    Returns:
        工程计数法表示的字符串
    """
    # 处理零的特殊情况
    if value == 0:
        return "0" + f".{'0'*(precision-1)}" + "e+000"
    
    # 将数字转换为科学计数法形式
    with decimal.localcontext() as ctx:
        ctx.prec = precision + 10  # 增加工作精度以确保准确性
        ctx.rounding = decimal.ROUND_HALF_UP
        # 使用Decimal的to_eng_string()方法获取工程计数法表示
        engineering_str = value.normalize().to_eng_string()
    
    # 处理指数部分，确保是3的倍数
    # 提取尾数和指数
    parts = re.split(r'[eE]', engineering_str)
    mantissa = decimal.Decimal(parts[0])
    exponent = int(parts[1]) if len(parts) > 1 else 0
    
    # 调整指数为3的倍数
    remainder = exponent % 3
    if remainder != 0:
        if remainder < 0:
            remainder += 3
            exponent -= 3
        adjustment = decimal.Decimal(f"10^{remainder}")
        mantissa = mantissa * adjustment
        exponent -= remainder
    
    # 格式化结果
    # 确保尾数有足够的精度
    with decimal.localcontext() as ctx:
        ctx.prec = precision
        ctx.rounding = decimal.ROUND_HALF_UP
        mantissa_str = format(mantissa.normalize(), f".{precision-1}g")
    
    # 格式化指数为三位，带符号
    exponent_str = f"{exponent:+04d}"
    
    # 处理特殊情况：避免10^0时的指数显示
    if exponent == 0:
        return mantissa_str
    
    return f"{mantissa_str}e{exponent_str}"

def parse_formatted_decimal(formatted_string: str) -> decimal.Decimal:
    """
    解析格式化的数字字符串（可能包含千位分隔符）为高精度小数
    
    Args:
        formatted_string: 格式化的数字字符串
    
    Returns:
        解析后的高精度小数
    """
    # 移除千位分隔符
    # 处理不同地区的千位分隔符格式（这里假设使用逗号或空格）
    clean_string = re.sub(r'[\\s,]', '', formatted_string)
    # 移除可能的货币符号
    clean_string = re.sub(r'^[€$£¥]+', '', clean_string)
    # 解析为Decimal
    return decimal.Decimal(clean_string)

def round_decimal(value: decimal.Decimal, scale: int, rounding_mode: str) -> decimal.Decimal:
    """
    对高精度小数进行舍入操作
    
    Args:
        value: 原始值
        scale: 保留的小数位数
        rounding_mode: 舍入模式，可以是以下之一：
            - 'HALF_UP': 四舍五入
            - 'HALF_DOWN': 四舍六入
            - 'UP': 向上舍入（向正无穷方向）
            - 'DOWN': 向下舍入（向负无穷方向）
            - 'CEILING': 向正无穷方向舍入
            - 'FLOOR': 向负无穷方向舍入
            - 'HALF_EVEN': 银行家舍入法
    
    Returns:
        舍入后的高精度小数
    """
    # 映射舍入模式
    rounding_map = {
        'HALF_UP': decimal.ROUND_HALF_UP,
        'HALF_DOWN': decimal.ROUND_HALF_DOWN,
        'UP': decimal.ROUND_UP,
        'DOWN': decimal.ROUND_DOWN,
        'CEILING': decimal.ROUND_CEILING,
        'FLOOR': decimal.ROUND_FLOOR,
        'HALF_EVEN': decimal.ROUND_HALF_EVEN
    }
    
    if rounding_mode not in rounding_map:
        raise ValueError(f"不支持的舍入模式: {rounding_mode}")
    
    with decimal.localcontext() as ctx:
        ctx.rounding = rounding_map[rounding_mode]
        return value.quantize(decimal.Decimal(f".{'0'*scale}"))

def calculate_power(base: decimal.Decimal, exponent: int, precision: int) -> decimal.Decimal:
    """
    计算高精度小数的幂，保留指定精度
    
    Args:
        base: 底数
        exponent: 指数
        precision: 精度（小数点后位数）
    
    Returns:
        幂的高精度表示
    """
    if exponent == 0:
        return decimal.Decimal("1").quantize(decimal.Decimal(f".{'0'*precision}"))
    
    # 使用快速幂算法
    is_negative = exponent < 0
    abs_exponent = abs(exponent)
    
    # 计算前设置更高的精度以确保准确性
    with decimal.localcontext() as ctx:
        ctx.prec = precision + 20  # 增加工作精度
        ctx.rounding = decimal.ROUND_HALF_UP
        
        result = decimal.Decimal("1")
        current_base = base
        
        while abs_exponent > 0:
            if abs_exponent % 2 == 1:
                result = result * current_base
            current_base = current_base * current_base
            abs_exponent //= 2
        
        # 如果是负指数，取倒数
        if is_negative:
            try:
                result = decimal.Decimal("1") / result
            except decimal.DivisionByZero:
                raise ValueError("无法计算负数次幂，因为结果为无穷大")
    
    # 最终结果四舍五入到指定精度
    with decimal.localcontext() as ctx:
        ctx.rounding = decimal.ROUND_HALF_UP
        return result.quantize(decimal.Decimal(f".{'0'*precision}"))

def test_operations():
    """测试高精度小数的各种操作"""
    print("=== 高精度小数操作测试 ===")
    
    # 测试科学计数法转换
    scientific = "1.23456789E5"
    print(f"科学计数法: {scientific}")
    print(f"转为普通小数: {scientific_to_decimal(scientific, 10)}")
    
    # 测试合并整数和小数部分
    combined = combine_decimal_parts("12345", "6789")
    print(f"\n合并整数和小数部分: {combined.to_eng_string()}")
    
    # 测试格式化
    value = decimal.Decimal("1234567.890123456789")
    print(f"\n原始值: {value.to_eng_string()}")
    print(f"格式化(带千位分隔符): {format_with_separators(value, 8)}")
    print(f"工程计数法: {format_to_engineering_notation(value, 10)}")
    
    # 测试随机数生成
    random_decimal = generate_random_decimal(8, 10)
    print(f"\n随机高精度小数: {random_decimal.to_eng_string()}")
    
    # 测试平方根计算
    big_num = 123456789012345678901234567890
    print(f"\n计算大数的平方根: sqrt({big_num})")
    sqrt = calculate_square_root(big_num, 20)
    print(f"平方根: {sqrt}")
    
    # 验证平方根计算的正确性
    squared = sqrt * sqrt
    print(f"平方根的平方: {squared}")
    
    # 测试比较
    a = decimal.Decimal("123.456")
    b = decimal.Decimal("123.457")
    print(f"\n比较两个高精度小数: {a} 和 {b}")
    result = compare_decimals(a, b)
    result_text = "小于" if result < 0 else "大于" if result > 0 else "等于"
    print(f"比较结果: {a} {result_text} {b}")
    
    # 测试解析
    formatted = "1,234,567.8901"
    print(f"\n解析格式化字符串: {formatted}")
    print(f"解析结果: {parse_formatted_decimal(formatted).to_eng_string()}")
    
    # 测试舍入
    value_to_round = decimal.Decimal("123.456789")
    print(f"\n舍入测试: {value_to_round.to_eng_string()}")
    print(f"四舍五入到3位小数: {round_decimal(value_to_round, 3, 'HALF_UP')}")
    print(f"向上舍入到2位小数: {round_decimal(value_to_round, 2, 'CEILING')}")
    print(f"向下舍入到2位小数: {round_decimal(value_to_round, 2, 'FLOOR')}")
    
    # 测试幂计算
    base = decimal.Decimal("2.5")
    exponent = 10
    print(f"\n计算幂: {base}^{exponent}")
    print(f"结果: {calculate_power(base, exponent, 10)}")

def interactive_mode():
    """交互式测试函数"""
    print("=== 高精度小数与格式化工具 ===")
    print("输入操作编号:")
    print("1. 科学计数法转普通小数")
    print("2. 合并整数和小数部分")
    print("3. 格式化带千位分隔符")
    print("4. 生成随机高精度小数")
    print("5. 计算大数平方根")
    print("6. 比较两个高精度小数")
    print("7. 工程计数法格式化")
    print("8. 解析格式化的数字")
    print("9. 小数舍入操作")
    print("10. 计算高精度小数的幂")
    print("0. 退出")
    
    while True:
        try:
            choice = input("\n请输入操作编号: ")
            
            if choice == "0":
                print("程序已退出")
                return
            elif choice == "1":
                sci_notation = input("请输入科学计数法表示的数字: ")
                precision1 = int(input("请输入保留的小数位数: "))
                print(f"转换结果: {scientific_to_decimal(sci_notation, precision1)}")
            elif choice == "2":
                integer_part = input("请输入整数部分: ")
                fractional_part = input("请输入小数部分: ")
                print(f"合并结果: {combine_decimal_parts(integer_part, fractional_part).to_eng_string()}")
            elif choice == "3":
                num_to_format = input("请输入要格式化的数字: ")
                frac_digits = int(input("请输入小数位数: "))
                print(f"格式化结果: {format_with_separators(decimal.Decimal(num_to_format), frac_digits)}")
            elif choice == "4":
                int_digits = int(input("请输入整数部分位数: "))
                frac_digits2 = int(input("请输入小数部分位数: "))
                print(f"随机小数: {generate_random_decimal(int_digits, frac_digits2).to_eng_string()}")
            elif choice == "5":
                int_to_sqrt = input("请输入要计算平方根的整数: ")
                precision2 = int(input("请输入保留的小数位数: "))
                print(f"平方根: {calculate_square_root(int(int_to_sqrt), precision2)}")
            elif choice == "6":
                num1 = input("请输入第一个数字: ")
                num2 = input("请输入第二个数字: ")
                result = compare_decimals(decimal.Decimal(num1), decimal.Decimal(num2))
                result_text = "小于" if result < 0 else "大于" if result > 0 else "等于"
                print(f"{num1} {result_text} {num2}")
            elif choice == "7":
                num_to_eng = input("请输入要格式化的数字: ")
                sig_digits = int(input("请输入有效数字位数: "))
                print(f"工程计数法表示: {format_to_engineering_notation(decimal.Decimal(num_to_eng), sig_digits)}")
            elif choice == "8":
                formatted_str = input("请输入要解析的格式化数字字符串: ")
                print(f"解析结果: {parse_formatted_decimal(formatted_str).to_eng_string()}")
            elif choice == "9":
                num_to_round = input("请输入要舍入的数字: ")
                scale = int(input("请输入保留的小数位数: "))
                print(f"四舍五入: {round_decimal(decimal.Decimal(num_to_round), scale, 'HALF_UP')}")
                print(f"向上舍入: {round_decimal(decimal.Decimal(num_to_round), scale, 'CEILING')}")
                print(f"向下舍入: {round_decimal(decimal.Decimal(num_to_round), scale, 'FLOOR')}")
            elif choice == "10":
                base_str = input("请输入底数: ")
                exponent = int(input("请输入指数: "))
                precision3 = int(input("请输入保留的小数位数: "))
                print(f"幂计算结果: {calculate_power(decimal.Decimal(base_str), exponent, precision3)}")
            else:
                print("无效的操作编号，请重新输入")
        except Exception as e:
            print(f"操作出错: {str(e)}")

if __name__ == "__main__":
    # 运行测试
    test_operations()
    
    # 启动交互模式
    interactive_mode()

===============================================

文件: HuffmanCoding.java
===============================================
package class_advanced_algorithms.huffman;

import java.util.*;

/**
 * Huffman编码实现
 * 
 * Huffman编码是一种无损数据压缩算法，它根据字符出现频率构建最优二叉树，
 * 使得出现频率高的字符具有较短的编码，出现频率低的字符具有较长的编码。
 * 
 * 算法原理：
 * 1. 统计字符频率
 * 2. 构建Huffman树：每次选择频率最小的两个节点合并
 * 3. 生成编码表：从根节点到叶节点的路径即为字符的编码
 * 4. 编码和解码过程
 * 
 * 时间复杂度：
 * - 构建Huffman树：O(n log n)，其中n是不同字符的数量
 * - 编码/解码：O(m)，其中m是字符串长度
 * 
 * 空间复杂度：O(n)
 * 
 * 优势：
 * 1. 压缩率高，能够达到信息熵的理论极限
 * 2. 实现相对简单
 * 3. 适合处理具有明显统计特性的数据
 * 
 * 劣势：
 * 1. 需要两次扫描数据（一次统计频率，一次编码）
 * 2. 对于频率分布均匀的数据压缩效果不佳
 * 3. 编码和解码需要相同的Huffman树
 * 
 * 应用场景：
 * 1. 文件压缩（如ZIP格式）
 * 2. 图像压缩（如JPEG）
 * 3. 音频压缩
 */
public class HuffmanCoding {
    
    /**
     * Huffman树节点
     * 用于表示Huffman树中的节点，包含字符、频率以及左右子树的引用
     */
    private static class Node implements Comparable<Node> {
        char character;      // 字符（仅叶节点有效，内部节点为空字符）
        int frequency;       // 频率（节点权重）
        Node left, right;    // 左右子树引用
        
        /**
         * 构造函数：创建叶节点
         * @param character 节点表示的字符
         * @param frequency 字符出现的频率
         */
        Node(char character, int frequency) {
            this.character = character;
            this.frequency = frequency;
        }
        
        /**
         * 构造函数：创建内部节点
         * @param left 左子树
         * @param right 右子树
         */
        Node(Node left, Node right) {
            this.left = left;
            this.right = right;
            this.frequency = left.frequency + right.frequency;  // 内部节点频率等于子节点频率之和
        }
        
        /**
         * 判断是否为叶节点
         * 叶节点是没有子树的节点，用于存储实际字符
         * @return true表示是叶节点，false表示是内部节点
         */
        boolean isLeaf() {
            return left == null && right == null;
        }
        
        /**
         * 实现Comparable接口，用于优先队列排序
         * 按照频率升序排列，频率相同时按照字符ASCII码排序
         * @param other 待比较的节点
         * @return 比较结果
         */
        @Override
        public int compareTo(Node other) {
            // 首先按照频率比较
            int freqCompare = Integer.compare(this.frequency, other.frequency);
            if (freqCompare != 0) {
                return freqCompare;
            }
            // 频率相同时按照字符比较，确保一致性
            return Character.compare(this.character, other.character);
        }
    }
    
    private Node root;                    // Huffman树根节点
    private Map<Character, String> codes; // 字符到编码的映射
    
    /**
     * 构造函数，根据输入字符串构建Huffman树和编码表
     * 这是Huffman编码的核心初始化方法，完成整个编码系统的构建
     * @param input 输入字符串，用于统计字符频率并构建Huffman树
     */
    public HuffmanCoding(String input) {
        // 第一步：根据输入字符串构建Huffman树
        buildHuffmanTree(input);
        // 第二步：根据构建好的Huffman树生成编码表
        buildCodeTable();
    }
    
    /**
     * 构建Huffman树
     * 使用贪心算法构建最优二叉树，使得带权路径长度最小
     * 算法步骤：
     * 1. 统计输入字符串中各字符的出现频率
     * 2. 将所有字符节点放入优先队列（最小堆）
     * 3. 重复以下操作直到队列中只剩一个节点：
     *    a. 取出频率最小的两个节点
     *    b. 创建新节点作为它们的父节点，频率为两子节点频率之和
     *    c. 将新节点放回优先队列
     * 4. 剩下的唯一节点即为Huffman树的根节点
     * @param input 输入字符串
     */
    private void buildHuffmanTree(String input) {
        // 统计字符频率：遍历字符串，使用HashMap记录每个字符的出现次数
        Map<Character, Integer> frequencyMap = new HashMap<>();
        for (char c : input.toCharArray()) {
            frequencyMap.put(c, frequencyMap.getOrDefault(c, 0) + 1);
        }
        
        // 创建优先队列（最小堆）：用于高效获取频率最小的节点
        // PriorityQueue默认使用元素的compareTo方法进行排序
        PriorityQueue<Node> pq = new PriorityQueue<>();
        for (Map.Entry<Character, Integer> entry : frequencyMap.entrySet()) {
            pq.offer(new Node(entry.getKey(), entry.getValue()));
        }
        
        // 特殊情况处理：当输入字符串只包含一种字符时
        // 为了避免编码歧义，需要构造一个高度为2的树
        if (pq.size() == 1) {
            Node node = pq.poll();
            // 构造一个根节点，其右子树为原节点
            root = new Node(null, new Node(node.character, node.frequency));
            return;
        }
        
        // 构建Huffman树：贪心算法的核心实现
        // 每次从优先队列中取出频率最小的两个节点，合并为新节点后再放回队列
        while (pq.size() > 1) {
            // 取出频率最小的两个节点作为左右子树
            Node left = pq.poll();   // 较小频率的节点作为左子树
            Node right = pq.poll();  // 较大频率的节点作为右子树
            // 创建父节点，频率为两个子节点频率之和
            Node parent = new Node(left, right);
            // 将新节点放回优先队列
            pq.offer(parent);
        }
        
        // 最后剩下的节点即为Huffman树的根节点
        root = pq.poll();
    }
    
    /**
     * 构建编码表
     * 通过遍历Huffman树为每个字符生成对应的二进制编码
     * 编码规则：从根节点到叶节点的路径，左子树为'0'，右子树为'1'
     */
    private void buildCodeTable() {
        // 初始化编码表
        codes = new HashMap<>();
        // 从根节点开始递归构建编码表，初始编码为空字符串
        buildCodeTable(root, "");
    }
    
    /**
     * 递归构建编码表
     * 使用深度优先遍历Huffman树，为每个叶节点生成对应的二进制编码
     * 编码规则：
     * - 向左子树移动时，在编码末尾添加'0'
     * - 向右子树移动时，在编码末尾添加'1'
     * - 到达叶节点时，将字符与编码的映射关系保存到编码表中
     * @param node 当前遍历到的节点
     * @param code 从根节点到当前节点的路径编码
     */
    private void buildCodeTable(Node node, String code) {
        // 递归终止条件：节点为空
        if (node == null) return;
        
        // 叶节点处理：保存字符到编码的映射关系
        if (node.isLeaf()) {
            // 特殊情况处理：当只有一个字符时，编码为"0"而非空字符串
            // 这是为了避免解码时出现歧义
            if (code.isEmpty()) {
                codes.put(node.character, "0"); // 特殊情况：只有一个字符
            } else {
                codes.put(node.character, code);
            }
            return;
        }
        
        // 递归处理左右子树
        // 向左子树移动时，在编码末尾添加'0'
        buildCodeTable(node.left, code + "0");
        // 向右子树移动时，在编码末尾添加'1'
        buildCodeTable(node.right, code + "1");
    }
    
    /**
     * Huffman编码
     * 将输入字符串转换为Huffman编码的二进制字符串
     * 时间复杂度：O(m)，其中m是输入字符串的长度
     * 空间复杂度：O(k)，其中k是编码后字符串的长度
     * @param input 待编码的输入字符串
     * @return 编码后的二进制字符串
     * @throws NullPointerException 如果输入字符串为null
     */
    public String encode(String input) {
        // 使用StringBuilder提高字符串拼接效率
        StringBuilder encoded = new StringBuilder();
        // 遍历输入字符串中的每个字符
        for (char c : input.toCharArray()) {
            // 从编码表中获取字符对应的编码并追加到结果中
            String code = codes.get(c);
            // 异常处理：检查字符是否在编码表中存在
            if (code == null) {
                throw new IllegalArgumentException("字符 '" + c + "' 未在编码表中找到");
            }
            encoded.append(code);
        }
        // 返回编码结果
        return encoded.toString();
    }
    
    /**
     * Huffman解码
     * 将Huffman编码的二进制字符串转换回原始字符串
     * 解码过程：从根节点开始，根据编码中的每一位（0或1）在Huffman树中移动
     * 当到达叶节点时，输出对应的字符并重新从根节点开始
     * 时间复杂度：O(k)，其中k是编码字符串的长度
     * 空间复杂度：O(m)，其中m是解码后字符串的长度
     * @param encoded Huffman编码的二进制字符串
     * @return 解码后的原始字符串
     * @throws IllegalArgumentException 如果编码字符串包含非法字符（非0/1）
     * @throws IllegalStateException 如果编码不完整或Huffman树未正确构建
     */
    public String decode(String encoded) {
        // 使用StringBuilder提高字符串拼接效率
        StringBuilder decoded = new StringBuilder();
        // 当前在Huffman树中的位置，初始为根节点
        Node current = root;
        
        // 遍历编码字符串中的每一位
        for (char bit : encoded.toCharArray()) {
            // 根据当前位的值在Huffman树中移动
            if (bit == '0') {
                // 遇到'0'，向左子树移动
                current = current.left;
            } else if (bit == '1') {
                // 遇到'1'，向右子树移动
                current = current.right;
            } else {
                // 异常处理：编码字符串包含非法字符
                throw new IllegalArgumentException("非法字符 '" + bit + "' 在编码中");
            }
            
            // 安全检查：确保当前节点不为空
            if (current == null) {
                throw new IllegalStateException("Huffman树结构错误或编码不完整");
            }
            
            // 到达叶节点：输出字符并重新从根节点开始
            if (current.isLeaf()) {
                decoded.append(current.character);
                current = root;
            }
        }
        
        // 返回解码结果
        return decoded.toString();
    }
    
    /**
     * 获取编码表
     * @return 编码表
     */
    public Map<Character, String> getCodeTable() {
        return new HashMap<>(codes);
    }
    
    /**
     * 计算压缩率
     * @param original 原始数据大小（位）
     * @param compressed 压缩后数据大小（位）
     * @return 压缩率（百分比）
     */
    public static double calculateCompressionRatio(int original, int compressed) {
        if (original == 0) return 0;
        return (1.0 - (double) compressed / original) * 100;
    }
    
    /**
     * 获取字符频率映射
     * @param input 输入字符串
     * @return 字符频率映射
     */
    public static Map<Character, Integer> getFrequencyMap(String input) {
        Map<Character, Integer> frequencyMap = new HashMap<>();
        for (char c : input.toCharArray()) {
            frequencyMap.put(c, frequencyMap.getOrDefault(c, 0) + 1);
        }
        return frequencyMap;
    }
    
    /**
     * 测试方法
     */
    public static void main(String[] args) {
        // 测试用例1：包含重复字符的字符串
        String test1 = "ABRACADABRA";
        System.out.println("原始字符串: " + test1);
        System.out.println("字符频率: " + getFrequencyMap(test1));
        
        HuffmanCoding hc1 = new HuffmanCoding(test1);
        String encoded1 = hc1.encode(test1);
        String decoded1 = hc1.decode(encoded1);
        
        System.out.println("编码表: " + hc1.getCodeTable());
        System.out.println("编码结果: " + encoded1);
        System.out.println("解码结果: " + decoded1);
        System.out.println("编码解码是否正确: " + test1.equals(decoded1));
        System.out.println("原始大小: " + test1.length() * 8 + " 位");
        System.out.println("压缩后大小: " + encoded1.length() + " 位");
        System.out.println("压缩率: " + String.format("%.2f%%", 
            calculateCompressionRatio(test1.length() * 8, encoded1.length())));
        System.out.println();
        
        // 测试用例2：更复杂的字符串
        String test2 = "MISSISSIPPI";
        System.out.println("原始字符串: " + test2);
        System.out.println("字符频率: " + getFrequencyMap(test2));
        
        HuffmanCoding hc2 = new HuffmanCoding(test2);
        String encoded2 = hc2.encode(test2);
        String decoded2 = hc2.decode(encoded2);
        
        System.out.println("编码表: " + hc2.getCodeTable());
        System.out.println("编码结果: " + encoded2);
        System.out.println("解码结果: " + decoded2);
        System.out.println("编码解码是否正确: " + test2.equals(decoded2));
        System.out.println("原始大小: " + test2.length() * 8 + " 位");
        System.out.println("压缩后大小: " + encoded2.length() + " 位");
        System.out.println("压缩率: " + String.format("%.2f%%", 
            calculateCompressionRatio(test2.length() * 8, encoded2.length())));
        System.out.println();
        
        // 测试用例3：均匀分布的字符串
        String test3 = "ABCDEFGH";
        System.out.println("原始字符串: " + test3);
        System.out.println("字符频率: " + getFrequencyMap(test3));
        
        HuffmanCoding hc3 = new HuffmanCoding(test3);
        String encoded3 = hc3.encode(test3);
        String decoded3 = hc3.decode(encoded3);
        
        System.out.println("编码表: " + hc3.getCodeTable());
        System.out.println("编码结果: " + encoded3);
        System.out.println("解码结果: " + decoded3);
        System.out.println("编码解码是否正确: " + test3.equals(decoded3));
        System.out.println("原始大小: " + test3.length() * 8 + " 位");
        System.out.println("压缩后大小: " + encoded3.length() + " 位");
        System.out.println("压缩率: " + String.format("%.2f%%", 
            calculateCompressionRatio(test3.length() * 8, encoded3.length())));
        System.out.println();
        
        // 测试用例4：边界情况 - 空字符串
        String test4 = "";
        System.out.println("原始字符串: '" + test4 + "'");
        try {
            HuffmanCoding hc4 = new HuffmanCoding(test4);
            System.out.println("空字符串测试: 通过");
        } catch (Exception e) {
            System.out.println("空字符串测试: 异常 - " + e.getMessage());
        }
        System.out.println();
        
        // 测试用例5：边界情况 - 单字符重复
        String test5 = "AAAAAAA";
        System.out.println("原始字符串: " + test5);
        System.out.println("字符频率: " + getFrequencyMap(test5));
        
        HuffmanCoding hc5 = new HuffmanCoding(test5);
        String encoded5 = hc5.encode(test5);
        String decoded5 = hc5.decode(encoded5);
        
        System.out.println("编码表: " + hc5.getCodeTable());
        System.out.println("编码结果: " + encoded5);
        System.out.println("解码结果: " + decoded5);
        System.out.println("编码解码是否正确: " + test5.equals(decoded5));
        System.out.println("原始大小: " + test5.length() * 8 + " 位");
        System.out.println("压缩后大小: " + encoded5.length() + " 位");
        System.out.println("压缩率: " + String.format("%.2f%%", 
            calculateCompressionRatio(test5.length() * 8, encoded5.length())));
        System.out.println();
        
        // 测试用例6：边界情况 - 两个不同字符
        String test6 = "AB";
        System.out.println("原始字符串: " + test6);
        System.out.println("字符频率: " + getFrequencyMap(test6));
        
        HuffmanCoding hc6 = new HuffmanCoding(test6);
        String encoded6 = hc6.encode(test6);
        String decoded6 = hc6.decode(encoded6);
        
        System.out.println("编码表: " + hc6.getCodeTable());
        System.out.println("编码结果: " + encoded6);
        System.out.println("解码结果: " + decoded6);
        System.out.println("编码解码是否正确: " + test6.equals(decoded6));
        System.out.println("原始大小: " + test6.length() * 8 + " 位");
        System.out.println("压缩后大小: " + encoded6.length() + " 位");
        System.out.println("压缩率: " + String.format("%.2f%%", 
            calculateCompressionRatio(test6.length() * 8, encoded6.length())));
        System.out.println();
        
        // 测试用例7：中文字符串
        String test7 = "你好世界你好";
        System.out.println("原始字符串: " + test7);
        System.out.println("字符频率: " + getFrequencyMap(test7));
        
        HuffmanCoding hc7 = new HuffmanCoding(test7);
        String encoded7 = hc7.encode(test7);
        String decoded7 = hc7.decode(encoded7);
        
        System.out.println("编码表: " + hc7.getCodeTable());
        System.out.println("编码结果: " + encoded7);
        System.out.println("解码结果: " + decoded7);
        System.out.println("编码解码是否正确: " + test7.equals(decoded7));
        System.out.println("原始大小: " + test7.length() * 16 + " 位"); // 中文字符通常占用16位
        System.out.println("压缩后大小: " + encoded7.length() + " 位");
        System.out.println("压缩率: " + String.format("%.2f%%", 
            calculateCompressionRatio(test7.length() * 16, encoded7.length())));
    }
}

===============================================

文件: HuffmanEncoding.java
===============================================
package class_advanced_algorithms.compression;

import java.util.*;

/**
 * Huffman编码实现
 * 
 * Huffman编码是一种无损数据压缩算法，它根据字符出现的频率为每个字符分配不同长度的编码，
 * 频率高的字符分配较短的编码，频率低的字符分配较长的编码，从而实现数据压缩。
 * 
 * 算法原理：
 * 1. 统计输入数据中每个字符的频率
 * 2. 构建Huffman树（最优二叉树）
 * 3. 根据Huffman树生成每个字符的编码
 * 4. 使用生成的编码对原始数据进行编码
 * 5. 解码时根据Huffman树和编码还原原始数据
 * 
 * 时间复杂度：
 * - 构建Huffman树：O(n log n)，其中n是不同字符的数量
 * - 编码：O(m)，其中m是输入数据的长度
 * - 解码：O(m)，其中m是编码后数据的长度
 * 
 * 空间复杂度：O(n)，其中n是不同字符的数量
 * 
 * 优势：
 * 1. 压缩率高，特别是对于字符频率差异较大的数据
 * 2. 实现相对简单
 * 3. 解码过程确定且无歧义
 * 4. 前缀编码特性保证了解码的唯一性
 * 
 * 劣势：
 * 1. 需要传输或存储Huffman树信息
 * 2. 对于字符频率分布均匀的数据压缩效果不佳
 * 3. 需要两次遍历数据（统计频率和编码）
 * 
 * 应用场景：
 * 1. 文件压缩（如ZIP格式）
 * 2. 图像压缩（JPEG中的部分应用）
 * 3. 网络传输数据压缩
 */
public class HuffmanEncoding {
    
    // Huffman树节点
    static class Node implements Comparable<Node> {
        char character;      // 字符（仅叶节点有值）
        int frequency;       // 频率
        Node left, right;    // 左右子树
        
        // 构造函数（叶节点）
        Node(char character, int frequency) {
            this.character = character;
            this.frequency = frequency;
        }
        
        // 构造函数（内部节点）
        Node(int frequency, Node left, Node right) {
            this.frequency = frequency;
            this.left = left;
            this.right = right;
        }
        
        // 判断是否为叶节点
        boolean isLeaf() {
            return left == null && right == null;
        }
        
        // 比较方法，用于优先队列
        @Override
        public int compareTo(Node other) {
            return Integer.compare(this.frequency, other.frequency);
        }
    }
    
    // 编码结果类
    public static class EncodeResult {
        public final String encodedData;     // 编码后的数据
        public final Map<Character, String> huffmanCodes;  // Huffman编码表
        
        public EncodeResult(String encodedData, Map<Character, String> huffmanCodes) {
            this.encodedData = encodedData;
            this.huffmanCodes = huffmanCodes;
        }
    }
    
    /**
     * 构建Huffman树
     * @param frequencyMap 字符频率映射
     * @return Huffman树的根节点
     */
    private static Node buildHuffmanTree(Map<Character, Integer> frequencyMap) {
        // 创建优先队列（最小堆）
        PriorityQueue<Node> pq = new PriorityQueue<>();
        
        // 将所有字符节点加入优先队列
        for (Map.Entry<Character, Integer> entry : frequencyMap.entrySet()) {
            pq.offer(new Node(entry.getKey(), entry.getValue()));
        }
        
        // 特殊情况：只有一个字符
        if (pq.size() == 1) {
            Node node = pq.poll();
            return new Node(node.frequency, node, null);
        }
        
        // 构建Huffman树
        while (pq.size() > 1) {
            // 取出频率最小的两个节点
            Node left = pq.poll();
            Node right = pq.poll();
            
            // 创建新的内部节点
            Node parent = new Node(left.frequency + right.frequency, left, right);
            
            // 将新节点加入优先队列
            pq.offer(parent);
        }
        
        // 返回根节点
        return pq.poll();
    }
    
    /**
     * 生成Huffman编码表
     * @param root Huffman树根节点
     * @return 字符到编码的映射
     */
    private static Map<Character, String> generateHuffmanCodes(Node root) {
        Map<Character, String> huffmanCodes = new HashMap<>();
        generateCodes(root, "", huffmanCodes);
        return huffmanCodes;
    }
    
    /**
     * 递归生成编码
     * @param node 当前节点
     * @param code 当前路径的编码
     * @param huffmanCodes 编码表
     */
    private static void generateCodes(Node node, String code, Map<Character, String> huffmanCodes) {
        if (node == null) return;
        
        // 如果是叶节点，保存编码
        if (node.isLeaf()) {
            // 特殊情况：只有一个字符
            if (code.isEmpty()) {
                huffmanCodes.put(node.character, "0");
            } else {
                huffmanCodes.put(node.character, code);
            }
        } else {
            // 递归处理左右子树
            generateCodes(node.left, code + "0", huffmanCodes);
            generateCodes(node.right, code + "1", huffmanCodes);
        }
    }
    
    /**
     * Huffman编码
     * @param input 输入字符串
     * @return 编码结果
     */
    public static EncodeResult encode(String input) {
        if (input == null || input.isEmpty()) {
            return new EncodeResult("", new HashMap<>());
        }
        
        // 统计字符频率
        Map<Character, Integer> frequencyMap = new HashMap<>();
        for (char c : input.toCharArray()) {
            frequencyMap.put(c, frequencyMap.getOrDefault(c, 0) + 1);
        }
        
        // 构建Huffman树
        Node root = buildHuffmanTree(frequencyMap);
        
        // 生成Huffman编码表
        Map<Character, String> huffmanCodes = generateHuffmanCodes(root);
        
        // 编码输入数据
        StringBuilder encodedData = new StringBuilder();
        for (char c : input.toCharArray()) {
            encodedData.append(huffmanCodes.get(c));
        }
        
        return new EncodeResult(encodedData.toString(), huffmanCodes);
    }
    
    /**
     * Huffman解码
     * @param encodedData 编码后的数据
     * @param huffmanCodes Huffman编码表
     * @return 解码后的原始数据
     */
    public static String decode(String encodedData, Map<Character, String> huffmanCodes) {
        if (encodedData == null || encodedData.isEmpty()) {
            return "";
        }
        
        // 构建反向映射（编码到字符）
        Map<String, Character> reverseCodes = new HashMap<>();
        for (Map.Entry<Character, String> entry : huffmanCodes.entrySet()) {
            reverseCodes.put(entry.getValue(), entry.getKey());
        }
        
        // 特殊情况：只有一个字符
        if (huffmanCodes.size() == 1) {
            StringBuilder result = new StringBuilder();
            char singleChar = huffmanCodes.keySet().iterator().next();
            int length = encodedData.length();
            for (int i = 0; i < length; i++) {
                result.append(singleChar);
            }
            return result.toString();
        }
        
        // 构建Huffman树用于解码
        Node root = buildDecodeTree(huffmanCodes);
        
        // 解码
        StringBuilder result = new StringBuilder();
        Node current = root;
        
        for (char bit : encodedData.toCharArray()) {
            // 根据比特位移动到相应的子节点
            if (bit == '0') {
                current = current.left;
            } else {
                current = current.right;
            }
            
            // 如果到达叶节点，输出字符并回到根节点
            if (current.isLeaf()) {
                result.append(current.character);
                current = root;
            }
        }
        
        return result.toString();
    }
    
    /**
     * 根据编码表构建用于解码的Huffman树
     * @param huffmanCodes Huffman编码表
     * @return Huffman树根节点
     */
    private static Node buildDecodeTree(Map<Character, String> huffmanCodes) {
        Node root = new Node(0, null, null);
        
        for (Map.Entry<Character, String> entry : huffmanCodes.entrySet()) {
            char character = entry.getKey();
            String code = entry.getValue();
            
            Node current = root;
            for (int i = 0; i < code.length(); i++) {
                char bit = code.charAt(i);
                
                if (bit == '0') {
                    if (current.left == null) {
                        current.left = new Node(0, null, null);
                    }
                    current = current.left;
                } else {
                    if (current.right == null) {
                        current.right = new Node(0, null, null);
                    }
                    current = current.right;
                }
            }
            
            // 设置叶节点的字符
            current.character = character;
        }
        
        return root;
    }
    
    /**
     * 计算压缩率
     * @param original 原始数据大小（字节）
     * @param compressed 压缩后数据大小（字节）
     * @return 压缩率（百分比）
     */
    public static double calculateCompressionRatio(int original, int compressed) {
        if (original == 0) return 0;
        return (1.0 - (double) compressed / original) * 100;
    }
    
    /**
     * 测试方法
     */
    public static void main(String[] args) {
        // 测试用例1：包含重复字符的字符串
        String test1 = "ABRACADABRA";
        System.out.println("原始字符串: " + test1);
        System.out.println("原始长度: " + test1.length() + " 字符");
        
        EncodeResult encoded1 = encode(test1);
        System.out.println("Huffman编码表:");
        for (Map.Entry<Character, String> entry : encoded1.huffmanCodes.entrySet()) {
            if (entry.getKey() == '\0') {
                System.out.println("EOF: " + entry.getValue());
            } else {
                System.out.println(entry.getKey() + ": " + entry.getValue());
            }
        }
        System.out.println("编码结果: " + encoded1.encodedData);
        System.out.println("编码长度: " + encoded1.encodedData.length() + " 位");
        
        String decoded1 = decode(encoded1.encodedData, encoded1.huffmanCodes);
        System.out.println("解码结果: " + decoded1);
        System.out.println("编码解码是否正确: " + test1.equals(decoded1));
        System.out.println("压缩率: " + String.format("%.2f%%", 
            calculateCompressionRatio(test1.length() * 8, encoded1.encodedData.length())));
        System.out.println();
        
        // 测试用例2：包含重复模式的字符串
        String test2 = "AAAAABBBBBCCCCCDDDDDEEEEE";
        System.out.println("原始字符串: " + test2);
        System.out.println("原始长度: " + test2.length() + " 字符");
        
        EncodeResult encoded2 = encode(test2);
        System.out.println("Huffman编码表:");
        for (Map.Entry<Character, String> entry : encoded2.huffmanCodes.entrySet()) {
            System.out.println(entry.getKey() + ": " + entry.getValue());
        }
        System.out.println("编码结果: " + encoded2.encodedData);
        System.out.println("编码长度: " + encoded2.encodedData.length() + " 位");
        
        String decoded2 = decode(encoded2.encodedData, encoded2.huffmanCodes);
        System.out.println("解码结果: " + decoded2);
        System.out.println("编码解码是否正确: " + test2.equals(decoded2));
        System.out.println("压缩率: " + String.format("%.2f%%", 
            calculateCompressionRatio(test2.length() * 8, encoded2.encodedData.length())));
        System.out.println();
        
        // 测试用例3：随机字符串
        String test3 = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
        System.out.println("原始字符串: " + test3);
        System.out.println("原始长度: " + test3.length() + " 字符");
        
        EncodeResult encoded3 = encode(test3);
        System.out.println("Huffman编码表:");
        for (Map.Entry<Character, String> entry : encoded3.huffmanCodes.entrySet()) {
            System.out.println(entry.getKey() + ": " + entry.getValue());
        }
        System.out.println("编码结果: " + encoded3.encodedData);
        System.out.println("编码长度: " + encoded3.encodedData.length() + " 位");
        
        String decoded3 = decode(encoded3.encodedData, encoded3.huffmanCodes);
        System.out.println("解码结果: " + decoded3);
        System.out.println("编码解码是否正确: " + test3.equals(decoded3));
        System.out.println("压缩率: " + String.format("%.2f%%", 
            calculateCompressionRatio(test3.length() * 8, encoded3.encodedData.length())));
    }
}

===============================================

文件: HuffmanTree.java
===============================================
package class175.霍夫曼树;

import java.util.*;

/**
 * 霍夫曼树（Huffman Tree）实现类
 * 霍夫曼树是一种带权路径长度最短的二叉树，也称为最优二叉树
 * 
 * 常见应用场景：
 * 1. 数据压缩（霍夫曼编码）
 * 2. 文件压缩算法（如ZIP、GZIP等）
 * 3. 信息论中的最优编码
 * 4. 通讯中的数据传输优化
 * 5. 频率相关的排序和检索
 * 
 * 相关算法题目：
 * - LeetCode 1161. 最大层内元素和 https://leetcode.cn/problems/maximum-level-sum-of-a-binary-tree/
 * - LeetCode 1676. 二叉树的最近公共祖先 IV https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree-iv/
 * - LeetCode 199. 二叉树的右视图 https://leetcode.cn/problems/binary-tree-right-side-view/
 * - LintCode 913. 二叉树的序列化与反序列化 https://www.lintcode.com/problem/913/
 * - 洛谷 P1090 合并果子 https://www.luogu.com.cn/problem/P1090
 * - 牛客 NC139 数据流中的中位数 https://www.nowcoder.com/practice/9be0172896bd43948f8a32fb954e1be1
 * - HackerRank Huffman Coding https://www.hackerrank.com/challenges/tree-huffman-decoding/problem
 * - CodeChef HUFFMAN https://www.codechef.com/problems/HUFFMAN
 * - USACO Huffman Coding https://usaco.org/index.php?page=viewproblem2&cpid=689
 * - AtCoder ABC240 E - Ranges on Tree https://atcoder.jp/contests/abc240/tasks/abc240_e
 * - 杭电 OJ 1053 Entropy https://acm.hdu.edu.cn/showproblem.php?pid=1053
 */

class HuffmanNode {
    public char data;       // 字符数据
    public int frequency;   // 出现频率
    public HuffmanNode left; // 左子节点
    public HuffmanNode right; // 右子节点

    /**
     * 构造函数
     * @param data 字符数据
     * @param frequency 出现频率
     */
    public HuffmanNode(char data, int frequency) {
        this.data = data;
        this.frequency = frequency;
        this.left = null;
        this.right = null;
    }

    /**
     * 构造函数（用于内部节点）
     * @param frequency 出现频率
     */
    public HuffmanNode(int frequency) {
        this.data = ' ';
        this.frequency = frequency;
        this.left = null;
        this.right = null;
    }
}

public class HuffmanTree {
    private HuffmanNode root; // 霍夫曼树的根节点

    /**
     * 构造函数，通过字符频率表构建霍夫曼树
     * @param frequencyMap 字符频率映射表
     */
    public HuffmanTree(Map<Character, Integer> frequencyMap) {
        buildTree(frequencyMap);
    }

    /**
     * 构建霍夫曼树
     * @param frequencyMap 字符频率映射表
     */
    private void buildTree(Map<Character, Integer> frequencyMap) {
        // 创建优先队列（最小堆），按照频率排序
        PriorityQueue<HuffmanNode> pq = new PriorityQueue<>((a, b) -> a.frequency - b.frequency);

        // 将所有字符节点加入优先队列
        for (Map.Entry<Character, Integer> entry : frequencyMap.entrySet()) {
            pq.offer(new HuffmanNode(entry.getKey(), entry.getValue()));
        }

        // 构建霍夫曼树
        while (pq.size() > 1) {
            // 取出两个最小频率的节点
            HuffmanNode left = pq.poll();
            HuffmanNode right = pq.poll();

            // 创建新的内部节点，频率为两个子节点的频率之和
            HuffmanNode internalNode = new HuffmanNode(left.frequency + right.frequency);
            internalNode.left = left;
            internalNode.right = right;

            // 将内部节点加入队列
            pq.offer(internalNode);
        }

        // 队中只剩下根节点
        root = pq.poll();
    }

    /**
     * 获取霍夫曼编码表
     * @return 字符到霍夫曼编码的映射
     */
    public Map<Character, String> getHuffmanCodes() {
        Map<Character, String> codes = new HashMap<>();
        if (root != null) {
            generateCodes(root, "", codes);
        }
        return codes;
    }

    /**
     * 递归生成霍夫曼编码
     * @param node 当前节点
     * @param currentCode 当前编码
     * @param codes 编码映射表
     */
    private void generateCodes(HuffmanNode node, String currentCode, Map<Character, String> codes) {
        if (node == null) {
            return;
        }

        // 如果是叶子节点，保存编码
        if (node.left == null && node.right == null) {
            codes.put(node.data, currentCode.isEmpty() ? "0" : currentCode);
            return;
        }

        // 递归遍历左右子树
        generateCodes(node.left, currentCode + "0", codes);
        generateCodes(node.right, currentCode + "1", codes);
    }

    /**
     * 编码文本
     * @param text 原始文本
     * @return 霍夫曼编码后的二进制字符串
     */
    public String encode(String text) {
        Map<Character, String> codes = getHuffmanCodes();
        StringBuilder encoded = new StringBuilder();

        for (char c : text.toCharArray()) {
            if (codes.containsKey(c)) {
                encoded.append(codes.get(c));
            } else {
                throw new IllegalArgumentException("字符 " + c + " 不在霍夫曼树中");
            }
        }

        return encoded.toString();
    }

    /**
     * 解码二进制字符串
     * @param encoded 霍夫曼编码的二进制字符串
     * @return 解码后的文本
     */
    public String decode(String encoded) {
        StringBuilder decoded = new StringBuilder();
        HuffmanNode current = root;

        for (char bit : encoded.toCharArray()) {
            if (bit == '0') {
                current = current.left;
            } else if (bit == '1') {
                current = current.right;
            } else {
                throw new IllegalArgumentException("无效的二进制位: " + bit);
            }

            // 到达叶子节点
            if (current.left == null && current.right == null) {
                decoded.append(current.data);
                current = root; // 重置到根节点
            }
        }

        return decoded.toString();
    }

    /**
     * 计算霍夫曼树的带权路径长度（WPL）
     * @return 带权路径长度
     */
    public int calculateWPL() {
        return calculateWPL(root, 0);
    }

    /**
     * 递归计算带权路径长度
     * @param node 当前节点
     * @param depth 当前深度
     * @return 带权路径长度
     */
    private int calculateWPL(HuffmanNode node, int depth) {
        if (node == null) {
            return 0;
        }

        // 叶子节点
        if (node.left == null && node.right == null) {
            return node.frequency * depth;
        }

        // 内部节点，递归计算左右子树
        return calculateWPL(node.left, depth + 1) + calculateWPL(node.right, depth + 1);
    }

    /**
     * 打印霍夫曼树的结构
     */
    public void printTree() {
        System.out.println("霍夫曼树结构：");
        printTree(root, 0);
    }

    /**
     * 递归打印树结构
     * @param node 当前节点
     * @param level 当前层级
     */
    private void printTree(HuffmanNode node, int level) {
        if (node == null) {
            return;
        }

        // 打印右子树
        printTree(node.right, level + 1);

        // 打印当前节点
        for (int i = 0; i < level; i++) {
            System.out.print("    ");
        }
        if (node.data == ' ') {
            System.out.println("[内部] " + node.frequency);
        } else {
            System.out.println("['" + node.data + "'] " + node.frequency);
        }

        // 打印左子树
        printTree(node.left, level + 1);
    }

    /**
     * 获取树的高度
     * @return 树的高度
     */
    public int getHeight() {
        return getHeight(root);
    }

    /**
     * 递归计算树的高度
     * @param node 当前节点
     * @return 树的高度
     */
    private int getHeight(HuffmanNode node) {
        if (node == null) {
            return 0;
        }
        int leftHeight = getHeight(node.left);
        int rightHeight = getHeight(node.right);
        return Math.max(leftHeight, rightHeight) + 1;
    }

    /**
     * 统计叶子节点数量
     * @return 叶子节点数量
     */
    public int getLeafCount() {
        return getLeafCount(root);
    }

    /**
     * 递归统计叶子节点数量
     * @param node 当前节点
     * @return 叶子节点数量
     */
    private int getLeafCount(HuffmanNode node) {
        if (node == null) {
            return 0;
        }
        if (node.left == null && node.right == null) {
            return 1;
        }
        return getLeafCount(node.left) + getLeafCount(node.right);
    }

    /**
     * 根据文本自动构建频率表并创建霍夫曼树
     * @param text 输入文本
     * @return 构建的霍夫曼树
     */
    public static HuffmanTree buildFromText(String text) {
        // 统计字符频率
        Map<Character, Integer> frequencyMap = new HashMap<>();
        for (char c : text.toCharArray()) {
            frequencyMap.put(c, frequencyMap.getOrDefault(c, 0) + 1);
        }
        return new HuffmanTree(frequencyMap);
    }

    /**
     * 获取根节点
     * @return 根节点
     */
    public HuffmanNode getRoot() {
        return root;
    }

    /**
     * 检查两棵霍夫曼树是否相同
     * @param other 另一棵霍夫曼树
     * @return 如果相同返回true，否则返回false
     */
    public boolean equals(HuffmanTree other) {
        if (other == null) {
            return false;
        }
        return equals(root, other.getRoot());
    }

    /**
     * 递归比较两棵子树是否相同
     * @param node1 第一棵树的节点
     * @param node2 第二棵树的节点
     * @return 如果相同返回true，否则返回false
     */
    private boolean equals(HuffmanNode node1, HuffmanNode node2) {
        if (node1 == null && node2 == null) {
            return true;
        }
        if (node1 == null || node2 == null) {
            return false;
        }
        // 比较当前节点的频率
        if (node1.frequency != node2.frequency) {
            return false;
        }
        // 如果是叶子节点，还需要比较字符
        if (node1.left == null && node1.right == null && node2.left == null && node2.right == null) {
            return node1.data == node2.data;
        }
        // 递归比较左右子树
        return equals(node1.left, node2.left) && equals(node1.right, node2.right);
    }

    /**
     * 层序遍历霍夫曼树
     * @return 层序遍历结果
     */
    public List<List<String>> levelOrderTraversal() {
        List<List<String>> result = new ArrayList<>();
        if (root == null) {
            return result;
        }

        Queue<HuffmanNode> queue = new LinkedList<>();
        queue.offer(root);

        while (!queue.isEmpty()) {
            int levelSize = queue.size();
            List<String> currentLevel = new ArrayList<>();

            for (int i = 0; i < levelSize; i++) {
                HuffmanNode node = queue.poll();
                if (node.data == ' ') {
                    currentLevel.add("[内部] " + node.frequency);
                } else {
                    currentLevel.add("['" + node.data + "'] " + node.frequency);
                }

                if (node.left != null) {
                    queue.offer(node.left);
                }
                if (node.right != null) {
                    queue.offer(node.right);
                }
            }

            result.add(currentLevel);
        }

        return result;
    }

    /**
     * 计算压缩率
     * @param originalText 原始文本
     * @return 压缩率（压缩后大小/原始大小）
     */
    public double getCompressionRatio(String originalText) {
        // 假设原始文本每个字符占用8位
        int originalSize = originalText.length() * 8;
        
        // 计算压缩后的大小（以位为单位）
        String encoded = encode(originalText);
        int compressedSize = encoded.length();
        
        return (double) compressedSize / originalSize;
    }

    /**
     * 主方法，用于测试
     */
    public static void main(String[] args) {
        // 测试数据：字符及其频率
        Map<Character, Integer> frequencyMap = new HashMap<>();
        frequencyMap.put('a', 5);
        frequencyMap.put('b', 9);
        frequencyMap.put('c', 12);
        frequencyMap.put('d', 13);
        frequencyMap.put('e', 16);
        frequencyMap.put('f', 45);

        // 创建霍夫曼树
        HuffmanTree huffmanTree = new HuffmanTree(frequencyMap);

        // 打印树结构
        huffmanTree.printTree();

        // 获取霍夫曼编码
        Map<Character, String> codes = huffmanTree.getHuffmanCodes();
        System.out.println("\n霍夫曼编码：");
        for (Map.Entry<Character, String> entry : codes.entrySet()) {
            System.out.println(entry.getKey() + ": " + entry.getValue());
        }

        // 计算WPL
        System.out.println("\n带权路径长度(WPL): " + huffmanTree.calculateWPL());

        // 计算树高和叶子节点数
        System.out.println("树高: " + huffmanTree.getHeight());
        System.out.println("叶子节点数: " + huffmanTree.getLeafCount());

        // 层序遍历
        System.out.println("\n层序遍历：");
        List<List<String>> levelOrder = huffmanTree.levelOrderTraversal();
        for (int i = 0; i < levelOrder.size(); i++) {
            System.out.println("层 " + (i + 1) + ": " + levelOrder.get(i));
        }

        // 测试编码和解码
        String text = "abcdef"; // 测试文本
        try {
            String encoded = huffmanTree.encode(text);
            String decoded = huffmanTree.decode(encoded);
            
            System.out.println("\n原始文本: " + text);
            System.out.println("编码后: " + encoded);
            System.out.println("解码后: " + decoded);
            System.out.println("编码解码一致性: " + text.equals(decoded));
            System.out.println("压缩率: " + huffmanTree.getCompressionRatio(text));
        } catch (Exception e) {
            System.out.println("错误: " + e.getMessage());
        }

        // 测试从文本构建霍夫曼树
        System.out.println("\n从文本构建霍夫曼树：");
        String testText = "hello huffman coding!";  
        HuffmanTree treeFromText = HuffmanTree.buildFromText(testText);
        Map<Character, String> codesFromText = treeFromText.getHuffmanCodes();
        System.out.println("文本霍夫曼编码：");
        for (Map.Entry<Character, String> entry : codesFromText.entrySet()) {
            System.out.println("'" + entry.getKey() + "'"); // 打印键
            System.out.println(" : " + entry.getValue()); // 打印值
        }
        
        // 测试编码解码
        String encodedText = treeFromText.encode(testText);
        String decodedText = treeFromText.decode(encodedText);
        System.out.println("\n原始文本长度: " + testText.length() + " 字符");
        System.out.println("编码后长度: " + encodedText.length() + " 位");
        System.out.println("解码后: " + decodedText);
        System.out.println("解码正确性: " + testText.equals(decodedText));
        System.out.println("压缩率: " + treeFromText.getCompressionRatio(testText));
    }
}

===============================================

文件: huffman_coding.cpp
===============================================
/**
 * Huffman编码实现 (C++简化版本)
 * 
 * Huffman编码是一种无损数据压缩算法，它根据字符出现频率构建最优二叉树，
 * 使得出现频率高的字符具有较短的编码，出现频率低的字符具有较长的编码。
 * 
 * 算法原理：
 * 1. 统计字符频率
 * 2. 构建Huffman树：每次选择频率最小的两个节点合并
 * 3. 生成编码表：从根节点到叶节点的路径即为字符的编码
 * 4. 编码和解码过程
 * 
 * 时间复杂度：
 * - 构建Huffman树：O(n log n)，其中n是不同字符的数量
 * - 编码/解码：O(m)，其中m是字符串长度
 * 
 * 空间复杂度：O(n)
 * 
 * 优势：
 * 1. 压缩率高，能够达到信息熵的理论极限
 * 2. 实现相对简单
 * 3. 适合处理具有明显统计特性的数据
 * 
 * 劣势：
 * 1. 需要两次扫描数据（一次统计频率，一次编码）
 * 2. 对于频率分布均匀的数据压缩效果不佳
 * 3. 编码和解码需要相同的Huffman树
 * 
 * 应用场景：
 * 1. 文件压缩（如ZIP格式）
 * 2. 图像压缩（如JPEG）
 * 3. 音频压缩
 */

// 定义最大字符数和相关常量
#define MAX_CHARS 256
#define MAX_NODES 512
#define NULL 0

/**
 * Huffman树节点
 * 
 * 使用数组索引方式表示树结构，避免指针操作
 * character: 节点表示的字符（仅叶节点有效，内部节点为'\0'）
 * frequency: 字符出现的频率（节点权重）
 * left: 左子树在节点数组中的索引（-1表示无左子树）
 * right: 右子树在节点数组中的索引（-1表示无右子树）
 */
typedef struct {
    char character;      // 字符（叶节点有效）
    int frequency;       // 频率
    int left;            // 左子树索引（-1表示无左子树）
    int right;           // 右子树索引（-1表示无右子树）
} Node;

/**
 * Huffman编码器
 * 
 * 使用结构体封装Huffman编码所需的所有数据结构
 * nodes: 节点数组，存储所有Huffman树节点
 * nodeCount: 当前节点数量
 * root: Huffman树根节点在数组中的索引（-1表示空树）
 * codes: 字符到编码的映射表，使用二维数组存储每个字符的编码
 * codeLengths: 每个字符编码的长度，用于提高编码效率
 */
typedef struct {
    Node nodes[MAX_NODES];     // 节点数组，存储所有Huffman树节点
    int nodeCount;             // 节点数量
    int root;                  // 根节点索引（-1表示空树）
    char codes[MAX_CHARS][MAX_CHARS]; // 字符到编码的映射表
    int codeLengths[MAX_CHARS];       // 每个字符编码的长度
} HuffmanCoding;

/**
 * 初始化Huffman编码器
 * 
 * 将Huffman编码器的所有成员变量初始化为默认值
 * nodeCount设置为0，表示还没有节点
 * root设置为-1，表示空树
 * codes数组清空，codeLengths数组置零
 * 
 * @param hc 指向Huffman编码器结构体的指针
 */
void initHuffmanCoding(HuffmanCoding* hc) {
    // 初始化节点计数器
    hc->nodeCount = 0;
    // 初始化根节点索引为-1（表示空树）
    hc->root = -1;
    // 初始化编码表和编码长度数组
    for (int i = 0; i < MAX_CHARS; i++) {
        // 将每个字符的编码设置为空字符串
        hc->codes[i][0] = '\0';
        // 将每个字符的编码长度设置为0
        hc->codeLengths[i] = 0;
    }
}

/**
 * 优先队列（最小堆）实现
 * 
 * 使用数组实现的最小堆，用于高效获取频率最小的节点索引
 * data: 存储节点索引的数组
 * size: 当前队列中的元素数量
 */
typedef struct {
    int data[MAX_NODES];  // 存储节点索引的数组
    int size;             // 当前队列中的元素数量
} PriorityQueue;

/**
 * 初始化优先队列
 * 
 * 将优先队列的大小设置为0，表示空队列
 * 
 * @param pq 指向优先队列结构体的指针
 */
void initPriorityQueue(PriorityQueue* pq) {
    pq->size = 0;
}

/**
 * 向优先队列添加元素
 * 
 * 将元素添加到队列末尾，然后通过上浮调整维护堆性质
 * 时间复杂度：O(log n)
 * 
 * @param pq 指向优先队列结构体的指针
 * @param value 要添加的元素（节点索引）
 */
void pushPriorityQueue(PriorityQueue* pq, int value) {
    // 检查队列是否已满
    if (pq->size >= MAX_NODES) return;
    
    // 将元素添加到队列末尾
    pq->data[pq->size] = value;
    pq->size++;
    
    // 上浮调整：维护最小堆性质
    int i = pq->size - 1;
    while (i > 0) {
        // 计算父节点索引
        int parent = (i - 1) / 2;
        // 如果父节点不大于当前节点，调整结束
        if (pq->data[parent] <= pq->data[i]) break;
        // 交换当前节点与父节点
        int temp = pq->data[parent];
        pq->data[parent] = pq->data[i];
        pq->data[i] = temp;
        // 继续向上调整
        i = parent;
    }
}

/**
 * 从优先队列取出最小元素
 * 
 * 取出堆顶元素（最小值），然后通过下沉调整维护堆性质
 * 时间复杂度：O(log n)
 * 
 * @param pq 指向优先队列结构体的指针
 * @return 堆顶元素（最小值），如果队列为空则返回-1
 */
int popPriorityQueue(PriorityQueue* pq) {
    // 检查队列是否为空
    if (pq->size <= 0) return -1;
    
    // 取出堆顶元素
    int result = pq->data[0];
    pq->size--;
    
    // 如果队列不为空，需要调整堆结构
    if (pq->size > 0) {
        // 将最后一个元素移到堆顶
        pq->data[0] = pq->data[pq->size];
        
        // 下沉调整：维护最小堆性质
        int i = 0;
        while (1) {
            // 计算左右子节点索引
            int left = 2 * i + 1;
            int right = 2 * i + 2;
            int smallest = i;
            
            // 找到当前节点及其子节点中的最小值
            if (left < pq->size && pq->data[left] < pq->data[smallest]) {
                smallest = left;
            }
            if (right < pq->size && pq->data[right] < pq->data[smallest]) {
                smallest = right;
            }
            
            // 如果当前节点已经是最小的，调整结束
            if (smallest == i) break;
            
            // 交换当前节点与最小节点
            int temp = pq->data[i];
            pq->data[i] = pq->data[smallest];
            pq->data[smallest] = temp;
            // 继续向下调整
            i = smallest;
        }
    }
    
    return result;
}

/**
 * 创建新节点（叶节点）
 * 
 * 创建一个新的叶节点，用于表示输入字符串中的字符
 * 
 * @param hc 指向Huffman编码器结构体的指针
 * @param character 节点表示的字符
 * @param frequency 字符出现的频率
 * @return 新节点在数组中的索引，如果节点数组已满则返回-1
 */
int createNode(HuffmanCoding* hc, char character, int frequency) {
    // 检查节点数组是否已满
    if (hc->nodeCount >= MAX_NODES) return -1;
    
    // 获取新节点的索引
    int index = hc->nodeCount;
    // 初始化节点属性
    hc->nodes[index].character = character;
    hc->nodes[index].frequency = frequency;
    hc->nodes[index].left = -1;   // 叶节点无左子树
    hc->nodes[index].right = -1;  // 叶节点无右子树
    // 增加节点计数器
    hc->nodeCount++;
    return index;
}

/**
 * 创建内部节点
 * 
 * 创建一个新的内部节点，作为两个子节点的父节点
 * 频率为两个子节点频率之和
 * 
 * @param hc 指向Huffman编码器结构体的指针
 * @param left 左子节点的索引
 * @param right 右子节点的索引
 * @return 新节点在数组中的索引，如果节点数组已满则返回-1
 */
int createInternalNode(HuffmanCoding* hc, int left, int right) {
    // 检查节点数组是否已满
    if (hc->nodeCount >= MAX_NODES) return -1;
    
    // 获取新节点的索引
    int index = hc->nodeCount;
    // 初始化内部节点属性
    hc->nodes[index].character = '\0';  // 内部节点无字符
    // 内部节点频率等于两个子节点频率之和
    hc->nodes[index].frequency = hc->nodes[left].frequency + hc->nodes[right].frequency;
    hc->nodes[index].left = left;   // 设置左子树
    hc->nodes[index].right = right; // 设置右子树
    // 增加节点计数器
    hc->nodeCount++;
    return index;
}

/**
 * 判断是否为叶节点
 * 
 * 叶节点是没有子树的节点，用于存储实际字符
 * 在数组表示的树结构中，左右子树索引都为-1表示叶节点
 * 
 * @param hc 指向Huffman编码器结构体的指针
 * @param nodeIndex 要判断的节点索引
 * @return 非0值表示是叶节点，0表示不是叶节点
 */
int isLeaf(HuffmanCoding* hc, int nodeIndex) {
    // 当节点的左右子树索引都为-1时，表示叶节点
    return hc->nodes[nodeIndex].left == -1 && hc->nodes[nodeIndex].right == -1;
}

/**
 * 构建Huffman树
 * 
 * 使用贪心算法构建最优二叉树，使得带权路径长度最小
 * 算法步骤：
 * 1. 统计输入字符串中各字符的出现频率
 * 2. 将所有字符节点放入优先队列（最小堆）
 * 3. 重复以下操作直到队列中只剩一个节点：
 *    a. 取出频率最小的两个节点
 *    b. 创建新节点作为它们的父节点，频率为两子节点频率之和
 *    c. 将新节点放回优先队列
 * 4. 剩下的唯一节点即为Huffman树的根节点
 * 
 * @param hc 指向Huffman编码器结构体的指针
 * @param input 输入字符串
 */
void buildHuffmanTree(HuffmanCoding* hc, const char* input) {
    // 统计字符频率：遍历字符串，使用数组记录每个字符的出现次数
    int frequency[MAX_CHARS] = {0};
    int inputLen = 0;
    
    // 遍历输入字符串统计字符频率
    while (input[inputLen] != '\0') {
        // 使用unsigned char避免负数索引问题
        frequency[(unsigned char)input[inputLen]]++;
        inputLen++;
    }
    
    // 创建优先队列（最小堆）：用于高效获取频率最小的节点
    PriorityQueue pq;
    initPriorityQueue(&pq);
    
    // 为每个出现过的字符创建节点并加入优先队列
    for (int i = 0; i < MAX_CHARS; i++) {
        if (frequency[i] > 0) {
            // 创建叶节点
            int nodeIndex = createNode(hc, (char)i, frequency[i]);
            // 检查节点创建是否成功
            if (nodeIndex != -1) {
                // 将节点索引加入优先队列
                pushPriorityQueue(&pq, nodeIndex);
            }
        }
    }
    
    // 特殊情况处理：当输入字符串只包含一种字符时
    // 为了避免编码歧义，需要构造一个高度为2的树
    if (pq.size == 1) {
        int nodeIndex = popPriorityQueue(&pq);
        // 构造一个根节点，其右子树为原节点
        int internalIndex = createInternalNode(hc, -1, nodeIndex);
        hc->root = internalIndex;
        return;
    }
    
    // 构建Huffman树：贪心算法的核心实现
    // 每次从优先队列中取出频率最小的两个节点，合并为新节点后再放回队列
    while (pq.size > 1) {
        // 取出频率最小的两个节点作为左右子树
        int left = popPriorityQueue(&pq);   // 较小频率的节点作为左子树
        int right = popPriorityQueue(&pq);  // 较大频率的节点作为右子树
        // 创建父节点，频率为两个子节点频率之和
        int parent = createInternalNode(hc, left, right);
        // 将新节点放回优先队列
        pushPriorityQueue(&pq, parent);
    }
    
    // 最后剩下的节点即为Huffman树的根节点
    if (pq.size > 0) {
        hc->root = popPriorityQueue(&pq);
    }
}

/**
 * 递归构建编码表
 * 
 * 使用深度优先遍历Huffman树，为每个叶节点生成对应的二进制编码
 * 编码规则：
 * - 向左子树移动时，在编码末尾添加'0'
 * - 向右子树移动时，在编码末尾添加'1'
 * - 到达叶节点时，将字符与编码的映射关系保存到编码表中
 * 
 * @param hc 指向Huffman编码器结构体的指针
 * @param nodeIndex 当前遍历到的节点索引
 * @param code 从根节点到当前节点的路径编码
 * @param codeLen 当前编码的长度
 */
void buildCodeTableRecursive(HuffmanCoding* hc, int nodeIndex, char* code, int codeLen) {
    // 递归终止条件：节点索引无效
    if (nodeIndex == -1) return;
    
    // 叶节点处理：保存字符到编码的映射关系
    if (isLeaf(hc, nodeIndex)) {
        // 在编码末尾添加字符串结束符
        code[codeLen] = '\0';
        // 获取叶节点表示的字符
        hc->nodes[nodeIndex].character;
        unsigned char ch = (unsigned char)hc->nodes[nodeIndex].character;
        // 将编码复制到编码表中
        for (int i = 0; i < codeLen; i++) {
            hc->codes[ch][i] = code[i];
        }
        hc->codes[ch][codeLen] = '\0';
        // 保存编码长度，提高编码效率
        hc->codeLengths[ch] = codeLen;
        return;
    }
    
    // 递归处理左右子树
    // 向左子树移动时，在编码末尾添加'0'
    if (hc->nodes[nodeIndex].left != -1) {
        code[codeLen] = '0';
        buildCodeTableRecursive(hc, hc->nodes[nodeIndex].left, code, codeLen + 1);
    }
    
    // 向右子树移动时，在编码末尾添加'1'
    if (hc->nodes[nodeIndex].right != -1) {
        code[codeLen] = '1';
        buildCodeTableRecursive(hc, hc->nodes[nodeIndex].right, code, codeLen + 1);
    }
}

/**
 * 构建编码表
 * 
 * 通过遍历Huffman树为每个字符生成对应的二进制编码
 * 编码规则：从根节点到叶节点的路径，左子树为'0'，右子树为'1'
 * 
 * @param hc 指向Huffman编码器结构体的指针
 */
void buildCodeTable(HuffmanCoding* hc) {
    // 检查Huffman树是否为空
    if (hc->root == -1) return;
    
    // 创建临时编码缓冲区
    char code[MAX_CHARS];
    // 从根节点开始递归构建编码表，初始编码长度为0
    buildCodeTableRecursive(hc, hc->root, code, 0);
}

/**
 * Huffman编码
 * 
 * 将输入字符串转换为Huffman编码的二进制字符串
 * 时间复杂度：O(m)，其中m是输入字符串的长度
 * 空间复杂度：O(k)，其中k是编码后字符串的长度
 * 
 * @param hc 指向Huffman编码器结构体的指针
 * @param input 待编码的输入字符串
 * @param output 编码后的二进制字符串（需要预先分配足够空间）
 */
void encode(HuffmanCoding* hc, const char* input, char* output) {
    // 初始化输出字符串为空
    output[0] = '\0';
    // 输出字符串的当前位置索引
    int outputIndex = 0;
    
    // 遍历输入字符串中的每个字符
    int i = 0;
    while (input[i] != '\0') {
        // 获取当前字符（使用unsigned char避免负数问题）
        unsigned char ch = (unsigned char)input[i];
        // 从预计算的编码长度数组中获取编码长度
        int len = hc->codeLengths[ch];
        
        // 将字符对应的编码复制到输出字符串中
        for (int j = 0; j < len; j++) {
            output[outputIndex++] = hc->codes[ch][j];
        }
        i++;
    }
    
    // 在输出字符串末尾添加结束符
    output[outputIndex] = '\0';
}

/**
 * Huffman解码
 * 
 * 将Huffman编码的二进制字符串转换回原始字符串
 * 解码过程：从根节点开始，根据编码中的每一位（0或1）在Huffman树中移动
 * 当到达叶节点时，输出对应的字符并重新从根节点开始
 * 时间复杂度：O(k)，其中k是编码字符串的长度
 * 空间复杂度：O(m)，其中m是解码后字符串的长度
 * 
 * @param hc 指向Huffman编码器结构体的指针
 * @param encoded Huffman编码的二进制字符串
 * @param output 解码后的原始字符串（需要预先分配足够空间）
 */
void decode(HuffmanCoding* hc, const char* encoded, char* output) {
    // 初始化输出字符串为空
    output[0] = '\0';
    // 输出字符串的当前位置索引
    int outputIndex = 0;
    // 当前在Huffman树中的位置，初始为根节点
    int currentNode = hc->root;
    
    // 遍历编码字符串中的每一位
    int i = 0;
    while (encoded[i] != '\0' && currentNode != -1) {
        // 根据当前位的值在Huffman树中移动
        if (encoded[i] == '0') {
            // 遇到'0'，向左子树移动
            currentNode = hc->nodes[currentNode].left;
        } else {
            // 遇到'1'，向右子树移动
            currentNode = hc->nodes[currentNode].right;
        }
        
        // 安全检查：确保当前节点有效
        if (currentNode == -1) {
            // 如果节点无效，可能是编码错误或树结构问题
            break;
        }
        
        // 到达叶节点：输出字符并重新从根节点开始
        if (isLeaf(hc, currentNode)) {
            output[outputIndex++] = hc->nodes[currentNode].character;
            currentNode = hc->root;
        }
        
        i++;
    }
    
    // 在输出字符串末尾添加结束符
    output[outputIndex] = '\0';
}

/**
 * 计算压缩率
 */
double calculateCompressionRatio(int original, int compressed) {
    if (original == 0) return 0;
    return (1.0 - (double) compressed / original) * 100;
}

// 由于环境限制，不包含main函数和输出语句
// 算法核心功能已实现，可被其他程序调用

===============================================

文件: huffman_coding.py
===============================================
#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
Huffman编码实现 (Python版本)

Huffman编码是一种无损数据压缩算法，它根据字符出现频率构建最优二叉树，
使得出现频率高的字符具有较短的编码，出现频率低的字符具有较长的编码。

算法原理：
1. 统计字符频率
2. 构建Huffman树：每次选择频率最小的两个节点合并
3. 生成编码表：从根节点到叶节点的路径即为字符的编码
4. 编码和解码过程

时间复杂度：
- 构建Huffman树：O(n log n)，其中n是不同字符的数量
- 编码/解码：O(m)，其中m是字符串长度

空间复杂度：O(n)

优势：
1. 压缩率高，能够达到信息熵的理论极限
2. 实现相对简单
3. 适合处理具有明显统计特性的数据

劣势：
1. 需要两次扫描数据（一次统计频率，一次编码）
2. 对于频率分布均匀的数据压缩效果不佳
3. 编码和解码需要相同的Huffman树

应用场景：
1. 文件压缩（如ZIP格式）
2. 图像压缩（如JPEG）
3. 音频压缩
"""

import heapq
from collections import defaultdict, Counter
from typing import Dict, Tuple, Optional

class HuffmanCoding:
    """Huffman编码实现"""
    
    class Node:
        """Huffman树节点
        
        用于表示Huffman树中的节点，包含字符、频率以及左右子树的引用
        """
        
        def __init__(self, character: Optional[str] = None, frequency: int = 0):
            """
            初始化Huffman树节点
            
            :param character: 节点表示的字符（仅叶节点有效，内部节点为None）
            :param frequency: 字符出现的频率（节点权重）
            """
            self.character = character      # 字符（仅叶节点有效，内部节点为None）
            self.frequency = frequency      # 频率（节点权重）
            self.left: Optional['HuffmanCoding.Node'] = None   # 左子树引用
            self.right: Optional['HuffmanCoding.Node'] = None  # 右子树引用
        
        def is_leaf(self) -> bool:
            """
            判断是否为叶节点
            叶节点是没有子树的节点，用于存储实际字符
            
            :return: True表示是叶节点，False表示是内部节点
            """
            return self.left is None and self.right is None
        
        def __lt__(self, other: 'HuffmanCoding.Node') -> bool:
            """
            实现小于比较操作，用于优先队列排序
            按照频率升序排列，频率相同时按照字符排序
            
            :param other: 待比较的节点
            :return: 比较结果
            """
            # 首先按照频率比较
            if self.frequency != other.frequency:
                return self.frequency < other.frequency
            # 频率相同时按照字符比较，确保一致性
            if self.character is None:
                return True
            if other.character is None:
                return False
            return self.character < other.character
    
    def __init__(self, input_string: str):
        """
        构造函数，根据输入字符串构建Huffman树和编码表
        这是Huffman编码的核心初始化方法，完成整个编码系统的构建
        
        :param input_string: 输入字符串，用于统计字符频率并构建Huffman树
        """
        # 初始化Huffman树根节点和编码表
        self.root: Optional[HuffmanCoding.Node] = None
        self.codes: Dict[str, str] = {}
        # 第一步：根据输入字符串构建Huffman树
        self.build_huffman_tree(input_string)
        # 第二步：根据构建好的Huffman树生成编码表
        self.build_code_table()
    
    def build_huffman_tree(self, input_string: str) -> None:
        """
        构建Huffman树
        使用贪心算法构建最优二叉树，使得带权路径长度最小
        算法步骤：
        1. 统计输入字符串中各字符的出现频率
        2. 将所有字符节点放入优先队列（最小堆）
        3. 重复以下操作直到队列中只剩一个节点：
           a. 取出频率最小的两个节点
           b. 创建新节点作为它们的父节点，频率为两子节点频率之和
           c. 将新节点放回优先队列
        4. 剩下的唯一节点即为Huffman树的根节点
        
        :param input_string: 输入字符串
        """
        # 统计字符频率：使用Counter高效统计每个字符的出现次数
        frequency_map = Counter(input_string)
        
        # 创建优先队列（最小堆）：用于高效获取频率最小的节点
        # 使用heapq模块实现最小堆，heappush和heappop保证了堆的性质
        pq = []
        for char, freq in frequency_map.items():
            heapq.heappush(pq, HuffmanCoding.Node(char, freq))
        
        # 特殊情况处理：当输入字符串只包含一种字符时
        # 为了避免编码歧义，需要构造一个高度为2的树
        if len(pq) == 1:
            node = heapq.heappop(pq)
            # 构造一个根节点，其右子树为原节点
            self.root = HuffmanCoding.Node()
            self.root.right = node
            return
        
        # 构建Huffman树：贪心算法的核心实现
        # 每次从优先队列中取出频率最小的两个节点，合并为新节点后再放回队列
        while len(pq) > 1:
            # 取出频率最小的两个节点作为左右子树
            left = heapq.heappop(pq)   # 较小频率的节点作为左子树
            right = heapq.heappop(pq)  # 较大频率的节点作为右子树
            # 创建父节点，频率为两个子节点频率之和
            parent = HuffmanCoding.Node()
            parent.frequency = left.frequency + right.frequency
            parent.left = left
            parent.right = right
            # 将新节点放回优先队列
            heapq.heappush(pq, parent)
        
        # 最后剩下的节点即为Huffman树的根节点
        self.root = heapq.heappop(pq)
    
    def build_code_table(self) -> None:
        """
        构建编码表
        通过遍历Huffman树为每个字符生成对应的二进制编码
        编码规则：从根节点到叶节点的路径，左子树为'0'，右子树为'1'
        """
        # 初始化编码表
        self.codes = {}
        # 从根节点开始递归构建编码表，初始编码为空字符串
        self._build_code_table(self.root, "")
    
    def _build_code_table(self, node: Optional['HuffmanCoding.Node'], code: str) -> None:
        """
        递归构建编码表
        使用深度优先遍历Huffman树，为每个叶节点生成对应的二进制编码
        编码规则：
        - 向左子树移动时，在编码末尾添加'0'
        - 向右子树移动时，在编码末尾添加'1'
        - 到达叶节点时，将字符与编码的映射关系保存到编码表中
        
        :param node: 当前遍历到的节点
        :param code: 从根节点到当前节点的路径编码
        """
        # 递归终止条件：节点为空
        if node is None:
            return
        
        # 叶节点处理：保存字符到编码的映射关系
        if node.is_leaf():
            # 确保character不为None（安全检查）
            if node.character is not None:
                # 特殊情况处理：当只有一个字符时，编码为"0"而非空字符串
                # 这是为了避免解码时出现歧义
                if not code:  # 特殊情况：只有一个字符
                    self.codes[node.character] = "0"
                else:
                    self.codes[node.character] = code
            return
        
        # 递归处理左右子树
        # 向左子树移动时，在编码末尾添加'0'
        self._build_code_table(node.left, code + "0")
        # 向右子树移动时，在编码末尾添加'1'
        self._build_code_table(node.right, code + "1")
    
    def encode(self, input_string: str) -> str:
        """
        Huffman编码
        将输入字符串转换为Huffman编码的二进制字符串
        时间复杂度：O(m)，其中m是输入字符串的长度
        空间复杂度：O(k)，其中k是编码后字符串的长度
        
        :param input_string: 待编码的输入字符串
        :return: 编码后的二进制字符串
        :raises KeyError: 如果输入字符串中包含未在编码表中的字符
        """
        # 使用列表存储编码结果，提高字符串拼接效率
        encoded = []
        # 遍历输入字符串中的每个字符
        for char in input_string:
            # 从编码表中获取字符对应的编码并添加到结果中
            code = self.codes[char]
            # 异常处理：检查字符是否在编码表中存在
            if code is None:
                raise KeyError(f"字符 '{char}' 未在编码表中找到")
            encoded.append(code)
        # 使用join方法高效拼接所有编码
        return "".join(encoded)
    
    def decode(self, encoded: str) -> str:
        """
        Huffman解码
        将Huffman编码的二进制字符串转换回原始字符串
        解码过程：从根节点开始，根据编码中的每一位（0或1）在Huffman树中移动
        当到达叶节点时，输出对应的字符并重新从根节点开始
        时间复杂度：O(k)，其中k是编码字符串的长度
        空间复杂度：O(m)，其中m是解码后字符串的长度
        
        :param encoded: Huffman编码的二进制字符串
        :return: 解码后的原始字符串
        :raises ValueError: 如果编码字符串包含非法字符（非0/1）
        :raises RuntimeError: 如果Huffman树结构错误或编码不完整
        """
        # 使用列表存储解码结果，提高字符串拼接效率
        decoded = []
        # 当前在Huffman树中的位置，初始为根节点
        current = self.root
        
        # 遍历编码字符串中的每一位
        for bit in encoded:
            # 安全检查：确保当前节点不为空
            if current is None:
                raise RuntimeError("Huffman树结构错误或编码不完整")
                
            # 根据当前位的值在Huffman树中移动
            if bit == "0":
                # 遇到'0'，向左子树移动
                current = current.left
            elif bit == "1":
                # 遇到'1'，向右子树移动
                current = current.right
            else:
                # 异常处理：编码字符串包含非法字符
                raise ValueError(f"非法字符 '{bit}' 在编码中")
            
            # 到达叶节点：输出字符并重新从根节点开始
            if current is not None and current.is_leaf():
                # 确保character不为None（安全检查）
                if current.character is not None:
                    decoded.append(current.character)
                current = self.root
        
        # 返回解码结果
        return "".join(decoded)
    
    def get_code_table(self) -> Dict[str, str]:
        """
        获取编码表
        :return: 编码表
        """
        return self.codes.copy()
    
    @staticmethod
    def calculate_compression_ratio(original: int, compressed: int) -> float:
        """
        计算压缩率
        :param original: 原始数据大小（位）
        :param compressed: 压缩后数据大小（位）
        :return: 压缩率（百分比）
        """
        if original == 0:
            return 0
        return (1.0 - compressed / original) * 100
    
    @staticmethod
    def get_frequency_map(input_string: str) -> Dict[str, int]:
        """
        获取字符频率映射
        :param input_string: 输入字符串
        :return: 字符频率映射
        """
        return dict(Counter(input_string))


def main():
    """测试方法"""
    # 测试用例1：包含重复字符的字符串
    test1 = "ABRACADABRA"
    print(f"原始字符串: {test1}")
    print(f"字符频率: {HuffmanCoding.get_frequency_map(test1)}")
    
    hc1 = HuffmanCoding(test1)
    encoded1 = hc1.encode(test1)
    decoded1 = hc1.decode(encoded1)
    
    print(f"编码表: {hc1.get_code_table()}")
    print(f"编码结果: {encoded1}")
    print(f"解码结果: {decoded1}")
    print(f"编码解码是否正确: {test1 == decoded1}")
    print(f"原始大小: {len(test1) * 8} 位")
    print(f"压缩后大小: {len(encoded1)} 位")
    print(f"压缩率: {HuffmanCoding.calculate_compression_ratio(len(test1) * 8, len(encoded1)):.2f}%")
    print()
    
    # 测试用例2：更复杂的字符串
    test2 = "MISSISSIPPI"
    print(f"原始字符串: {test2}")
    print(f"字符频率: {HuffmanCoding.get_frequency_map(test2)}")
    
    hc2 = HuffmanCoding(test2)
    encoded2 = hc2.encode(test2)
    decoded2 = hc2.decode(encoded2)
    
    print(f"编码表: {hc2.get_code_table()}")
    print(f"编码结果: {encoded2}")
    print(f"解码结果: {decoded2}")
    print(f"编码解码是否正确: {test2 == decoded2}")
    print(f"原始大小: {len(test2) * 8} 位")
    print(f"压缩后大小: {len(encoded2)} 位")
    print(f"压缩率: {HuffmanCoding.calculate_compression_ratio(len(test2) * 8, len(encoded2)):.2f}%")
    print()
    
    # 测试用例3：均匀分布的字符串
    test3 = "ABCDEFGH"
    print(f"原始字符串: {test3}")
    print(f"字符频率: {HuffmanCoding.get_frequency_map(test3)}")
    
    hc3 = HuffmanCoding(test3)
    encoded3 = hc3.encode(test3)
    decoded3 = hc3.decode(encoded3)
    
    print(f"编码表: {hc3.get_code_table()}")
    print(f"编码结果: {encoded3}")
    print(f"解码结果: {decoded3}")
    print(f"编码解码是否正确: {test3 == decoded3}")
    print(f"原始大小: {len(test3) * 8} 位")
    print(f"压缩后大小: {len(encoded3)} 位")
    print(f"压缩率: {HuffmanCoding.calculate_compression_ratio(len(test3) * 8, len(encoded3)):.2f}%")
    print()
    
    # 测试用例4：边界情况 - 空字符串
    test4 = ""
    print(f"原始字符串: '{test4}'")
    try:
        hc4 = HuffmanCoding(test4)
        print("空字符串测试: 通过")
    except Exception as e:
        print(f"空字符串测试: 异常 - {e}")
    print()
    
    # 测试用例5：边界情况 - 单字符重复
    test5 = "AAAAAAA"
    print(f"原始字符串: {test5}")
    print(f"字符频率: {HuffmanCoding.get_frequency_map(test5)}")
    
    hc5 = HuffmanCoding(test5)
    encoded5 = hc5.encode(test5)
    decoded5 = hc5.decode(encoded5)
    
    print(f"编码表: {hc5.get_code_table()}")
    print(f"编码结果: {encoded5}")
    print(f"解码结果: {decoded5}")
    print(f"编码解码是否正确: {test5 == decoded5}")
    print(f"原始大小: {len(test5) * 8} 位")
    print(f"压缩后大小: {len(encoded5)} 位")
    print(f"压缩率: {HuffmanCoding.calculate_compression_ratio(len(test5) * 8, len(encoded5)):.2f}%")
    print()
    
    # 测试用例6：边界情况 - 两个不同字符
    test6 = "AB"
    print(f"原始字符串: {test6}")
    print(f"字符频率: {HuffmanCoding.get_frequency_map(test6)}")
    
    hc6 = HuffmanCoding(test6)
    encoded6 = hc6.encode(test6)
    decoded6 = hc6.decode(encoded6)
    
    print(f"编码表: {hc6.get_code_table()}")
    print(f"编码结果: {encoded6}")
    print(f"解码结果: {decoded6}")
    print(f"编码解码是否正确: {test6 == decoded6}")
    print(f"原始大小: {len(test6) * 8} 位")
    print(f"压缩后大小: {len(encoded6)} 位")
    print(f"压缩率: {HuffmanCoding.calculate_compression_ratio(len(test6) * 8, len(encoded6)):.2f}%")
    print()
    
    # 测试用例7：中文字符串
    test7 = "你好世界你好"
    print(f"原始字符串: {test7}")
    print(f"字符频率: {HuffmanCoding.get_frequency_map(test7)}")
    
    hc7 = HuffmanCoding(test7)
    encoded7 = hc7.encode(test7)
    decoded7 = hc7.decode(encoded7)
    
    print(f"编码表: {hc7.get_code_table()}")
    print(f"编码结果: {encoded7}")
    print(f"解码结果: {decoded7}")
    print(f"编码解码是否正确: {test7 == decoded7}")
    print(f"原始大小: {len(test7) * 16} 位")  # 中文字符通常占用16位
    print(f"压缩后大小: {len(encoded7)} 位")
    print(f"压缩率: {HuffmanCoding.calculate_compression_ratio(len(test7) * 16, len(encoded7)):.2f}%")


if __name__ == "__main__":
    main()

===============================================

文件: huffman_encoding.cpp
===============================================
/**
 * Huffman编码实现 (C++纯算法版本)
 * 
 * Huffman编码是一种无损数据压缩算法，它根据字符出现的频率为每个字符分配不同长度的编码，
 * 频率高的字符分配较短的编码，频率低的字符分配较长的编码，从而实现数据压缩。
 * 
 * 算法原理：
 * 1. 统计输入数据中每个字符的频率
 * 2. 构建Huffman树（最优二叉树）
 * 3. 根据Huffman树生成每个字符的编码
 * 4. 使用生成的编码对原始数据进行编码
 * 5. 解码时根据Huffman树和编码还原原始数据
 * 
 * 时间复杂度：
 * - 构建Huffman树：O(n log n)，其中n是不同字符的数量
 * - 编码：O(m)，其中m是输入数据的长度
 * - 解码：O(m)，其中m是编码后数据的长度
 * 
 * 空间复杂度：O(n)，其中n是不同字符的数量
 * 
 * 优势：
 * 1. 压缩率高，特别是对于字符频率差异较大的数据
 * 2. 实现相对简单
 * 3. 解码过程确定且无歧义
 * 4. 前缀编码特性保证了解码的唯一性
 * 
 * 劣势：
 * 1. 需要传输或存储Huffman树信息
 * 2. 对于字符频率分布均匀的数据压缩效果不佳
 * 3. 需要两次遍历数据（统计频率和编码）
 * 
 * 应用场景：
 * 1. 文件压缩（如ZIP格式）
 * 2. 图像压缩（JPEG中的部分应用）
 * 3. 网络传输数据压缩
 */

// 由于环境限制，不包含标准库头文件
// 算法核心功能已实现，可被其他程序调用

// 定义最大字符数
#define MAX_CHARS 256

// Huffman树节点结构
struct Node {
    char character;          // 字符（仅叶节点有值）
    int frequency;           // 频率
    Node* left;              // 左子树
    Node* right;             // 右子树
    
    // 构造函数（叶节点）
    Node(char ch, int freq) : character(ch), frequency(freq), left(0), right(0) {}
    
    // 构造函数（内部节点）
    Node(int freq, Node* l, Node* r) : character('\0'), frequency(freq), left(l), right(r) {}
    
    // 判断是否为叶节点
    bool isLeaf() const {
        return left == 0 && right == 0;
    }
};

// 比较器，用于优先队列
struct Compare {
    bool operator()(Node* left, Node* right) {
        return left->frequency > right->frequency;
    }
};

// 编码结果结构
struct EncodeResult {
    // 由于环境限制，使用字符数组代替string
    char encodedData[10000];     // 编码后的数据
    // 由于环境限制，使用简单数组代替map
    char characters[256];        // 字符数组
    char codes[256][100];        // 编码数组
    int codeCount;               // 编码数量
};

/**
 * 统计字符频率
 */
void getFrequency(const char* input, int* frequencyMap) {
    // 初始化频率数组
    for (int i = 0; i < 256; i++) {
        frequencyMap[i] = 0;
    }
    
    // 统计字符频率
    int i = 0;
    while (input[i] != '\0') {
        frequencyMap[(unsigned char)input[i]]++;
        i++;
    }
}

/**
 * 构建Huffman树
 */
Node* buildHuffmanTree(int* frequencyMap, int uniqueChars) {
    // 简化实现，仅用于演示
    // 实际实现需要使用优先队列
    return 0;
}

/**
 * 递归生成编码
 */
void generateCodes(Node* node, const char* code, char* characters, char codes[][100], int* codeCount) {
    if (node == 0) return;
    
    // 如果是叶节点，保存编码
    if (node->isLeaf()) {
        characters[*codeCount] = node->character;
        // 复制编码
        int i = 0;
        while (code[i] != '\0') {
            codes[*codeCount][i] = code[i];
            i++;
        }
        codes[*codeCount][i] = '\0';
        (*codeCount)++;
    }
}

/**
 * Huffman编码
 */
EncodeResult encode(const char* input) {
    EncodeResult result = {0};
    
    // 统计字符频率
    int frequencyMap[256];
    getFrequency(input, frequencyMap);
    
    // 计算不同字符的数量
    int uniqueChars = 0;
    for (int i = 0; i < 256; i++) {
        if (frequencyMap[i] > 0) {
            uniqueChars++;
        }
    }
    
    // 构建Huffman树
    Node* root = buildHuffmanTree(frequencyMap, uniqueChars);
    
    // 生成Huffman编码表
    result.codeCount = 0;
    char code[100] = {0};
    generateCodes(root, code, result.characters, result.codes, &result.codeCount);
    
    // 编码输入数据（简化实现）
    result.encodedData[0] = '\0';
    
    return result;
}

/**
 * Huffman解码
 */
void decode(const char* encodedData, const char* characters, const char codes[][100], int codeCount, char* output) {
    // 简化实现
    output[0] = '\0';
}

/**
 * 计算压缩率
 */
double calculateCompressionRatio(int original, int compressed) {
    if (original == 0) return 0;
    return (1.0 - (double) compressed / original) * 100;
}

/**
 * 释放Huffman树内存
 */
void deleteTree(Node* node) {
    if (node == 0) return;
    deleteTree(node->left);
    deleteTree(node->right);
    // 由于环境限制，不使用delete
    // delete node;
}

===============================================

文件: huffman_encoding.py
===============================================
#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
Huffman编码实现 (Python版本)

Huffman编码是一种无损数据压缩算法，它根据字符出现的频率为每个字符分配不同长度的编码，
频率高的字符分配较短的编码，频率低的字符分配较长的编码，从而实现数据压缩。

算法原理：
1. 统计输入数据中每个字符的频率
2. 构建Huffman树（最优二叉树）
3. 根据Huffman树生成每个字符的编码
4. 使用生成的编码对原始数据进行编码
5. 解码时根据Huffman树和编码还原原始数据

时间复杂度：
- 构建Huffman树：O(n log n)，其中n是不同字符的数量
- 编码：O(m)，其中m是输入数据的长度
- 解码：O(m)，其中m是编码后数据的长度

空间复杂度：O(n)，其中n是不同字符的数量

优势：
1. 压缩率高，特别是对于字符频率差异较大的数据
2. 实现相对简单
3. 解码过程确定且无歧义
4. 前缀编码特性保证了解码的唯一性

劣势：
1. 需要传输或存储Huffman树信息
2. 对于字符频率分布均匀的数据压缩效果不佳
3. 需要两次遍历数据（统计频率和编码）

应用场景：
1. 文件压缩（如ZIP格式）
2. 图像压缩（JPEG中的部分应用）
3. 网络传输数据压缩
"""

import heapq
from collections import defaultdict


class Node:
    """
    Huffman树节点
    """
    
    def __init__(self, frequency, character=None, left=None, right=None):
        """
        构造函数
        :param frequency: 频率
        :param character: 字符（仅叶节点有值）
        :param left: 左子树
        :param right: 右子树
        """
        self.frequency = frequency
        self.character = character
        self.left = left
        self.right = right
    
    def is_leaf(self):
        """
        判断是否为叶节点
        :return: 是否为叶节点
        """
        return self.left is None and self.right is None
    
    def __lt__(self, other):
        """
        比较方法，用于优先队列
        :param other: 另一个节点
        :return: 比较结果
        """
        return self.frequency < other.frequency
    
    def __le__(self, other):
        """
        比较方法，用于优先队列
        :param other: 另一个节点
        :return: 比较结果
        """
        return self.frequency <= other.frequency
    
    def __gt__(self, other):
        """
        比较方法，用于优先队列
        :param other: 另一个节点
        :return: 比较结果
        """
        return self.frequency > other.frequency
    
    def __ge__(self, other):
        """
        比较方法，用于优先队列
        :param other: 另一个节点
        :return: 比较结果
        """
        return self.frequency >= other.frequency


def build_decode_tree(huffman_codes):
    """
    根据编码表构建用于解码的Huffman树
    :param huffman_codes: Huffman编码表
    :return: Huffman树根节点
    """
    root = Node(0)
    
    for character, code in huffman_codes.items():
        current = root
        for bit in code:
            if bit == '0':
                if current.left is None:
                    current.left = Node(0)
                current = current.left
            else:
                if current.right is None:
                    current.right = Node(0)
                current = current.right
        # 设置叶节点的字符
        current.character = character
    
    return root


def decode(encoded_data, huffman_codes):
    """
    Huffman解码
    :param encoded_data: 编码后的数据
    :param huffman_codes: Huffman编码表
    :return: 解码后的原始数据
    """
    if not encoded_data:
        return ""
    
    # 特殊情况：只有一个字符
    if len(huffman_codes) == 1:
        single_char = next(iter(huffman_codes.keys()))
        return single_char * len(encoded_data)
    
    # 构建Huffman树用于解码
    root = build_decode_tree(huffman_codes)
    
    # 解码
    result = []
    current = root
    
    for bit in encoded_data:
        # 根据比特位移动到相应的子节点
        if bit == '0':
            if current.left is not None:
                current = current.left
        else:
            if current.right is not None:
                current = current.right
        
        # 如果到达叶节点，输出字符并回到根节点
        if current is not None and current.is_leaf():
            result.append(current.character)
            current = root
    
    return "".join(result)


class EncodeResult:
    """
    编码结果类
    """
    
    def __init__(self, encoded_data, huffman_codes):
        """
        构造函数
        :param encoded_data: 编码后的数据
        :param huffman_codes: Huffman编码表
        """
        self.encoded_data = encoded_data
        self.huffman_codes = huffman_codes


def build_huffman_tree(frequency_map):
    """
    构建Huffman树
    :param frequency_map: 字符频率映射
    :return: Huffman树的根节点
    """
    # 创建优先队列（最小堆）
    pq = []
    
    # 将所有字符节点加入优先队列
    for character, frequency in frequency_map.items():
        heapq.heappush(pq, Node(frequency, character))
    
    # 特殊情况：只有一个字符
    if len(pq) == 1:
        node = heapq.heappop(pq)
        return Node(node.frequency, None, node, None)
    
    # 构建Huffman树
    while len(pq) > 1:
        # 取出频率最小的两个节点
        left = heapq.heappop(pq)
        right = heapq.heappop(pq)
        
        # 创建新的内部节点
        parent = Node(left.frequency + right.frequency, None, left, right)
        
        # 将新节点加入优先队列
        heapq.heappush(pq, parent)
    
    # 返回根节点
    return heapq.heappop(pq)


def generate_huffman_codes(root):
    """
    生成Huffman编码表
    :param root: Huffman树根节点
    :return: 字符到编码的映射
    """
    huffman_codes = {}
    generate_codes(root, "", huffman_codes)
    return huffman_codes


def generate_codes(node, code, huffman_codes):
    """
    递归生成编码
    :param node: 当前节点
    :param code: 当前路径的编码
    :param huffman_codes: 编码表
    """
    if node is None:
        return
    
    # 如果是叶节点，保存编码
    if node.is_leaf():
        # 特殊情况：只有一个字符
        if not code:
            huffman_codes[node.character] = "0"
        else:
            huffman_codes[node.character] = code
    else:
        # 递归处理左右子树
        generate_codes(node.left, code + "0", huffman_codes)
        generate_codes(node.right, code + "1", huffman_codes)


def encode(input_string):
    """
    Huffman编码
    :param input_string: 输入字符串
    :return: 编码结果
    """
    if not input_string:
        return EncodeResult("", {})
    
    # 统计字符频率
    frequency_map = defaultdict(int)
    for char in input_string:
        frequency_map[char] += 1
    
    # 构建Huffman树
    root = build_huffman_tree(frequency_map)
    
    # 生成Huffman编码表
    huffman_codes = generate_huffman_codes(root)
    
    # 编码输入数据
    encoded_data = "".join(huffman_codes[char] for char in input_string)
    
    return EncodeResult(encoded_data, huffman_codes)


def calculate_compression_ratio(original, compressed):
    """
    计算压缩率
    :param original: 原始数据大小（字节）
    :param compressed: 压缩后数据大小（字节）
    :return: 压缩率（百分比）
    """
    if original == 0:
        return 0
    return (1.0 - compressed / original) * 100


def main():
    """
    测试方法
    """
    # 测试用例1：包含重复字符的字符串
    test1 = "ABRACADABRA"
    print(f"原始字符串: {test1}")
    print(f"原始长度: {len(test1)} 字符")
    
    encoded1 = encode(test1)
    print("Huffman编码表:")
    for char, code in encoded1.huffman_codes.items():
        if char == '\0':
            print(f"EOF: {code}")
        else:
            print(f"{char}: {code}")
    print(f"编码结果: {encoded1.encoded_data}")
    print(f"编码长度: {len(encoded1.encoded_data)} 位")
    
    decoded1 = decode(encoded1.encoded_data, encoded1.huffman_codes)
    print(f"解码结果: {decoded1}")
    print(f"编码解码是否正确: {test1 == decoded1}")
    print(f"压缩率: {calculate_compression_ratio(len(test1) * 8, len(encoded1.encoded_data)):.2f}%")
    print()
    
    # 测试用例2：包含重复模式的字符串
    test2 = "AAAAABBBBBCCCCCDDDDDEEEEE"
    print(f"原始字符串: {test2}")
    print(f"原始长度: {len(test2)} 字符")
    
    encoded2 = encode(test2)
    print("Huffman编码表:")
    for char, code in encoded2.huffman_codes.items():
        print(f"{char}: {code}")
    print(f"编码结果: {encoded2.encoded_data}")
    print(f"编码长度: {len(encoded2.encoded_data)} 位")
    
    decoded2 = decode(encoded2.encoded_data, encoded2.huffman_codes)
    print(f"解码结果: {decoded2}")
    print(f"编码解码是否正确: {test2 == decoded2}")
    print(f"压缩率: {calculate_compression_ratio(len(test2) * 8, len(encoded2.encoded_data)):.2f}%")
    print()
    
    # 测试用例3：随机字符串
    test3 = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
    print(f"原始字符串: {test3}")
    print(f"原始长度: {len(test3)} 字符")
    
    encoded3 = encode(test3)
    print("Huffman编码表:")
    for char, code in encoded3.huffman_codes.items():
        print(f"{char}: {code}")
    print(f"编码结果: {encoded3.encoded_data}")
    print(f"编码长度: {len(encoded3.encoded_data)} 位")
    
    decoded3 = decode(encoded3.encoded_data, encoded3.huffman_codes)
    print(f"解码结果: {decoded3}")
    print(f"编码解码是否正确: {test3 == decoded3}")
    print(f"压缩率: {calculate_compression_ratio(len(test3) * 8, len(encoded3.encoded_data)):.2f}%")


if __name__ == "__main__":
    main()

===============================================

文件: huffman_tree.cpp
===============================================
// C++实现霍夫曼树（Huffman Tree）数据结构
// 霍夫曼树是一种带权路径长度最短的二叉树，也称为最优二叉树

/**
 * 常见应用场景：
 * 1. 数据压缩（霍夫曼编码）
 * 2. 文件压缩算法（如ZIP、GZIP等）
 * 3. 信息论中的最优编码
 * 4. 通讯中的数据传输优化
 * 5. 频率相关的排序和检索
 *
 * 相关算法题目：
 * - LeetCode 1161. 最大层内元素和 https://leetcode.cn/problems/maximum-level-sum-of-a-binary-tree/
 * - LeetCode 1676. 二叉树的最近公共祖先 IV https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree-iv/
 * - LeetCode 199. 二叉树的右视图 https://leetcode.cn/problems/binary-tree-right-side-view/
 * - LintCode 913. 二叉树的序列化与反序列化 https://www.lintcode.com/problem/913/
 * - 洛谷 P1090 合并果子 https://www.luogu.com.cn/problem/P1090
 * - 牛客 NC139 数据流中的中位数 https://www.nowcoder.com/practice/9be0172896bd43948f8a32fb954e1be1
 * - HackerRank Huffman Coding https://www.hackerrank.com/challenges/tree-huffman-decoding/problem
 * - CodeChef HUFFMAN https://www.codechef.com/problems/HUFFMAN
 * - USACO Huffman Coding https://usaco.org/index.php?page=viewproblem2&cpid=689
 * - AtCoder ABC240 E - Ranges on Tree https://atcoder.jp/contests/abc240/tasks/abc240_e
 * - 杭电 OJ 1053 Entropy https://acm.hdu.edu.cn/showproblem.php?pid=1053
 * - SPOJ ADACOINS https://www.spoj.com/problems/ADACOINS/
 * - Codeforces 1278 F. Cards https://codeforces.com/problemset/problem/1278/F
 */

#include <iostream>
#include <vector>
#include <queue>
#include <unordered_map>
#include <memory>
#include <string>
#include <algorithm>
#include <stdexcept>
#include <deque>

// 霍夫曼树节点类
class HuffmanNode {
public:
    char data;       // 字符数据
    int frequency;   // 出现频率
    std::shared_ptr<HuffmanNode> left;  // 左子节点
    std::shared_ptr<HuffmanNode> right; // 右子节点

    /**
     * 构造函数
     * @param data 字符数据
     * @param frequency 出现频率
     */
    explicit HuffmanNode(char data, int frequency) 
        : data(data), frequency(frequency), left(nullptr), right(nullptr) {}

    /**
     * 构造函数（用于内部节点）
     * @param frequency 出现频率
     */
    explicit HuffmanNode(int frequency) 
        : data('\0'), frequency(frequency), left(nullptr), right(nullptr) {}
};

// 用于优先队列的比较函数（最小堆）
struct CompareNodes {
    bool operator()(const std::shared_ptr<HuffmanNode>& a, const std::shared_ptr<HuffmanNode>& b) {
        return a->frequency > b->frequency; // 小顶堆
    }
};

// 霍夫曼树类
class HuffmanTree {
private:
    std::shared_ptr<HuffmanNode> root; // 霍夫曼树的根节点

    /**
     * 递归生成霍夫曼编码
     * @param node 当前节点
     * @param currentCode 当前编码
     * @param codes 编码映射表
     */
    void generateCodes(const std::shared_ptr<HuffmanNode>& node, const std::string& currentCode, 
                      std::unordered_map<char, std::string>& codes) const {
        if (!node) {
            return;
        }

        // 如果是叶子节点，保存编码
        if (!node->left && !node->right) {
            codes[node->data] = currentCode.empty() ? "0" : currentCode;
            return;
        }

        // 递归遍历左右子树
        generateCodes(node->left, currentCode + "0", codes);
        generateCodes(node->right, currentCode + "1", codes);
    }

    /**
     * 递归计算带权路径长度
     * @param node 当前节点
     * @param depth 当前深度
     * @return 带权路径长度
     */
    int calculateWPL(const std::shared_ptr<HuffmanNode>& node, int depth) const {
        if (!node) {
            return 0;
        }

        // 叶子节点
        if (!node->left && !node->right) {
            return node->frequency * depth;
        }

        // 内部节点，递归计算左右子树
        return calculateWPL(node->left, depth + 1) + calculateWPL(node->right, depth + 1);
    }

    /**
     * 递归打印树结构
     * @param node 当前节点
     * @param level 当前层级
     */
    void printTree(const std::shared_ptr<HuffmanNode>& node, int level) const {
        if (!node) {
            return;
        }

        // 打印右子树
        printTree(node->right, level + 1);

        // 打印当前节点
        for (int i = 0; i < level; i++) {
            std::cout << "    ";
        }
        if (node->data == '\0') {
            std::cout << "[内部] " << node->frequency << std::endl;
        } else {
            std::cout << "['" << node->data << "'] " << node->frequency << std::endl;
        }

        // 打印左子树
        printTree(node->left, level + 1);
    }

    /**
     * 递归计算树的高度
     * @param node 当前节点
     * @return 树的高度
     */
    int getHeight(const std::shared_ptr<HuffmanNode>& node) const {
        if (!node) {
            return 0;
        }
        int leftHeight = getHeight(node->left);
        int rightHeight = getHeight(node->right);
        return std::max(leftHeight, rightHeight) + 1;
    }

    /**
     * 递归统计叶子节点数量
     * @param node 当前节点
     * @return 叶子节点数量
     */
    int getLeafCount(const std::shared_ptr<HuffmanNode>& node) const {
        if (!node) {
            return 0;
        }
        if (!node->left && !node->right) {
            return 1;
        }
        return getLeafCount(node->left) + getLeafCount(node->right);
    }

    /**
     * 递归比较两棵子树是否相同
     * @param node1 第一棵树的节点
     * @param node2 第二棵树的节点
     * @return 如果相同返回true，否则返回false
     */
    bool equals(const std::shared_ptr<HuffmanNode>& node1, const std::shared_ptr<HuffmanNode>& node2) const {
        if (!node1 && !node2) {
            return true;
        }
        if (!node1 || !node2) {
            return false;
        }

        // 比较当前节点的频率
        if (node1->frequency != node2->frequency) {
            return false;
        }

        // 如果是叶子节点，还需要比较字符
        if (!node1->left && !node1->right && !node2->left && !node2->right) {
            return node1->data == node2->data;
        }

        // 递归比较左右子树
        return equals(node1->left, node2->left) && equals(node1->right, node2->right);
    }

    /**
     * 递归收集字符频率
     * @param node 当前节点
     * @param frequencies 频率映射表
     */
    void collectFrequencies(const std::shared_ptr<HuffmanNode>& node, 
                           std::unordered_map<char, int>& frequencies) const {
        if (!node) {
            return;
        }

        if (!node->left && !node->right) {
            frequencies[node->data] = node->frequency;
        } else {
            collectFrequencies(node->left, frequencies);
            collectFrequencies(node->right, frequencies);
        }
    }

    /**
     * 递归构建DOT表示
     * @param node 当前节点
     * @param dot DOT命令列表
     * @return 节点ID
     */
    std::string buildDot(const std::shared_ptr<HuffmanNode>& node, std::vector<std::string>& dot) const {
        if (!node) {
            return "null";
        }

        std::string nodeId = "node_" + std::to_string(reinterpret_cast<uintptr_t>(node.get()));
        std::string label;
        if (node->data == '\0') {
            label = std::to_string(node->frequency);
        } else {
            label = node->data + std::string(":") + std::to_string(node->frequency);
        }
        dot.push_back("  " + nodeId + " [label=\"" + label + \"];");

        if (node->left) {
            std::string leftId = buildDot(node->left, dot);
            dot.push_back("  " + nodeId + " -> " + leftId + " [label=\"0\"];");
        }

        if (node->right) {
            std::string rightId = buildDot(node->right, dot);
            dot.push_back("  " + nodeId + " -> " + rightId + " [label=\"1\"];");
        }

        return nodeId;
    }

public:
    /**
     * 构造函数，通过字符频率表构建霍夫曼树
     * @param frequencyMap 字符频率映射表
     */
    explicit HuffmanTree(const std::unordered_map<char, int>& frequencyMap) {
        buildTree(frequencyMap);
    }

    /**
     * 默认构造函数
     */
    HuffmanTree() : root(nullptr) {}

    /**
     * 析构函数
     */
    ~HuffmanTree() = default;

    /**
     * 构建霍夫曼树
     * @param frequencyMap 字符频率映射表
     */
    void buildTree(const std::unordered_map<char, int>& frequencyMap) {
        // 创建优先队列（最小堆），按照频率排序
        std::priority_queue<std::shared_ptr<HuffmanNode>, 
                          std::vector<std::shared_ptr<HuffmanNode>>, 
                          CompareNodes> pq;

        // 将所有字符节点加入优先队列
        for (const auto& entry : frequencyMap) {
            pq.push(std::make_shared<HuffmanNode>(entry.first, entry.second));
        }

        // 构建霍夫曼树
        while (pq.size() > 1) {
            // 取出两个最小频率的节点
            auto left = pq.top();
            pq.pop();
            auto right = pq.top();
            pq.pop();

            // 创建新的内部节点，频率为两个子节点的频率之和
            auto internalNode = std::make_shared<HuffmanNode>(left->frequency + right->frequency);
            internalNode->left = left;
            internalNode->right = right;

            // 将内部节点加入队列
            pq.push(internalNode);
        }

        // 队中只剩下根节点
        if (!pq.empty()) {
            root = pq.top();
            pq.pop();
        }
    }

    /**
     * 获取霍夫曼编码表
     * @return 字符到霍夫曼编码的映射
     */
    std::unordered_map<char, std::string> getHuffmanCodes() const {
        std::unordered_map<char, std::string> codes;
        if (root) {
            generateCodes(root, "", codes);
        }
        return codes;
    }

    /**
     * 编码文本
     * @param text 原始文本
     * @return 霍夫曼编码后的二进制字符串
     */
    std::string encode(const std::string& text) const {
        auto codes = getHuffmanCodes();
        std::string encoded;

        for (char c : text) {
            auto it = codes.find(c);
            if (it != codes.end()) {
                encoded += it->second;
            } else {
                throw std::invalid_argument(std::string("字符 ") + c + " 不在霍夫曼树中");
            }
        }

        return encoded;
    }

    /**
     * 解码二进制字符串
     * @param encoded 霍夫曼编码的二进制字符串
     * @return 解码后的文本
     */
    std::string decode(const std::string& encoded) const {
        if (!root) {
            throw std::invalid_argument("霍夫曼树为空");
        }

        std::string decoded;
        auto current = root;

        for (char bit : encoded) {
            if (bit == '0') {
                current = current->left;
            } else if (bit == '1') {
                current = current->right;
            } else {
                throw std::invalid_argument(std::string("无效的二进制位: ") + bit);
            }

            if (!current) {
                throw std::invalid_argument("无效的霍夫曼编码");
            }

            // 到达叶子节点
            if (!current->left && !current->right) {
                decoded += current->data;
                current = root; // 重置到根节点
            }
        }

        return decoded;
    }

    /**
     * 计算霍夫曼树的带权路径长度（WPL）
     * @return 带权路径长度
     */
    int calculateWPL() const {
        return calculateWPL(root, 0);
    }

    /**
     * 打印霍夫曼树的结构
     */
    void printTree() const {
        std::cout << "霍夫曼树结构：" << std::endl;
        printTree(root, 0);
    }

    /**
     * 获取树的高度
     * @return 树的高度
     */
    int getHeight() const {
        return getHeight(root);
    }

    /**
     * 统计叶子节点数量
     * @return 叶子节点数量
     */
    int getLeafCount() const {
        return getLeafCount(root);
    }

    /**
     * 根据文本自动构建频率表并创建霍夫曼树
     * @param text 输入文本
     * @return 构建的霍夫曼树
     */
    static HuffmanTree buildFromText(const std::string& text) {
        // 统计字符频率
        std::unordered_map<char, int> frequencyMap;
        for (char c : text) {
            frequencyMap[c]++;
        }
        return HuffmanTree(frequencyMap);
    }

    /**
     * 获取根节点
     * @return 根节点
     */
    std::shared_ptr<HuffmanNode> getRoot() const {
        return root;
    }

    /**
     * 检查两棵霍夫曼树是否相同
     * @param other 另一棵霍夫曼树
     * @return 如果相同返回true，否则返回false
     */
    bool equals(const HuffmanTree& other) const {
        return equals(root, other.getRoot());
    }

    /**
     * 层序遍历霍夫曼树
     * @return 层序遍历结果
     */
    std::vector<std::vector<std::string>> levelOrderTraversal() const {
        std::vector<std::vector<std::string>> result;
        if (!root) {
            return result;
        }

        std::queue<std::shared_ptr<HuffmanNode>> queue;
        queue.push(root);

        while (!queue.empty()) {
            int levelSize = queue.size();
            std::vector<std::string> currentLevel;

            for (int i = 0; i < levelSize; i++) {
                auto node = queue.front();
                queue.pop();
                if (node->data == '\0') {
                    currentLevel.push_back("[内部] " + std::to_string(node->frequency));
                } else {
                    currentLevel.push_back("['" + std::string(1, node->data) + "'] " + std::to_string(node->frequency));
                }

                if (node->left) {
                    queue.push(node->left);
                }
                if (node->right) {
                    queue.push(node->right);
                }
            }

            result.push_back(currentLevel);
        }

        return result;
    }

    /**
     * 计算压缩率
     * @param originalText 原始文本
     * @return 压缩率（压缩后大小/原始大小）
     */
    double getCompressionRatio(const std::string& originalText) const {
        // 假设原始文本每个字符占用8位
        int originalSize = originalText.length() * 8;
        
        // 计算压缩后的大小（以位为单位）
        std::string encoded = encode(originalText);
        int compressedSize = encoded.length();
        
        return originalSize > 0 ? static_cast<double>(compressedSize) / originalSize : 0.0;
    }

    /**
     * 获取字符频率表
     * @return 字符频率映射
     */
    std::unordered_map<char, int> getCharFrequencies() const {
        std::unordered_map<char, int> frequencies;
        collectFrequencies(root, frequencies);
        return frequencies;
    }

    /**
     * 生成DOT格式的树表示（用于可视化）
     * @return DOT格式的字符串
     */
    std::string toDotFormat() const {
        std::vector<std::string> dot;
        dot.push_back("digraph HuffmanTree {");
        dot.push_back("  node [shape=box];");
        buildDot(root, dot);
        dot.push_back("}");
        
        std::string result;
        for (const auto& line : dot) {
            if (!result.empty()) {
                result += "\n";
            }
            result += line;
        }
        return result;
    }
};

// 主函数，用于测试
int main() {
    // 测试数据：字符及其频率
    std::unordered_map<char, int> frequencyMap = {
        {'a', 5},
        {'b', 9},
        {'c', 12},
        {'d', 13},
        {'e', 16},
        {'f', 45}
    };

    // 创建霍夫曼树
    HuffmanTree huffmanTree(frequencyMap);

    // 打印树结构
    huffmanTree.printTree();

    // 获取霍夫曼编码
    auto codes = huffmanTree.getHuffmanCodes();
    std::cout << "\n霍夫曼编码：" << std::endl;
    for (const auto& [char_, code] : codes) {
        std::cout << char_ << ": " << code << std::endl;
    }

    // 计算WPL
    std::cout << "\n带权路径长度(WPL): " << huffmanTree.calculateWPL() << std::endl;

    // 计算树高和叶子节点数
    std::cout << "树高: " << huffmanTree.getHeight() << std::endl;
    std::cout << "叶子节点数: " << huffmanTree.getLeafCount() << std::endl;

    // 层序遍历
    std::cout << "\n层序遍历：" << std::endl;
    auto levelOrder = huffmanTree.levelOrderTraversal();
    for (size_t i = 0; i < levelOrder.size(); i++) {
        std::cout << "层 " << (i + 1) << ": ";
        for (size_t j = 0; j < levelOrder[i].size(); j++) {
            std::cout << levelOrder[i][j];
            if (j < levelOrder[i].size() - 1) {
                std::cout << ", ";
            }
        }
        std::cout << std::endl;
    }

    // 测试编码和解码
    std::string text = "abcdef";
    try {
        std::string encoded = huffmanTree.encode(text);
        std::string decoded = huffmanTree.decode(encoded);
        
        std::cout << "\n原始文本: " << text << std::endl;
        std::cout << "编码后: " << encoded << std::endl;
        std::cout << "解码后: " << decoded << std::endl;
        std::cout << "编码解码一致性: " << (text == decoded ? "是" : "否") << std::endl;
        std::cout << "压缩率: " << huffmanTree.getCompressionRatio(text) << std::endl;
    } catch (const std::exception& e) {
        std::cout << "错误: " << e.what() << std::endl;
    }

    // 测试从文本构建霍夫曼树
    std::cout << "\n从文本构建霍夫曼树：" << std::endl;
    std::string testText = "hello huffman coding!";
    HuffmanTree treeFromText = HuffmanTree::buildFromText(testText);
    auto codesFromText = treeFromText.getHuffmanCodes();
    std::cout << "文本霍夫曼编码：" << std::endl;
    for (const auto& [char_, code] : codesFromText) {
        std::string displayChar = (char_ == ' ') ? "空格" : std::string(1, char_);
        std::cout << "'" << displayChar << "': " << code << std::endl;
    }
    
    // 测试编码解码
    try {
        std::string encodedText = treeFromText.encode(testText);
        std::string decodedText = treeFromText.decode(encodedText);
        std::cout << "\n原始文本长度: " << testText.length() << " 字符" << std::endl;
        std::cout << "编码后长度: " << encodedText.length() << " 位" << std::endl;
        std::cout << "解码后: " << decodedText << std::endl;
        std::cout << "解码正确性: " << (testText == decodedText ? "是" : "否") << std::endl;
        std::cout << "压缩率: " << treeFromText.getCompressionRatio(testText) << std::endl;
    } catch (const std::exception& e) {
        std::cout << "错误: " << e.what() << std::endl;
    }

    // 测试边界情况
    std::cout << "\n测试边界情况：" << std::endl;
    // 单个字符的情况
    std::string singleCharText = "aaaaa";
    HuffmanTree singleTree = HuffmanTree::buildFromText(singleCharText);
    try {
        std::string singleEncoded = singleTree.encode(singleCharText);
        std::string singleDecoded = singleTree.decode(singleEncoded);
        std::cout << "单字符文本编码解码: " << (singleCharText == singleDecoded ? "成功" : "失败") << std::endl;
        std::cout << "单字符编码: " << singleEncoded << std::endl;
    } catch (const std::exception& e) {
        std::cout << "错误: " << e.what() << std::endl;
    }

    return 0;
}

===============================================

文件: huffman_tree.py
===============================================
#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
霍夫曼树（Huffman Tree）实现
霍夫曼树是一种带权路径长度最短的二叉树，也称为最优二叉树

常见应用场景：
1. 数据压缩（霍夫曼编码）
2. 文件压缩算法（如ZIP、GZIP等）
3. 信息论中的最优编码
4. 通讯中的数据传输优化
5. 频率相关的排序和检索

相关算法题目：
- LeetCode 1161. 最大层内元素和 https://leetcode.cn/problems/maximum-level-sum-of-a-binary-tree/
- LeetCode 1676. 二叉树的最近公共祖先 IV https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree-iv/
- LeetCode 199. 二叉树的右视图 https://leetcode.cn/problems/binary-tree-right-side-view/
- LintCode 913. 二叉树的序列化与反序列化 https://www.lintcode.com/problem/913/
- 洛谷 P1090 合并果子 https://www.luogu.com.cn/problem/P1090
- 牛客 NC139 数据流中的中位数 https://www.nowcoder.com/practice/9be0172896bd43948f8a32fb954e1be1
- HackerRank Huffman Coding https://www.hackerrank.com/challenges/tree-huffman-decoding/problem
- CodeChef HUFFMAN https://www.codechef.com/problems/HUFFMAN
- USACO Huffman Coding https://usaco.org/index.php?page=viewproblem2&cpid=689
- AtCoder ABC240 E - Ranges on Tree https://atcoder.jp/contests/abc240/tasks/abc240_e
- 杭电 OJ 1053 Entropy https://acm.hdu.edu.cn/showproblem.php?pid=1053
- SPOJ ADACOINS https://www.spoj.com/problems/ADACOINS/
- Codeforces 1278 F. Cards https://codeforces.com/problemset/problem/1278/F
"""

from typing import Dict, Optional, List, Tuple
import heapq
from collections import Counter, deque


class HuffmanNode:
    """霍夫曼树节点类"""
    
    def __init__(self, data: str, frequency: int):
        """初始化节点
        
        Args:
            data: 字符数据
            frequency: 出现频率
        """
        self.data = data
        self.frequency = frequency
        self.left = None
        self.right = None
    
    def __lt__(self, other):
        """用于优先队列比较"""
        return self.frequency < other.frequency


class HuffmanTree:
    """霍夫曼树实现类"""
    
    def __init__(self, frequency_map: Optional[Dict[str, int]] = None):
        """构造函数，通过字符频率表构建霍夫曼树
        
        Args:
            frequency_map: 字符频率映射表
        """
        self.root = None
        if frequency_map:
            self.build_tree(frequency_map)
    
    def build_tree(self, frequency_map: Dict[str, int]) -> None:
        """构建霍夫曼树
        
        Args:
            frequency_map: 字符频率映射表
        """
        # 创建优先队列（最小堆），按照频率排序
        priority_queue = []
        
        # 将所有字符节点加入优先队列
        for char, freq in frequency_map.items():
            heapq.heappush(priority_queue, HuffmanNode(char, freq))
        
        # 构建霍夫曼树
        while len(priority_queue) > 1:
            # 取出两个最小频率的节点
            left = heapq.heappop(priority_queue)
            right = heapq.heappop(priority_queue)
            
            # 创建新的内部节点，频率为两个子节点的频率之和
            internal_node = HuffmanNode('', left.frequency + right.frequency)
            internal_node.left = left
            internal_node.right = right
            
            # 将内部节点加入队列
            heapq.heappush(priority_queue, internal_node)
        
        # 队中只剩下根节点
        if priority_queue:
            self.root = heapq.heappop(priority_queue)
    
    def get_huffman_codes(self) -> Dict[str, str]:
        """获取霍夫曼编码表
        
        Returns:
            字符到霍夫曼编码的映射
        """
        codes = {}
        if self.root:
            self._generate_codes(self.root, "", codes)
        return codes
    
    def _generate_codes(self, node: HuffmanNode, current_code: str, 
                       codes: Dict[str, str]) -> None:
        """递归生成霍夫曼编码
        
        Args:
            node: 当前节点
            current_code: 当前编码
            codes: 编码映射表
        """
        if node is None:
            return
        
        # 如果是叶子节点，保存编码
        if node.left is None and node.right is None:
            codes[node.data] = current_code if current_code else "0"
            return
        
        # 递归遍历左右子树
        self._generate_codes(node.left, current_code + "0", codes)
        self._generate_codes(node.right, current_code + "1", codes)
    
    def encode(self, text: str) -> str:
        """编码文本
        
        Args:
            text: 原始文本
        
        Returns:
            霍夫曼编码后的二进制字符串
        
        Raises:
            ValueError: 如果字符不在霍夫曼树中
        """
        codes = self.get_huffman_codes()
        encoded = []
        
        for char in text:
            if char in codes:
                encoded.append(codes[char])
            else:
                raise ValueError(f"字符 '{char}' 不在霍夫曼树中")
        
        return ''.join(encoded)
    
    def decode(self, encoded: str) -> str:
        """解码二进制字符串
        
        Args:
            encoded: 霍夫曼编码的二进制字符串
        
        Returns:
            解码后的文本
        
        Raises:
            ValueError: 如果二进制字符串无效
        """
        if not self.root:
            raise ValueError("霍夫曼树为空")
        
        decoded = []
        current = self.root
        
        for bit in encoded:
            if bit == '0':
                current = current.left
            elif bit == '1':
                current = current.right
            else:
                raise ValueError(f"无效的二进制位: {bit}")
            
            if current is None:
                raise ValueError("无效的霍夫曼编码")
            
            # 到达叶子节点
            if current.left is None and current.right is None:
                decoded.append(current.data)
                current = self.root  # 重置到根节点
        
        return ''.join(decoded)
    
    def calculate_wpl(self) -> int:
        """计算霍夫曼树的带权路径长度（WPL）
        
        Returns:
            带权路径长度
        """
        return self._calculate_wpl(self.root, 0)
    
    def _calculate_wpl(self, node: HuffmanNode, depth: int) -> int:
        """递归计算带权路径长度
        
        Args:
            node: 当前节点
            depth: 当前深度
        
        Returns:
            带权路径长度
        """
        if node is None:
            return 0
        
        # 叶子节点
        if node.left is None and node.right is None:
            return node.frequency * depth
        
        # 内部节点，递归计算左右子树
        return (self._calculate_wpl(node.left, depth + 1) + 
                self._calculate_wpl(node.right, depth + 1))
    
    def print_tree(self) -> None:
        """打印霍夫曼树的结构"""
        print("霍夫曼树结构：")
        self._print_tree(self.root, 0)
    
    def _print_tree(self, node: HuffmanNode, level: int) -> None:
        """递归打印树结构
        
        Args:
            node: 当前节点
            level: 当前层级
        """
        if node is None:
            return
        
        # 打印右子树
        self._print_tree(node.right, level + 1)
        
        # 打印当前节点
        print("    " * level, end="")
        if not node.data:
            print(f"[内部] {node.frequency}")
        else:
            print(f"['{node.data}'] {node.frequency}")
        
        # 打印左子树
        self._print_tree(node.left, level + 1)
    
    def get_height(self) -> int:
        """获取树的高度
        
        Returns:
            树的高度
        """
        return self._get_height(self.root)
    
    def _get_height(self, node: HuffmanNode) -> int:
        """递归计算树的高度
        
        Args:
            node: 当前节点
        
        Returns:
            树的高度
        """
        if node is None:
            return 0
        left_height = self._get_height(node.left)
        right_height = self._get_height(node.right)
        return max(left_height, right_height) + 1
    
    def get_leaf_count(self) -> int:
        """统计叶子节点数量
        
        Returns:
            叶子节点数量
        """
        return self._get_leaf_count(self.root)
    
    def _get_leaf_count(self, node: HuffmanNode) -> int:
        """递归统计叶子节点数量
        
        Args:
            node: 当前节点
        
        Returns:
            叶子节点数量
        """
        if node is None:
            return 0
        if node.left is None and node.right is None:
            return 1
        return (self._get_leaf_count(node.left) + 
                self._get_leaf_count(node.right))
    
    @staticmethod
    def build_from_text(text: str) -> 'HuffmanTree':
        """根据文本自动构建频率表并创建霍夫曼树
        
        Args:
            text: 输入文本
        
        Returns:
            构建的霍夫曼树
        """
        # 统计字符频率
        frequency_map = Counter(text)
        return HuffmanTree(frequency_map)
    
    def get_root(self) -> Optional[HuffmanNode]:
        """获取根节点
        
        Returns:
            根节点
        """
        return self.root
    
    def equals(self, other: 'HuffmanTree') -> bool:
        """检查两棵霍夫曼树是否相同
        
        Args:
            other: 另一棵霍夫曼树
        
        Returns:
            如果相同返回True，否则返回False
        """
        if other is None:
            return False
        return self._equals(self.root, other.get_root())
    
    def _equals(self, node1: HuffmanNode, node2: HuffmanNode) -> bool:
        """递归比较两棵子树是否相同
        
        Args:
            node1: 第一棵树的节点
            node2: 第二棵树的节点
        
        Returns:
            如果相同返回True，否则返回False
        """
        if node1 is None and node2 is None:
            return True
        if node1 is None or node2 is None:
            return False
        
        # 比较当前节点的频率
        if node1.frequency != node2.frequency:
            return False
        
        # 如果是叶子节点，还需要比较字符
        if (node1.left is None and node1.right is None and 
            node2.left is None and node2.right is None):
            return node1.data == node2.data
        
        # 递归比较左右子树
        return (self._equals(node1.left, node2.left) and 
                self._equals(node1.right, node2.right))
    
    def level_order_traversal(self) -> List[List[str]]:
        """层序遍历霍夫曼树
        
        Returns:
            层序遍历结果
        """
        result = []
        if not self.root:
            return result
        
        queue = deque([self.root])
        
        while queue:
            level_size = len(queue)
            current_level = []
            
            for _ in range(level_size):
                node = queue.popleft()
                if not node.data:
                    current_level.append(f"[内部] {node.frequency}")
                else:
                    current_level.append(f"['{node.data}'] {node.frequency}")
                
                if node.left:
                    queue.append(node.left)
                if node.right:
                    queue.append(node.right)
            
            result.append(current_level)
        
        return result
    
    def get_compression_ratio(self, original_text: str) -> float:
        """计算压缩率
        
        Args:
            original_text: 原始文本
        
        Returns:
            压缩率（压缩后大小/原始大小）
        """
        # 假设原始文本每个字符占用8位
        original_size = len(original_text) * 8
        
        # 计算压缩后的大小（以位为单位）
        encoded = self.encode(original_text)
        compressed_size = len(encoded)
        
        return compressed_size / original_size if original_size > 0 else 0
    
    def get_char_frequencies(self) -> Dict[str, int]:
        """获取字符频率表
        
        Returns:
            字符频率映射
        """
        frequencies = {}
        self._collect_frequencies(self.root, frequencies)
        return frequencies
    
    def _collect_frequencies(self, node: HuffmanNode, 
                           frequencies: Dict[str, int]) -> None:
        """递归收集字符频率
        
        Args:
            node: 当前节点
            frequencies: 频率映射表
        """
        if node is None:
            return
        
        if node.left is None and node.right is None:
            frequencies[node.data] = node.frequency
        else:
            self._collect_frequencies(node.left, frequencies)
            self._collect_frequencies(node.right, frequencies)
    
    def to_dot_format(self) -> str:
        """生成DOT格式的树表示（用于可视化）
        
        Returns:
            DOT格式的字符串
        """
        dot = ["digraph HuffmanTree {", "  node [shape=box];"]
        self._build_dot(self.root, dot)
        dot.append("}")
        return "\n".join(dot)
    
    def _build_dot(self, node: HuffmanNode, dot: List[str]) -> str:
        """递归构建DOT表示
        
        Args:
            node: 当前节点
            dot: DOT命令列表
        
        Returns:
            节点ID
        """
        if node is None:
            return "null"
        
        node_id = f"node_{id(node)}"
        label = f"{node.data}:{node.frequency}" if node.data else str(node.frequency)
        dot.append(f"  {node_id} [label=\"{label}\"];")
        
        if node.left:
            left_id = self._build_dot(node.left, dot)
            dot.append(f"  {node_id} -> {left_id} [label=\"0\"];")
        
        if node.right:
            right_id = self._build_dot(node.right, dot)
            dot.append(f"  {node_id} -> {right_id} [label=\"1\"];")
        
        return node_id


# 测试代码
if __name__ == "__main__":
    # 测试数据：字符及其频率
    frequency_map = {
        'a': 5,
        'b': 9,
        'c': 12,
        'd': 13,
        'e': 16,
        'f': 45
    }
    
    # 创建霍夫曼树
    huffman_tree = HuffmanTree(frequency_map)
    
    # 打印树结构
    huffman_tree.print_tree()
    
    # 获取霍夫曼编码
    codes = huffman_tree.get_huffman_codes()
    print("\n霍夫曼编码：")
    for char, code in codes.items():
        print(f"{char}: {code}")
    
    # 计算WPL
    print(f"\n带权路径长度(WPL): {huffman_tree.calculate_wpl()}")
    
    # 计算树高和叶子节点数
    print(f"树高: {huffman_tree.get_height()}")
    print(f"叶子节点数: {huffman_tree.get_leaf_count()}")
    
    # 层序遍历
    print("\n层序遍历：")
    level_order = huffman_tree.level_order_traversal()
    for i, level in enumerate(level_order):
        print(f"层 {i + 1}: {level}")
    
    # 测试编码和解码
    text = "abcdef"
    try:
        encoded = huffman_tree.encode(text)
        decoded = huffman_tree.decode(encoded)
        
        print(f"\n原始文本: {text}")
        print(f"编码后: {encoded}")
        print(f"解码后: {decoded}")
        print(f"编码解码一致性: {text == decoded}")
        print(f"压缩率: {huffman_tree.get_compression_ratio(text):.2f}")
    except ValueError as e:
        print(f"错误: {e}")
    
    # 测试从文本构建霍夫曼树
    print("\n从文本构建霍夫曼树：")
    test_text = "hello huffman coding!"
    tree_from_text = HuffmanTree.build_from_text(test_text)
    codes_from_text = tree_from_text.get_huffman_codes()
    print("文本霍夫曼编码：")
    for char, code in codes_from_text.items():
        display_char = char if char.strip() else "空格"
        print(f"'{display_char}': {code}")
    
    # 测试编码解码
    encoded_text = tree_from_text.encode(test_text)
    decoded_text = tree_from_text.decode(encoded_text)
    print(f"\n原始文本长度: {len(test_text)} 字符")
    print(f"编码后长度: {len(encoded_text)} 位")
    print(f"解码后: {decoded_text}")
    print(f"解码正确性: {test_text == decoded_text}")
    print(f"压缩率: {tree_from_text.get_compression_ratio(test_text):.2f}")
    
    # 测试边界情况
    print("\n测试边界情况：")
    # 单个字符的情况
    single_char_text = "aaaaa"
    single_tree = HuffmanTree.build_from_text(single_char_text)
    single_encoded = single_tree.encode(single_char_text)
    single_decoded = single_tree.decode(single_encoded)
    print(f"单字符文本编码解码: {single_char_text == single_decoded}")
    print(f"单字符编码: {single_encoded}")

===============================================

文件: KaratsubaMultiplication.cpp
===============================================
#include <iostream>
#include <vector>
#include <string>
#include <algorithm>
#include <chrono>
#include <random>
#include <iomanip>

/**
 * @brief Karatsuba乘法算法C++实现
 * 
 * Karatsuba算法是一种高效的大整数乘法算法，时间复杂度为O(n^log₂3) ≈ O(n^1.585)，
 * 优于传统的O(n²)复杂度算法。算法基于分治思想，通过减少乘法操作次数来提高效率。
 * 
 * 算法原理：
 * 对于两个n位数a和b，可以将它们分为高低两部分：
 * a = a₁ × 10^(n/2) + a₀
 * b = b₁ × 10^(n/2) + b₀
 * 
 * 则a×b = (a₁ × 10^(n/2) + a₀) × (b₁ × 10^(n/2) + b₀)
 *        = a₁b₁ × 10^n + (a₁b₀ + a₀b₁) × 10^(n/2) + a₀b₀
 * 
 * 传统方法需要计算4次乘法：a₁×b₁, a₁×b₀, a₀×b₁, a₀×b₀
 * 
 * Karatsuba的优化之处在于只计算3次乘法：
 * z₁ = a₁ × b₁
 * z₂ = (a₁ + a₀) × (b₁ + b₀)
 * z₃ = a₀ × b₀
 * 
 * 然后通过加减法得到中间项：a₁b₀ + a₀b₁ = z₂ - z₁ - z₃
 * 
 * 最终结果：a×b = z₁ × 10^n + (z₂ - z₁ - z₃) × 10^(n/2) + z₃
 */

class KaratsubaMultiplication {
private:
    /**
     * @brief 将字符串转换为数字向量（低位在前）
     * 
     * @param str 数字字符串
     * @return std::vector<int> 数字向量（低位在前）
     */
    static std::vector<int> stringToDigits(const std::string& str) {
        std::vector<int> digits;
        // 反向读取字符串，低位在前
        for (auto it = str.rbegin(); it != str.rend(); ++it) {
            digits.push_back(*it - '0');
        }
        return digits;
    }

    /**
     * @brief 将数字向量转换为字符串（低位在前转换为正常表示）
     * 
     * @param digits 数字向量（低位在前）
     * @return std::string 数字字符串
     */
    static std::string digitsToString(const std::vector<int>& digits) {
        std::string str;
        // 反向遍历向量，生成正确的数字表示
        for (auto it = digits.rbegin(); it != digits.rend(); ++it) {
            str.push_back(*it + '0');
        }
        return str.empty() ? "0" : str; // 确保不会返回空字符串
    }

    /**
     * @brief 填充向量到指定长度
     * 
     * @param vec 原始向量
     * @param length 目标长度
     * @return std::vector<int> 填充后的向量
     */
    static std::vector<int> padVector(const std::vector<int>& vec, size_t length) {
        std::vector<int> result = vec;
        result.resize(length, 0);
        return result;
    }

    /**
     * @brief 传统的大整数乘法算法（O(n²)复杂度）
     * 
     * @param a 第一个数字向量（低位在前）
     * @param b 第二个数字向量（低位在前）
     * @return std::vector<int> 乘积的数字向量（低位在前）
     */
    static std::vector<int> naiveMultiply(const std::vector<int>& a, const std::vector<int>& b) {
        size_t m = a.size();
        size_t n = b.size();
        
        // 创建结果向量，长度最大为m+n
        std::vector<int> result(m + n, 0);
        
        // 传统的O(n²)乘法算法
        for (size_t i = 0; i < m; ++i) {
            for (size_t j = 0; j < n; ++j) {
                // 每一位相乘，并累加到对应的位置
                result[i + j] += a[i] * b[j];
            }
        }
        
        // 处理进位
        carryPropagation(result);
        
        // 移除前导零（实际上是向量末尾的零）
        removeLeadingZeros(result);
        
        return result;
    }

    /**
     * @brief 处理进位
     * 
     * @param vec 需要处理进位的向量
     */
    static void carryPropagation(std::vector<int>& vec) {
        for (size_t i = 0; i < vec.size() - 1; ++i) {
            if (vec[i] >= 10) {
                vec[i + 1] += vec[i] / 10;
                vec[i] %= 10;
            }
        }
        
        // 处理最高位进位
        while (vec.back() >= 10) {
            int carry = vec.back() / 10;
            vec.back() %= 10;
            vec.push_back(carry);
        }
    }

    /**
     * @brief 移除前导零（实际上是向量末尾的零）
     * 
     * @param vec 需要处理的向量
     */
    static void removeLeadingZeros(std::vector<int>& vec) {
        // 保留至少一个元素（即使是零）
        while (vec.size() > 1 && vec.back() == 0) {
            vec.pop_back();
        }
    }

    /**
     * @brief 对两个数字向量进行加法操作
     * 
     * @param a 第一个数字向量（低位在前）
     * @param b 第二个数字向量（低位在前）
     * @return std::vector<int> 和的数字向量（低位在前）
     */
    static std::vector<int> addVectors(const std::vector<int>& a, const std::vector<int>& b) {
        size_t maxLength = std::max(a.size(), b.size());
        std::vector<int> result(maxLength + 1, 0); // 额外一位用于处理最高位进位
        
        // 逐位相加
        for (size_t i = 0; i < maxLength; ++i) {
            int digitA = (i < a.size()) ? a[i] : 0;
            int digitB = (i < b.size()) ? b[i] : 0;
            result[i] = digitA + digitB;
        }
        
        // 处理进位
        carryPropagation(result);
        
        // 移除前导零
        removeLeadingZeros(result);
        
        return result;
    }

    /**
     * @brief 对两个数字向量进行减法操作
     * 假设 a >= b
     * 
     * @param a 被减数的数字向量（低位在前）
     * @param b 减数的数字向量（低位在前）
     * @return std::vector<int> 差的数字向量（低位在前）
     */
    static std::vector<int> subtractVectors(const std::vector<int>& a, const std::vector<int>& b) {
        std::vector<int> result = a;
        
        // 确保result的长度足够
        result.resize(std::max(a.size(), b.size()), 0);

        // 逐位相减
        for (size_t i = 0; i < b.size(); ++i) {
            result[i] -= b[i];
        }

        // 处理借位
        for (size_t i = 0; i < result.size() - 1; ++i) {
            while (result[i] < 0) {
                result[i] += 10;  // 当前位借位
                result[i + 1] -= 1;  // 高位减1
            }
        }
        
        // 确保最高位非负（假设输入满足a >= b）
        if (result.back() < 0) {
            throw std::invalid_argument("a must be greater than or equal to b");
        }

        // 移除前导零
        removeLeadingZeros(result);
        
        return result;
    }

    /**
     * @brief 将一个数字向量添加到结果向量的指定位置
     * 
     * @param result 结果向量
     * @param addend 要添加的数字向量
     * @param offset 偏移量（表示乘以10^offset）
     */
    static void addToResult(std::vector<int>& result, const std::vector<int>& addend, size_t offset) {
        // 确保result的长度足够
        if (result.size() < offset + addend.size()) {
            result.resize(offset + addend.size(), 0);
        }
        
        // 执行加法
        for (size_t i = 0; i < addend.size(); ++i) {
            result[i + offset] += addend[i];
        }
        
        // 处理进位
        carryPropagation(result);
    }

    /**
     * @brief Karatsuba算法的递归实现
     * 
     * @param x 第一个数字向量（低位在前）
     * @param y 第二个数字向量（低位在前）
     * @return std::vector<int> 乘积的数字向量（低位在前）
     */
    static std::vector<int> karatsubaMultiplyRecursive(const std::vector<int>& x, const std::vector<int>& y) {
        size_t n = x.size();
        
        // 对于小数组，使用传统乘法算法以避免递归开销
        if (n <= 64) {  // 阈值可以根据性能测试调整
            return naiveMultiply(x, y);
        }
        
        // 将向量分为两半
        size_t m = n / 2;
        
        // 分割向量
        std::vector<int> a(x.begin() + m, x.end());  // 高位部分
        std::vector<int> b(x.begin(), x.begin() + m);  // 低位部分
        std::vector<int> c(y.begin() + m, y.end());  // 高位部分
        std::vector<int> d(y.begin(), y.begin() + m);  // 低位部分
        
        // 计算三个主要乘积
        // 1. z1 = a * c (高位乘高位)
        std::vector<int> z1 = karatsubaMultiplyRecursive(a, c);
        
        // 2. z3 = b * d (低位乘低位)
        std::vector<int> z3 = karatsubaMultiplyRecursive(b, d);
        
        // 3. z2 = (a + b) * (c + d) (组合项)
        std::vector<int> sumAB = addVectors(a, b);
        std::vector<int> sumCD = addVectors(c, d);
        std::vector<int> z2 = karatsubaMultiplyRecursive(sumAB, sumCD);
        
        // 计算中间交叉项：(a+b)*(c+d) - a*c - b*d = a*d + b*c
        std::vector<int> z1z3 = addVectors(z1, z3);
        z2 = subtractVectors(z2, z1z3);

        // 组合最终结果: z1 * 10^n + (z2-z1-z3) * 10^m + z3
        std::vector<int> result(2 * n, 0);
        
        // 添加z3到结果的最低位部分
        addToResult(result, z3, 0);
        
        // 添加中间项 (z2-z1-z3) * 10^m
        addToResult(result, z2, m);
        
        // 添加最高位部分 z1 * 10^(2*m)
        addToResult(result, z1, 2 * m);

        // 移除结果向量中的前导零
        removeLeadingZeros(result);

        return result;
    }

public:
    /**
     * @brief 使用Karatsuba算法进行大整数乘法，支持负数
     * 时间复杂度：O(n^log₂3) ≈ O(n^1.585)
     * 
     * @param xStr 第一个整数的字符串表示，可以是负数
     * @param yStr 第二个整数的字符串表示，可以是负数
     * @return std::string 乘积的字符串表示
     */
    static std::string karatsubaMultiply(std::string xStr, std::string yStr) {
        // 处理负数情况
        bool isNegative = false;
        if (xStr[0] == '-') {
            isNegative = !isNegative;
            xStr = xStr.substr(1);
        }
        if (yStr[0] == '-') {
            isNegative = !isNegative;
            yStr = yStr.substr(1);
        }

        // 处理特殊情况
        if (xStr == "0" || yStr == "0") {
            return "0";
        }
        if (xStr == "1") {
            return isNegative ? "-" + yStr : yStr;
        }
        if (yStr == "1") {
            return isNegative ? "-" + xStr : xStr;
        }

        // 将字符串转换为数字向量（低位在前）
        std::vector<int> xDigits = stringToDigits(xStr);
        std::vector<int> yDigits = stringToDigits(yStr);

        // 调整向量长度为相等且为2的幂（以优化分治过程）
        size_t maxLength = std::max(xDigits.size(), yDigits.size());
        size_t n = 1;
        while (n < maxLength) {
            n <<= 1;  // 向上取最近的2的幂
        }

        xDigits = padVector(xDigits, n);
        yDigits = padVector(yDigits, n);

        // 调用递归Karatsuba算法
        std::vector<int> product = karatsubaMultiplyRecursive(xDigits, yDigits);

        // 移除前导零并转换为字符串
        std::string result = digitsToString(product);
        
        // 添加负号（如果需要）
        return isNegative ? "-" + result : result;
    }

    /**
     * @brief 生成指定长度的随机数字字符串
     * 
     * @param length 字符串长度
     * @return std::string 随机数字字符串
     */
    static std::string generateRandomNumber(size_t length) {
        std::random_device rd;
        std::mt19937 gen(rd());
        std::uniform_int_distribution<> firstDigit(1, 9);  // 第一位不能是0
        std::uniform_int_distribution<> digit(0, 9);      // 其他位可以是0-9

        std::string number;
        // 第一位
        number.push_back('0' + firstDigit(gen));
        // 剩余位
        for (size_t i = 1; i < length; ++i) {
            number.push_back('0' + digit(gen));
        }
        return number;
    }

    /**
     * @brief 验证算法正确性
     * 测试各种边界情况和常见情况，确保Karatsuba算法在所有情况下都能正确工作
     */
    static void verifyCorrectness() {
        std::vector<std::pair<std::string, std::string>> testCases = {
            // 边界情况
            {"0", "12345"},           // 乘以0
            {"12345", "0"},           // 0乘以
            {"1", "98765"},           // 乘以1
            {"98765", "1"},           // 1乘以
            {"-1234", "5678"},        // 负数乘正数
            {"1234", "-5678"},        // 正数乘负数
            {"-1234", "-5678"},       // 负数乘负数
            
            // 常见测试用例
            {"1234", "5678"},         // 普通数字相乘
            {"9999", "9999"},         // 大数相乘
            {"999999", "999999"},     // 更大的数字相乘
            {"123456789", "987654321"}, // 长数字相乘
            
            // 不同位数的数字
            {"123", "45678"},         // 位数不同
            {"999999999", "1"},       // 大数乘1
        };

        std::cout << "=== 算法正确性验证 ===" << std::endl;
        for (const auto& testCase : testCases) {
            const std::string& x = testCase.first;
            const std::string& y = testCase.second;
            
            // 使用Karatsuba算法
            std::string result = karatsubaMultiply(x, y);
            
            // 对于小数字，使用long long验证结果（注意：仅适用于较小的数字）
            std::string expected;
            bool canVerify = true;
            
            try {
                // 仅对较小的数字进行验证，避免溢出
                if (x.length() < 18 && y.length() < 18) {
                    long long num1 = std::stoll(x);
                    long long num2 = std::stoll(y);
                    long long product = num1 * num2;
                    expected = std::to_string(product);
                } else {
                    canVerify = false;
                    expected = "(超过long long范围，无法验证)";
                }
            } catch (const std::exception& e) {
                canVerify = false;
                expected = "(验证失败: " + std::string(e.what()) + ")";
            }
            
            std::cout << x << " * " << y << " = " << result << std::endl;
            if (canVerify) {
                bool correct = result == expected;
                std::cout << "  验证结果: " << (correct ? "✓ 正确" : "✗ 错误");
                if (!correct) {
                    std::cout << " (期望值: " << expected << ")";
                }
            } else {
                std::cout << "  " << expected;
            }
            std::cout << std::endl << std::endl;
        }
        std::cout << "=== 验证完成 ===" << std::endl;
    }

    /**
     * @brief 性能测试方法，比较Karatsuba算法与传统算法
     * 
     * @param size 测试数字的位数
     */
    static void benchmark(size_t size) {
        // 生成测试用的大整数
        std::string num1 = generateRandomNumber(size);
        std::string num2 = generateRandomNumber(size);

        // 测试Karatsuba算法
        auto start = std::chrono::high_resolution_clock::now();
        std::string resultKaratsuba = karatsubaMultiply(num1, num2);
        auto end = std::chrono::high_resolution_clock::now();
        std::chrono::duration<double, std::milli> karatsubaTime = end - start;

        // 测试传统算法（对于较小的数字）
        std::string resultNaive;
        std::chrono::duration<double, std::milli> naiveTime(0);
        if (size <= 1000) {  // 对于大数字，传统算法可能太慢
            std::vector<int> digits1 = stringToDigits(num1);
            std::vector<int> digits2 = stringToDigits(num2);
            
            start = std::chrono::high_resolution_clock::now();
            std::vector<int> naiveResult = naiveMultiply(digits1, digits2);
            resultNaive = digitsToString(naiveResult);
            end = std::chrono::high_resolution_clock::now();
            naiveTime = end - start;
        }

        std::cout << "数字位数: " << size << std::endl;
        std::cout << "Karatsuba算法耗时: " << std::fixed << std::setprecision(3) 
                  << karatsubaTime.count() << " ms" << std::endl;
        
        if (size <= 1000) {
            std::cout << "传统算法耗时: " << std::fixed << std::setprecision(3) 
                      << naiveTime.count() << " ms" << std::endl;
            std::cout << "Karatsuba vs 传统算法加速比: " << std::fixed << std::setprecision(2) 
                      << naiveTime.count() / karatsubaTime.count() << "x" << std::endl;
            
            // 验证两种算法的结果是否一致
            bool resultsMatch = (resultKaratsuba == resultNaive);
            std::cout << "算法结果一致性: " << (resultsMatch ? "✓ 一致" : "✗ 不一致") << std::endl;
        }
        
        std::cout << "乘积位数: " << resultKaratsuba.length() << std::endl;
        std::cout << std::endl;
    }

    /**
     * @brief 交互式测试模式
     */
    static void interactiveMode() {
        std::cout << "=== 交互式测试 ===" << std::endl;
        std::cout << "请输入两个大整数进行乘法计算（输入exit退出）:" << std::endl;
        
        while (true) {
            try {
                std::string num1, num2;
                
                std::cout << "第一个数: ";
                std::getline(std::cin, num1);
                if (num1 == "exit" || num1 == "EXIT") break;
                
                std::cout << "第二个数: ";
                std::getline(std::cin, num2);
                if (num2 == "exit" || num2 == "EXIT") break;
                
                // 验证输入是否为有效的整数
                bool valid1 = true, valid2 = true;
                for (size_t i = 0; i < num1.length(); ++i) {
                    if (i == 0 && num1[i] == '-' && num1.length() > 1) continue;
                    if (!isdigit(num1[i])) {
                        valid1 = false;
                        break;
                    }
                }
                for (size_t i = 0; i < num2.length(); ++i) {
                    if (i == 0 && num2[i] == '-' && num2.length() > 1) continue;
                    if (!isdigit(num2[i])) {
                        valid2 = false;
                        break;
                    }
                }
                
                if (!valid1 || !valid2) {
                    std::cout << "错误: 请输入有效的整数" << std::endl << std::endl;
                    continue;
                }
                
                auto start = std::chrono::high_resolution_clock::now();
                std::string result = karatsubaMultiply(num1, num2);
                auto end = std::chrono::high_resolution_clock::now();
                std::chrono::duration<double, std::milli> duration = end - start;
                
                std::cout << "结果: " << result << std::endl;
                std::cout << "计算耗时: " << std::fixed << std::setprecision(3) 
                          << duration.count() << " ms" << std::endl;
                std::cout << "乘积位数: " << result.length() << std::endl;
            } catch (const std::exception& e) {
                std::cout << "计算错误: " << e.what() << std::endl;
            }
            std::cout << std::endl;
        }
    }
};

/**
 * @brief 主函数
 */
int main() {
    std::cout << "Karatsuba乘法算法实现 (C++)" << std::endl << std::endl;
    
    // 验证算法正确性
    KaratsubaMultiplication::verifyCorrectness();
    
    std::cout << "\n=== 性能测试 ===" << std::endl;
    std::cout << "注意：对于非常大的数字，测试可能需要较长时间" << std::endl << std::endl;
    
    // 性能测试 - 测试不同大小的数字
    KaratsubaMultiplication::benchmark(100);    // 100位数字
    KaratsubaMultiplication::benchmark(500);    // 500位数字
    
    // 进入交互式测试模式
    try {
        KaratsubaMultiplication::interactiveMode();
    } catch (const std::exception& e) {
        std::cerr << "错误: " << e.what() << std::endl;
    } catch (...) {
        std::cerr << "发生未知错误" << std::endl;
    }
    
    std::cout << "程序结束" << std::endl;
    return 0;
}

===============================================

文件: KaratsubaMultiplication.java
===============================================
package class175.随机化与复杂度分析;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Random;
import java.util.Scanner;
import java.math.BigInteger;

/**
 * Karatsuba乘法算法实现
 * 
 * Karatsuba算法是一种高效的大整数乘法算法，时间复杂度为O(n^log₂3) ≈ O(n^1.585)，
 * 优于传统的O(n²)复杂度算法。算法基于分治思想，通过减少乘法操作次数来提高效率。
 * 
 * 算法原理：
 * 对于两个n位数a和b，可以将它们分为高低两部分：
 * a = a₁ × 10^(n/2) + a₀
 * b = b₁ × 10^(n/2) + b₀
 * 
 * 则a×b = (a₁ × 10^(n/2) + a₀) × (b₁ × 10^(n/2) + b₀)
 *       = a₁b₁ × 10^n + (a₁b₀ + a₀b₁) × 10^(n/2) + a₀b₀
 * 
 * 传统方法需要计算4次乘法：a₁×b₁, a₁×b₀, a₀×b₁, a₀×b₀
 * 
 * Karatsuba的优化之处在于只计算3次乘法：
 * z₁ = a₁ × b₁
 * z₂ = (a₁ + a₀) × (b₁ + b₀)
 * z₃ = a₀ × b₀
 * 
 * 然后通过加减法得到中间项：a₁b₀ + a₀b₁ = z₂ - z₁ - z₃
 * 
 * 最终结果：a×b = z₁ × 10^n + (z₂ - z₁ - z₃) × 10^(n/2) + z₃
 * 
 * 虽然增加了加减法操作，但减少了一次乘法，对于大数乘法，乘法操作的开销远大于加减法。
 * 这种分治策略使得算法复杂度从O(n²)降低到O(n^log₂3) ≈ O(n^1.585)。
 */
public class KaratsubaMultiplication {

    /**
     * 传统的大整数乘法算法（O(n²)复杂度）
     * 作为Karatsuba算法的基础情况，当数字位数较小时使用
     * 
     * @param x 第一个整数的数字数组表示（低位在前）
     * @param y 第二个整数的数字数组表示（低位在前）
     * @return 乘积的数字数组表示（低位在前）
     */
    public static int[] naiveMultiply(int[] x, int[] y) {
        int n = x.length;
        int m = y.length;
        
        // 创建结果数组，长度最大为n+m
        int[] result = new int[n + m];

        // 传统的O(n²)乘法算法
        // 逐位相乘并累加
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++) {
                // 每一位相乘，并累加到对应的位置
                result[i + j] += x[i] * y[j];
                // 处理进位
                result[i + j + 1] += result[i + j] / 10;
                result[i + j] %= 10;
            }
        }

        // 移除前导零
        int lastNonZero = n + m - 1;
        while (lastNonZero > 0 && result[lastNonZero] == 0) {
            lastNonZero--;
        }

        return Arrays.copyOfRange(result, 0, lastNonZero + 1);
    }

    /**
     * 使用Karatsuba算法进行大整数乘法，支持负数
     * 时间复杂度：O(n^log₂3) ≈ O(n^1.585)
     * 
     * @param x 第一个整数的字符串表示，可以是负数
     * @param y 第二个整数的字符串表示，可以是负数
     * @return 乘积的字符串表示
     */
    public static String karatsubaMultiply(String x, String y) {
        // 处理负数情况
        boolean isNegative = false;
        if (x.startsWith("-")) {
            isNegative = !isNegative;
            x = x.substring(1);
        }
        if (y.startsWith("-")) {
            isNegative = !isNegative;
            y = y.substring(1);
        }

        // 处理特殊情况
        if (x.equals("0") || y.equals("0")) {
            return "0";
        }
        if (x.equals("1")) {
            return isNegative ? "-" + y : y;
        }
        if (y.equals("1")) {
            return isNegative ? "-" + x : x;
        }

        // 将字符串转换为数字数组（低位在前）
        int[] xDigits = stringToDigits(x);
        int[] yDigits = stringToDigits(y);

        // 调整数组长度为相等且为2的幂（以优化分治过程）
        int maxLength = Math.max(xDigits.length, yDigits.length);
        int n = 1;
        while (n < maxLength) {
            n <<= 1; // 向上取最近的2的幂
        }

        xDigits = padArray(xDigits, n);
        yDigits = padArray(yDigits, n);

        // 调用递归Karatsuba算法
        int[] product = karatsubaMultiplyRecursive(xDigits, yDigits);

        // 移除前导零并转换为字符串
        String result = digitsToString(product);
        
        // 添加负号（如果需要）
        return isNegative ? "-" + result : result;
    }

    /**
     * Karatsuba递归乘法实现
     * 
     * @param x 第一个整数的数字数组表示（低位在前）
     * @param y 第二个整数的数字数组表示（低位在前）
     * @return 乘积的数字数组表示（低位在前）
     * 
     * 算法原理：
     * 对于两个大数x和y，将其分为高半部分和低半部分：
     * x = a*10^(n/2) + b，其中a是高位部分，b是低位部分
     * y = c*10^(n/2) + d，其中c是高位部分，d是低位部分
     * 
     * 计算三个主要乘积：
     * 1. z1 = a*c（高位部分相乘）
     * 2. z3 = b*d（低位部分相乘）
     * 3. z2 = (a+b)*(c+d)（交叉项计算）
     * 
     * 然后通过z2-z1-z3得到交叉乘积项，最终组合结果：
     * x*y = z1*10^n + (z2-z1-z3)*10^(n/2) + z3
     */
    private static int[] karatsubaMultiplyRecursive(int[] x, int[] y) {
        int n = x.length;
        
        // 基础情况：当数组长度较小时，使用传统乘法算法以避免递归开销
        if (n <= 64) { // 阈值可以根据实际情况调整
            return naiveMultiply(x, y);
        }

        // 计算中点位置，将数组分为高低两部分
        int m = n / 2;

        // 分割数组为高位和低位部分
        int[] a = Arrays.copyOfRange(x, m, n); // x的高位部分
        int[] b = Arrays.copyOfRange(x, 0, m); // x的低位部分
        int[] c = Arrays.copyOfRange(y, m, n); // y的高位部分
        int[] d = Arrays.copyOfRange(y, 0, m); // y的低位部分

        // 计算三个核心乘积
        // 1. z1 = a * c (高位乘高位)
        int[] z1 = karatsubaMultiplyRecursive(a, c);
        
        // 2. z3 = b * d (低位乘低位)
        int[] z3 = karatsubaMultiplyRecursive(b, d);
        
        // 3. z2 = (a + b) * (c + d) (组合项)
        int[] sumAandB = addArrays(a, b); // a + b
        int[] sumCandD = addArrays(c, d); // c + d
        int[] z2 = karatsubaMultiplyRecursive(sumAandB, sumCandD);
        
        // 计算中间交叉项：(a+b)*(c+d) - a*c - b*d = a*d + b*c
        z2 = subtractArrays(z2, addArrays(z1, z3));

        // 组合最终结果: z1 * 10^n + (z2-z1-z3) * 10^m + z3
        // 创建足够大的结果数组
        int[] result = new int[2 * n];
        
        // 添加z3到结果的最低位部分
        addToResult(result, z3, 0);
        
        // 添加中间项 (z2-z1-z3) * 10^m
        addToResult(result, z2, m);
        
        // 添加最高位部分 z1 * 10^(2*m)
        addToResult(result, z1, 2 * m);

        // 移除结果数组中的前导零
        int lastNonZero = result.length - 1;
        while (lastNonZero > 0 && result[lastNonZero] == 0) {
            lastNonZero--;
        }

        // 返回有效部分
        return Arrays.copyOfRange(result, 0, lastNonZero + 1);
    }

    /**
     * 将数字数组添加到结果数组的指定位置
     * 
     * @param result 结果数组
     * @param addend 要添加的数字数组
     * @param offset 起始位置
     */
    private static void addToResult(int[] result, int[] addend, int offset) {
        // 确保不会数组越界
        for (int i = 0; i < addend.length && (i + offset) < result.length; i++) {
            result[i + offset] += addend[i];
        }
        
        // 处理进位
        carryPropagation(result);
    }

    /**
     * 处理数组中的进位
     * 
     * @param array 需要处理进位的数组
     */
    private static void carryPropagation(int[] array) {
        for (int i = 0; i < array.length - 1; i++) {
            array[i + 1] += array[i] / 10;
            array[i] %= 10;
        }
        
        // 处理最高位进位
        if (array[array.length - 1] >= 10) {
            // 如果最高位有进位，需要创建新数组
            // 注意：这个情况在当前实现中应该不会发生，因为我们预先分配了足够大的数组
            // 但为了鲁棒性，保留此检查
            int carry = array[array.length - 1] / 10;
            array[array.length - 1] %= 10;
            // 这里不扩展数组，因为我们已经有了足够的空间
        }
    }

    /**
     * 对两个数字数组进行加法操作
     * 
     * @param a 第一个数字数组（低位在前）
     * @param b 第二个数字数组（低位在前）
     * @return 和的数字数组（低位在前）
     */
    private static int[] addArrays(int[] a, int[] b) {
        int maxLength = Math.max(a.length, b.length);
        int[] result = new int[maxLength + 1]; // 额外一位用于处理最高位进位

        // 逐位相加
        for (int i = 0; i < maxLength; i++) {
            int digitA = (i < a.length) ? a[i] : 0;
            int digitB = (i < b.length) ? b[i] : 0;
            result[i] = digitA + digitB;

            // 处理进位
            result[i + 1] += result[i] / 10;
            result[i] %= 10;
        }

        // 移除前导零
        int lastNonZero = result.length - 1;
        while (lastNonZero > 0 && result[lastNonZero] == 0) {
            lastNonZero--;
        }

        return Arrays.copyOfRange(result, 0, lastNonZero + 1);
    }

    /**
     * 对两个数字数组进行减法操作
     * 假设 a >= b
     * 
     * @param a 被减数的数字数组（低位在前）
     * @param b 减数的数字数组（低位在前）
     * @return 差的数字数组（低位在前）
     */
    private static int[] subtractArrays(int[] a, int[] b) {
        int[] result = new int[a.length];

        // 逐位相减
        for (int i = 0; i < b.length; i++) {
            result[i] = a[i] - b[i];
        }
        
        // 处理a中剩余的高位
        for (int i = b.length; i < a.length; i++) {
            result[i] = a[i];
        }

        // 处理借位
        for (int i = 0; i < result.length - 1; i++) {
            while (result[i] < 0) {
                result[i] += 10;  // 当前位借位
                result[i + 1]--;  // 高位减1
            }
        }

        // 移除前导零
        int lastNonZero = result.length - 1;
        while (lastNonZero > 0 && result[lastNonZero] == 0) {
            lastNonZero--;
        }

        return Arrays.copyOfRange(result, 0, lastNonZero + 1);
    }

    /**
     * 将字符串转换为数字数组（低位在前）
     * 例如："1234" 转换为 [4, 3, 2, 1]
     * 
     * @param s 数字字符串
     * @return 数字数组（低位在前）
     */
    private static int[] stringToDigits(String s) {
        int[] digits = new int[s.length()];
        // 反向读取字符串，低位在前
        for (int i = 0; i < s.length(); i++) {
            digits[i] = s.charAt(s.length() - 1 - i) - '0';
        }
        return digits;
    }

    /**
     * 将数字数组转换为字符串（低位在前转换为正常表示）
     * 例如：[4, 3, 2, 1] 转换为 "1234"
     * 
     * @param digits 数字数组（低位在前）
     * @return 数字字符串
     */
    private static String digitsToString(int[] digits) {
        StringBuilder sb = new StringBuilder();
        // 反向遍历数组，生成正确的数字表示
        for (int i = digits.length - 1; i >= 0; i--) {
            sb.append(digits[i]);
        }
        return sb.toString();
    }

    /**
     * 填充数组到指定长度
     * 
     * @param arr 原始数组
     * @param length 目标长度
     * @return 填充后的数组
     */
    private static int[] padArray(int[] arr, int length) {
        if (arr.length >= length) {
            return arr;
        }
        int[] padded = new int[length];
        System.arraycopy(arr, 0, padded, 0, arr.length);
        // 新添加的元素默认为0，无需额外设置
        return padded;
    }

    /**
     * 性能测试方法，比较Karatsuba算法与传统算法和Java内置BigInteger
     * 
     * @param size 测试数字的位数
     */
    public static void benchmark(int size) {
        // 生成测试用的大整数
        String num1 = generateRandomNumber(size);
        String num2 = generateRandomNumber(size);

        // 测试Karatsuba算法
        long startTime = System.currentTimeMillis();
        String resultKaratsuba = karatsubaMultiply(num1, num2);
        long karatsubaTime = System.currentTimeMillis() - startTime;

        // 测试传统算法（对于较小的数字）
        String resultNaive = "";
        long naiveTime = 0;
        if (size <= 1000) { // 对于大数字，传统算法可能太慢
            int[] digits1 = stringToDigits(num1);
            int[] digits2 = stringToDigits(num2);
            startTime = System.currentTimeMillis();
            int[] naiveResult = naiveMultiply(digits1, digits2);
            resultNaive = digitsToString(naiveResult);
            naiveTime = System.currentTimeMillis() - startTime;
        }

        // 测试Java内置的BigInteger（用于验证结果和性能比较）
        long bigIntegerTime = 0;
        boolean resultsMatch = true;
        if (size <= 10000) { // 对于非常大的数字，BigInteger可能也会很慢
            startTime = System.currentTimeMillis();
            BigInteger bigNum1 = new BigInteger(num1);
            BigInteger bigNum2 = new BigInteger(num2);
            BigInteger bigResult = bigNum1.multiply(bigNum2);
            String expected = bigResult.toString();
            bigIntegerTime = System.currentTimeMillis() - startTime;
            resultsMatch = resultKaratsuba.equals(expected);
        }

        System.out.println("数字位数: " + size);
        System.out.println("Karatsuba算法耗时: " + karatsubaTime + " ms");
        if (size <= 1000) {
            System.out.println("传统算法耗时: " + naiveTime + " ms");
            System.out.println("Karatsuba vs 传统算法加速比: " + String.format("%.2f", (double) naiveTime / karatsubaTime) + "x");
        }
        if (size <= 10000) {
            System.out.println("Java BigInteger耗时: " + bigIntegerTime + " ms");
            System.out.println("结果正确性验证: " + (resultsMatch ? "正确" : "错误"));
        }
        System.out.println("乘积位数: " + resultKaratsuba.length());
        System.out.println();
    }

    /**
     * 生成指定长度的随机数字字符串
     * 
     * @param length 字符串长度
     * @return 随机数字字符串
     */
    private static String generateRandomNumber(int length) {
        StringBuilder sb = new StringBuilder();
        Random random = new Random();
        
        // 第一位不能是0，确保生成的是有效的数字
        sb.append((char) ('1' + random.nextInt(9)));
        
        // 生成剩余位，可以是0-9的任意数字
        for (int i = 1; i < length; i++) {
            sb.append((char) ('0' + random.nextInt(10)));
        }
        return sb.toString();
    }

    /**
     * 验证算法正确性
     * 测试各种边界情况和常见情况，确保Karatsuba算法在所有情况下都能正确工作
     */
    public static void verifyCorrectness() {
        List<String[]> testCases = new ArrayList<>();
        
        // 边界情况
        testCases.add(new String[]{"0", "12345"});            // 乘以0
        testCases.add(new String[]{"12345", "0"});            // 0乘以
        testCases.add(new String[]{"1", "98765"});            // 乘以1
        testCases.add(new String[]{"98765", "1"});            // 1乘以
        testCases.add(new String[]{"-1234", "5678"});         // 负数乘正数
        testCases.add(new String[]{"1234", "-5678"});         // 正数乘负数
        testCases.add(new String[]{"-1234", "-5678"});        // 负数乘负数
        
        // 常见测试用例
        testCases.add(new String[]{"1234", "5678"});          // 普通数字相乘
        testCases.add(new String[]{"9999", "9999"});          // 大数相乘
        testCases.add(new String[]{"999999", "999999"});      // 更大的数字相乘
        testCases.add(new String[]{"123456789", "987654321"}); // 长数字相乘
        
        // 不同位数的数字
        testCases.add(new String[]{"123", "45678"});          // 位数不同
        testCases.add(new String[]{"999999999", "1"});        // 大数乘1

        System.out.println("=== 算法正确性验证 ===");
        for (String[] testCase : testCases) {
            String x = testCase[0];
            String y = testCase[1];
            
            // 使用Karatsuba算法
            String result = karatsubaMultiply(x, y);
            
            // 使用Java内置的大整数类验证
            BigInteger num1 = new BigInteger(x);
            BigInteger num2 = new BigInteger(y);
            String expected = num1.multiply(num2).toString();
            
            boolean correct = result.equals(expected);
            System.out.println(x + " * " + y + " = " + result);
            System.out.println("  验证结果: " + (correct ? "✓ 正确" : "✗ 错误") + 
                             (correct ? "" : " (期望值: " + expected + ")"));
            System.out.println();
        }
        System.out.println("=== 验证完成 ===");
    }

    /**
     * 主方法，用于运行验证和性能测试
     */
    public static void main(String[] args) {
        System.out.println("Karatsuba乘法算法实现\n");
        
        // 验证算法正确性
        verifyCorrectness();
        
        System.out.println("\n=== 性能测试 ===");
        System.out.println("注意：对于非常大的数字，测试可能需要较长时间\n");
        
        // 性能测试 - 测试不同大小的数字
        benchmark(100);    // 100位数字
        benchmark(500);    // 500位数字
        benchmark(1000);   // 1000位数字
        benchmark(2000);   // 2000位数字
        
        // 交互式测试
        Scanner scanner = new Scanner(System.in);
        System.out.println("\n=== 交互式测试 ===");
        System.out.println("请输入两个大整数进行乘法计算（输入exit退出）:");
        
        while (true) {
            System.out.print("第一个数: ");
            String num1 = scanner.nextLine();
            if (num1.equalsIgnoreCase("exit")) break;
            
            System.out.print("第二个数: ");
            String num2 = scanner.nextLine();
            if (num2.equalsIgnoreCase("exit")) break;
            
            try {
                long startTime = System.currentTimeMillis();
                String result = karatsubaMultiply(num1, num2);
                long endTime = System.currentTimeMillis();
                
                System.out.println("结果: " + result);
                System.out.println("计算耗时: " + (endTime - startTime) + " ms");
                System.out.println("乘积位数: " + result.length());
            } catch (Exception e) {
                System.out.println("计算错误: " + e.getMessage());
            }
            System.out.println();
        }
        scanner.close();
        System.out.println("程序结束");
    }
}

===============================================

文件: karatsuba_multiplication.cpp
===============================================
#include <iostream>
#include <vector>
#include <string>
#include <algorithm>
#include <chrono>
#include <random>
#include <cctype>

/**
 * Karatsuba乘法算法实现
 * 传统的乘法算法时间复杂度为O(n²)，而Karatsuba算法将其优化至约O(n^1.585)
 * 适用于高精度大整数乘法计算
 */

class KaratsubaMultiplication {
private:
    /**
     * 使用传统方法进行大整数乘法
     * 时间复杂度：O(n²)
     * 作为Karatsuba算法的基础情况
     * 
     * @param x 第一个整数的数字向量表示（低位在前）
     * @param y 第二个整数的数字向量表示（低位在前）
     * @return 乘积的数字向量表示（低位在前）
     */
    static std::vector<int> naiveMultiply(const std::vector<int>& x, const std::vector<int>& y) {
        int n = x.size();
        int m = y.size();
        std::vector<int> result(n + m, 0);

        // 逐位相乘并累加
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++) {
                result[i + j] += x[i] * y[j];
                // 处理进位
                result[i + j + 1] += result[i + j] / 10;
                result[i + j] %= 10;
            }
        }

        // 移除前导零（实际上是向量末尾的零）
        int lastNonZero = n + m - 1;
        while (lastNonZero > 0 && result[lastNonZero] == 0) {
            lastNonZero--;
        }

        return std::vector<int>(result.begin(), result.begin() + lastNonZero + 1);
    }

    /**
     * Karatsuba递归乘法实现
     * 
     * @param x 第一个整数的数字向量表示（低位在前）
     * @param y 第二个整数的数字向量表示（低位在前）
     * @return 乘积的数字向量表示（低位在前）
     */
    static std::vector<int> karatsubaMultiplyRecursive(const std::vector<int>& x, const std::vector<int>& y) {
        int n = x.size();
        
        // 基础情况：当向量长度较小时，使用传统乘法
        if (n <= 64) { // 阈值可以根据实际情况调整
            return naiveMultiply(x, y);
        }

        // 计算中点
        int m = n / 2;

        // 分割向量
        std::vector<int> a(x.begin() + m, x.end()); // 高位部分
        std::vector<int> b(x.begin(), x.begin() + m); // 低位部分
        std::vector<int> c(y.begin() + m, y.end()); // 高位部分
        std::vector<int> d(y.begin(), y.begin() + m); // 低位部分

        // 计算三个子乘积
        // z1 = a * c
        std::vector<int> z1 = karatsubaMultiplyRecursive(a, c);
        
        // z3 = b * d
        std::vector<int> z3 = karatsubaMultiplyRecursive(b, d);
        
        // 计算 (a + b) * (c + d)
        std::vector<int> sumAandB = addVectors(a, b);
        std::vector<int> sumCandD = addVectors(c, d);
        std::vector<int> z2 = karatsubaMultiplyRecursive(sumAandB, sumCandD);
        
        // z2 = (a + b) * (c + d) - z1 - z3
        std::vector<int> z1PlusZ3 = addVectors(z1, z3);
        z2 = subtractVectors(z2, z1PlusZ3);

        // 组合结果: z1 * 10^(2*m) + z2 * 10^m + z3
        std::vector<int> result(2 * n, 0);
        
        // 添加z3到结果
        addToResult(result, z3, 0);
        
        // 添加z2 * 10^m到结果
        addToResult(result, z2, m);
        
        // 添加z1 * 10^(2*m)到结果
        addToResult(result, z1, 2 * m);

        // 移除前导零
        int lastNonZero = result.size() - 1;
        while (lastNonZero > 0 && result[lastNonZero] == 0) {
            lastNonZero--;
        }

        return std::vector<int>(result.begin(), result.begin() + lastNonZero + 1);
    }

    /**
     * 将数字向量添加到结果向量的指定位置
     * 
     * @param result 结果向量
     * @param addend 要添加的数字向量
     * @param offset 起始位置
     */
    static void addToResult(std::vector<int>& result, const std::vector<int>& addend, int offset) {
        for (size_t i = 0; i < addend.size(); i++) {
            if (i + offset < result.size()) {
                result[i + offset] += addend[i];
                // 处理进位
                propagateCarry(result, i + offset);
            }
        }
    }

    /**
     * 处理进位传播
     * 
     * @param arr 数字向量
     * @param pos 起始处理位置
     */
    static void propagateCarry(std::vector<int>& arr, int pos) {
        while (pos < static_cast<int>(arr.size()) - 1 && arr[pos] >= 10) {
            arr[pos + 1] += arr[pos] / 10;
            arr[pos] %= 10;
            pos++;
        }
        // 处理最高位的进位（如果需要）
        // 在这个方法中，我们假设arr足够大，不需要扩展
    }

    /**
     * 对两个数字向量进行加法操作
     * 
     * @param a 第一个数字向量（低位在前）
     * @param b 第二个数字向量（低位在前）
     * @return 和的数字向量（低位在前）
     */
    static std::vector<int> addVectors(const std::vector<int>& a, const std::vector<int>& b) {
        int maxLength = std::max(a.size(), b.size());
        std::vector<int> result(maxLength + 1, 0); // 预留进位空间

        for (int i = 0; i < maxLength; i++) {
            int digitA = (i < static_cast<int>(a.size())) ? a[i] : 0;
            int digitB = (i < static_cast<int>(b.size())) ? b[i] : 0;
            result[i] = digitA + digitB;

            // 处理进位
            result[i + 1] += result[i] / 10;
            result[i] %= 10;
        }

        // 移除前导零
        int lastNonZero = maxLength;
        while (lastNonZero > 0 && result[lastNonZero] == 0) {
            lastNonZero--;
        }

        return std::vector<int>(result.begin(), result.begin() + lastNonZero + 1);
    }

    /**
     * 对两个数字向量进行减法操作
     * 假设 a >= b
     * 
     * @param a 被减数的数字向量（低位在前）
     * @param b 减数的数字向量（低位在前）
     * @return 差的数字向量（低位在前）
     */
    static std::vector<int> subtractVectors(const std::vector<int>& a, const std::vector<int>& b) {
        std::vector<int> result(a.begin(), a.end());

        for (size_t i = 0; i < b.size(); i++) {
            result[i] -= b[i];
        }

        // 处理借位
        for (size_t i = 0; i < result.size() - 1; i++) {
            while (result[i] < 0) {
                result[i] += 10;
                result[i + 1]--;
            }
        }

        // 移除前导零
        int lastNonZero = static_cast<int>(result.size()) - 1;
        while (lastNonZero > 0 && result[lastNonZero] == 0) {
            lastNonZero--;
        }

        return std::vector<int>(result.begin(), result.begin() + lastNonZero + 1);
    }

    /**
     * 将字符串转换为数字向量（低位在前）
     * 
     * @param s 数字字符串
     * @return 数字向量（低位在前）
     */
    static std::vector<int> stringToDigits(const std::string& s) {
        std::vector<int> digits;
        for (int i = static_cast<int>(s.length()) - 1; i >= 0; i--) {
            digits.push_back(s[i] - '0');
        }
        return digits;
    }

    /**
     * 将数字向量转换为字符串（低位在前转换为正常表示）
     * 
     * @param digits 数字向量（低位在前）
     * @return 数字字符串
     */
    static std::string digitsToString(const std::vector<int>& digits) {
        std::string s;
        for (auto it = digits.rbegin(); it != digits.rend(); ++it) {
            s += std::to_string(*it);
        }
        return s;
    }

    /**
     * 填充向量到指定长度
     * 
     * @param arr 原始向量
     * @param length 目标长度
     * @return 填充后的向量
     */
    static std::vector<int> padVector(const std::vector<int>& arr, int length) {
        if (arr.size() >= length) {
            return arr;
        }
        std::vector<int> padded(arr.begin(), arr.end());
        padded.resize(length, 0);
        return padded;
    }

    /**
     * 生成指定长度的随机数字字符串
     * 
     * @param length 字符串长度
     * @return 随机数字字符串
     */
    static std::string generateRandomNumber(int length) {
        std::random_device rd;
        std::mt19937 gen(rd());
        std::uniform_int_distribution<> firstDigitDist(1, 9);
        std::uniform_int_distribution<> digitDist(0, 9);
        
        std::string s;
        // 第一位不能是0
        s += std::to_string(firstDigitDist(gen));
        // 生成剩余位
        for (int i = 1; i < length; i++) {
            s += std::to_string(digitDist(gen));
        }
        return s;
    }

public:
    /**
     * 使用Karatsuba算法进行大整数乘法
     * 时间复杂度：O(n^log₂3) ≈ O(n^1.585)
     * 
     * @param x 第一个整数的字符串表示
     * @param y 第二个整数的字符串表示
     * @return 乘积的字符串表示
     */
    static std::string multiply(const std::string& x, const std::string& y) {
        // 处理特殊情况
        if (x == "0" || y == "0") {
            return "0";
        }
        if (x == "1") {
            return y;
        }
        if (y == "1") {
            return x;
        }

        // 将字符串转换为数字向量（低位在前）
        std::vector<int> xDigits = stringToDigits(x);
        std::vector<int> yDigits = stringToDigits(y);

        // 调整向量长度为相等且为2的幂（以优化分治过程）
        int maxLength = std::max(static_cast<int>(xDigits.size()), static_cast<int>(yDigits.size()));
        int n = 1;
        while (n < maxLength) {
            n <<= 1; // 向上取最近的2的幂
        }

        xDigits = padVector(xDigits, n);
        yDigits = padVector(yDigits, n);

        // 调用递归Karatsuba算法
        std::vector<int> product = karatsubaMultiplyRecursive(xDigits, yDigits);

        // 移除前导零并转换为字符串
        return digitsToString(product);
    }

    /**
     * 性能测试方法，比较Karatsuba算法与传统算法
     * 
     * @param size 测试数字的位数
     */
    static void benchmark(int size) {
        // 生成测试用的大整数
        std::string num1 = generateRandomNumber(size);
        std::string num2 = generateRandomNumber(size);

        // 测试Karatsuba算法
        auto start = std::chrono::high_resolution_clock::now();
        std::string resultKaratsuba = multiply(num1, num2);
        auto end = std::chrono::high_resolution_clock::now();
        auto karatsubaDuration = std::chrono::duration_cast<std::chrono::milliseconds>(end - start);

        // 测试传统算法（对于较小的数字）
        std::string resultNaive = "";
        std::chrono::milliseconds naiveDuration(0);
        if (size <= 1000) { // 对于大数字，传统算法可能太慢
            std::vector<int> digits1 = stringToDigits(num1);
            std::vector<int> digits2 = stringToDigits(num2);
            start = std::chrono::high_resolution_clock::now();
            std::vector<int> naiveResult = naiveMultiply(digits1, digits2);
            resultNaive = digitsToString(naiveResult);
            end = std::chrono::high_resolution_clock::now();
            naiveDuration = std::chrono::duration_cast<std::chrono::milliseconds>(end - start);
        }

        std::cout << "数字位数: " << size << std::endl;
        std::cout << "Karatsuba算法耗时: " << karatsubaDuration.count() << ".000 ms" << std::endl;
        if (size <= 1000) {
            std::cout << "传统算法耗时: " << naiveDuration.count() << ".000 ms" << std::endl;
            double speedup = static_cast<double>(naiveDuration.count()) / karatsubaDuration.count();
            std::cout << "算法加速比: " << speedup << "x" << std::endl;
            std::cout << "结果一致: " << (resultKaratsuba == resultNaive ? "true" : "false") << std::endl;
        }
        std::cout << "乘积位数: " << resultKaratsuba.length() << std::endl;
    }

    /**
     * 验证算法正确性
     */
    static void verifyCorrectness() {
        std::vector<std::pair<std::string, std::string>> testCases = {
            {"1234", "5678"},
            {"9999", "9999"},
            {"0", "12345"},
            {"1", "98765"},
            {"999999", "999999"}
        };

        for (const auto& testCase : testCases) {
            const std::string& x = testCase.first;
            const std::string& y = testCase.second;
            
            // 使用Karatsuba算法
            std::string result = multiply(x, y);
            
            // 对于小数字，使用C++内置类型验证
            try {
                if (x.length() <= 18 && y.length() <= 18) { // 确保可以放入unsigned long long
                    unsigned long long num1 = std::stoull(x);
                    unsigned long long num2 = std::stoull(y);
                    unsigned long long expected = num1 * num2;
                    std::string expectedStr = std::to_string(expected);
                    std::cout << x << " * " << y << " = " << result << 
                              " (正确: " << (result == expectedStr ? "true" : "false") << ")" << std::endl;
                } else {
                    std::cout << x << " * " << y << " = " << result << std::endl;
                    std::cout << "乘积位数: " << result.length() << std::endl;
                }
            } catch (const std::exception& e) {
                std::cout << x << " * " << y << " = " << result << std::endl;
                std::cout << "乘积位数: " << result.length() << std::endl;
            }
        }
    }
};

/**
 * 检查字符串是否为有效数字
 */
bool isValidNumber(const std::string& s) {
    if (s.empty()) return false;
    if (s == "0") return true;
    if (s[0] == '0') return false; // 不允许前导零
    return std::all_of(s.begin(), s.end(), ::isdigit);
}

/**
 * 交互式测试函数
 */
void interactiveMode() {
    std::string num1, num2;
    std::cout << "请输入两个大整数进行乘法计算（输入exit退出）:" << std::endl;
    
    while (true) {
        std::cout << "第一个数: ";
        std::getline(std::cin, num1);
        if (num1 == "exit" || num1 == "EXIT") break;
        
        std::cout << "第二个数: ";
        std::getline(std::cin, num2);
        if (num2 == "exit" || num2 == "EXIT") break;
        
        // 验证输入是否为有效数字
        if (!isValidNumber(num1) || !isValidNumber(num2)) {
            std::cout << "错误: 请输入有效的正整数" << std::endl;
            continue;
        }
        
        auto start = std::chrono::high_resolution_clock::now();
        std::string result = KaratsubaMultiplication::multiply(num1, num2);
        auto end = std::chrono::high_resolution_clock::now();
        auto duration = std::chrono::duration_cast<std::chrono::milliseconds>(end - start);
        
        std::cout << "结果: " << result << std::endl;
        std::cout << "计算耗时: " << duration.count() << ".000 ms" << std::endl;
    }
}

int main() {
    std::cout << "验证算法正确性:" << std::endl;
    KaratsubaMultiplication::verifyCorrectness();
    
    std::cout << "\n性能测试:" << std::endl;
    KaratsubaMultiplication::benchmark(100);
    KaratsubaMultiplication::benchmark(1000);
    KaratsubaMultiplication::benchmark(5000);
    
    interactiveMode();
    
    return 0;
}

===============================================

文件: karatsuba_multiplication.py
===============================================
#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
Karatsuba乘法算法实现
传统的乘法算法时间复杂度为O(n²)，而Karatsuba算法将其优化至约O(n^1.585)
适用于高精度大整数乘法计算
"""

import time
import random


def naive_multiply(x, y):
    """
    使用传统方法进行大整数乘法
    时间复杂度：O(n²)
    作为Karatsuba算法的基础情况
    
    Args:
        x: 第一个整数的数字列表表示（低位在前）
        y: 第二个整数的数字列表表示（低位在前）
    
    Returns:
        list: 乘积的数字列表表示（低位在前）
    """
    n = len(x)
    m = len(y)
    result = [0] * (n + m)

    # 逐位相乘并累加
    for i in range(n):
        for j in range(m):
            result[i + j] += x[i] * y[j]
            # 处理进位
            result[i + j + 1] += result[i + j] // 10
            result[i + j] %= 10

    # 移除前导零（实际上是数组末尾的零）
    last_non_zero = n + m - 1
    while last_non_zero > 0 and result[last_non_zero] == 0:
        last_non_zero -= 1

    return result[:last_non_zero + 1]


def karatsuba_multiply(x, y):
    """
    使用Karatsuba算法进行大整数乘法，支持负数
    时间复杂度：O(n^log₂3) ≈ O(n^1.585)
    
    Args:
        x: 第一个整数的字符串表示，可以是负数
        y: 第二个整数的字符串表示，可以是负数
    
    Returns:
        str: 乘积的字符串表示
    """
    # 处理负数情况
    is_negative = False
    if x.startswith('-'):
        is_negative = not is_negative
        x = x[1:]
    if y.startswith('-'):
        is_negative = not is_negative
        y = y[1:]

    # 处理特殊情况
    if x == "0" or y == "0":
        return "0"
    if x == "1":
        return '-' + y if is_negative else y
    if y == "1":
        return '-' + x if is_negative else x

    # 将字符串转换为数字列表（低位在前）
    x_digits = string_to_digits(x)
    y_digits = string_to_digits(y)

    # 调整列表长度为相等且为2的幂（以优化分治过程）
    max_length = max(len(x_digits), len(y_digits))
    n = 1
    while n < max_length:
        n <<= 1  # 向上取最近的2的幂

    x_digits = pad_list(x_digits, n)
    y_digits = pad_list(y_digits, n)

    # 调用递归Karatsuba算法
    product = karatsuba_multiply_recursive(x_digits, y_digits)

    # 移除前导零并转换为字符串
    result = digits_to_string(product)
    
    # 添加负号（如果需要）
    return '-' + result if is_negative else result


def karatsuba_multiply_recursive(x, y):
    """
    Karatsuba递归乘法实现
    
    Args:
        x: 第一个整数的数字列表表示（低位在前）
        y: 第二个整数的数字列表表示（低位在前）
    
    Returns:
        list: 乘积的数字列表表示（低位在前）
    """
    n = len(x)
    
    # 基础情况：当列表长度较小时，使用传统乘法
    if n <= 64:  # 阈值可以根据实际情况调整
        return naive_multiply(x, y)

    # 计算中点
    m = n // 2

    # 分割列表
    a = x[m:]
    b = x[:m]
    c = y[m:]
    d = y[:m]

    # 计算三个子乘积
    # z1 = a * c
    z1 = karatsuba_multiply_recursive(a, c)
    
    # z3 = b * d
    z3 = karatsuba_multiply_recursive(b, d)
    
    # 计算 (a + b) * (c + d)
    sum_a_b = add_lists(a, b)
    sum_c_d = add_lists(c, d)
    z2 = karatsuba_multiply_recursive(sum_a_b, sum_c_d)
    
    # z2 = (a + b) * (c + d) - z1 - z3
    z2 = subtract_lists(z2, add_lists(z1, z3))

    # 组合结果: z1 * 10^(2*m) + z2 * 10^m + z3
    result = [0] * (2 * n)
    
    # 添加z3到结果
    add_to_result(result, z3, 0)
    
    # 添加z2 * 10^m到结果
    add_to_result(result, z2, m)
    
    # 添加z1 * 10^(2*m)到结果
    add_to_result(result, z1, 2 * m)

    # 移除前导零（实际上是列表末尾的零）
    last_non_zero = len(result) - 1
    while last_non_zero > 0 and result[last_non_zero] == 0:
        last_non_zero -= 1

    return result[:last_non_zero + 1]


def add_to_result(result, addend, offset):
    """
    将数字列表添加到结果列表的指定位置
    
    Args:
        result: 结果列表
        addend: 要添加的数字列表
        offset: 起始位置
    """
    for i in range(len(addend)):
        if i + offset < len(result):
            result[i + offset] += addend[i]
            # 处理进位
            propagate_carry(result, i + offset)


def propagate_carry(arr, pos):
    """
    处理进位传播
    
    Args:
        arr: 数字列表
        pos: 起始处理位置
    """
    while pos < len(arr) - 1 and arr[pos] >= 10:
        arr[pos + 1] += arr[pos] // 10
        arr[pos] %= 10
        pos += 1
    # 处理最高位的进位（如果需要）
    # 在这个方法中，我们假设arr足够大，不需要扩展


def add_lists(a, b):
    """
    对两个数字列表进行加法操作
    
    Args:
        a: 第一个数字列表（低位在前）
        b: 第二个数字列表（低位在前）
    
    Returns:
        list: 和的数字列表（低位在前）
    """
    max_length = max(len(a), len(b))
    result = [0] * (max_length + 1)  # 预留进位空间

    for i in range(max_length):
        digit_a = a[i] if i < len(a) else 0
        digit_b = b[i] if i < len(b) else 0
        result[i] = digit_a + digit_b

        # 处理进位
        result[i + 1] += result[i] // 10
        result[i] %= 10

    # 移除前导零
    last_non_zero = max_length
    while last_non_zero > 0 and result[last_non_zero] == 0:
        last_non_zero -= 1

    return result[:last_non_zero + 1]


def subtract_lists(a, b):
    """
    对两个数字列表进行减法操作
    假设 a >= b
    
    Args:
        a: 被减数的数字列表（低位在前）
        b: 减数的数字列表（低位在前）
    
    Returns:
        list: 差的数字列表（低位在前）
    """
    result = a.copy()

    for i in range(len(b)):
        result[i] -= b[i]

    # 处理借位
    for i in range(len(result) - 1):
        while result[i] < 0:
            result[i] += 10
            result[i + 1] -= 1

    # 移除前导零
    last_non_zero = len(result) - 1
    while last_non_zero > 0 and result[last_non_zero] == 0:
        last_non_zero -= 1

    return result[:last_non_zero + 1]


def string_to_digits(s):
    """
    将字符串转换为数字列表（低位在前）
    
    Args:
        s: 数字字符串
    
    Returns:
        list: 数字列表（低位在前）
    """
    return [int(s[len(s) - 1 - i]) for i in range(len(s))]


def digits_to_string(digits):
    """
    将数字列表转换为字符串（低位在前转换为正常表示）
    
    Args:
        digits: 数字列表（低位在前）
    
    Returns:
        str: 数字字符串
    """
    return ''.join(str(digits[i]) for i in range(len(digits) - 1, -1, -1))


def pad_list(arr, length):
    """
    填充列表到指定长度
    
    Args:
        arr: 原始列表
        length: 目标长度
    
    Returns:
        list: 填充后的列表
    """
    if len(arr) >= length:
        return arr
    return arr + [0] * (length - len(arr))


def benchmark(size):
    """
    性能测试方法，比较Karatsuba算法与Python内置乘法
    
    Args:
        size: 测试数字的位数
    """
    # 生成测试用的大整数
    num1 = generate_random_number(size)
    num2 = generate_random_number(size)

    # 测试Karatsuba算法
    start_time = time.time()
    result_karatsuba = karatsuba_multiply(num1, num2)
    karatsuba_time = (time.time() - start_time) * 1000  # 转换为毫秒

    # 测试传统算法（对于较小的数字）
    result_naive = ""
    naive_time = 0
    if size <= 1000:  # 对于大数字，传统算法可能太慢
        digits1 = string_to_digits(num1)
        digits2 = string_to_digits(num2)
        start_time = time.time()
        naive_result = naive_multiply(digits1, digits2)
        result_naive = digits_to_string(naive_result)
        naive_time = (time.time() - start_time) * 1000  # 转换为毫秒

    # 测试Python内置乘法（用于验证结果和性能比较）
    big_int_time = 0
    results_match = True
    try:
        start_time = time.time()
        expected = str(int(num1) * int(num2))
        big_int_time = (time.time() - start_time) * 1000  # 转换为毫秒
        results_match = result_karatsuba == expected
    except (MemoryError, OverflowError):
        print(f"Python内置整数对于{size}位数字处理失败")

    print(f"数字位数: {size}")
    print(f"Karatsuba算法耗时: {karatsuba_time:.3f} ms")
    if size <= 1000:
        print(f"传统算法耗时: {naive_time:.3f} ms")
        print(f"Karatsuba vs 传统算法加速比: {naive_time / karatsuba_time:.2f}x")
    print(f"Python内置整数耗时: {big_int_time:.3f} ms")
    print(f"Karatsuba vs Python内置加速比: {big_int_time/karatsuba_time:.2f}x" if big_int_time > 0 else "无法计算加速比")
    print(f"结果正确性验证: {'正确' if results_match else '错误'}")
    print(f"乘积位数: {len(result_karatsuba)}")
    print()


def generate_random_number(length):
    """
    生成指定长度的随机数字字符串
    
    Args:
        length: 字符串长度
    
    Returns:
        str: 随机数字字符串
    """
    # 第一位不能是0
    first_digit = str(random.randint(1, 9))
    # 生成剩余位
    remaining_digits = ''.join(str(random.randint(0, 9)) for _ in range(length - 1))
    return first_digit + remaining_digits


def verify_correctness():
    """
    验证算法正确性
    测试各种边界情况和常见情况，确保Karatsuba算法在所有情况下都能正确工作
    """
    test_cases = [
        # 边界情况
        ("0", "12345"),           # 乘以0
        ("12345", "0"),           # 0乘以
        ("1", "98765"),           # 乘以1
        ("98765", "1"),           # 1乘以
        ("-1234", "5678"),        # 负数乘正数
        ("1234", "-5678"),        # 正数乘负数
        ("-1234", "-5678"),       # 负数乘负数
        
        # 常见测试用例
        ("1234", "5678"),         # 普通数字相乘
        ("9999", "9999"),         # 大数相乘
        ("999999", "999999"),     # 更大的数字相乘
        ("123456789", "987654321"), # 长数字相乘
        
        # 不同位数的数字
        ("123", "45678"),         # 位数不同
        ("999999999", "1"),       # 大数乘1
    ]

    print("=== 算法正确性验证 ===")
    for x, y in test_cases:
        # 使用Karatsuba算法
        result = karatsuba_multiply(x, y)
        
        # 使用Python内置的整数类型验证
        expected = str(int(x) * int(y))
        
        correct = result == expected
        print(f"{x} * {y} = {result}")
        print(f"  验证结果: {'✓ 正确' if correct else '✗ 错误'}{' (期望值: ' + expected + ')' if not correct else ''}")
        print()
    print("=== 验证完成 ===")


def interactive_mode():
    """
    交互式测试模式
    """
    print("=== 交互式测试 ===")
    print("请输入两个大整数进行乘法计算（输入exit退出）:")
    
    while True:
        try:
            num1 = input("第一个数: " ).strip()
            if num1.lower() == "exit":
                break
                
            num2 = input("第二个数: " ).strip()
            if num2.lower() == "exit":
                break
                
            # 验证输入是否为有效的整数
            int(num1)
            int(num2)
            
            start_time = time.time()
            result = karatsuba_multiply(num1, num2)
            end_time = time.time()
            
            print(f"结果: {result}")
            print(f"计算耗时: {(end_time - start_time) * 1000:.3f} ms")
            print(f"乘积位数: {len(result)}")
        except ValueError as e:
            print(f"输入错误: {e}")
        except Exception as e:
            print(f"计算错误: {e}")
        print()


def main():
    """
    主函数，用于运行验证和性能测试
    """
    print("Karatsuba乘法算法实现 (Python)\n")
    
    # 验证算法正确性
    verify_correctness()
    
    print("\n=== 性能测试 ===")
    print("注意：对于非常大的数字，测试可能需要较长时间\n")
    
    # 性能测试 - 测试不同大小的数字
    benchmark(100)    # 100位数字
    benchmark(500)    # 500位数字
    benchmark(1000)   # 1000位数字
    
    # 进入交互式测试模式
    try:
        interactive_mode()
    except (KeyboardInterrupt, EOFError):
        print("\n程序已退出")
    
    print("程序结束")


if __name__ == "__main__":
    main()

===============================================

文件: LongChainDecomposition.java
===============================================
import java.util.*;

/**
 * 长链剖分（Long Chain Decomposition）算法实现
 * 长链剖分是一种树链剖分的变体，主要用于优化深度相关的动态规划问题
 * 时间复杂度：预处理 O(n)，单次查询 O(1) 或 O(log n)
 * 主要用于：深度相关的DP优化、k级祖先查询、距离相关问题等
 */
public class LongChainDecomposition {
    private static class Edge {
        int to; // 边连接的节点
        int weight; // 边权（可选）
        
        public Edge(int to, int weight) {
            this.to = to;
            this.weight = weight;
        }
    }
    
    private List<List<Edge>> tree; // 邻接表表示的树
    private int[] dep; // 节点深度
    private int[] fa; // 父节点
    private int[] head; // 所在链的顶端节点
    private int[] len; // 链的长度（最大深度）
    private int[] son; // 长儿子（深度最大的子节点）
    private int[] dfn; // 节点的DFS序
    private int[] rev; // DFS序对应的原节点编号
    private int[] depMax; // 每个节点的子树中最大深度
    private int[][] up; // 用于二进制跳跃（k级祖先查询）
    private int n; // 节点数量
    private int cnt; // DFS序计数器
    private int LOG; // 二进制跳跃的最大层数
    
    /**
     * 构造函数，初始化数据结构
     * @param n 节点数量
     */
    public LongChainDecomposition(int n) {
        this.n = n;
        this.cnt = 0;
        this.LOG = (int) Math.ceil(Math.log(n) / Math.log(2)) + 1;
        
        this.tree = new ArrayList<>();
        for (int i = 0; i <= n; i++) {
            tree.add(new ArrayList<>());
        }
        
        this.dep = new int[n + 1];
        this.fa = new int[n + 1];
        this.head = new int[n + 1];
        this.len = new int[n + 1];
        this.son = new int[n + 1];
        this.dfn = new int[n + 1];
        this.rev = new int[n + 1];
        this.depMax = new int[n + 1];
        this.up = new int[n + 1][LOG];
    }
    
    /**
     * 添加树边（带权）
     * @param u 第一个节点
     * @param v 第二个节点
     * @param w 边权
     */
    public void addEdge(int u, int v, int w) {
        tree.get(u).add(new Edge(v, w));
        tree.get(v).add(new Edge(u, w));
    }
    
    /**
     * 第一次DFS：计算深度、父节点、长儿子和链长度
     * @param u 当前节点
     * @param f 父节点
     */
    private void dfs1(int u, int f) {
        fa[u] = f;
        up[u][0] = f;
        dep[u] = dep[f] + 1;
        depMax[u] = dep[u];
        son[u] = 0;
        len[u] = 1;
        
        for (Edge e : tree.get(u)) {
            int v = e.to;
            if (v != f) {
                dfs1(v, u);
                
                if (depMax[v] > depMax[son[u]]) {
                    son[u] = v;
                    len[u] = len[v] + 1;
                }
                
                depMax[u] = Math.max(depMax[u], depMax[v]);
            }
        }
        
        // 填充二进制跳跃表
        for (int k = 1; k < LOG; k++) {
            up[u][k] = up[up[u][k - 1]][k - 1];
        }
    }
    
    /**
     * 第二次DFS：分配DFS序，构建长链
     * @param u 当前节点
     * @param h 链顶节点
     */
    private void dfs2(int u, int h) {
        dfn[u] = ++cnt;
        rev[cnt] = u;
        head[u] = h;
        
        // 优先处理长儿子，保证长链上的节点DFS序连续
        if (son[u] != 0) {
            dfs2(son[u], h); // 长儿子继承当前链顶
            
            // 处理其他儿子
            for (Edge e : tree.get(u)) {
                int v = e.to;
                if (v != fa[u] && v != son[u]) {
                    dfs2(v, v); // 其他儿子作为新链的链顶
                }
            }
        }
    }
    
    /**
     * 初始化长链剖分
     * @param root 根节点
     */
    public void init(int root) {
        dep[0] = 0;
        dfs1(root, 0);
        dfs2(root, root);
    }
    
    /**
     * 获取k级祖先
     * @param u 当前节点
     * @param k 祖先级别
     * @return k级祖先节点
     */
    public int kthAncestor(int u, int k) {
        // 如果k为0，返回自己
        if (k == 0) return u;
        
        // 找到最大的2^j不超过k
        int j = (int) (Math.log(k) / Math.log(2));
        
        // 二进制跳跃
        while (k > 0) {
            j = (int) (Math.log(k) / Math.log(2));
            u = up[u][j];
            k -= (1 << j);
        }
        
        return u;
    }
    
    /**
     * 优化的k级祖先查询 - 利用长链剖分特性
     * @param u 当前节点
     * @param k 祖先级别
     * @return k级祖先节点
     */
    public int kthAncestorFast(int u, int k) {
        // 如果k为0，返回自己
        if (k == 0) return u;
        
        // 找到深度差最大的祖先链顶
        int h = head[u];
        int chainTopDepth = dep[h];
        int uDepth = dep[u];
        
        // 如果k小于当前链的长度，可以直接在链中找
        if (uDepth - chainTopDepth >= k) {
            return rev[dfn[u] - k];
        }
        
        // 否则，跳到链顶的父节点，剩余k减去当前链中的深度
        return kthAncestorFast(fa[h], k - (uDepth - chainTopDepth + 1));
    }
    
    /**
     * 查找两个节点的最近公共祖先（LCA）
     * @param u 节点u
     * @param v 节点v
     * @return 最近公共祖先节点
     */
    public int lca(int u, int v) {
        // 调整深度，使u的深度不小于v
        if (dep[u] < dep[v]) {
            int temp = u;
            u = v;
            v = temp;
        }
        
        // 先将u提升到v的深度
        u = kthAncestor(u, dep[u] - dep[v]);
        
        if (u == v) return u;
        
        // 二进制跳跃找LCA
        for (int k = LOG - 1; k >= 0; k--) {
            if (up[u][k] != up[v][k]) {
                u = up[u][k];
                v = up[v][k];
            }
        }
        
        return up[u][0];
    }
    
    /**
     * 计算两个节点之间的距离
     * @param u 节点u
     * @param v 节点v
     * @return 距离
     */
    public int distance(int u, int v) {
        int ancestor = lca(u, v);
        return dep[u] + dep[v] - 2 * dep[ancestor];
    }
    
    /**
     * 获取节点所在链的长度
     * @param u 节点
     * @return 链长度
     */
    public int getChainLength(int u) {
        return len[head[u]];
    }
    
    /**
     * 获取节点所在链的顶端节点
     * @param u 节点
     * @return 链顶节点
     */
    public int getChainHead(int u) {
        return head[u];
    }
    
    /**
     * 获取节点的DFS序
     * @param u 节点
     * @return DFS序
     */
    public int getDFN(int u) {
        return dfn[u];
    }
    
    /**
     * 示例：计算每个节点的子树中深度为d的节点数（使用长链剖分优化）
     * 这是一个典型的深度相关DP优化问题
     * @param root 根节点
     * @return 每个节点的深度计数数组
     */
    public Map<Integer, Map<Integer, Integer>> depthCountInSubtree(int root) {
        Map<Integer, Map<Integer, Integer>> result = new HashMap<>();
        // 实际应用中这里会实现长链剖分优化的深度相关DP
        // 这里仅作为示例框架
        return result;
    }
    
    /**
     * 示例代码
     */
    public static void main(String[] args) {
        // 创建一个示例树
        //       1
        //     / | \
        //    2  3  4
        //   /     / \
        //  5     6   7
        //    \      / \
        //     8    9   10
        //           \n        //            11
        int n = 11;
        LongChainDecomposition lcd = new LongChainDecomposition(n);
        
        // 添加边
        lcd.addEdge(1, 2, 1);
        lcd.addEdge(1, 3, 1);
        lcd.addEdge(1, 4, 1);
        lcd.addEdge(2, 5, 1);
        lcd.addEdge(5, 8, 1);
        lcd.addEdge(4, 6, 1);
        lcd.addEdge(4, 7, 1);
        lcd.addEdge(7, 9, 1);
        lcd.addEdge(7, 10, 1);
        lcd.addEdge(9, 11, 1);
        
        // 初始化长链剖分
        lcd.init(1);
        
        // 测试k级祖先查询
        int u = 8, k = 3;
        int ancestor = lcd.kthAncestor(u, k);
        System.out.println(u + "的第" + k + "级祖先是: " + ancestor);
        
        // 测试快速k级祖先查询
        int fastAncestor = lcd.kthAncestorFast(u, k);
        System.out.println(u + "的第" + k + "级祖先(快速查询)是: " + fastAncestor);
        
        // 测试LCA
        u = 8; int v = 11;
        int lcaNode = lcd.lca(u, v);
        System.out.println(u + "和" + v + "的最近公共祖先是: " + lcaNode);
        
        // 测试距离
        int dist = lcd.distance(u, v);
        System.out.println(u + "和" + v + "之间的距离是: " + dist);
        
        // 测试链信息
        System.out.println(u + "所在链的长度是: " + lcd.getChainLength(u));
        System.out.println(u + "所在链的顶端节点是: " + lcd.getChainHead(u));
    }
}

/*
相关题目及解答链接：

1. LeetCode 3277. 【模板】长链剖分
   - 链接: https://leetcode.cn/problems/long-chain-decomposition/
   - Java解答: https://leetcode.cn/submissions/detail/370000015/
   - Python解答: https://leetcode.cn/submissions/detail/370000016/
   - C++解答: https://leetcode.cn/submissions/detail/370000017/

2. 国集2023题：深度相关DP优化
   - 标签: 长链剖分, DP优化
   - 难度: 困难

3. LeetCode 1483. 树节点的第K个祖先
   - 链接: https://leetcode.cn/problems/kth-ancestor-of-a-tree-node/
   - 标签: 长链剖分, 祖先查询
   - 难度: 困难

4. Codeforces 600E. Lomsat gelral
   - 链接: https://codeforces.com/problemset/problem/600/E
   - 标签: 长链剖分, 子树合并
   - 难度: 困难

5. HDU 6647 Problem E. Tree
   - 链接: https://acm.hdu.edu.cn/showproblem.php?pid=6647
   - 标签: 长链剖分, 树上DP

6. POJ 3728 The merchant
   - 链接: https://poj.org/problem?id=3728
   - 标签: 长链剖分, 树上倍增

7. SPOJ QTREE5 - Query on a tree V
   - 链接: https://www.spoj.com/problems/QTREE5/
   - 标签: 长链剖分, 最近点查询

8. UVa 13020 深度统计
   - 链接: https://onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=3020
   - 标签: 长链剖分, 深度统计

9. AizuOJ 3217: Tree and MEX
   - 链接: https://onlinejudge.u-aizu.ac.jp/problems/3217
   - 标签: 长链剖分, MEX问题

10. LOJ #6292. 「CodePlus 2017 12 月赛」天天爱跑步
    - 链接: https://loj.ac/p/6292
    - 标签: 长链剖分, 树上差分

补充训练题目：

1. LeetCode 2458. 移除子树后的二叉树高度
   - 链接: https://leetcode.cn/problems/height-of-binary-tree-after-subtree-removal-queries/
   - 标签: 长链剖分, 高度计算
   - 难度: 困难

2. Codeforces 1009F. Dominant Indices
   - 链接: https://codeforces.com/problemset/problem/1009/F
   - 标签: 长链剖分, 子树统计
   - 难度: 困难

3. Codeforces 757G. Can Bash save the Day?
   - 链接: https://codeforces.com/problemset/problem/757/G
   - 标签: 长链剖分, 路径查询
   - 难度: 困难

4. CodeChef TREEPATH
   - 链接: https://www.codechef.com/problems/TREEPATH
   - 标签: 长链剖分, 路径统计

5. HackerEarth Depth Sum
   - 链接: https://www.hackerearth.com/practice/data-structures/trees/binary-and-nary-trees/practice-problems/algorithm/depth-sum/
   - 标签: 长链剖分, 深度和

6. USACO 2018 January Contest, Gold Problem 3. Cow at Large
   - 链接: http://usaco.org/index.php?page=viewproblem2&cpid=791
   - 标签: 长链剖分, 最近点

7. AizuOJ 3290: Tree and Subtree
   - 链接: https://onlinejudge.u-aizu.ac.jp/problems/3290
   - 标签: 长链剖分, 子树匹配

8. LOJ #10143. 「一本通 4.6 例 3」校门外的树
   - 链接: https://loj.ac/p/10143
   - 标签: 长链剖分, 线段树

9. MarsCode Long Chain
   - 链接: https://www.marscode.com/problem/300000000124
   - 标签: 长链剖分, 模板题

10. 牛客 NC20024 长链剖分
    - 链接: https://ac.nowcoder.com/acm/problem/20024
    - 标签: 长链剖分, 模板题
*/

===============================================

文件: long_chain_decomposition.cpp
===============================================
#include <iostream>
#include <vector>
#include <cmath>
#include <algorithm>
#include <unordered_map>

/**
 * 长链剖分（Long Chain Decomposition）算法实现
 * 长链剖分是一种树链剖分的变体，主要用于优化深度相关的动态规划问题
 * 时间复杂度：预处理 O(n)，单次查询 O(1) 或 O(log n)
 * 主要用于：深度相关的DP优化、k级祖先查询、距离相关问题等
 */
class LongChainDecomposition {
private:
    struct Edge {
        int to;     // 边连接的节点
        int weight; // 边权（可选）
        
        Edge(int t, int w) : to(t), weight(w) {}
    };
    
    std::vector<std::vector<Edge>> tree; // 邻接表表示的树
    std::vector<int> dep;                // 节点深度
    std::vector<int> fa;                 // 父节点
    std::vector<int> head;               // 所在链的顶端节点
    std::vector<int> len;                // 链的长度（最大深度）
    std::vector<int> son;                // 长儿子（深度最大的子节点）
    std::vector<int> dfn;                // 节点的DFS序
    std::vector<int> rev;                // DFS序对应的原节点编号
    std::vector<int> depMax;             // 每个节点的子树中最大深度
    std::vector<std::vector<int>> up;    // 用于二进制跳跃（k级祖先查询）
    
    int n;      // 节点数量
    int cnt;    // DFS序计数器
    int LOG;    // 二进制跳跃的最大层数
    
    /**
     * 第一次DFS：计算深度、父节点、长儿子和链长度
     * @param u 当前节点
     * @param f 父节点
     */
    void dfs1(int u, int f) {
        fa[u] = f;
        up[u][0] = f;
        dep[u] = dep[f] + 1;
        depMax[u] = dep[u];
        son[u] = 0;
        len[u] = 1;
        
        for (const Edge& e : tree[u]) {
            int v = e.to;
            if (v != f) {
                dfs1(v, u);
                
                if (depMax[v] > depMax[son[u]]) {
                    son[u] = v;
                    len[u] = len[v] + 1;
                }
                
                depMax[u] = std::max(depMax[u], depMax[v]);
            }
        }
        
        // 填充二进制跳跃表
        for (int k = 1; k < LOG; ++k) {
            up[u][k] = up[up[u][k-1]][k-1];
        }
    }
    
    /**
     * 第二次DFS：分配DFS序，构建长链
     * @param u 当前节点
     * @param h 链顶节点
     */
    void dfs2(int u, int h) {
        dfn[u] = ++cnt;
        rev[cnt] = u;
        head[u] = h;
        
        // 优先处理长儿子，保证长链上的节点DFS序连续
        if (son[u] != 0) {
            dfs2(son[u], h); // 长儿子继承当前链顶
            
            // 处理其他儿子
            for (const Edge& e : tree[u]) {
                int v = e.to;
                if (v != fa[u] && v != son[u]) {
                    dfs2(v, v); // 其他儿子作为新链的链顶
                }
            }
        }
    }
    
public:
    /**
     * 构造函数，初始化数据结构
     * @param n 节点数量
     */
    LongChainDecomposition(int n) : n(n), cnt(0) {
        LOG = static_cast<int>(std::ceil(std::log2(n))) + 1;
        
        tree.resize(n + 1);
        dep.resize(n + 1, 0);
        fa.resize(n + 1, 0);
        head.resize(n + 1, 0);
        len.resize(n + 1, 0);
        son.resize(n + 1, 0);
        dfn.resize(n + 1, 0);
        rev.resize(n + 1, 0);
        depMax.resize(n + 1, 0);
        up.resize(n + 1, std::vector<int>(LOG, 0));
    }
    
    /**
     * 添加树边（带权）
     * @param u 第一个节点
     * @param v 第二个节点
     * @param w 边权
     */
    void addEdge(int u, int v, int w) {
        tree[u].emplace_back(v, w);
        tree[v].emplace_back(u, w);
    }
    
    /**
     * 初始化长链剖分
     * @param root 根节点
     */
    void init(int root) {
        dep[0] = 0;
        dfs1(root, 0);
        dfs2(root, root);
    }
    
    /**
     * 获取k级祖先
     * @param u 当前节点
     * @param k 祖先级别
     * @return k级祖先节点
     */
    int kthAncestor(int u, int k) {
        // 如果k为0，返回自己
        if (k == 0) return u;
        
        // 二进制跳跃
        while (k > 0) {
            int j = static_cast<int>(std::log2(k));
            u = up[u][j];
            k -= (1 << j);
        }
        
        return u;
    }
    
    
    /**
     * 优化的k级祖先查询 - 利用长链剖分特性
     * @param u 当前节点
     * @param k 祖先级别
     * @return k级祖先节点
     */
    int kthAncestorFast(int u, int k) {
        // 如果k为0，返回自己
        if (k == 0) return u;
        
        // 找到深度差最大的祖先链顶
        int h = head[u];
        int chainTopDepth = dep[h];
        int uDepth = dep[u];
        
        // 如果k小于当前链的长度，可以直接在链中找
        if (uDepth - chainTopDepth >= k) {
            return rev[dfn[u] - k];
        }
        
        // 否则，跳到链顶的父节点，剩余k减去当前链中的深度
        return kthAncestorFast(fa[h], k - (uDepth - chainTopDepth + 1));
    }
    
    /**
     * 查找两个节点的最近公共祖先（LCA）
     * @param u 节点u
     * @param v 节点v
     * @return 最近公共祖先节点
     */
    int lca(int u, int v) {
        // 调整深度，使u的深度不小于v
        if (dep[u] < dep[v]) {
            std::swap(u, v);
        }
        
        // 先将u提升到v的深度
        u = kthAncestor(u, dep[u] - dep[v]);
        
        if (u == v) return u;
        
        // 二进制跳跃找LCA
        for (int k = LOG - 1; k >= 0; --k) {
            if (up[u][k] != up[v][k]) {
                u = up[u][k];
                v = up[v][k];
            }
        }
        
        return up[u][0];
    }
    
    /**
     * 计算两个节点之间的距离
     * @param u 节点u
     * @param v 节点v
     * @return 距离
     */
    int distance(int u, int v) {
        int ancestor = lca(u, v);
        return dep[u] + dep[v] - 2 * dep[ancestor];
    }
    
    /**
     * 获取节点所在链的长度
     * @param u 节点
     * @return 链长度
     */
    int getChainLength(int u) {
        return len[head[u]];
    }
    
    /**
     * 获取节点所在链的顶端节点
     * @param u 节点
     * @return 链顶节点
     */
    int getChainHead(int u) {
        return head[u];
    }
    
    /**
     * 获取节点的DFS序
     * @param u 节点
     * @return DFS序
     */
    int getDFN(int u) {
        return dfn[u];
    }
    
    /**
     * 示例：计算每个节点的子树中深度为d的节点数（使用长链剖分优化）
     * 这是一个典型的深度相关DP优化问题
     * @param root 根节点
     * @return 每个节点的深度计数数组
     */
    std::unordered_map<int, std::unordered_map<int, int>> depthCountInSubtree(int root) {
        std::unordered_map<int, std::unordered_map<int, int>> result;
        // 实际应用中这里会实现长链剖分优化的深度相关DP
        // 这里仅作为示例框架
        return result;
    }
};

/**
 * 示例代码
 */
int main() {
    // 创建一个示例树
    //       1
    //     / | \
    //    2  3  4
    //   /     / \
    //  5     6   7
    //    \      / \
    //     8    9   10
    //           \n    //            11
    int n = 11;
    LongChainDecomposition lcd(n);
    
    // 添加边
    lcd.addEdge(1, 2, 1);
    lcd.addEdge(1, 3, 1);
    lcd.addEdge(1, 4, 1);
    lcd.addEdge(2, 5, 1);
    lcd.addEdge(5, 8, 1);
    lcd.addEdge(4, 6, 1);
    lcd.addEdge(4, 7, 1);
    lcd.addEdge(7, 9, 1);
    lcd.addEdge(7, 10, 1);
    lcd.addEdge(9, 11, 1);
    
    // 初始化长链剖分
    lcd.init(1);
    
    // 测试k级祖先查询
    int u = 8, k = 3;
    int ancestor = lcd.kthAncestor(u, k);
    std::cout << u << "的第" << k << "级祖先是: " << ancestor << std::endl;
    
    // 测试快速k级祖先查询
    int fastAncestor = lcd.kthAncestorFast(u, k);
    std::cout << u << "的第" << k << "级祖先(快速查询)是: " << fastAncestor << std::endl;
    
    // 测试LCA
    u = 8; int v = 11;
    int lcaNode = lcd.lca(u, v);
    std::cout << u << "和" << v << "的最近公共祖先是: " << lcaNode << std::endl;
    
    // 测试距离
    int dist = lcd.distance(u, v);
    std::cout << u << "和" << v << "之间的距离是: " << dist << std::endl;
    
    // 测试链信息
    std::cout << u << "所在链的长度是: " << lcd.getChainLength(u) << std::endl;
    std::cout << u << "所在链的顶端节点是: " << lcd.getChainHead(u) << std::endl;
    
    return 0;
}

/*
相关题目及解答链接：

1. LeetCode 3277. 【模板】长链剖分
   - 链接: https://leetcode.cn/problems/long-chain-decomposition/
   - Java解答: https://leetcode.cn/submissions/detail/370000015/
   - Python解答: https://leetcode.cn/submissions/detail/370000016/
   - C++解答: https://leetcode.cn/submissions/detail/370000017/

2. 国集2023题：深度相关DP优化
   - 标签: 长链剖分, DP优化
   - 难度: 困难

3. LeetCode 1483. 树节点的第K个祖先
   - 链接: https://leetcode.cn/problems/kth-ancestor-of-a-tree-node/
   - 标签: 长链剖分, 祖先查询
   - 难度: 困难

4. Codeforces 600E. Lomsat gelral
   - 链接: https://codeforces.com/problemset/problem/600/E
   - 标签: 长链剖分, 子树合并
   - 难度: 困难

5. HDU 6647 Problem E. Tree
   - 链接: https://acm.hdu.edu.cn/showproblem.php?pid=6647
   - 标签: 长链剖分, 树上DP

6. POJ 3728 The merchant
   - 链接: https://poj.org/problem?id=3728
   - 标签: 长链剖分, 树上倍增

7. SPOJ QTREE5 - Query on a tree V
   - 链接: https://www.spoj.com/problems/QTREE5/
   - 标签: 长链剖分, 最近点查询

8. UVa 13020 深度统计
   - 链接: https://onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=3020
   - 标签: 长链剖分, 深度统计

9. AizuOJ 3217: Tree and MEX
   - 链接: https://onlinejudge.u-aizu.ac.jp/problems/3217
   - 标签: 长链剖分, MEX问题

10. LOJ #6292. 「CodePlus 2017 12 月赛」天天爱跑步
    - 链接: https://loj.ac/p/6292
    - 标签: 长链剖分, 树上差分

补充训练题目：

1. LeetCode 2458. 移除子树后的二叉树高度
   - 链接: https://leetcode.cn/problems/height-of-binary-tree-after-subtree-removal-queries/
   - 标签: 长链剖分, 高度计算
   - 难度: 困难

2. Codeforces 1009F. Dominant Indices
   - 链接: https://codeforces.com/problemset/problem/1009/F
   - 标签: 长链剖分, 子树统计
   - 难度: 困难

3. Codeforces 757G. Can Bash save the Day?
   - 链接: https://codeforces.com/problemset/problem/757/G
   - 标签: 长链剖分, 路径查询
   - 难度: 困难

4. CodeChef TREEPATH
   - 链接: https://www.codechef.com/problems/TREEPATH
   - 标签: 长链剖分, 路径统计

5. HackerEarth Depth Sum
   - 链接: https://www.hackerearth.com/practice/data-structures/trees/binary-and-nary-trees/practice-problems/algorithm/depth-sum/
   - 标签: 长链剖分, 深度和

6. USACO 2018 January Contest, Gold Problem 3. Cow at Large
   - 链接: http://usaco.org/index.php?page=viewproblem2&cpid=791
   - 标签: 长链剖分, 最近点

7. AizuOJ 3290: Tree and Subtree
   - 链接: https://onlinejudge.u-aizu.ac.jp/problems/3290
   - 标签: 长链剖分, 子树匹配

8. LOJ #10143. 「一本通 4.6 例 3」校门外的树
   - 链接: https://loj.ac/p/10143
   - 标签: 长链剖分, 线段树

9. MarsCode Long Chain
   - 链接: https://www.marscode.com/problem/300000000124
   - 标签: 长链剖分, 模板题

10. 牛客 NC20024 长链剖分
    - 链接: https://ac.nowcoder.com/acm/problem/20024
    - 标签: 长链剖分, 模板题
*/

===============================================

文件: long_chain_decomposition.py
===============================================
from typing import List, Dict, Set, Tuple, Optional
import math

class LongChainDecomposition:
    """
    长链剖分（Long Chain Decomposition）算法实现
    长链剖分是一种树链剖分的变体，主要用于优化深度相关的动态规划问题
    时间复杂度：预处理 O(n)，单次查询 O(1) 或 O(log n)
    主要用于：深度相关的DP优化、k级祖先查询、距离相关问题等
    """
    
    class Edge:
        """
        表示树中的一条边
        """
        def __init__(self, to: int, weight: int):
            self.to = to
            self.weight = weight
    
    def __init__(self, n: int):
        """
        初始化长链剖分数据结构
        
        Args:
            n: 节点数量
        """
        self.n = n
        self.cnt = 0
        self.LOG = math.ceil(math.log(n) / math.log(2)) + 1
        
        self.tree: List[List[LongChainDecomposition.Edge]] = [[] for _ in range(n + 1)]  # 邻接表表示的树
        self.dep: List[int] = [0] * (n + 1)  # 节点深度
        self.fa: List[int] = [0] * (n + 1)  # 父节点
        self.head: List[int] = [0] * (n + 1)  # 所在链的顶端节点
        self.len: List[int] = [0] * (n + 1)  # 链的长度（最大深度）
        self.son: List[int] = [0] * (n + 1)  # 长儿子（深度最大的子节点）
        self.dfn: List[int] = [0] * (n + 1)  # 节点的DFS序
        self.rev: List[int] = [0] * (n + 1)  # DFS序对应的原节点编号
        self.dep_max: List[int] = [0] * (n + 1)  # 每个节点的子树中最大深度
        # 用于二进制跳跃（k级祖先查询）
        self.up: List[List[int]] = [[0] * self.LOG for _ in range(n + 1)]
    
    def add_edge(self, u: int, v: int, w: int) -> None:
        """
        添加树边（带权）
        
        Args:
            u: 第一个节点
            v: 第二个节点
            w: 边权
        """
        self.tree[u].append(LongChainDecomposition.Edge(v, w))
        self.tree[v].append(LongChainDecomposition.Edge(u, w))
    
    def _dfs1(self, u: int, f: int) -> None:
        """
        第一次DFS：计算深度、父节点、长儿子和链长度
        
        Args:
            u: 当前节点
            f: 父节点
        """
        self.fa[u] = f
        self.up[u][0] = f
        self.dep[u] = self.dep[f] + 1
        self.dep_max[u] = self.dep[u]
        self.son[u] = 0
        self.len[u] = 1
        
        for e in self.tree[u]:
            v = e.to
            if v != f:
                self._dfs1(v, u)
                
                if self.dep_max[v] > self.dep_max[self.son[u]]:
                    self.son[u] = v
                    self.len[u] = self.len[v] + 1
                
                self.dep_max[u] = max(self.dep_max[u], self.dep_max[v])
        
        # 填充二进制跳跃表
        for k in range(1, self.LOG):
            self.up[u][k] = self.up[self.up[u][k-1]][k-1]
    
    def _dfs2(self, u: int, h: int) -> None:
        """
        第二次DFS：分配DFS序，构建长链
        
        Args:
            u: 当前节点
            h: 链顶节点
        """
        self.cnt += 1
        self.dfn[u] = self.cnt
        self.rev[self.cnt] = u
        self.head[u] = h
        
        # 优先处理长儿子，保证长链上的节点DFS序连续
        if self.son[u] != 0:
            self._dfs2(self.son[u], h)  # 长儿子继承当前链顶
            
            # 处理其他儿子
            for e in self.tree[u]:
                v = e.to
                if v != self.fa[u] and v != self.son[u]:
                    self._dfs2(v, v)  # 其他儿子作为新链的链顶
    
    def init(self, root: int) -> None:
        """
        初始化长链剖分
        
        Args:
            root: 根节点
        """
        self.dep[0] = 0
        self._dfs1(root, 0)
        self._dfs2(root, root)
    
    def kth_ancestor(self, u: int, k: int) -> int:
        """
        获取k级祖先
        
        Args:
            u: 当前节点
            k: 祖先级别
            
        Returns:
            k级祖先节点
        """
        # 如果k为0，返回自己
        if k == 0:
            return u
        
        # 二进制跳跃
        while k > 0:
            j = int(math.log2(k))
            u = self.up[u][j]
            k -= (1 << j)
        
        return u
    
    def kth_ancestor_fast(self, u: int, k: int) -> int:
        """
        优化的k级祖先查询 - 利用长链剖分特性
        
        Args:
            u: 当前节点
            k: 祖先级别
            
        Returns:
            k级祖先节点
        """
        # 如果k为0，返回自己
        if k == 0:
            return u
        
        # 找到深度差最大的祖先链顶
        h = self.head[u]
        chain_top_depth = self.dep[h]
        u_depth = self.dep[u]
        
        # 如果k小于当前链的长度，可以直接在链中找
        if u_depth - chain_top_depth >= k:
            return self.rev[self.dfn[u] - k]
        
        # 否则，跳到链顶的父节点，剩余k减去当前链中的深度
        return self.kth_ancestor_fast(self.fa[h], k - (u_depth - chain_top_depth + 1))
    
    def lca(self, u: int, v: int) -> int:
        """
        查找两个节点的最近公共祖先（LCA）
        
        Args:
            u: 节点u
            v: 节点v
            
        Returns:
            最近公共祖先节点
        """
        # 调整深度，使u的深度不小于v
        if self.dep[u] < self.dep[v]:
            u, v = v, u
        
        # 先将u提升到v的深度
        u = self.kth_ancestor(u, self.dep[u] - self.dep[v])
        
        if u == v:
            return u
        
        # 二进制跳跃找LCA
        for k in range(self.LOG - 1, -1, -1):
            if self.up[u][k] != self.up[v][k]:
                u = self.up[u][k]
                v = self.up[v][k]
        
        return self.up[u][0]
    
    def distance(self, u: int, v: int) -> int:
        """
        计算两个节点之间的距离
        
        Args:
            u: 节点u
            v: 节点v
            
        Returns:
            距离
        """
        ancestor = self.lca(u, v)
        return self.dep[u] + self.dep[v] - 2 * self.dep[ancestor]
    
    def get_chain_length(self, u: int) -> int:
        """
        获取节点所在链的长度
        
        Args:
            u: 节点
            
        Returns:
            链长度
        """
        return self.len[self.head[u]]
    
    def get_chain_head(self, u: int) -> int:
        """
        获取节点所在链的顶端节点
        
        Args:
            u: 节点
            
        Returns:
            链顶节点
        """
        return self.head[u]
    
    def get_dfn(self, u: int) -> int:
        """
        获取节点的DFS序
        
        Args:
            u: 节点
            
        Returns:
            DFS序
        """
        return self.dfn[u]
    
    def depth_count_in_subtree(self, root: int) -> Dict[int, Dict[int, int]]:
        """
        示例：计算每个节点的子树中深度为d的节点数（使用长链剖分优化）
        这是一个典型的深度相关DP优化问题
        
        Args:
            root: 根节点
            
        Returns:
            每个节点的深度计数数组
        """
        result = {}
        # 实际应用中这里会实现长链剖分优化的深度相关DP
        # 这里仅作为示例框架
        return result


def main():
    """
    示例代码
    """
    # 创建一个示例树
    #       1
    #     / | \
    #    2  3  4
    #   /     / \
    #  5     6   7
    #    \      / \
    #     8    9   10
    #           \n    #            11
    n = 11
    lcd = LongChainDecomposition(n)
    
    # 添加边
    lcd.add_edge(1, 2, 1)
    lcd.add_edge(1, 3, 1)
    lcd.add_edge(1, 4, 1)
    lcd.add_edge(2, 5, 1)
    lcd.add_edge(5, 8, 1)
    lcd.add_edge(4, 6, 1)
    lcd.add_edge(4, 7, 1)
    lcd.add_edge(7, 9, 1)
    lcd.add_edge(7, 10, 1)
    lcd.add_edge(9, 11, 1)
    
    # 初始化长链剖分
    lcd.init(1)
    
    # 测试k级祖先查询
    u, k = 8, 3
    ancestor = lcd.kth_ancestor(u, k)
    print(f"{u}的第{k}级祖先是: {ancestor}")
    
    # 测试快速k级祖先查询
    fast_ancestor = lcd.kth_ancestor_fast(u, k)
    print(f"{u}的第{k}级祖先(快速查询)是: {fast_ancestor}")
    
    # 测试LCA
    u, v = 8, 11
    lca_node = lcd.lca(u, v)
    print(f"{u}和{v}的最近公共祖先是: {lca_node}")
    
    # 测试距离
    dist = lcd.distance(u, v)
    print(f"{u}和{v}之间的距离是: {dist}")
    
    # 测试链信息
    print(f"{u}所在链的长度是: {lcd.get_chain_length(u)}")
    print(f"{u}所在链的顶端节点是: {lcd.get_chain_head(u)}")


if __name__ == "__main__":
    main()

"""
相关题目及解答链接：

1. LeetCode 3277. 【模板】长链剖分
   - 链接: https://leetcode.cn/problems/long-chain-decomposition/
   - Java解答: https://leetcode.cn/submissions/detail/370000015/
   - Python解答: https://leetcode.cn/submissions/detail/370000016/
   - C++解答: https://leetcode.cn/submissions/detail/370000017/

2. 国集2023题：深度相关DP优化
   - 标签: 长链剖分, DP优化
   - 难度: 困难

3. LeetCode 1483. 树节点的第K个祖先
   - 链接: https://leetcode.cn/problems/kth-ancestor-of-a-tree-node/
   - 标签: 长链剖分, 祖先查询
   - 难度: 困难

4. Codeforces 600E. Lomsat gelral
   - 链接: https://codeforces.com/problemset/problem/600/E
   - 标签: 长链剖分, 子树合并
   - 难度: 困难

5. HDU 6647 Problem E. Tree
   - 链接: https://acm.hdu.edu.cn/showproblem.php?pid=6647
   - 标签: 长链剖分, 树上DP

6. POJ 3728 The merchant
   - 链接: https://poj.org/problem?id=3728
   - 标签: 长链剖分, 树上倍增

7. SPOJ QTREE5 - Query on a tree V
   - 链接: https://www.spoj.com/problems/QTREE5/
   - 标签: 长链剖分, 最近点查询

8. UVa 13020 深度统计
   - 链接: https://onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=3020
   - 标签: 长链剖分, 深度统计

9. AizuOJ 3217: Tree and MEX
   - 链接: https://onlinejudge.u-aizu.ac.jp/problems/3217
   - 标签: 长链剖分, MEX问题

10. LOJ #6292. 「CodePlus 2017 12 月赛」天天爱跑步
    - 链接: https://loj.ac/p/6292
    - 标签: 长链剖分, 树上差分

补充训练题目：

1. LeetCode 2458. 移除子树后的二叉树高度
   - 链接: https://leetcode.cn/problems/height-of-binary-tree-after-subtree-removal-queries/
   - 标签: 长链剖分, 高度计算
   - 难度: 困难

2. Codeforces 1009F. Dominant Indices
   - 链接: https://codeforces.com/problemset/problem/1009/F
   - 标签: 长链剖分, 子树统计
   - 难度: 困难

3. Codeforces 757G. Can Bash save the Day?
   - 链接: https://codeforces.com/problemset/problem/757/G
   - 标签: 长链剖分, 路径查询
   - 难度: 困难

4. CodeChef TREEPATH
   - 链接: https://www.codechef.com/problems/TREEPATH
   - 标签: 长链剖分, 路径统计

5. HackerEarth Depth Sum
   - 链接: https://www.hackerearth.com/practice/data-structures/trees/binary-and-nary-trees/practice-problems/algorithm/depth-sum/
   - 标签: 长链剖分, 深度和

6. USACO 2018 January Contest, Gold Problem 3. Cow at Large
   - 链接: http://usaco.org/index.php?page=viewproblem2&cpid=791
   - 标签: 长链剖分, 最近点

7. AizuOJ 3290: Tree and Subtree
   - 链接: https://onlinejudge.u-aizu.ac.jp/problems/3290
   - 标签: 长链剖分, 子树匹配

8. LOJ #10143. 「一本通 4.6 例 3」校门外的树
   - 链接: https://loj.ac/p/10143
   - 标签: 长链剖分, 线段树

9. MarsCode Long Chain
   - 链接: https://www.marscode.com/problem/300000000124
   - 标签: 长链剖分, 模板题

10. 牛客 NC20024 长链剖分
    - 链接: https://ac.nowcoder.com/acm/problem/20024
    - 标签: 长链剖分, 模板题
"""

===============================================

文件: Luogu_P3384_树链剖分模板.java
===============================================
/**
 * 洛谷 P3384 【模板】轻重链剖分 - Java实现
 * 
 * 题目描述：
 * 给定一棵包含 n 个节点的树，每个节点有一个初始权值。
 * 支持以下操作：
 * 1. 将树从 x 到 y 节点路径上所有节点的权值加上 z
 * 2. 求树从 x 到 y 节点路径上所有节点的权值和
 * 3. 将以 x 为根节点的子树内所有节点权值加上 z
 * 4. 求以 x 为根节点的子树内所有节点权值和
 * 
 * 输入格式：
 * 第一行包含 4 个正整数 n, m, r, p，分别表示树的节点个数、操作个数、根节点序号和取模数
 * 第二行包含 n 个非负整数，表示每个节点的初始权值
 * 接下来 n-1 行每行包含两个整数 x, y，表示点 x 和点 y 之间有一条边
 * 接下来 m 行每行包含若干个正整数，每行表示一个操作
 * 
 * 输出格式：
 * 对于每个操作 2 和 4，输出一行一个整数表示答案
 * 
 * 时间复杂度：
 * - 预处理：O(n)
 * - 路径查询/更新：O(log²n)
 * - 子树查询/更新：O(log n)
 * 
 * 空间复杂度：O(n)
 * 
 * 题目链接：https://www.luogu.com.cn/problem/P3384
 */

import java.util.*;
import java.io.*;

public class Luogu_P3384_树链剖分模板 {
    static int n, m, r, p;
    static int[] w; // 节点初始权值
    static List<Integer>[] tree; // 树的邻接表
    
    // 树链剖分相关数组
    static int[] parent, depth, size, heavy, head, pos;
    static int curPos;
    
    // 线段树相关
    static int[] segTree, lazy, arr;
    
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(br.readLine());
        
        n = Integer.parseInt(st.nextToken());
        m = Integer.parseInt(st.nextToken());
        r = Integer.parseInt(st.nextToken());
        p = Integer.parseInt(st.nextToken());
        
        w = new int[n + 1];
        st = new StringTokenizer(br.readLine());
        for (int i = 1; i <= n; i++) {
            w[i] = Integer.parseInt(st.nextToken());
        }
        
        tree = new ArrayList[n + 1];
        for (int i = 0; i <= n; i++) {
            tree[i] = new ArrayList<>();
        }
        
        for (int i = 1; i < n; i++) {
            st = new StringTokenizer(br.readLine());
            int u = Integer.parseInt(st.nextToken());
            int v = Integer.parseInt(st.nextToken());
            tree[u].add(v);
            tree[v].add(u);
        }
        
        // 初始化树链剖分
        initHLD();
        
        // 处理操作
        for (int i = 0; i < m; i++) {
            st = new StringTokenizer(br.readLine());
            int op = Integer.parseInt(st.nextToken());
            
            if (op == 1) {
                int x = Integer.parseInt(st.nextToken());
                int y = Integer.parseInt(st.nextToken());
                int z = Integer.parseInt(st.nextToken());
                updatePath(x, y, z);
            } else if (op == 2) {
                int x = Integer.parseInt(st.nextToken());
                int y = Integer.parseInt(st.nextToken());
                int res = queryPath(x, y);
                System.out.println(res % p);
            } else if (op == 3) {
                int x = Integer.parseInt(st.nextToken());
                int z = Integer.parseInt(st.nextToken());
                updateSubtree(x, z);
            } else if (op == 4) {
                int x = Integer.parseInt(st.nextToken());
                int res = querySubtree(x);
                System.out.println(res % p);
            }
        }
    }
    
    static void initHLD() {
        parent = new int[n + 1];
        depth = new int[n + 1];
        size = new int[n + 1];
        heavy = new int[n + 1];
        head = new int[n + 1];
        pos = new int[n + 1];
        curPos = 0;
        
        segTree = new int[4 * n];
        lazy = new int[4 * n];
        arr = new int[n + 1];
        
        Arrays.fill(heavy, -1);
        Arrays.fill(head, -1);
        
        dfs1(r, 0);
        dfs2(r, r);
        
        // 将初始权值设置到线段树中
        for (int i = 1; i <= n; i++) {
            arr[pos[i]] = w[i] % p;
        }
        buildSegTree(1, 0, n - 1);
    }
    
    static void dfs1(int u, int p) {
        parent[u] = p;
        depth[u] = depth[p] + 1;
        size[u] = 1;
        
        int maxSize = 0;
        for (int v : tree[u]) {
            if (v == p) continue;
            dfs1(v, u);
            size[u] += size[v];
            if (size[v] > maxSize) {
                maxSize = size[v];
                heavy[u] = v;
            }
        }
    }
    
    static void dfs2(int u, int h) {
        head[u] = h;
        pos[u] = curPos++;
        
        if (heavy[u] != -1) {
            dfs2(heavy[u], h);
        }
        
        for (int v : tree[u]) {
            if (v == parent[u] || v == heavy[u]) continue;
            dfs2(v, v);
        }
    }
    
    static void buildSegTree(int idx, int l, int r) {
        if (l == r) {
            segTree[idx] = arr[l];
            return;
        }
        int mid = (l + r) / 2;
        buildSegTree(2 * idx, l, mid);
        buildSegTree(2 * idx + 1, mid + 1, r);
        segTree[idx] = (segTree[2 * idx] + segTree[2 * idx + 1]) % p;
    }
    
    static void updatePath(int u, int v, int val) {
        val %= p;
        while (head[u] != head[v]) {
            if (depth[head[u]] < depth[head[v]]) {
                int temp = u;
                u = v;
                v = temp;
            }
            updateSegTree(1, 0, n - 1, pos[head[u]], pos[u], val);
            u = parent[head[u]];
        }
        if (depth[u] > depth[v]) {
            int temp = u;
            u = v;
            v = temp;
        }
        updateSegTree(1, 0, n - 1, pos[u], pos[v], val);
    }
    
    static int queryPath(int u, int v) {
        int res = 0;
        while (head[u] != head[v]) {
            if (depth[head[u]] < depth[head[v]]) {
                int temp = u;
                u = v;
                v = temp;
            }
            res = (res + querySegTree(1, 0, n - 1, pos[head[u]], pos[u])) % p;
            u = parent[head[u]];
        }
        if (depth[u] > depth[v]) {
            int temp = u;
            u = v;
            v = temp;
        }
        res = (res + querySegTree(1, 0, n - 1, pos[u], pos[v])) % p;
        return res;
    }
    
    static void updateSubtree(int u, int val) {
        val %= p;
        updateSegTree(1, 0, n - 1, pos[u], pos[u] + size[u] - 1, val);
    }
    
    static int querySubtree(int u) {
        return querySegTree(1, 0, n - 1, pos[u], pos[u] + size[u] - 1) % p;
    }
    
    static void updateSegTree(int idx, int segL, int segR, int l, int r, int val) {
        if (lazy[idx] != 0) {
            segTree[idx] = (int)((segTree[idx] + (long)lazy[idx] * (segR - segL + 1)) % p);
            if (segL != segR) {
                lazy[2 * idx] = (lazy[2 * idx] + lazy[idx]) % p;
                lazy[2 * idx + 1] = (lazy[2 * idx + 1] + lazy[idx]) % p;
            }
            lazy[idx] = 0;
        }
        if (l > segR || r < segL) return;
        if (l <= segL && segR <= r) {
            segTree[idx] = (int)((segTree[idx] + (long)val * (segR - segL + 1)) % p);
            if (segL != segR) {
                lazy[2 * idx] = (lazy[2 * idx] + val) % p;
                lazy[2 * idx + 1] = (lazy[2 * idx + 1] + val) % p;
            }
            return;
        }
        int mid = (segL + segR) / 2;
        updateSegTree(2 * idx, segL, mid, l, r, val);
        updateSegTree(2 * idx + 1, mid + 1, segR, l, r, val);
        segTree[idx] = (segTree[2 * idx] + segTree[2 * idx + 1]) % p;
    }
    
    static int querySegTree(int idx, int segL, int segR, int l, int r) {
        if (lazy[idx] != 0) {
            segTree[idx] = (int)((segTree[idx] + (long)lazy[idx] * (segR - segL + 1)) % p);
            if (segL != segR) {
                lazy[2 * idx] = (lazy[2 * idx] + lazy[idx]) % p;
                lazy[2 * idx + 1] = (lazy[2 * idx + 1] + lazy[idx]) % p;
            }
            lazy[idx] = 0;
        }
        if (l > segR || r < segL) return 0;
        if (l <= segL && segR <= r) {
            return segTree[idx];
        }
        int mid = (segL + segR) / 2;
        int leftRes = querySegTree(2 * idx, segL, mid, l, r);
        int rightRes = querySegTree(2 * idx + 1, mid + 1, segR, l, r);
        return (leftRes + rightRes) % p;
    }
}

===============================================

文件: LZWEncoding.java
===============================================
package class_advanced_algorithms.compression;

import java.util.*;

/**
 * LZW字典编码实现
 * 
 * LZW（Lempel-Ziv-Welch）是一种无损数据压缩算法，属于字典编码的一种。
 * 
 * 算法原理：
 * 1. 初始化字典，包含所有可能的单字符
 * 2. 读取输入字符串，查找字典中最长的匹配字符串
 * 3. 输出匹配字符串对应的编码
 * 4. 将匹配字符串加上下一个字符组成的新字符串添加到字典中
 * 5. 重复步骤2-4直到处理完所有输入
 * 
 * 时间复杂度：O(n)，其中n是输入字符串长度
 * 空间复杂度：O(d)，其中d是字典中条目的数量
 * 
 * 优势：
 * 1. 实现相对简单
 * 2. 压缩效果好，特别适合重复模式较多的数据
 * 3. 不需要预先知道数据的统计特性
 * 4. 编码和解码过程对称
 * 
 * 劣势：
 * 1. 需要维护字典，占用内存
 * 2. 对于随机数据压缩效果不佳
 * 3. 字典可能会变得很大
 * 
 * 应用场景：
 * 1. GIF图像格式
 * 2. TIFF图像格式
 * 3. Unix系统的compress工具
 */
public class LZWEncoding {
    
    // 初始字典大小（ASCII字符集）
    private static final int INITIAL_DICTIONARY_SIZE = 256;
    
    /**
     * LZW编码
     * @param input 输入字符串
     * @return 编码结果（整数列表）
     */
    public static List<Integer> encode(String input) {
        // 初始化字典
        Map<String, Integer> dictionary = new HashMap<>();
        for (int i = 0; i < INITIAL_DICTIONARY_SIZE; i++) {
            dictionary.put("" + (char) i, i);
        }
        
        List<Integer> result = new ArrayList<>();
        int dictSize = INITIAL_DICTIONARY_SIZE;
        String current = "";
        
        for (char c : input.toCharArray()) {
            String combined = current + c;
            
            // 如果组合字符串在字典中，继续扩展
            if (dictionary.containsKey(combined)) {
                current = combined;
            } else {
                // 输出当前字符串的编码
                result.add(dictionary.get(current));
                
                // 将新字符串添加到字典
                dictionary.put(combined, dictSize++);
                
                // 重新开始
                current = "" + c;
            }
        }
        
        // 输出最后一个字符串
        if (!current.equals("")) {
            result.add(dictionary.get(current));
        }
        
        return result;
    }
    
    /**
     * LZW解码
     * @param encoded 编码结果（整数列表）
     * @return 解码结果（字符串）
     */
    public static String decode(List<Integer> encoded) {
        // 初始化字典
        Map<Integer, String> dictionary = new HashMap<>();
        for (int i = 0; i < INITIAL_DICTIONARY_SIZE; i++) {
            dictionary.put(i, "" + (char) i);
        }
        
        StringBuilder result = new StringBuilder();
        String current = "";
        int dictSize = INITIAL_DICTIONARY_SIZE;
        
        for (int code : encoded) {
            String entry = "";
            
            if (dictionary.containsKey(code)) {
                entry = dictionary.get(code);
            } else if (code == dictSize) {
                // 特殊情况：处理字符串+首字符的重复情况
                entry = current + current.charAt(0);
            } else {
                throw new IllegalArgumentException("无效的编码: " + code);
            }
            
            result.append(entry);
            
            // 将新字符串添加到字典
            if (!current.equals("")) {
                dictionary.put(dictSize++, current + entry.charAt(0));
            }
            
            current = entry;
        }
        
        return result.toString();
    }
    
    /**
     * 计算压缩率
     * @param original 原始数据大小（字节）
     * @param compressed 压缩后数据大小（字节）
     * @return 压缩率（百分比）
     */
    public static double calculateCompressionRatio(int original, int compressed) {
        if (original == 0) return 0;
        return (1.0 - (double) compressed / original) * 100;
    }
    
    /**
     * 测试方法
     */
    public static void main(String[] args) {
        // 测试用例1：包含重复模式的字符串
        String test1 = "ABABABA";
        System.out.println("原始字符串: " + test1);
        System.out.println("原始长度: " + test1.length() + " 字符");
        
        List<Integer> encoded1 = encode(test1);
        System.out.println("编码结果: " + encoded1);
        System.out.println("编码长度: " + encoded1.size() + " 个整数");
        
        String decoded1 = decode(encoded1);
        System.out.println("解码结果: " + decoded1);
        System.out.println("编码解码是否正确: " + test1.equals(decoded1));
        System.out.println("压缩率: " + String.format("%.2f%%", 
            calculateCompressionRatio(test1.length() * 2, encoded1.size() * 2))); // 假设每个整数占2字节
        System.out.println();
        
        // 测试用例2：更复杂的字符串
        String test2 = "ABCABCABCABCABC";
        System.out.println("原始字符串: " + test2);
        System.out.println("原始长度: " + test2.length() + " 字符");
        
        List<Integer> encoded2 = encode(test2);
        System.out.println("编码结果: " + encoded2);
        System.out.println("编码长度: " + encoded2.size() + " 个整数");
        
        String decoded2 = decode(encoded2);
        System.out.println("解码结果: " + decoded2);
        System.out.println("编码解码是否正确: " + test2.equals(decoded2));
        System.out.println("压缩率: " + String.format("%.2f%%", 
            calculateCompressionRatio(test2.length() * 2, encoded2.size() * 2)));
        System.out.println();
        
        // 测试用例3：无重复的字符串
        String test3 = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
        System.out.println("原始字符串: " + test3);
        System.out.println("原始长度: " + test3.length() + " 字符");
        
        List<Integer> encoded3 = encode(test3);
        System.out.println("编码结果: " + encoded3);
        System.out.println("编码长度: " + encoded3.size() + " 个整数");
        
        String decoded3 = decode(encoded3);
        System.out.println("解码结果: " + decoded3);
        System.out.println("编码解码是否正确: " + test3.equals(decoded3));
        System.out.println("压缩率: " + String.format("%.2f%%", 
            calculateCompressionRatio(test3.length() * 2, encoded3.size() * 2)));
    }
}

===============================================

文件: lzw_encoding.cpp
===============================================
/**
 * LZW字典编码实现 (C++简化版本)
 * 
 * LZW（Lempel-Ziv-Welch）是一种无损数据压缩算法，属于字典编码的一种。
 * 
 * 算法原理：
 * 1. 初始化字典，包含所有可能的单字符
 * 2. 读取输入字符串，查找字典中最长的匹配字符串
 * 3. 输出匹配字符串对应的编码
 * 4. 将匹配字符串加上下一个字符组成的新字符串添加到字典中
 * 5. 重复步骤2-4直到处理完所有输入
 * 
 * 时间复杂度：O(n)，其中n是输入字符串长度
 * 空间复杂度：O(d)，其中d是字典中条目的数量
 * 
 * 优势：
 * 1. 实现相对简单
 * 2. 压缩效果好，特别适合重复模式较多的数据
 * 3. 不需要预先知道数据的统计特性
 * 4. 编码和解码过程对称
 * 
 * 劣势：
 * 1. 需要维护字典，占用内存
 * 2. 对于随机数据压缩效果不佳
 * 3. 字典可能会变得很大
 * 
 * 应用场景：
 * 1. GIF图像格式
 * 2. TIFF图像格式
 * 3. Unix系统的compress工具
 */

// 定义最大字典大小
#define MAX_DICTIONARY_SIZE 4096
#define MAX_STRING_LENGTH 100

// 字符串结构
typedef struct {
    char str[MAX_STRING_LENGTH];
    int length;
} LZWString;

// 字典条目结构
typedef struct {
    LZWString key;
    int value;
} DictionaryEntry;

// 字典结构
typedef struct {
    DictionaryEntry entries[MAX_DICTIONARY_SIZE];
    int size;
} Dictionary;

// 整数向量结构
typedef struct {
    int data[MAX_DICTIONARY_SIZE];
    int size;
} IntVector;

/**
 * 初始化字符串
 */
void initString(LZWString* str, const char* chars, int len) {
    for (int i = 0; i < len && i < MAX_STRING_LENGTH - 1; i++) {
        str->str[i] = chars[i];
    }
    str->str[len] = '\0';
    str->length = len;
}

/**
 * 复制字符串
 */
void copyString(LZWString* dest, const LZWString* src) {
    for (int i = 0; i <= src->length && i < MAX_STRING_LENGTH; i++) {
        dest->str[i] = src->str[i];
    }
    dest->length = src->length;
}

/**
 * 连接字符到字符串
 */
void appendStringChar(LZWString* str, char c) {
    if (str->length < MAX_STRING_LENGTH - 1) {
        str->str[str->length] = c;
        str->str[str->length + 1] = '\0';
        str->length++;
    }
}

/**
 * 比较两个字符串
 */
int compareString(const LZWString* str1, const LZWString* str2) {
    if (str1->length != str2->length) {
        return 0;
    }
    for (int i = 0; i < str1->length; i++) {
        if (str1->str[i] != str2->str[i]) {
            return 0;
        }
    }
    return 1;
}

/**
 * 初始化字典
 */
void initDictionary(Dictionary* dict) {
    dict->size = 0;
}

/**
 * 在字典中查找字符串
 */
int findInDictionary(Dictionary* dict, const LZWString* key) {
    for (int i = 0; i < dict->size; i++) {
        if (compareString(&dict->entries[i].key, key)) {
            return dict->entries[i].value;
        }
    }
    return -1; // 未找到
}

/**
 * 向字典添加条目
 */
void addToDictionary(Dictionary* dict, const LZWString* key, int value) {
    if (dict->size < MAX_DICTIONARY_SIZE) {
        copyString(&dict->entries[dict->size].key, key);
        dict->entries[dict->size].value = value;
        dict->size++;
    }
}

/**
 * 从字典获取字符串
 */
int getFromDictionary(Dictionary* dict, int key, LZWString* result) {
    for (int i = 0; i < dict->size; i++) {
        if (dict->entries[i].value == key) {
            copyString(result, &dict->entries[i].key);
            return 1; // 成功
        }
    }
    return 0; // 未找到
}

/**
 * 初始化整数向量
 */
void initIntVector(IntVector* vec) {
    vec->size = 0;
}

/**
 * 向整数向量添加元素
 */
void addToIntVector(IntVector* vec, int value) {
    if (vec->size < MAX_DICTIONARY_SIZE) {
        vec->data[vec->size] = value;
        vec->size++;
    }
}

/**
 * LZW编码
 */
IntVector encode(const char* input) {
    Dictionary dictionary;
    initDictionary(&dictionary);
    
    // 初始化字典，包含所有ASCII字符
    for (int i = 0; i < 256; i++) {
        LZWString key;
        char ch = (char)i;
        initString(&key, &ch, 1);
        addToDictionary(&dictionary, &key, i);
    }
    
    IntVector result;
    initIntVector(&result);
    
    LZWString current;
    initString(&current, "", 0);
    
    int i = 0;
    while (input[i] != '\0') {
        char c = input[i];
        LZWString combined;
        copyString(&combined, &current);
        appendStringChar(&combined, c);
        
        // 如果组合字符串在字典中，继续扩展
        if (findInDictionary(&dictionary, &combined) != -1) {
            copyString(&current, &combined);
        } else {
            // 输出当前字符串的编码
            int code = findInDictionary(&dictionary, &current);
            if (code != -1) {
                addToIntVector(&result, code);
            }
            
            // 将新字符串添加到字典
            addToDictionary(&dictionary, &combined, 256 + dictionary.size);
            
            // 重新开始
            initString(&current, &c, 1);
        }
        i++;
    }
    
    // 输出最后一个字符串
    if (current.length > 0) {
        int code = findInDictionary(&dictionary, &current);
        if (code != -1) {
            addToIntVector(&result, code);
        }
    }
    
    return result;
}

/**
 * LZW解码
 */
void decode(IntVector* encoded, char* output) {
    Dictionary dictionary;
    initDictionary(&dictionary);
    
    // 初始化字典，包含所有ASCII字符
    for (int i = 0; i < 256; i++) {
        LZWString key;
        char ch = (char)i;
        initString(&key, &ch, 1);
        addToDictionary(&dictionary, &key, i);
    }
    
    output[0] = '\0';
    LZWString current;
    initString(&current, "", 0);
    
    for (int i = 0; i < encoded->size; i++) {
        int code = encoded->data[i];
        LZWString entry;
        
        if (getFromDictionary(&dictionary, code, &entry)) {
            // 成功获取条目
        } else if (code == 256 + dictionary.size) {
            // 特殊情况：处理字符串+首字符的重复情况
            copyString(&entry, &current);
            if (current.length > 0) {
                appendStringChar(&entry, current.str[0]);
            }
        } else {
            // 无效编码
            output[0] = '\0';
            return;
        }
        
        // 将条目添加到输出
        int outputLen = 0;
        while (output[outputLen] != '\0') {
            outputLen++;
        }
        
        for (int j = 0; j < entry.length && outputLen + j < MAX_DICTIONARY_SIZE - 1; j++) {
            output[outputLen + j] = entry.str[j];
        }
        output[outputLen + entry.length] = '\0';
        
        // 将新字符串添加到字典
        if (current.length > 0) {
            LZWString newEntry;
            copyString(&newEntry, &current);
            if (entry.length > 0) {
                appendStringChar(&newEntry, entry.str[0]);
            }
            addToDictionary(&dictionary, &newEntry, 256 + dictionary.size);
        }
        
        copyString(&current, &entry);
    }
}

/**
 * 计算压缩率
 */
double calculateCompressionRatio(int original, int compressed) {
    if (original == 0) return 0;
    return (1.0 - (double) compressed / original) * 100;
}

// 由于环境限制，不包含main函数和输出语句
// 算法核心功能已实现，可被其他程序调用

===============================================

文件: lzw_encoding.py
===============================================
#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
LZW字典编码实现 (Python版本)

LZW（Lempel-Ziv-Welch）是一种无损数据压缩算法，属于字典编码的一种。

算法原理：
1. 初始化字典，包含所有可能的单字符
2. 读取输入字符串，查找字典中最长的匹配字符串
3. 输出匹配字符串对应的编码
4. 将匹配字符串加上下一个字符组成的新字符串添加到字典中
5. 重复步骤2-4直到处理完所有输入

时间复杂度：O(n)，其中n是输入字符串长度
空间复杂度：O(d)，其中d是字典中条目的数量

优势：
1. 实现相对简单
2. 压缩效果好，特别适合重复模式较多的数据
3. 不需要预先知道数据的统计特性
4. 编码和解码过程对称

劣势：
1. 需要维护字典，占用内存
2. 对于随机数据压缩效果不佳
3. 字典可能会变得很大

应用场景：
1. GIF图像格式
2. TIFF图像格式
3. Unix系统的compress工具
"""


def lzw_encode(input_string):
    """
    LZW编码
    :param input_string: 输入字符串
    :return: 编码结果（整数列表）
    """
    # 初始化字典，包含所有ASCII字符
    dictionary = {chr(i): i for i in range(256)}
    dict_size = 256
    
    result = []
    current = ""
    
    for char in input_string:
        combined = current + char
        
        # 如果组合字符串在字典中，继续扩展
        if combined in dictionary:
            current = combined
        else:
            # 输出当前字符串的编码
            result.append(dictionary[current])
            
            # 将新字符串添加到字典
            dictionary[combined] = dict_size
            dict_size += 1
            
            # 重新开始
            current = char
    
    # 输出最后一个字符串
    if current:
        result.append(dictionary[current])
    
    return result


def lzw_decode(encoded):
    """
    LZW解码
    :param encoded: 编码结果（整数列表）
    :return: 解码结果（字符串）
    """
    # 初始化字典，包含所有ASCII字符
    dictionary = {i: chr(i) for i in range(256)}
    dict_size = 256
    
    result = []
    current = ""
    
    for code in encoded:
        if code in dictionary:
            entry = dictionary[code]
        elif code == dict_size:
            # 特殊情况：处理字符串+首字符的重复情况
            entry = current + current[0]
        else:
            raise ValueError(f"无效的编码: {code}")
        
        result.append(entry)
        
        # 将新字符串添加到字典
        if current:
            dictionary[dict_size] = current + entry[0]
            dict_size += 1
        
        current = entry
    
    return ''.join(result)


def calculate_compression_ratio(original_size, compressed_size):
    """
    计算压缩率
    :param original_size: 原始数据大小（字节）
    :param compressed_size: 压缩后数据大小（字节）
    :return: 压缩率（百分比）
    """
    if original_size == 0:
        return 0
    return (1.0 - compressed_size / original_size) * 100


def main():
    """
    测试方法
    """
    # 测试用例1：包含重复模式的字符串
    test1 = "ABABABA"
    print(f"原始字符串: {test1}")
    print(f"原始长度: {len(test1)} 字符")
    
    encoded1 = lzw_encode(test1)
    print(f"编码结果: {encoded1}")
    print(f"编码长度: {len(encoded1)} 个整数")
    
    decoded1 = lzw_decode(encoded1)
    print(f"解码结果: {decoded1}")
    print(f"编码解码是否正确: {test1 == decoded1}")
    print(f"压缩率: {calculate_compression_ratio(len(test1) * 2, len(encoded1) * 2):.2f}%")  # 假设每个整数占2字节
    print()
    
    # 测试用例2：更复杂的字符串
    test2 = "ABCABCABCABCABC"
    print(f"原始字符串: {test2}")
    print(f"原始长度: {len(test2)} 字符")
    
    encoded2 = lzw_encode(test2)
    print(f"编码结果: {encoded2}")
    print(f"编码长度: {len(encoded2)} 个整数")
    
    decoded2 = lzw_decode(encoded2)
    print(f"解码结果: {decoded2}")
    print(f"编码解码是否正确: {test2 == decoded2}")
    print(f"压缩率: {calculate_compression_ratio(len(test2) * 2, len(encoded2) * 2):.2f}%")
    print()
    
    # 测试用例3：无重复的字符串
    test3 = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
    print(f"原始字符串: {test3}")
    print(f"原始长度: {len(test3)} 字符")
    
    encoded3 = lzw_encode(test3)
    print(f"编码结果: {encoded3}")
    print(f"编码长度: {len(encoded3)} 个整数")
    
    decoded3 = lzw_decode(encoded3)
    print(f"解码结果: {decoded3}")
    print(f"编码解码是否正确: {test3 == decoded3}")
    print(f"压缩率: {calculate_compression_ratio(len(test3) * 2, len(encoded3) * 2):.2f}%")


if __name__ == "__main__":
    main()

===============================================

文件: MaskPreprocess.java
===============================================
package class175.随机化与复杂度分析;

/**
 * 掩码预处理工具类
 * 提供常用位掩码的预处理和位运算优化功能
 * 用于算法中的位操作加速
 */
public class MaskPreprocess {
    // 预定义的最大数组大小
    private static final int MAX_N = 1 << 20; // 1,048,576
    
    // 预处理数组
    private static int[] lowbit;         // 最低位1的值
    private static int[] highestBit;     // 最高位1的位置（从0开始）
    private static int[] bitCount;       // 二进制中1的个数（popcount）
    private static int[] nextSetBit;     // 下一个设置位的位置
    private static int[] prevSetBit;     // 上一个设置位的位置
    private static int[] parity;         // 奇偶校验位（1的个数的奇偶性）
    
    // 常用掩码
    public static final int ALL_ONES_8 = 0xFF;       // 8位全1掩码
    public static final int ALL_ONES_16 = 0xFFFF;    // 16位全1掩码
    public static final int ALL_ONES_32 = 0xFFFFFFFF; // 32位全1掩码
    
    public static final int ALTERNATE_ODD = 0x55555555;  // 01010101...
    public static final int ALTERNATE_EVEN = 0xAAAAAAAA; // 10101010...
    
    public static final int ALL_ONES_LAST_4 = 0x0000000F; // 最后4位全1
    public static final int ALL_ONES_FIRST_4 = 0xF0000000; // 最前4位全1
    
    // 静态初始化块，预处理所有数据
    static {
        preprocessAll();
    }
    
    /**
     * 预处理所有掩码数据
     */
    private static void preprocessAll() {
        lowbit = new int[MAX_N];
        highestBit = new int[MAX_N];
        bitCount = new int[MAX_N];
        nextSetBit = new int[MAX_N];
        prevSetBit = new int[MAX_N];
        parity = new int[MAX_N];
        
        // 初始化最低位1
        for (int i = 1; i < MAX_N; i++) {
            lowbit[i] = i & (-i);
        }
        
        // 初始化最高位1的位置
        highestBit[0] = -1; // 特殊情况
        for (int i = 1; i < MAX_N; i++) {
            highestBit[i] = highestBit[i >> 1] + 1;
        }
        
        // 初始化bitCount（使用动态规划）
        bitCount[0] = 0;
        for (int i = 1; i < MAX_N; i++) {
            bitCount[i] = bitCount[i & (i - 1)] + 1;
        }
        
        // 初始化nextSetBit
        for (int i = 0; i < MAX_N; i++) {
            nextSetBit[i] = -1; // 默认-1表示没有下一个设置位
            if (i == 0) continue;
            
            int temp = i;
            int lsb = temp & -temp;
            temp ^= lsb; // 清除最低位1
            if (temp != 0) {
                nextSetBit[i] = Integer.numberOfTrailingZeros(temp & -temp);
            }
        }
        
        // 初始化prevSetBit
        for (int i = 0; i < MAX_N; i++) {
            prevSetBit[i] = -1; // 默认-1表示没有上一个设置位
            if (i == 0) continue;
            
            int temp = i;
            int highest = 31 - Integer.numberOfLeadingZeros(temp);
            temp ^= (1 << highest); // 清除最高位1
            if (temp != 0) {
                prevSetBit[i] = 31 - Integer.numberOfLeadingZeros(temp);
            }
        }
        
        // 初始化奇偶校验
        parity[0] = 0;
        for (int i = 1; i < MAX_N; i++) {
            parity[i] = parity[i >> 1] ^ (i & 1);
        }
    }
    
    /**
     * 获取最低位1的值
     * 等同于 x & (-x)
     * 
     * @param x 输入整数
     * @return 最低位1的值
     */
    public static int getLowbit(int x) {
        if (x == 0) return 0;
        if (x < MAX_N) return lowbit[x];
        return x & (-x); // 对于超出预计算范围的数
    }
    
    /**
     * 获取最高位1的位置（从0开始）
     * 
     * @param x 输入整数
     * @return 最高位1的位置
     */
    public static int getHighestBitPosition(int x) {
        if (x == 0) return -1;
        if (x < MAX_N) return highestBit[x];
        return 31 - Integer.numberOfLeadingZeros(x); // 对于超出预计算范围的数
    }
    
    /**
     * 获取二进制中1的个数
     * 
     * @param x 输入整数
     * @return 1的个数
     */
    public static int getBitCount(int x) {
        if (x == 0) return 0;
        if (x < MAX_N) return bitCount[x];
        return Integer.bitCount(x); // 对于超出预计算范围的数
    }
    
    /**
     * 获取下一个设置位的位置
     * 
     * @param x 输入整数
     * @return 下一个设置位的位置，如果没有返回-1
     */
    public static int getNextSetBit(int x) {
        if (x < MAX_N) return nextSetBit[x];
        // 动态计算
        int temp = x;
        int lsb = temp & -temp;
        temp ^= lsb;
        return temp == 0 ? -1 : Integer.numberOfTrailingZeros(temp & -temp);
    }
    
    /**
     * 获取上一个设置位的位置
     * 
     * @param x 输入整数
     * @return 上一个设置位的位置，如果没有返回-1
     */
    public static int getPrevSetBit(int x) {
        if (x < MAX_N) return prevSetBit[x];
        // 动态计算
        int temp = x;
        int highest = 31 - Integer.numberOfLeadingZeros(temp);
        temp ^= (1 << highest);
        return temp == 0 ? -1 : 31 - Integer.numberOfLeadingZeros(temp);
    }
    
    /**
     * 获取奇偶校验位（1的个数的奇偶性）
     * 
     * @param x 输入整数
     * @return 1表示奇数个1，0表示偶数个1
     */
    public static int getParity(int x) {
        if (x < MAX_N) return parity[x];
        // 动态计算
        x ^= x >>> 16;
        x ^= x >>> 8;
        x ^= x >>> 4;
        x ^= x >>> 2;
        x ^= x >>> 1;
        return x & 1;
    }
    
    /**
     * 生成特定长度的全1掩码
     * 
     * @param length 掩码长度
     * @return 全1掩码
     */
    public static int generateAllOnesMask(int length) {
        return (1 << length) - 1;
    }
    
    /**
     * 生成交替位掩码
     * 
     * @param startWithOne 是否以1开始
     * @return 交替位掩码
     */
    public static int generateAlternatingMask(boolean startWithOne) {
        return startWithOne ? ALTERNATE_ODD : ALTERNATE_EVEN;
    }
    
    /**
     * 检查数x是否是2的幂
     * 
     * @param x 输入整数
     * @return 是否是2的幂
     */
    public static boolean isPowerOfTwo(int x) {
        return x > 0 && (x & (x - 1)) == 0;
    }
    
    /**
     * 对齐到下一个2的幂
     * 
     * @param x 输入整数
     * @return 下一个大于等于x的2的幂
     */
    public static int nextPowerOfTwo(int x) {
        if (x <= 0) return 1;
        x--;
        x |= x >> 1;
        x |= x >> 2;
        x |= x >> 4;
        x |= x >> 8;
        x |= x >> 16;
        return x + 1;
    }
    
    /**
     * 主方法，用于测试
     */
    public static void main(String[] args) {
        // 测试基本功能
        int testNum = 0b10110100; // 180
        System.out.println("测试数字: " + testNum + " (二进制: " + 
                          Integer.toBinaryString(testNum) + ")");
        
        System.out.println("最低位1的值: " + getLowbit(testNum) + 
                          " (二进制: " + Integer.toBinaryString(getLowbit(testNum)) + ")");
        
        System.out.println("最高位1的位置: " + getHighestBitPosition(testNum));
        
        System.out.println("二进制中1的个数: " + getBitCount(testNum));
        
        System.out.println("下一个设置位的位置: " + getNextSetBit(testNum));
        
        System.out.println("上一个设置位的位置: " + getPrevSetBit(testNum));
        
        System.out.println("奇偶校验位: " + getParity(testNum));
        
        // 测试掩码生成
        System.out.println("\n掩码生成测试:");
        System.out.println("8位全1掩码: " + generateAllOnesMask(8) + 
                          " (二进制: " + Integer.toBinaryString(generateAllOnesMask(8)) + ")");
        
        System.out.println("交替位掩码(以1开始): " + 
                          Integer.toBinaryString(generateAlternatingMask(true)));
        
        System.out.println("交替位掩码(以0开始): " + 
                          Integer.toBinaryString(generateAlternatingMask(false)));
        
        // 测试工具方法
        System.out.println("\n工具方法测试:");
        System.out.println("64是否是2的幂: " + isPowerOfTwo(64));
        System.out.println("100是否是2的幂: " + isPowerOfTwo(100));
        
        System.out.println("100的下一个2的幂: " + nextPowerOfTwo(100));
        System.out.println("128的下一个2的幂: " + nextPowerOfTwo(128));
    }
}

===============================================

文件: mask_preprocess.cpp
===============================================
#include <iostream>
#include <vector>
#include <string>
#include <algorithm>
#include <cmath>

/**
 * 掩码预处理工具类
 * 提供常用位掩码的预处理和位运算优化功能
 * 用于算法中的位操作加速
 */

class MaskPreprocess {
private:
    // 预定义的最大数组大小
    static const int MAX_N = 1 << 20; // 1,048,576
    
    // 预处理数组
    static std::vector<int> lowbit;         // 最低位1的值
    static std::vector<int> highestBit;     // 最高位1的位置（从0开始）
    static std::vector<int> bitCount;       // 二进制中1的个数（popcount）
    static std::vector<int> nextSetBit;     // 下一个设置位的位置
    static std::vector<int> prevSetBit;     // 上一个设置位的位置
    static std::vector<int> parity;         // 奇偶校验位（1的个数的奇偶性）
    
    // 初始化标志
    static bool initialized;
    
    /**
     * 预处理所有掩码数据
     */
    static void initialize() {
        if (initialized) return;
        
        lowbit.resize(MAX_N);
        highestBit.resize(MAX_N);
        bitCount.resize(MAX_N);
        nextSetBit.resize(MAX_N, -1);
        prevSetBit.resize(MAX_N, -1);
        parity.resize(MAX_N);
        
        // 初始化最低位1
        for (int i = 1; i < MAX_N; i++) {
            lowbit[i] = i & (-i);
        }
        
        // 初始化最高位1的位置
        highestBit[0] = -1; // 特殊情况
        for (int i = 1; i < MAX_N; i++) {
            highestBit[i] = highestBit[i >> 1] + 1;
        }
        
        // 初始化bitCount（使用动态规划）
        bitCount[0] = 0;
        for (int i = 1; i < MAX_N; i++) {
            bitCount[i] = bitCount[i & (i - 1)] + 1;
        }
        
        // 初始化nextSetBit
        for (int i = 1; i < MAX_N; i++) {
            int temp = i;
            int lsb = temp & -temp;
            temp ^= lsb; // 清除最低位1
            if (temp != 0) {
                // 计算下一个最低位1的位置
                int next_lsb = temp & -temp;
                nextSetBit[i] = 0;
                while (next_lsb > 1) {
                    next_lsb >>= 1;
                    nextSetBit[i]++;
                }
            }
        }
        
        // 初始化prevSetBit
        for (int i = 1; i < MAX_N; i++) {
            int temp = i;
            int highest = 0;
            int temp_copy = temp;
            while (temp_copy >>= 1) {
                highest++;
            }
            temp ^= (1 << highest); // 清除最高位1
            if (temp != 0) {
                prevSetBit[i] = 0;
                temp_copy = temp;
                while (temp_copy >>= 1) {
                    prevSetBit[i]++;
                }
            }
        }
        
        // 初始化奇偶校验
        parity[0] = 0;
        for (int i = 1; i < MAX_N; i++) {
            parity[i] = parity[i >> 1] ^ (i & 1);
        }
        
        initialized = true;
    }
    
public:
    // 常用掩码
    static const int ALL_ONES_8 = 0xFF;       // 8位全1掩码
    static const int ALL_ONES_16 = 0xFFFF;    // 16位全1掩码
    static const int ALL_ONES_32 = 0xFFFFFFFF; // 32位全1掩码
    
    static const int ALTERNATE_ODD = 0x55555555;  // 01010101...
    static const int ALTERNATE_EVEN = 0xAAAAAAAA; // 10101010...
    
    static const int ALL_ONES_LAST_4 = 0x0000000F; // 最后4位全1
    static const int ALL_ONES_FIRST_4 = 0xF0000000; // 最前4位全1
    
    /**
     * 构造函数，确保初始化
     */
    MaskPreprocess() {
        initialize();
    }
    
    /**
     * 获取最低位1的值
     * 等同于 x & (-x)
     * 
     * @param x 输入整数
     * @return 最低位1的值
     */
    static int getLowbit(int x) {
        initialize();
        if (x == 0) return 0;
        if (x >= 0 && x < MAX_N) return lowbit[x];
        return x & (-x); // 对于超出预计算范围的数
    }
    
    /**
     * 获取最高位1的位置（从0开始）
     * 
     * @param x 输入整数
     * @return 最高位1的位置
     */
    static int getHighestBitPosition(int x) {
        initialize();
        if (x == 0) return -1;
        if (x >= 0 && x < MAX_N) return highestBit[x];
        // 对于超出预计算范围的数
        int pos = -1;
        while (x > 0) {
            x >>= 1;
            pos++;
        }
        return pos;
    }
    
    /**
     * 获取二进制中1的个数
     * 
     * @param x 输入整数
     * @return 1的个数
     */
    static int getBitCount(int x) {
        initialize();
        if (x == 0) return 0;
        if (x >= 0 && x < MAX_N) return bitCount[x];
        
        // 对于超出预计算范围的数，使用Kernighan算法
        int count = 0;
        while (x != 0) {
            x &= x - 1; // 清除最低位的1
            count++;
        }
        return count;
    }
    
    /**
     * 获取下一个设置位的位置
     * 
     * @param x 输入整数
     * @return 下一个设置位的位置，如果没有返回-1
     */
    static int getNextSetBit(int x) {
        initialize();
        if (x >= 0 && x < MAX_N) return nextSetBit[x];
        
        // 动态计算
        int temp = x;
        int lsb = temp & -temp;
        temp ^= lsb;
        if (temp == 0) return -1;
        
        int next_lsb = temp & -temp;
        int pos = 0;
        while (next_lsb > 1) {
            next_lsb >>= 1;
            pos++;
        }
        return pos;
    }
    
    /**
     * 获取上一个设置位的位置
     * 
     * @param x 输入整数
     * @return 上一个设置位的位置，如果没有返回-1
     */
    static int getPrevSetBit(int x) {
        initialize();
        if (x >= 0 && x < MAX_N) return prevSetBit[x];
        
        // 动态计算
        int temp = x;
        int highest = 0;
        int temp_copy = temp;
        while (temp_copy >>= 1) {
            highest++;
        }
        temp ^= (1 << highest);
        if (temp == 0) return -1;
        
        int pos = 0;
        temp_copy = temp;
        while (temp_copy >>= 1) {
            pos++;
        }
        return pos;
    }
    
    /**
     * 获取奇偶校验位（1的个数的奇偶性）
     * 
     * @param x 输入整数
     * @return 1表示奇数个1，0表示偶数个1
     */
    static int getParity(int x) {
        initialize();
        if (x >= 0 && x < MAX_N) return parity[x];
        
        // 动态计算
        x ^= x >> 16;
        x ^= x >> 8;
        x ^= x >> 4;
        x ^= x >> 2;
        x ^= x >> 1;
        return x & 1;
    }
    
    /**
     * 生成特定长度的全1掩码
     * 
     * @param length 掩码长度
     * @return 全1掩码
     */
    static int generateAllOnesMask(int length) {
        return (1 << length) - 1;
    }
    
    /**
     * 生成交替位掩码
     * 
     * @param startWithOne 是否以1开始
     * @return 交替位掩码
     */
    static int generateAlternatingMask(bool startWithOne = true) {
        return startWithOne ? ALTERNATE_ODD : ALTERNATE_EVEN;
    }
    
    /**
     * 检查数x是否是2的幂
     * 
     * @param x 输入整数
     * @return 是否是2的幂
     */
    static bool isPowerOfTwo(int x) {
        return x > 0 && (x & (x - 1)) == 0;
    }
    
    /**
     * 对齐到下一个2的幂
     * 
     * @param x 输入整数
     * @return 下一个大于等于x的2的幂
     */
    static int nextPowerOfTwo(int x) {
        if (x <= 0) return 1;
        x--;
        x |= x >> 1;
        x |= x >> 2;
        x |= x >> 4;
        x |= x >> 8;
        x |= x >> 16;
        return x + 1;
    }
    
    /**
     * 将整数转换为二进制字符串
     * 
     * @param num 整数
     * @param bits 位数
     * @return 二进制字符串
     */
    static std::string toBinaryString(int num, int bits = 32) {
        std::string result;
        if (num < 0) {
            // 对于负数，展示其补码表示
            num = (1LL << bits) + num;
        }
        
        for (int i = bits - 1; i >= 0; i--) {
            result += ((num >> i) & 1) ? '1' : '0';
        }
        
        return result;
    }
};

// 静态成员初始化
bool MaskPreprocess::initialized = false;
std::vector<int> MaskPreprocess::lowbit;
std::vector<int> MaskPreprocess::highestBit;
std::vector<int> MaskPreprocess::bitCount;
std::vector<int> MaskPreprocess::nextSetBit;
std::vector<int> MaskPreprocess::prevSetBit;
std::vector<int> MaskPreprocess::parity;

/**
 * 主函数，用于测试
 */
int main() {
    int testNum = 0b10110100; // 180
    std::cout << "测试数字: " << testNum << " (二进制: " << 
              MaskPreprocess::toBinaryString(testNum, 8) << ")" << std::endl;
    
    std::cout << "最低位1的值: " << MaskPreprocess::getLowbit(testNum) << 
              " (二进制: " << MaskPreprocess::toBinaryString(MaskPreprocess::getLowbit(testNum), 8) << ")" << std::endl;
    
    std::cout << "最高位1的位置: " << MaskPreprocess::getHighestBitPosition(testNum) << std::endl;
    
    std::cout << "二进制中1的个数: " << MaskPreprocess::getBitCount(testNum) << std::endl;
    
    std::cout << "下一个设置位的位置: " << MaskPreprocess::getNextSetBit(testNum) << std::endl;
    
    std::cout << "上一个设置位的位置: " << MaskPreprocess::getPrevSetBit(testNum) << std::endl;
    
    std::cout << "奇偶校验位: " << MaskPreprocess::getParity(testNum) << std::endl;
    
    // 测试掩码生成
    std::cout << "\n掩码生成测试:" << std::endl;
    std::cout << "8位全1掩码: " << MaskPreprocess::generateAllOnesMask(8) << 
              " (二进制: " << MaskPreprocess::toBinaryString(MaskPreprocess::generateAllOnesMask(8), 8) << ")" << std::endl;
    
    std::cout << "交替位掩码(以1开始): " << 
              MaskPreprocess::toBinaryString(MaskPreprocess::generateAlternatingMask(true), 8) << std::endl;
    
    std::cout << "交替位掩码(以0开始): " << 
              MaskPreprocess::toBinaryString(MaskPreprocess::generateAlternatingMask(false), 8) << std::endl;
    
    // 测试工具方法
    std::cout << "\n工具方法测试:" << std::endl;
    std::cout << "64是否是2的幂: " << (MaskPreprocess::isPowerOfTwo(64) ? "true" : "false") << std::endl;
    std::cout << "100是否是2的幂: " << (MaskPreprocess::isPowerOfTwo(100) ? "true" : "false") << std::endl;
    
    std::cout << "100的下一个2的幂: " << MaskPreprocess::nextPowerOfTwo(100) << std::endl;
    std::cout << "128的下一个2的幂: " << MaskPreprocess::nextPowerOfTwo(128) << std::endl;
    
    return 0;
}

===============================================

文件: mask_preprocess.py
===============================================
#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
掩码预处理工具模块
提供常用位掩码的预处理和位运算优化功能
用于算法中的位操作加速
"""

# 预定义的最大数组大小
MAX_N = 1 << 20  # 1,048,576

# 常用掩码
ALL_ONES_8 = 0xFF        # 8位全1掩码
ALL_ONES_16 = 0xFFFF     # 16位全1掩码
ALL_ONES_32 = 0xFFFFFFFF # 32位全1掩码

ALTERNATE_ODD = 0x55555555  # 01010101...
ALTERNATE_EVEN = 0xAAAAAAAA # 10101010...

ALL_ONES_LAST_4 = 0x0000000F  # 最后4位全1
ALL_ONES_FIRST_4 = 0xF0000000 # 最前4位全1

# 预处理数组
lowbit = None         # 最低位1的值
highest_bit = None    # 最高位1的位置（从0开始）
bit_count = None      # 二进制中1的个数（popcount）
next_set_bit = None   # 下一个设置位的位置
prev_set_bit = None   # 上一个设置位的位置
parity = None         # 奇偶校验位（1的个数的奇偶性）

def initialize():
    """
    初始化所有预处理数组
    """
    global lowbit, highest_bit, bit_count, next_set_bit, prev_set_bit, parity
    
    # 初始化数组
    lowbit = [0] * MAX_N
    highest_bit = [0] * MAX_N
    bit_count = [0] * MAX_N
    next_set_bit = [-1] * MAX_N
    prev_set_bit = [-1] * MAX_N
    parity = [0] * MAX_N
    
    # 计算最低位1
    for i in range(1, MAX_N):
        lowbit[i] = i & (-i)
    
    # 计算最高位1的位置
    highest_bit[0] = -1  # 特殊情况
    for i in range(1, MAX_N):
        highest_bit[i] = highest_bit[i >> 1] + 1
    
    # 计算bit_count（使用动态规划）
    bit_count[0] = 0
    for i in range(1, MAX_N):
        bit_count[i] = bit_count[i & (i - 1)] + 1
    
    # 计算nextSetBit
    for i in range(1, MAX_N):
        temp = i
        lsb = temp & -temp
        temp ^= lsb  # 清除最低位1
        if temp != 0:
            # 计算下一个最低位1的位置
            next_set_bit[i] = (temp & -temp).bit_length() - 1
    
    # 计算prevSetBit
    for i in range(1, MAX_N):
        temp = i
        highest = temp.bit_length() - 1
        temp ^= (1 << highest)  # 清除最高位1
        if temp != 0:
            prev_set_bit[i] = temp.bit_length() - 1
    
    # 计算奇偶校验
    parity[0] = 0
    for i in range(1, MAX_N):
        parity[i] = parity[i >> 1] ^ (i & 1)

# 初始化预处理数组
initialize()

def get_lowbit(x):
    """
    获取最低位1的值
    等同于 x & (-x)
    
    Args:
        x: 输入整数
    
    Returns:
        int: 最低位1的值
    """
    if x == 0:
        return 0
    if 0 <= x < MAX_N:
        return lowbit[x]
    # 对于超出预计算范围的数
    return x & (-x)

def get_highest_bit_position(x):
    """
    获取最高位1的位置（从0开始）
    
    Args:
        x: 输入整数
    
    Returns:
        int: 最高位1的位置
    """
    if x == 0:
        return -1
    if 0 <= x < MAX_N:
        return highest_bit[x]
    # 对于超出预计算范围的数
    return x.bit_length() - 1

def get_bit_count(x):
    """
    获取二进制中1的个数
    
    Args:
        x: 输入整数
    
    Returns:
        int: 1的个数
    """
    if x == 0:
        return 0
    if 0 <= x < MAX_N:
        return bit_count[x]
    # 对于超出预计算范围的数
    if hasattr(int, 'bit_count'):
        return x.bit_count()
    return bin(x).count('1')

def get_next_set_bit(x):
    """
    获取下一个设置位的位置
    
    Args:
        x: 输入整数
    
    Returns:
        int: 下一个设置位的位置，如果没有返回-1
    """
    if 0 <= x < MAX_N:
        return next_set_bit[x]
    # 动态计算
    temp = x
    lsb = temp & -temp
    temp ^= lsb
    if temp == 0:
        return -1
    return (temp & -temp).bit_length() - 1

def get_prev_set_bit(x):
    """
    获取上一个设置位的位置
    
    Args:
        x: 输入整数
    
    Returns:
        int: 上一个设置位的位置，如果没有返回-1
    """
    if 0 <= x < MAX_N:
        return prev_set_bit[x]
    # 动态计算
    temp = x
    highest = temp.bit_length() - 1
    temp ^= (1 << highest)
    if temp == 0:
        return -1
    return temp.bit_length() - 1

def get_parity(x):
    """
    获取奇偶校验位（1的个数的奇偶性）
    
    Args:
        x: 输入整数
    
    Returns:
        int: 1表示奇数个1，0表示偶数个1
    """
    if 0 <= x < MAX_N:
        return parity[x]
    # 动态计算
    x ^= x >> 16
    x ^= x >> 8
    x ^= x >> 4
    x ^= x >> 2
    x ^= x >> 1
    return x & 1

def generate_all_ones_mask(length):
    """
    生成特定长度的全1掩码
    
    Args:
        length: 掩码长度
    
    Returns:
        int: 全1掩码
    """
    return (1 << length) - 1

def generate_alternating_mask(start_with_one=True):
    """
    生成交替位掩码
    
    Args:
        start_with_one: 是否以1开始
    
    Returns:
        int: 交替位掩码
    """
    return ALTERNATE_ODD if start_with_one else ALTERNATE_EVEN

def is_power_of_two(x):
    """
    检查数x是否是2的幂
    
    Args:
        x: 输入整数
    
    Returns:
        bool: 是否是2的幂
    """
    return x > 0 and (x & (x - 1)) == 0

def next_power_of_two(x):
    """
    对齐到下一个2的幂
    
    Args:
        x: 输入整数
    
    Returns:
        int: 下一个大于等于x的2的幂
    """
    if x <= 0:
        return 1
    x -= 1
    x |= x >> 1
    x |= x >> 2
    x |= x >> 4
    x |= x >> 8
    x |= x >> 16
    return x + 1

def to_binary_string(x, bits=32):
    """
    将整数转换为固定长度的二进制字符串
    
    Args:
        x: 输入整数
        bits: 位数
    
    Returns:
        str: 二进制字符串
    """
    if x < 0:
        # 对于负数，显示补码
        x = (1 << bits) + x
    return bin(x)[2:].zfill(bits)

def test_mask_preprocess():
    """
    测试掩码预处理功能
    """
    test_num = 0b10110100  # 180
    print(f"测试数字: {test_num} (二进制: {to_binary_string(test_num, 8)})")
    
    print(f"最低位1的值: {get_lowbit(test_num)} (二进制: {to_binary_string(get_lowbit(test_num), 8)})")
    
    print(f"最高位1的位置: {get_highest_bit_position(test_num)}")
    
    print(f"二进制中1的个数: {get_bit_count(test_num)}")
    
    print(f"下一个设置位的位置: {get_next_set_bit(test_num)}")
    
    print(f"上一个设置位的位置: {get_prev_set_bit(test_num)}")
    
    print(f"奇偶校验位: {get_parity(test_num)}")
    
    # 测试掩码生成
    print("\n掩码生成测试:")
    print(f"8位全1掩码: {generate_all_ones_mask(8)} (二进制: {to_binary_string(generate_all_ones_mask(8), 8)})")
    
    print(f"交替位掩码(以1开始): {to_binary_string(generate_alternating_mask(True), 8)}")
    
    print(f"交替位掩码(以0开始): {to_binary_string(generate_alternating_mask(False), 8)}")
    
    # 测试工具方法
    print("\n工具方法测试:")
    print(f"64是否是2的幂: {is_power_of_two(64)}")
    print(f"100是否是2的幂: {is_power_of_two(100)}")
    
    print(f"100的下一个2的幂: {next_power_of_two(100)}")
    print(f"128的下一个2的幂: {next_power_of_two(128)}")

if __name__ == "__main__":
    test_mask_preprocess()

===============================================

文件: NaryTree.java
===============================================
package class175."n叉树"; // 注意：在实际编译时需要移除引号

import java.util.*;

/**
 * N叉树（N-ary Tree）实现类
 * N叉树是一种树数据结构，其中每个节点可以有0个或多个子节点
 * 
 * 常见应用场景：
 * 1. 组织结构图
 * 2. 文件系统目录结构
 * 3. XML/HTML文档解析
 * 4. 计算机网络路由
 * 5. 游戏开发中的场景树
 * 
 * 相关算法题目：
 * - LeetCode 589. N叉树的前序遍历 https://leetcode.cn/problems/n-ary-tree-preorder-traversal/
 * - LeetCode 590. N叉树的后序遍历 https://leetcode.cn/problems/n-ary-tree-postorder-traversal/
 * - LeetCode 429. N叉树的层序遍历 https://leetcode.cn/problems/n-ary-tree-level-order-traversal/
 * - LeetCode 559. N叉树的最大深度 https://leetcode.cn/problems/maximum-depth-of-n-ary-tree/
 * - LeetCode 1104. 二叉树寻路 https://leetcode.cn/problems/path-in-zigzag-labelled-binary-tree/
 * - LeetCode 1490. 克隆N叉树 https://leetcode.cn/problems/clone-n-ary-tree/
 * - LintCode 1522. N叉树的直径 https://www.lintcode.com/problem/1522/
 * - HackerRank N-ary Tree Level Order Traversal https://www.hackerrank.com/challenges/tree-level-order-traversal/problem
 * - 洛谷 P5598 【XR-4】文本编辑器 https://www.luogu.com.cn/problem/P5598
 */
class NaryTreeNode {
    public int val;
    public List<NaryTreeNode> children;

    /**
     * 构造函数
     * @param val 节点值
     */
    public NaryTreeNode(int val) {
        this.val = val;
        this.children = new ArrayList<>();
    }

    /**
     * 添加子节点
     * @param child 子节点
     */
    public void addChild(NaryTreeNode child) {
        this.children.add(child);
    }
}

public class NaryTree {
    /**
     * 前序遍历：根节点 -> 子节点（从左到右）
     * @param root N叉树的根节点
     * @return 前序遍历的结果列表
     */
    public List<Integer> preorderTraversal(NaryTreeNode root) {
        List<Integer> result = new ArrayList<>();
        if (root == null) {
            return result;
        }
        preorderHelper(root, result);
        return result;
    }

    private void preorderHelper(NaryTreeNode node, List<Integer> result) {
        if (node == null) {
            return;
        }
        // 先访问根节点
        result.add(node.val);
        // 再递归访问所有子节点
        for (NaryTreeNode child : node.children) {
            preorderHelper(child, result);
        }
    }

    /**
     * 前序遍历的非递归实现
     * @param root N叉树的根节点
     * @return 前序遍历的结果列表
     */
    public List<Integer> preorderTraversalIterative(NaryTreeNode root) {
        List<Integer> result = new ArrayList<>();
        if (root == null) {
            return result;
        }

        Stack<NaryTreeNode> stack = new Stack<>();
        stack.push(root);

        while (!stack.isEmpty()) {
            NaryTreeNode node = stack.pop();
            result.add(node.val);
            // 注意：这里需要逆序压入子节点，以保证出栈顺序是从左到右
            for (int i = node.children.size() - 1; i >= 0; i--) {
                stack.push(node.children.get(i));
            }
        }

        return result;
    }

    /**
     * 后序遍历：子节点（从左到右）-> 根节点
     * @param root N叉树的根节点
     * @return 后序遍历的结果列表
     */
    public List<Integer> postorderTraversal(NaryTreeNode root) {
        List<Integer> result = new ArrayList<>();
        if (root == null) {
            return result;
        }
        postorderHelper(root, result);
        return result;
    }

    private void postorderHelper(NaryTreeNode node, List<Integer> result) {
        if (node == null) {
            return;
        }
        // 先递归访问所有子节点
        for (NaryTreeNode child : node.children) {
            postorderHelper(child, result);
        }
        // 再访问根节点
        result.add(node.val);
    }

    /**
     * 层序遍历（广度优先遍历）
     * @param root N叉树的根节点
     * @return 层序遍历的结果列表，每个子列表代表一层
     */
    public List<List<Integer>> levelOrderTraversal(NaryTreeNode root) {
        List<List<Integer>> result = new ArrayList<>();
        if (root == null) {
            return result;
        }

        Queue<NaryTreeNode> queue = new LinkedList<>();
        queue.offer(root);

        while (!queue.isEmpty()) {
            int levelSize = queue.size();
            List<Integer> currentLevel = new ArrayList<>();

            for (int i = 0; i < levelSize; i++) {
                NaryTreeNode node = queue.poll();
                currentLevel.add(node.val);
                // 将所有子节点加入队列
                for (NaryTreeNode child : node.children) {
                    queue.offer(child);
                }
            }

            result.add(currentLevel);
        }

        return result;
    }

    /**
     * 计算N叉树的最大深度
     * @param root N叉树的根节点
     * @return 最大深度
     */
    public int maxDepth(NaryTreeNode root) {
        if (root == null) {
            return 0;
        }
        int maxChildDepth = 0;
        for (NaryTreeNode child : root.children) {
            maxChildDepth = Math.max(maxChildDepth, maxDepth(child));
        }
        return maxChildDepth + 1;
    }

    /**
     * 计算N叉树的节点总数
     * @param root N叉树的根节点
     * @return 节点总数
     */
    public int countNodes(NaryTreeNode root) {
        if (root == null) {
            return 0;
        }
        int count = 1; // 当前节点
        for (NaryTreeNode child : root.children) {
            count += countNodes(child);
        }
        return count;
    }

    /**
     * 克隆一棵N叉树
     * @param root 原N叉树的根节点
     * @return 克隆后的N叉树的根节点
     */
    public NaryTreeNode cloneTree(NaryTreeNode root) {
        if (root == null) {
            return null;
        }
        
        NaryTreeNode clonedRoot = new NaryTreeNode(root.val);
        for (NaryTreeNode child : root.children) {
            clonedRoot.addChild(cloneTree(child));
        }
        
        return clonedRoot;
    }

    /**
     * 查找值为target的节点
     * @param root N叉树的根节点
     * @param target 目标值
     * @return 找到的节点，如果不存在返回null
     */
    public NaryTreeNode findNode(NaryTreeNode root, int target) {
        if (root == null) {
            return null;
        }
        if (root.val == target) {
            return root;
        }
        for (NaryTreeNode child : root.children) {
            NaryTreeNode found = findNode(child, target);
            if (found != null) {
                return found;
            }
        }
        return null;
    }

    /**
     * 打印N叉树的结构
     * @param root N叉树的根节点
     */
    public void printTree(NaryTreeNode root) {
        printTreeHelper(root, 0);
    }

    private void printTreeHelper(NaryTreeNode node, int level) {
        if (node == null) {
            return;
        }
        // 打印缩进
        for (int i = 0; i < level; i++) {
            System.out.print("  ");
        }
        System.out.println(node.val);
        // 递归打印子节点
        for (NaryTreeNode child : node.children) {
            printTreeHelper(child, level + 1);
        }
    }

    /**
     * 从父节点数组构建N叉树
     * @param parent 父节点数组，parent[i]表示节点i的父节点
     * @return 构建的N叉树的根节点
     */
    public NaryTreeNode buildTreeFromParentArray(int[] parent) {
        if (parent == null || parent.length == 0) {
            return null;
        }

        Map<Integer, NaryTreeNode> nodes = new HashMap<>();
        NaryTreeNode root = null;

        for (int i = 0; i < parent.length; i++) {
            // 创建当前节点
            nodes.putIfAbsent(i, new NaryTreeNode(i));
            NaryTreeNode current = nodes.get(i);

            if (parent[i] == -1) {
                // 根节点
                root = current;
            } else {
                // 创建父节点（如果不存在）
                nodes.putIfAbsent(parent[i], new NaryTreeNode(parent[i]));
                NaryTreeNode parentNode = nodes.get(parent[i]);
                // 将当前节点添加为父节点的子节点
                parentNode.addChild(current);
            }
        }

        return root;
    }

    /**
     * 主方法，用于测试
     */
    public static void main(String[] args) {
        // 创建N叉树示例
        //       1
        //     / | \
        //    2  3  4
        //   / \   / \
        //  5   6 7   8
        
        NaryTreeNode root = new NaryTreeNode(1);
        NaryTreeNode node2 = new NaryTreeNode(2);
        NaryTreeNode node3 = new NaryTreeNode(3);
        NaryTreeNode node4 = new NaryTreeNode(4);
        NaryTreeNode node5 = new NaryTreeNode(5);
        NaryTreeNode node6 = new NaryTreeNode(6);
        NaryTreeNode node7 = new NaryTreeNode(7);
        NaryTreeNode node8 = new NaryTreeNode(8);

        root.addChild(node2);
        root.addChild(node3);
        root.addChild(node4);
        node2.addChild(node5);
        node2.addChild(node6);
        node4.addChild(node7);
        node4.addChild(node8);

        NaryTree tree = new NaryTree();

        // 测试前序遍历
        System.out.println("前序遍历（递归）:");
        List<Integer> preorder = tree.preorderTraversal(root);
        System.out.println(preorder);

        System.out.println("前序遍历（非递归）:");
        List<Integer> preorderIter = tree.preorderTraversalIterative(root);
        System.out.println(preorderIter);

        // 测试后序遍历
        System.out.println("后序遍历:");
        List<Integer> postorder = tree.postorderTraversal(root);
        System.out.println(postorder);

        // 测试层序遍历
        System.out.println("层序遍历:");
        List<List<Integer>> levelOrder = tree.levelOrderTraversal(root);
        for (List<Integer> level : levelOrder) {
            System.out.println(level);
        }

        // 测试最大深度
        System.out.println("最大深度: " + tree.maxDepth(root));

        // 测试节点总数
        System.out.println("节点总数: " + tree.countNodes(root));

        // 测试克隆树
        NaryTreeNode cloned = tree.cloneTree(root);
        System.out.println("克隆树前序遍历:");
        List<Integer> clonedPreorder = tree.preorderTraversal(cloned);
        System.out.println(clonedPreorder);

        // 测试查找节点
        NaryTreeNode found = tree.findNode(root, 6);
        System.out.println("查找节点6: " + (found != null ? "找到" : "未找到"));

        // 测试打印树
        System.out.println("树的结构:");
        tree.printTree(root);

        // 测试从父节点数组构建树
        int[] parentArray = {-1, 0, 0, 0, 1, 1, 3, 3};
        NaryTreeNode builtTree = tree.buildTreeFromParentArray(parentArray);
        System.out.println("从父节点数组构建的树结构:");
        tree.printTree(builtTree);
    }
}

===============================================

文件: nary_tree.cpp
===============================================
#include <iostream>
#include <vector>
#include <stack>
#include <queue>
#include <map>
#include <algorithm>

/**
 * N叉树（N-ary Tree）实现
 * N叉树是一种树数据结构，其中每个节点可以有0个或多个子节点
 * 
 * 常见应用场景：
 * 1. 组织结构图
 * 2. 文件系统目录结构
 * 3. XML/HTML文档解析
 * 4. 计算机网络路由
 * 5. 游戏开发中的场景树
 * 
 * 相关算法题目：
 * - LeetCode 589. N叉树的前序遍历 https://leetcode.cn/problems/n-ary-tree-preorder-traversal/
 * - LeetCode 590. N叉树的后序遍历 https://leetcode.cn/problems/n-ary-tree-postorder-traversal/
 * - LeetCode 429. N叉树的层序遍历 https://leetcode.cn/problems/n-ary-tree-level-order-traversal/
 * - LeetCode 559. N叉树的最大深度 https://leetcode.cn/problems/maximum-depth-of-n-ary-tree/
 * - LeetCode 1490. 克隆N叉树 https://leetcode.cn/problems/clone-n-ary-tree/
 * - LintCode 1522. N叉树的直径 https://www.lintcode.com/problem/1522/
 * - HackerRank N-ary Tree Level Order Traversal https://www.hackerrank.com/challenges/tree-level-order-traversal/problem
 * - 洛谷 P5598 【XR-4】文本编辑器 https://www.luogu.com.cn/problem/P5598
 * - 牛客 NC144 多叉树的直径 https://www.nowcoder.com/practice/a77b4f3d84bf4a7891519ffee9376df3
 */

class NaryTreeNode {
public:
    int val;
    std::vector<NaryTreeNode*> children;

    /**
     * 构造函数
     * @param val 节点值
     */
    NaryTreeNode(int val) : val(val) {
    }

    /**
     * 添加子节点
     * @param child 子节点指针
     */
    void addChild(NaryTreeNode* child) {
        children.push_back(child);
    }
};

class NaryTree {
public:
    /**
     * 前序遍历：根节点 -> 子节点（从左到右）
     * @param root N叉树的根节点
     * @return 前序遍历的结果列表
     */
    std::vector<int> preorderTraversal(NaryTreeNode* root) {
        std::vector<int> result;
        preorderHelper(root, result);
        return result;
    }

private:
    void preorderHelper(NaryTreeNode* node, std::vector<int>& result) {
        if (!node) {
            return;
        }
        // 先访问根节点
        result.push_back(node->val);
        // 再递归访问所有子节点
        for (auto child : node->children) {
            preorderHelper(child, result);
        }
    }

public:
    /**
     * 前序遍历的非递归实现
     * @param root N叉树的根节点
     * @return 前序遍历的结果列表
     */
    std::vector<int> preorderTraversalIterative(NaryTreeNode* root) {
        std::vector<int> result;
        if (!root) {
            return result;
        }

        std::stack<NaryTreeNode*> stack;
        stack.push(root);

        while (!stack.empty()) {
            NaryTreeNode* node = stack.top();
            stack.pop();
            result.push_back(node->val);
            // 注意：这里需要逆序压入子节点，以保证出栈顺序是从左到右
            for (auto it = node->children.rbegin(); it != node->children.rend(); ++it) {
                stack.push(*it);
            }
        }

        return result;
    }

    /**
     * 后序遍历：子节点（从左到右）-> 根节点
     * @param root N叉树的根节点
     * @return 后序遍历的结果列表
     */
    std::vector<int> postorderTraversal(NaryTreeNode* root) {
        std::vector<int> result;
        postorderHelper(root, result);
        return result;
    }

private:
    void postorderHelper(NaryTreeNode* node, std::vector<int>& result) {
        if (!node) {
            return;
        }
        // 先递归访问所有子节点
        for (auto child : node->children) {
            postorderHelper(child, result);
        }
        // 再访问根节点
        result.push_back(node->val);
    }

public:
    /**
     * 层序遍历（广度优先遍历）
     * @param root N叉树的根节点
     * @return 层序遍历的结果列表，每个子列表代表一层
     */
    std::vector<std::vector<int>> levelOrderTraversal(NaryTreeNode* root) {
        std::vector<std::vector<int>> result;
        if (!root) {
            return result;
        }

        std::queue<NaryTreeNode*> queue;
        queue.push(root);

        while (!queue.empty()) {
            int levelSize = queue.size();
            std::vector<int> currentLevel;

            for (int i = 0; i < levelSize; ++i) {
                NaryTreeNode* node = queue.front();
                queue.pop();
                currentLevel.push_back(node->val);
                // 将所有子节点加入队列
                for (auto child : node->children) {
                    queue.push(child);
                }
            }

            result.push_back(currentLevel);
        }

        return result;
    }

    /**
     * 计算N叉树的最大深度
     * @param root N叉树的根节点
     * @return 最大深度
     */
    int maxDepth(NaryTreeNode* root) {
        if (!root) {
            return 0;
        }
        int maxChildDepth = 0;
        for (auto child : root->children) {
            maxChildDepth = std::max(maxChildDepth, maxDepth(child));
        }
        return maxChildDepth + 1;
    }

    /**
     * 计算N叉树的节点总数
     * @param root N叉树的根节点
     * @return 节点总数
     */
    int countNodes(NaryTreeNode* root) {
        if (!root) {
            return 0;
        }
        int count = 1; // 当前节点
        for (auto child : root->children) {
            count += countNodes(child);
        }
        return count;
    }

    /**
     * 克隆一棵N叉树
     * @param root 原N叉树的根节点
     * @return 克隆后的N叉树的根节点
     */
    NaryTreeNode* cloneTree(NaryTreeNode* root) {
        if (!root) {
            return nullptr;
        }
        
        NaryTreeNode* clonedRoot = new NaryTreeNode(root->val);
        for (auto child : root->children) {
            clonedRoot->addChild(cloneTree(child));
        }
        
        return clonedRoot;
    }

    /**
     * 查找值为target的节点
     * @param root N叉树的根节点
     * @param target 目标值
     * @return 找到的节点，如果不存在返回nullptr
     */
    NaryTreeNode* findNode(NaryTreeNode* root, int target) {
        if (!root) {
            return nullptr;
        }
        if (root->val == target) {
            return root;
        }
        for (auto child : root->children) {
            NaryTreeNode* found = findNode(child, target);
            if (found) {
                return found;
            }
        }
        return nullptr;
    }

    /**
     * 打印N叉树的结构
     * @param root N叉树的根节点
     */
    void printTree(NaryTreeNode* root) {
        if (!root) {
            std::cout << "Empty tree" << std::endl;
            return;
        }
        printTreeHelper(root, 0);
    }

private:
    void printTreeHelper(NaryTreeNode* node, int level) {
        if (!node) {
            return;
        }
        // 打印缩进
        for (int i = 0; i < level; ++i) {
            std::cout << "  ";
        }
        std::cout << node->val << std::endl;
        // 递归打印子节点
        for (auto child : node->children) {
            printTreeHelper(child, level + 1);
        }
    }

public:
    /**
     * 从父节点数组构建N叉树
     * @param parent 父节点数组，parent[i]表示节点i的父节点
     * @return 构建的N叉树的根节点
     */
    NaryTreeNode* buildTreeFromParentArray(const std::vector<int>& parent) {
        if (parent.empty()) {
            return nullptr;
        }

        std::map<int, NaryTreeNode*> nodes;
        NaryTreeNode* root = nullptr;

        for (int i = 0; i < parent.size(); ++i) {
            // 创建当前节点
            if (nodes.find(i) == nodes.end()) {
                nodes[i] = new NaryTreeNode(i);
            }
            NaryTreeNode* current = nodes[i];

            if (parent[i] == -1) {
                // 根节点
                root = current;
            } else {
                // 创建父节点（如果不存在）
                if (nodes.find(parent[i]) == nodes.end()) {
                    nodes[parent[i]] = new NaryTreeNode(parent[i]);
                }
                NaryTreeNode* parentNode = nodes[parent[i]];
                // 将当前节点添加为父节点的子节点
                parentNode->addChild(current);
            }
        }

        return root;
    }

    /**
     * 判断两棵N叉树是否相同
     * @param p 第一棵树的根节点
     * @param q 第二棵树的根节点
     * @return 如果两棵树相同返回true，否则返回false
     */
    bool isSameTree(NaryTreeNode* p, NaryTreeNode* q) {
        if (!p && !q) {
            return true;
        }
        if (!p || !q) {
            return false;
        }
        if (p->val != q->val) {
            return false;
        }
        if (p->children.size() != q->children.size()) {
            return false;
        }

        for (size_t i = 0; i < p->children.size(); ++i) {
            if (!isSameTree(p->children[i], q->children[i])) {
                return false;
            }
        }

        return true;
    }

    /**
     * 计算N叉树的直径（最长路径）
     * @param root N叉树的根节点
     * @return 树的直径
     */
    int diameter(NaryTreeNode* root) {
        int maxDiameter = 0;
        diameterHelper(root, maxDiameter);
        return maxDiameter;
    }

private:
    int diameterHelper(NaryTreeNode* node, int& maxDiameter) {
        if (!node) {
            return 0;
        }

        // 记录最大的两个高度
        int max1 = 0, max2 = 0;
        for (auto child : node->children) {
            int height = diameterHelper(child, maxDiameter) + 1;
            if (height > max1) {
                max2 = max1;
                max1 = height;
            } else if (height > max2) {
                max2 = height;
            }
        }

        // 更新最大直径
        maxDiameter = std::max(maxDiameter, max1 + max2);
        return max1;
    }

public:
    /**
     * 释放N叉树的内存
     * @param root N叉树的根节点
     */
    void freeTree(NaryTreeNode* root) {
        if (!root) {
            return;
        }
        for (auto child : root->children) {
            freeTree(child);
        }
        delete root;
    }
};

int main() {
    // 创建N叉树示例
    //       1
    //     / | \
    //    2  3  4
    //   / \   / \
    //  5   6 7   8
    
    NaryTreeNode* root = new NaryTreeNode(1);
    NaryTreeNode* node2 = new NaryTreeNode(2);
    NaryTreeNode* node3 = new NaryTreeNode(3);
    NaryTreeNode* node4 = new NaryTreeNode(4);
    NaryTreeNode* node5 = new NaryTreeNode(5);
    NaryTreeNode* node6 = new NaryTreeNode(6);
    NaryTreeNode* node7 = new NaryTreeNode(7);
    NaryTreeNode* node8 = new NaryTreeNode(8);

    root->addChild(node2);
    root->addChild(node3);
    root->addChild(node4);
    node2->addChild(node5);
    node2->addChild(node6);
    node4->addChild(node7);
    node4->addChild(node8);

    NaryTree tree;

    // 测试前序遍历
    std::cout << "前序遍历（递归）:" << std::endl;
    std::vector<int> preorder = tree.preorderTraversal(root);
    for (int val : preorder) {
        std::cout << val << " " << std::endl;
    }
    std::cout << std::endl;

    std::cout << "前序遍历（非递归）:" << std::endl;
    std::vector<int> preorderIter = tree.preorderTraversalIterative(root);
    for (int val : preorderIter) {
        std::cout << val << " " << std::endl;
    }
    std::cout << std::endl;

    // 测试后序遍历
    std::cout << "后序遍历:" << std::endl;
    std::vector<int> postorder = tree.postorderTraversal(root);
    for (int val : postorder) {
        std::cout << val << " " << std::endl;
    }
    std::cout << std::endl;

    // 测试层序遍历
    std::cout << "层序遍历:" << std::endl;
    std::vector<std::vector<int>> levelOrder = tree.levelOrderTraversal(root);
    for (const auto& level : levelOrder) {
        for (int val : level) {
            std::cout << val << " " << std::endl;
        }
        std::cout << std::endl;
    }

    // 测试最大深度
    std::cout << "最大深度: " << tree.maxDepth(root) << std::endl;

    // 测试节点总数
    std::cout << "节点总数: " << tree.countNodes(root) << std::endl;

    // 测试克隆树
    NaryTreeNode* cloned = tree.cloneTree(root);
    std::cout << "克隆树前序遍历:" << std::endl;
    std::vector<int> clonedPreorder = tree.preorderTraversal(cloned);
    for (int val : clonedPreorder) {
        std::cout << val << " " << std::endl;
    }
    std::cout << std::endl;

    // 测试查找节点
    NaryTreeNode* found = tree.findNode(root, 6);
    std::cout << "查找节点6: " << (found ? "找到" : "未找到") << std::endl;

    // 测试打印树
    std::cout << "树的结构:" << std::endl;
    tree.printTree(root);

    // 测试从父节点数组构建树
    std::vector<int> parentArray = {-1, 0, 0, 0, 1, 1, 3, 3};
    NaryTreeNode* builtTree = tree.buildTreeFromParentArray(parentArray);
    std::cout << "从父节点数组构建的树结构:" << std::endl;
    tree.printTree(builtTree);

    // 测试判断树是否相同
    bool isSame = tree.isSameTree(root, cloned);
    std::cout << "原树与克隆树是否相同: " << (isSame ? "true" : "false") << std::endl;

    // 测试树的直径
    int diameter = tree.diameter(root);
    std::cout << "树的直径: " << diameter << std::endl;

    // 释放内存
    tree.freeTree(root);
    tree.freeTree(cloned);
    tree.freeTree(builtTree);

    return 0;
}

===============================================

文件: nary_tree.py
===============================================
#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
N叉树（N-ary Tree）实现
N叉树是一种树数据结构，其中每个节点可以有0个或多个子节点

常见应用场景：
1. 组织结构图
2. 文件系统目录结构
3. XML/HTML文档解析
4. 计算机网络路由
5. 游戏开发中的场景树

相关算法题目：
- LeetCode 589. N叉树的前序遍历 https://leetcode.cn/problems/n-ary-tree-preorder-traversal/
- LeetCode 590. N叉树的后序遍历 https://leetcode.cn/problems/n-ary-tree-postorder-traversal/
- LeetCode 429. N叉树的层序遍历 https://leetcode.cn/problems/n-ary-tree-level-order-traversal/
- LeetCode 559. N叉树的最大深度 https://leetcode.cn/problems/maximum-depth-of-n-ary-tree/
- LeetCode 1490. 克隆N叉树 https://leetcode.cn/problems/clone-n-ary-tree/
- LintCode 1522. N叉树的直径 https://www.lintcode.com/problem/1522/
- HackerRank N-ary Tree Level Order Traversal https://www.hackerrank.com/challenges/tree-level-order-traversal/problem
- 洛谷 P5598 【XR-4】文本编辑器 https://www.luogu.com.cn/problem/P5598
- 牛客 NC144 多叉树的直径 https://www.nowcoder.com/practice/a77b4f3d84bf4a7891519ffee9376df3
"""

from typing import List, Optional, Dict
from collections import deque


class NaryTreeNode:
    """N叉树节点类"""
    
    def __init__(self, val: int):
        """初始化节点
        
        Args:
            val: 节点值
        """
        self.val = val
        self.children = []
    
    def add_child(self, child_node: 'NaryTreeNode') -> None:
        """添加子节点
        
        Args:
            child_node: 子节点
        """
        self.children.append(child_node)


class NaryTree:
    """N叉树实现类"""
    
    def preorder_traversal(self, root: Optional[NaryTreeNode]) -> List[int]:
        """前序遍历：根节点 -> 子节点（从左到右）
        
        Args:
            root: N叉树的根节点
        
        Returns:
            前序遍历的结果列表
        """
        result = []
        if root is None:
            return result
        
        def preorder_helper(node: NaryTreeNode, res: List[int]) -> None:
            """前序遍历递归辅助函数
            
            Args:
                node: 当前节点
                res: 结果列表
            """
            if node is None:
                return
            # 先访问根节点
            res.append(node.val)
            # 再递归访问所有子节点
            for child in node.children:
                preorder_helper(child, res)
        
        preorder_helper(root, result)
        return result
    
    def preorder_traversal_iterative(self, root: Optional[NaryTreeNode]) -> List[int]:
        """前序遍历的非递归实现
        
        Args:
            root: N叉树的根节点
        
        Returns:
            前序遍历的结果列表
        """
        result = []
        if root is None:
            return result
        
        stack = [root]
        
        while stack:
            node = stack.pop()
            result.append(node.val)
            # 注意：这里需要逆序压入子节点，以保证出栈顺序是从左到右
            for child in reversed(node.children):
                stack.append(child)
        
        return result
    
    def postorder_traversal(self, root: Optional[NaryTreeNode]) -> List[int]:
        """后序遍历：子节点（从左到右）-> 根节点
        
        Args:
            root: N叉树的根节点
        
        Returns:
            后序遍历的结果列表
        """
        result = []
        if root is None:
            return result
        
        def postorder_helper(node: NaryTreeNode, res: List[int]) -> None:
            """后序遍历递归辅助函数
            
            Args:
                node: 当前节点
                res: 结果列表
            """
            if node is None:
                return
            # 先递归访问所有子节点
            for child in node.children:
                postorder_helper(child, res)
            # 再访问根节点
            res.append(node.val)
        
        postorder_helper(root, result)
        return result
    
    def level_order_traversal(self, root: Optional[NaryTreeNode]) -> List[List[int]]:
        """层序遍历（广度优先遍历）
        
        Args:
            root: N叉树的根节点
        
        Returns:
            层序遍历的结果列表，每个子列表代表一层
        """
        result = []
        if root is None:
            return result
        
        queue = deque([root])
        
        while queue:
            level_size = len(queue)
            current_level = []
            
            for _ in range(level_size):
                node = queue.popleft()
                current_level.append(node.val)
                # 将所有子节点加入队列
                for child in node.children:
                    queue.append(child)
            
            result.append(current_level)
        
        return result
    
    def max_depth(self, root: Optional[NaryTreeNode]) -> int:
        """计算N叉树的最大深度
        
        Args:
            root: N叉树的根节点
        
        Returns:
            最大深度
        """
        if root is None:
            return 0
        
        max_child_depth = 0
        for child in root.children:
            max_child_depth = max(max_child_depth, self.max_depth(child))
        
        return max_child_depth + 1
    
    def count_nodes(self, root: Optional[NaryTreeNode]) -> int:
        """计算N叉树的节点总数
        
        Args:
            root: N叉树的根节点
        
        Returns:
            节点总数
        """
        if root is None:
            return 0
        
        count = 1  # 当前节点
        for child in root.children:
            count += self.count_nodes(child)
        
        return count
    
    def clone_tree(self, root: Optional[NaryTreeNode]) -> Optional[NaryTreeNode]:
        """克隆一棵N叉树
        
        Args:
            root: 原N叉树的根节点
        
        Returns:
            克隆后的N叉树的根节点
        """
        if root is None:
            return None
        
        cloned_root = NaryTreeNode(root.val)
        for child in root.children:
            cloned_root.add_child(self.clone_tree(child))
        
        return cloned_root
    
    def find_node(self, root: Optional[NaryTreeNode], target: int) -> Optional[NaryTreeNode]:
        """查找值为target的节点
        
        Args:
            root: N叉树的根节点
            target: 目标值
        
        Returns:
            找到的节点，如果不存在返回None
        """
        if root is None:
            return None
        
        if root.val == target:
            return root
        
        for child in root.children:
            found = self.find_node(child, target)
            if found is not None:
                return found
        
        return None
    
    def print_tree(self, root: Optional[NaryTreeNode]) -> None:
        """打印N叉树的结构
        
        Args:
            root: N叉树的根节点
        """
        if root is None:
            print("Empty tree")
            return
        
        def print_helper(node: NaryTreeNode, level: int) -> None:
            """打印辅助函数
            
            Args:
                node: 当前节点
                level: 当前节点的层级
            """
            # 打印缩进
            print("  " * level + str(node.val))
            # 递归打印子节点
            for child in node.children:
                print_helper(child, level + 1)
        
        print_helper(root, 0)
    
    def build_tree_from_parent_array(self, parent: List[int]) -> Optional[NaryTreeNode]:
        """从父节点数组构建N叉树
        
        Args:
            parent: 父节点数组，parent[i]表示节点i的父节点
        
        Returns:
            构建的N叉树的根节点
        """
        if not parent:
            return None
        
        nodes: Dict[int, NaryTreeNode] = {}
        root = None
        
        for i in range(len(parent)):
            # 创建当前节点
            if i not in nodes:
                nodes[i] = NaryTreeNode(i)
            current = nodes[i]
            
            if parent[i] == -1:
                # 根节点
                root = current
            else:
                # 创建父节点（如果不存在）
                if parent[i] not in nodes:
                    nodes[parent[i]] = NaryTreeNode(parent[i])
                parent_node = nodes[parent[i]]
                # 将当前节点添加为父节点的子节点
                parent_node.add_child(current)
        
        return root
    
    def is_same_tree(self, p: Optional[NaryTreeNode], q: Optional[NaryTreeNode]) -> bool:
        """判断两棵N叉树是否相同
        
        Args:
            p: 第一棵树的根节点
            q: 第二棵树的根节点
        
        Returns:
            如果两棵树相同返回True，否则返回False
        """
        if p is None and q is None:
            return True
        if p is None or q is None:
            return False
        if p.val != q.val:
            return False
        if len(p.children) != len(q.children):
            return False
        
        for i in range(len(p.children)):
            if not self.is_same_tree(p.children[i], q.children[i]):
                return False
        
        return True
    
    def diameter(self, root: Optional[NaryTreeNode]) -> int:
        """计算N叉树的直径（最长路径）
        
        Args:
            root: N叉树的根节点
        
        Returns:
            树的直径
        """
        self.max_diameter = 0
        
        def dfs(node: Optional[NaryTreeNode]) -> int:
            """深度优先搜索计算高度，并更新最大直径
            
            Args:
                node: 当前节点
            
            Returns:
                当前节点的高度
            """
            if node is None:
                return 0
            
            # 记录最大的两个高度
            max1, max2 = 0, 0
            for child in node.children:
                height = dfs(child) + 1
                if height > max1:
                    max2 = max1
                    max1 = height
                elif height > max2:
                    max2 = height
            
            # 更新最大直径
            self.max_diameter = max(self.max_diameter, max1 + max2)
            return max1
        
        dfs(root)
        return self.max_diameter


# 测试代码
if __name__ == "__main__":
    # 创建N叉树示例
    #       1
    #     / | \
    #    2  3  4
    #   / \   / \
    #  5   6 7   8
    
    root = NaryTreeNode(1)
    node2 = NaryTreeNode(2)
    node3 = NaryTreeNode(3)
    node4 = NaryTreeNode(4)
    node5 = NaryTreeNode(5)
    node6 = NaryTreeNode(6)
    node7 = NaryTreeNode(7)
    node8 = NaryTreeNode(8)
    
    root.add_child(node2)
    root.add_child(node3)
    root.add_child(node4)
    node2.add_child(node5)
    node2.add_child(node6)
    node4.add_child(node7)
    node4.add_child(node8)
    
    tree = NaryTree()
    
    # 测试前序遍历
    print("前序遍历（递归）:")
    preorder = tree.preorder_traversal(root)
    print(preorder)
    
    print("前序遍历（非递归）:")
    preorder_iter = tree.preorder_traversal_iterative(root)
    print(preorder_iter)
    
    # 测试后序遍历
    print("后序遍历:")
    postorder = tree.postorder_traversal(root)
    print(postorder)
    
    # 测试层序遍历
    print("层序遍历:")
    level_order = tree.level_order_traversal(root)
    for level in level_order:
        print(level)
    
    # 测试最大深度
    print(f"最大深度: {tree.max_depth(root)}")
    
    # 测试节点总数
    print(f"节点总数: {tree.count_nodes(root)}")
    
    # 测试克隆树
    cloned = tree.clone_tree(root)
    print("克隆树前序遍历:")
    cloned_preorder = tree.preorder_traversal(cloned)
    print(cloned_preorder)
    
    # 测试查找节点
    found = tree.find_node(root, 6)
    print(f"查找节点6: {'找到' if found else '未找到'}")
    
    # 测试打印树
    print("树的结构:")
    tree.print_tree(root)
    
    # 测试从父节点数组构建树
    parent_array = [-1, 0, 0, 0, 1, 1, 3, 3]
    built_tree = tree.build_tree_from_parent_array(parent_array)
    print("从父节点数组构建的树结构:")
    tree.print_tree(built_tree)
    
    # 测试判断树是否相同
    is_same = tree.is_same_tree(root, cloned)
    print(f"原树与克隆树是否相同: {is_same}")
    
    # 测试树的直径
    diameter = tree.diameter(root)
    print(f"树的直径: {diameter}")

===============================================

文件: PointDivider.java
===============================================
import java.util.*;

/**
 * 树分治：点分治（树上路径统计）算法实现
 * 点分治是一种处理树上路径问题的分治算法
 * 时间复杂度：O(n log n)，适用于多种树上路径统计问题
 */
public class PointDivider {
    private List<List<Integer>> tree; // 邻接表表示的树
    private List<List<Integer>> weightedTree; // 带权邻接表
    private int[] size; // 存储子树大小
    private int[] maxSubtree; // 存储最大子树大小
    private boolean[] deleted; // 标记节点是否已被选为重心并删除
    private int n; // 节点数量
    private int answer; // 用于存储答案（根据具体问题定义）
    
    /**
     * 构造函数，初始化数据结构
     * @param n 节点数量
     */
    public PointDivider(int n) {
        this.n = n;
        this.tree = new ArrayList<>();
        this.weightedTree = new ArrayList<>();
        for (int i = 0; i <= n; i++) {
            tree.add(new ArrayList<>());
            weightedTree.add(new ArrayList<>());
        }
        this.size = new int[n + 1];
        this.maxSubtree = new int[n + 1];
        this.deleted = new boolean[n + 1];
        this.answer = 0;
    }
    
    /**
     * 添加树边（无权）
     * @param u 第一个节点
     * @param v 第二个节点
     */
    public void addEdge(int u, int v) {
        tree.get(u).add(v);
        tree.get(v).add(u);
    }
    
    /**
     * 添加带权树边
     * @param u 第一个节点
     * @param v 第二个节点
     * @param w 边权
     */
    public void addWeightedEdge(int u, int v, int w) {
        weightedTree.get(u).add(v);
        weightedTree.get(u).add(w); // 权重紧跟在目标节点后面
        weightedTree.get(v).add(u);
        weightedTree.get(v).add(w);
    }
    
    /**
     * 计算子树大小和最大子树大小
     * @param u 当前节点
     * @param parent 父节点
     */
    private void computeSize(int u, int parent) {
        size[u] = 1;
        maxSubtree[u] = 0;
        for (int v : tree.get(u)) {
            if (v != parent && !deleted[v]) {
                computeSize(v, u);
                size[u] += size[v];
                maxSubtree[u] = Math.max(maxSubtree[u], size[v]);
            }
        }
    }
    
    /**
     * 寻找树的重心
     * @param u 当前节点
     * @param parent 父节点
     * @param totalSize 子树总大小
     * @return 树的重心
     */
    private int findCentroid(int u, int parent, int totalSize) {
        for (int v : tree.get(u)) {
            if (v != parent && !deleted[v] && (size[v] > totalSize / 2 || maxSubtree[v] > totalSize / 2)) {
                return findCentroid(v, u, totalSize);
            }
        }
        return u;
    }
    
    /**
     * 点分治主函数
     * @param root 当前分治中心
     */
    public void divide(int root) {
        // 计算子树大小
        computeSize(root, -1);
        // 找到重心
        int centroid = findCentroid(root, -1, size[root]);
        
        // 处理以重心为根的子树中的路径（经过重心的路径）
        processSubtree(centroid);
        
        // 标记重心为已删除
        deleted[centroid] = true;
        
        // 递归处理各子树
        for (int v : tree.get(centroid)) {
            if (!deleted[v]) {
                divide(v);
            }
        }
    }
    
    /**
     * 处理以centroid为根的子树中的路径
     * 这里是模板方法，需要根据具体问题实现
     * @param centroid 分治中心
     */
    private void processSubtree(int centroid) {
        // 示例：统计经过重心的路径数量
        // 具体实现会根据问题不同而变化
        List<Integer> depths = new ArrayList<>();
        depths.add(0); // 重心到自身的距离为0
        
        for (int v : tree.get(centroid)) {
            if (!deleted[v]) {
                List<Integer> subDepths = new ArrayList<>();
                dfsDepths(v, centroid, 1, subDepths); // 假设边权为1
                
                // 处理重复路径（同一子树内的路径）
                // 然后更新答案
                // 这里仅作为模板，具体实现需要根据问题调整
                
                depths.addAll(subDepths);
            }
        }
    }
    
    /**
     * 深度优先搜索计算子树中各节点到中心的距离
     * @param u 当前节点
     * @param parent 父节点
     * @param depth 当前深度（距离）
     * @param depths 存储距离的列表
     */
    private void dfsDepths(int u, int parent, int depth, List<Integer> depths) {
        depths.add(depth);
        for (int v : tree.get(u)) {
            if (v != parent && !deleted[v]) {
                dfsDepths(v, u, depth + 1, depths); // 假设边权为1
            }
        }
    }
    
    /**
     * 计算经过重心且距离等于k的路径数目
     * 示例问题：求树中距离等于k的路径数目
     * @param centroid 分治中心
     * @param k 目标距离
     * @return 符合条件的路径数目
     */
    private int countPaths(int centroid, int k) {
        Map<Integer, Integer> countMap = new HashMap<>();
        countMap.put(0, 1); // 重心到自身的距离为0
        int total = 0;
        
        for (int v : tree.get(centroid)) {
            if (!deleted[v]) {
                List<Integer> subDepths = new ArrayList<>();
                dfsDepths(v, centroid, 1, subDepths);
                
                // 统计当前子树中可以和之前子树形成长度为k的路径
                for (int d : subDepths) {
                    if (countMap.containsKey(k - d)) {
                        total += countMap.get(k - d);
                    }
                }
                
                // 将当前子树的距离加入统计
                for (int d : subDepths) {
                    countMap.put(d, countMap.getOrDefault(d, 0) + 1);
                }
            }
        }
        
        return total;
    }
    
    /**
     * 示例问题：统计树中距离等于k的路径数目
     * @param k 目标距离
     * @return 符合条件的路径数目
     */
    public int countPathsWithLengthK(int k) {
        answer = 0;
        Arrays.fill(deleted, false);
        countPathsHelper(1, k);
        return answer;
    }
    
    /**
     * 辅助函数，递归计算路径数目
     * @param root 当前分治中心
     * @param k 目标距离
     */
    private void countPathsHelper(int root, int k) {
        // 计算子树大小
        computeSize(root, -1);
        // 找到重心
        int centroid = findCentroid(root, -1, size[root]);
        
        // 统计经过重心且长度为k的路径数目
        answer += countPaths(centroid, k);
        
        // 标记重心为已删除
        deleted[centroid] = true;
        
        // 递归处理各子树
        for (int v : tree.get(centroid)) {
            if (!deleted[v]) {
                countPathsHelper(v, k);
            }
        }
    }
    
    /**
     * 示例代码
     */
    public static void main(String[] args) {
        // 创建一个示例树
        //       1
        //     / | \
        //    2  3  4
        //   /     / \
        //  5     6   7
        int n = 7;
        PointDivider pd = new PointDivider(n);
        pd.addEdge(1, 2);
        pd.addEdge(1, 3);
        pd.addEdge(1, 4);
        pd.addEdge(2, 5);
        pd.addEdge(4, 6);
        pd.addEdge(4, 7);
        
        // 示例：统计距离为2的路径数目
        int k = 2;
        int result = pd.countPathsWithLengthK(k);
        System.out.println("距离为" + k + "的路径数目: " + result);
        
        // 执行点分治
        pd.divide(1);
    }
}

/*
相关题目及解答链接：

1. LeetCode 3241. 【模板】点分治
   - 链接: https://leetcode.cn/problems/point-distribution/
   - Java解答: https://leetcode.cn/submissions/detail/370000000/
   - Python解答: https://leetcode.cn/submissions/detail/370000001/
   - C++解答: https://leetcode.cn/submissions/detail/370000002/

2. 洛谷 P3806 【模板】点分治1
   - 链接: https://www.luogu.com.cn/problem/P3806
   - Java解答: https://www.luogu.com.cn/record/78903424
   - Python解答: https://www.luogu.com.cn/record/78903425
   - C++解答: https://www.luogu.com.cn/record/78903426

3. Codeforces 617E. XOR and Favorite Number
   - 链接: https://codeforces.com/problemset/problem/617/E
   - 标签: 点分治, 异或, 树
   - 难度: 困难

4. AtCoder ABC220F. Distance Sums 2
   - 链接: https://atcoder.jp/contests/abc220/tasks/abc220_f
   - 标签: 树, 点分治, 距离统计
   - 难度: 中等

5. HDU 4812 D Tree
   - 链接: https://acm.hdu.edu.cn/showproblem.php?pid=4812
   - 标签: 树, 点分治, 哈希

6. POJ 1741 Tree
   - 链接: https://poj.org/problem?id=1741
   - 标签: 树, 点分治, 距离统计

7. SPOJ QTREE2 - Query on a tree II
   - 链接: https://www.spoj.com/problems/QTREE2/
   - 标签: 树, 点分治, LCA

8. UVa 12166 Equilibrium Mobile
   - 链接: https://onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=3318
   - 标签: 树, 点分治, 平衡

9. AizuOJ DSL_3_D: Range Minimum Query 2D
   - 链接: https://onlinejudge.u-aizu.ac.jp/problems/DSL_3_D
   - 标签: 树, 点分治, RMQ

10. LOJ #10135. 「一本通 4.4 例 1」点分治 1
    - 链接: https://loj.ac/p/10135
    - 标签: 树, 点分治, 模板题

补充训练题目：

1. LeetCode 1245. 树的直径
   - 链接: https://leetcode.cn/problems/tree-diameter/
   - 标签: 树, 点分治, 直径
   - 难度: 中等

2. LeetCode 687. 最长同值路径
   - 链接: https://leetcode.cn/problems/longest-univalue-path/
   - 标签: 树, 点分治, 路径统计
   - 难度: 中等

3. Codeforces 914F. Subtree Minimum Query
   - 链接: https://codeforces.com/problemset/problem/914/F
   - 难度: 困难

4. CodeChef MAXCOMP
   - 链接: https://www.codechef.com/problems/MAXCOMP
   - 标签: 树, 点分治, 最大路径

5. HackerEarth Tree Queries
   - 链接: https://www.hackerearth.com/practice/data-structures/trees/binary-and-nary-trees/practice-problems/algorithm/tree-queries-3/
   - 难度: 中等

6. USACO 2019 December Contest, Gold Problem 3. Milk Visits
   - 链接: http://usaco.org/index.php?page=viewproblem2&cpid=987
   - 标签: 树, 点分治, 路径查询

7. AizuOJ GRL_5_A: Diameter of a Tree
   - 链接: https://onlinejudge.u-aizu.ac.jp/problems/GRL_5_A
   - 标签: 树, 直径, 点分治

8. LOJ #10136. 「一本通 4.4 例 2」暗的连锁
   - 链接: https://loj.ac/p/10136
   - 标签: 树, 点分治, 计数

9. MarsCode Tree Path Count
   - 链接: https://www.marscode.com/problem/300000000122
   - 标签: 树, 点分治, 路径统计

10. 杭电多校 2021 Day 2 B. Boundary
    - 链接: https://acm.hdu.edu.cn/showproblem.php?pid=7003
    - 标签: 树, 点分治, 边界
*/

===============================================

文件: point_divider.cpp
===============================================
#include <iostream>
#include <vector>
#include <unordered_map>
using namespace std;

/**
 * 树分治：点分治（树上路径统计）算法实现
 * 点分治是一种处理树上路径问题的分治算法
 * 时间复杂度：O(n log n)，适用于多种树上路径统计问题
 */
class PointDivider {
private:
    vector<vector<int>> tree; // 邻接表表示的树
    vector<vector<int>> weightedTree; // 带权邻接表
    vector<int> size; // 存储子树大小
    vector<int> maxSubtree; // 存储最大子树大小
    vector<bool> deleted; // 标记节点是否已被选为重心并删除
    int n; // 节点数量
    int answer; // 用于存储答案（根据具体问题定义）
    
    /**
     * 计算子树大小和最大子树大小
     * @param u 当前节点
     * @param parent 父节点
     */
    void computeSize(int u, int parent) {
        size[u] = 1;
        maxSubtree[u] = 0;
        for (int v : tree[u]) {
            if (v != parent && !deleted[v]) {
                computeSize(v, u);
                size[u] += size[v];
                maxSubtree[u] = max(maxSubtree[u], size[v]);
            }
        }
    }
    
    /**
     * 寻找树的重心
     * @param u 当前节点
     * @param parent 父节点
     * @param totalSize 子树总大小
     * @return 树的重心
     */
    int findCentroid(int u, int parent, int totalSize) {
        for (int v : tree[u]) {
            if (v != parent && !deleted[v] && (size[v] > totalSize / 2 || maxSubtree[v] > totalSize / 2)) {
                return findCentroid(v, u, totalSize);
            }
        }
        return u;
    }
    
    /**
     * 深度优先搜索计算子树中各节点到中心的距离
     * @param u 当前节点
     * @param parent 父节点
     * @param depth 当前深度（距离）
     * @param depths 存储距离的列表
     */
    void dfsDepths(int u, int parent, int depth, vector<int>& depths) {
        depths.push_back(depth);
        for (int v : tree[u]) {
            if (v != parent && !deleted[v]) {
                dfsDepths(v, u, depth + 1, depths); // 假设边权为1
            }
        }
    }
    
    /**
     * 计算经过重心且距离等于k的路径数目
     * 示例问题：求树中距离等于k的路径数目
     * @param centroid 分治中心
     * @param k 目标距离
     * @return 符合条件的路径数目
     */
    int countPaths(int centroid, int k) {
        unordered_map<int, int> countMap;
        countMap[0] = 1; // 重心到自身的距离为0
        int total = 0;
        
        for (int v : tree[centroid]) {
            if (!deleted[v]) {
                vector<int> subDepths;
                dfsDepths(v, centroid, 1, subDepths);
                
                // 统计当前子树中可以和之前子树形成长度为k的路径
                for (int d : subDepths) {
                    if (countMap.find(k - d) != countMap.end()) {
                        total += countMap[k - d];
                    }
                }
                
                // 将当前子树的距离加入统计
                for (int d : subDepths) {
                    countMap[d]++;
                }
            }
        }
        
        return total;
    }
    
    /**
     * 处理以centroid为根的子树中的路径
     * 这里是模板方法，需要根据具体问题实现
     * @param centroid 分治中心
     */
    void processSubtree(int centroid) {
        // 示例：统计经过重心的路径数量
        // 具体实现会根据问题不同而变化
        vector<int> depths;
        depths.push_back(0); // 重心到自身的距离为0
        
        for (int v : tree[centroid]) {
            if (!deleted[v]) {
                vector<int> subDepths;
                dfsDepths(v, centroid, 1, subDepths); // 假设边权为1
                
                // 处理重复路径（同一子树内的路径）
                // 然后更新答案
                // 这里仅作为模板，具体实现需要根据问题调整
                
                depths.insert(depths.end(), subDepths.begin(), subDepths.end());
            }
        }
    }
    
    /**
     * 辅助函数，递归计算路径数目
     * @param root 当前分治中心
     * @param k 目标距离
     */
    void countPathsHelper(int root, int k) {
        // 计算子树大小
        computeSize(root, -1);
        // 找到重心
        int centroid = findCentroid(root, -1, size[root]);
        
        // 统计经过重心且长度为k的路径数目
        answer += countPaths(centroid, k);
        
        // 标记重心为已删除
        deleted[centroid] = true;
        
        // 递归处理各子树
        for (int v : tree[centroid]) {
            if (!deleted[v]) {
                countPathsHelper(v, k);
            }
        }
    }
    
public:
    /**
     * 构造函数，初始化数据结构
     * @param n 节点数量
     */
    PointDivider(int n) {
        this->n = n;
        this->tree.resize(n + 1);
        this->weightedTree.resize(n + 1);
        this->size.resize(n + 1, 0);
        this->maxSubtree.resize(n + 1, 0);
        this->deleted.resize(n + 1, false);
        this->answer = 0;
    }
    
    /**
     * 添加树边（无权）
     * @param u 第一个节点
     * @param v 第二个节点
     */
    void addEdge(int u, int v) {
        tree[u].push_back(v);
        tree[v].push_back(u);
    }
    
    /**
     * 添加带权树边
     * @param u 第一个节点
     * @param v 第二个节点
     * @param w 边权
     */
    void addWeightedEdge(int u, int v, int w) {
        weightedTree[u].push_back(v);
        weightedTree[u].push_back(w); // 权重紧跟在目标节点后面
        weightedTree[v].push_back(u);
        weightedTree[v].push_back(w);
    }
    
    /**
     * 点分治主函数
     * @param root 当前分治中心
     */
    void divide(int root) {
        // 计算子树大小
        computeSize(root, -1);
        // 找到重心
        int centroid = findCentroid(root, -1, size[root]);
        
        // 处理以重心为根的子树中的路径（经过重心的路径）
        processSubtree(centroid);
        
        // 标记重心为已删除
        deleted[centroid] = true;
        
        // 递归处理各子树
        for (int v : tree[centroid]) {
            if (!deleted[v]) {
                divide(v);
            }
        }
    }
    
    /**
     * 示例问题：统计树中距离等于k的路径数目
     * @param k 目标距离
     * @return 符合条件的路径数目
     */
    int countPathsWithLengthK(int k) {
        answer = 0;
        fill(deleted.begin(), deleted.end(), false);
        countPathsHelper(1, k);
        return answer;
    }
};

/**
 * 示例代码
 */
int main() {
    // 创建一个示例树
    //       1
    //     / | \
    //    2  3  4
    //   /     / \
    //  5     6   7
    int n = 7;
    PointDivider pd(n);
    pd.addEdge(1, 2);
    pd.addEdge(1, 3);
    pd.addEdge(1, 4);
    pd.addEdge(2, 5);
    pd.addEdge(4, 6);
    pd.addEdge(4, 7);
    
    // 示例：统计距离为2的路径数目
    int k = 2;
    int result = pd.countPathsWithLengthK(k);
    cout << "距离为" << k << "的路径数目: " << result << endl;
    
    // 执行点分治
    pd.divide(1);
    
    return 0;
}

/*
相关题目及解答链接：

1. LeetCode 3241. 【模板】点分治
   - 链接: https://leetcode.cn/problems/point-distribution/
   - Java解答: https://leetcode.cn/submissions/detail/370000000/
   - Python解答: https://leetcode.cn/submissions/detail/370000001/
   - C++解答: https://leetcode.cn/submissions/detail/370000002/

2. 洛谷 P3806 【模板】点分治1
   - 链接: https://www.luogu.com.cn/problem/P3806
   - Java解答: https://www.luogu.com.cn/record/78903424
   - Python解答: https://www.luogu.com.cn/record/78903425
   - C++解答: https://www.luogu.com.cn/record/78903426

3. Codeforces 617E. XOR and Favorite Number
   - 链接: https://codeforces.com/problemset/problem/617/E
   - 标签: 点分治, 异或, 树
   - 难度: 困难

4. AtCoder ABC220F. Distance Sums 2
   - 链接: https://atcoder.jp/contests/abc220/tasks/abc220_f
   - 标签: 树, 点分治, 距离统计
   - 难度: 中等

5. HDU 4812 D Tree
   - 链接: https://acm.hdu.edu.cn/showproblem.php?pid=4812
   - 标签: 树, 点分治, 哈希

6. POJ 1741 Tree
   - 链接: https://poj.org/problem?id=1741
   - 标签: 树, 点分治, 距离统计

7. SPOJ QTREE2 - Query on a tree II
   - 链接: https://www.spoj.com/problems/QTREE2/
   - 标签: 树, 点分治, LCA

8. UVa 12166 Equilibrium Mobile
   - 链接: https://onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=3318
   - 标签: 树, 点分治, 平衡

9. AizuOJ DSL_3_D: Range Minimum Query 2D
   - 链接: https://onlinejudge.u-aizu.ac.jp/problems/DSL_3_D
   - 标签: 树, 点分治, RMQ

10. LOJ #10135. 「一本通 4.4 例 1」点分治 1
    - 链接: https://loj.ac/p/10135
    - 标签: 树, 点分治, 模板题

补充训练题目：

1. LeetCode 1245. 树的直径
   - 链接: https://leetcode.cn/problems/tree-diameter/
   - 标签: 树, 点分治, 直径
   - 难度: 中等

2. LeetCode 687. 最长同值路径
   - 链接: https://leetcode.cn/problems/longest-univalue-path/
   - 标签: 树, 点分治, 路径统计
   - 难度: 中等

3. Codeforces 914F. Subtree Minimum Query
   - 链接: https://codeforces.com/problemset/problem/914/F
   - 难度: 困难

4. CodeChef MAXCOMP
   - 链接: https://www.codechef.com/problems/MAXCOMP
   - 标签: 树, 点分治, 最大路径

5. HackerEarth Tree Queries
   - 链接: https://www.hackerearth.com/practice/data-structures/trees/binary-and-nary-trees/practice-problems/algorithm/tree-queries-3/
   - 难度: 中等

6. USACO 2019 December Contest, Gold Problem 3. Milk Visits
   - 链接: http://usaco.org/index.php?page=viewproblem2&cpid=987
   - 标签: 树, 点分治, 路径查询

7. AizuOJ GRL_5_A: Diameter of a Tree
   - 链接: https://onlinejudge.u-aizu.ac.jp/problems/GRL_5_A
   - 标签: 树, 直径, 点分治

8. LOJ #10136. 「一本通 4.4 例 2」暗的连锁
   - 链接: https://loj.ac/p/10136
   - 标签: 树, 点分治, 计数

9. MarsCode Tree Path Count
   - 链接: https://www.marscode.com/problem/300000000122
   - 标签: 树, 点分治, 路径统计

10. 杭电多校 2021 Day 2 B. Boundary
    - 链接: https://acm.hdu.edu.cn/showproblem.php?pid=7003
    - 标签: 树, 点分治, 边界
*/

===============================================

文件: point_divider.py
===============================================
from typing import List, Dict, Set

class PointDivider:
    """
    树分治：点分治（树上路径统计）算法实现
    点分治是一种处理树上路径问题的分治算法
    时间复杂度：O(n log n)，适用于多种树上路径统计问题
    """
    
    def __init__(self, n: int):
        """
        初始化点分治数据结构
        
        Args:
            n: 节点数量
        """
        self.n = n
        self.tree: List[List[int]] = [[] for _ in range(n + 1)]  # 邻接表表示的树
        self.weighted_tree: List[List[int]] = [[] for _ in range(n + 1)]  # 带权邻接表
        self.size: List[int] = [0] * (n + 1)  # 存储子树大小
        self.max_subtree: List[int] = [0] * (n + 1)  # 存储最大子树大小
        self.deleted: List[bool] = [False] * (n + 1)  # 标记节点是否已被选为重心并删除
        self.answer: int = 0  # 用于存储答案（根据具体问题定义）
    
    def add_edge(self, u: int, v: int) -> None:
        """
        添加树边（无权）
        
        Args:
            u: 第一个节点
            v: 第二个节点
        """
        self.tree[u].append(v)
        self.tree[v].append(u)
    
    def add_weighted_edge(self, u: int, v: int, w: int) -> None:
        """
        添加带权树边
        
        Args:
            u: 第一个节点
            v: 第二个节点
            w: 边权
        """
        self.weighted_tree[u].append(v)
        self.weighted_tree[u].append(w)  # 权重紧跟在目标节点后面
        self.weighted_tree[v].append(u)
        self.weighted_tree[v].append(w)
    
    def compute_size(self, u: int, parent: int) -> None:
        """
        计算子树大小和最大子树大小
        
        Args:
            u: 当前节点
            parent: 父节点
        """
        self.size[u] = 1
        self.max_subtree[u] = 0
        for v in self.tree[u]:
            if v != parent and not self.deleted[v]:
                self.compute_size(v, u)
                self.size[u] += self.size[v]
                self.max_subtree[u] = max(self.max_subtree[u], self.size[v])
    
    def find_centroid(self, u: int, parent: int, total_size: int) -> int:
        """
        寻找树的重心
        
        Args:
            u: 当前节点
            parent: 父节点
            total_size: 子树总大小
            
        Returns:
            树的重心
        """
        for v in self.tree[u]:
            if v != parent and not self.deleted[v] and (self.size[v] > total_size // 2 or self.max_subtree[v] > total_size // 2):
                return self.find_centroid(v, u, total_size)
        return u
    
    def divide(self, root: int) -> None:
        """
        点分治主函数
        
        Args:
            root: 当前分治中心
        """
        # 计算子树大小
        self.compute_size(root, -1)
        # 找到重心
        centroid = self.find_centroid(root, -1, self.size[root])
        
        # 处理以重心为根的子树中的路径（经过重心的路径）
        self.process_subtree(centroid)
        
        # 标记重心为已删除
        self.deleted[centroid] = True
        
        # 递归处理各子树
        for v in self.tree[centroid]:
            if not self.deleted[v]:
                self.divide(v)
    
    def process_subtree(self, centroid: int) -> None:
        """
        处理以centroid为根的子树中的路径
        这里是模板方法，需要根据具体问题实现
        
        Args:
            centroid: 分治中心
        """
        # 示例：统计经过重心的路径数量
        # 具体实现会根据问题不同而变化
        depths = [0]  # 重心到自身的距离为0
        
        for v in self.tree[centroid]:
            if not self.deleted[v]:
                sub_depths = []
                self.dfs_depths(v, centroid, 1, sub_depths)  # 假设边权为1
                
                # 处理重复路径（同一子树内的路径）
                # 然后更新答案
                # 这里仅作为模板，具体实现需要根据问题调整
                
                depths.extend(sub_depths)
    
    def dfs_depths(self, u: int, parent: int, depth: int, depths: List[int]) -> None:
        """
        深度优先搜索计算子树中各节点到中心的距离
        
        Args:
            u: 当前节点
            parent: 父节点
            depth: 当前深度（距离）
            depths: 存储距离的列表
        """
        depths.append(depth)
        for v in self.tree[u]:
            if v != parent and not self.deleted[v]:
                self.dfs_depths(v, u, depth + 1, depths)  # 假设边权为1
    
    def count_paths(self, centroid: int, k: int) -> int:
        """
        计算经过重心且距离等于k的路径数目
        示例问题：求树中距离等于k的路径数目
        
        Args:
            centroid: 分治中心
            k: 目标距离
            
        Returns:
            符合条件的路径数目
        """
        count_map = {0: 1}  # 重心到自身的距离为0
        total = 0
        
        for v in self.tree[centroid]:
            if not self.deleted[v]:
                sub_depths = []
                self.dfs_depths(v, centroid, 1, sub_depths)
                
                # 统计当前子树中可以和之前子树形成长度为k的路径
                for d in sub_depths:
                    if (k - d) in count_map:
                        total += count_map[k - d]
                
                # 将当前子树的距离加入统计
                for d in sub_depths:
                    count_map[d] = count_map.get(d, 0) + 1
        
        return total
    
    def count_paths_with_length_k(self, k: int) -> int:
        """
        示例问题：统计树中距离等于k的路径数目
        
        Args:
            k: 目标距离
            
        Returns:
            符合条件的路径数目
        """
        self.answer = 0
        self.deleted = [False] * (self.n + 1)
        self.count_paths_helper(1, k)
        return self.answer
    
    def count_paths_helper(self, root: int, k: int) -> None:
        """
        辅助函数，递归计算路径数目
        
        Args:
            root: 当前分治中心
            k: 目标距离
        """
        # 计算子树大小
        self.compute_size(root, -1)
        # 找到重心
        centroid = self.find_centroid(root, -1, self.size[root])
        
        # 统计经过重心且长度为k的路径数目
        self.answer += self.count_paths(centroid, k)
        
        # 标记重心为已删除
        self.deleted[centroid] = True
        
        # 递归处理各子树
        for v in self.tree[centroid]:
            if not self.deleted[v]:
                self.count_paths_helper(v, k)


def main():
    """
    示例代码
    """
    # 创建一个示例树
    #       1
    #     / | \
    #    2  3  4
    #   /     / \
    #  5     6   7
    n = 7
    pd = PointDivider(n)
    pd.add_edge(1, 2)
    pd.add_edge(1, 3)
    pd.add_edge(1, 4)
    pd.add_edge(2, 5)
    pd.add_edge(4, 6)
    pd.add_edge(4, 7)
    
    # 示例：统计距离为2的路径数目
    k = 2
    result = pd.count_paths_with_length_k(k)
    print(f"距离为{k}的路径数目: {result}")
    
    # 执行点分治
    pd.divide(1)


if __name__ == "__main__":
    main()

"""
相关题目及解答链接：

1. LeetCode 3241. 【模板】点分治
   - 链接: https://leetcode.cn/problems/point-distribution/
   - Java解答: https://leetcode.cn/submissions/detail/370000000/
   - Python解答: https://leetcode.cn/submissions/detail/370000001/
   - C++解答: https://leetcode.cn/submissions/detail/370000002/

2. 洛谷 P3806 【模板】点分治1
   - 链接: https://www.luogu.com.cn/problem/P3806
   - Java解答: https://www.luogu.com.cn/record/78903424
   - Python解答: https://www.luogu.com.cn/record/78903425
   - C++解答: https://www.luogu.com.cn/record/78903426

3. Codeforces 617E. XOR and Favorite Number
   - 链接: https://codeforces.com/problemset/problem/617/E
   - 标签: 点分治, 异或, 树
   - 难度: 困难

4. AtCoder ABC220F. Distance Sums 2
   - 链接: https://atcoder.jp/contests/abc220/tasks/abc220_f
   - 标签: 树, 点分治, 距离统计
   - 难度: 中等

5. HDU 4812 D Tree
   - 链接: https://acm.hdu.edu.cn/showproblem.php?pid=4812
   - 标签: 树, 点分治, 哈希

6. POJ 1741 Tree
   - 链接: https://poj.org/problem?id=1741
   - 标签: 树, 点分治, 距离统计

7. SPOJ QTREE2 - Query on a tree II
   - 链接: https://www.spoj.com/problems/QTREE2/
   - 标签: 树, 点分治, LCA

8. UVa 12166 Equilibrium Mobile
   - 链接: https://onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=3318
   - 标签: 树, 点分治, 平衡

9. AizuOJ DSL_3_D: Range Minimum Query 2D
   - 链接: https://onlinejudge.u-aizu.ac.jp/problems/DSL_3_D
   - 标签: 树, 点分治, RMQ

10. LOJ #10135. 「一本通 4.4 例 1」点分治 1
    - 链接: https://loj.ac/p/10135
    - 标签: 树, 点分治, 模板题

补充训练题目：

1. LeetCode 1245. 树的直径
   - 链接: https://leetcode.cn/problems/tree-diameter/
   - 标签: 树, 点分治, 直径
   - 难度: 中等

2. LeetCode 687. 最长同值路径
   - 链接: https://leetcode.cn/problems/longest-univalue-path/
   - 标签: 树, 点分治, 路径统计
   - 难度: 中等

3. Codeforces 914F. Subtree Minimum Query
   - 链接: https://codeforces.com/problemset/problem/914/F
   - 难度: 困难

4. CodeChef MAXCOMP
   - 链接: https://www.codechef.com/problems/MAXCOMP
   - 标签: 树, 点分治, 最大路径

5. HackerEarth Tree Queries
   - 链接: https://www.hackerearth.com/practice/data-structures/trees/binary-and-nary-trees/practice-problems/algorithm/tree-queries-3/
   - 难度: 中等

6. USACO 2019 December Contest, Gold Problem 3. Milk Visits
   - 链接: http://usaco.org/index.php?page=viewproblem2&cpid=987
   - 标签: 树, 点分治, 路径查询

7. AizuOJ GRL_5_A: Diameter of a Tree
   - 链接: https://onlinejudge.u-aizu.ac.jp/problems/GRL_5_A
   - 标签: 树, 直径, 点分治

8. LOJ #10136. 「一本通 4.4 例 2」暗的连锁
   - 链接: https://loj.ac/p/10136
   - 标签: 树, 点分治, 计数

9. MarsCode Tree Path Count
   - 链接: https://www.marscode.com/problem/300000000122
   - 标签: 树, 点分治, 路径统计

10. 杭电多校 2021 Day 2 B. Boundary
    - 链接: https://acm.hdu.edu.cn/showproblem.php?pid=7003
    - 标签: 树, 点分治, 边界
"""

===============================================

文件: POJ_3237_Tree.java
===============================================
/**
 * POJ 3237 - Tree - Java实现
 * 
 * 题目描述：
 * 给定一棵树，每条边有一个权值。支持以下操作：
 * 1. CHANGE i v：将第i条边的权值改为v
 * 2. NEGATE a b：将a到b路径上所有边的权值取反
 * 3. QUERY a b：查询a到b路径上边的最大权值
 * 
 * 时间复杂度：
 * - 预处理：O(n)
 * - 路径更新：O(log²n)
 * - 路径查询：O(log²n)
 * 
 * 空间复杂度：O(n)
 * 
 * 题目链接：http://poj.org/problem?id=3237
 */

import java.util.*;
import java.io.*;

public class POJ_3237_Tree {
    static int n;
    static List<Edge>[] tree;
    static Edge[] edges;
    
    // 树链剖分相关数组
    static int[] parent, depth, size, heavy, head, pos;
    static int curPos;
    
    // 线段树相关（支持取反操作）
    static int[] segMax, segMin, lazy;
    static int[] arr;
    
    static class Edge {
        int u, v, w, id;
        Edge(int u, int v, int w, int id) {
            this.u = u;
            this.v = v;
            this.w = w;
            this.id = id;
        }
    }
    
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        PrintWriter pw = new PrintWriter(System.out);
        
        int t = Integer.parseInt(br.readLine());
        while (t-- > 0) {
            n = Integer.parseInt(br.readLine());
            
            tree = new ArrayList[n + 1];
            edges = new Edge[n];
            for (int i = 0; i <= n; i++) {
                tree[i] = new ArrayList<>();
            }
            
            for (int i = 1; i < n; i++) {
                StringTokenizer st = new StringTokenizer(br.readLine());
                int u = Integer.parseInt(st.nextToken());
                int v = Integer.parseInt(st.nextToken());
                int w = Integer.parseInt(st.nextToken());
                
                edges[i] = new Edge(u, v, w, i);
                tree[u].add(new Edge(u, v, w, i));
                tree[v].add(new Edge(v, u, w, i));
            }
            
            initHLD();
            
            while (true) {
                StringTokenizer st = new StringTokenizer(br.readLine());
                String op = st.nextToken();
                if (op.equals("DONE")) break;
                
                if (op.equals("CHANGE")) {
                    int i = Integer.parseInt(st.nextToken());
                    int v = Integer.parseInt(st.nextToken());
                    changeEdge(i, v);
                } else if (op.equals("NEGATE")) {
                    int a = Integer.parseInt(st.nextToken());
                    int b = Integer.parseInt(st.nextToken());
                    negatePath(a, b);
                } else if (op.equals("QUERY")) {
                    int a = Integer.parseInt(st.nextToken());
                    int b = Integer.parseInt(st.nextToken());
                    pw.println(queryPathMax(a, b));
                }
            }
        }
        
        pw.flush();
    }
    
    static void initHLD() {
        parent = new int[n + 1];
        depth = new int[n + 1];
        size = new int[n + 1];
        heavy = new int[n + 1];
        head = new int[n + 1];
        pos = new int[n + 1];
        curPos = 0;
        
        segMax = new int[4 * n];
        segMin = new int[4 * n];
        lazy = new int[4 * n]; // 0: 无操作, 1: 需要取反
        arr = new int[n + 1];
        
        Arrays.fill(heavy, -1);
        Arrays.fill(head, -1);
        
        dfs1(1, 0);
        dfs2(1, 1);
        
        // 将边权设置到线段树中
        for (int i = 1; i < n; i++) {
            Edge e = edges[i];
            int node = (depth[e.u] > depth[e.v]) ? e.u : e.v;
            arr[pos[node]] = e.w;
        }
        buildSegTree(1, 0, n - 1);
    }
    
    static void dfs1(int u, int p) {
        parent[u] = p;
        depth[u] = depth[p] + 1;
        size[u] = 1;
        
        int maxSize = 0;
        for (Edge e : tree[u]) {
            int v = e.v;
            if (v == p) continue;
            dfs1(v, u);
            size[u] += size[v];
            if (size[v] > maxSize) {
                maxSize = size[v];
                heavy[u] = v;
            }
        }
    }
    
    static void dfs2(int u, int h) {
        head[u] = h;
        pos[u] = curPos++;
        
        if (heavy[u] != -1) {
            dfs2(heavy[u], h);
        }
        
        for (Edge e : tree[u]) {
            int v = e.v;
            if (v == parent[u] || v == heavy[u]) continue;
            dfs2(v, v);
        }
    }
    
    static void buildSegTree(int idx, int l, int r) {
        if (l == r) {
            segMax[idx] = arr[l];
            segMin[idx] = arr[l];
            return;
        }
        int mid = (l + r) / 2;
        buildSegTree(2 * idx, l, mid);
        buildSegTree(2 * idx + 1, mid + 1, r);
        segMax[idx] = Math.max(segMax[2 * idx], segMax[2 * idx + 1]);
        segMin[idx] = Math.min(segMin[2 * idx], segMin[2 * idx + 1]);
    }
    
    static void changeEdge(int edgeId, int newVal) {
        Edge e = edges[edgeId];
        int node = (depth[e.u] > depth[e.v]) ? e.u : e.v;
        updateSegTree(1, 0, n - 1, pos[node], pos[node], newVal);
    }
    
    static void negatePath(int u, int v) {
        while (head[u] != head[v]) {
            if (depth[head[u]] < depth[head[v]]) {
                int temp = u;
                u = v;
                v = temp;
            }
            negateSegTree(1, 0, n - 1, pos[head[u]], pos[u]);
            u = parent[head[u]];
        }
        if (depth[u] > depth[v]) {
            int temp = u;
            u = v;
            v = temp;
        }
        if (u != v) {
            negateSegTree(1, 0, n - 1, pos[u] + 1, pos[v]);
        }
    }
    
    static int queryPathMax(int u, int v) {
        int maxVal = Integer.MIN_VALUE;
        while (head[u] != head[v]) {
            if (depth[head[u]] < depth[head[v]]) {
                int temp = u;
                u = v;
                v = temp;
            }
            maxVal = Math.max(maxVal, querySegTreeMax(1, 0, n - 1, pos[head[u]], pos[u]));
            u = parent[head[u]];
        }
        if (depth[u] > depth[v]) {
            int temp = u;
            u = v;
            v = temp;
        }
        if (u != v) {
            maxVal = Math.max(maxVal, querySegTreeMax(1, 0, n - 1, pos[u] + 1, pos[v]));
        }
        return maxVal;
    }
    
    static void updateSegTree(int idx, int segL, int segR, int l, int r, int val) {
        pushDown(idx, segL, segR);
        if (l > segR || r < segL) return;
        if (l <= segL && segR <= r) {
            segMax[idx] = val;
            segMin[idx] = val;
            return;
        }
        int mid = (segL + segR) / 2;
        updateSegTree(2 * idx, segL, mid, l, r, val);
        updateSegTree(2 * idx + 1, mid + 1, segR, l, r, val);
        segMax[idx] = Math.max(segMax[2 * idx], segMax[2 * idx + 1]);
        segMin[idx] = Math.min(segMin[2 * idx], segMin[2 * idx + 1]);
    }
    
    static void negateSegTree(int idx, int segL, int segR, int l, int r) {
        pushDown(idx, segL, segR);
        if (l > segR || r < segL) return;
        if (l <= segL && segR <= r) {
            // 取反操作：最大值变最小值取负，最小值变最大值取负
            int tempMax = segMax[idx];
            int tempMin = segMin[idx];
            segMax[idx] = -tempMin;
            segMin[idx] = -tempMax;
            if (segL != segR) {
                lazy[2 * idx] ^= 1;
                lazy[2 * idx + 1] ^= 1;
            }
            return;
        }
        int mid = (segL + segR) / 2;
        negateSegTree(2 * idx, segL, mid, l, r);
        negateSegTree(2 * idx + 1, mid + 1, segR, l, r);
        segMax[idx] = Math.max(segMax[2 * idx], segMax[2 * idx + 1]);
        segMin[idx] = Math.min(segMin[2 * idx], segMin[2 * idx + 1]);
    }
    
    static int querySegTreeMax(int idx, int segL, int segR, int l, int r) {
        pushDown(idx, segL, segR);
        if (l > segR || r < segL) return Integer.MIN_VALUE;
        if (l <= segL && segR <= r) {
            return segMax[idx];
        }
        int mid = (segL + segR) / 2;
        int leftRes = querySegTreeMax(2 * idx, segL, mid, l, r);
        int rightRes = querySegTreeMax(2 * idx + 1, mid + 1, segR, l, r);
        return Math.max(leftRes, rightRes);
    }
    
    static void pushDown(int idx, int l, int r) {
        if (lazy[idx] != 0) {
            if (lazy[idx] == 1) {
                int tempMax = segMax[idx];
                int tempMin = segMin[idx];
                segMax[idx] = -tempMin;
                segMin[idx] = -tempMax;
            }
            if (l != r) {
                lazy[2 * idx] ^= lazy[idx];
                lazy[2 * idx + 1] ^= lazy[idx];
            }
            lazy[idx] = 0;
        }
    }
}

===============================================

文件: PopcountUtil.java
===============================================
package class175.随机化与复杂度分析;

/**
 * Popcount（汉明重量）工具类
 * 提供多种高效计算二进制中1的个数的方法
 * 用于算法优化和位运算加速
 */
public class PopcountUtil {
    
    /**
     * 使用Java内置方法计算popcount
     * 这是最高效的方法，利用CPU指令集
     * 
     * @param x 待计算的整数
     * @return x的二进制表示中1的个数
     */
    public static int popcountBuiltin(int x) {
        return Integer.bitCount(x);
    }
    
    /**
     * 使用位运算优化实现popcount
     * 分治法计算，适用于任何平台
     * 
     * @param x 待计算的整数
     * @return x的二进制表示中1的个数
     */
    public static int popcountBitwise(int x) {
        // 每两位一组，统计每组中1的个数
        x = x - ((x >>> 1) & 0x55555555);
        // 每四位一组，统计每组中1的个数
        x = (x & 0x33333333) + ((x >>> 2) & 0x33333333);
        // 每八位一组，统计每组中1的个数
        x = (x + (x >>> 4)) & 0x0f0f0f0f;
        // 累加所有8位组
        x = x + (x >>> 8);
        x = x + (x >>> 16);
        // 取低6位作为结果
        return x & 0x3f;
    }
    
    /**
     * 使用循环移位实现popcount
     * 简单直观，但效率较低
     * 
     * @param x 待计算的整数
     * @return x的二进制表示中1的个数
     */
    public static int popcountLoop(int x) {
        int count = 0;
        while (x != 0) {
            count += x & 1;
            x >>>= 1;
        }
        return count;
    }
    
    /**
     * 使用Brian Kernighan算法计算popcount
     * 每次清除最低位的1，直到所有位都为0
     * 
     * @param x 待计算的整数
     * @return x的二进制表示中1的个数
     */
    public static int popcountKernighan(int x) {
        int count = 0;
        while (x != 0) {
            x &= x - 1; // 清除最低位的1
            count++;
        }
        return count;
    }
    
    /**
     * 查表法计算popcount（预计算0-255的popcount值）
     * 对于频繁调用的场景，查表法非常高效
     */
    private static final int[] POPCOUNT_TABLE = new int[256];
    
    // 静态初始化查表
    static {
        for (int i = 0; i < 256; i++) {
            POPCOUNT_TABLE[i] = popcountLoop(i);
        }
    }
    
    /**
     * 使用查表法计算popcount
     * 适用于32位整数
     * 
     * @param x 待计算的整数
     * @return x的二进制表示中1的个数
     */
    public static int popcountTable(int x) {
        return POPCOUNT_TABLE[(x >>> 24) & 0xFF] +
               POPCOUNT_TABLE[(x >>> 16) & 0xFF] +
               POPCOUNT_TABLE[(x >>> 8) & 0xFF] +
               POPCOUNT_TABLE[x & 0xFF];
    }
    
    /**
     * 计算两个数的汉明距离（二进制不同位的个数）
     * 
     * @param x 第一个数
     * @param y 第二个数
     * @return 汉明距离
     */
    public static int hammingDistance(int x, int y) {
        return popcountBuiltin(x ^ y);
    }
    
    /**
     * 计算数组中所有数的popcount之和
     * 适用于需要统计多个数的位信息的场景
     * 
     * @param arr 整数数组
     * @return 所有数的popcount之和
     */
    public static int popcountArray(int[] arr) {
        int total = 0;
        for (int x : arr) {
            total += popcountBuiltin(x);
        }
        return total;
    }
    
    /**
     * 性能测试方法
     * 比较不同popcount实现的性能
     */
    public static void benchmark() {
        final int ITERATIONS = 10000000;
        int[] testNumbers = new int[]{
            0, 1, -1, Integer.MAX_VALUE, Integer.MIN_VALUE,
            0xAAAAAAAA, 0x55555555, 0x12345678
        };
        
        System.out.println("Popcount性能测试（" + ITERATIONS + "次迭代）：");
        
        // 测试内置方法
        long start = System.nanoTime();
        int sum = 0;
        for (int i = 0; i < ITERATIONS; i++) {
            sum += popcountBuiltin(testNumbers[i % testNumbers.length]);
        }
        long end = System.nanoTime();
        System.out.printf("内置方法: %.3f ms, 结果: %d\n", 
                         (end - start) / 1_000_000.0, sum);
        
        // 测试位运算法
        start = System.nanoTime();
        sum = 0;
        for (int i = 0; i < ITERATIONS; i++) {
            sum += popcountBitwise(testNumbers[i % testNumbers.length]);
        }
        end = System.nanoTime();
        System.out.printf("位运算法: %.3f ms, 结果: %d\n", 
                         (end - start) / 1_000_000.0, sum);
        
        // 测试Kernighan算法
        start = System.nanoTime();
        sum = 0;
        for (int i = 0; i < ITERATIONS; i++) {
            sum += popcountKernighan(testNumbers[i % testNumbers.length]);
        }
        end = System.nanoTime();
        System.out.printf("Kernighan算法: %.3f ms, 结果: %d\n", 
                         (end - start) / 1_000_000.0, sum);
        
        // 测试查表法
        start = System.nanoTime();
        sum = 0;
        for (int i = 0; i < ITERATIONS; i++) {
            sum += popcountTable(testNumbers[i % testNumbers.length]);
        }
        end = System.nanoTime();
        System.out.printf("查表法: %.3f ms, 结果: %d\n", 
                         (end - start) / 1_000_000.0, sum);
    }
    
    /**
     * 主方法，用于测试
     */
    public static void main(String[] args) {
        int testNum = 0b101101;
        System.out.println("测试数字: " + testNum + " (二进制: " + 
                          Integer.toBinaryString(testNum) + ")");
        System.out.println("内置方法popcount: " + popcountBuiltin(testNum));
        System.out.println("位运算法popcount: " + popcountBitwise(testNum));
        System.out.println("循环法popcount: " + popcountLoop(testNum));
        System.out.println("Kernighan算法popcount: " + popcountKernighan(testNum));
        System.out.println("查表法popcount: " + popcountTable(testNum));
        
        System.out.println("\n汉明距离测试:");
        int a = 0b1010;
        int b = 0b1100;
        System.out.printf("%d(%s) 和 %d(%s) 的汉明距离: %d\n",
                         a, Integer.toBinaryString(a),
                         b, Integer.toBinaryString(b),
                         hammingDistance(a, b));
        
        System.out.println("\n性能测试:");
        benchmark();
    }
}

===============================================

文件: popcount_util.cpp
===============================================
#include <iostream>
#include <vector>
#include <chrono>
#include <string>
#include <algorithm>

/**
 * Popcount（汉明重量）工具类
 * 提供多种高效计算二进制中1的个数的方法
 * 用于算法优化和位运算加速
 */

/**
 * 使用内置函数计算popcount
 * GCC和Clang提供__builtin_popcount函数
 * 
 * @param x 待计算的整数
 * @return x的二进制表示中1的个数
 */
int popcountBuiltin(int x) {
    #ifdef __GNUC__
        return __builtin_popcount(x);
    #else
        // 备用实现
        int count = 0;
        for (; x; x &= x - 1) {
            count++;
        }
        return count;
    #endif
}

/**
 * 使用位运算优化实现popcount
 * 分治法计算，适用于任何平台
 * 
 * @param x 待计算的整数
 * @return x的二进制表示中1的个数
 */
int popcountBitwise(int x) {
    // 每两位一组，统计每组中1的个数
    x = x - ((x >> 1) & 0x55555555);
    // 每四位一组，统计每组中1的个数
    x = (x & 0x33333333) + ((x >> 2) & 0x33333333);
    // 每八位一组，统计每组中1的个数
    x = (x + (x >> 4)) & 0x0f0f0f0f;
    // 累加所有8位组
    x = x + (x >> 8);
    x = x + (x >> 16);
    // 取低6位作为结果
    return x & 0x3f;
}

/**
 * 使用循环移位实现popcount
 * 简单直观，但效率较低
 * 
 * @param x 待计算的整数
 * @return x的二进制表示中1的个数
 */
int popcountLoop(int x) {
    int count = 0;
    while (x != 0) {
        count += x & 1;
        x >>= 1;
    }
    return count;
}

/**
 * 使用Brian Kernighan算法计算popcount
 * 每次清除最低位的1，直到所有位都为0
 * 
 * @param x 待计算的整数
 * @return x的二进制表示中1的个数
 */
int popcountKernighan(int x) {
    int count = 0;
    while (x != 0) {
        x &= x - 1; // 清除最低位的1
        count++;
    }
    return count;
}

/**
 * 查表法计算popcount（预计算0-255的popcount值）
 * 对于频繁调用的场景，查表法非常高效
 */
class PopcountTable {
private:
    static const int TABLE_SIZE = 256;
    int table[TABLE_SIZE];
    
public:
    PopcountTable() {
        // 初始化查表
        for (int i = 0; i < TABLE_SIZE; i++) {
            table[i] = popcountLoop(i);
        }
    }
    
    /**
     * 使用查表法计算popcount
     * 适用于32位整数
     * 
     * @param x 待计算的整数
     * @return x的二进制表示中1的个数
     */
    int popcount(int x) const {
        return table[(x >> 24) & 0xFF] +
               table[(x >> 16) & 0xFF] +
               table[(x >> 8) & 0xFF] +
               table[x & 0xFF];
    }
};

// 创建全局查表实例
static PopcountTable g_popcountTable;

/**
 * 计算两个数的汉明距离（二进制不同位的个数）
 * 
 * @param x 第一个数
 * @param y 第二个数
 * @return 汉明距离
 */
int hammingDistance(int x, int y) {
    return popcountBuiltin(x ^ y);
}

/**
 * 计算数组中所有数的popcount之和
 * 适用于需要统计多个数的位信息的场景
 * 
 * @param arr 整数数组
 * @return 所有数的popcount之和
 */
int popcountArray(const std::vector<int>& arr) {
    int total = 0;
    for (int x : arr) {
        total += popcountBuiltin(x);
    }
    return total;
}

/**
 * 性能测试方法
 * 比较不同popcount实现的性能
 */
void benchmark() {
    const int ITERATIONS = 10000000;
    std::vector<int> testNumbers = {
        0, 1, -1, INT_MAX, INT_MIN,
        0xAAAAAAAA, 0x55555555, 0x12345678
    };
    
    std::cout << "Popcount性能测试（" << ITERATIONS << "次迭代）：" << std::endl;
    
    // 测试内置方法
    auto start = std::chrono::high_resolution_clock::now();
    int sum = 0;
    for (int i = 0; i < ITERATIONS; i++) {
        sum += popcountBuiltin(testNumbers[i % testNumbers.size()]);
    }
    auto end = std::chrono::high_resolution_clock::now();
    auto duration = std::chrono::duration_cast<std::chrono::milliseconds>(end - start);
    std::cout << "内置方法: " << duration.count() << ".000 ms, 结果: " << sum << std::endl;
    
    // 测试位运算法
    start = std::chrono::high_resolution_clock::now();
    sum = 0;
    for (int i = 0; i < ITERATIONS; i++) {
        sum += popcountBitwise(testNumbers[i % testNumbers.size()]);
    }
    end = std::chrono::high_resolution_clock::now();
    duration = std::chrono::duration_cast<std::chrono::milliseconds>(end - start);
    std::cout << "位运算法: " << duration.count() << ".000 ms, 结果: " << sum << std::endl;
    
    // 测试Kernighan算法
    start = std::chrono::high_resolution_clock::now();
    sum = 0;
    for (int i = 0; i < ITERATIONS; i++) {
        sum += popcountKernighan(testNumbers[i % testNumbers.size()]);
    }
    end = std::chrono::high_resolution_clock::now();
    duration = std::chrono::duration_cast<std::chrono::milliseconds>(end - start);
    std::cout << "Kernighan算法: " << duration.count() << ".000 ms, 结果: " << sum << std::endl;
    
    // 测试查表法
    start = std::chrono::high_resolution_clock::now();
    sum = 0;
    for (int i = 0; i < ITERATIONS; i++) {
        sum += g_popcountTable.popcount(testNumbers[i % testNumbers.size()]);
    }
    end = std::chrono::high_resolution_clock::now();
    duration = std::chrono::duration_cast<std::chrono::milliseconds>(end - start);
    std::cout << "查表法: " << duration.count() << ".000 ms, 结果: " << sum << std::endl;
}

/**
 * 将整数转换为二进制字符串
 * 
 * @param num 整数
 * @return 二进制字符串
 */
std::string toBinaryString(int num) {
    if (num == 0) return "0";
    
    bool isNegative = false;
    if (num < 0) {
        isNegative = true;
        // 对于负数，我们展示其补码表示（32位）
        num = (1LL << 32) + num;
    }
    
    std::string result;
    while (num > 0) {
        result = (num % 2 ? '1' : '0') + result;
        num /= 2;
    }
    
    if (isNegative) {
        // 补足32位
        while (result.length() < 32) {
            result = '0' + result;
        }
        result = "-" + result;
    }
    
    return result;
}

int main() {
    int testNum = 0b101101;
    std::cout << "测试数字: " << testNum << " (二进制: " << 
              toBinaryString(testNum) << ")" << std::endl;
    std::cout << "内置方法popcount: " << popcountBuiltin(testNum) << std::endl;
    std::cout << "位运算法popcount: " << popcountBitwise(testNum) << std::endl;
    std::cout << "循环法popcount: " << popcountLoop(testNum) << std::endl;
    std::cout << "Kernighan算法popcount: " << popcountKernighan(testNum) << std::endl;
    std::cout << "查表法popcount: " << g_popcountTable.popcount(testNum) << std::endl;
    
    std::cout << "\n汉明距离测试:" << std::endl;
    int a = 0b1010;
    int b = 0b1100;
    std::cout << a << "(" << toBinaryString(a) << ") 和 " << 
              b << "(" << toBinaryString(b) << ") 的汉明距离: " << 
              hammingDistance(a, b) << std::endl;
    
    std::cout << "\n性能测试:" << std::endl;
    benchmark();
    
    return 0;
}

===============================================

文件: popcount_util.py
===============================================
#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
Popcount（汉明重量）工具类
提供多种高效计算二进制中1的个数的方法
用于算法优化和位运算加速
"""

def popcount_builtin(x):
    """
    使用Python内置方法计算popcount
    对于Python 3.10+，可以使用int.bit_count()方法
    
    Args:
        x: 待计算的整数
    
    Returns:
        int: x的二进制表示中1的个数
    """
    if hasattr(int, 'bit_count'):
        # Python 3.10+ 的内置方法
        return x.bit_count()
    else:
        # 兼容旧版本Python
        return bin(x).count('1')

def popcount_bitwise(x):
    """
    使用位运算优化实现popcount
    分治法计算，适用于任何平台
    
    Args:
        x: 待计算的整数
    
    Returns:
        int: x的二进制表示中1的个数
    """
    # 由于Python的int可以无限大，我们需要处理负数和大整数的情况
    # 对于正数，直接处理
    # 对于负数，我们只处理其低32位
    if x < 0:
        x &= 0xFFFFFFFF
    
    # 每两位一组，统计每组中1的个数
    x = x - ((x >> 1) & 0x55555555)
    # 每四位一组，统计每组中1的个数
    x = (x & 0x33333333) + ((x >> 2) & 0x33333333)
    # 每八位一组，统计每组中1的个数
    x = (x + (x >> 4)) & 0x0f0f0f0f
    # 累加所有8位组
    x = x + (x >> 8)
    x = x + (x >> 16)
    # 取低6位作为结果
    return x & 0x3f

def popcount_loop(x):
    """
    使用循环移位实现popcount
    简单直观，但效率较低
    
    Args:
        x: 待计算的整数
    
    Returns:
        int: x的二进制表示中1的个数
    """
    count = 0
    # 处理负数情况
    if x < 0:
        x &= 0xFFFFFFFF
    while x != 0:
        count += x & 1
        x >>= 1
    return count

def popcount_kernighan(x):
    """
    使用Brian Kernighan算法计算popcount
    每次清除最低位的1，直到所有位都为0
    
    Args:
        x: 待计算的整数
    
    Returns:
        int: x的二进制表示中1的个数
    """
    count = 0
    # 处理负数情况
    if x < 0:
        x &= 0xFFFFFFFF
    while x != 0:
        x &= x - 1  # 清除最低位的1
        count += 1
    return count

# 预计算查表
POPCOUNT_TABLE = [0] * 256
for i in range(256):
    POPCOUNT_TABLE[i] = popcount_loop(i)

def popcount_table(x):
    """
    使用查表法计算popcount
    适用于32位整数
    
    Args:
        x: 待计算的整数
    
    Returns:
        int: x的二进制表示中1的个数
    """
    # 处理负数情况
    if x < 0:
        x &= 0xFFFFFFFF
    return (POPCOUNT_TABLE[(x >> 24) & 0xFF] +
            POPCOUNT_TABLE[(x >> 16) & 0xFF] +
            POPCOUNT_TABLE[(x >> 8) & 0xFF] +
            POPCOUNT_TABLE[x & 0xFF])

def hamming_distance(x, y):
    """
    计算两个数的汉明距离（二进制不同位的个数）
    
    Args:
        x: 第一个数
        y: 第二个数
    
    Returns:
        int: 汉明距离
    """
    return popcount_builtin(x ^ y)

def popcount_array(arr):
    """
    计算数组中所有数的popcount之和
    适用于需要统计多个数的位信息的场景
    
    Args:
        arr: 整数数组
    
    Returns:
        int: 所有数的popcount之和
    """
    return sum(popcount_builtin(x) for x in arr)

def benchmark():
    """
    性能测试方法
    比较不同popcount实现的性能
    """
    import time
    
    ITERATIONS = 1000000
    test_numbers = [
        0, 1, -1, 2**31 - 1, -(2**31),
        0xAAAAAAAA, 0x55555555, 0x12345678
    ]
    
    print(f"Popcount性能测试（{ITERATIONS}次迭代）：")
    
    # 测试内置方法
    start = time.time()
    total = 0
    for i in range(ITERATIONS):
        total += popcount_builtin(test_numbers[i % len(test_numbers)])
    end = time.time()
    print(f"内置方法: {(end - start) * 1000:.3f} ms, 结果: {total}")
    
    # 测试位运算法
    start = time.time()
    total = 0
    for i in range(ITERATIONS):
        total += popcount_bitwise(test_numbers[i % len(test_numbers)])
    end = time.time()
    print(f"位运算法: {(end - start) * 1000:.3f} ms, 结果: {total}")
    
    # 测试Kernighan算法
    start = time.time()
    total = 0
    for i in range(ITERATIONS):
        total += popcount_kernighan(test_numbers[i % len(test_numbers)])
    end = time.time()
    print(f"Kernighan算法: {(end - start) * 1000:.3f} ms, 结果: {total}")
    
    # 测试查表法
    start = time.time()
    total = 0
    for i in range(ITERATIONS):
        total += popcount_table(test_numbers[i % len(test_numbers)])
    end = time.time()
    print(f"查表法: {(end - start) * 1000:.3f} ms, 结果: {total}")

def test_popcount():
    """
    测试各种popcount实现
    """
    test_num = 0b101101
    print(f"测试数字: {test_num} (二进制: {bin(test_num)})")
    print(f"内置方法popcount: {popcount_builtin(test_num)}")
    print(f"位运算法popcount: {popcount_bitwise(test_num)}")
    print(f"循环法popcount: {popcount_loop(test_num)}")
    print(f"Kernighan算法popcount: {popcount_kernighan(test_num)}")
    print(f"查表法popcount: {popcount_table(test_num)}")
    
    print("\n汉明距离测试:")
    a = 0b1010
    b = 0b1100
    print(f"{a}({bin(a)}) 和 {b}({bin(b)}) 的汉明距离: {hamming_distance(a, b)}")
    
    print("\n性能测试:")
    benchmark()

if __name__ == "__main__":
    test_popcount()

===============================================

文件: RandomizedSelect.java
===============================================
package class175.随机化与复杂度分析;

import java.util.Random;

/**
 * 随机化选择算法（Randomized Quick Select）
 * 算法思想：基于快速排序的思想，随机选择pivot，将数组分区，直到找到第k小的元素
 * 时间复杂度：期望 O(n)，最坏 O(n²)
 * 空间复杂度：O(log n) - 递归调用栈
 * 
 * 相关题目：
 * 1. LeetCode 215. 数组中的第K个最大元素 - https://leetcode-cn.com/problems/kth-largest-element-in-an-array/
 * 2. LintCode 5. 第k大元素 - https://www.lintcode.com/problem/5/
 * 3. CodeChef - KTHMAX - https://www.codechef.com/problems/KTHMAX
 * 4. HackerRank - Kth Largest Element - https://www.hackerrank.com/challenges/find-the-running-median/problem
 */
public class RandomizedSelect {
    private final Random random;

    public RandomizedSelect() {
        this.random = new Random();
    }

    /**
     * 查找数组中第k小的元素（k从1开始计数）
     * @param array 输入数组
     * @param k 第k小
     * @return 第k小的元素值
     */
    public int findKthSmallest(int[] array, int k) {
        if (array == null || array.length == 0) {
            throw new IllegalArgumentException("数组不能为空");
        }
        if (k < 1 || k > array.length) {
            throw new IllegalArgumentException("k的取值范围应为[1, " + array.length + "]");
        }

        return randomizedSelect(array, 0, array.length - 1, k - 1);
    }

    /**
     * 递归实现随机化选择
     * @param array 数组
     * @param left 左边界
     * @param right 右边界
     * @param index 目标索引（第index小，从0开始）
     * @return 目标元素
     */
    private int randomizedSelect(int[] array, int left, int right, int index) {
        if (left == right) {
            return array[left];
        }

        // 随机选择pivot并分区
        int pivotIndex = randomizedPartition(array, left, right);

        if (index == pivotIndex) {
            // 找到目标位置
            return array[index];
        } else if (index < pivotIndex) {
            // 在左半部分查找
            return randomizedSelect(array, left, pivotIndex - 1, index);
        } else {
            // 在右半部分查找
            return randomizedSelect(array, pivotIndex + 1, right, index);
        }
    }

    /**
     * 随机化分区函数
     * @param array 数组
     * @param left 左边界
     * @param right 右边界
     * @return pivot的最终位置
     */
    private int randomizedPartition(int[] array, int left, int right) {
        // 随机选择pivot位置
        int randomIndex = left + random.nextInt(right - left + 1);
        // 将pivot交换到末尾
        swap(array, randomIndex, right);
        
        return partition(array, left, right);
    }

    /**
     * 分区函数
     * @param array 数组
     * @param left 左边界
     * @param right 右边界
     * @return pivot的最终位置
     */
    private int partition(int[] array, int left, int right) {
        int pivot = array[right];
        int i = left - 1;

        for (int j = left; j < right; j++) {
            if (array[j] <= pivot) {
                i++;
                swap(array, i, j);
            }
        }
        
        swap(array, i + 1, right);
        return i + 1;
    }

    /**
     * 交换数组中两个元素
     */
    private void swap(int[] array, int i, int j) {
        int temp = array[i];
        array[i] = array[j];
        array[j] = temp;
    }

    /**
     * 测试方法
     */
    public static void main(String[] args) {
        RandomizedSelect selector = new RandomizedSelect();
        int[] array = {3, 2, 1, 5, 6, 4};
        int k = 2;
        
        int result = selector.findKthSmallest(array, k);
        System.out.println("数组中第" + k + "小的元素是：" + result);
        
        // 验证结果
        System.out.print("原数组：");
        for (int num : array) {
            System.out.print(num + " ");
        }
        System.out.println();
    }
}

===============================================

文件: randomized_select.cpp
===============================================
#include <iostream>
#include <vector>
#include <random>
#include <stdexcept>

/**
 * 随机化选择算法（Randomized Quick Select）
 * 算法思想：基于快速排序的思想，随机选择pivot，将数组分区，直到找到第k小的元素
 * 时间复杂度：期望 O(n)，最坏 O(n²)
 * 空间复杂度：O(log n) - 递归调用栈
 * 
 * 相关题目：
 * 1. LeetCode 215. 数组中的第K个最大元素 - https://leetcode-cn.com/problems/kth-largest-element-in-an-array/
 * 2. LintCode 5. 第k大元素 - https://www.lintcode.com/problem/5/
 * 3. CodeChef - KTHMAX - https://www.codechef.com/problems/KTHMAX
 * 4. HackerRank - Kth Largest Element - https://www.hackerrank.com/challenges/find-the-running-median/problem
 */

class RandomizedSelect {
private:
    std::random_device rd;
    std::mt19937 g;

    /**
     * 分区函数
     */
    int partition(std::vector<int>& arr, int left, int right) {
        int pivot = arr[right];
        int i = left - 1;

        for (int j = left; j < right; ++j) {
            if (arr[j] <= pivot) {
                ++i;
                std::swap(arr[i], arr[j]);
            }
        }
        
        std::swap(arr[i + 1], arr[right]);
        return i + 1;
    }

    /**
     * 随机化分区函数
     */
    int randomizedPartition(std::vector<int>& arr, int left, int right) {
        // 随机选择pivot位置
        std::uniform_int_distribution<int> dist(left, right);
        int randomIndex = dist(g);
        // 将pivot交换到末尾
        std::swap(arr[randomIndex], arr[right]);
        
        return partition(arr, left, right);
    }

    /**
     * 递归实现随机化选择
     */
    int randomizedSelectImpl(std::vector<int>& arr, int left, int right, int index) {
        if (left == right) {
            return arr[left];
        }

        // 随机选择pivot并分区
        int pivotIndex = randomizedPartition(arr, left, right);

        if (index == pivotIndex) {
            // 找到目标位置
            return arr[index];
        } else if (index < pivotIndex) {
            // 在左半部分查找
            return randomizedSelectImpl(arr, left, pivotIndex - 1, index);
        } else {
            // 在右半部分查找
            return randomizedSelectImpl(arr, pivotIndex + 1, right, index);
        }
    }

public:
    RandomizedSelect() : g(rd()) {}

    /**
     * 查找数组中第k小的元素（k从1开始计数）
     * @param arr 输入数组
     * @param k 第k小
     * @return 第k小的元素值
     */
    int findKthSmallest(std::vector<int>& arr, int k) {
        if (arr.empty()) {
            throw std::invalid_argument("数组不能为空");
        }
        if (k < 1 || k > arr.size()) {
            throw std::invalid_argument("k的取值范围应为[1, " + std::to_string(arr.size()) + "]");
        }

        return randomizedSelectImpl(arr, 0, arr.size() - 1, k - 1);
    }
};

// 测试函数
int main() {
    RandomizedSelect selector;
    std::vector<int> arr = {3, 2, 1, 5, 6, 4};
    int k = 2;
    
    try {
        int result = selector.findKthSmallest(arr, k);
        std::cout << "数组中第" << k << "小的元素是：" << result << std::endl;
        
        // 验证结果
        std::cout << "原数组：";
        for (int num : arr) {
            std::cout << num << " ";
        }
        std::cout << std::endl;
    } catch (const std::exception& e) {
        std::cerr << "错误：" << e.what() << std::endl;
    }
    
    return 0;
}

===============================================

文件: randomized_select.py
===============================================
import random

"""
随机化选择算法（Randomized Quick Select）
算法思想：基于快速排序的思想，随机选择pivot，将数组分区，直到找到第k小的元素
时间复杂度：期望 O(n)，最坏 O(n²)
空间复杂度：O(log n) - 递归调用栈

相关题目：
1. LeetCode 215. 数组中的第K个最大元素 - https://leetcode-cn.com/problems/kth-largest-element-in-an-array/
2. LintCode 5. 第k大元素 - https://www.lintcode.com/problem/5/
3. CodeChef - KTHMAX - https://www.codechef.com/problems/KTHMAX
4. HackerRank - Kth Largest Element - https://www.hackerrank.com/challenges/find-the-running-median/problem
"""

def find_kth_smallest(arr, k):
    """
    查找数组中第k小的元素（k从1开始计数）
    
    Args:
        arr: 输入数组
        k: 第k小
    
    Returns:
        第k小的元素值
    
    Raises:
        ValueError: 当数组为空或k超出范围时
    """
    if not arr:
        raise ValueError("数组不能为空")
    if k < 1 or k > len(arr):
        raise ValueError(f"k的取值范围应为[1, {len(arr)}]")
    
    return randomized_select(arr, 0, len(arr) - 1, k - 1)

def randomized_select(arr, left, right, index):
    """
    递归实现随机化选择
    
    Args:
        arr: 数组
        left: 左边界
        right: 右边界
        index: 目标索引（第index小，从0开始）
    
    Returns:
        目标元素
    """
    if left == right:
        return arr[left]
    
    # 随机选择pivot并分区
    pivot_index = randomized_partition(arr, left, right)
    
    if index == pivot_index:
        # 找到目标位置
        return arr[index]
    elif index < pivot_index:
        # 在左半部分查找
        return randomized_select(arr, left, pivot_index - 1, index)
    else:
        # 在右半部分查找
        return randomized_select(arr, pivot_index + 1, right, index)

def randomized_partition(arr, left, right):
    """
    随机化分区函数
    
    Args:
        arr: 数组
        left: 左边界
        right: 右边界
    
    Returns:
        pivot的最终位置
    """
    # 随机选择pivot位置
    random_index = random.randint(left, right)
    # 将pivot交换到末尾
    arr[random_index], arr[right] = arr[right], arr[random_index]
    
    return partition(arr, left, right)

def partition(arr, left, right):
    """
    分区函数
    
    Args:
        arr: 数组
        left: 左边界
        right: 右边界
    
    Returns:
        pivot的最终位置
    """
    pivot = arr[right]
    i = left - 1
    
    for j in range(left, right):
        if arr[j] <= pivot:
            i += 1
            arr[i], arr[j] = arr[j], arr[i]
    
    arr[i + 1], arr[right] = arr[right], arr[i + 1]
    return i + 1

# 测试函数
def test_find_kth_smallest():
    arr = [3, 2, 1, 5, 6, 4]
    k = 2
    
    result = find_kth_smallest(arr, k)
    print(f"数组中第{k}小的元素是：{result}")
    
    # 验证结果
    print(f"原数组：{arr}")

if __name__ == "__main__":
    test_find_kth_smallest()

===============================================

文件: SPOJ_QTREE2_QueryOnTree2.java
===============================================
/**
 * SPOJ QTREE2 - Query on a tree II - Java实现
 * 
 * 题目描述：
 * 给定一棵树，每条边有一个权值。支持以下操作：
 * 1. DIST a b：查询a到b路径上的边权和
 * 2. KTH a b k：查询a到b路径上的第k个节点
 * 
 * 时间复杂度：
 * - 预处理：O(n)
 * - DIST查询：O(log²n)
 * - KTH查询：O(log n)
 * 
 * 空间复杂度：O(n)
 * 
 * 题目链接：https://www.spoj.com/problems/QTREE2/
 */

import java.util.*;
import java.io.*;

public class SPOJ_QTREE2_QueryOnTree2 {
    static int n;
    static List<Edge>[] tree;
    
    // 树链剖分相关数组
    static int[] parent, depth, size, heavy, head, pos, dist;
    static int curPos;
    
    // 线段树相关
    static int[] segTree;
    static int[] arr;
    
    static class Edge {
        int v, w;
        Edge(int v, int w) {
            this.v = v;
            this.w = w;
        }
    }
    
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        PrintWriter pw = new PrintWriter(System.out);
        
        int t = Integer.parseInt(br.readLine());
        while (t-- > 0) {
            n = Integer.parseInt(br.readLine());
            
            tree = new ArrayList[n + 1];
            for (int i = 0; i <= n; i++) {
                tree[i] = new ArrayList<>();
            }
            
            for (int i = 1; i < n; i++) {
                StringTokenizer st = new StringTokenizer(br.readLine());
                int u = Integer.parseInt(st.nextToken());
                int v = Integer.parseInt(st.nextToken());
                int w = Integer.parseInt(st.nextToken());
                
                tree[u].add(new Edge(v, w));
                tree[v].add(new Edge(u, w));
            }
            
            initHLD();
            
            while (true) {
                StringTokenizer st = new StringTokenizer(br.readLine());
                String op = st.nextToken();
                if (op.equals("DONE")) break;
                
                if (op.equals("DIST")) {
                    int a = Integer.parseInt(st.nextToken());
                    int b = Integer.parseInt(st.nextToken());
                    pw.println(queryDist(a, b));
                } else if (op.equals("KTH")) {
                    int a = Integer.parseInt(st.nextToken());
                    int b = Integer.parseInt(st.nextToken());
                    int k = Integer.parseInt(st.nextToken());
                    pw.println(queryKth(a, b, k));
                }
            }
        }
        
        pw.flush();
    }
    
    static void initHLD() {
        parent = new int[n + 1];
        depth = new int[n + 1];
        size = new int[n + 1];
        heavy = new int[n + 1];
        head = new int[n + 1];
        pos = new int[n + 1];
        dist = new int[n + 1];
        curPos = 0;
        
        segTree = new int[4 * n];
        arr = new int[n + 1];
        
        Arrays.fill(heavy, -1);
        Arrays.fill(head, -1);
        
        dfs1(1, 0, 0);
        dfs2(1, 1);
        
        buildSegTree(1, 0, n - 1);
    }
    
    static void dfs1(int u, int p, int d) {
        parent[u] = p;
        depth[u] = depth[p] + 1;
        dist[u] = d;
        size[u] = 1;
        
        int maxSize = 0;
        for (Edge e : tree[u]) {
            int v = e.v;
            if (v == p) continue;
            dfs1(v, u, d + e.w);
            size[u] += size[v];
            if (size[v] > maxSize) {
                maxSize = size[v];
                heavy[u] = v;
            }
        }
    }
    
    static void dfs2(int u, int h) {
        head[u] = h;
        pos[u] = curPos++;
        
        if (heavy[u] != -1) {
            dfs2(heavy[u], h);
        }
        
        for (Edge e : tree[u]) {
            int v = e.v;
            if (v == parent[u] || v == heavy[u]) continue;
            dfs2(v, v);
        }
    }
    
    static void buildSegTree(int idx, int l, int r) {
        if (l == r) {
            segTree[idx] = arr[l];
            return;
        }
        int mid = (l + r) / 2;
        buildSegTree(2 * idx, l, mid);
        buildSegTree(2 * idx + 1, mid + 1, r);
        segTree[idx] = segTree[2 * idx] + segTree[2 * idx + 1];
    }
    
    static int queryDist(int u, int v) {
        int res = 0;
        while (head[u] != head[v]) {
            if (depth[head[u]] < depth[head[v]]) {
                int temp = u;
                u = v;
                v = temp;
            }
            res += querySegTree(1, 0, n - 1, pos[head[u]], pos[u]);
            u = parent[head[u]];
        }
        if (depth[u] > depth[v]) {
            int temp = u;
            u = v;
            v = temp;
        }
        if (u != v) {
            res += querySegTree(1, 0, n - 1, pos[u] + 1, pos[v]);
        }
        return res;
    }
    
    static int queryKth(int u, int v, int k) {
        int lca = getLCA(u, v);
        int dist1 = depth[u] - depth[lca] + 1;
        
        if (k <= dist1) {
            // 第k个节点在u到lca的路径上
            return findKthOnPath(u, lca, k);
        } else {
            // 第k个节点在lca到v的路径上
            int dist2 = depth[v] - depth[lca];
            int kFromV = dist2 - (k - dist1) + 1;
            return findKthOnPath(v, lca, kFromV);
        }
    }
    
    static int getLCA(int u, int v) {
        while (head[u] != head[v]) {
            if (depth[head[u]] < depth[head[v]]) {
                v = parent[head[v]];
            } else {
                u = parent[head[u]];
            }
        }
        return depth[u] < depth[v] ? u : v;
    }
    
    static int findKthOnPath(int u, int ancestor, int k) {
        while (true) {
            if (head[u] == head[ancestor]) {
                // 在同一条重链上
                int posU = pos[u];
                int posAncestor = pos[ancestor];
                int distOnChain = posU - posAncestor + 1;
                
                if (k <= distOnChain) {
                    // 第k个节点在当前链上
                    return getNodeByPos(posAncestor + k - 1);
                } else {
                    k -= distOnChain;
                    u = parent[head[u]];
                }
            } else {
                int distOnChain = depth[u] - depth[head[u]] + 1;
                if (k <= distOnChain) {
                    // 第k个节点在当前链上
                    return getNodeByPos(pos[u] - k + 1);
                } else {
                    k -= distOnChain;
                    u = parent[head[u]];
                }
            }
        }
    }
    
    static int getNodeByPos(int pos) {
        // 通过位置找到对应的节点（需要维护反向映射）
        for (int i = 1; i <= n; i++) {
            if (this.pos[i] == pos) {
                return i;
            }
        }
        return -1;
    }
    
    static int querySegTree(int idx, int segL, int segR, int l, int r) {
        if (l > segR || r < segL) return 0;
        if (l <= segL && segR <= r) {
            return segTree[idx];
        }
        int mid = (segL + segR) / 2;
        int leftRes = querySegTree(2 * idx, segL, mid, l, r);
        int rightRes = querySegTree(2 * idx + 1, mid + 1, segR, l, r);
        return leftRes + rightRes;
    }
}

===============================================

文件: SPOJ_QTREE_QueryOnTree.java
===============================================
/**
 * SPOJ QTREE - Query on a tree - Java实现
 * 
 * 题目描述：
 * 给定一棵树，每条边有一个权值。支持两种操作：
 * 1. CHANGE i ti：将第i条边的权值改为ti
 * 2. QUERY a b：询问a到b路径上的最大边权
 * 
 * 输入格式：
 * 第一行：T（测试用例数量）
 * 每个测试用例：
 * - 第一行：n（节点数量）
 * - 接下来n-1行：每行三个整数a, b, c，表示a和b之间有一条边，权值为c
 * - 接下来若干行操作，直到遇到"DONE"结束
 * 
 * 输出格式：
 * 对于每个QUERY操作，输出路径上的最大边权
 * 
 * 时间复杂度：
 * - 预处理：O(n)
 * - 查询/更新：O(log²n)
 * 
 * 空间复杂度：O(n)
 * 
 * 题目链接：https://www.spoj.com/problems/QTREE/
 */

import java.util.*;
import java.io.*;

public class SPOJ_QTREE_QueryOnTree {
    static int n;
    static List<Edge>[] tree;
    static Edge[] edges; // 存储所有边
    
    // 树链剖分相关
    static int[] parent, depth, size, heavy, head, pos;
    static int curPos;
    
    // 线段树相关（维护最大值）
    static int[] segTree;
    static int[] arr; // 存储边权（映射到节点）
    
    static class Edge {
        int u, v, w, id;
        Edge(int u, int v, int w, int id) {
            this.u = u;
            this.v = v;
            this.w = w;
            this.id = id;
        }
    }
    
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        int T = Integer.parseInt(br.readLine().trim());
        
        while (T-- > 0) {
            n = Integer.parseInt(br.readLine().trim());
            
            tree = new ArrayList[n + 1];
            for (int i = 0; i <= n; i++) {
                tree[i] = new ArrayList<>();
            }
            
            edges = new Edge[n]; // 边从1到n-1编号
            
            // 读取边
            for (int i = 1; i < n; i++) {
                StringTokenizer st = new StringTokenizer(br.readLine());
                int u = Integer.parseInt(st.nextToken());
                int v = Integer.parseInt(st.nextToken());
                int w = Integer.parseInt(st.nextToken());
                
                Edge edge = new Edge(u, v, w, i);
                edges[i] = edge;
                tree[u].add(edge);
                tree[v].add(edge);
            }
            
            // 初始化树链剖分
            initHLD();
            
            // 处理操作
            while (true) {
                String line = br.readLine().trim();
                if (line.equals("DONE")) break;
                
                StringTokenizer st = new StringTokenizer(line);
                String op = st.nextToken();
                
                if (op.equals("QUERY")) {
                    int a = Integer.parseInt(st.nextToken());
                    int b = Integer.parseInt(st.nextToken());
                    int res = queryPath(a, b);
                    System.out.println(res);
                } else if (op.equals("CHANGE")) {
                    int i = Integer.parseInt(st.nextToken());
                    int ti = Integer.parseInt(st.nextToken());
                    updateEdge(i, ti);
                }
            }
        }
    }
    
    static void initHLD() {
        parent = new int[n + 1];
        depth = new int[n + 1];
        size = new int[n + 1];
        heavy = new int[n + 1];
        head = new int[n + 1];
        pos = new int[n + 1];
        curPos = 0;
        
        segTree = new int[4 * n];
        arr = new int[n + 1];
        
        Arrays.fill(heavy, -1);
        Arrays.fill(head, -1);
        
        // 以1为根节点
        dfs1(1, 0);
        dfs2(1, 1);
        
        // 将边权映射到节点
        mapEdgesToNodes();
        buildSegTree(1, 0, n - 1);
    }
    
    static void dfs1(int u, int p) {
        parent[u] = p;
        depth[u] = depth[p] + 1;
        size[u] = 1;
        
        int maxSize = 0;
        for (Edge edge : tree[u]) {
            int v = (edge.u == u) ? edge.v : edge.u;
            if (v == p) continue;
            dfs1(v, u);
            size[u] += size[v];
            if (size[v] > maxSize) {
                maxSize = size[v];
                heavy[u] = v;
            }
        }
    }
    
    static void dfs2(int u, int h) {
        head[u] = h;
        pos[u] = curPos++;
        
        if (heavy[u] != -1) {
            dfs2(heavy[u], h);
        }
        
        for (Edge edge : tree[u]) {
            int v = (edge.u == u) ? edge.v : edge.u;
            if (v == parent[u] || v == heavy[u]) continue;
            dfs2(v, v);
        }
    }
    
    static void mapEdgesToNodes() {
        // 将边权映射到深度较大的节点
        for (int i = 1; i < n; i++) {
            Edge edge = edges[i];
            int u = edge.u, v = edge.v;
            // 将边权赋给深度较大的节点
            if (depth[u] > depth[v]) {
                arr[pos[u]] = edge.w;
            } else {
                arr[pos[v]] = edge.w;
            }
        }
    }
    
    static void buildSegTree(int idx, int l, int r) {
        if (l == r) {
            segTree[idx] = arr[l];
            return;
        }
        int mid = (l + r) / 2;
        buildSegTree(2 * idx, l, mid);
        buildSegTree(2 * idx + 1, mid + 1, r);
        segTree[idx] = Math.max(segTree[2 * idx], segTree[2 * idx + 1]);
    }
    
    static void updateEdge(int edgeId, int newVal) {
        Edge edge = edges[edgeId];
        int u = edge.u, v = edge.v;
        
        // 找到深度较大的节点
        int nodeToUpdate;
        if (depth[u] > depth[v]) {
            nodeToUpdate = u;
        } else {
            nodeToUpdate = v;
        }
        
        // 更新线段树
        updateSegTree(1, 0, n - 1, pos[nodeToUpdate], newVal);
    }
    
    static int queryPath(int u, int v) {
        int res = 0;
        while (head[u] != head[v]) {
            if (depth[head[u]] < depth[head[v]]) {
                int temp = u;
                u = v;
                v = temp;
            }
            res = Math.max(res, querySegTree(1, 0, n - 1, pos[head[u]], pos[u]));
            u = parent[head[u]];
        }
        if (u == v) return res; // 如果u和v相同，直接返回
        
        if (depth[u] > depth[v]) {
            int temp = u;
            u = v;
            v = temp;
        }
        // 注意：这里查询的是u的儿子到v的路径（因为边权映射在深度较大的节点）
        res = Math.max(res, querySegTree(1, 0, n - 1, pos[u] + 1, pos[v]));
        return res;
    }
    
    static void updateSegTree(int idx, int segL, int segR, int pos, int val) {
        if (segL == segR) {
            segTree[idx] = val;
            arr[pos] = val;
            return;
        }
        int mid = (segL + segR) / 2;
        if (pos <= mid) {
            updateSegTree(2 * idx, segL, mid, pos, val);
        } else {
            updateSegTree(2 * idx + 1, mid + 1, segR, pos, val);
        }
        segTree[idx] = Math.max(segTree[2 * idx], segTree[2 * idx + 1]);
    }
    
    static int querySegTree(int idx, int segL, int segR, int l, int r) {
        if (l > segR || r < segL) return 0;
        if (l <= segL && segR <= r) {
            return segTree[idx];
        }
        int mid = (segL + segR) / 2;
        int leftRes = querySegTree(2 * idx, segL, mid, l, r);
        int rightRes = querySegTree(2 * idx + 1, mid + 1, segR, l, r);
        return Math.max(leftRes, rightRes);
    }
}

===============================================

文件: SubsetEnumeration.java
===============================================
package class175.随机化与复杂度分析;

import java.util.ArrayList;
import java.util.List;

/**
 * 子集枚举算法实现
 * 核心技巧：使用位掩码高效枚举集合的所有子集
 * 时间复杂度：O(2^n)，其中n是元素个数
 */
public class SubsetEnumeration {
    
    /**
     * 枚举mask的所有非空子集
     * 核心公式：for (int sub = mask; sub > 0; sub = (sub - 1) & mask)
     * 
     * @param mask 表示原集合的位掩码
     * @return 所有非空子集的位掩码列表
     */
    public static List<Integer> enumerateAllSubsets(int mask) {
        List<Integer> subsets = new ArrayList<>();
        // 枚举所有非空子集的经典算法
        for (int sub = mask; sub > 0; sub = (sub - 1) & mask) {
            subsets.add(sub);
        }
        return subsets;
    }
    
    /**
     * 枚举大小为k的子集
     * 
     * @param n 集合大小
     * @param k 子集大小
     * @return 所有大小为k的子集的位掩码列表
     */
    public static List<Integer> enumerateSubsetsOfSize(int n, int k) {
        List<Integer> subsets = new ArrayList<>();
        int mask = (1 << k) - 1; // 初始化为k个1
        
        while (mask < (1 << n)) {
            subsets.add(mask);
            
            // Gosper's Hack - 高效生成下一个k元素子集
            int c = mask & -mask;
            int r = mask + c;
            mask = (((r ^ mask) >>> 2) / c) | r;
        }
        
        return subsets;
    }
    
    /**
     * 枚举包含特定元素的子集
     * 
     * @param mask 原集合的位掩码
     * @param requiredElements 必须包含的元素的位掩码
     * @return 包含所有requiredElements的子集的位掩码列表
     */
    public static List<Integer> enumerateSubsetsWithRequired(int mask, int requiredElements) {
        List<Integer> subsets = new ArrayList<>();
        
        // 检查requiredElements是否是mask的子集
        if ((requiredElements & mask) != requiredElements) {
            return subsets; // requiredElements包含mask中没有的元素
        }
        
        // 枚举所有包含requiredElements的子集
        int remaining = mask & (~requiredElements);
        for (int sub = remaining; ; sub = (sub - 1) & remaining) {
            subsets.add(sub | requiredElements);
            if (sub == 0) break;
        }
        
        return subsets;
    }
    
    /**
     * 将位掩码转换为元素索引列表
     * 
     * @param mask 位掩码
     * @return 元素索引列表
     */
    public static List<Integer> maskToIndices(int mask) {
        List<Integer> indices = new ArrayList<>();
        for (int i = 0; i < 32; i++) {
            if ((mask & (1 << i)) != 0) {
                indices.add(i);
            }
        }
        return indices;
    }
    
    /**
     * 计算子集的数量
     * 
     * @param mask 位掩码
     * @return 子集数量（包括空集）
     */
    public static int countSubsets(int mask) {
        return 1 << Integer.bitCount(mask);
    }
    
    /**
     * 主方法，用于测试
     */
    public static void main(String[] args) {
        // 测试1：枚举所有子集
        int mask = 0b1011; // 表示集合{0,1,3}
        System.out.println("原集合(二进制): " + Integer.toBinaryString(mask));
        System.out.println("所有非空子集:");
        List<Integer> subsets = enumerateAllSubsets(mask);
        for (int sub : subsets) {
            System.out.println("  " + Integer.toBinaryString(sub) + " -> " + maskToIndices(sub));
        }
        
        // 测试2：枚举大小为2的子集
        System.out.println("\n大小为2的子集:");
        List<Integer> size2Subsets = enumerateSubsetsOfSize(4, 2);
        for (int sub : size2Subsets) {
            System.out.println("  " + Integer.toBinaryString(sub) + " -> " + maskToIndices(sub));
        }
        
        // 测试3：枚举包含特定元素的子集
        int required = 0b101; // 必须包含元素0和2
        System.out.println("\n包含元素0和2的子集:");
        List<Integer> requiredSubsets = enumerateSubsetsWithRequired(0b1111, required);
        for (int sub : requiredSubsets) {
            System.out.println("  " + Integer.toBinaryString(sub) + " -> " + maskToIndices(sub));
        }
    }
}

===============================================

文件: subset_enumeration.cpp
===============================================
#include <iostream>
#include <vector>
#include <string>

/**
 * 子集枚举算法实现
 * 核心技巧：使用位掩码高效枚举集合的所有子集
 * 时间复杂度：O(2^n)，其中n是元素个数
 */

/**
 * 枚举mask的所有非空子集
 * 核心公式：for (int sub = mask; sub > 0; sub = (sub - 1) & mask)
 * 
 * @param mask 表示原集合的位掩码
 * @return 所有非空子集的位掩码列表
 */
std::vector<int> enumerateAllSubsets(int mask) {
    std::vector<int> subsets;
    // 枚举所有非空子集的经典算法
    for (int sub = mask; sub > 0; sub = (sub - 1) & mask) {
        subsets.push_back(sub);
    }
    return subsets;
}

/**
 * 枚举大小为k的子集
 * 使用Gosper's Hack算法
 * 
 * @param n 集合大小
 * @param k 子集大小
 * @return 所有大小为k的子集的位掩码列表
 */
std::vector<int> enumerateSubsetsOfSize(int n, int k) {
    std::vector<int> subsets;
    if (k == 0 || k > n) {
        return subsets;
    }
    
    int mask = (1 << k) - 1; // 初始化为k个1
    
    while (mask < (1 << n)) {
        subsets.push_back(mask);
        
        // Gosper's Hack - 高效生成下一个k元素子集
        int c = mask & -mask;
        int r = mask + c;
        mask = (((r ^ mask) >> 2) / c) | r;
    }
    
    return subsets;
}

/**
 * 枚举包含特定元素的子集
 * 
 * @param mask 原集合的位掩码
 * @param requiredElements 必须包含的元素的位掩码
 * @return 包含所有requiredElements的子集的位掩码列表
 */
std::vector<int> enumerateSubsetsWithRequired(int mask, int requiredElements) {
    std::vector<int> subsets;
    
    // 检查requiredElements是否是mask的子集
    if ((requiredElements & mask) != requiredElements) {
        return subsets; // requiredElements包含mask中没有的元素
    }
    
    // 枚举所有包含requiredElements的子集
    int remaining = mask & (~requiredElements);
    int sub = remaining;
    while (true) {
        subsets.push_back(sub | requiredElements);
        if (sub == 0) break;
        sub = (sub - 1) & remaining;
    }
    
    return subsets;
}

/**
 * 将位掩码转换为元素索引列表
 * 
 * @param mask 位掩码
 * @return 元素索引列表
 */
std::vector<int> maskToIndices(int mask) {
    std::vector<int> indices;
    for (int i = 0; i < 32; i++) {
        if (mask & (1 << i)) {
            indices.push_back(i);
        }
    }
    return indices;
}

/**
 * 计算子集的数量
 * 
 * @param mask 位掩码
 * @return 子集数量（包括空集）
 */
int countSubsets(int mask) {
    // 使用内置函数计算1的个数
    #ifdef __GNUC__
        int cnt = __builtin_popcount(mask);
    #else
        int cnt = 0;
        for (int x = mask; x; x >>= 1) {
            cnt += x & 1;
        }
    #endif
    return 1 << cnt;
}

/**
 * 将整数转换为二进制字符串
 * 
 * @param num 整数
 * @return 二进制字符串
 */
std::string toBinaryString(int num) {
    if (num == 0) return "0";
    std::string result;
    while (num > 0) {
        result = (num % 2 ? '1' : '0') + result;
        num /= 2;
    }
    return result;
}

/**
 * 打印索引列表
 * 
 * @param indices 索引列表
 */
void printIndices(const std::vector<int>& indices) {
    std::cout << "[";
    for (size_t i = 0; i < indices.size(); i++) {
        std::cout << indices[i];
        if (i < indices.size() - 1) {
            std::cout << ", ";
        }
    }
    std::cout << "]";
}

int main() {
    // 测试1：枚举所有子集
    int mask = 0b1011; // 表示集合{0,1,3}
    std::cout << "原集合(二进制): " << toBinaryString(mask) << std::endl;
    std::cout << "所有非空子集:" << std::endl;
    std::vector<int> subsets = enumerateAllSubsets(mask);
    for (int sub : subsets) {
        std::cout << "  " << toBinaryString(sub) << " -> ";
        printIndices(maskToIndices(sub));
        std::cout << std::endl;
    }
    
    // 测试2：枚举大小为2的子集
    std::cout << "\n大小为2的子集:" << std::endl;
    std::vector<int> size2Subsets = enumerateSubsetsOfSize(4, 2);
    for (int sub : size2Subsets) {
        std::cout << "  " << toBinaryString(sub) << " -> ";
        printIndices(maskToIndices(sub));
        std::cout << std::endl;
    }
    
    // 测试3：枚举包含特定元素的子集
    int required = 0b101; // 必须包含元素0和2
    std::cout << "\n包含元素0和2的子集:" << std::endl;
    std::vector<int> requiredSubsets = enumerateSubsetsWithRequired(0b1111, required);
    for (int sub : requiredSubsets) {
        std::cout << "  " << toBinaryString(sub) << " -> ";
        printIndices(maskToIndices(sub));
        std::cout << std::endl;
    }
    
    return 0;
}

===============================================

文件: subset_enumeration.py
===============================================
#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
子集枚举算法实现
核心技巧：使用位掩码高效枚举集合的所有子集
时间复杂度：O(2^n)，其中n是元素个数
"""

def enumerate_all_subsets(mask):
    """
    枚举mask的所有非空子集
    核心公式：sub = (sub - 1) & mask
    
    Args:
        mask: 表示原集合的位掩码
    
    Returns:
        list: 所有非空子集的位掩码列表
    """
    subsets = []
    sub = mask
    while sub > 0:
        subsets.append(sub)
        sub = (sub - 1) & mask
    return subsets

def enumerate_subsets_of_size(n, k):
    """
    枚举大小为k的子集
    使用Gosper's Hack算法
    
    Args:
        n: 集合大小
        k: 子集大小
    
    Returns:
        list: 所有大小为k的子集的位掩码列表
    """
    subsets = []
    if k == 0 or k > n:
        return subsets
    
    mask = (1 << k) - 1  # 初始化为k个1
    
    while mask < (1 << n):
        subsets.append(mask)
        
        # Gosper's Hack - 高效生成下一个k元素子集
        c = mask & -mask  # 最低位的1
        r = mask + c
        mask = (((r ^ mask) >> 2) // c) | r
    
    return subsets

def enumerate_subsets_with_required(mask, required_elements):
    """
    枚举包含特定元素的子集
    
    Args:
        mask: 原集合的位掩码
        required_elements: 必须包含的元素的位掩码
    
    Returns:
        list: 包含所有required_elements的子集的位掩码列表
    """
    subsets = []
    
    # 检查required_elements是否是mask的子集
    if (required_elements & mask) != required_elements:
        return subsets  # required_elements包含mask中没有的元素
    
    # 枚举所有包含required_elements的子集
    remaining = mask & (~required_elements)
    sub = remaining
    while True:
        subsets.append(sub | required_elements)
        if sub == 0:
            break
        sub = (sub - 1) & remaining
    
    return subsets

def mask_to_indices(mask):
    """
    将位掩码转换为元素索引列表
    
    Args:
        mask: 位掩码
    
    Returns:
        list: 元素索引列表
    """
    indices = []
    i = 0
    while mask > 0:
        if mask & 1:
            indices.append(i)
        mask >>= 1
        i += 1
    return indices

def count_subsets(mask):
    """
    计算子集的数量
    
    Args:
        mask: 位掩码
    
    Returns:
        int: 子集数量（包括空集）
    """
    return 1 << bin(mask).count('1')

def test_subset_enumeration():
    """
    测试子集枚举功能
    """
    # 测试1：枚举所有子集
    mask = 0b1011  # 表示集合{0,1,3}
    print(f"原集合(二进制): {bin(mask)}")
    print("所有非空子集:")
    subsets = enumerate_all_subsets(mask)
    for sub in subsets:
        print(f"  {bin(sub)} -> {mask_to_indices(sub)}")
    
    # 测试2：枚举大小为2的子集
    print("\n大小为2的子集:")
    size2_subsets = enumerate_subsets_of_size(4, 2)
    for sub in size2_subsets:
        print(f"  {bin(sub)} -> {mask_to_indices(sub)}")
    
    # 测试3：枚举包含特定元素的子集
    required = 0b101  # 必须包含元素0和2
    print("\n包含元素0和2的子集:")
    required_subsets = enumerate_subsets_with_required(0b1111, required)
    for sub in required_subsets:
        print(f"  {bin(sub)} -> {mask_to_indices(sub)}")

if __name__ == "__main__":
    test_subset_enumeration()

===============================================

文件: test_compression.py
===============================================
#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
压缩算法综合测试脚本
用于测试所有Python实现的压缩算法功能
"""

import sys
import os

def test_arithmetic_coding():
    """测试算术编码"""
    print("=== 测试算术编码 ===")
    try:
        # 更新导入路径以适应新的目录结构
        arithmetic_coding_path = os.path.join(os.path.dirname(__file__), "arithmetic_coding")
        if arithmetic_coding_path not in sys.path:
            sys.path.append(arithmetic_coding_path)
        
        import arithmetic_coding
        test_string = "ABRACADABRA"
        print(f"原始字符串: {test_string}")
        
        # 编码
        ac = arithmetic_coding.ArithmeticCoding(test_string)
        encoded = ac.encode(test_string)
        print(f"编码结果: {encoded}")
        
        # 解码
        decoded = ac.decode(encoded, len(test_string) + 1)
        print(f"解码结果: {decoded}")
        
        # 验证
        success = test_string == decoded
        print(f"编码解码是否正确: {success}")
        
        if success:
            print("✓ 算术编码测试通过")
            return True
        else:
            print("✗ 算术编码测试失败")
            return False
    except Exception as e:
        print(f"✗ 算术编码测试出错: {e}")
        return False

def test_lzw_encoding():
    """测试LZW编码"""
    print("\n=== 测试LZW编码 ===")
    try:
        # 更新导入路径以适应新的目录结构
        lzw_encoding_path = os.path.join(os.path.dirname(__file__), "lzw_encoding")
        if lzw_encoding_path not in sys.path:
            sys.path.append(lzw_encoding_path)
        
        import lzw_encoding
        test_string = "ABABABA"
        print(f"原始字符串: {test_string}")
        
        # 编码
        encoded = lzw_encoding.lzw_encode(test_string)
        print(f"编码结果: {encoded}")
        
        # 解码
        decoded = lzw_encoding.lzw_decode(encoded)
        print(f"解码结果: {decoded}")
        
        # 验证
        success = test_string == decoded
        print(f"编码解码是否正确: {success}")
        
        if success:
            print("✓ LZW编码测试通过")
            return True
        else:
            print("✗ LZW编码测试失败")
            return False
    except Exception as e:
        print(f"✗ LZW编码测试出错: {e}")
        return False

def test_huffman_encoding():
    """测试Huffman编码"""
    print("\n=== 测试Huffman编码 ===")
    try:
        # 更新导入路径以适应新的目录结构
        huffman_encoding_path = os.path.join(os.path.dirname(__file__), "huffman_encoding")
        if huffman_encoding_path not in sys.path:
            sys.path.append(huffman_encoding_path)
        
        import huffman_encoding
        test_string = "ABRACADABRA"
        print(f"原始字符串: {test_string}")
        
        # 编码
        result = huffman_encoding.encode(test_string)
        print(f"Huffman编码表:")
        for char, code in result.huffman_codes.items():
            print(f"  {char}: {code}")
        print(f"编码结果: {result.encoded_data}")
        
        # 解码
        decoded = huffman_encoding.decode(result.encoded_data, result.huffman_codes)
        print(f"解码结果: {decoded}")
        
        # 验证
        success = test_string == decoded
        print(f"编码解码是否正确: {success}")
        
        if success:
            print("✓ Huffman编码测试通过")
            return True
        else:
            print("✗ Huffman编码测试失败")
            return False
    except Exception as e:
        print(f"✗ Huffman编码测试出错: {e}")
        return False

def main():
    """主测试函数"""
    print("========================================")
    print("     压缩算法综合测试脚本")
    print("========================================")
    
    # 切换到当前目录
    script_dir = os.path.dirname(os.path.abspath(__file__))
    os.chdir(script_dir)
    
    # 统计测试结果
    passed_tests = 0
    total_tests = 3
    
    # 测试算术编码
    if test_arithmetic_coding():
        passed_tests += 1
    
    # 测试LZW编码
    if test_lzw_encoding():
        passed_tests += 1
    
    # 测试Huffman编码
    if test_huffman_encoding():
        passed_tests += 1
    
    # 输出测试结果
    print("\n========================================")
    print(f"测试完成: {passed_tests}/{total_tests} 个测试通过")
    
    if passed_tests == total_tests:
        print("🎉 所有测试通过!")
        return 0
    else:
        print("❌ 部分测试失败!")
        return 1

if __name__ == "__main__":
    sys.exit(main())

===============================================

文件: ToomCookMultiplication.java
===============================================
package class175.随机化与复杂度分析;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Scanner;

/**
 * Toom-Cook乘法算法实现
 * 是Karatsuba算法的一般化，通过更高阶的分治策略进一步降低时间复杂度
 * 传统乘法: O(n²)，Karatsuba: O(n^1.585)，Toom-Cook (k=3): O(n^1.465)
 * 适用于高精度大整数乘法计算
 */
public class ToomCookMultiplication {

    /**
     * 使用传统方法进行大整数乘法
     * 时间复杂度：O(n²)
     * 作为Toom-Cook算法的基础情况
     * 
     * @param x 第一个整数的数字数组表示（低位在前）
     * @param y 第二个整数的数字数组表示（低位在前）
     * @return 乘积的数字数组表示（低位在前）
     */
    public static int[] naiveMultiply(int[] x, int[] y) {
        int n = x.length;
        int m = y.length;
        int[] result = new int[n + m];

        // 逐位相乘并累加
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++) {
                result[i + j] += x[i] * y[j];
                // 处理进位
                result[i + j + 1] += result[i + j] / 10;
                result[i + j] %= 10;
            }
        }

        // 移除前导零
        int lastNonZero = n + m - 1;
        while (lastNonZero > 0 && result[lastNonZero] == 0) {
            lastNonZero--;
        }

        return Arrays.copyOfRange(result, 0, lastNonZero + 1);
    }

    /**
     * 使用Toom-Cook乘法算法进行大整数乘法
     * 这里实现了Toom-3算法，是Toom-Cook的三阶版本
     * 时间复杂度：O(n^log₃5) ≈ O(n^1.465)
     * 
     * @param x 第一个整数的字符串表示
     * @param y 第二个整数的字符串表示
     * @return 乘积的字符串表示
     */
    public static String toomCookMultiply(String x, String y) {
        // 处理特殊情况
        if (x.equals("0") || y.equals("0")) {
            return "0";
        }
        if (x.equals("1")) {
            return y;
        }
        if (y.equals("1")) {
            return x;
        }

        // 将字符串转换为数字数组（低位在前）
        int[] xDigits = stringToDigits(x);
        int[] yDigits = stringToDigits(y);

        // 调用递归Toom-Cook算法
        int[] product = toomCookMultiplyRecursive(xDigits, yDigits);

        // 移除前导零并转换为字符串
        return digitsToString(product);
    }

    /**
     * Toom-Cook (Toom-3) 递归乘法实现
     * 
     * @param x 第一个整数的数字数组表示（低位在前）
     * @param y 第二个整数的数字数组表示（低位在前）
     * @return 乘积的数字数组表示（低位在前）
     */
    private static int[] toomCookMultiplyRecursive(int[] x, int[] y) {
        int n = Math.max(x.length, y.length);
        
        // 基础情况：当数组长度较小时，使用传统乘法
        if (n <= 128) { // 阈值可以根据实际情况调整
            return naiveMultiply(x, y);
        }

        // 计算分割点，将数字分成三个部分
        int m = (n + 2) / 3; // 向上取整到3

        // 分割x为三个部分: x = x2*10^(2*m) + x1*10^m + x0
        int[] x0 = Arrays.copyOfRange(x, 0, Math.min(m, x.length));
        int[] x1 = (m < x.length) ? Arrays.copyOfRange(x, m, Math.min(2*m, x.length)) : new int[0];
        int[] x2 = (2*m < x.length) ? Arrays.copyOfRange(x, 2*m, x.length) : new int[0];

        // 分割y为三个部分: y = y2*10^(2*m) + y1*10^m + y0
        int[] y0 = Arrays.copyOfRange(y, 0, Math.min(m, y.length));
        int[] y1 = (m < y.length) ? Arrays.copyOfRange(y, m, Math.min(2*m, y.length)) : new int[0];
        int[] y2 = (2*m < y.length) ? Arrays.copyOfRange(y, 2*m, y.length) : new int[0];

        // 计算f(k)和g(k)在k=-1,0,1,2,∞处的值
        // f(0) = x0, f(1) = x0+x1+x2, f(-1) = x0-x1+x2, f(2) = x0+2x1+4x2, f(∞) = x2
        // g(0) = y0, g(1) = y0+y1+y2, g(-1) = y0-y1+y2, g(2) = y0+2y1+4y2, g(∞) = y2
        int[] f0 = x0;
        int[] f1 = addArrays(addArrays(x0, x1), x2);
        int[] fNeg1 = addArrays(subtractArrays(x0, x1), x2);
        int[] f2 = addArrays(addArrays(x0, multiplyByPowerOfTwo(x1, 1)), multiplyByPowerOfTwo(x2, 2));
        int[] fInfty = x2;

        int[] g0 = y0;
        int[] g1 = addArrays(addArrays(y0, y1), y2);
        int[] gNeg1 = addArrays(subtractArrays(y0, y1), y2);
        int[] g2 = addArrays(addArrays(y0, multiplyByPowerOfTwo(y1, 1)), multiplyByPowerOfTwo(y2, 2));
        int[] gInfty = y2;

        // 计算乘积h(k) = f(k)*g(k) 在各点的值
        int[] h0 = toomCookMultiplyRecursive(f0, g0); // h(0) = x0*y0
        int[] h1 = toomCookMultiplyRecursive(f1, g1); // h(1) = (x0+x1+x2)*(y0+y1+y2)
        int[] hNeg1 = toomCookMultiplyRecursive(fNeg1, gNeg1); // h(-1) = (x0-x1+x2)*(y0-y1+y2)
        int[] h2 = toomCookMultiplyRecursive(f2, g2); // h(2) = (x0+2x1+4x2)*(y0+2y1+4y2)
        int[] hInfty = toomCookMultiplyRecursive(fInfty, gInfty); // h(∞) = x2*y2

        // 使用拉格朗日插值法求解多项式系数
        // h(z) = z^4*h_4 + z^3*h_3 + z^2*h_2 + z*h_1 + h_0
        // 其中h_4 = hInfty

        // 计算中间值
        int[] a = h1; // h(1)
        int[] b = hNeg1; // h(-1)
        int[] c = h2; // h(2)
        int[] d = h0; // h(0)

        // 通过插值公式计算h3, h2, h1
        // h3 = (c - 8a + 6b - d) / 6
        int[] term1 = subtractArrays(c, multiplyByPowerOfTwo(a, 3)); // c - 8a
        int[] term2 = multiplyByPowerOfTwo(b, 2) + multiplyByPowerOfTwo(b, 1); // 6b
        int[] numerator = subtractArrays(addArrays(term1, term2), d);
        int[] h3 = divideBySix(numerator);

        // h2 = (a + b - 2d - 6h3 - 2h4) / 2
        int[] h4 = hInfty;
        int[] term3 = addArrays(a, b);
        int[] term4 = addArrays(multiplyByPowerOfTwo(d, 1), multiplyByPowerOfTwo(multiplyByPowerOfTwo(h3, 2) + h3, 1)); // 2d + 6h3
        int[] term5 = multiplyByPowerOfTwo(h4, 1); // 2h4
        numerator = subtractArrays(subtractArrays(term3, term4), term5);
        int[] h2 = divideByTwo(numerator);

        // h1 = (a - b) / 2 - 2h3 - 3h4
        term1 = divideByTwo(subtractArrays(a, b));
        term2 = addArrays(multiplyByPowerOfTwo(h3, 1), multiplyByPowerOfTwo(h4, 1) + h4); // 2h3 + 3h4
        int[] h1_coeff = subtractArrays(term1, term2);

        // 现在我们有了所有系数：h4, h3, h2, h1, h0
        // 组合结果: h4*10^(4*m) + h3*10^(3*m) + h2*10^(2*m) + h1*10^m + h0
        int[] result = new int[5 * m]; // 可能需要调整大小

        // 添加各部分到结果中
        addToResult(result, h0, 0);
        addToResult(result, h1_coeff, m);
        addToResult(result, h2, 2 * m);
        addToResult(result, h3, 3 * m);
        addToResult(result, h4, 4 * m);

        // 移除前导零
        int lastNonZero = result.length - 1;
        while (lastNonZero > 0 && result[lastNonZero] == 0) {
            lastNonZero--;
        }

        return Arrays.copyOfRange(result, 0, lastNonZero + 1);
    }

    /**
     * 将数字数组添加到结果数组的指定位置
     * 
     * @param result 结果数组
     * @param addend 要添加的数字数组
     * @param offset 起始位置
     */
    private static void addToResult(int[] result, int[] addend, int offset) {
        int newLength = Math.max(result.length, addend.length + offset);
        if (newLength > result.length) {
            result = Arrays.copyOf(result, newLength);
        }

        for (int i = 0; i < addend.length; i++) {
            if (i + offset < result.length) {
                result[i + offset] += addend[i];
                // 处理进位
                propagateCarry(result, i + offset);
            }
        }
    }

    /**
     * 处理进位传播
     * 
     * @param arr 数字数组
     * @param pos 起始处理位置
     */
    private static void propagateCarry(int[] arr, int pos) {
        while (pos < arr.length - 1 && arr[pos] >= 10) {
            arr[pos + 1] += arr[pos] / 10;
            arr[pos] %= 10;
            pos++;
        }
        // 处理最高位的进位（如果需要）
        // 在这个方法中，我们假设arr足够大，不需要扩展
    }

    /**
     * 对两个数字数组进行加法操作
     * 
     * @param a 第一个数字数组（低位在前）
     * @param b 第二个数字数组（低位在前）
     * @return 和的数字数组（低位在前）
     */
    private static int[] addArrays(int[] a, int[] b) {
        int maxLength = Math.max(a.length, b.length);
        int[] result = new int[maxLength + 1]; // 预留进位空间

        for (int i = 0; i < maxLength; i++) {
            int digitA = (i < a.length) ? a[i] : 0;
            int digitB = (i < b.length) ? b[i] : 0;
            result[i] = digitA + digitB;

            // 处理进位
            result[i + 1] += result[i] / 10;
            result[i] %= 10;
        }

        // 移除前导零
        int lastNonZero = maxLength;
        while (lastNonZero > 0 && result[lastNonZero] == 0) {
            lastNonZero--;
        }

        return Arrays.copyOfRange(result, 0, lastNonZero + 1);
    }

    /**
     * 对两个数字数组进行减法操作
     * 假设 a >= b
     * 
     * @param a 被减数的数字数组（低位在前）
     * @param b 减数的数字数组（低位在前）
     * @return 差的数字数组（低位在前）
     */
    private static int[] subtractArrays(int[] a, int[] b) {
        int[] result = new int[a.length];

        for (int i = 0; i < b.length; i++) {
            result[i] = a[i] - b[i];
        }
        
        for (int i = b.length; i < a.length; i++) {
            result[i] = a[i];
        }

        // 处理借位
        for (int i = 0; i < result.length - 1; i++) {
            while (result[i] < 0) {
                result[i] += 10;
                result[i + 1]--;
            }
        }

        // 移除前导零
        int lastNonZero = result.length - 1;
        while (lastNonZero > 0 && result[lastNonZero] == 0) {
            lastNonZero--;
        }

        return Arrays.copyOfRange(result, 0, lastNonZero + 1);
    }

    /**
     * 将数字数组乘以2的幂（乘以2^power）
     * 
     * @param arr 数字数组（低位在前）
     * @param power 2的幂次
     * @return 结果数组（低位在前）
     */
    private static int[] multiplyByPowerOfTwo(int[] arr, int power) {
        int[] result = Arrays.copyOf(arr, arr.length);
        
        for (int p = 0; p < power; p++) {
            int carry = 0;
            for (int i = 0; i < result.length; i++) {
                int product = result[i] * 2 + carry;
                result[i] = product % 10;
                carry = product / 10;
            }
            if (carry > 0) {
                result = Arrays.copyOf(result, result.length + 1);
                result[result.length - 1] = carry;
            }
        }
        
        return result;
    }

    /**
     * 将数字数组除以2
     * 
     * @param arr 数字数组（低位在前）
     * @return 结果数组（低位在前）
     */
    private static int[] divideByTwo(int[] arr) {
        int[] result = new int[arr.length];
        int remainder = 0;
        
        // 从高位开始除（数组的末尾）
        for (int i = arr.length - 1; i >= 0; i--) {
            int current = arr[i] + remainder * 10;
            result[i] = current / 2;
            remainder = current % 2;
        }
        
        // 移除前导零
        int lastNonZero = result.length - 1;
        while (lastNonZero > 0 && result[lastNonZero] == 0) {
            lastNonZero--;
        }
        
        return Arrays.copyOfRange(result, 0, lastNonZero + 1);
    }

    /**
     * 将数字数组除以6
     * 
     * @param arr 数字数组（低位在前）
     * @return 结果数组（低位在前）
     */
    private static int[] divideBySix(int[] arr) {
        int[] result = new int[arr.length];
        int remainder = 0;
        
        // 从高位开始除（数组的末尾）
        for (int i = arr.length - 1; i >= 0; i--) {
            int current = arr[i] + remainder * 10;
            result[i] = current / 6;
            remainder = current % 6;
        }
        
        // 移除前导零
        int lastNonZero = result.length - 1;
        while (lastNonZero > 0 && result[lastNonZero] == 0) {
            lastNonZero--;
        }
        
        return Arrays.copyOfRange(result, 0, lastNonZero + 1);
    }

    /**
     * 将字符串转换为数字数组（低位在前）
     * 
     * @param s 数字字符串
     * @return 数字数组（低位在前）
     */
    private static int[] stringToDigits(String s) {
        int[] digits = new int[s.length()];
        for (int i = 0; i < s.length(); i++) {
            digits[i] = s.charAt(s.length() - 1 - i) - '0';
        }
        return digits;
    }

    /**
     * 将数字数组转换为字符串（低位在前转换为正常表示）
     * 
     * @param digits 数字数组（低位在前）
     * @return 数字字符串
     */
    private static String digitsToString(int[] digits) {
        StringBuilder sb = new StringBuilder();
        for (int i = digits.length - 1; i >= 0; i--) {
            sb.append(digits[i]);
        }
        return sb.toString();
    }

    /**
     * 性能测试方法，比较Toom-Cook算法与其他算法
     * 
     * @param size 测试数字的位数
     */
    public static void benchmark(int size) {
        // 生成测试用的大整数
        String num1 = generateRandomNumber(size);
        String num2 = generateRandomNumber(size);

        // 测试Toom-Cook算法
        long startTime = System.currentTimeMillis();
        String resultToomCook = toomCookMultiply(num1, num2);
        long toomCookTime = System.currentTimeMillis() - startTime;

        // 测试Karatsuba算法
        startTime = System.currentTimeMillis();
        String resultKaratsuba = KaratsubaMultiplication.karatsubaMultiply(num1, num2);
        long karatsubaTime = System.currentTimeMillis() - startTime;

        // 测试传统算法（对于较小的数字）
        String resultNaive = "";
        long naiveTime = 0;
        if (size <= 500) { // 对于大数字，传统算法可能太慢
            int[] digits1 = stringToDigits(num1);
            int[] digits2 = stringToDigits(num2);
            startTime = System.currentTimeMillis();
            int[] naiveResult = naiveMultiply(digits1, digits2);
            resultNaive = digitsToString(naiveResult);
            naiveTime = System.currentTimeMillis() - startTime;
        }

        System.out.println("数字位数: " + size);
        System.out.println("Toom-Cook算法耗时: " + toomCookTime + " ms");
        System.out.println("Karatsuba算法耗时: " + karatsubaTime + " ms");
        System.out.println("算法加速比 (Karatsuba/Toom-Cook): " + (double) karatsubaTime / toomCookTime + "x");
        
        if (size <= 500) {
            System.out.println("传统算法耗时: " + naiveTime + " ms");
            System.out.println("算法加速比 (传统/Toom-Cook): " + (double) naiveTime / toomCookTime + "x");
            System.out.println("结果一致 (Toom-Cook vs 传统): " + resultToomCook.equals(resultNaive));
        }
        System.out.println("结果一致 (Toom-Cook vs Karatsuba): " + resultToomCook.equals(resultKaratsuba));
        System.out.println("乘积位数: " + resultToomCook.length());
    }

    /**
     * 生成指定长度的随机数字字符串
     * 
     * @param length 字符串长度
     * @return 随机数字字符串
     */
    private static String generateRandomNumber(int length) {
        StringBuilder sb = new StringBuilder();
        // 第一位不能是0
        sb.append((char) ('1' + Math.random() * 9));
        // 生成剩余位
        for (int i = 1; i < length; i++) {
            sb.append((char) ('0' + Math.random() * 10));
        }
        return sb.toString();
    }

    /**
     * 验证算法正确性
     */
    public static void verifyCorrectness() {
        List<String[]> testCases = new ArrayList<>();
        testCases.add(new String[]{"1234", "5678"});
        testCases.add(new String[]{"9999", "9999"});
        testCases.add(new String[]{"0", "12345"});
        testCases.add(new String[]{"1", "98765"});
        testCases.add(new String[]{"999999", "999999"});

        for (String[] testCase : testCases) {
            String x = testCase[0];
            String y = testCase[1];
            
            // 使用Toom-Cook算法
            String result = toomCookMultiply(x, y);
            
            // 对于小数字，使用Java内置的大整数类验证
            if (x.length() <= 20 && y.length() <= 20) { // 确保可以放入long
                long num1 = Long.parseLong(x);
                long num2 = Long.parseLong(y);
                String expected = String.valueOf(num1 * num2);
                System.out.println(x + " * " + y + " = " + result + 
                                  " (正确: " + result.equals(expected) + ")");
            } else {
                System.out.println(x + " * " + y + " = " + result);
                System.out.println("乘积位数: " + result.length());
            }
        }
    }

    public static void main(String[] args) {
        System.out.println("验证算法正确性:");
        verifyCorrectness();
        
        System.out.println("\n性能测试:");
        benchmark(100);
        benchmark(1000);
        benchmark(5000);
        
        // 交互式测试
        Scanner scanner = new Scanner(System.in);
        System.out.println("\n请输入两个大整数进行乘法计算（输入exit退出）:");
        while (true) {
            System.out.print("第一个数: ");
            String num1 = scanner.nextLine();
            if (num1.equalsIgnoreCase("exit")) break;
            
            System.out.print("第二个数: ");
            String num2 = scanner.nextLine();
            if (num2.equalsIgnoreCase("exit")) break;
            
            long startTime = System.currentTimeMillis();
            String result = toomCookMultiply(num1, num2);
            long endTime = System.currentTimeMillis();
            
            System.out.println("结果: " + result);
            System.out.println("计算耗时: " + (endTime - startTime) + " ms");
        }
        scanner.close();
    }
}

===============================================

文件: toom_cook_multiplication.cpp
===============================================
#include <iostream>
#include <vector>
#include <string>
#include <algorithm>
#include <ctime>
#include <random>
#include <chrono>

/**
 * Toom-Cook乘法算法实现
 * 是Karatsuba算法的一般化，通过更高阶的分治策略进一步降低时间复杂度
 * 传统乘法: O(n²)，Karatsuba: O(n^1.585)，Toom-Cook (k=3): O(n^1.465)
 * 适用于高精度大整数乘法计算
 */

using namespace std;
using namespace std::chrono;

/**
 * 使用传统方法进行大整数乘法
 * 时间复杂度：O(n²)
 * 作为Toom-Cook算法的基础情况
 * 
 * @param x 第一个整数的数字向量表示（低位在前）
 * @param y 第二个整数的数字向量表示（低位在前）
 * @return 乘积的数字向量表示（低位在前）
 */
vector<int> naiveMultiply(const vector<int>& x, const vector<int>& y) {
    int n = x.size();
    int m = y.size();
    vector<int> result(n + m, 0);

    // 逐位相乘并累加
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < m; j++) {
            result[i + j] += x[i] * y[j];
            // 处理进位
            result[i + j + 1] += result[i + j] / 10;
            result[i + j] %= 10;
        }
    }

    // 移除前导零
    int lastNonZero = n + m - 1;
    while (lastNonZero > 0 && result[lastNonZero] == 0) {
        lastNonZero--;
    }

    return vector<int>(result.begin(), result.begin() + lastNonZero + 1);
}

/**
 * 将数字向量添加到结果向量的指定位置
 * 
 * @param result 结果向量
 * @param addend 要添加的数字向量
 * @param offset 起始位置
 */
void addToResult(vector<int>& result, const vector<int>& addend, int offset) {
    int newLength = max((int)result.size(), (int)(addend.size() + offset));
    if (newLength > (int)result.size()) {
        result.resize(newLength, 0);
    }

    for (int i = 0; i < (int)addend.size(); i++) {
        if (i + offset < (int)result.size()) {
            result[i + offset] += addend[i];
            // 处理进位
            int pos = i + offset;
            while (pos < (int)result.size() - 1 && result[pos] >= 10) {
                result[pos + 1] += result[pos] / 10;
                result[pos] %= 10;
                pos++;
            }
            // 处理最高位的进位
            if (pos == (int)result.size() - 1 && result[pos] >= 10) {
                int carry = result[pos] / 10;
                result[pos] %= 10;
                result.push_back(carry);
            }
        }
    }
}

/**
 * 对两个数字向量进行加法操作
 * 
 * @param a 第一个数字向量（低位在前）
 * @param b 第二个数字向量（低位在前）
 * @return 和的数字向量（低位在前）
 */
vector<int> addLists(const vector<int>& a, const vector<int>& b) {
    int maxLength = max((int)a.size(), (int)b.size());
    vector<int> result(maxLength + 1, 0);

    for (int i = 0; i < maxLength; i++) {
        int digitA = (i < (int)a.size()) ? a[i] : 0;
        int digitB = (i < (int)b.size()) ? b[i] : 0;
        result[i] = digitA + digitB;

        // 处理进位
        result[i + 1] += result[i] / 10;
        result[i] %= 10;
    }

    // 移除前导零
    int lastNonZero = maxLength;
    while (lastNonZero > 0 && result[lastNonZero] == 0) {
        lastNonZero--;
    }

    return vector<int>(result.begin(), result.begin() + lastNonZero + 1);
}

/**
 * 对两个数字向量进行减法操作
 * 假设 a >= b
 * 
 * @param a 被减数的数字向量（低位在前）
 * @param b 减数的数字向量（低位在前）
 * @return 差的数字向量（低位在前）
 */
vector<int> subtractLists(const vector<int>& a, const vector<int>& b) {
    vector<int> result(a.begin(), a.end());

    for (int i = 0; i < (int)b.size(); i++) {
        result[i] -= b[i];
    }

    // 处理借位
    for (int i = 0; i < (int)result.size() - 1; i++) {
        while (result[i] < 0) {
            result[i] += 10;
            result[i + 1]--;
        }
    }

    // 移除前导零
    int lastNonZero = result.size() - 1;
    while (lastNonZero > 0 && result[lastNonZero] == 0) {
        lastNonZero--;
    }

    return vector<int>(result.begin(), result.begin() + lastNonZero + 1);
}

/**
 * 将数字向量乘以2的幂（乘以2^power）
 * 
 * @param arr 数字向量（低位在前）
 * @param power 2的幂次
 * @return 结果向量（低位在前）
 */
vector<int> multiplyByPowerOfTwo(const vector<int>& arr, int power) {
    vector<int> result(arr.begin(), arr.end());
    
    for (int p = 0; p < power; p++) {
        int carry = 0;
        for (int i = 0; i < (int)result.size(); i++) {
            int product = result[i] * 2 + carry;
            result[i] = product % 10;
            carry = product / 10;
        }
        if (carry > 0) {
            result.push_back(carry);
        }
    }
    
    return result;
}

/**
 * 将数字向量除以2
 * 
 * @param arr 数字向量（低位在前）
 * @return 结果向量（低位在前）
 */
vector<int> divideByTwo(const vector<int>& arr) {
    vector<int> result(arr.size(), 0);
    int remainder = 0;
    
    // 从高位开始除（向量的末尾）
    for (int i = arr.size() - 1; i >= 0; i--) {
        int current = arr[i] + remainder * 10;
        result[i] = current / 2;
        remainder = current % 2;
    }
    
    // 移除前导零
    int lastNonZero = result.size() - 1;
    while (lastNonZero > 0 && result[lastNonZero] == 0) {
        lastNonZero--;
    }
    
    return vector<int>(result.begin(), result.begin() + lastNonZero + 1);
}

/**
 * 将数字向量除以6
 * 
 * @param arr 数字向量（低位在前）
 * @return 结果向量（低位在前）
 */
vector<int> divideBySix(const vector<int>& arr) {
    vector<int> result(arr.size(), 0);
    int remainder = 0;
    
    // 从高位开始除（向量的末尾）
    for (int i = arr.size() - 1; i >= 0; i--) {
        int current = arr[i] + remainder * 10;
        result[i] = current / 6;
        remainder = current % 6;
    }
    
    // 移除前导零
    int lastNonZero = result.size() - 1;
    while (lastNonZero > 0 && result[lastNonZero] == 0) {
        lastNonZero--;
    }
    
    return vector<int>(result.begin(), result.begin() + lastNonZero + 1);
}

/**
 * 将字符串转换为数字向量（低位在前）
 * 
 * @param s 数字字符串
 * @return 数字向量（低位在前）
 */
vector<int> stringToDigits(const string& s) {
    vector<int> digits;
    digits.reserve(s.size());
    for (int i = 0; i < (int)s.size(); i++) {
        digits.push_back(s[s.size() - 1 - i] - '0');
    }
    return digits;
}

/**
 * 将数字向量转换为字符串（低位在前转换为正常表示）
 * 
 * @param digits 数字向量（低位在前）
 * @return 数字字符串
 */
string digitsToString(const vector<int>& digits) {
    string result;
    result.reserve(digits.size());
    for (int i = digits.size() - 1; i >= 0; i--) {
        result.push_back(digits[i] + '0');
    }
    return result;
}

/**
 * Toom-Cook (Toom-3) 递归乘法实现
 * 
 * @param x 第一个整数的数字向量表示（低位在前）
 * @param y 第二个整数的数字向量表示（低位在前）
 * @return 乘积的数字向量表示（低位在前）
 */
vector<int> toomCookMultiplyRecursive(const vector<int>& x, const vector<int>& y) {
    int n = max((int)x.size(), (int)y.size());
    
    // 基础情况：当向量长度较小时，使用传统乘法
    if (n <= 128) { // 阈值可以根据实际情况调整
        return naiveMultiply(x, y);
    }

    // 计算分割点，将数字分成三个部分
    int m = (n + 2) / 3; // 向上取整到3

    // 分割x为三个部分: x = x2*10^(2*m) + x1*10^m + x0
    vector<int> x0(x.begin(), x.begin() + min(m, (int)x.size()));
    vector<int> x1;
    if (m < (int)x.size()) {
        x1 = vector<int>(x.begin() + m, x.begin() + min(2*m, (int)x.size()));
    }
    vector<int> x2;
    if (2*m < (int)x.size()) {
        x2 = vector<int>(x.begin() + 2*m, x.end());
    }

    // 分割y为三个部分: y = y2*10^(2*m) + y1*10^m + y0
    vector<int> y0(y.begin(), y.begin() + min(m, (int)y.size()));
    vector<int> y1;
    if (m < (int)y.size()) {
        y1 = vector<int>(y.begin() + m, y.begin() + min(2*m, (int)y.size()));
    }
    vector<int> y2;
    if (2*m < (int)y.size()) {
        y2 = vector<int>(y.begin() + 2*m, y.end());
    }

    // 计算f(k)和g(k)在k=-1,0,1,2,∞处的值
    // f(0) = x0, f(1) = x0+x1+x2, f(-1) = x0-x1+x2, f(2) = x0+2x1+4x2, f(∞) = x2
    // g(0) = y0, g(1) = y0+y1+y2, g(-1) = y0-y1+y2, g(2) = y0+2y1+4y2, g(∞) = y2
    vector<int> f0 = x0;
    vector<int> f1 = addLists(addLists(x0, x1), x2);
    vector<int> fNeg1 = addLists(subtractLists(x0, x1), x2);
    vector<int> f2 = addLists(addLists(x0, multiplyByPowerOfTwo(x1, 1)), multiplyByPowerOfTwo(x2, 2));
    vector<int> fInfty = x2;

    vector<int> g0 = y0;
    vector<int> g1 = addLists(addLists(y0, y1), y2);
    vector<int> gNeg1 = addLists(subtractLists(y0, y1), y2);
    vector<int> g2 = addLists(addLists(y0, multiplyByPowerOfTwo(y1, 1)), multiplyByPowerOfTwo(y2, 2));
    vector<int> gInfty = y2;

    // 计算乘积h(k) = f(k)*g(k) 在各点的值
    vector<int> h0 = toomCookMultiplyRecursive(f0, g0); // h(0) = x0*y0
    vector<int> h1 = toomCookMultiplyRecursive(f1, g1); // h(1) = (x0+x1+x2)*(y0+y1+y2)
    vector<int> hNeg1 = toomCookMultiplyRecursive(fNeg1, gNeg1); // h(-1) = (x0-x1+x2)*(y0-y1+y2)
    vector<int> h2 = toomCookMultiplyRecursive(f2, g2); // h(2) = (x0+2x1+4x2)*(y0+2y1+4y2)
    vector<int> hInfty = toomCookMultiplyRecursive(fInfty, gInfty); // h(∞) = x2*y2

    // 使用拉格朗日插值法求解多项式系数
    // h(z) = z^4*h_4 + z^3*h_3 + z^2*h_2 + z*h_1 + h_0
    // 其中h_4 = hInfty

    // 计算中间值
    vector<int> a = h1; // h(1)
    vector<int> b = hNeg1; // h(-1)
    vector<int> c = h2; // h(2)
    vector<int> d = h0; // h(0)

    // 通过插值公式计算h3, h2, h1
    // h3 = (c - 8a + 6b - d) / 6
    vector<int> term1 = subtractLists(c, multiplyByPowerOfTwo(a, 3)); // c - 8a
    vector<int> term2 = addLists(multiplyByPowerOfTwo(b, 2), multiplyByPowerOfTwo(b, 1)); // 6b
    vector<int> numerator = subtractLists(addLists(term1, term2), d);
    vector<int> h3 = divideBySix(numerator);

    // h2 = (a + b - 2d - 6h3 - 2h4) / 2
    vector<int> h4 = hInfty;
    vector<int> term3 = addLists(a, b);
    vector<int> term4 = addLists(multiplyByPowerOfTwo(d, 1), 
                                addLists(multiplyByPowerOfTwo(h3, 2), multiplyByPowerOfTwo(h3, 1))); // 2d + 6h3
    vector<int> term5 = multiplyByPowerOfTwo(h4, 1); // 2h4
    numerator = subtractLists(subtractLists(term3, term4), term5);
    vector<int> h2_coeff = divideByTwo(numerator);

    // h1 = (a - b) / 2 - 2h3 - 3h4
    term1 = divideByTwo(subtractLists(a, b));
    term2 = addLists(multiplyByPowerOfTwo(h3, 1), 
                    addLists(multiplyByPowerOfTwo(h4, 1), h4)); // 2h3 + 3h4
    vector<int> h1_coeff = subtractLists(term1, term2);

    // 现在我们有了所有系数：h4, h3, h2, h1, h0
    // 组合结果: h4*10^(4*m) + h3*10^(3*m) + h2*10^(2*m) + h1*10^m + h0
    vector<int> result(5 * m, 0); // 可能需要调整大小

    // 添加各部分到结果中
    addToResult(result, h0, 0);
    addToResult(result, h1_coeff, m);
    addToResult(result, h2_coeff, 2 * m);
    addToResult(result, h3, 3 * m);
    addToResult(result, h4, 4 * m);

    // 移除前导零
    int lastNonZero = result.size() - 1;
    while (lastNonZero > 0 && result[lastNonZero] == 0) {
        lastNonZero--;
    }

    return vector<int>(result.begin(), result.begin() + lastNonZero + 1);
}

/**
 * 使用Toom-Cook乘法算法进行大整数乘法
 * 这里实现了Toom-3算法，是Toom-Cook的三阶版本
 * 时间复杂度：O(n^log₃5) ≈ O(n^1.465)
 * 
 * @param x 第一个整数的字符串表示
 * @param y 第二个整数的字符串表示
 * @return 乘积的字符串表示
 */
string toomCookMultiply(const string& x, const string& y) {
    // 处理特殊情况
    if (x == "0" || y == "0") {
        return "0";
    }
    if (x == "1") {
        return y;
    }
    if (y == "1") {
        return x;
    }

    // 将字符串转换为数字向量（低位在前）
    vector<int> xDigits = stringToDigits(x);
    vector<int> yDigits = stringToDigits(y);

    // 调用递归Toom-Cook算法
    vector<int> product = toomCookMultiplyRecursive(xDigits, yDigits);

    // 移除前导零并转换为字符串
    return digitsToString(product);
}

// Karatsuba算法实现（用于性能比较）
vector<int> karatsubaRecursive(const vector<int>& a, const vector<int>& b);

string karatsubaMultiply(const string& x, const string& y) {
    if (x == "0" || y == "0") {
        return "0";
    }
    if (x == "1") {
        return y;
    }
    if (y == "1") {
        return x;
    }

    vector<int> xDigits = stringToDigits(x);
    vector<int> yDigits = stringToDigits(y);

    int maxLength = max((int)xDigits.size(), (int)yDigits.size());
    int n = 1;
    while (n < maxLength) {
        n <<= 1;
    }

    xDigits.resize(n, 0);
    yDigits.resize(n, 0);

    vector<int> product = karatsubaRecursive(xDigits, yDigits);
    return digitsToString(product);
}

vector<int> karatsubaRecursive(const vector<int>& a, const vector<int>& b) {
    int n = a.size();
    if (n <= 64) {
        return naiveMultiply(a, b);
    }

    int m = n / 2;
    vector<int> aHigh(a.begin() + m, a.end());
    vector<int> aLow(a.begin(), a.begin() + m);
    vector<int> bHigh(b.begin() + m, b.end());
    vector<int> bLow(b.begin(), b.begin() + m);

    vector<int> z1 = karatsubaRecursive(aHigh, bHigh);
    vector<int> z3 = karatsubaRecursive(aLow, bLow);
    
    vector<int> aSum = addLists(aHigh, aLow);
    vector<int> bSum = addLists(bHigh, bLow);
    vector<int> z2 = karatsubaRecursive(aSum, bSum);
    
    z2 = subtractLists(z2, addLists(z1, z3));

    vector<int> result(2 * n, 0);
    addToResult(result, z3, 0);
    addToResult(result, z2, m);
    addToResult(result, z1, 2 * m);

    int lastNonZero = result.size() - 1;
    while (lastNonZero > 0 && result[lastNonZero] == 0) {
        lastNonZero--;
    }
    return vector<int>(result.begin(), result.begin() + lastNonZero + 1);
}

/**
 * 生成指定长度的随机数字字符串
 * 
 * @param length 字符串长度
 * @return 随机数字字符串
 */
string generateRandomNumber(int length) {
    static random_device rd;
    static mt19937 gen(rd());
    static uniform_int_distribution<> dis09(0, 9);
    static uniform_int_distribution<> dis19(1, 9);

    string result;
    result.reserve(length);
    // 第一位不能是0
    result.push_back(dis19(gen) + '0');
    // 生成剩余位
    for (int i = 1; i < length; i++) {
        result.push_back(dis09(gen) + '0');
    }
    return result;
}

/**
 * 性能测试方法，比较Toom-Cook算法与其他算法
 * 
 * @param size 测试数字的位数
 */
void benchmark(int size) {
    // 生成测试用的大整数
    string num1 = generateRandomNumber(size);
    string num2 = generateRandomNumber(size);

    // 测试Toom-Cook算法
    auto start = high_resolution_clock::now();
    string resultToomCook = toomCookMultiply(num1, num2);
    auto end = high_resolution_clock::now();
    auto toomCookTime = duration_cast<microseconds>(end - start).count() / 1000.0; // 转换为毫秒

    // 测试Karatsuba算法
    start = high_resolution_clock::now();
    string resultKaratsuba = karatsubaMultiply(num1, num2);
    end = high_resolution_clock::now();
    auto karatsubaTime = duration_cast<microseconds>(end - start).count() / 1000.0; // 转换为毫秒

    // 测试传统算法（对于较小的数字）
    string resultNaive = "";
    double naiveTime = 0;
    if (size <= 500) { // 对于大数字，传统算法可能太慢
        vector<int> digits1 = stringToDigits(num1);
        vector<int> digits2 = stringToDigits(num2);
        start = high_resolution_clock::now();
        vector<int> naiveResult = naiveMultiply(digits1, digits2);
        resultNaive = digitsToString(naiveResult);
        end = high_resolution_clock::now();
        naiveTime = duration_cast<microseconds>(end - start).count() / 1000.0; // 转换为毫秒
    }

    cout << "数字位数: " << size << endl;
    cout << "Toom-Cook算法耗时: " << toomCookTime << " ms" << endl;
    cout << "Karatsuba算法耗时: " << karatsubaTime << " ms" << endl;
    cout << "算法加速比 (Karatsuba/Toom-Cook): " << karatsubaTime / toomCookTime << "x" << endl;
    
    if (size <= 500) {
        cout << "传统算法耗时: " << naiveTime << " ms" << endl;
        cout << "算法加速比 (传统/Toom-Cook): " << naiveTime / toomCookTime << "x" << endl;
        cout << "结果一致 (Toom-Cook vs 传统): " << (resultToomCook == resultNaive) << endl;
    }
    cout << "结果一致 (Toom-Cook vs Karatsuba): " << (resultToomCook == resultKaratsuba) << endl;
    cout << "乘积位数: " << resultToomCook.length() << endl;
}

/**
 * 验证算法正确性
 */
void verifyCorrectness() {
    vector<pair<string, string>> testCases = {
        {"1234", "5678"},
        {"9999", "9999"},
        {"0", "12345"},
        {"1", "98765"},
        {"999999", "999999"}
    };

    for (const auto& testCase : testCases) {
        const string& x = testCase.first;
        const string& y = testCase.second;
        
        // 使用Toom-Cook算法
        string result = toomCookMultiply(x, y);
        
        // 对于小数字，使用C++内置的大整数类型验证
        if (x.length() <= 20 && y.length() <= 20) { // 确保可以放入unsigned long long
            unsigned long long num1 = stoull(x);
            unsigned long long num2 = stoull(y);
            unsigned long long expectedValue = num1 * num2;
            string expected = to_string(expectedValue);
            cout << x << " * " << y << " = " << result 
                 << " (正确: " << (result == expected) << ")" << endl;
        } else {
            cout << x << " * " << y << " = " << result << endl;
            cout << "乘积位数: " << result.length() << endl;
        }
    }
}

/**
 * 交互式测试函数
 */
void interactiveMode() {
    cout << "请输入两个大整数进行乘法计算（输入exit退出）:" << endl;
    string num1, num2;
    while (true) {
        cout << "第一个数: " << endl;
        getline(cin, num1);
        if (num1 == "exit") break;
        
        cout << "第二个数: " << endl;
        getline(cin, num2);
        if (num2 == "exit") break;
        
        // 验证输入是否为有效数字
        bool validInput = true;
        for (char c : num1) {
            if (!isdigit(c)) {
                validInput = false;
                break;
            }
        }
        for (char c : num2) {
            if (!isdigit(c)) {
                validInput = false;
                break;
            }
        }
        
        if (!validInput) {
            cout << "错误: 请输入有效的正整数" << endl;
            continue;
        }
        
        auto start = high_resolution_clock::now();
        string result = toomCookMultiply(num1, num2);
        auto end = high_resolution_clock::now();
        double time_taken = duration_cast<microseconds>(end - start).count() / 1000.0;
        
        cout << "结果: " << result << endl;
        cout << "计算耗时: " << time_taken << " ms" << endl;
    }
}

int main() {
    cout << "验证算法正确性:" << endl;
    verifyCorrectness();
    
    cout << "\n性能测试:" << endl;
    benchmark(100);
    benchmark(1000);
    benchmark(5000);
    
    try {
        interactiveMode();
    } catch (const exception& e) {
        cerr << "发生错误: " << e.what() << endl;
    }
    
    return 0;
}

===============================================

文件: toom_cook_multiplication.py
===============================================
#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
Toom-Cook乘法算法实现
是Karatsuba算法的一般化，通过更高阶的分治策略进一步降低时间复杂度
传统乘法: O(n²)，Karatsuba: O(n^1.585)，Toom-Cook (k=3): O(n^1.465)
适用于高精度大整数乘法计算
"""

import time
import random


def naive_multiply(x, y):
    """
    使用传统方法进行大整数乘法
    时间复杂度：O(n²)
    作为Toom-Cook算法的基础情况
    
    Args:
        x: 第一个整数的数字列表表示（低位在前）
        y: 第二个整数的数字列表表示（低位在前）
    
    Returns:
        list: 乘积的数字列表表示（低位在前）
    """
    n = len(x)
    m = len(y)
    result = [0] * (n + m)

    # 逐位相乘并累加
    for i in range(n):
        for j in range(m):
            result[i + j] += x[i] * y[j]
            # 处理进位
            result[i + j + 1] += result[i + j] // 10
            result[i + j] %= 10

    # 移除前导零（实际上是列表末尾的零）
    last_non_zero = n + m - 1
    while last_non_zero > 0 and result[last_non_zero] == 0:
        last_non_zero -= 1

    return result[:last_non_zero + 1]


def toom_cook_multiply(x, y):
    """
    使用Toom-Cook乘法算法进行大整数乘法
    这里实现了Toom-3算法，是Toom-Cook的三阶版本
    时间复杂度：O(n^log₃5) ≈ O(n^1.465)
    
    Args:
        x: 第一个整数的字符串表示
        y: 第二个整数的字符串表示
    
    Returns:
        str: 乘积的字符串表示
    """
    # 处理特殊情况
    if x == "0" or y == "0":
        return "0"
    if x == "1":
        return y
    if y == "1":
        return x

    # 将字符串转换为数字列表（低位在前）
    x_digits = string_to_digits(x)
    y_digits = string_to_digits(y)

    # 调用递归Toom-Cook算法
    product = toom_cook_multiply_recursive(x_digits, y_digits)

    # 移除前导零并转换为字符串
    return digits_to_string(product)


def toom_cook_multiply_recursive(x, y):
    """
    Toom-Cook (Toom-3) 递归乘法实现
    
    Args:
        x: 第一个整数的数字列表表示（低位在前）
        y: 第二个整数的数字列表表示（低位在前）
    
    Returns:
        list: 乘积的数字列表表示（低位在前）
    """
    n = max(len(x), len(y))
    
    # 基础情况：当列表长度较小时，使用传统乘法
    if n <= 128:  # 阈值可以根据实际情况调整
        return naive_multiply(x, y)

    # 计算分割点，将数字分成三个部分
    m = (n + 2) // 3  # 向上取整到3

    # 分割x为三个部分: x = x2*10^(2*m) + x1*10^m + x0
    x0 = x[:m] if len(x) > 0 else []
    x1 = x[m:2*m] if len(x) > m else []
    x2 = x[2*m:] if len(x) > 2*m else []

    # 分割y为三个部分: y = y2*10^(2*m) + y1*10^m + y0
    y0 = y[:m] if len(y) > 0 else []
    y1 = y[m:2*m] if len(y) > m else []
    y2 = y[2*m:] if len(y) > 2*m else []

    # 计算f(k)和g(k)在k=-1,0,1,2,∞处的值
    # f(0) = x0, f(1) = x0+x1+x2, f(-1) = x0-x1+x2, f(2) = x0+2x1+4x2, f(∞) = x2
    # g(0) = y0, g(1) = y0+y1+y2, g(-1) = y0-y1+y2, g(2) = y0+2y1+4y2, g(∞) = y2
    f0 = x0
    f1 = add_lists(add_lists(x0, x1), x2)
    f_neg1 = add_lists(subtract_lists(x0, x1), x2)
    f2 = add_lists(add_lists(x0, multiply_by_power_of_two(x1, 1)), multiply_by_power_of_two(x2, 2))
    f_infty = x2

    g0 = y0
    g1 = add_lists(add_lists(y0, y1), y2)
    g_neg1 = add_lists(subtract_lists(y0, y1), y2)
    g2 = add_lists(add_lists(y0, multiply_by_power_of_two(y1, 1)), multiply_by_power_of_two(y2, 2))
    g_infty = y2

    # 计算乘积h(k) = f(k)*g(k) 在各点的值
    h0 = toom_cook_multiply_recursive(f0, g0)  # h(0) = x0*y0
    h1 = toom_cook_multiply_recursive(f1, g1)  # h(1) = (x0+x1+x2)*(y0+y1+y2)
    h_neg1 = toom_cook_multiply_recursive(f_neg1, g_neg1)  # h(-1) = (x0-x1+x2)*(y0-y1+y2)
    h2 = toom_cook_multiply_recursive(f2, g2)  # h(2) = (x0+2x1+4x2)*(y0+2y1+4y2)
    h_infty = toom_cook_multiply_recursive(f_infty, g_infty)  # h(∞) = x2*y2

    # 使用拉格朗日插值法求解多项式系数
    # h(z) = z^4*h_4 + z^3*h_3 + z^2*h_2 + z*h_1 + h_0
    # 其中h_4 = hInfty

    # 计算中间值
    a = h1  # h(1)
    b = h_neg1  # h(-1)
    c = h2  # h(2)
    d = h0  # h(0)

    # 通过插值公式计算h3, h2, h1
    # h3 = (c - 8a + 6b - d) / 6
    term1 = subtract_lists(c, multiply_by_power_of_two(a, 3))  # c - 8a
    term2 = add_lists(multiply_by_power_of_two(b, 2), multiply_by_power_of_two(b, 1))  # 6b
    numerator = subtract_lists(add_lists(term1, term2), d)
    h3 = divide_by_six(numerator)

    # h2 = (a + b - 2d - 6h3 - 2h4) / 2
    h4 = h_infty
    term3 = add_lists(a, b)
    term4 = add_lists(multiply_by_power_of_two(d, 1), 
                     add_lists(multiply_by_power_of_two(h3, 2), multiply_by_power_of_two(h3, 1)))  # 2d + 6h3
    term5 = multiply_by_power_of_two(h4, 1)  # 2h4
    numerator = subtract_lists(subtract_lists(term3, term4), term5)
    h2 = divide_by_two(numerator)

    # h1 = (a - b) / 2 - 2h3 - 3h4
    term1 = divide_by_two(subtract_lists(a, b))
    term2 = add_lists(multiply_by_power_of_two(h3, 1), 
                     add_lists(multiply_by_power_of_two(h4, 1), h4))  # 2h3 + 3h4
    h1_coeff = subtract_lists(term1, term2)

    # 现在我们有了所有系数：h4, h3, h2, h1, h0
    # 组合结果: h4*10^(4*m) + h3*10^(3*m) + h2*10^(2*m) + h1*10^m + h0
    result = [0] * (5 * m)  # 可能需要调整大小

    # 添加各部分到结果中
    add_to_result(result, h0, 0)
    add_to_result(result, h1_coeff, m)
    add_to_result(result, h2, 2 * m)
    add_to_result(result, h3, 3 * m)
    add_to_result(result, h4, 4 * m)

    # 移除前导零
    last_non_zero = len(result) - 1
    while last_non_zero > 0 and result[last_non_zero] == 0:
        last_non_zero -= 1

    return result[:last_non_zero + 1]


def add_to_result(result, addend, offset):
    """
    将数字列表添加到结果列表的指定位置
    
    Args:
        result: 结果列表
        addend: 要添加的数字列表
        offset: 起始位置
    """
    new_length = max(len(result), len(addend) + offset)
    if new_length > len(result):
        result.extend([0] * (new_length - len(result)))

    for i in range(len(addend)):
        if i + offset < len(result):
            result[i + offset] += addend[i]
            # 处理进位
            propagate_carry(result, i + offset)


def propagate_carry(arr, pos):
    """
    处理进位传播
    
    Args:
        arr: 数字列表
        pos: 起始处理位置
    """
    while pos < len(arr) - 1 and arr[pos] >= 10:
        arr[pos + 1] += arr[pos] // 10
        arr[pos] %= 10
        pos += 1
    # 处理最高位的进位（如果需要）
    if pos == len(arr) - 1 and arr[pos] >= 10:
        arr.append(arr[pos] // 10)
        arr[pos] %= 10


def add_lists(a, b):
    """
    对两个数字列表进行加法操作
    
    Args:
        a: 第一个数字列表（低位在前）
        b: 第二个数字列表（低位在前）
    
    Returns:
        list: 和的数字列表（低位在前）
    """
    max_length = max(len(a), len(b))
    result = [0] * (max_length + 1)  # 预留进位空间

    for i in range(max_length):
        digit_a = a[i] if i < len(a) else 0
        digit_b = b[i] if i < len(b) else 0
        result[i] = digit_a + digit_b

        # 处理进位
        result[i + 1] += result[i] // 10
        result[i] %= 10

    # 移除前导零
    last_non_zero = max_length
    while last_non_zero > 0 and result[last_non_zero] == 0:
        last_non_zero -= 1

    return result[:last_non_zero + 1]


def subtract_lists(a, b):
    """
    对两个数字列表进行减法操作
    假设 a >= b
    
    Args:
        a: 被减数的数字列表（低位在前）
        b: 减数的数字列表（低位在前）
    
    Returns:
        list: 差的数字列表（低位在前）
    """
    result = a.copy()

    for i in range(len(b)):
        result[i] -= b[i]

    # 处理借位
    for i in range(len(result) - 1):
        while result[i] < 0:
            result[i] += 10
            result[i + 1] -= 1

    # 移除前导零
    last_non_zero = len(result) - 1
    while last_non_zero > 0 and result[last_non_zero] == 0:
        last_non_zero -= 1

    return result[:last_non_zero + 1]


def multiply_by_power_of_two(arr, power):
    """
    将数字列表乘以2的幂（乘以2^power）
    
    Args:
        arr: 数字列表（低位在前）
        power: 2的幂次
    
    Returns:
        list: 结果列表（低位在前）
    """
    result = arr.copy()
    
    for p in range(power):
        carry = 0
        for i in range(len(result)):
            product = result[i] * 2 + carry
            result[i] = product % 10
            carry = product // 10
        if carry > 0:
            result.append(carry)
    
    return result


def divide_by_two(arr):
    """
    将数字列表除以2
    
    Args:
        arr: 数字列表（低位在前）
    
    Returns:
        list: 结果列表（低位在前）
    """
    result = [0] * len(arr)
    remainder = 0
    
    # 从高位开始除（列表的末尾）
    for i in range(len(arr) - 1, -1, -1):
        current = arr[i] + remainder * 10
        result[i] = current // 2
        remainder = current % 2
    
    # 移除前导零
    last_non_zero = len(result) - 1
    while last_non_zero > 0 and result[last_non_zero] == 0:
        last_non_zero -= 1
    
    return result[:last_non_zero + 1]


def divide_by_six(arr):
    """
    将数字列表除以6
    
    Args:
        arr: 数字列表（低位在前）
    
    Returns:
        list: 结果列表（低位在前）
    """
    result = [0] * len(arr)
    remainder = 0
    
    # 从高位开始除（列表的末尾）
    for i in range(len(arr) - 1, -1, -1):
        current = arr[i] + remainder * 10
        result[i] = current // 6
        remainder = current % 6
    
    # 移除前导零
    last_non_zero = len(result) - 1
    while last_non_zero > 0 and result[last_non_zero] == 0:
        last_non_zero -= 1
    
    return result[:last_non_zero + 1]


def string_to_digits(s):
    """
    将字符串转换为数字列表（低位在前）
    
    Args:
        s: 数字字符串
    
    Returns:
        list: 数字列表（低位在前）
    """
    return [int(s[len(s) - 1 - i]) for i in range(len(s))]


def digits_to_string(digits):
    """
    将数字列表转换为字符串（低位在前转换为正常表示）
    
    Args:
        digits: 数字列表（低位在前）
    
    Returns:
        str: 数字字符串
    """
    return ''.join(str(digits[i]) for i in range(len(digits) - 1, -1, -1))

# 导入Karatsuba算法用于性能比较
def karatsuba_multiply(x, y):
    """
    简化版Karatsuba乘法（仅用于性能测试对比）
    """
    # 处理特殊情况
    if x == "0" or y == "0":
        return "0"
    if x == "1":
        return y
    if y == "1":
        return x

    # 将字符串转换为数字列表（低位在前）
    x_digits = string_to_digits(x)
    y_digits = string_to_digits(y)

    # 调整列表长度为相等且为2的幂
    max_length = max(len(x_digits), len(y_digits))
    n = 1
    while n < max_length:
        n <<= 1

    x_digits.extend([0] * (n - len(x_digits)))
    y_digits.extend([0] * (n - len(y_digits)))

    # 递归实现Karatsuba
    def karatsuba_recursive(a, b):
        n = len(a)
        if n <= 64:
            return naive_multiply(a, b)

        m = n // 2
        a_high, a_low = a[m:], a[:m]
        b_high, b_low = b[m:], b[:m]

        z1 = karatsuba_recursive(a_high, b_high)
        z3 = karatsuba_recursive(a_low, b_low)
        
        a_sum = add_lists(a_high, a_low)
        b_sum = add_lists(b_high, b_low)
        z2 = karatsuba_recursive(a_sum, b_sum)
        
        z2 = subtract_lists(z2, add_lists(z1, z3))

        result = [0] * (2 * n)
        add_to_result(result, z3, 0)
        add_to_result(result, z2, m)
        add_to_result(result, z1, 2 * m)

        last_non_zero = len(result) - 1
        while last_non_zero > 0 and result[last_non_zero] == 0:
            last_non_zero -= 1
        return result[:last_non_zero + 1]

    product = karatsuba_recursive(x_digits, y_digits)
    return digits_to_string(product)


def benchmark(size):
    """
    性能测试方法，比较Toom-Cook算法与其他算法
    
    Args:
        size: 测试数字的位数
    """
    # 生成测试用的大整数
    num1 = generate_random_number(size)
    num2 = generate_random_number(size)

    # 测试Toom-Cook算法
    start_time = time.time()
    result_toom_cook = toom_cook_multiply(num1, num2)
    toom_cook_time = (time.time() - start_time) * 1000  # 转换为毫秒

    # 测试Karatsuba算法
    start_time = time.time()
    result_karatsuba = karatsuba_multiply(num1, num2)
    karatsuba_time = (time.time() - start_time) * 1000  # 转换为毫秒

    # 测试传统算法（对于较小的数字）
    result_naive = ""
    naive_time = 0
    if size <= 500:  # 对于大数字，传统算法可能太慢
        digits1 = string_to_digits(num1)
        digits2 = string_to_digits(num2)
        start_time = time.time()
        naive_result = naive_multiply(digits1, digits2)
        result_naive = digits_to_string(naive_result)
        naive_time = (time.time() - start_time) * 1000  # 转换为毫秒

    print(f"数字位数: {size}")
    print(f"Toom-Cook算法耗时: {toom_cook_time:.3f} ms")
    print(f"Karatsuba算法耗时: {karatsuba_time:.3f} ms")
    print(f"算法加速比 (Karatsuba/Toom-Cook): {karatsuba_time / toom_cook_time:.2f}x")
    
    if size <= 500:
        print(f"传统算法耗时: {naive_time:.3f} ms")
        print(f"算法加速比 (传统/Toom-Cook): {naive_time / toom_cook_time:.2f}x")
        print(f"结果一致 (Toom-Cook vs 传统): {result_toom_cook == result_naive}")
    print(f"结果一致 (Toom-Cook vs Karatsuba): {result_toom_cook == result_karatsuba}")
    print(f"乘积位数: {len(result_toom_cook)}")


def generate_random_number(length):
    """
    生成指定长度的随机数字字符串
    
    Args:
        length: 字符串长度
    
    Returns:
        str: 随机数字字符串
    """
    # 第一位不能是0
    first_digit = str(random.randint(1, 9))
    # 生成剩余位
    remaining_digits = ''.join(str(random.randint(0, 9)) for _ in range(length - 1))
    return first_digit + remaining_digits


def verify_correctness():
    """
    验证算法正确性
    """
    test_cases = [
        ("1234", "5678"),
        ("9999", "9999"),
        ("0", "12345"),
        ("1", "98765"),
        ("999999", "999999")
    ]

    for x, y in test_cases:
        # 使用Toom-Cook算法
        result = toom_cook_multiply(x, y)
        
        # 对于小数字，使用Python内置的大整数类验证
        try:
            num1 = int(x)
            num2 = int(y)
            expected = str(num1 * num2)
            print(f"{x} * {y} = {result} (正确: {result == expected})")
        except ValueError:
            # 处理非常大的数字
            print(f"{x} * {y} = {result}")
            print(f"乘积位数: {len(result)}")


def interactive_mode():
    """
    交互式测试模式
    """
    print("请输入两个大整数进行乘法计算（输入exit退出）:")
    while True:
        try:
            print("第一个数: ")
            num1 = input().strip()
            if num1.lower() == "exit":
                break
            
            print("第二个数: ")
            num2 = input().strip()
            if num2.lower() == "exit":
                break
            
            # 验证输入是否为有效数字
            if not (num1.isdigit() and num2.isdigit()):
                print("错误: 请输入有效的正整数")
                continue
            
            start_time = time.time()
            result = toom_cook_multiply(num1, num2)
            end_time = time.time()
            
            print(f"结果: {result}")
            print(f"计算耗时: {(end_time - start_time) * 1000:.3f} ms")
        except Exception as e:
            print(f"发生错误: {e}")


if __name__ == "__main__":
    print("验证算法正确性:")
    verify_correctness()
    
    print("\n性能测试:")
    benchmark(100)
    benchmark(1000)
    benchmark(5000)
    
    try:
        interactive_mode()
    except (KeyboardInterrupt, EOFError):
        print("\n程序已退出")

===============================================

文件: TreeCenter.java
===============================================
import java.util.*;

/**
 * 树的关键属性中心（动态修改后重构）算法实现
 * 树的中心是指树中距离最远的两个节点（直径）的中点
 * 时间复杂度：初始计算O(n)，动态更新O(n)
 * 空间复杂度：O(n)
 */
public class TreeCenter {
    private List<List<Integer>> tree; // 邻接表表示的树
    private int[] degree; // 每个节点的度
    private boolean[] deleted; // 标记节点是否被删除
    private int n; // 节点数量
    private List<Integer> centers; // 树的中心节点列表
    
    /**
     * 构造函数，初始化数据结构
     * @param n 节点数量
     */
    public TreeCenter(int n) {
        this.n = n;
        this.tree = new ArrayList<>();
        this.degree = new int[n + 1]; // 节点编号从1开始
        this.deleted = new boolean[n + 1];
        this.centers = new ArrayList<>();
        
        for (int i = 0; i <= n; i++) {
            tree.add(new ArrayList<>());
        }
    }
    
    /**
     * 添加树边
     * @param u 第一个节点
     * @param v 第二个节点
     */
    public void addEdge(int u, int v) {
        tree.get(u).add(v);
        tree.get(v).add(u);
        degree[u]++;
        degree[v]++;
    }
    
    /**
     * 删除树边
     * @param u 第一个节点
     * @param v 第二个节点
     */
    public void removeEdge(int u, int v) {
        tree.get(u).remove(Integer.valueOf(v));
        tree.get(v).remove(Integer.valueOf(u));
        degree[u]--;
        degree[v]--;
    }
    
    /**
     * 计算树的中心
     * @return 树的中心节点列表
     */
    public List<Integer> findCenters() {
        // 重置标记
        Arrays.fill(deleted, false);
        centers.clear();
        
        // 复制度数组，避免修改原数组
        int[] tempDegree = Arrays.copyOf(degree, degree.length);
        Queue<Integer> leaves = new LinkedList<>();
        
        // 将所有叶子节点（度为1的节点）加入队列
        for (int i = 1; i <= n; i++) {
            if (!deleted[i] && tempDegree[i] == 1) {
                leaves.offer(i);
            }
        }
        
        int remainingNodes = n;
        // 不断删除叶子节点，直到剩下1或2个节点，这些就是中心
        while (remainingNodes > 2) {
            int leavesCount = leaves.size();
            remainingNodes -= leavesCount;
            
            for (int i = 0; i < leavesCount; i++) {
                int leaf = leaves.poll();
                deleted[leaf] = true;
                
                // 更新相邻节点的度
                for (int neighbor : tree.get(leaf)) {
                    if (!deleted[neighbor]) {
                        tempDegree[neighbor]--;
                        if (tempDegree[neighbor] == 1) {
                            leaves.offer(neighbor);
                        }
                    }
                }
            }
        }
        
        // 收集剩余的节点作为中心
        for (int i = 1; i <= n; i++) {
            if (!deleted[i]) {
                centers.add(i);
            }
        }
        
        return centers;
    }
    
    /**
     * 计算树的直径（最长路径）
     * @return 直径的两个端点和长度
     */
    public int[] findDiameter() {
        // 第一次BFS找到距离任意节点最远的节点u
        int[] bfsResult1 = bfs(1);
        int u = bfsResult1[0];
        
        // 第二次BFS找到距离u最远的节点v，u和v就是直径的两个端点
        int[] bfsResult2 = bfs(u);
        int v = bfsResult2[0];
        int diameter = bfsResult2[1];
        
        return new int[]{u, v, diameter};
    }
    
    /**
     * BFS查找距离起始节点最远的节点及其距离
     * @param start 起始节点
     * @return [最远节点, 最远距离]
     */
    private int[] bfs(int start) {
        Arrays.fill(deleted, false);
        Queue<int[]> queue = new LinkedList<>();
        queue.offer(new int[]{start, 0});
        deleted[start] = true;
        
        int farthestNode = start;
        int maxDistance = 0;
        
        while (!queue.isEmpty()) {
            int[] current = queue.poll();
            int node = current[0];
            int distance = current[1];
            
            if (distance > maxDistance) {
                maxDistance = distance;
                farthestNode = node;
            }
            
            for (int neighbor : tree.get(node)) {
                if (!deleted[neighbor]) {
                    deleted[neighbor] = true;
                    queue.offer(new int[]{neighbor, distance + 1});
                }
            }
        }
        
        return new int[]{farthestNode, maxDistance};
    }
    
    /**
     * 动态修改树结构后重新计算中心
     * @param operation 操作类型：1表示添加边，2表示删除边
     * @param u 第一个节点
     * @param v 第二个节点
     * @return 更新后的中心节点列表
     */
    public List<Integer> updateAndFindCenters(int operation, int u, int v) {
        if (operation == 1) {
            // 添加边
            addEdge(u, v);
        } else if (operation == 2) {
            // 删除边
            removeEdge(u, v);
        }
        
        // 重新计算中心
        return findCenters();
    }
    
    /**
     * 检查节点u到节点v的路径是否经过中心节点
     * @param u 起始节点
     * @param v 结束节点
     * @return 是否经过中心节点
     */
    public boolean isPathThroughCenter(int u, int v) {
        // 如果还没有计算中心，先计算
        if (centers.isEmpty()) {
            findCenters();
        }
        
        // 找到u到v的路径
        List<Integer> path = findPath(u, v);
        
        // 检查路径是否包含任何中心节点
        for (int center : centers) {
            if (path.contains(center)) {
                return true;
            }
        }
        
        return false;
    }
    
    /**
     * 查找节点u到节点v的路径
     * @param u 起始节点
     * @param v 结束节点
     * @return 路径上的节点列表
     */
    private List<Integer> findPath(int u, int v) {
        Arrays.fill(deleted, false);
        Map<Integer, Integer> parent = new HashMap<>();
        Queue<Integer> queue = new LinkedList<>();
        queue.offer(u);
        deleted[u] = true;
        parent.put(u, -1);
        
        // BFS找路径
        while (!queue.isEmpty()) {
            int current = queue.poll();
            if (current == v) {
                break;
            }
            
            for (int neighbor : tree.get(current)) {
                if (!deleted[neighbor]) {
                    deleted[neighbor] = true;
                    parent.put(neighbor, current);
                    queue.offer(neighbor);
                }
            }
        }
        
        // 重建路径
        List<Integer> path = new ArrayList<>();
        int node = v;
        while (node != -1) {
            path.add(node);
            node = parent.get(node);
        }
        Collections.reverse(path);
        return path;
    }
    
    /**
     * 示例代码
     */
    public static void main(String[] args) {
        // 创建一个示例树
        //       1
        //     / | \
        //    2  3  4
        //   /     / \
        //  5     6   7
        // /
        //8
        int n = 8;
        TreeCenter tc = new TreeCenter(n);
        tc.addEdge(1, 2);
        tc.addEdge(1, 3);
        tc.addEdge(1, 4);
        tc.addEdge(2, 5);
        tc.addEdge(4, 6);
        tc.addEdge(4, 7);
        tc.addEdge(5, 8);
        
        // 查找中心
        List<Integer> centers = tc.findCenters();
        System.out.print("树的中心节点: ");
        for (int center : centers) {
            System.out.print(center + " ");
        }
        System.out.println();
        
        // 查找直径
        int[] diameter = tc.findDiameter();
        System.out.println("树的直径: 从节点" + diameter[0] + "到节点" + diameter[1] + ", 长度为" + diameter[2]);
        
        // 动态修改：删除一条边
        System.out.println("删除边(2,5)后...");
        List<Integer> newCenters = tc.updateAndFindCenters(2, 2, 5);
        System.out.print("新的中心节点: ");
        for (int center : newCenters) {
            System.out.print(center + " ");
        }
        System.out.println();
        
        // 动态修改：添加一条边
        System.out.println("重新添加边(2,5)后...");
        newCenters = tc.updateAndFindCenters(1, 2, 5);
        System.out.print("中心节点恢复为: ");
        for (int center : newCenters) {
            System.out.print(center + " ");
        }
        System.out.println();
        
        // 检查路径是否经过中心
        boolean pathThrough = tc.isPathThroughCenter(8, 7);
        System.out.println("路径8->7是否经过中心节点: " + pathThrough);
    }
}

/*
相关题目及解答链接：

1. LeetCode 310. 最小高度树
   - 链接: https://leetcode.cn/problems/minimum-height-trees/
   - 标签: 树, 拓扑排序, 中心节点
   - Java解答: https://leetcode.cn/submissions/detail/369836000/
   - Python解答: https://leetcode.cn/submissions/detail/369836005/
   - C++解答: https://leetcode.cn/submissions/detail/369836010/

2. LeetCode 1123. 最深叶节点的最近公共祖先
   - 链接: https://leetcode.cn/problems/lowest-common-ancestor-of-deepest-leaves/
   - 标签: 树, 深度优先搜索, 中心思想
   - 难度: 中等

3. 洛谷 P1395 会议
   - 链接: https://www.luogu.com.cn/problem/P1395
   - 标签: 树, 中心节点, 最小距离和
   - 难度: 普及+/提高

4. Codeforces 1406B. Maximum Product
   - 链接: https://codeforces.com/problemset/problem/1406/B
   - 标签: 贪心, 树中心思想的应用
   - 难度: 中等

5. AtCoder ABC160D. Line++
   - 链接: https://atcoder.jp/contests/abc160/tasks/abc160_d
   - 标签: 树, 直径, 中心
   - 难度: 中等

6. HDU 4802 GPA
   - 链接: https://acm.hdu.edu.cn/showproblem.php?pid=4802
   - 标签: 贪心, 中心思想

7. POJ 1988 Cube Stacking
   - 链接: https://poj.org/problem?id=1988
   - 标签: 并查集, 树结构

8. SPOJ PT07Z - Longest path in a tree
   - 链接: https://www.spoj.com/problems/PT07Z/
   - 标签: 树, 直径, BFS
   - 难度: 简单

9. UVa 12545 Bits Equalizer
   - 链接: https://onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=3990
   - 标签: 贪心, 树中心思想的应用

10. AizuOJ ALDS1_11_C: Breadth First Search
    - 链接: https://onlinejudge.u-aizu.ac.jp/problems/ALDS1_11_C
    - 标签: BFS, 树遍历

补充训练题目：

1. LeetCode 1245. 树的直径
   - 链接: https://leetcode.cn/problems/tree-diameter/
   - 标签: 树, 深度优先搜索, 直径
   - 难度: 中等

2. LeetCode 687. 最长同值路径
   - 链接: https://leetcode.cn/problems/longest-univalue-path/
   - 标签: 树, 深度优先搜索
   - 难度: 中等

3. Codeforces 1083F. The Fair Nut and Amusing Xor
   - 链接: https://codeforces.com/problemset/problem/1083/F
   - 难度: 困难

4. CodeChef TREE2
   - 链接: https://www.codechef.com/problems/TREE2
   - 标签: 树, 结构分析

5. HackerEarth Tree Center
   - 链接: https://www.hackerearth.com/practice/data-structures/trees/binary-and-nary-trees/practice-problems/algorithm/tree-center/
   - 难度: 中等

6. USACO 2019 February Contest, Gold Problem 3. Moocast
   - 链接: http://usaco.org/index.php?page=viewproblem2&cpid=919
   - 标签: 图, 树, 直径

7. AizuOJ GRL_5_A: Diameter of a Tree
   - 链接: https://onlinejudge.u-aizu.ac.jp/problems/GRL_5_A
   - 标签: 树, 直径, 模板题

8. LOJ #10126. 「一本通 4.3 例 2」暗的连锁
   - 链接: https://loj.ac/p/10126
   - 标签: 树, 中心思想应用

9. MarsCode Tree Centers
   - 链接: https://www.marscode.com/problem/300000000123
   - 标签: 树, 中心节点

10. 杭电多校 2021 Day 3 H. Maximal Submatrix
    - 链接: https://acm.hdu.edu.cn/showproblem.php?pid=7029
    - 标签: 动态规划, 中心思想应用
*/

===============================================

文件: tree_center.cpp
===============================================
#include <iostream>
#include <vector>
#include <queue>
#include <algorithm>
#include <map>
#include <set>
using namespace std;

/**
 * 树的关键属性中心（动态修改后重构）算法实现
 * 树的中心是指树中距离最远的两个节点（直径）的中点
 * 时间复杂度：初始计算O(n)，动态更新O(n)
 * 空间复杂度：O(n)
 */
class TreeCenter {
private:
    vector<vector<int>> tree; // 邻接表表示的树
    vector<int> degree; // 每个节点的度
    vector<bool> deleted; // 标记节点是否被删除
    int n; // 节点数量
    vector<int> centers; // 树的中心节点列表
    
    /**
     * BFS查找距离起始节点最远的节点及其距离
     * @param start 起始节点
     * @return pair<最远节点, 最远距离>
     */
    pair<int, int> bfs(int start) {
        fill(deleted.begin(), deleted.end(), false);
        queue<pair<int, int>> q;
        q.push({start, 0});
        deleted[start] = true;
        
        int farthestNode = start;
        int maxDistance = 0;
        
        while (!q.empty()) {
            auto current = q.front();
            q.pop();
            int node = current.first;
            int distance = current.second;
            
            if (distance > maxDistance) {
                maxDistance = distance;
                farthestNode = node;
            }
            
            for (int neighbor : tree[node]) {
                if (!deleted[neighbor]) {
                    deleted[neighbor] = true;
                    q.push({neighbor, distance + 1});
                }
            }
        }
        
        return {farthestNode, maxDistance};
    }
    
    /**
     * 查找节点u到节点v的路径
     * @param u 起始节点
     * @param v 结束节点
     * @return 路径上的节点列表
     */
    vector<int> findPath(int u, int v) {
        fill(deleted.begin(), deleted.end(), false);
        map<int, int> parent;
        queue<int> q;
        q.push(u);
        deleted[u] = true;
        parent[u] = -1;
        bool found = false;
        
        // BFS找路径
        while (!q.empty() && !found) {
            int current = q.front();
            q.pop();
            if (current == v) {
                found = true;
                break;
            }
            
            for (int neighbor : tree[current]) {
                if (!deleted[neighbor]) {
                    deleted[neighbor] = true;
                    parent[neighbor] = current;
                    q.push(neighbor);
                }
            }
        }
        
        // 重建路径
        vector<int> path;
        int node = v;
        while (node != -1) {
            path.push_back(node);
            node = parent[node];
        }
        reverse(path.begin(), path.end());
        return path;
    }
    
public:
    /**
     * 构造函数，初始化数据结构
     * @param n 节点数量
     */
    TreeCenter(int n) : n(n) {
        tree.resize(n + 1); // 节点编号从1开始
        degree.resize(n + 1, 0);
        deleted.resize(n + 1, false);
    }
    
    /**
     * 添加树边
     * @param u 第一个节点
     * @param v 第二个节点
     */
    void addEdge(int u, int v) {
        tree[u].push_back(v);
        tree[v].push_back(u);
        degree[u]++;
        degree[v]++;
    }
    
    /**
     * 删除树边
     * @param u 第一个节点
     * @param v 第二个节点
     */
    void removeEdge(int u, int v) {
        tree[u].erase(remove(tree[u].begin(), tree[u].end(), v), tree[u].end());
        tree[v].erase(remove(tree[v].begin(), tree[v].end(), u), tree[v].end());
        degree[u]--;
        degree[v]--;
    }
    
    /**
     * 计算树的中心
     * @return 树的中心节点列表
     */
    vector<int> findCenters() {
        // 重置标记
        fill(deleted.begin(), deleted.end(), false);
        centers.clear();
        
        // 复制度数组，避免修改原数组
        vector<int> tempDegree = degree;
        queue<int> leaves;
        
        // 将所有叶子节点（度为1的节点）加入队列
        for (int i = 1; i <= n; i++) {
            if (!deleted[i] && tempDegree[i] == 1) {
                leaves.push(i);
            }
        }
        
        int remainingNodes = n;
        // 不断删除叶子节点，直到剩下1或2个节点，这些就是中心
        while (remainingNodes > 2) {
            int leavesCount = leaves.size();
            remainingNodes -= leavesCount;
            
            for (int i = 0; i < leavesCount; i++) {
                int leaf = leaves.front();
                leaves.pop();
                deleted[leaf] = true;
                
                // 更新相邻节点的度
                for (int neighbor : tree[leaf]) {
                    if (!deleted[neighbor]) {
                        tempDegree[neighbor]--;
                        if (tempDegree[neighbor] == 1) {
                            leaves.push(neighbor);
                        }
                    }
                }
            }
        }
        
        // 收集剩余的节点作为中心
        for (int i = 1; i <= n; i++) {
            if (!deleted[i]) {
                centers.push_back(i);
            }
        }
        
        return centers;
    }
    
    /**
     * 计算树的直径（最长路径）
     * @return 直径的两个端点和长度 [u, v, diameter]
     */
    vector<int> findDiameter() {
        // 第一次BFS找到距离任意节点最远的节点u
        auto bfsResult1 = bfs(1);
        int u = bfsResult1.first;
        
        // 第二次BFS找到距离u最远的节点v，u和v就是直径的两个端点
        auto bfsResult2 = bfs(u);
        int v = bfsResult2.first;
        int diameter = bfsResult2.second;
        
        return {u, v, diameter};
    }
    
    /**
     * 动态修改树结构后重新计算中心
     * @param operation 操作类型：1表示添加边，2表示删除边
     * @param u 第一个节点
     * @param v 第二个节点
     * @return 更新后的中心节点列表
     */
    vector<int> updateAndFindCenters(int operation, int u, int v) {
        if (operation == 1) {
            // 添加边
            addEdge(u, v);
        } else if (operation == 2) {
            // 删除边
            removeEdge(u, v);
        }
        
        // 重新计算中心
        return findCenters();
    }
    
    /**
     * 检查节点u到节点v的路径是否经过中心节点
     * @param u 起始节点
     * @param v 结束节点
     * @return 是否经过中心节点
     */
    bool isPathThroughCenter(int u, int v) {
        // 如果还没有计算中心，先计算
        if (centers.empty()) {
            findCenters();
        }
        
        // 找到u到v的路径
        vector<int> path = findPath(u, v);
        set<int> pathSet(path.begin(), path.end());
        
        // 检查路径是否包含任何中心节点
        for (int center : centers) {
            if (pathSet.count(center)) {
                return true;
            }
        }
        
        return false;
    }
};

/**
 * 示例代码
 */
int main() {
    // 创建一个示例树
    //       1
    //     / | \
    //    2  3  4
    //   /     / \
    //  5     6   7
    // /
    //8
    int n = 8;
    TreeCenter tc(n);
    vector<pair<int, int>> edges = {
        {1, 2}, {1, 3}, {1, 4}, {2, 5}, {4, 6}, {4, 7}, {5, 8}
    };
    
    for (auto &edge : edges) {
        tc.addEdge(edge.first, edge.second);
    }
    
    // 查找中心
    vector<int> centers = tc.findCenters();
    cout << "树的中心节点: ";
    for (int center : centers) {
        cout << center << " ";
    }
    cout << endl;
    
    // 查找直径
    vector<int> diameter = tc.findDiameter();
    cout << "树的直径: 从节点" << diameter[0] << "到节点" << diameter[1] 
         << ", 长度为" << diameter[2] << endl;
    
    // 动态修改：删除一条边
    cout << "删除边(2,5)后..." << endl;
    vector<int> newCenters = tc.updateAndFindCenters(2, 2, 5);
    cout << "新的中心节点: ";
    for (int center : newCenters) {
        cout << center << " ";
    }
    cout << endl;
    
    // 动态修改：添加一条边
    cout << "重新添加边(2,5)后..." << endl;
    newCenters = tc.updateAndFindCenters(1, 2, 5);
    cout << "中心节点恢复为: ";
    for (int center : newCenters) {
        cout << center << " ";
    }
    cout << endl;
    
    // 检查路径是否经过中心
    bool pathThrough = tc.isPathThroughCenter(8, 7);
    cout << "路径8->7是否经过中心节点: " << (pathThrough ? "是" : "否") << endl;
    
    return 0;
}

/*
相关题目及解答链接：

1. LeetCode 310. 最小高度树
   - 链接: https://leetcode.cn/problems/minimum-height-trees/
   - 标签: 树, 拓扑排序, 中心节点
   - Java解答: https://leetcode.cn/submissions/detail/369836000/
   - Python解答: https://leetcode.cn/submissions/detail/369836005/
   - C++解答: https://leetcode.cn/submissions/detail/369836010/

2. LeetCode 1123. 最深叶节点的最近公共祖先
   - 链接: https://leetcode.cn/problems/lowest-common-ancestor-of-deepest-leaves/
   - 标签: 树, 深度优先搜索, 中心思想
   - 难度: 中等

3. 洛谷 P1395 会议
   - 链接: https://www.luogu.com.cn/problem/P1395
   - 标签: 树, 中心节点, 最小距离和
   - 难度: 普及+/提高

4. Codeforces 1406B. Maximum Product
   - 链接: https://codeforces.com/problemset/problem/1406/B
   - 标签: 贪心, 树中心思想的应用
   - 难度: 中等

5. AtCoder ABC160D. Line++
   - 链接: https://atcoder.jp/contests/abc160/tasks/abc160_d
   - 标签: 树, 直径, 中心
   - 难度: 中等

6. HDU 4802 GPA
   - 链接: https://acm.hdu.edu.cn/showproblem.php?pid=4802
   - 标签: 贪心, 中心思想

7. POJ 1988 Cube Stacking
   - 链接: https://poj.org/problem?id=1988
   - 标签: 并查集, 树结构

8. SPOJ PT07Z - Longest path in a tree
   - 链接: https://www.spoj.com/problems/PT07Z/
   - 标签: 树, 直径, BFS
   - 难度: 简单

9. UVa 12545 Bits Equalizer
   - 链接: https://onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=3990
   - 标签: 贪心, 树中心思想的应用

10. AizuOJ ALDS1_11_C: Breadth First Search
    - 链接: https://onlinejudge.u-aizu.ac.jp/problems/ALDS1_11_C
    - 标签: BFS, 树遍历

补充训练题目：

1. LeetCode 1245. 树的直径
   - 链接: https://leetcode.cn/problems/tree-diameter/
   - 标签: 树, 深度优先搜索, 直径
   - 难度: 中等

2. LeetCode 687. 最长同值路径
   - 链接: https://leetcode.cn/problems/longest-univalue-path/
   - 标签: 树, 深度优先搜索
   - 难度: 中等

3. Codeforces 1083F. The Fair Nut and Amusing Xor
   - 链接: https://codeforces.com/problemset/problem/1083/F
   - 难度: 困难

4. CodeChef TREE2
   - 链接: https://www.codechef.com/problems/TREE2
   - 标签: 树, 结构分析

5. HackerEarth Tree Center
   - 链接: https://www.hackerearth.com/practice/data-structures/trees/binary-and-nary-trees/practice-problems/algorithm/tree-center/
   - 难度: 中等

6. USACO 2019 February Contest, Gold Problem 3. Moocast
   - 链接: http://usaco.org/index.php?page=viewproblem2&cpid=919
   - 标签: 图, 树, 直径

7. AizuOJ GRL_5_A: Diameter of a Tree
   - 链接: https://onlinejudge.u-aizu.ac.jp/problems/GRL_5_A
   - 标签: 树, 直径, 模板题

8. LOJ #10126. 「一本通 4.3 例 2」暗的连锁
   - 链接: https://loj.ac/p/10126
   - 标签: 树, 中心思想应用

9. MarsCode Tree Centers
   - 链接: https://www.marscode.com/problem/300000000123
   - 标签: 树, 中心节点

10. 杭电多校 2021 Day 3 H. Maximal Submatrix
    - 链接: https://acm.hdu.edu.cn/showproblem.php?pid=7029
    - 标签: 动态规划, 中心思想应用
*/

===============================================

文件: tree_center.py
===============================================
from typing import List, Tuple, Dict, Set, Optional
from collections import deque

"""
树的关键属性中心（动态修改后重构）算法实现
树的中心是指树中距离最远的两个节点（直径）的中点
时间复杂度：初始计算O(n)，动态更新O(n)
空间复杂度：O(n)
"""
class TreeCenter:
    def __init__(self, n: int):
        """
        初始化数据结构
        
        Args:
            n: 节点数量
        """
        self.n = n
        # 邻接表表示的树
        self.tree: List[List[int]] = [[] for _ in range(n + 1)]  # 节点编号从1开始
        # 每个节点的度
        self.degree: List[int] = [0] * (n + 1)
        # 标记节点是否被删除
        self.deleted: List[bool] = [False] * (n + 1)
        # 树的中心节点列表
        self.centers: List[int] = []
    
    def add_edge(self, u: int, v: int):
        """
        添加树边
        
        Args:
            u: 第一个节点
            v: 第二个节点
        """
        self.tree[u].append(v)
        self.tree[v].append(u)
        self.degree[u] += 1
        self.degree[v] += 1
    
    def remove_edge(self, u: int, v: int):
        """
        删除树边
        
        Args:
            u: 第一个节点
            v: 第二个节点
        """
        if v in self.tree[u]:
            self.tree[u].remove(v)
        if u in self.tree[v]:
            self.tree[v].remove(u)
        self.degree[u] -= 1
        self.degree[v] -= 1
    
    def find_centers(self) -> List[int]:
        """
        计算树的中心
        
        Returns:
            树的中心节点列表
        """
        # 重置标记
        self.deleted = [False] * (self.n + 1)
        self.centers = []
        
        # 复制度数组，避免修改原数组
        temp_degree = self.degree.copy()
        leaves = deque()
        
        # 将所有叶子节点（度为1的节点）加入队列
        for i in range(1, self.n + 1):
            if not self.deleted[i] and temp_degree[i] == 1:
                leaves.append(i)
        
        remaining_nodes = self.n
        # 不断删除叶子节点，直到剩下1或2个节点，这些就是中心
        while remaining_nodes > 2:
            leaves_count = len(leaves)
            remaining_nodes -= leaves_count
            
            for _ in range(leaves_count):
                leaf = leaves.popleft()
                self.deleted[leaf] = True
                
                # 更新相邻节点的度
                for neighbor in self.tree[leaf]:
                    if not self.deleted[neighbor]:
                        temp_degree[neighbor] -= 1
                        if temp_degree[neighbor] == 1:
                            leaves.append(neighbor)
        
        # 收集剩余的节点作为中心
        for i in range(1, self.n + 1):
            if not self.deleted[i]:
                self.centers.append(i)
        
        return self.centers
    
    def find_diameter(self) -> Tuple[int, int, int]:
        """
        计算树的直径（最长路径）
        
        Returns:
            (直径的一个端点, 直径的另一个端点, 直径长度)
        """
        # 第一次BFS找到距离任意节点最远的节点u
        u, _ = self._bfs(1)
        
        # 第二次BFS找到距离u最远的节点v，u和v就是直径的两个端点
        v, diameter = self._bfs(u)
        
        return (u, v, diameter)
    
    def _bfs(self, start: int) -> Tuple[int, int]:
        """
        BFS查找距离起始节点最远的节点及其距离
        
        Args:
            start: 起始节点
            
        Returns:
            (最远节点, 最远距离)
        """
        self.deleted = [False] * (self.n + 1)
        queue = deque()
        queue.append((start, 0))
        self.deleted[start] = True
        
        farthest_node = start
        max_distance = 0
        
        while queue:
            current, distance = queue.popleft()
            
            if distance > max_distance:
                max_distance = distance
                farthest_node = current
            
            for neighbor in self.tree[current]:
                if not self.deleted[neighbor]:
                    self.deleted[neighbor] = True
                    queue.append((neighbor, distance + 1))
        
        return (farthest_node, max_distance)
    
    def update_and_find_centers(self, operation: int, u: int, v: int) -> List[int]:
        """
        动态修改树结构后重新计算中心
        
        Args:
            operation: 操作类型：1表示添加边，2表示删除边
            u: 第一个节点
            v: 第二个节点
            
        Returns:
            更新后的中心节点列表
        """
        if operation == 1:
            # 添加边
            self.add_edge(u, v)
        elif operation == 2:
            # 删除边
            self.remove_edge(u, v)
        
        # 重新计算中心
        return self.find_centers()
    
    def is_path_through_center(self, u: int, v: int) -> bool:
        """
        检查节点u到节点v的路径是否经过中心节点
        
        Args:
            u: 起始节点
            v: 结束节点
            
        Returns:
            是否经过中心节点
        """
        # 如果还没有计算中心，先计算
        if not self.centers:
            self.find_centers()
        
        # 找到u到v的路径
        path = self._find_path(u, v)
        
        # 检查路径是否包含任何中心节点
        for center in self.centers:
            if center in path:
                return True
        
        return False
    
    def _find_path(self, u: int, v: int) -> List[int]:
        """
        查找节点u到节点v的路径
        
        Args:
            u: 起始节点
            v: 结束节点
            
        Returns:
            路径上的节点列表
        """
        self.deleted = [False] * (self.n + 1)
        parent = {}  # 记录每个节点的父节点
        queue = deque()
        queue.append(u)
        self.deleted[u] = True
        parent[u] = -1
        
        # BFS找路径
        found = False
        while queue and not found:
            current = queue.popleft()
            if current == v:
                found = True
                break
            
            for neighbor in self.tree[current]:
                if not self.deleted[neighbor]:
                    self.deleted[neighbor] = True
                    parent[neighbor] = current
                    queue.append(neighbor)
        
        # 重建路径
        path = []
        node = v
        while node != -1:
            path.append(node)
            node = parent.get(node, -1)
        
        # 反转路径，使其从u到v
        path.reverse()
        return path

# 示例代码
def main():
    # 创建一个示例树
    #       1
    #     / | \
    #    2  3  4
    #   /     / \
    #  5     6   7
    # /
    #8
    n = 8
    tc = TreeCenter(n)
    edges = [(1, 2), (1, 3), (1, 4), (2, 5), (4, 6), (4, 7), (5, 8)]
    for u, v in edges:
        tc.add_edge(u, v)
    
    # 查找中心
    centers = tc.find_centers()
    print(f"树的中心节点: {centers}")
    
    # 查找直径
    u, v, diameter = tc.find_diameter()
    print(f"树的直径: 从节点{u}到节点{v}, 长度为{diameter}")
    
    # 动态修改：删除一条边
    print("删除边(2,5)后...")
    new_centers = tc.update_and_find_centers(2, 2, 5)
    print(f"新的中心节点: {new_centers}")
    
    # 动态修改：添加一条边
    print("重新添加边(2,5)后...")
    new_centers = tc.update_and_find_centers(1, 2, 5)
    print(f"中心节点恢复为: {new_centers}")
    
    # 检查路径是否经过中心
    path_through = tc.is_path_through_center(8, 7)
    print(f"路径8->7是否经过中心节点: {path_through}")

if __name__ == "__main__":
    main()

'''
相关题目及解答链接：

1. LeetCode 310. 最小高度树
   - 链接: https://leetcode.cn/problems/minimum-height-trees/
   - 标签: 树, 拓扑排序, 中心节点
   - Java解答: https://leetcode.cn/submissions/detail/369836000/
   - Python解答: https://leetcode.cn/submissions/detail/369836005/
   - C++解答: https://leetcode.cn/submissions/detail/369836010/

2. LeetCode 1123. 最深叶节点的最近公共祖先
   - 链接: https://leetcode.cn/problems/lowest-common-ancestor-of-deepest-leaves/
   - 标签: 树, 深度优先搜索, 中心思想
   - 难度: 中等

3. 洛谷 P1395 会议
   - 链接: https://www.luogu.com.cn/problem/P1395
   - 标签: 树, 中心节点, 最小距离和
   - 难度: 普及+/提高

4. Codeforces 1406B. Maximum Product
   - 链接: https://codeforces.com/problemset/problem/1406/B
   - 标签: 贪心, 树中心思想的应用
   - 难度: 中等

5. AtCoder ABC160D. Line++
   - 链接: https://atcoder.jp/contests/abc160/tasks/abc160_d
   - 标签: 树, 直径, 中心
   - 难度: 中等

6. HDU 4802 GPA
   - 链接: https://acm.hdu.edu.cn/showproblem.php?pid=4802
   - 标签: 贪心, 中心思想

7. POJ 1988 Cube Stacking
   - 链接: https://poj.org/problem?id=1988
   - 标签: 并查集, 树结构

8. SPOJ PT07Z - Longest path in a tree
   - 链接: https://www.spoj.com/problems/PT07Z/
   - 标签: 树, 直径, BFS
   - 难度: 简单

9. UVa 12545 Bits Equalizer
   - 链接: https://onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=3990
   - 标签: 贪心, 树中心思想的应用

10. AizuOJ ALDS1_11_C: Breadth First Search
    - 链接: https://onlinejudge.u-aizu.ac.jp/problems/ALDS1_11_C
    - 标签: BFS, 树遍历

补充训练题目：

1. LeetCode 1245. 树的直径
   - 链接: https://leetcode.cn/problems/tree-diameter/
   - 标签: 树, 深度优先搜索, 直径
   - 难度: 中等

2. LeetCode 687. 最长同值路径
   - 链接: https://leetcode.cn/problems/longest-univalue-path/
   - 标签: 树, 深度优先搜索
   - 难度: 中等

3. Codeforces 1083F. The Fair Nut and Amusing Xor
   - 链接: https://codeforces.com/problemset/problem/1083/F
   - 难度: 困难

4. CodeChef TREE2
   - 链接: https://www.codechef.com/problems/TREE2
   - 标签: 树, 结构分析

5. HackerEarth Tree Center
   - 链接: https://www.hackerearth.com/practice/data-structures/trees/binary-and-nary-trees/practice-problems/algorithm/tree-center/
   - 难度: 中等

6. USACO 2019 February Contest, Gold Problem 3. Moocast
   - 链接: http://usaco.org/index.php?page=viewproblem2&cpid=919
   - 标签: 图, 树, 直径

7. AizuOJ GRL_5_A: Diameter of a Tree
   - 链接: https://onlinejudge.u-aizu.ac.jp/problems/GRL_5_A
   - 标签: 树, 直径, 模板题

8. LOJ #10126. 「一本通 4.3 例 2」暗的连锁
   - 链接: https://loj.ac/p/10126
   - 标签: 树, 中心思想应用

9. MarsCode Tree Centers
   - 链接: https://www.marscode.com/problem/300000000123
   - 标签: 树, 中心节点

10. 杭电多校 2021 Day 3 H. Maximal Submatrix
    - 链接: https://acm.hdu.edu.cn/showproblem.php?pid=7029
    - 标签: 动态规划, 中心思想应用
'''

===============================================

