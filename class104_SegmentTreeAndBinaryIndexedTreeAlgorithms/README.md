# çº¿æ®µæ ‘å’Œæ ‘çŠ¶æ•°ç»„ä¸“é¢˜è¯¦è§£

## ğŸ§  æ ¸å¿ƒæ¦‚å¿µ

çº¿æ®µæ ‘ï¼ˆSegment Treeï¼‰å’Œæ ‘çŠ¶æ•°ç»„ï¼ˆBinary Indexed Tree/Fenwick Treeï¼‰æ˜¯ä¸¤ç§é‡è¦çš„æ•°æ®ç»“æ„ï¼Œä¸»è¦ç”¨äºè§£å†³åŒºé—´æŸ¥è¯¢å’Œå•ç‚¹æ›´æ–°é—®é¢˜ã€‚

### çº¿æ®µæ ‘ï¼ˆSegment Treeï¼‰
- ä¸€ç§åŸºäºåˆ†æ²»æ€æƒ³çš„äºŒå‰æ ‘æ•°æ®ç»“æ„
- ä¸»è¦ç”¨äºè§£å†³åŒºé—´æŸ¥è¯¢å’ŒåŒºé—´æ›´æ–°é—®é¢˜
- æ¯ä¸ªèŠ‚ç‚¹ä»£è¡¨ä¸€ä¸ªåŒºé—´ï¼Œå¯ä»¥é«˜æ•ˆåœ°æ”¯æŒåŒºé—´æ“ä½œ
- æ—¶é—´å¤æ‚åº¦ï¼šO(log n) for æŸ¥è¯¢å’Œæ›´æ–°æ“ä½œ
- ç©ºé—´å¤æ‚åº¦ï¼šO(4n)

### æ ‘çŠ¶æ•°ç»„ï¼ˆBinary Indexed Tree/Fenwick Treeï¼‰
- ä¸€ç§æ›´ç®€æ´çš„æ•°æ®ç»“æ„ï¼Œä¸»è¦ç”¨äºè§£å†³å•ç‚¹æ›´æ–°å’Œå‰ç¼€å’ŒæŸ¥è¯¢é—®é¢˜
- ç›¸æ¯”çº¿æ®µæ ‘ï¼Œå®ç°æ›´ç®€å•ï¼Œå¸¸æ•°æ›´å°
- æ—¶é—´å¤æ‚åº¦ï¼šO(log n) for æŸ¥è¯¢å’Œæ›´æ–°æ“ä½œ
- ç©ºé—´å¤æ‚åº¦ï¼šO(n)

## ğŸš€ é¡¹ç›®ç‰¹è‰²

æœ¬é¡¹ç›®æä¾›äº†**Javaã€C++ã€Pythonä¸‰è¯­è¨€å®Œæ•´å®ç°**ï¼Œæ¯ä¸ªé¢˜ç›®éƒ½åŒ…å«ï¼š

- âœ… **è¯¦ç»†æ³¨é‡Š**ï¼šä»£ç é€»è¾‘æ¸…æ™°ï¼Œæ³¨é‡Šè¯¦å°½
- âœ… **å¤æ‚åº¦åˆ†æ**ï¼šæ—¶é—´å’Œç©ºé—´å¤æ‚åº¦è¯¦ç»†åˆ†æ
- âœ… **å®Œæ•´æµ‹è¯•**ï¼šå•å…ƒæµ‹è¯•è¦†ç›–å„ç§è¾¹ç•Œæƒ…å†µ
- âœ… **æ€§èƒ½ä¼˜åŒ–**ï¼šå·¥ç¨‹åŒ–å¼‚å¸¸å¤„ç†å’Œæ€§èƒ½è€ƒé‡
- âœ… **ç®—æ³•æ€»ç»“**ï¼šé¢˜å‹åˆ†ç±»å’Œè§£é¢˜æŠ€å·§æ€»ç»“

## ğŸ“š æœ¬ä¸“é¢˜é¢˜ç›®åˆ—è¡¨

### æ ¸å¿ƒé¢˜ç›®
1. **Code01_CountOfRangeSum** - åŒºé—´å’Œçš„ä¸ªæ•°
   - æ¥æºï¼šLeetCode 327
   - éš¾åº¦ï¼šå›°éš¾
   - ç®—æ³•ï¼šå½’å¹¶æ’åºã€çº¿æ®µæ ‘
   - ä¸‰è¯­è¨€å®ç°ï¼šâœ… Java âœ… C++ âœ… Python
   - æ—¶é—´å¤æ‚åº¦ï¼šO(n log n)
   - ç©ºé—´å¤æ‚åº¦ï¼šO(n)

2. **Code02_MaximumBalancedSubsequence** - å¹³è¡¡å­åºåˆ—çš„æœ€å¤§å’Œ
   - æ¥æºï¼šLeetCode 2784
   - éš¾åº¦ï¼šå›°éš¾
   - ç®—æ³•ï¼šæ ‘çŠ¶æ•°ç»„ã€ç¦»æ•£åŒ–
   - ä¸‰è¯­è¨€å®ç°ï¼šâœ… Java âœ… C++ âœ… Python
   - æ—¶é—´å¤æ‚åº¦ï¼šO(n log n)
   - ç©ºé—´å¤æ‚åº¦ï¼šO(n)

3. **Code03_CornField** - æ–¹ä¼¯ä¼¯çš„ç‰ç±³ç”°
   - æ¥æºï¼šæ´›è°· P3287
   - éš¾åº¦ï¼šå›°éš¾
   - ç®—æ³•ï¼šäºŒç»´æ ‘çŠ¶æ•°ç»„ã€åŠ¨æ€è§„åˆ’
   - ä¸‰è¯­è¨€å®ç°ï¼šâœ… Java âœ… C++ âœ… Python
   - æ—¶é—´å¤æ‚åº¦ï¼šO(nÂ² log n)
   - ç©ºé—´å¤æ‚åº¦ï¼šO(nÂ²)

4. **Code04_LongestIdealString** - æœ€é•¿ç†æƒ³å­åºåˆ—
   - æ¥æºï¼šLeetCode 2370
   - éš¾åº¦ï¼šä¸­ç­‰
   - ç®—æ³•ï¼šçº¿æ®µæ ‘ã€åŠ¨æ€è§„åˆ’
   - ä¸‰è¯­è¨€å®ç°ï¼šâœ… Java âœ… C++ âœ… Python
   - æ—¶é—´å¤æ‚åº¦ï¼šO(n)
   - ç©ºé—´å¤æ‚åº¦ï¼šO(1)

5. **Code05_TheBakery** - åˆ’åˆ†kæ®µçš„æœ€å¤§å¾—åˆ†
   - æ¥æºï¼šCodeforces 833B
   - éš¾åº¦ï¼šå›°éš¾
   - ç®—æ³•ï¼šçº¿æ®µæ ‘ã€åŠ¨æ€è§„åˆ’
   - ä¸‰è¯­è¨€å®ç°ï¼šâœ… Java âœ… C++ âœ… Python
   - æ—¶é—´å¤æ‚åº¦ï¼šO(nk log n)
   - ç©ºé—´å¤æ‚åº¦ï¼šO(nk)

6. **Code06_StationLocation** - åŸºç«™é€‰å€
   - æ¥æºï¼šæ´›è°· P2605
   - éš¾åº¦ï¼šå›°éš¾
   - ç®—æ³•ï¼šçº¿æ®µæ ‘ã€åŠ¨æ€è§„åˆ’
   - ä¸‰è¯­è¨€å®ç°ï¼šâœ… Java âœ… C++ âœ… Python
   - æ—¶é—´å¤æ‚åº¦ï¼šO(nÂ²)
   - ç©ºé—´å¤æ‚åº¦ï¼šO(n)

7. **Code07_RangeSumQueryMutable_SegmentTree** - åŒºåŸŸå’Œæ£€ç´¢ï¼ˆçº¿æ®µæ ‘ç‰ˆï¼‰
   - æ¥æºï¼šLeetCode 307
   - éš¾åº¦ï¼šä¸­ç­‰
   - ç®—æ³•ï¼šçº¿æ®µæ ‘
   - ä¸‰è¯­è¨€å®ç°ï¼šâœ… Java âœ… C++ âœ… Python
   - æ—¶é—´å¤æ‚åº¦ï¼šO(n)å»ºæ ‘ï¼ŒO(log n)æŸ¥è¯¢/æ›´æ–°
   - ç©ºé—´å¤æ‚åº¦ï¼šO(4n)

8. **Code08_RangeSumQueryMutable_BIT** - åŒºåŸŸå’Œæ£€ç´¢ï¼ˆæ ‘çŠ¶æ•°ç»„ç‰ˆï¼‰
   - æ¥æºï¼šLeetCode 307
   - éš¾åº¦ï¼šä¸­ç­‰
   - ç®—æ³•ï¼šæ ‘çŠ¶æ•°ç»„
   - ä¸‰è¯­è¨€å®ç°ï¼šâœ… Java âœ… C++ âœ… Python
   - æ—¶é—´å¤æ‚åº¦ï¼šO(n log n)åˆå§‹åŒ–ï¼ŒO(log n)æŸ¥è¯¢/æ›´æ–°
   - ç©ºé—´å¤æ‚åº¦ï¼šO(n)

9. **Code09_CountSmallerNumbersAfterSelf** - è®¡ç®—å³ä¾§å°äºå½“å‰å…ƒç´ çš„ä¸ªæ•°
   - æ¥æºï¼šLeetCode 315
   - éš¾åº¦ï¼šå›°éš¾
   - ç®—æ³•ï¼šæ ‘çŠ¶æ•°ç»„ã€ç¦»æ•£åŒ–
   - ä¸‰è¯­è¨€å®ç°ï¼šâœ… Java âœ… C++ âœ… Python
   - æ—¶é—´å¤æ‚åº¦ï¼šO(n log n)
   - ç©ºé—´å¤æ‚åº¦ï¼šO(n)

### æ‰©å±•é¢˜ç›®
10. **Code14_RangeXORQuery** - åŒºé—´å¼‚æˆ–æŸ¥è¯¢
    - æ¥æºï¼šè‡ªå®šä¹‰é¢˜ç›®
    - éš¾åº¦ï¼šä¸­ç­‰
    - ç®—æ³•ï¼šçº¿æ®µæ ‘
    - ä¸‰è¯­è¨€å®ç°ï¼šâœ… Java âœ… C++ âœ… Python

11. **Code15_MaximumSubarraySum** - æœ€å¤§å­æ•°ç»„å’Œ
    - æ¥æºï¼šLeetCode 53
    - éš¾åº¦ï¼šä¸­ç­‰
    - ç®—æ³•ï¼šçº¿æ®µæ ‘
    - ä¸‰è¯­è¨€å®ç°ï¼šâœ… Java âœ… C++ âœ… Python

12. **Code16_KthNumber** - åŒºé—´ç¬¬Kå¤§æ•°
    - æ¥æºï¼šè‡ªå®šä¹‰é¢˜ç›®
    - éš¾åº¦ï¼šå›°éš¾
    - ç®—æ³•ï¼šçº¿æ®µæ ‘ã€äºŒåˆ†æŸ¥æ‰¾
    - ä¸‰è¯­è¨€å®ç°ï¼šâœ… Java âœ… C++ âœ… Python

13. **Code17_SegmentTreeMerge** - çº¿æ®µæ ‘åˆå¹¶
    - æ¥æºï¼šè‡ªå®šä¹‰é¢˜ç›®
    - éš¾åº¦ï¼šå›°éš¾
    - ç®—æ³•ï¼šçº¿æ®µæ ‘åˆå¹¶
    - ä¸‰è¯­è¨€å®ç°ï¼šâœ… Java âœ… C++ âœ… Python

14. **Code18_FenwickTreeWithSegmentTree** - æ ‘çŠ¶æ•°ç»„ä¸çº¿æ®µæ ‘ç»“åˆ
    - æ¥æºï¼šè‡ªå®šä¹‰é¢˜ç›®
    - éš¾åº¦ï¼šå›°éš¾
    - ç®—æ³•ï¼šæ ‘çŠ¶æ•°ç»„ã€çº¿æ®µæ ‘
    - ä¸‰è¯­è¨€å®ç°ï¼šâœ… Java âœ… C++ âœ… Python

15. **Code19_2DSegmentTree** - äºŒç»´çº¿æ®µæ ‘
    - æ¥æºï¼šè‡ªå®šä¹‰é¢˜ç›®
    - éš¾åº¦ï¼šå›°éš¾
    - ç®—æ³•ï¼šäºŒç»´çº¿æ®µæ ‘
    - ä¸‰è¯­è¨€å®ç°ï¼šâœ… Java âœ… C++ âœ… Python

## ğŸš€ å¿«é€Ÿå¼€å§‹

### Java ç¼–è¯‘è¿è¡Œ
```bash
# ç¼–è¯‘
javac Code01_CountOfRangeSum1.java

# è¿è¡Œ
java Code01_CountOfRangeSum1

# æ‰¹é‡ç¼–è¯‘æ‰€æœ‰Javaæ–‡ä»¶
javac *.java
```

### C++ ç¼–è¯‘è¿è¡Œ
```bash
# ç¼–è¯‘
g++ -std=c++17 Code01_CountOfRangeSum1.cpp -o test

# è¿è¡Œ
./test

# æ‰¹é‡ç¼–è¯‘æ‰€æœ‰C++æ–‡ä»¶
for file in *.cpp; do
    g++ -std=c++17 "$file" -o "${file%.cpp}"
done
```

### Python è¿è¡Œ
```bash
# ç›´æ¥è¿è¡Œ
python Code01_CountOfRangeSum1.py

# éªŒè¯è¯­æ³•
python -m py_compile Code01_CountOfRangeSum1.py

# æ‰¹é‡éªŒè¯æ‰€æœ‰Pythonæ–‡ä»¶
for file in *.py; do
    python -m py_compile "$file"
done
```

## ğŸ§ª æµ‹è¯•éªŒè¯

æ¯ä¸ªä»£ç æ–‡ä»¶éƒ½åŒ…å«å®Œæ•´çš„æµ‹è¯•ç”¨ä¾‹ï¼ŒåŒ…æ‹¬ï¼š

- âœ… **è¾¹ç•Œæµ‹è¯•**ï¼šç©ºæ•°ç»„ã€å•å…ƒç´ ç­‰
- âœ… **åŠŸèƒ½æµ‹è¯•**ï¼šæ­£å¸¸è¾“å…¥éªŒè¯
- âœ… **æ€§èƒ½æµ‹è¯•**ï¼šå¤§è§„æ¨¡æ•°æ®æµ‹è¯•
- âœ… **å¼‚å¸¸æµ‹è¯•**ï¼šéæ³•è¾“å…¥å¤„ç†

### è¿è¡Œæµ‹è¯•ç¤ºä¾‹
```java
// Javaæµ‹è¯•è¾“å‡ºç¤ºä¾‹
public static void main(String[] args) {
    // åŸºæœ¬åŠŸèƒ½æµ‹è¯•
    testBasicFunctionality();
    
    // è¾¹ç•Œæ¡ä»¶æµ‹è¯•
    testEdgeCases();
    
    // æ€§èƒ½æµ‹è¯•
    testPerformance();
    
    System.out.println("æ‰€æœ‰æµ‹è¯•é€šè¿‡ï¼");
}
```

## ğŸ“Š æ€§èƒ½åŸºå‡†

### æ—¶é—´å¤æ‚åº¦å¯¹æ¯”
| ç®—æ³• | å»ºæ ‘æ—¶é—´ | æŸ¥è¯¢æ—¶é—´ | æ›´æ–°æ—¶é—´ | ç©ºé—´å¤æ‚åº¦ |
|------|----------|----------|----------|------------|
| çº¿æ®µæ ‘ | O(n) | O(log n) | O(log n) | O(4n) |
| æ ‘çŠ¶æ•°ç»„ | O(n log n) | O(log n) | O(log n) | O(n) |

### é€‚ç”¨åœºæ™¯
- **çº¿æ®µæ ‘**ï¼šéœ€è¦åŒºé—´æ›´æ–°ã€åŒºé—´æŸ¥è¯¢çš„å¤æ‚æ“ä½œ
- **æ ‘çŠ¶æ•°ç»„**ï¼šåªéœ€è¦å•ç‚¹æ›´æ–°ã€å‰ç¼€å’ŒæŸ¥è¯¢çš„ç®€å•æ“ä½œ

## ğŸ”§ å·¥ç¨‹åŒ–ç‰¹æ€§

### 1. å¼‚å¸¸å¤„ç†
æ¯ä¸ªå®ç°éƒ½åŒ…å«å®Œæ•´çš„è¾“å…¥éªŒè¯å’Œå¼‚å¸¸å¤„ç†ï¼š
```java
// è¾“å…¥éªŒè¯ç¤ºä¾‹
if (nums == null || nums.length == 0) {
    throw new IllegalArgumentException("è¾“å…¥æ•°ç»„ä¸èƒ½ä¸ºç©º");
}
```

### 2. è¾¹ç•Œæ¡ä»¶å¤„ç†
- ç©ºæ•°ç»„å¤„ç†
- å•å…ƒç´ å¤„ç†
- é‡å¤å…ƒç´ å¤„ç†
- æç«¯å€¼å¤„ç†

### 3. æ€§èƒ½ä¼˜åŒ–
- å†…å­˜ä¼˜åŒ–ï¼šä½¿ç”¨æ»šåŠ¨æ•°ç»„
- æ—¶é—´ä¼˜åŒ–ï¼šé¢„å¤„ç†+æŸ¥è¯¢åˆ†ç¦»
- å¸¸æ•°ä¼˜åŒ–ï¼šé€‰æ‹©åˆé€‚çš„æ•°æ®ç»“æ„

## ğŸ“š å­¦ä¹ è·¯å¾„

### åˆçº§ï¼ˆå»ºè®®é¡ºåºï¼‰
1. `Code07_RangeSumQueryMutable_SegmentTree` - çº¿æ®µæ ‘åŸºç¡€
2. `Code08_RangeSumQueryMutable_BIT` - æ ‘çŠ¶æ•°ç»„åŸºç¡€
3. `Code04_LongestIdealString` - ç®€å•åº”ç”¨

### ä¸­çº§
1. `Code09_CountSmallerNumbersAfterSelf` - ç¦»æ•£åŒ–+æ ‘çŠ¶æ•°ç»„
2. `Code01_CountOfRangeSum` - å½’å¹¶æ’åº+çº¿æ®µæ ‘
3. `Code02_MaximumBalancedSubsequence` - åŠ¨æ€è§„åˆ’ä¼˜åŒ–

### é«˜çº§
1. `Code05_TheBakery` - å¤æ‚åŠ¨æ€è§„åˆ’
2. `Code03_CornField` - äºŒç»´æ ‘çŠ¶æ•°ç»„
3. `Code06_StationLocation` - çº¿æ®µæ ‘ä¼˜åŒ–DP

## ğŸ¯ é¢è¯•å‡†å¤‡

### å¸¸è§é¢è¯•é—®é¢˜
1. çº¿æ®µæ ‘å’Œæ ‘çŠ¶æ•°ç»„çš„åŒºåˆ«ï¼Ÿ
2. ä»€ä¹ˆæ—¶å€™é€‰æ‹©çº¿æ®µæ ‘ï¼Ÿä»€ä¹ˆæ—¶å€™é€‰æ‹©æ ‘çŠ¶æ•°ç»„ï¼Ÿ
3. å¦‚ä½•ä¼˜åŒ–çº¿æ®µæ ‘çš„ç©ºé—´å¤æ‚åº¦ï¼Ÿ
4. ç¦»æ•£åŒ–çš„ä½œç”¨æ˜¯ä»€ä¹ˆï¼Ÿ

### è§£é¢˜æŠ€å·§
1. è¯†åˆ«é—®é¢˜ç±»å‹ï¼šåŒºé—´æŸ¥è¯¢ã€åŠ¨æ€è§„åˆ’ä¼˜åŒ–ã€è®¡æ•°ç»Ÿè®¡
2. é€‰æ‹©åˆé€‚çš„æ•°æ®ç»“æ„
3. è€ƒè™‘ç¦»æ•£åŒ–å¤„ç†
4. ä¼˜åŒ–ç©ºé—´å’Œæ—¶é—´å¤æ‚åº¦

## ğŸ”— ç›¸å…³èµ„æº

### åœ¨çº¿è¯„æµ‹å¹³å°
- [LeetCode](https://leetcode.com)
- [Codeforces](https://codeforces.com)
- [æ´›è°·](https://www.luogu.com.cn)
- [AtCoder](https://atcoder.jp)

### å­¦ä¹ èµ„æ–™
- ã€Šç®—æ³•å¯¼è®ºã€‹- çº¿æ®µæ ‘å’Œæ ‘çŠ¶æ•°ç»„ç« èŠ‚
- ã€ŠæŒ‘æˆ˜ç¨‹åºè®¾è®¡ç«èµ›ã€‹- æ•°æ®ç»“æ„ä¸“é¢˜
- å„å¤§é«˜æ ¡ç®—æ³•è¯¾ç¨‹è®²ä¹‰

## ğŸ¤ è´¡çŒ®æŒ‡å—

æ¬¢è¿æäº¤Issueå’ŒPull Requestæ¥æ”¹è¿›æœ¬é¡¹ç›®ï¼š

1. å‘ç°bugæˆ–é—®é¢˜
2. æä¾›æ–°çš„é¢˜ç›®å®ç°
3. ä¼˜åŒ–ç°æœ‰ä»£ç 
4. å®Œå–„æ–‡æ¡£å’Œæ³¨é‡Š

## ğŸ“„ è®¸å¯è¯

æœ¬é¡¹ç›®é‡‡ç”¨MITè®¸å¯è¯ï¼Œè¯¦è§LICENSEæ–‡ä»¶ã€‚
   - ä¸‰è¯­è¨€å®ç°ï¼šâœ… Java âœ… C++ âœ… Python
   - æ—¶é—´å¤æ‚åº¦ï¼šO(n log n)
   - ç©ºé—´å¤æ‚åº¦ï¼šO(n)

### æ‰©å±•é¢˜ç›®
10. **Code14_RangeXORQuery** - åŒºé—´å¼‚æˆ–æŸ¥è¯¢
    - æ¥æºï¼šè‡ªå®šä¹‰é¢˜ç›®
    - éš¾åº¦ï¼šä¸­ç­‰
    - ç®—æ³•ï¼šçº¿æ®µæ ‘
    - ä¸‰è¯­è¨€å®ç°ï¼šâœ… Java âœ… C++ âœ… Python

11. **Code15_MaximumSubarraySum** - æœ€å¤§å­æ•°ç»„å’Œ
    - æ¥æºï¼šLeetCode 53
    - éš¾åº¦ï¼šä¸­ç­‰
    - ç®—æ³•ï¼šçº¿æ®µæ ‘
    - ä¸‰è¯­è¨€å®ç°ï¼šâœ… Java âœ… C++ âœ… Python

12. **Code16_KthNumber** - åŒºé—´ç¬¬Kå¤§æ•°
    - æ¥æºï¼šè‡ªå®šä¹‰é¢˜ç›®
    - éš¾åº¦ï¼šå›°éš¾
    - ç®—æ³•ï¼šçº¿æ®µæ ‘ã€äºŒåˆ†æŸ¥æ‰¾
    - ä¸‰è¯­è¨€å®ç°ï¼šâœ… Java âœ… C++ âœ… Python

13. **Code17_SegmentTreeMerge** - çº¿æ®µæ ‘åˆå¹¶
    - æ¥æºï¼šè‡ªå®šä¹‰é¢˜ç›®
    - éš¾åº¦ï¼šå›°éš¾
    - ç®—æ³•ï¼šçº¿æ®µæ ‘åˆå¹¶
    - ä¸‰è¯­è¨€å®ç°ï¼šâœ… Java âœ… C++ âœ… Python

14. **Code18_FenwickTreeWithSegmentTree** - æ ‘çŠ¶æ•°ç»„ä¸çº¿æ®µæ ‘ç»“åˆ
    - æ¥æºï¼šè‡ªå®šä¹‰é¢˜ç›®
    - éš¾åº¦ï¼šå›°éš¾
    - ç®—æ³•ï¼šæ ‘çŠ¶æ•°ç»„ã€çº¿æ®µæ ‘
    - ä¸‰è¯­è¨€å®ç°ï¼šâœ… Java âœ… C++ âœ… Python

15. **Code19_2DSegmentTree** - äºŒç»´çº¿æ®µæ ‘
    - æ¥æºï¼šè‡ªå®šä¹‰é¢˜ç›®
    - éš¾åº¦ï¼šå›°éš¾
    - ç®—æ³•ï¼šäºŒç»´çº¿æ®µæ ‘
    - ä¸‰è¯­è¨€å®ç°ï¼šâœ… Java âœ… C++ âœ… Python

## ğŸ“š æœ¬ä¸“é¢˜é¢˜ç›®åˆ—è¡¨

### æ ¸å¿ƒé¢˜ç›®
1. **Code01_CountOfRangeSum** - åŒºé—´å’Œçš„ä¸ªæ•°
   - æ¥æºï¼šLeetCode 327
   - éš¾åº¦ï¼šå›°éš¾
   - ç®—æ³•ï¼šå½’å¹¶æ’åºã€çº¿æ®µæ ‘

2. **Code02_MaximumBalancedSubsequence** - å¹³è¡¡å­åºåˆ—çš„æœ€å¤§å’Œ
   - æ¥æºï¼šLeetCode 2784
   - éš¾åº¦ï¼šå›°éš¾
   - ç®—æ³•ï¼šæ ‘çŠ¶æ•°ç»„ã€ç¦»æ•£åŒ–

3. **Code03_CornField** - æ–¹ä¼¯ä¼¯çš„ç‰ç±³ç”°
   - æ¥æºï¼šæ´›è°· P3287
   - éš¾åº¦ï¼šå›°éš¾
   - ç®—æ³•ï¼šäºŒç»´æ ‘çŠ¶æ•°ç»„ã€åŠ¨æ€è§„åˆ’

4. **Code04_LongestIdealString** - æœ€é•¿ç†æƒ³å­åºåˆ—
   - æ¥æºï¼šLeetCode 2370
   - éš¾åº¦ï¼šä¸­ç­‰
   - ç®—æ³•ï¼šçº¿æ®µæ ‘ã€åŠ¨æ€è§„åˆ’

5. **Code05_TheBakery** - åˆ’åˆ†kæ®µçš„æœ€å¤§å¾—åˆ†
   - æ¥æºï¼šCodeforces 833B
   - éš¾åº¦ï¼šå›°éš¾
   - ç®—æ³•ï¼šçº¿æ®µæ ‘ã€åŠ¨æ€è§„åˆ’

6. **Code06_StationLocation** - åŸºç«™é€‰å€
   - æ¥æºï¼šæ´›è°· P2605
   - éš¾åº¦ï¼šå›°éš¾
   - ç®—æ³•ï¼šçº¿æ®µæ ‘ã€åŠ¨æ€è§„åˆ’

## ğŸ”§ è¡¥å……é¢˜ç›®åˆ—è¡¨

### LeetCodeé¢˜ç›®
1. **LeetCode 307. Range Sum Query - Mutable**
   - é¢˜ç›®æè¿°ï¼šæ”¯æŒæ•°ç»„çš„å•ç‚¹æ›´æ–°å’ŒåŒºé—´æ±‚å’ŒæŸ¥è¯¢
   - ç®—æ³•ï¼šçº¿æ®µæ ‘ã€æ ‘çŠ¶æ•°ç»„

2. **LeetCode 315. Count of Smaller Numbers After Self**
   - é¢˜ç›®æè¿°ï¼šè®¡ç®—æ•°ç»„å³ä¾§æ¯”å½“å‰å…ƒç´ å°çš„å…ƒç´ ä¸ªæ•°
   - ç®—æ³•ï¼šå½’å¹¶æ’åºã€æ ‘çŠ¶æ•°ç»„ã€çº¿æ®µæ ‘

3. **LeetCode 493. Reverse Pairs**
   - é¢˜ç›®æè¿°ï¼šè®¡ç®—æ•°ç»„ä¸­é‡è¦çš„ç¿»è½¬å¯¹ä¸ªæ•°
   - ç®—æ³•ï¼šå½’å¹¶æ’åºã€æ ‘çŠ¶æ•°ç»„ã€çº¿æ®µæ ‘

4. **LeetCode 303. Range Sum Query - Immutable**
   - é¢˜ç›®æè¿°ï¼šè®¡ç®—æ•°ç»„åŒºé—´å’Œï¼ˆä¸å¯å˜ï¼‰
   - ç®—æ³•ï¼šå‰ç¼€å’Œ

5. **LeetCode 304. Range Sum Query 2D - Immutable**
   - é¢˜ç›®æè¿°ï¼šè®¡ç®—äºŒç»´æ•°ç»„å­çŸ©é˜µå’Œï¼ˆä¸å¯å˜ï¼‰
   - ç®—æ³•ï¼šäºŒç»´å‰ç¼€å’Œ

6. **LeetCode 308. Range Sum Query 2D - Mutable**
   - é¢˜ç›®æè¿°ï¼šè®¡ç®—äºŒç»´æ•°ç»„å­çŸ©é˜µå’Œï¼ˆå¯å˜ï¼‰
   - ç®—æ³•ï¼šäºŒç»´çº¿æ®µæ ‘ã€äºŒç»´æ ‘çŠ¶æ•°ç»„

7. **LeetCode 327. Count of Range Sum**
   - é¢˜ç›®æè¿°ï¼šè®¡ç®—åŒºé—´å’Œåœ¨æŒ‡å®šèŒƒå›´å†…çš„ä¸ªæ•°
   - ç®—æ³•ï¼šå½’å¹¶æ’åºã€çº¿æ®µæ ‘

8. **LeetCode 1157. Online Majority Element In Subarray**
   - é¢˜ç›®æè¿°ï¼šæŸ¥è¯¢å­æ•°ç»„ä¸­å‡ºç°æ¬¡æ•°è¶…è¿‡é˜ˆå€¼çš„å…ƒç´ 
   - ç®—æ³•ï¼šçº¿æ®µæ ‘ã€éšæœºåŒ–

9. **LeetCode 715. Range Module**
   - é¢˜ç›®æè¿°ï¼šå®ç°èŒƒå›´æ·»åŠ ã€æŸ¥è¯¢ã€åˆ é™¤æ“ä½œ
   - ç®—æ³•ï¼šçº¿æ®µæ ‘ã€å¹³è¡¡äºŒå‰æœç´¢æ ‘

10. **LeetCode 699. Falling Squares**
    - é¢˜ç›®æè¿°ï¼šè®¡ç®—æ¯æ¬¡æ–¹å—è½ä¸‹åçš„æœ€å¤§é«˜åº¦
    - ç®—æ³•ï¼šçº¿æ®µæ ‘ã€åæ ‡ç¦»æ•£åŒ–

### Codeforcesé¢˜ç›®
1. **Codeforces 833B. The Bakery**
   - é¢˜ç›®æè¿°ï¼šå°†æ•°ç»„åˆ†æˆkæ®µï¼Œæœ€å¤§åŒ–æ¯æ®µä¸åŒå…ƒç´ ä¸ªæ•°ä¹‹å’Œ
   - ç®—æ³•ï¼šçº¿æ®µæ ‘ã€åŠ¨æ€è§„åˆ’

2. **Codeforces 52C. Circular RMQ**
   - é¢˜ç›®æè¿°ï¼šå¾ªç¯æ•°ç»„çš„åŒºé—´æœ€å°å€¼æŸ¥è¯¢å’Œæ›´æ–°
   - ç®—æ³•ï¼šçº¿æ®µæ ‘

3. **Codeforces 242E. XOR on Segment**
   - é¢˜ç›®æè¿°ï¼šåŒºé—´å¼‚æˆ–å’ŒåŒºé—´æ±‚å’Œæ“ä½œ
   - ç®—æ³•ï¼šçº¿æ®µæ ‘ã€ä½è¿ç®—

4. **Codeforces 438D. The Child and Sequence**
   - é¢˜ç›®æè¿°ï¼šåŒºé—´å–æ¨¡å’ŒåŒºé—´æœ€å¤§å€¼æŸ¥è¯¢
   - ç®—æ³•ï¼šçº¿æ®µæ ‘

5. **Codeforces 145E. Lucky Queries**
   - é¢˜ç›®æè¿°ï¼šåŒºé—´å­—ç¬¦äº¤æ¢å’ŒæŸ¥è¯¢
   - ç®—æ³•ï¼šçº¿æ®µæ ‘

6. **Codeforces 380C. Sereja and Brackets**
   - é¢˜ç›®æè¿°ï¼šæŸ¥è¯¢åŒºé—´å†…èƒ½ç»„æˆçš„æœ€å¤§æ‹¬å·å¯¹æ•°
   - ç®—æ³•ï¼šçº¿æ®µæ ‘
   - é“¾æ¥ï¼šhttps://codeforces.com/problemset/problem/380/C

7. **Codeforces 1234D. Distinct Characters Queries**
   - é¢˜ç›®æè¿°ï¼šåŠ¨æ€å­—ç¬¦ä¸²åŒºé—´ä¸åŒå­—ç¬¦æŸ¥è¯¢
   - ç®—æ³•ï¼šçº¿æ®µæ ‘ã€ä½è¿ç®—
   - é“¾æ¥ï¼šhttps://codeforces.com/problemset/problem/1234/D

### æ´›è°·é¢˜ç›®
1. **æ´›è°· P3372. ã€æ¨¡æ¿ã€‘çº¿æ®µæ ‘ 1**
   - é¢˜ç›®æè¿°ï¼šåŒºé—´åŠ æ³•å’ŒåŒºé—´æ±‚å’Œ
   - ç®—æ³•ï¼šçº¿æ®µæ ‘

2. **æ´›è°· P3373. ã€æ¨¡æ¿ã€‘çº¿æ®µæ ‘ 2**
   - é¢˜ç›®æè¿°ï¼šåŒºé—´ä¹˜æ³•ã€åŠ æ³•å’ŒåŒºé—´æ±‚å’Œ
   - ç®—æ³•ï¼šçº¿æ®µæ ‘

3. **æ´›è°· P3368. ã€æ¨¡æ¿ã€‘æ ‘çŠ¶æ•°ç»„ 2**
   - é¢˜ç›®æè¿°ï¼šåŒºé—´ä¿®æ”¹å’Œå•ç‚¹æŸ¥è¯¢
   - ç®—æ³•ï¼šæ ‘çŠ¶æ•°ç»„

4. **æ´›è°· P1908. é€†åºå¯¹**
   - é¢˜ç›®æè¿°ï¼šè®¡ç®—æ•°ç»„ä¸­é€†åºå¯¹çš„ä¸ªæ•°
   - ç®—æ³•ï¼šå½’å¹¶æ’åºã€æ ‘çŠ¶æ•°ç»„

5. **æ´›è°· P1972. [SDOI2009] HHçš„é¡¹é“¾**
   - é¢˜ç›®æè¿°ï¼šåŒºé—´ä¸åŒå…ƒç´ ä¸ªæ•°æŸ¥è¯¢
   - ç®—æ³•ï¼šæ ‘çŠ¶æ•°ç»„ã€è«é˜Ÿç®—æ³•

6. **æ´›è°· P1533. å¯æ€œçš„ç‹—ç‹—**
   - é¢˜ç›®æè¿°ï¼šåŒºé—´ä¸åŒå…ƒç´ ä¸ªæ•°æŸ¥è¯¢
   - ç®—æ³•ï¼šä¸»å¸­æ ‘
   - é“¾æ¥ï¼šhttps://www.luogu.com.cn/problem/P1533

7. **æ´›è°· P2839. [å›½å®¶é›†è®­é˜Ÿ] middle**
   - é¢˜ç›®æè¿°ï¼šåŒºé—´ä¸­ä½æ•°æŸ¥è¯¢
   - ç®—æ³•ï¼šä¸»å¸­æ ‘ã€äºŒåˆ†ç­”æ¡ˆ
   - é“¾æ¥ï¼šhttps://www.luogu.com.cn/problem/P2839

### LintCodeé¢˜ç›®
1. **LintCode 247. Segment Tree Query II**
   - é¢˜ç›®æè¿°ï¼šæŸ¥è¯¢åŒºé—´å†…å…ƒç´ ä¸ªæ•°
   - ç®—æ³•ï¼šçº¿æ®µæ ‘

2. **LintCode 439. Segment Tree Build II**
   - é¢˜ç›®æè¿°ï¼šæ„å»ºæœ€å¤§çº¿æ®µæ ‘
   - ç®—æ³•ï¼šçº¿æ®µæ ‘

### SPOJé¢˜ç›®
1. **SPOJ GSS1. Can you answer these queries I**
   - é¢˜ç›®æè¿°ï¼šåŒºé—´æœ€å¤§å­æ®µå’ŒæŸ¥è¯¢
   - ç®—æ³•ï¼šçº¿æ®µæ ‘
   - é“¾æ¥ï¼šhttps://www.spoj.com/problems/GSS1/

2. **SPOJ GSS3. Can you answer these queries III**
   - é¢˜ç›®æè¿°ï¼šåŒºé—´æœ€å¤§å­æ®µå’ŒæŸ¥è¯¢ï¼ˆæ”¯æŒå•ç‚¹æ›´æ–°ï¼‰
   - ç®—æ³•ï¼šçº¿æ®µæ ‘
   - é“¾æ¥ï¼šhttps://www.spoj.com/problems/GSS3/

3. **SPOJ MKTHNUM. K-th Number**
   - é¢˜ç›®æè¿°ï¼šåŒºé—´ç¬¬kå°å…ƒç´ æŸ¥è¯¢
   - ç®—æ³•ï¼šä¸»å¸­æ ‘
   - é“¾æ¥ï¼šhttps://www.spoj.com/problems/MKTHNUM/

4. **SPOJ DQUERY. D-query**
   - é¢˜ç›®æè¿°ï¼šåŒºé—´ä¸åŒå…ƒç´ ä¸ªæ•°æŸ¥è¯¢
   - ç®—æ³•ï¼šä¸»å¸­æ ‘ã€è«é˜Ÿç®—æ³•
   - é“¾æ¥ï¼šhttps://www.spoj.com/problems/DQUERY/

### AtCoderé¢˜ç›®
1. **AtCoder ABC185F. Range Xor Query**
   - é¢˜ç›®æè¿°ï¼šåŒºé—´å¼‚æˆ–æŸ¥è¯¢
   - ç®—æ³•ï¼šçº¿æ®µæ ‘ã€æ ‘çŠ¶æ•°ç»„
   - é“¾æ¥ï¼šhttps://atcoder.jp/contests/abc185/tasks/abc185_f

2. **AtCoder ABC234F. Predilection**
   - é¢˜ç›®æè¿°ï¼šåŒºé—´åˆå¹¶æœ€å¤§å€¼æŸ¥è¯¢
   - ç®—æ³•ï¼šçº¿æ®µæ ‘ã€åŠ¨æ€è§„åˆ’
   - é“¾æ¥ï¼šhttps://atcoder.jp/contests/abc234/tasks/abc234_f

### HackerRanké¢˜ç›®
1. **HackerRank Array Manipulation**
   - é¢˜ç›®æè¿°ï¼šåŒºé—´åŠ æ³•æ“ä½œåæŸ¥è¯¢æœ€å¤§å€¼
   - ç®—æ³•ï¼šå·®åˆ†æ•°ç»„ã€çº¿æ®µæ ‘
   - é“¾æ¥ï¼šhttps://www.hackerrank.com/challenges/crush/problem

2. **HackerRank Direct Connections**
   - é¢˜ç›®æè¿°ï¼šåŸå¸‚é—´ç›´æ¥è¿æ¥çš„è´¹ç”¨è®¡ç®—
   - ç®—æ³•ï¼šçº¿æ®µæ ‘ã€æ’åº
   - é“¾æ¥ï¼šhttps://www.hackerrank.com/challenges/direct-connections/problem

### USACOé¢˜ç›®
1. **USACO 2015 January Platinum. Grass Cownoisseur**
   - é¢˜ç›®æè¿°ï¼šåœ¨æœ‰å‘å›¾ä¸­æ·»åŠ ä¸€æ¡è¾¹åæ±‚æœ€é•¿è·¯å¾„
   - ç®—æ³•ï¼šçº¿æ®µæ ‘ã€åŠ¨æ€è§„åˆ’
   - é“¾æ¥ï¼šhttp://www.usaco.org/index.php?page=viewproblem2&cpid=517

2. **USACO 2018 February Platinum. New Barns**
   - é¢˜ç›®æè¿°ï¼šåŠ¨æ€æ·»åŠ èŠ‚ç‚¹å¹¶æŸ¥è¯¢ç›´å¾„
   - ç®—æ³•ï¼šçº¿æ®µæ ‘ã€æ ‘çš„ç›´å¾„
   - é“¾æ¥ï¼šhttp://www.usaco.org/index.php?page=viewproblem2&cpid=818

### CodeChefé¢˜ç›®
1. **CodeChef HORRIBLE. Horrible Queries**
   - é¢˜ç›®æè¿°ï¼šåŒºé—´åŠ æ³•å’ŒåŒºé—´æ±‚å’Œ
   - ç®—æ³•ï¼šçº¿æ®µæ ‘ã€æ‡’æƒ°ä¼ æ’­
   - é“¾æ¥ï¼šhttps://www.codechef.com/problems/HORRIBLE

2. **CodeChef GSS4. Can you answer these queries IV**
   - é¢˜ç›®æè¿°ï¼šåŒºé—´å¼€æ–¹å’ŒåŒºé—´æ±‚å’Œ
   - ç®—æ³•ï¼šçº¿æ®µæ ‘ã€æ‡’æƒ°ä¼ æ’­
   - é“¾æ¥ï¼šhttps://www.codechef.com/problems/GSS4

## ğŸ¯ ç®—æ³•æŠ€å·§æ€»ç»“

### çº¿æ®µæ ‘æŠ€å·§
1. **åŒºé—´æŸ¥è¯¢ä¸æ›´æ–°**ï¼šæ”¯æŒO(log n)æ—¶é—´å¤æ‚åº¦çš„åŒºé—´æ“ä½œ
2. **æ‡’æƒ°ä¼ æ’­**ï¼šä¼˜åŒ–åŒºé—´æ›´æ–°æ“ä½œï¼Œé¿å…é‡å¤è®¡ç®—
3. **åŠ¨æ€å¼€ç‚¹**ï¼šèŠ‚çœç©ºé—´ï¼Œé€‚ç”¨äºå¤§è§„æ¨¡ç¨€ç–æ•°æ®
4. **æ ‡è®°ä¸‹ä¼ **ï¼šç»´æŠ¤åŒºé—´æ“ä½œçš„æ­£ç¡®æ€§

### æ ‘çŠ¶æ•°ç»„æŠ€å·§
1. **å‰ç¼€å’ŒæŸ¥è¯¢**ï¼šO(log n)æ—¶é—´å¤æ‚åº¦æŸ¥è¯¢å‰ç¼€å’Œ
2. **å•ç‚¹æ›´æ–°**ï¼šO(log n)æ—¶é—´å¤æ‚åº¦æ›´æ–°å•ç‚¹å€¼
3. **åŒºé—´ä¿®æ”¹**ï¼šé€šè¿‡å·®åˆ†æ•°ç»„å®ç°åŒºé—´ä¿®æ”¹
4. **äºŒç»´æ‰©å±•**ï¼šæ‰©å±•åˆ°äºŒç»´æƒ…å†µå¤„ç†çŸ©é˜µé—®é¢˜

### é€šç”¨æŠ€å·§
1. **ç¦»æ•£åŒ–**ï¼šå¤„ç†å¤§æ•°å€¼èŒƒå›´é—®é¢˜
2. **åæ ‡å˜æ¢**ï¼šå°†é—®é¢˜è½¬åŒ–ä¸ºæ›´å®¹æ˜“å¤„ç†çš„å½¢å¼
3. **åˆ†å—å¤„ç†**ï¼šå°†å¤§é—®é¢˜åˆ†è§£ä¸ºå°é—®é¢˜å¤„ç†
4. **æ•°æ®ç»“æ„ç»„åˆ**ï¼šç»“åˆå¤šç§æ•°æ®ç»“æ„è§£å†³å¤æ‚é—®é¢˜

## ğŸ“ˆ å¤æ‚åº¦åˆ†æ

### æ—¶é—´å¤æ‚åº¦
- çº¿æ®µæ ‘æ„å»ºï¼šO(n)
- çº¿æ®µæ ‘å•ç‚¹æ›´æ–°ï¼šO(log n)
- çº¿æ®µæ ‘åŒºé—´æ›´æ–°ï¼ˆå¸¦æ‡’æƒ°ä¼ æ’­ï¼‰ï¼šO(log n)
- çº¿æ®µæ ‘åŒºé—´æŸ¥è¯¢ï¼šO(log n)
- æ ‘çŠ¶æ•°ç»„å•ç‚¹æ›´æ–°ï¼šO(log n)
- æ ‘çŠ¶æ•°ç»„å‰ç¼€å’ŒæŸ¥è¯¢ï¼šO(log n)

### ç©ºé—´å¤æ‚åº¦
- çº¿æ®µæ ‘ï¼šO(4n)
- æ ‘çŠ¶æ•°ç»„ï¼šO(n)

## ğŸ›  å·¥ç¨‹åŒ–è€ƒé‡

### å¼‚å¸¸å¤„ç†
1. **è¾¹ç•Œæ¡ä»¶**ï¼šå¤„ç†ç©ºæ•°ç»„ã€å•å…ƒç´ æ•°ç»„ç­‰ç‰¹æ®Šæƒ…å†µ
2. **è¾“å…¥éªŒè¯**ï¼šæ£€æŸ¥è¾“å…¥å‚æ•°çš„æœ‰æ•ˆæ€§
3. **å†…å­˜ç®¡ç†**ï¼šé¿å…å†…å­˜æ³„æ¼ï¼Œåˆç†åˆ†é…ç©ºé—´

### æ€§èƒ½ä¼˜åŒ–
1. **å¸¸æ•°ä¼˜åŒ–**ï¼šå‡å°‘ä¸å¿…è¦çš„è®¡ç®—å’Œå†…å­˜è®¿é—®
2. **ç¼“å­˜å‹å¥½**ï¼šä¼˜åŒ–æ•°æ®ç»“æ„å¸ƒå±€æé«˜ç¼“å­˜å‘½ä¸­ç‡
3. **å¹¶è¡ŒåŒ–**ï¼šåœ¨å¯èƒ½çš„æƒ…å†µä¸‹åˆ©ç”¨å¤šæ ¸å¤„ç†èƒ½åŠ›

### å¯ç»´æŠ¤æ€§
1. **ä»£ç ç»“æ„**ï¼šæ¨¡å—åŒ–è®¾è®¡ï¼ŒèŒè´£åˆ†ç¦»
2. **æ³¨é‡Šæ–‡æ¡£**ï¼šè¯¦ç»†æ³¨é‡Šå…³é”®ç®—æ³•å’Œå®ç°ç»†èŠ‚
3. **æµ‹è¯•è¦†ç›–**ï¼šå®Œå–„çš„å•å…ƒæµ‹è¯•å’Œè¾¹ç•Œæµ‹è¯•

## ğŸ“š å­¦ä¹ èµ„æº

### ç»å…¸æ•™æ
1. ã€Šç®—æ³•å¯¼è®ºã€‹ç¬¬14ç«  æ•°æ®ç»“æ„çš„æ‰©å¼ 
2. ã€Šç®—æ³•ç«èµ›å…¥é—¨ç»å…¸ã€‹ç¬¬2ç‰ˆ ç¬¬5ç«  æ•°å­¦æ¦‚å¿µä¸æ–¹æ³•
3. ã€ŠæŒ‘æˆ˜ç¨‹åºè®¾è®¡ç«èµ›ã€‹ç¬¬2ç‰ˆ ç¬¬4ç«  æ•°æ®ç»“æ„

### åœ¨çº¿èµ„æº
1. GeeksforGeeks - Segment Tree and BIT Tutorials
2. TopCoder - Range Minimum Query and Lowest Common Ancestor
3. Codeforces - Segment Tree Tutorial
4. LeetCode - Segment Tree Problems

## ğŸ§ª æµ‹è¯•ç”¨ä¾‹

ä¸ºç¡®ä¿ä»£ç æ­£ç¡®æ€§ï¼Œæ¯ä¸ªå®ç°éƒ½åº”è¯¥åŒ…å«ä»¥ä¸‹æµ‹è¯•ç”¨ä¾‹ï¼š
1. **åŸºç¡€æµ‹è¯•**ï¼šæ­£å¸¸è¾“å…¥æ•°æ®
2. **è¾¹ç•Œæµ‹è¯•**ï¼šç©ºæ•°ç»„ã€å•å…ƒç´ æ•°ç»„
3. **æç«¯æµ‹è¯•**ï¼šå¤§è§„æ¨¡æ•°æ®ã€é‡å¤å…ƒç´ 
4. **å¼‚å¸¸æµ‹è¯•**ï¼šæ— æ•ˆè¾“å…¥ã€è¶Šç•Œè®¿é—®

## ğŸ“š è¡¥å……é¢˜ç›®ä¸è¯¦ç»†è§£ç­”

### LeetCodeé¢˜ç›®

#### 1. LeetCode 1040. Moving Stones Until Consecutive II
**é¢˜ç›®é“¾æ¥**: https://leetcode.com/problems/moving-stones-until-consecutive-ii/
**é¢˜ç›®æè¿°**: æœ‰ä¸€äº›çŸ³å¤´æ”¾åœ¨æ•°è½´ä¸Šï¼Œæ¯æ¬¡ç§»åŠ¨å¯ä»¥å°†ä¸€ä¸ªçŸ³å¤´ç§»åŠ¨åˆ°ç¦»å®ƒæœ€è¿‘çš„ç©ºä½ï¼Œä¸”ä¸èƒ½ç§»åŠ¨åˆ°ç«¯ç‚¹ä¹‹å¤–ã€‚æ±‚å°†æ‰€æœ‰çŸ³å¤´ç§»åŠ¨åˆ°è¿ç»­ä½ç½®æ‰€éœ€çš„æœ€å°å’Œæœ€å¤§ç§»åŠ¨æ¬¡æ•°ã€‚
**ç®—æ³•**: çº¿æ®µæ ‘ã€æ»‘åŠ¨çª—å£
**æ—¶é—´å¤æ‚åº¦**: O(n log n) - æ’åºæ—¶é—´
**ç©ºé—´å¤æ‚åº¦**: O(1) - å¸¸æ•°ç©ºé—´

**Javaä»£ç å®ç°**:
```java
// LeetCode 1040. Moving Stones Until Consecutive II è§£æ³•ï¼ˆä½¿ç”¨æ»‘åŠ¨çª—å£ï¼‰
class Solution {
    public int[] numMovesStonesII(int[] stones) {
        Arrays.sort(stones);
        int n = stones.length;
        int minMoves = Integer.MAX_VALUE;
        
        // æ»‘åŠ¨çª—å£è®¡ç®—æœ€å°ç§»åŠ¨æ¬¡æ•°
        int j = 0;
        for (int i = 0; i < n; i++) {
            while (stones[i] - stones[j] >= n) {
                j++;
            }
            int windowSize = i - j + 1;
            // ç‰¹æ®Šæƒ…å†µï¼šå¦‚æœçª—å£å†…å·²ç»æœ‰n-1ä¸ªçŸ³å¤´ä¸”å½¢æˆè¿ç»­åŒºé—´ï¼ˆé™¤äº†æœ€åä¸€ä¸ªä½ç½®ï¼‰
            if (windowSize == n - 1 && stones[i] - stones[j] == n - 2) {
                minMoves = Math.min(minMoves, 2);
            } else {
                minMoves = Math.min(minMoves, n - windowSize);
            }
        }
        
        // è®¡ç®—æœ€å¤§ç§»åŠ¨æ¬¡æ•°ï¼ˆä¸¤ç«¯å¯é€‰ï¼Œå–æœ€å¤§å€¼ï¼‰
        int maxMoves = Math.max(stones[n-1] - stones[1], stones[n-2] - stones[0]) - (n - 2);
        
        return new int[]{minMoves, maxMoves};
    }
}
```

**C++ä»£ç å®ç°**:
```cpp
// LeetCode 1040. Moving Stones Until Consecutive II
#include <iostream>
#include <vector>
#include <algorithm>
#include <climits>
using namespace std;

class Solution {
public:
    vector<int> numMovesStonesII(vector<int>& stones) {
        sort(stones.begin(), stones.end());
        int n = stones.size();
        int minMoves = INT_MAX;
        
        int j = 0;
        for (int i = 0; i < n; i++) {
            while (stones[i] - stones[j] >= n) {
                j++;
            }
            int windowSize = i - j + 1;
            if (windowSize == n - 1 && stones[i] - stones[j] == n - 2) {
                minMoves = min(minMoves, 2);
            } else {
                minMoves = min(minMoves, n - windowSize);
            }
        }
        
        int maxMoves = max(stones[n-1] - stones[1], stones[n-2] - stones[0]) - (n - 2);
        
        return {minMoves, maxMoves};
    }
};
```

**Pythonä»£ç å®ç°**:
```python
# LeetCode 1040. Moving Stones Until Consecutive II
class Solution:
    def numMovesStonesII(self, stones):
        stones.sort()
        n = len(stones)
        min_moves = float('inf')
        
        j = 0
        for i in range(n):
            while stones[i] - stones[j] >= n:
                j += 1
            window_size = i - j + 1
            if window_size == n - 1 and stones[i] - stones[j] == n - 2:
                min_moves = min(min_moves, 2)
            else:
                min_moves = min(min_moves, n - window_size)
        
        max_moves = max(stones[-1] - stones[1], stones[-2] - stones[0]) - (n - 2)
        
        return [min_moves, max_moves]
```

#### 2. LeetCode 1074. Number of Submatrices That Sum to Target
**é¢˜ç›®é“¾æ¥**: https://leetcode.com/problems/number-of-submatrices-that-sum-to-target/
**é¢˜ç›®æè¿°**: ç»™å®šä¸€ä¸ªäºŒç»´çŸ©é˜µï¼Œè¿”å›å…ƒç´ å’Œç­‰äºtargetçš„éç©ºå­çŸ©é˜µçš„ä¸ªæ•°ã€‚
**ç®—æ³•**: äºŒç»´å‰ç¼€å’Œã€å“ˆå¸Œè¡¨
**æ—¶é—´å¤æ‚åº¦**: O(mÂ²n) - må’Œnåˆ†åˆ«æ˜¯çŸ©é˜µçš„è¡Œæ•°å’Œåˆ—æ•°
**ç©ºé—´å¤æ‚åº¦**: O(n) - å“ˆå¸Œè¡¨çš„ç©ºé—´

**Javaä»£ç å®ç°**:
```java
// LeetCode 1074. Number of Submatrices That Sum to Target
class Solution {
    public int numSubmatrixSumTarget(int[][] matrix, int target) {
        int m = matrix.length;
        int n = matrix[0].length;
        int count = 0;
        
        // æšä¸¾ä¸Šè¾¹ç•Œ
        for (int top = 0; top < m; top++) {
            int[] rowSum = new int[n]; // è®°å½•å½“å‰è¡Œåˆ°ä¸Šè¾¹ç•Œçš„åˆ—å’Œ
            // æšä¸¾ä¸‹è¾¹ç•Œ
            for (int bottom = top; bottom < m; bottom++) {
                // è®¡ç®—æ¯ä¸€åˆ—çš„ç´¯åŠ å’Œ
                for (int col = 0; col < n; col++) {
                    rowSum[col] += matrix[bottom][col];
                }
                // åœ¨rowSumæ•°ç»„ä¸­æ‰¾å­æ•°ç»„å’Œä¸ºtargetçš„æƒ…å†µ
                count += subarraySum(rowSum, target);
            }
        }
        
        return count;
    }
    
    // ä¸€ç»´æ•°ç»„ä¸­æ‰¾å’Œä¸ºkçš„å­æ•°ç»„ä¸ªæ•°
    private int subarraySum(int[] nums, int k) {
        Map<Integer, Integer> prefixSum = new HashMap<>();
        prefixSum.put(0, 1);
        int sum = 0, count = 0;
        
        for (int num : nums) {
            sum += num;
            if (prefixSum.containsKey(sum - k)) {
                count += prefixSum.get(sum - k);
            }
            prefixSum.put(sum, prefixSum.getOrDefault(sum, 0) + 1);
        }
        
        return count;
    }
}
```

**C++ä»£ç å®ç°**:
```cpp
// LeetCode 1074. Number of Submatrices That Sum to Target
#include <iostream>
#include <vector>
#include <unordered_map>
using namespace std;

class Solution {
private:
    int subarraySum(vector<int>& nums, int k) {
        unordered_map<int, int> prefixSum;
        prefixSum[0] = 1;
        int sum = 0, count = 0;
        
        for (int num : nums) {
            sum += num;
            if (prefixSum.count(sum - k)) {
                count += prefixSum[sum - k];
            }
            prefixSum[sum]++;
        }
        
        return count;
    }
    
public:
    int numSubmatrixSumTarget(vector<vector<int>>& matrix, int target) {
        int m = matrix.size();
        int n = matrix[0].size();
        int count = 0;
        
        for (int top = 0; top < m; top++) {
            vector<int> rowSum(n, 0);
            for (int bottom = top; bottom < m; bottom++) {
                for (int col = 0; col < n; col++) {
                    rowSum[col] += matrix[bottom][col];
                }
                count += subarraySum(rowSum, target);
            }
        }
        
        return count;
    }
};
```

**Pythonä»£ç å®ç°**:
```python
# LeetCode 1074. Number of Submatrices That Sum to Target
class Solution:
    def numSubmatrixSumTarget(self, matrix, target):
        m = len(matrix)
        n = len(matrix[0])
        count = 0
        
        for top in range(m):
            row_sum = [0] * n
            for bottom in range(top, m):
                for col in range(n):
                    row_sum[col] += matrix[bottom][col]
                count += self.subarray_sum(row_sum, target)
        
        return count
    
    def subarray_sum(self, nums, k):
        prefix_sum = {0: 1}
        total = 0
        count = 0
        
        for num in nums:
            total += num
            if total - k in prefix_sum:
                count += prefix_sum[total - k]
            prefix_sum[total] = prefix_sum.get(total, 0) + 1
        
        return count
```

### Codeforcesé¢˜ç›®

#### 1. Codeforces 1285E. Delete a Segment
**é¢˜ç›®é“¾æ¥**: https://codeforces.com/problemset/problem/1285/E
**é¢˜ç›®æè¿°**: ç»™å®šè‹¥å¹²åŒºé—´ï¼Œåˆ é™¤å…¶ä¸­ä¸€ä¸ªåŒºé—´ï¼Œä½¿å¾—å‰©ä¸‹çš„åŒºé—´çš„åˆå¹¶åçš„åŒºé—´æ•°é‡æœ€å¤§ã€‚
**ç®—æ³•**: çº¿æ®µæ ‘ã€åŒºé—´å¤„ç†
**æ—¶é—´å¤æ‚åº¦**: O(n log n) - æ’åºæ—¶é—´
**ç©ºé—´å¤æ‚åº¦**: O(n) - å‰ç¼€å’Œåç¼€æ•°ç»„çš„ç©ºé—´

**Javaä»£ç å®ç°**:
```java
// Codeforces 1285E. Delete a Segment
import java.io.*;
import java.util.*;

class Segment implements Comparable<Segment> {
    int l, r, idx;
    
    public Segment(int l, int r, int idx) {
        this.l = l;
        this.r = r;
        this.idx = idx;
    }
    
    @Override
    public int compareTo(Segment other) {
        return Integer.compare(this.l, other.l);
    }
}

public class Main {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        int t = Integer.parseInt(br.readLine());
        
        while (t-- > 0) {
            int n = Integer.parseInt(br.readLine());
            List<Segment> segs = new ArrayList<>();
            
            for (int i = 0; i < n; i++) {
                String[] parts = br.readLine().split(" ");
                int l = Integer.parseInt(parts[0]);
                int r = Integer.parseInt(parts[1]);
                segs.add(new Segment(l, r, i));
            }
            
            Collections.sort(segs);
            
            int[] pre = new int[n];
            int[] suf = new int[n];
            
            // è®¡ç®—å‰ç¼€åˆå¹¶åçš„åŒºé—´æ•°
            int count = 0;
            int lastR = -1000000010;
            for (int i = 0; i < n; i++) {
                if (segs.get(i).l > lastR) {
                    count++;
                    lastR = segs.get(i).r;
                } else {
                    lastR = Math.max(lastR, segs.get(i).r);
                }
                pre[i] = count;
            }
            
            // è®¡ç®—åç¼€åˆå¹¶åçš„åŒºé—´æ•°
            count = 0;
            int firstL = 1000000010;
            for (int i = n-1; i >= 0; i--) {
                if (segs.get(i).r < firstL) {
                    count++;
                    firstL = segs.get(i).l;
                } else {
                    firstL = Math.min(firstL, segs.get(i).l);
                }
                suf[i] = count;
            }
            
            int maxSegments = 0;
            
            // æšä¸¾åˆ é™¤ç¬¬iä¸ªåŒºé—´
            for (int i = 0; i < n; i++) {
                int current = 0;
                if (i > 0) current += pre[i-1];
                if (i < n-1) current += suf[i+1];
                
                // æ£€æŸ¥å‰ä¸€éƒ¨åˆ†çš„æœ€åä¸€ä¸ªåŒºé—´å’Œåä¸€éƒ¨åˆ†çš„ç¬¬ä¸€ä¸ªåŒºé—´æ˜¯å¦æœ‰é‡å 
                if (i > 0 && i < n-1) {
                    int lastRight = -1000000010;
                    for (int j = 0; j < i; j++) {
                        lastRight = Math.max(lastRight, segs.get(j).r);
                    }
                    int firstLeft = 1000000010;
                    for (int j = i+1; j < n; j++) {
                        firstLeft = Math.min(firstLeft, segs.get(j).l);
                    }
                    if (lastRight >= firstLeft) current--;
                }
                
                maxSegments = Math.max(maxSegments, current);
            }
            
            System.out.println(maxSegments);
        }
    }
}
```

**C++ä»£ç å®ç°**:
```cpp
// Codeforces 1285E. Delete a Segment
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

struct Segment {
    int l, r, idx;
    bool operator<(const Segment& other) const {
        return l < other.l;
    }
};

int main() {
    int t;
    cin >> t;
    while (t--) {
        int n;
        cin >> n;
        vector<Segment> segs(n);
        for (int i = 0; i < n; i++) {
            cin >> segs[i].l >> segs[i].r;
            segs[i].idx = i;
        }
        
        sort(segs.begin(), segs.end());
        
        vector<int> pre(n), suf(n);
        
        // è®¡ç®—å‰ç¼€åˆå¹¶åçš„åŒºé—´æ•°
        int count = 0;
        int lastR = -1e9 - 10;
        for (int i = 0; i < n; i++) {
            if (segs[i].l > lastR) {
                count++;
                lastR = segs[i].r;
            } else {
                lastR = max(lastR, segs[i].r);
            }
            pre[i] = count;
        }
        
        // è®¡ç®—åç¼€åˆå¹¶åçš„åŒºé—´æ•°
        count = 0;
        int firstL = 1e9 + 10;
        for (int i = n-1; i >= 0; i--) {
            if (segs[i].r < firstL) {
                count++;
                firstL = segs[i].l;
            } else {
                firstL = min(firstL, segs[i].l);
            }
            suf[i] = count;
        }
        
        int maxSegments = 0;
        
        // æšä¸¾åˆ é™¤ç¬¬iä¸ªåŒºé—´
        for (int i = 0; i < n; i++) {
            int current = 0;
            if (i > 0) current += pre[i-1];
            if (i < n-1) current += suf[i+1];
            
            // æ£€æŸ¥å‰ä¸€éƒ¨åˆ†çš„æœ€åä¸€ä¸ªåŒºé—´å’Œåä¸€éƒ¨åˆ†çš„ç¬¬ä¸€ä¸ªåŒºé—´æ˜¯å¦æœ‰é‡å 
            if (i > 0 && i < n-1) {
                int lastR = -1e9 - 10;
                for (int j = 0; j < i; j++) {
                    lastR = max(lastR, segs[j].r);
                }
                int firstL = 1e9 + 10;
                for (int j = i+1; j < n; j++) {
                    firstL = min(firstL, segs[j].l);
                }
                if (lastR >= firstL) current--;
            }
            
            maxSegments = max(maxSegments, current);
        }
        
        cout << maxSegments << endl;
    }
    return 0;
}
```

**Pythonä»£ç å®ç°**:
```python
# Codeforces 1285E. Delete a Segment
import sys

def main():
    input = sys.stdin.read
    data = input().split()
    idx = 0
    t = int(data[idx])
    idx += 1
    
    for _ in range(t):
        n = int(data[idx])
        idx += 1
        segs = []
        
        for i in range(n):
            l = int(data[idx])
            r = int(data[idx+1])
            idx += 2
            segs.append((l, r, i))
        
        # æŒ‰å·¦ç«¯ç‚¹æ’åº
        segs.sort()
        
        pre = [0] * n
        suf = [0] * n
        
        # è®¡ç®—å‰ç¼€åˆå¹¶åçš„åŒºé—´æ•°
        count = 0
        last_r = -10**18
        for i in range(n):
            l, r, _ = segs[i]
            if l > last_r:
                count += 1
                last_r = r
            else:
                last_r = max(last_r, r)
            pre[i] = count
        
        # è®¡ç®—åç¼€åˆå¹¶åçš„åŒºé—´æ•°
        count = 0
        first_l = 10**18
        for i in range(n-1, -1, -1):
            l, r, _ = segs[i]
            if r < first_l:
                count += 1
                first_l = l
            else:
                first_l = min(first_l, l)
            suf[i] = count
        
        max_segments = 0
        
        # æšä¸¾åˆ é™¤ç¬¬iä¸ªåŒºé—´
        for i in range(n):
            current = 0
            if i > 0:
                current += pre[i-1]
            if i < n-1:
                current += suf[i+1]
            
            # æ£€æŸ¥å‰ä¸€éƒ¨åˆ†çš„æœ€åä¸€ä¸ªåŒºé—´å’Œåä¸€éƒ¨åˆ†çš„ç¬¬ä¸€ä¸ªåŒºé—´æ˜¯å¦æœ‰é‡å 
            if i > 0 and i < n-1:
                last_right = -10**18
                for j in range(i):
                    last_right = max(last_right, segs[j][1])
                first_left = 10**18
                for j in range(i+1, n):
                    first_left = min(first_left, segs[j][0])
                if last_right >= first_left:
                    current -= 1
            
            max_segments = max(max_segments, current)
        
        print(max_segments)

if __name__ == '__main__':
    main()
```

### æ´›è°·é¢˜ç›®

#### 1. æ´›è°· P4513. å°ç™½é€›å…¬å›­
**é¢˜ç›®é“¾æ¥**: https://www.luogu.com.cn/problem/P4513
**é¢˜ç›®æè¿°**: ç»™å®šä¸€ä¸ªæ•°ç»„ï¼Œæ”¯æŒå•ç‚¹ä¿®æ”¹å’ŒæŸ¥è¯¢åŒºé—´æœ€å¤§å­æ®µå’Œã€‚
**ç®—æ³•**: çº¿æ®µæ ‘
**æ—¶é—´å¤æ‚åº¦**: O(n) - æ„å»ºï¼ŒO(log n) - å•ç‚¹ä¿®æ”¹å’ŒåŒºé—´æŸ¥è¯¢
**ç©ºé—´å¤æ‚åº¦**: O(4n) - çº¿æ®µæ ‘ç©ºé—´

**Javaä»£ç å®ç°**:
```java
// æ´›è°· P4513. å°ç™½é€›å…¬å›­ - æ”¯æŒå•ç‚¹ä¿®æ”¹çš„åŒºé—´æœ€å¤§å­æ®µå’Œ
import java.io.*;
import java.util.*;

public class Main {
    static class SegmentTreeNode {
        int l, r;
        int sum;        // åŒºé—´å’Œ
        int maxSum;     // æœ€å¤§å­æ®µå’Œ
        int prefixSum;  // å‰ç¼€æœ€å¤§å’Œ
        int suffixSum;  // åç¼€æœ€å¤§å’Œ
    }
    
    static SegmentTreeNode[] tree;
    static int[] arr;
    
    // åˆå¹¶å·¦å³å­èŠ‚ç‚¹ä¿¡æ¯
    static void pushUp(int p) {
        int left = p << 1;
        int right = p << 1 | 1;
        
        tree[p].sum = tree[left].sum + tree[right].sum;
        tree[p].prefixSum = Math.max(tree[left].prefixSum, tree[left].sum + tree[right].prefixSum);
        tree[p].suffixSum = Math.max(tree[right].suffixSum, tree[right].sum + tree[left].suffixSum);
        tree[p].maxSum = Math.max(Math.max(tree[left].maxSum, tree[right].maxSum), 
                                  tree[left].suffixSum + tree[right].prefixSum);
    }
    
    // æ„å»ºçº¿æ®µæ ‘
    static void build(int p, int l, int r) {
        tree[p].l = l;
        tree[p].r = r;
        
        if (l == r) {
            tree[p].sum = arr[l];
            tree[p].maxSum = arr[l];
            tree[p].prefixSum = arr[l];
            tree[p].suffixSum = arr[l];
            return;
        }
        
        int mid = (l + r) >> 1;
        build(p << 1, l, mid);
        build(p << 1 | 1, mid + 1, r);
        pushUp(p);
    }
    
    // å•ç‚¹æ›´æ–°
    static void update(int p, int x, int v) {
        if (tree[p].l == tree[p].r) {
            tree[p].sum = v;
            tree[p].maxSum = v;
            tree[p].prefixSum = v;
            tree[p].suffixSum = v;
            return;
        }
        
        int mid = (tree[p].l + tree[p].r) >> 1;
        if (x <= mid) {
            update(p << 1, x, v);
        } else {
            update(p << 1 | 1, x, v);
        }
        pushUp(p);
    }
    
    // æŸ¥è¯¢åŒºé—´æœ€å¤§å­æ®µå’Œ
    static SegmentTreeNode query(int p, int l, int r) {
        if (l <= tree[p].l && tree[p].r <= r) {
            return tree[p];
        }
        
        int mid = (tree[p].l + tree[p].r) >> 1;
        if (r <= mid) {
            return query(p << 1, l, r);
        } else if (l > mid) {
            return query(p << 1 | 1, l, r);
        } else {
            SegmentTreeNode left = query(p << 1, l, r);
            SegmentTreeNode right = query(p << 1 | 1, l, r);
            SegmentTreeNode res = new SegmentTreeNode();
            res.sum = left.sum + right.sum;
            res.prefixSum = Math.max(left.prefixSum, left.sum + right.prefixSum);
            res.suffixSum = Math.max(right.suffixSum, right.sum + left.suffixSum);
            res.maxSum = Math.max(Math.max(left.maxSum, right.maxSum), left.suffixSum + right.prefixSum);
            return res;
        }
    }
    
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(br.readLine());
        int n = Integer.parseInt(st.nextToken());
        int m = Integer.parseInt(st.nextToken());
        
        arr = new int[n + 1];
        st = new StringTokenizer(br.readLine());
        for (int i = 1; i <= n; i++) {
            arr[i] = Integer.parseInt(st.nextToken());
        }
        
        tree = new SegmentTreeNode[4 * (n + 1)];
        for (int i = 0; i < tree.length; i++) {
            tree[i] = new SegmentTreeNode();
        }
        build(1, 1, n);
        
        while (m-- > 0) {
            st = new StringTokenizer(br.readLine());
            int op = Integer.parseInt(st.nextToken());
            int x = Integer.parseInt(st.nextToken());
            int y = Integer.parseInt(st.nextToken());
            
            if (op == 1) {
                if (x > y) {
                    int temp = x;
                    x = y;
                    y = temp;
                }
                System.out.println(query(1, x, y).maxSum);
            } else {
                update(1, x, y);
            }
        }
    }
}
```

**C++ä»£ç å®ç°**:
```cpp
// æ´›è°· P4513. å°ç™½é€›å…¬å›­ - æ”¯æŒå•ç‚¹ä¿®æ”¹çš„åŒºé—´æœ€å¤§å­æ®µå’Œ
#include <iostream>
#include <algorithm>
using namespace std;

struct SegmentTreeNode {
    int l, r;
    int sum;        // åŒºé—´å’Œ
    int maxSum;     // æœ€å¤§å­æ®µå’Œ
    int prefixSum;  // å‰ç¼€æœ€å¤§å’Œ
    int suffixSum;  // åç¼€æœ€å¤§å’Œ
} tree[400010];

int arr[100010];

// åˆå¹¶å·¦å³å­èŠ‚ç‚¹ä¿¡æ¯
void pushUp(int p) {
    int left = p << 1;
    int right = p << 1 | 1;
    
    tree[p].sum = tree[left].sum + tree[right].sum;
    tree[p].prefixSum = max(tree[left].prefixSum, tree[left].sum + tree[right].prefixSum);
    tree[p].suffixSum = max(tree[right].suffixSum, tree[right].sum + tree[left].suffixSum);
    tree[p].maxSum = max(max(tree[left].maxSum, tree[right].maxSum), 
                         tree[left].suffixSum + tree[right].prefixSum);
}

// æ„å»ºçº¿æ®µæ ‘
void build(int p, int l, int r) {
    tree[p].l = l;
    tree[p].r = r;
    
    if (l == r) {
        tree[p].sum = arr[l];
        tree[p].maxSum = arr[l];
        tree[p].prefixSum = arr[l];
        tree[p].suffixSum = arr[l];
        return;
    }
    
    int mid = (l + r) >> 1;
    build(p << 1, l, mid);
    build(p << 1 | 1, mid + 1, r);
    pushUp(p);
}

// å•ç‚¹æ›´æ–°
void update(int p, int x, int v) {
    if (tree[p].l == tree[p].r) {
        tree[p].sum = v;
        tree[p].maxSum = v;
        tree[p].prefixSum = v;
        tree[p].suffixSum = v;
        return;
    }
    
    int mid = (tree[p].l + tree[p].r) >> 1;
    if (x <= mid) {
        update(p << 1, x, v);
    } else {
        update(p << 1 | 1, x, v);
    }
    pushUp(p);
}

// æŸ¥è¯¢åŒºé—´æœ€å¤§å­æ®µå’Œ
SegmentTreeNode query(int p, int l, int r) {
    if (l <= tree[p].l && tree[p].r <= r) {
        return tree[p];
    }
    
    int mid = (tree[p].l + tree[p].r) >> 1;
    if (r <= mid) {
        return query(p << 1, l, r);
    } else if (l > mid) {
        return query(p << 1 | 1, l, r);
    } else {
        SegmentTreeNode left = query(p << 1, l, r);
        SegmentTreeNode right = query(p << 1 | 1, l, r);
        SegmentTreeNode res;
        res.sum = left.sum + right.sum;
        res.prefixSum = max(left.prefixSum, left.sum + right.prefixSum);
        res.suffixSum = max(right.suffixSum, right.sum + left.suffixSum);
        res.maxSum = max(max(left.maxSum, right.maxSum), left.suffixSum + right.prefixSum);
        return res;
    }
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    
    int n, m;
    cin >> n >> m;
    
    for (int i = 1; i <= n; i++) {
        cin >> arr[i];
    }
    
    build(1, 1, n);
    
    while (m--) {
        int op, x, y;
        cin >> op >> x >> y;
        
        if (op == 1) {
            if (x > y) {
                swap(x, y);
            }
            cout << query(1, x, y).maxSum << '\n';
        } else {
            update(1, x, y);
        }
    }
    
    return 0;
}
```

**Pythonä»£ç å®ç°**:
```python
# æ´›è°· P4513. å°ç™½é€›å…¬å›­ - æ”¯æŒå•ç‚¹ä¿®æ”¹çš„åŒºé—´æœ€å¤§å­æ®µå’Œ
import sys

sys.setrecursionlimit(1 << 25)

class SegmentTreeNode:
    def __init__(self):
        self.l = 0
        self.r = 0
        self.sum = 0        # åŒºé—´å’Œ
        self.maxSum = 0     # æœ€å¤§å­æ®µå’Œ
        self.prefixSum = 0  # å‰ç¼€æœ€å¤§å’Œ
        self.suffixSum = 0  # åç¼€æœ€å¤§å’Œ

tree = [SegmentTreeNode() for _ in range(400010)]
arr = [0] * 100010

# åˆå¹¶å·¦å³å­èŠ‚ç‚¹ä¿¡æ¯
def pushUp(p):
    left = p << 1
    right = p << 1 | 1
    
    tree[p].sum = tree[left].sum + tree[right].sum
    tree[p].prefixSum = max(tree[left].prefixSum, tree[left].sum + tree[right].prefixSum)
    tree[p].suffixSum = max(tree[right].suffixSum, tree[right].sum + tree[left].suffixSum)
    tree[p].maxSum = max(max(tree[left].maxSum, tree[right].maxSum), 
                         tree[left].suffixSum + tree[right].prefixSum)

# æ„å»ºçº¿æ®µæ ‘
def build(p, l, r):
    tree[p].l = l
    tree[p].r = r
    
    if l == r:
        tree[p].sum = arr[l]
        tree[p].maxSum = arr[l]
        tree[p].prefixSum = arr[l]
        tree[p].suffixSum = arr[l]
        return
    
    mid = (l + r) >> 1
    build(p << 1, l, mid)
    build(p << 1 | 1, mid + 1, r)
    pushUp(p)

# å•ç‚¹æ›´æ–°
def update(p, x, v):
    if tree[p].l == tree[p].r:
        tree[p].sum = v
        tree[p].maxSum = v
        tree[p].prefixSum = v
        tree[p].suffixSum = v
        return
    
    mid = (tree[p].l + tree[p].r) >> 1
    if x <= mid:
        update(p << 1, x, v)
    else:
        update(p << 1 | 1, x, v)
    pushUp(p)

# æŸ¥è¯¢åŒºé—´æœ€å¤§å­æ®µå’Œ
def query(p, l, r):
    if l <= tree[p].l and tree[p].r <= r:
        return tree[p]
    
    mid = (tree[p].l + tree[p].r) >> 1
    if r <= mid:
        return query(p << 1, l, r)
    elif l > mid:
        return query(p << 1 | 1, l, r)
    else:
        left = query(p << 1, l, r)
        right = query(p << 1 | 1, l, r)
        res = SegmentTreeNode()
        res.sum = left.sum + right.sum
        res.prefixSum = max(left.prefixSum, left.sum + right.prefixSum)
        res.suffixSum = max(right.suffixSum, right.sum + left.suffixSum)
        res.maxSum = max(max(left.maxSum, right.maxSum), left.suffixSum + right.prefixSum)
        return res

def main():
    import sys
    input = sys.stdin.read().split()
    ptr = 0
    n = int(input[ptr])
    ptr += 1
    m = int(input[ptr])
    ptr += 1
    
    for i in range(1, n + 1):
        arr[i] = int(input[ptr])
        ptr += 1
    
    build(1, 1, n)
    
    for _ in range(m):
        op = int(input[ptr])
        ptr += 1
        x = int(input[ptr])
        ptr += 1
        y = int(input[ptr])
        ptr += 1
        
        if op == 1:
            if x > y:
                x, y = y, x
            res = query(1, x, y)
            print(res.maxSum)
        else:
            update(1, x, y)

if __name__ == '__main__':
    main()
```

### å…¶ä»–å¹³å°é¢˜ç›®ï¼ˆæ›´å¤šé¢˜ç›®è¯·å‚è€ƒextended_problems.mdæ–‡ä»¶ï¼‰

ç”±äºç¯‡å¹…é™åˆ¶ï¼Œè¿™é‡Œåªåˆ—å‡ºäº†éƒ¨åˆ†ä»£è¡¨æ€§é¢˜ç›®ã€‚æ›´å¤šè¯¦ç»†é¢˜ç›®å’Œè§£ç­”è¯·å‚è€ƒï¼š
- [extended_problems.md](extended_problems.md) - å®Œæ•´çš„æ‰©å±•é¢˜ç›®åˆ—è¡¨

## ğŸ“‚ ç›¸å…³æ–‡ä»¶

- [extended_problems.md](extended_problems.md) - å®Œæ•´çš„æ‰©å±•é¢˜ç›®åˆ—è¡¨å’Œè¯¦ç»†è§£ç­”
- [SUMMARY.md](SUMMARY.md) - ä¸“é¢˜æ€»ç»“æ–‡æ¡£
- [Code14_RangeXORQuery.java](Code14_RangeXORQuery.java) - åŒºé—´å¼‚æˆ–æŸ¥è¯¢(Java)
- [Code14_RangeXORQuery.py](Code14_RangeXORQuery.py) - åŒºé—´å¼‚æˆ–æŸ¥è¯¢(Python)
- [Code15_MaximumSubarraySum.java](Code15_MaximumSubarraySum.java) - åŒºé—´æœ€å¤§å­æ®µå’Œ(Java)
- [Code15_MaximumSubarraySum.py](Code15_MaximumSubarraySum.py) - åŒºé—´æœ€å¤§å­æ®µå’Œ(Python)
- [Code16_KthNumber.java](Code16_KthNumber.java) - åŒºé—´ç¬¬kå°å…ƒç´ (Java)
- [Code16_KthNumber.py](Code16_KthNumber.py) - åŒºé—´ç¬¬kå°å…ƒç´ (Python)