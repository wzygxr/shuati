#include <iostream>
#include <vector>
#include <string>
#include <sstream>
#include <algorithm>
#include <cstring>
using namespace std;

/**
 * 多重背包问题的基础实现
 * 
 * 问题描述：
 * 有n种物品，每种物品有价值v[i]，重量w[i]，以及数量c[i]。背包容量为t。
 * 每种物品最多可以选c[i]个。要求选择若干物品装入背包，使得总价值最大，且总重量不超过背包容量。
 * 
 * 算法分类：
 * - 动态规划
 * - 背包问题
 * 
 * 实现特点：
 * - 提供二维DP实现（compute1）和一维空间优化DP实现（compute2）
 * - 包含多重剪枝和优化
 * - 支持多组测试用例
 * 
 * 适用场景：
 * - 物品数量和背包容量不是特别大的情况
 * - 需要理解多重背包问题基本原理的场景
 * - 作为二进制优化和单调队列优化的基础对比
 * 
 * 测试链接：
 * - 牛客网：多重背包问题
 * - 洛谷：P1776 宝物筛选
 * 
 * 核心思想：
 * - 状态定义：dp[i][j]表示前i种物品，背包容量为j时的最大价值
 * - 状态转移：对于每种物品，可以选择0到c[i]个中的任意数量
 * - 一维优化：通过逆序遍历背包容量，确保每个物品只能被选择有限次数
 */

const int MAXN = 101; // 最大物品数量
const int MAXW = 1001; // 最大背包容量

int n, t; // 物品数量，背包容量
int v[MAXN]; // 物品价值数组
int w[MAXN]; // 物品重量数组
int c[MAXN]; // 物品数量数组
int dp[MAXW]; // 一维DP数组

/**
 * 严格位置依赖的动态规划实现
 * 使用二维数组存储状态
 * 
 * 算法思路：
 * 1. dp[i][j]表示前i种物品，背包容量为j时的最大价值
 * 2. 对于每个物品，可以选择不选或者选k个（1<=k<=c[i]且k*w[i]<=j）
 * 3. 状态转移方程：dp[i][j] = max(dp[i][j], dp[i-1][j-k*w[i]] + k*v[i])
 * 
 * 时间复杂度分析：
 * O(n * t * k_avg)，其中n是物品数量，t是背包容量，k_avg是每种物品的平均数量
 * 在最坏情况下（每种物品数量都很大），时间复杂度可能达到O(n * t^2)
 * 
 * 空间复杂度分析：
 * O(n * t)，使用二维数组存储所有状态
 * 
 * 优化思路：
 * 1. 可以提前计算每种物品的最大可选择数量，避免无效循环
 * 2. 对于重量为0的物品（如果允许的话），可以特殊处理
 * 3. 对于价值为0的物品，可以直接跳过，因为选择它们不会增加总价值
 * 
 * @return 背包能装下的最大价值
 */
int compute1() {
    // dp[0][....] = 0，表示没有货物的情况下，背包容量不管是多少，最大价值都是0
    vector<vector<int>> dp(n + 1, vector<int>(t + 1, 0));
    
    // 枚举前i种物品
    for (int i = 1; i <= n; i++) {
        int vi = v[i]; // 当前物品价值
        int wi = w[i]; // 当前物品重量
        int ci = c[i]; // 当前物品数量
        
        // 优化：跳过价值为0的物品
        if (vi == 0) continue;
        
        // 优化：跳过重量超过背包容量的物品
        if (wi > t) continue;
        
        // 枚举背包容量j
        for (int j = 0; j <= t; j++) {
            // 初始状态：不选第i种物品，继承前i-1种物品的最大价值
            dp[i][j] = dp[i - 1][j];
            
            // 计算当前容量下最多能选多少个该物品
            int maxK = min(ci, j / wi);
            
            // 枚举选择第i种物品的数量k（1到maxK个）
            for (int k = 1; k <= maxK; k++) {
                // 状态转移：选择k个第i种物品，那么剩余容量为j - k*wi，价值增加k*vi
                dp[i][j] = max(dp[i][j], dp[i - 1][j - k * wi] + k * vi);
            }
        }
    }
    
    // 返回所有物品、背包容量为t时的最大价值
    return dp[n][t];
}

/**
 * 空间优化的动态规划实现
 * 使用一维数组存储状态，逆序遍历背包容量
 * 
 * 算法思路：
 * 1. dp[j]表示背包容量为j时的最大价值
 * 2. 逆序遍历背包容量，确保每个物品只能被选择有限次数
 * 3. 枚举每种物品选择的数量，更新状态
 * 
 * 时间复杂度分析：
 * O(n * t * k_avg)，与compute1相同
 * 注意：部分测试用例可能超时，因为没有对枚举进行优化
 * 
 * 空间复杂度分析：
 * O(t)，只需要一维数组存储状态，大幅降低了空间消耗
 * 
 * 核心优化：
 * 1. 使用一维数组替代二维数组，减少空间占用
 * 2. 逆序遍历背包容量，确保每种物品只能被选择有限次数
 * 3. 提前计算maxK，避免重复计算
 * 4. 添加多重剪枝条件，跳过无效物品
 * 
 * @return 背包能装下的最大价值
 */
int compute2() {
    // 枚举每种物品
    for (int i = 1; i <= n; i++) {
        int vi = v[i]; // 当前物品价值
        int wi = w[i]; // 当前物品重量
        int ci = c[i]; // 当前物品数量
        
        // 优化1：跳过价值为0的物品
        if (vi == 0) continue;
        
        // 优化2：跳过重量为0且数量无限的物品（理论上可以无限取，但题目通常不会出现）
        if (wi == 0 && ci >= MAXW) continue;
        
        // 优化3：跳过重量超过背包容量的物品
        if (wi > t) continue;
        
        // 优化4：跳过数量为0的物品
        if (ci == 0) continue;
        
        // 逆序枚举背包容量，避免物品被重复选择
        for (int j = t; j >= wi; j--) { // 从wi开始，因为j < wi时无法选择该物品
            // 计算当前容量下最多能选多少个该物品
            int maxK = min(ci, j / wi);
            
            // 枚举选择当前物品的数量k（1到maxK个）
            for (int k = 1; k <= maxK; k++) {
                int prevJ = j - k * wi;
                // 状态转移：选择k个第i种物品，那么剩余容量为prevJ，价值增加k*vi
                if (dp[prevJ] + k * vi > dp[j]) {
                    dp[j] = dp[prevJ] + k * vi;
                }
            }
        }
    }
    
    // 返回背包容量为t时的最大价值
    return dp[t];
}

// 处理输入并运行算法
void run() {
    // 处理多组测试用例
    while (true) {
        // 读取物品数量和背包容量
        if (!(cin >> n >> t)) {
            break;
        }
        
        // 初始化数组
        memset(dp, 0, sizeof(dp));
        
        // 读取每种物品的价值、重量和数量
        for (int i = 1; i <= n; i++) {
            cin >> v[i] >> w[i] >> c[i];
        }
        
        // 调用空间优化的求解方法并输出结果
        cout << compute2() << endl;
    }
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    run();
    return 0;
}

/*
 * 算法详解与原理解析
 * 
 * 1. 问题建模：
 *    - 每种物品是一种资源，有价值、重量和数量限制
 *    - 背包容量是资源约束
 *    - 目标是在约束条件下最大化总价值
 * 
 * 2. 状态定义：
 *    - 二维DP：dp[i][j]表示前i种物品，背包容量为j时的最大价值
 *    - 一维DP：dp[j]表示背包容量为j时的最大价值
 * 
 * 3. 状态转移方程推导：
 *    对于第i种物品，我们可以选择0到c[i]个中的任意数量
 *    dp[i][j] = max{ dp[i-1][j - k*w[i]] + k*v[i] }, 其中0 ≤ k ≤ min(c[i], j/w[i])
 *    
 *    一维优化后：
 *    dp[j] = max{ dp[j - k*w[i]] + k*v[i] }, 其中1 ≤ k ≤ min(c[i], j/w[i])
 *    （从后向前遍历j，确保每种物品只能选有限次数）
 * 
 * 4. 边界条件：
 *    - dp[0][j] = 0（没有物品可选时，任何容量的最大价值都是0）
 *    - dp[i][0] = 0（背包容量为0时，无法装任何物品，价值为0）
 *    - dp[0] = 0（一维DP的初始状态）
 */

/*
 * 代码优化与工程化考量
 * 
 * 1. 输入优化：
 *    - 使用ios::sync_with_stdio(false)和cin.tie(nullptr)加速输入
 *    - 处理多组测试用例时，注意输入结束条件
 * 
 * 2. 算法优化：
 *    - 提前剪枝：跳过价值为0、重量超过容量或数量为0的物品
 *    - 计算maxK，避免重复计算j/w[i]和比较c[i]
 *    - 从wi开始遍历j，减少无效循环
 *    - 使用局部变量缓存v[i]、w[i]、c[i]，减少数组访问
 * 
 * 3. 代码健壮性：
 *    - 处理各种边界情况：n=0、t=0、物品重量或价值为0等
 *    - 避免除零错误（虽然题目通常保证w[i]>0）
 *    - 处理可能的整数溢出问题
 * 
 * 4. 性能优化：
 *    - 使用一维数组替代二维数组，减少内存占用和缓存未命中率
 *    - 逆序遍历j，确保状态转移的正确性
 *    - 优化循环顺序，提高缓存局部性
 */

/*
 * 多重背包问题的高级优化方法
 * 
 * 1. 二进制优化：
 *    - 思路：将数量为c[i]的物品拆分为log(c[i])个物品组
 *    - 每组代表2^k个该物品，转化为01背包问题
 *    - 时间复杂度：O(n * t * log c[i])
 *    - 实现简单，适用范围广
 *    
 * 2. 单调队列优化：
 *    - 思路：利用同余分组和单调队列维护最优状态
 *    - 时间复杂度：O(n * t)
 *    - 实现较复杂，但效率最高
 *    - 适合大规模数据
 *    
 * 3. 完全背包优化：
 *    - 当c[i] * w[i] >= t时，可以将物品视为完全背包
 *    - 时间复杂度：O(n * t)
 *    - 可以结合其他优化方法使用
 */

/*
 * 边界情况分析：
 * 1. 当n=0（没有物品）时，最大价值为0
 * 2. 当t=0（背包容量为0）时，最大价值为0
 * 3. 当所有物品的重量都大于t时，无法装入任何物品，最大价值为0
 * 4. 当所有物品的价值都为0时，最大价值为0
 * 5. 当物品重量为0且价值为正数时，如果数量无限则可以无限选（但题目通常不会出现）
 */

/*
 * 工程应用场景：
 * 1. 资源分配问题：在有限资源约束下实现收益最大化
 * 2. 投资组合优化：选择多种投资产品，在风险和收益之间取得平衡
 * 3. 生产计划制定：安排不同产品的生产数量，最大化利润
 * 4. 物流配送优化：在载重限制下选择最优配送方案
 * 5. 项目选择问题：在预算和时间约束下选择最优项目组合
 * 6. 广告投放优化：在预算限制下选择最优广告组合以最大化转化率
 */