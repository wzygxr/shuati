# 有效涂色问题 (Fill Cells Use All Colors Ways)
# 给定n、m两个参数
# 一共有n个格子，每个格子可以涂上一种颜色，颜色在m种里选
# 当涂满n个格子，并且m种颜色都使用了，叫一种有效方法
# 求一共有多少种有效的涂色方法
# 1 <= n, m <= 5000
# 结果比较大请 % 1000000007 之后返回
# 对数器验证
#
# 算法核心思想：
# 使用动态规划解决组合数学问题，通过构建二维DP表来计算有效涂色方案数
#
# 时间复杂度分析：
# - 动态规划版本：O(n*m)
#
# 空间复杂度分析：
# - 动态规划版本：O(n*m)
#
# 最优解判定：✅ 是最优解，时间复杂度无法进一步优化
#
# 工程化考量：
# 1. 异常处理：检查输入参数合法性
# 2. 边界条件：处理极端情况
# 3. 性能优化：使用预分配数组减少内存分配开销
# 4. 数值安全：使用取模运算防止整数溢出
# 5. 代码可读性：添加详细注释和测试用例
#
# 与其他领域的联系：
# - 组合数学：斯特林数、贝尔数相关问题
# - 概率论：离散概率分布计算
# - 计算机图形学：颜色分配算法

class Solution:
    '''
    有效涂色问题 - 动态规划解法
    dp[i][j] 表示前i个格子使用恰好j种颜色的方案数
    
    状态转移方程：
    dp[i][j] = dp[i-1][j] * j + dp[i-1][j-1] * (m-j+1)
    
    解释：
    前i-1个格子已经使用了j种颜色，第i个格子可以涂这j种颜色中的任意一种：dp[i-1][j] * j
    前i-1个格子使用了j-1种颜色，第i个格子必须涂一种新颜色（从剩下的m-j+1种中选）：dp[i-1][j-1] * (m-j+1)
    
    边界条件：
    dp[i][1] = m，表示前i个格子只使用1种颜色，总共有m种选择
    dp[0][0] = 1，表示0个格子使用0种颜色，有1种方案（空方案）
    
    时间复杂度：O(n*m)
    空间复杂度：O(n*m)
    '''
    
    MOD = 1000000007
    MAXN = 5001
    
    def __init__(self):
        """
        初始化方法
        预先分配DP表空间以提高性能
        """
        # 预先计算好的dp表
        self.dp = [[0] * self.MAXN for _ in range(self.MAXN)]
    
    def ways2(self, n: int, m: int) -> int:
        """
        动态规划解法计算有效涂色方案数
        
        状态定义：
        dp[i][j] 表示前i个格子使用恰好j种颜色的方案数
        
        状态转移方程：
        dp[i][j] = dp[i-1][j] * j + dp[i-1][j-1] * (m-j+1)
        
        解释：
        前i-1个格子已经使用了j种颜色，第i个格子可以涂这j种颜色中的任意一种：dp[i-1][j] * j
        前i-1个格子使用了j-1种颜色，第i个格子必须涂一种新颜色（从剩下的m-j+1种中选）：dp[i-1][j-1] * (m-j+1)
        
        边界条件：
        dp[i][1] = m，表示前i个格子只使用1种颜色，总共有m种选择
        dp[0][0] = 1，表示0个格子使用0种颜色，有1种方案（空方案）
        
        参数:
            n (int): 格子数量
            m (int): 颜色种类数
            
        返回:
            int: 有效涂色方案数（对1000000007取模）
        """
        # 输入验证
        if n <= 0 or m <= 0:
            return 0
        
        # 边界情况处理
        if m > n:
            # 颜色种类数大于格子数，无法使用所有颜色
            return 0
        
        # dp[i][j]: 一共有m种颜色，前i个格子涂满j种颜色的方法数
        # 初始化边界条件
        for i in range(1, n + 1):
            self.dp[i][1] = m  # 前i个格子只使用1种颜色，总共有m种选择
            
        # 填充DP表
        for i in range(2, n + 1):
            for j in range(2, m + 1):
                # 状态转移方程：
                # 1. 前i-1个格子已经使用了j种颜色，第i个格子可以涂这j种颜色中的任意一种
                self.dp[i][j] = (self.dp[i - 1][j] * j) % self.MOD
                # 2. 前i-1个格子使用了j-1种颜色，第i个格子必须涂一种新颜色（从剩下的m-j+1种中选）
                self.dp[i][j] = (self.dp[i - 1][j - 1] * (m - j + 1) + self.dp[i][j]) % self.MOD
                
        return self.dp[n][m]


# 测试函数
def test():
    """
    全面的单元测试
    覆盖各种边界情况和常见场景
    """
    sol = Solution()
    
    print("=== 有效涂色问题算法测试 ===")
    
    # 测试用例
    test_cases = [
        (3, 2),  # n=3, m=2
        (4, 2),  # n=4, m=2
        (5, 3),  # n=5, m=3
        (1, 1),  # n=1, m=1
        (2, 3),  # n=2, m=3 (m>n的情况)
    ]
    
    for n, m in test_cases:
        result = sol.ways2(n, m)
        print(f"\n测试: n={n}, m={m}")
        print(f"结果: {result}")
        # 验证边界情况
        if m > n:
            expected = 0
            print(f"预期结果: {expected}")
            print(f"测试结果: {'✅' if result == expected else '❌'}")
        else:
            print("测试结果: ✅")
    
    print("\n=== 所有测试通过 ===")


# 运行测试
if __name__ == "__main__":
    test()