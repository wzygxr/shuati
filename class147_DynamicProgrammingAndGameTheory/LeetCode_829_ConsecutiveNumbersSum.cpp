/*
 * LeetCode 829. Consecutive Numbers Sum (连续整数求和)
 * 题目描述：给定一个正整数N，返回连续正整数满足所有数字的和为N的组数。
 * 
 * 解题思路：
 * 与原题类似，但需要计算有多少种表示方法：
 * 1. 基于数学推导：2N = k*(2a + k - 1)
 * 2. 枚举k（序列长度），检查是否存在正整数解a
 * 3. 计算满足条件的k的个数
 * 
 * 时间复杂度：O(sqrt(N))
 * 空间复杂度：O(1)
 * 
 * 工程化考量：
 * 1. 异常处理：处理非正整数输入
 * 2. 边界条件：N=1等特殊情况
 * 3. 性能优化：只枚举到sqrt(2N)
 * 4. 数值溢出：注意大数处理
 */

// C++实现
int consecutiveNumbersSum(int N) {
    // 异常处理
    if (N <= 0) {
        return 0;
    }
    
    // 边界条件
    if (N == 1) {
        return 1; // 只有1本身
    }
    
    int count = 0;
    long long n2 = (long long)2 * N;
    
    // 枚举序列长度k
    for (long long k = 1; k * k <= n2; k++) {
        if (n2 % k == 0) {
            // k是n2的因数
            long long m = n2 / k;
            
            // 检查k是否能构成有效的连续序列
            // a = (m - k + 1) / 2
            // 需要满足a >= 1，即m - k + 1 >= 2，即m >= k + 1
            if (m >= k + 1 && (m - k + 1) % 2 == 0) {
                count++;
            }
            
            // 检查m是否能构成有效的连续序列（k和m不相等时）
            if (k != m && k >= m + 1 && (k - m + 1) % 2 == 0) {
                count++;
            }
        }
    }
    
    return count;
}

// 注意：由于系统环境限制，这里省略了main函数和测试代码
// 在实际环境中，需要包含适当的头文件才能编译运行