# 卡特兰数(Catalan Number)相关题目补充

## 1. 括号匹配问题
### 题目描述
给定n对括号，计算有多少种有效的括号组合方式。

### 来源
- LeetCode: [22. Generate Parentheses](https://leetcode.com/problems/generate-parentheses/)
- 牛客网: 括号匹配问题

### 解题思路
这是卡特兰数的经典应用之一。对于n对括号，第i对括号将序列分为两部分，左边有j对，右边有n-1-j对，因此满足卡特兰数的递推关系。

### 最优解分析
- 使用回溯算法生成所有有效括号组合
- 在回溯过程中，确保左括号的数量不超过n，右括号的数量不超过左括号的数量
- 时间复杂度：O(4^n / sqrt(n))，这是第n个卡特兰数的渐近表示
- 空间复杂度：O(n)，递归栈的深度

## 2. 出栈序列问题
### 题目描述
一个栈(无穷大)的进栈序列为1,2,3,..n，有多少个不同的出栈序列?

### 来源
- 51Nod: 1174
- 牛客网: 出栈序列统计
- Vijos: P1122 出栈序列统计
- 洛谷: P1044 栈

### 解题思路
这也是卡特兰数的经典应用。第k个元素是第一个出栈的元素时，将序列分为两部分，前面有k-1个元素，后面有n-k个元素。

### 最优解分析
- 使用递推公式：C(n) = C(n-1) * (4*n-2) / (n+1)
- 时间复杂度：O(n)
- 空间复杂度：O(1)
- 对于较大的n，需要使用高精度计算

## 3. 二叉树计数问题
### 题目描述
给定n个节点，能构成多少种不同的二叉树结构？

### 来源
- LeetCode: [96. Unique Binary Search Trees](https://leetcode.com/problems/unique-binary-search-trees/)
- Codeforces: 经典组合数学题

### 解题思路
n个节点的二叉树，根节点占据1个节点，左右子树分配剩下的n-1个节点。左子树有k个节点时，右子树有n-1-k个节点。

### 最优解分析
- 使用动态规划求解，dp[i]表示i个节点能构成的BST数量
- 状态转移方程：dp[n] = Σ(dp[i] * dp[n-1-i])，其中i从0到n-1
- 可以优化为递推公式：dp[n] = dp[n-1] * (4*n-2) / (n+1)
- 时间复杂度：O(n)（递推公式方法）
- 空间复杂度：O(1)（递推公式方法）

## 4. 凸多边形三角划分
### 题目描述
将一个凸多边形通过不相交的对角线划分为三角形的方法数。

### 来源
- USACO: 经典组合数学题
- Project Euler: 相关问题
- SGU: 161 凸多边形三角划分

### 解题思路
选择一条边，它必然属于某个三角形。这个三角形将多边形分为三部分，满足卡特兰数的递推关系。

### 最优解分析
- 凸多边形三角划分的方法数为第n-2项卡特兰数
- 使用递推公式或组合公式计算
- 时间复杂度：O(n)
- 空间复杂度：O(n)

## 5. 路径计数问题
### 题目描述
在n×n的网格中，从(0,0)到(n,n)有多少条不穿过对角线y=x的路径？

### 来源
- HackerRank: 相关组合数学问题
- CodeChef: 经典路径计数

### 解题思路
这是卡特兰数的另一个经典应用，也称为Dyck路径问题。

### 最优解分析
- 使用组合公式：C(n) = C(2n, n) / (n+1)
- 时间复杂度：O(n)，取决于组合数计算方法
- 空间复杂度：O(n)，用于存储阶乘等中间结果

## 6. 手牵手问题
### 题目描述
2n个人围成一个圆圈，将他们分成n对，使得连线不相交的方法数。

### 来源
- LeetCode: [1259. Handshakes That Don't Cross](https://leetcode.com/problems/handshakes-that-dont-cross/)
- AtCoder: 相关组合问题
- UVa: 991 Safe Salutations
- 洛谷: P1976 圆上的点

### 解题思路
任选一个人，他与某个人握手将圆分为两部分，满足卡特兰数的递推关系。

### 最优解分析
- 使用动态规划求解，dp[i]表示i对人握手的方式数
- 状态转移方程：dp[n] = Σ(dp[i] * dp[n-1-i])，其中i从0到n-1
- 时间复杂度：O(n²)
- 空间复杂度：O(n)

## 7. 高精度卡特兰数
### 题目描述
计算大数值的卡特兰数，如第1000项。

### 来源
- 洛谷: P1641 [SCOI2010]生成字符串
- SPOJ: CARD
- POJ: 2084
- HDU: 1023 Train Problem II

### 解题思路
使用高精度计算或通过质因数分解来处理大数取模问题。

### 最优解分析
- 使用递推公式：C(n) = C(n-1) * (4*n-2) / (n+1)，结合高精度运算
- 时间复杂度：O(n²)（高精度运算的时间）
- 空间复杂度：O(n)（存储大数的位数）
- 对于取模问题，可以使用预处理阶乘和逆元的方法

## 8. 卡特兰数计算
### 题目描述
直接计算第n项卡特兰数。

### 来源
- HackerEarth: Catalan Numbers 1

### 解题思路
使用卡特兰数的递推公式或组合公式直接计算第n项卡特兰数。

### 最优解分析
- 根据n的规模选择合适的公式：
  - n较小时：任何公式都可以
  - n中等时：递推公式2最优
  - n较大且需要取模时：组合公式+预处理阶乘
- 时间复杂度：O(n)到O(n²)不等
- 空间复杂度：O(1)到O(n)不等

## 9. 生成字符串问题
### 题目描述
生成满足条件的01字符串数目，要求在任意前缀中0的个数不少于1的个数。

### 来源
- 洛谷: P1641 [SCOI2010]生成字符串

### 解题思路
这是一个卡特兰数问题的变形，结果为第min(n,m)项卡特兰数的变形，当n = m时就是标准卡特兰数。

### 最优解分析
- 使用高精度计算或组合数学公式
- 时间复杂度：O(n)
- 空间复杂度：O(n)

## 卡特兰数公式总结

1. 递推公式1（主要应用）：
   ```
   C(0) = 1
   C(n) = Σ(i=0 to n-1) C(i) * C(n-1-i)
   ```
   时间复杂度：O(n²)
   空间复杂度：O(n)

2. 递推公式2：
   ```
   C(0) = 1
   C(n) = C(n-1) * (4*n-2) / (n+1)
   ```
   时间复杂度：O(n)
   空间复杂度：O(1)

3. 组合公式1：
   ```
   C(n) = C(2n, n) / (n+1)
   ```
   时间复杂度：O(n)
   空间复杂度：O(n)

4. 组合公式2：
   ```
   C(n) = C(2n, n) - C(2n, n-1)
   ```
   时间复杂度：O(n)
   空间复杂度：O(n)

## 时间复杂度分析

1. 递推公式1：O(n²)
2. 递推公式2：O(n)
3. 组合公式：需要计算组合数，复杂度取决于组合数计算方法，通常为O(n)
4. 高精度计算：O(n²)，因为每个数字的乘法和除法需要O(n)时间

## 空间复杂度分析

1. 递推公式1：O(n)
2. 递推公式2：O(1)
3. 组合公式：O(n)，用于存储阶乘和逆元
4. 高精度计算：O(n)，用于存储大数的位数

## 应用场景总结

1. 括号匹配问题
2. 栈的出栈序列
3. 二叉树结构计数
4. 凸多边形三角划分
5. 不穿越对角线的路径计数
6. 圆上不相交连线
7. 前缀约束序列计数
8. 投票问题：当候选人A得到n张票，候选人B得到m张票（n>m），A始终领先B的计票方式数为(n-m)/(n+m) * C(n+m, n)。当n=m时，结果就是第n项卡特兰数。

## 工程化实现要点

1. **大数处理策略**
   - 高精度计算：对于非常大的卡特兰数，需要实现高精度运算
   - 取模运算：在算法竞赛中，通常对结果取模，使用逆元处理除法
   - 数据类型选择：根据问题规模选择合适的数据类型（long, long long, BigInteger等）

2. **算法选择建议**
   - 当n较小时：可以使用任何公式，直接计算
   - 当n中等时：优先使用递推公式2，效率更高
   - 当n较大时：需要结合高精度或取模运算
   - 当需要多次查询时：预处理卡特兰数表

3. **常见优化技巧**
   - 预处理阶乘和逆元：加速组合数计算
   - 滚动数组：优化空间复杂度
   - 避免重复计算：使用记忆化递归或动态规划

## 识别卡特兰数问题的特征

1. **括号匹配类**：涉及括号、嵌套等问题
2. **出栈序列类**：涉及栈的操作序列
3. **二叉树计数类**：涉及树形结构的计数
4. **不相交路径类**：涉及路径不交叉的计数
5. **分割问题类**：涉及将结构分割为子结构的方法数

## 解题技巧总结

1. **识别模式**：通过题目特征识别是否为卡特兰数问题
2. **选择合适的公式**：根据问题规模和要求选择合适的计算公式
3. **处理边界条件**：特别注意n=0和n=1的情况
4. **考虑数据范围**：根据n的范围选择合适的实现方式
5. **优化实现**：使用预处理、滚动数组等技巧优化实现