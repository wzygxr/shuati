package class098;

/**
 * 统计元音字母序列的数目
 * 
 * 题目描述:
 * 给你一个整数n，请你帮忙统计一下我们可以按下述规则形成多少个长度为n的字符串：
 * 1. 字符串中的每个字符都应当是小写元音字母（'a', 'e', 'i', 'o', 'u'）
 * 2. 每个元音 'a' 后面都只能跟着 'e'
 * 3. 每个元音 'e' 后面只能跟着 'a' 或者是 'i'
 * 4. 每个元音 'i' 后面 不能 再跟着另一个 'i'
 * 5. 每个元音 'o' 后面只能跟着 'i' 或者是 'u'
 * 6. 每个元音 'u' 后面只能跟着 'a'
 * 7. 由于答案可能会很大，结果对1000000007取模
 * 
 * 解法分析:
 * 该问题可以转化为状态转移问题，使用矩阵快速幂优化时间复杂度
 * 
 * 状态转移分析:
 * 定义状态为以某个元音字母结尾的字符串数量，根据规则建立转移关系
 * a <- e, i, u
 * e <- a, i
 * i <- e, o
 * o <- i
 * u <- i, o
 * 
 * 矩阵推导:
 * 构建5×5的转移矩阵表示状态转移关系
 * 
 * 测试链接: https://leetcode.cn/problems/count-vowels-permutation/
 * 
 * 工程化考虑:
 * 1. 模运算: 防止整数溢出
 * 2. 边界条件处理: n=1的特殊情况
 * 3. 输入验证: 检查n的有效性
 * 
 * 与其他解法对比:
 * 1. 动态规划: 时间复杂度O(n)，空间复杂度O(1)
 * 2. 矩阵快速幂: 时间复杂度O(logn)，空间复杂度O(1)
 * 3. 最优性: 当n较大时，矩阵快速幂明显优于动态规划
 */
public class Code06_CountVowelsPermutation {

    // 正式方法
    // 矩阵快速幂
    // 时间复杂度O(logn)
    public static int MOD = 1000000007;

    /**
     * 使用矩阵快速幂计算长度为n的元音字母序列数目
     * 
     * 算法思路:
     * 1. 定义状态为以某个元音字母结尾的字符串数量
     * 2. 根据规则建立状态转移关系
     * 3. 构建转移矩阵表示状态转移
     * 4. 使用矩阵快速幂计算转移矩阵的(n-1)次幂
     * 5. 初始状态向量乘以结果矩阵得到最终各状态数量
     * 6. 求和得到总数量
     * 
     * 状态转移规则:
     * a <- e, i, u
     * e <- a, i
     * i <- e, o
     * o <- i
     * u <- i, o
     * 
     * 转移矩阵:
     * [[0,1,0,0,0],  // a <- e
     *  [1,0,1,0,0],  // e <- a, i
     *  [1,1,0,1,1],  // i <- e, a, o, u
     *  [0,0,1,0,1],  // o <- i, u
     *  [1,0,0,0,0]]  // u <- a
     * 
     * 时间复杂度: O(logn) - 使用矩阵快速幂优化
     * 空间复杂度: O(1) - 只使用常数额外空间
     * 
     * @param n 字符串长度
     * @return 合法字符串数量
     */
    public static int countVowelPermutation(int n) {
        // 长度为1的时候，以a、e、i、o、u结尾的合法数量都为1
        int[][] start = { { 1, 1, 1, 1, 1 } };
        
        // 转移矩阵表示状态转移关系
        int[][] base = {
                { 0, 1, 0, 0, 0 },  // a <- e
                { 1, 0, 1, 0, 0 },  // e <- a, i
                { 1, 1, 0, 1, 1 },  // i <- e, a, o, u
                { 0, 0, 1, 0, 1 },  // o <- i, u
                { 1, 0, 0, 0, 0 }   // u <- a
                };
        
        // 计算 start * base^(n-1) 得到长度为n时各状态的数量
        int[][] ans = multiply(start, power(base, n - 1));
        
        // 求和得到总数量
        int ret = 0;
        for (int a : ans[0]) {
            ret = (ret + a) % MOD;
        }
        return ret;
    }

    /**
     * 矩阵相乘（带模运算）
     * 
     * 算法原理:
     * 对于矩阵A(n×k)和矩阵B(k×m)，结果矩阵C(n×m)中:
     * C[i][j] = Σ(A[i][k] * B[k][j]) for k in 0..k-1
     * 
     * 时间复杂度: O(n×m×k)
     * 空间复杂度: O(n×m)
     * 
     * 注意事项:
     * - 矩阵乘法要求第一个矩阵的列数等于第二个矩阵的行数
     * - 每步都进行模运算防止溢出
     * - 使用long类型临时变量防止中间计算溢出
     * 
     * @param a 第一个矩阵 (n×k)
     * @param b 第二个矩阵 (k×m)
     * @return 两个矩阵的乘积 (n×m)
     */
    // 矩阵相乘 + 乘法取模
    // a的列数一定要等于b的行数
    public static int[][] multiply(int[][] a, int[][] b) {
        int n = a.length;      // 结果矩阵行数
        int m = b[0].length;   // 结果矩阵列数
        int k = a[0].length;   // 中间维度（a的列数，b的行数）
        int[][] ans = new int[n][m];
        
        // 三重循环计算矩阵乘法
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++) {
                for (int c = 0; c < k; c++) {
                    // 使用long类型防止中间计算溢出，每步都进行模运算
                    ans[i][j] = (int) (((long) a[i][c] * b[c][j] + ans[i][j]) % MOD);
                }
            }
        }
        return ans;
    }

    /**
     * 矩阵快速幂
     * 
     * 算法原理:
     * 利用二进制分解指数，通过不断平方和累积结果实现快速计算
     * 例如: A^13，13的二进制为1101
     * A^13 = A^8 * A^4 * A^1 (对应二进制位为1的位置)
     * 
     * 时间复杂度: O(n^3 * logp) - n为矩阵维度
     * 空间复杂度: O(n^2)
     * 
     * 实现技巧:
     * - 使用位运算优化指数分解 (p >>= 1)
     * - 使用位运算检查二进制位是否为1 ((p & 1) != 0)
     * - 结果初始化为单位矩阵
     * 
     * @param m 底数矩阵（必须是方阵）
     * @param p 指数
     * @return 矩阵m的p次幂
     */
    // 矩阵快速幂
    public static int[][] power(int[][] m, int p) {
        int n = m.length;  // 矩阵维度
        // 构造单位矩阵作为初始结果
        int[][] ans = new int[n][n];
        for (int i = 0; i < n; i++) {
            ans[i][i] = 1;  // 单位矩阵对角线元素为1
        }
        
        // 快速幂算法核心实现
        for (; p != 0; p >>= 1) {  // 指数不断右移一位（除以2）
            if ((p & 1) != 0) {    // 如果当前位为1，则累乘到结果中
                ans = multiply(ans, m);
            }
            m = multiply(m, m);    // 底数不断平方
        }
        return ans;
    }

}