# Class069 全面总结与扩展

## 一、算法分类与核心思想

### 1. 多维费用背包问题
**核心思想**：传统背包问题的扩展，每个物品有多个维度的限制条件（如重量、体积、数量等）。

**典型题目**：
- 一和零 (Ones and Zeroes)
- 盈利计划 (Profitable Schemes) 
- 目标和 (Target Sum)
- 最后一块石头的重量 II (Last Stone Weight II)

**解题技巧**：
1. **状态定义**：dp[i][j][k] 表示前i个物品，在满足各种限制条件下的最优解
2. **状态转移**：根据是否选择当前物品进行状态转移
3. **空间优化**：通过滚动数组优化空间复杂度

### 2. 概率动态规划问题
**核心思想**：计算某种状态发生的概率，通过递推方式从基础状态逐步计算复杂状态的概率。

**典型题目**：
- 骑士在棋盘上的概率 (Knight Probability in Chessboard)
- Coins (概率DP)
- 骑士拨号器 (Knight Dialer)

**解题技巧**：
1. **状态定义**：dp[i][j][k] 表示在某种条件下到达状态(i,j)的概率
2. **状态转移**：根据可能的转移路径计算概率
3. **边界条件**：确定初始状态和终止状态的概率

### 3. 路径计数动态规划问题
**核心思想**：在网格中从起点到终点的路径数量计算，可能还需要满足某些约束条件。

**典型题目**：
- 矩阵中和能被K整除的路径 (Paths Divisible by K)
- 不同路径 (Unique Paths)
- 最小路径和 (Minimum Path Sum)

**解题技巧**：
1. **状态定义**：dp[i][j][k] 表示到达位置(i,j)且满足某种条件的路径数
2. **状态转移**：根据前一个状态更新当前状态
3. **边界处理**：处理起点和边界情况

### 4. 字符串动态规划问题
**核心思想**：处理字符串相关的复杂操作，如扰乱、匹配、编辑等。

**典型题目**：
- 扰乱字符串 (Scramble String)
- 编辑距离 (Edit Distance)
- 最长公共子序列 (Longest Common Subsequence)

**解题技巧**：
1. **子问题分解**：将复杂字符串操作分解为子串操作
2. **状态定义**：dp[i][j] 表示字符串子问题的解
3. **转移方程**：根据字符匹配情况设计转移

### 5. 线性动态规划问题
**核心思想**：状态只依赖于前面有限个状态的动态规划问题，通常可以进行空间优化。

**典型题目**：
- 爬楼梯 (Climbing Stairs)
- 打家劫舍 (House Robber)
- 最长递增子序列 (Longest Increasing Subsequence)

**解题技巧**：
1. **状态定义**：dp[i] 表示以位置i结尾的最优解或到达位置i的方案数
2. **状态转移**：dp[i] = f(dp[i-k], ..., dp[i-1])，k为常数
3. **空间优化**：使用滚动变量降低空间复杂度到O(1)

## 二、时间复杂度与空间复杂度分析

### 通用复杂度分析框架
1. **暴力解法**：O(2^n) 或 O(n!) - 指数级复杂度
2. **记忆化搜索**：O(状态数) - 多项式复杂度
3. **动态规划**：O(状态数) - 多项式复杂度
4. **空间优化**：O(较小维度) - 降低空间复杂度

### 具体题目复杂度对比
| 题目 | 暴力解法 | 记忆化搜索 | 动态规划 | 空间优化 |
|------|----------|------------|----------|----------|
| 一和零 | O(2^n) | O(n*m*n) | O(n*m*n) | O(m*n) |
| 盈利计划 | O(2^m) | O(m*n*p) | O(m*n*p) | O(n*p) |
| 骑士概率 | O(8^k) | O(n^2*k) | O(n^2*k) | O(n^2) |
| 路径计数 | O(2^(m+n)) | O(n*m*k) | O(n*m*k) | O(m*k) |
| 扰乱字符串 | O(n!) | O(n^4) | O(n^4) | O(n^3) |

## 三、工程化考量与最佳实践

### 1. 异常处理策略
```java
// 输入验证
if (nums == null || nums.length == 0) return 0;
if (target < -sum || target > sum) return 0;
```

### 2. 边界条件处理
```java
// 边界条件
if (i == 0 || j == 0) return 1;  // 网格边界
if (steps == 0) return 1;         // 步数边界  
if (len == 1) return s1[i] == s2[j]; // 字符串边界
```

### 3. 性能优化技巧
```java
// 空间优化：滚动数组
for (int i = n - 1; i >= 0; i--) {
    for (int j = m; j >= cost; j--) {
        dp[j] = Math.max(dp[j], dp[j - cost] + value);
    }
}

// 剪枝优化：提前返回
if (sorted(s1) != sorted(s2)) return false;
```

### 4. 大数处理与模运算
```java
private static final int MOD = 1000000007;
int result = (a + b) % MOD;
int result = (int)((long)a * b % MOD);
```

## 四、语言特性差异与实现技巧

### Java 实现特点
- **内存管理**：自动垃圾回收，无需手动释放
- **集合框架**：丰富的集合类库支持
- **类型安全**：强类型系统，编译时检查

### C++ 实现特点  
- **性能优化**：手动内存管理，零开销抽象
- **模板编程**：泛型支持，代码复用
- **STL库**：高效的数据结构和算法

### Python 实现特点
- **简洁语法**：动态类型，代码简洁
- **内置函数**：丰富的内置函数支持
- **装饰器**：@lru_cache 简化记忆化实现

## 五、测试用例设计与验证

### 测试用例分类
1. **基础测试**：简单输入验证基本功能
2. **边界测试**：空数组、单元素、极值等
3. **性能测试**：大规模数据验证效率
4. **正确性测试**：对比不同解法的结果

### 测试用例示例
```java
// 一和零测试用例
String[] strs1 = {"10", "0001", "111001", "1", "0"};
int m1 = 5, n1 = 3;  // 预期结果: 4

// 目标和测试用例  
int[] nums1 = {1,1,1,1,1};
int target1 = 3;  // 预期结果: 5
```

## 六、算法扩展与变种

### 1. 多维背包变种
- **分组背包**：每组最多选一个物品
- **依赖背包**：物品间存在依赖关系
- **树形背包**：在树结构上的背包问题

### 2. 概率DP扩展
- **马尔可夫链**：状态转移概率矩阵
- **蒙特卡洛方法**：随机模拟近似解
- **贝叶斯推理**：条件概率计算

### 3. 路径计数进阶
- **带障碍物的路径**：网格中存在障碍物
- **多条路径问题**：机器人同时走多条路径
- **三维路径计数**：在三维空间中的路径

## 七、面试技巧与实战建议

### 1. 解题思路表达
- **问题分析**：明确问题本质，识别动态规划特征
- **状态定义**：清晰定义状态含义和维度
- **转移方程**：推导状态转移关系
- **边界处理**：考虑特殊情况

### 2. 代码实现规范
- **变量命名**：见名知意，避免缩写
- **注释说明**：关键步骤添加注释
- **代码结构**：模块化设计，函数职责单一

### 3. 性能优化讨论
- **复杂度分析**：时间复杂度和空间复杂度
- **优化策略**：空间优化、剪枝策略
- **替代方案**：不同解法的优缺点比较

## 八、补充题目资源

### LeetCode 相关题目
- 474. Ones and Zeroes (一和零)
- 879. Profitable Schemes (盈利计划)
- 494. Target Sum (目标和)
- 1049. Last Stone Weight II (最后一块石头的重量II)
- 688. Knight Probability in Chessboard (骑士在棋盘上的概率)
- 935. Knight Dialer (骑士拨号器)
- 2435. Paths in Matrix Whose Sum is Divisible by K (矩阵中和能被K整除的路径)
- 62. Unique Paths (不同路径)
- 87. Scramble String (扰乱字符串)

### 其他平台题目
- AtCoder DP Contest I - Coins (概率DP)
- Codeforces 相关动态规划题目
- 各大高校OJ中的经典DP题目

通过系统学习和实践这些题目，可以全面掌握动态规划的高级技巧，在算法面试和实际开发中游刃有余。