# Class069 解题思路与技巧总结

## 一、多维费用背包问题

### 1. 核心思想
多维费用背包问题是传统背包问题的扩展，每个物品不仅有重量限制，还有其他维度的限制条件（如体积、数量等）。我们需要在满足所有维度限制的前提下，最大化价值。

### 2. 典型题目
- 一和零 (Ones and Zeroes)
- 盈利计划 (Profitable Schemes)
- 目标和 (Target Sum)
- 最后一块石头的重量 II (Last Stone Weight II)

### 3. 解题思路
1. **状态定义**：dp[i][j][k] 表示前 i 个物品，在满足各种限制条件下的最优解
2. **状态转移**：根据是否选择当前物品进行状态转移
3. **空间优化**：通常可以通过滚动数组优化空间复杂度

### 4. 状态转移方程
```
dp[i][j][k] = max(dp[i-1][j][k], dp[i-1][j-cost1[i]][k-cost2[i]] + value[i])
```

### 5. 时间复杂度分析
- 时间复杂度：O(n * C1 * C2 * ... * Ck)，其中 n 是物品数量，C1, C2, ..., Ck 是各维度的容量
- 空间复杂度：O(C1 * C2 * ... * Ck)

## 二、概率动态规划问题

### 1. 核心思想
概率动态规划用于计算某种状态发生的概率。通常通过递推的方式，从基础状态逐步计算复杂状态的概率。

### 2. 典型题目
- 骑士在棋盘上的概率 (Knight Probability in Chessboard)
- 骑士拨号器 (Knight Dialer)
- Coins (概率DP)

### 3. 解题思路
1. **状态定义**：dp[i][j][k] 表示在某种条件下到达状态 (i,j) 的概率
2. **状态转移**：根据可能的转移路径计算概率
3. **边界条件**：确定初始状态和终止状态的概率

### 4. 状态转移方程
```
dp[i][j][k] = Σ(probability_of_move * dp[next_i][next_j][k-1])
```

### 5. 时间复杂度分析
- 时间复杂度：O(n * m * k * moves)，其中 n 和 m 是棋盘尺寸，k 是步数，moves 是可能的移动数
- 空间复杂度：O(n * m * k)

## 三、路径计数动态规划问题

### 1. 核心思想
路径计数问题通常涉及在网格中从起点到终点的路径数量计算，可能还需要满足某些约束条件（如路径和能被 K 整除）。

### 2. 典型题目
- 矩阵中和能被 K 整除的路径 (Paths in Matrix Whose Sum is Divisible by K)
- 不同路径 (Unique Paths)
- 最小路径和 (Minimum Path Sum)

### 3. 解题思路
1. **状态定义**：dp[i][j][k] 表示到达位置 (i,j) 且满足某种条件的路径数
2. **状态转移**：根据前一个状态更新当前状态
3. **边界处理**：处理起点和边界情况

### 4. 状态转移方程
```
dp[i][j][k] = dp[i-1][j][(k-grid[i][j])%K] + dp[i][j-1][(k-grid[i][j])%K]
```

### 5. 时间复杂度分析
- 时间复杂度：O(n * m * K)，其中 n 和 m 是网格尺寸，K 是模数
- 空间复杂度：O(n * m * K)

## 四、字符串扰乱问题

### 1. 核心思想
字符串扰乱问题判断一个字符串是否可以通过特定的分割和重组操作变成另一个字符串。

### 2. 典型题目
- 扰乱字符串 (Scramble String)
- 交错字符串 (Interleaving String)

### 3. 解题思路
1. **状态定义**：dp[i1][i2][len] 表示第一个字符串从 i1 开始，第二个字符串从 i2 开始，长度为 len 的子串是否为扰乱字符串
2. **状态转移**：考虑不交换和交换两种情况
3. **边界处理**：处理长度为 1 的情况

### 4. 状态转移方程
```
dp[i1][i2][len] = 
    (dp[i1][i2][k] && dp[i1+k][i2+k][len-k]) || 
    (dp[i1][i2+len-k][k] && dp[i1+k][i2][len-k])
```

### 5. 时间复杂度分析
- 时间复杂度：O(n^4)，其中 n 是字符串长度
- 空间复杂度：O(n^3)

## 五、工程化考量

### 1. 异常处理
- 检查输入参数合法性
- 处理边界条件（空数组、单元素等）
- 防止整数溢出（使用取模运算）

### 2. 性能优化
- 选择合适的数据结构
- 减少不必要的计算
- 空间优化降低内存使用

### 3. 可测试性
- 提供完整的测试用例
- 覆盖边界场景
- 验证算法正确性

## 六、语言特性差异

### 1. Java
- 内存管理自动化，无需手动释放
- 丰富的集合类库
- 强类型系统，编译时检查

### 2. C++
- 手动内存管理，需要关注内存泄漏
- STL 提供高效的数据结构
- 模板支持泛型编程

### 3. Python
- 动态类型，代码简洁
- 丰富的内置函数和库
- 列表推导式等高级特性

## 七、新增题目总结

### 1. Coins (概率DP)
- **题目来源**: AtCoder Educational DP Contest
- **核心思想**: 计算正面朝上的硬币数比反面朝上的硬币数多的概率
- **解法**: 动态规划、空间优化、记忆化搜索
- **时间复杂度**: O(N^2)
- **空间复杂度**: O(N)

### 2. Knight Dialer (骑士拨号器)
- **题目来源**: LeetCode
- **核心思想**: 计算骑士在数字键盘上能拨出的不同电话号码数量
- **解法**: 动态规划、空间优化、记忆化搜索
- **时间复杂度**: O(N)
- **空间复杂度**: O(1)

### 3. Unique Paths (不同路径)
- **题目来源**: LeetCode
- **核心思想**: 计算机器人从网格左上角到右下角的不同路径数
- **解法**: 动态规划、空间优化、数学组合
- **时间复杂度**: O(m*n) 或 O(min(m,n))
- **空间复杂度**: O(min(m,n))

## 八、总结

Class069 主要涵盖了多维费用背包、概率DP、路径计数DP和字符串扰乱等高级动态规划问题。掌握这些题型的关键在于：

1. **状态设计**：合理定义状态表示，确保状态转移的正确性
2. **转移方程**：准确写出状态转移方程
3. **边界处理**：正确处理初始状态和边界条件
4. **优化技巧**：掌握空间优化、记忆化搜索等优化方法
5. **工程实践**：关注代码质量、异常处理和性能优化

通过大量练习和深入理解，可以逐步掌握这些高级动态规划技巧，在算法面试和实际开发中灵活运用。