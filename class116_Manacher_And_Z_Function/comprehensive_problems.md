# Manacher算法与Z函数综合题目集

## 目录
1. [Manacher算法题目](#manacher算法题目)
   - [LeetCode 5. 最长回文子串](#leetcode-5-最长回文子串)
   - [LeetCode 647. 回文子串](#leetcode-647-回文子串)
   - [LeetCode 214. 最短回文串](#leetcode-214-最短回文串)
   - [LeetCode 1960. 两个回文子字符串长度的最大乘积](#leetcode-1960-两个回文子字符串长度的最大乘积)
   - [洛谷 P3805 【模板】manacher](#洛谷-p3805-模板manacher)
   - [UVa 11475 - Extend to Palindrome](#uva-11475---extend-to-palindrome)
   - [Codeforces 1326D2 - Prefix-Suffix Palindrome](#codeforces-1326d2---prefix-suffix-palindrome)
   - [HackerRank - Palindromic Substrings](#hackerrank---palindromic-substrings)
   - [AcWing 141. 周期](#acwing-141-周期)
   - [POJ 3240 - 回文串](#poj-3240---回文串)
   - [LeetCode 336. 回文对](#leetcode-336-回文对)
   - [LeetCode 131. 分割回文串](#leetcode-131-分割回文串)
   - [LeetCode 132. 分割回文串 II](#leetcode-132-分割回文串-ii)
   - [SPOJ PALIN - The Next Palindrome](#spoj-palin---the-next-palindrome)
   - [HackerRank Build a Palindrome](#hackerrank-build-a-palindrome)
   - [洛谷 P1659 [国家集训队]拉拉队排练](#洛谷-p1659-国家集训队拉拉队排练)
   - [洛谷 P4555 [国家集训队]最长双回文串](#洛谷-p4555-国家集训队最长双回文串)
2. [Z函数（扩展KMP）题目](#z函数扩展kmp题目)
   - [LeetCode 2223. 构造字符串的总得分和](#leetcode-2223-构造字符串的总得分和)
   - [LeetCode 3031. 将单词恢复初始状态所需的最短时间 II](#leetcode-3031-将单词恢复初始状态所需的最短时间-ii)
   - [Codeforces 126B. Password](#codeforces-126b-password)
   - [洛谷 P5410 【模板】扩展KMP/exKMP（Z 函数）](#洛谷-p5410-模板扩展kmppexkmpz-函数)
   - [SPOJ - Pattern Find](#spoj---pattern-find)
   - [HackerEarth - String Similarity](#hackerearth---string-similarity)
   - [AtCoder ABC141E - Who Says a Pun?](#atcoder-abc141e---who-says-a-pun)
   - [USACO 2011 November Contest, Bronze - Cow Photographs](#usaco-2011-november-contest-bronze---cow-photographs)
   - [牛客网 NC15051 - 字符串的匹配](#牛客网-nc15051---字符串的匹配)
3. [高级应用题目](#高级应用题目)
   - [LeetCode 336. 回文对](#leetcode-336-回文对-1)
   - [LeetCode 131. 分割回文串](#leetcode-131-分割回文串-1)
   - [LeetCode 132. 分割回文串 II](#leetcode-132-分割回文串-ii-1)

## Manacher算法题目

### LeetCode 5. 最长回文子串

**题目描述**：
给你一个字符串 s，找到 s 中最长的回文子串。

**示例**：
```
输入：s = "babad"
输出："bab"
解释："aba" 同样是符合题意的答案。

输入：s = "cbbd"
输出："bb"
```

**解题思路**：
使用Manacher算法找到最长回文子串，在处理后的字符串中找到最长回文的中心位置，将该位置映射回原字符串，提取对应的子串。

**时间复杂度**：O(n)
**空间复杂度**：O(n)

**代码实现**：
- [Java版本](Code01_Manacher.java)
- [Python版本](manacher_python.py)
- [C++版本](manacher_cpp.cpp)

### LeetCode 647. 回文子串

**题目描述**：
给定一个字符串，计算其中回文子串的数目。

**示例**：
```
输入: "abc"
输出: 3
解释: 三个回文子串: "a", "b", "c"

输入: "aaa"
输出: 6
解释: 六个回文子串: "a", "a", "a", "aa", "aa", "aaa"
```

**解题思路**：
使用Manacher算法计算每个位置的回文半径，每个回文半径可以贡献一定数量的回文子串，由于我们插入了'#'，实际回文子串数量需要转换计算。

**时间复杂度**：O(n)
**空间复杂度**：O(n)

### LeetCode 214. 最短回文串

**题目描述**：
给定一个字符串 s，你可以通过在字符串前面添加字符将其转换为回文串。找到并返回可以用这种方式转换的最短回文串。

**示例**：
```
输入：s = "aacecaaa"
输出："aaacecaaa"

输入：s = "abcd"
输出："dcbabcd"
```

**解题思路**：
此题虽然可以用Manacher算法解决，但更常用的是KMP算法。我们将字符串与其反转拼接，中间用特殊字符分隔，计算KMP的LPS数组，找到原字符串的最长回文前缀，在原字符串前添加反转的部分。

**时间复杂度**：O(n)
**空间复杂度**：O(n)

### LeetCode 1960. 两个回文子字符串长度的最大乘积

**题目描述**：
给你一个下标从0开始的字符串 s ，你需要找到两个不重叠的回文子字符串，它们的长度都必须为奇数，使得它们长度的乘积最大。

**示例**：
```
输入：s = "ababbb"
输出：9
解释：可以选择子串"aba"和"bbb"，它们的长度乘积是3*3=9。

输入：s = "zaaaxbbby"
输出：9
解释：可以选择子串"aaa"和"bbb"，它们的长度乘积是3*3=9。
```

**解题思路**：
使用Manacher算法计算所有奇回文信息，预处理前缀和后缀数组，分别记录到每个位置为止的最长回文长度，枚举每个分割点，通过前后缀获取左右两个子串中的最长回文大小，相乘即可。

**时间复杂度**：O(n)
**空间复杂度**：O(n)

**代码实现**：
- [Java版本](LeetCode1960_MaxProduct.java)

### 洛谷 P3805 【模板】manacher

**题目描述**：
给出一个只由小写英文字符 a,b,c...y,z 组成的字符串 S，求 S 中最长回文串的长度。

**解题思路**：
直接使用Manacher算法模板，返回最长回文子串的长度。

**时间复杂度**：O(n)
**空间复杂度**：O(n)

### UVa 11475 - Extend to Palindrome

**题目描述**：
给定一个字符串，你需要在其后面添加尽可能少的字符，使其成为一个回文串。

**示例**：
输入：aaaaa → 输出：aaaaa
输入：abcd → 输出：abcdcba

**解题思路**：
可以使用Manacher算法或者结合KMP来解决。我们需要找到字符串的最长前缀，使得该前缀是后缀的回文部分。然后将剩余部分反转添加到字符串后面。

**时间复杂度**：O(n)
**空间复杂度**：O(n)

### Codeforces 1326D2 - Prefix-Suffix Palindrome

**题目描述**：
给定一个字符串s，构造一个长度不超过2n的回文串，该回文串必须以s为前缀，且要求尽可能长。

**解题思路**：
首先匹配前后缀中相同的部分，然后在中间部分找到最长的回文前缀或后缀，使得整个字符串构成回文。可以使用Manacher算法来高效找到中间部分的最长回文。

**时间复杂度**：O(n)
**空间复杂度**：O(n)

### HackerRank - Palindromic Substrings

**题目描述**：
计算一个字符串中所有回文子串的数量。

**解题思路**：
使用Manacher算法可以高效地解决这个问题。对于每个中心位置，计算其回文半径，从而统计回文子串的数量。

**时间复杂度**：O(n)
**空间复杂度**：O(n)

### AcWing 141. 周期

**题目描述**：
一个字符串的前缀是周期性的，如果它可以由某个子串重复多次组成。例如，"abcabcabc"的前缀长度为9的部分可以由"abc"重复3次组成。给定一个字符串，求出它的每个前缀的最小周期长度。

**解题思路**：
这个问题可以使用Z函数来解决。对于前缀长度i，如果i - z[i]是一个周期，那么最小周期就是i - z[i]，其中z[i]是Z函数数组在位置i处的值。

**时间复杂度**：O(n)
**空间复杂度**：O(n)

### POJ 3240 - 回文串

**题目描述**：
给定一个字符串，求其最长回文子串的长度。

**解题思路**：
直接使用Manacher算法求解最长回文子串的长度。

**时间复杂度**：O(n)
**空间复杂度**：O(n)

### LeetCode 336. 回文对

**题目描述**：
给定一组互不相同的单词，找出所有不同的索引对(i, j)，使得两个单词拼接起来是回文串。

**解题思路**：
1. 使用Z函数或Manacher算法预处理每个单词
2. 构建字典树或哈希表
3. 枚举所有可能的拼接方式

**时间复杂度**：O(n * k²)，其中n是单词数量，k是单词平均长度
**空间复杂度**：O(n * k)

### LeetCode 131. 分割回文串

**题目描述**：
给定一个字符串s，将s分割成一些子串，使每个子串都是回文串。返回所有可能的分割方案。

**解题思路**：
1. 使用Manacher算法预处理回文信息
2. 使用回溯法枚举所有分割方案
3. 利用预处理信息快速判断子串是否为回文

**时间复杂度**：O(n * 2ⁿ)
**空间复杂度**：O(n²)

### LeetCode 132. 分割回文串 II

**题目描述**：
给定一个字符串s，将s分割成一些子串，使每个子串都是回文串。返回符合要求的最少分割次数。

**解题思路**：
1. 使用Manacher算法预处理回文信息
2. 使用动态规划计算最少分割次数
3. 优化状态转移过程

**时间复杂度**：O(n²)
**空间复杂度**：O(n²)

### SPOJ PALIN - The Next Palindrome

**题目描述**：
给定一个整数，找到大于该数的最小回文数。

**解题思路**：
1. 将数字转换为字符串
2. 使用Manacher算法找到当前数字的回文性质
3. 构造下一个回文数

**时间复杂度**：O(n)
**空间复杂度**：O(n)

### HackerRank Build a Palindrome

**题目描述**：
给定两个字符串a和b，从a中取一个非空前缀，从b中取一个非空后缀，拼接成一个回文串，求最长的回文串长度。

**解题思路**：
1. 使用Manacher算法预处理两个字符串
2. 枚举所有可能的前缀后缀组合
3. 检查拼接后的字符串是否为回文

**时间复杂度**：O(n²)
**空间复杂度**：O(n)

### 洛谷 P1659 [国家集训队]拉拉队排练

**题目描述**：
求字符串中所有奇数长度回文串的长度乘积。

**解题思路**：
1. 使用Manacher算法找到所有奇数长度回文串
2. 统计每个长度的回文串数量
3. 计算前k大的长度乘积

**时间复杂度**：O(n)
**空间复杂度**：O(n)

### 洛谷 P4555 [国家集训队]最长双回文串

**题目描述**：
求字符串中最长的双回文子串长度（可以分成两个回文串的字符串）。

**解题思路**：
1. 使用Manacher算法预处理
2. 计算每个位置作为分割点的左右最长回文
3. 枚举所有分割点求最大值

**时间复杂度**：O(n)
**空间复杂度**：O(n)

## Z函数（扩展KMP）题目

### LeetCode 2223. 构造字符串的总得分和

**题目描述**：
你需要从空字符串开始构造一个长度为n的字符串s，构造过程为每次给当前字符串前面添加一个字符。构造过程中得到的所有字符串编号为1到n，其中长度为i的字符串编号为si。si的得分为si和sn的最长公共前缀的长度（注意s == sn）。请你返回每一个si的得分之和。

**示例**：
```
输入：s = "babab"
输出：9
解释：
s1 == "b"，得分1
s2 == "ab"，得分0
s3 == "bab"，得分3
s4 == "abab"，得分0
s5 == "babab"，得分5
总和为1+0+3+0+5=9
```

**解题思路**：
题目求的就是扩展KMP（Z数组）的所有元素之和。使用Z函数计算每个后缀与原字符串的最长公共前缀长度，然后求和。

**时间复杂度**：O(n)
**空间复杂度**：O(n)

**代码实现**：
- [Java版本](Code02_ExpandKMP.java)
- [Python版本](z_function_python.py)
- [C++版本](z_function_cpp.cpp)

### LeetCode 3031. 将单词恢复初始状态所需的最短时间 II

**题目描述**：
给你一个下标从0开始的字符串word和一个整数k。每一秒执行以下操作：
1. 移除word的前k个字符
2. 在word的末尾添加k个任意字符
返回将word恢复到初始状态所需的最短时间（该时间必须大于零）。

**示例**：
```
输入：word = "abacaba", k = 3
输出：2
解释：
第1秒后，word变成"acaba**"（用*表示添加的字符）
第2秒后，word变成"aba****"
如果添加的字符分别为"cac"和"caba"，word就恢复为"abacaba"
```

**解题思路**：
使用Z函数计算每个后缀与原字符串的最长公共前缀长度，查找满足条件的最小时间。

**时间复杂度**：O(n)
**空间复杂度**：O(n)

### Codeforces 126B. Password

**题目描述**：
给定一个字符串s，找出最长的子串t，它既是s的前缀，也是s的后缀，还在s的中间出现过。如果存在这样的子串，输出最长的那个；否则输出"Just a legend"。

**解题思路**：
使用Z函数（扩展KMP）算法解决此问题：
1. 计算字符串s的Z函数数组z，其中z[i]表示以位置i开始的后缀与原字符串的最长公共前缀长度
2. 遍历z数组，找到既是前缀又是后缀的子串（即z[i] == n-i的情况）
3. 同时记录在中间出现过的前缀长度
4. 找到满足所有条件的最长子串

**时间复杂度**：O(n)
**空间复杂度**：O(n)

**代码实现**：
- [Java版本](Codeforces126B_Password.java)
- [Python版本](codeforces_126b_password.py)
- [C++版本](codeforces_126b_password.cpp)

### 洛谷 P5410 【模板】扩展KMP/exKMP（Z 函数）

**题目描述**：
给定两个字符串a,b，你要求出两个数组：
- b 的z函数数组z，即b与b的每一个后缀的LCP长度。
- b与a的每一个后缀的LCP长度数组p。

**解题思路**：
使用Z函数算法解决此问题。

**时间复杂度**：O(n + m)
**空间复杂度**：O(n + m)

### SPOJ - Pattern Find

**题目描述**：
给定一个字符串S和一个模式串T，找出T在S中的所有出现位置。

**解题思路**：
使用Z函数来解决字符串匹配问题。将模式串T与文本串S拼接，中间用特殊字符分隔，然后计算拼接后字符串的Z函数数组。Z函数值等于模式串长度的位置即为匹配位置。

**时间复杂度**：O(n + m)，其中n是文本串长度，m是模式串长度。
**空间复杂度**：O(n + m)

**代码实现**：
```python
# Python版本
def z_function(s):
    n = len(s)
    z = [0] * n
    z[0] = n
    l, r = 0, 0
    for i in range(1, n):
        if i <= r:
            z[i] = min(r - i + 1, z[i - l])
        while i + z[i] < n and s[z[i]] == s[i + z[i]]:
            z[i] += 1
        if i + z[i] - 1 > r:
            l, r = i, i + z[i] - 1
    return z

def pattern_find(pattern, text):
    combined = pattern + '#' + text
    z = z_function(combined)
    pattern_len = len(pattern)
    positions = []
    
    for i in range(pattern_len + 1, len(combined)):
        if z[i] == pattern_len:
            positions.append(i - pattern_len - 1)
    
    return positions
```

### HackerEarth - String Similarity

**题目描述**：
对于字符串s，定义其相似度为s的每个后缀与s的最长公共前缀的长度之和。例如，对于s="ababaa"，其后缀分别为"ababaa"、"babaa"、"abaa"、"baa"、"aa"、"a"，对应的最长公共前缀长度分别为6、0、3、0、1、1，因此相似度为6+0+3+0+1+1=11。

**解题思路**：
这道题直接要求计算Z函数数组的和，Z[i]表示从位置i开始的后缀与整个字符串的最长公共前缀长度。

**时间复杂度**：O(n)
**空间复杂度**：O(n)

**代码实现**：
```cpp
// C++版本
#include <iostream>
#include <vector>
#include <string>
using namespace std;

vector<int> z_function(const string &s) {
    int n = s.size();
    vector<int> z(n);
    z[0] = n;
    int l = 0, r = 0;
    for (int i = 1; i < n; ++i) {
        if (i <= r) {
            z[i] = min(r - i + 1, z[i - l]);
        }
        while (i + z[i] < n && s[z[i]] == s[i + z[i]]) {
            z[i]++;
        }
        if (i + z[i] - 1 > r) {
            l = i;
            r = i + z[i] - 1;
        }
    }
    return z;
}

long long string_similarity(const string &s) {
    vector<int> z = z_function(s);
    long long sum = 0;
    for (int val : z) {
        sum += val;
    }
    return sum;
}

int main() {
    int t;
    cin >> t;
    while (t--) {
        string s;
        cin >> s;
        cout << string_similarity(s) << endl;
    }
    return 0;
}
```

### AtCoder ABC141E - Who Says a Pun?

**题目描述**：
给定一个长度为n的字符串s，找出两个不重叠的子串，使得它们相等且长度尽可能大。求最大可能的长度。

**解题思路**：
可以使用Z函数来解决这个问题。对于每个可能的分割点，计算Z函数并找到最长的公共前缀。通过遍历所有可能的起始位置，找到最大长度L，使得存在两个位置i和j，满足j - i >= L，且s[i..i+L-1] == s[j..j+L-1]。

**时间复杂度**：O(n²)，但在实际应用中效率很高。
**空间复杂度**：O(n)

**代码实现**：
```java
// Java版本
import java.util.Scanner;

public class Main {
    public static int[] z_function(String s) {
        int n = s.length();
        int[] z = new int[n];
        z[0] = n;
        int l = 0, r = 0;
        for (int i = 1; i < n; i++) {
            if (i <= r) {
                z[i] = Math.min(r - i + 1, z[i - l]);
            }
            while (i + z[i] < n && s.charAt(z[i]) == s.charAt(i + z[i])) {
                z[i]++;
            }
            if (i + z[i] - 1 > r) {
                l = i;
                r = i + z[i] - 1;
            }
        }
        return z;
    }
    
    public static int solve(String s) {
        int n = s.length();
        int max_len = 0;
        
        for (int i = 0; i < n; i++) {
            String sub = s.substring(i);
            int[] z = z_function(sub);
            
            for (int j = 1; j < z.length; j++) {
                if (z[j] > max_len && j >= z[j]) {
                    max_len = Math.max(max_len, z[j]);
                }
            }
        }
        
        return max_len;
    }
    
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        String s = sc.next();
        System.out.println(solve(s));
    }
}
```

### USACO 2011 November Contest, Bronze - Cow Photographs

**题目描述**：
这道题与Z函数的应用相关，主要涉及到字符串的周期性检测。

**解题思路**：
可以使用Z函数来检测字符串的周期性。如果字符串s有周期p，那么对于所有i > p，s[i] = s[i-p]。利用Z函数，可以快速找到字符串的最小周期。

**时间复杂度**：O(n)
**空间复杂度**：O(n)

### 牛客网 NC15051 - 字符串的匹配

**题目描述**：
给定两个字符串s和t，求出在s中出现的t的所有位置，并输出这些位置的起始索引。

**解题思路**：
可以使用Z函数来解决字符串匹配问题，类似于SPOJ的Pattern Find题目。

**时间复杂度**：O(n + m)
**空间复杂度**：O(n + m)

## 高级应用题目

### LeetCode 336. 回文对

**题目描述**：
给定一组互不相同的单词，找出所有不同的索引对(i, j)，使得两个单词拼接起来是回文串。

**解题思路**：
1. 使用Z函数或Manacher算法预处理每个单词
2. 构建字典树或哈希表
3. 枚举所有可能的拼接方式

**时间复杂度**：O(n * k²)，其中n是单词数量，k是单词平均长度
**空间复杂度**：O(n * k)

### LeetCode 131. 分割回文串

**题目描述**：
给定一个字符串s，将s分割成一些子串，使每个子串都是回文串。返回所有可能的分割方案。

**解题思路**：
1. 使用Manacher算法预处理回文信息
2. 使用回溯法枚举所有分割方案
3. 利用预处理信息快速判断子串是否为回文

**时间复杂度**：O(n * 2ⁿ)
**空间复杂度**：O(n²)

### LeetCode 132. 分割回文串 II

**题目描述**：
给定一个字符串s，将s分割成一些子串，使每个子串都是回文串。返回符合要求的最少分割次数。

**解题思路**：
1. 使用Manacher算法预处理回文信息
2. 使用动态规划计算最少分割次数
3. 优化状态转移过程

**时间复杂度**：O(n²)
**空间复杂度**：O(n²)

## 算法对比总结

| 算法 | 主要用途 | 时间复杂度 | 空间复杂度 | 典型应用 | 适用场景 |
|------|---------|-----------|-----------|---------|---------|
| Manacher | 回文串处理 | O(n) | O(n) | 最长回文子串、回文计数 | 需要高效处理回文相关问题的场景 |
| Z函数 | 字符串匹配 | O(n) | O(n) | 模式匹配、前缀后缀匹配 | 字符串匹配、周期性检测、LCP计算 |

## 工程化考量

### 1. 异常处理与鲁棒性
- **空输入处理**：检查输入字符串是否为空或null
- **边界条件**：处理字符串长度为0、1等特殊情况
- **数组越界**：在扩展匹配时注意数组边界检查
- **内存管理**：预分配足够大的数组空间，避免动态扩容

### 2. 性能优化策略
- **局部变量优化**：减少数组访问开销
- **懒加载数组扩展**：根据实际需求动态调整数组大小
- **边界检查前置**：提前处理特殊情况，避免无效计算
- **算法常数优化**：减少不必要的操作，提高执行效率

### 3. 多语言实现对比

#### Java实现特点
- **字符串处理**：Java中字符串是不可变的，需要频繁创建新字符串或使用StringBuilder
- **数组操作**：数组下标从0开始，需要注意边界检查
- **异常处理**：提供了完善的异常机制，可用于边界条件处理

#### Python实现特点
- **动态类型**：无需提前声明变量类型，代码更简洁
- **字符串处理**：字符串切片操作方便，但需要注意效率
- **内存管理**：自动垃圾回收，但可能导致内存占用较高

#### C++实现特点
- **指针操作**：可以直接操作内存，性能更高
- **STL容器**：vector等容器使用灵活，但需要注意内存管理
- **性能优势**：在处理大规模数据时通常比Java和Python更快

### 4. 调试与问题定位
- **中间过程打印**：在算法执行过程中打印关键变量值
- **断言验证**：验证输入参数的有效性和算法执行结果
- **性能分析**：使用性能分析工具找出耗时操作

## 学习路径建议

### 初级阶段（掌握基础）
1. **理解算法原理**：深入理解Manacher算法和Z函数的核心思想
2. **熟练实现**：能够独立实现两种算法的代码
3. **基础题目练习**：解决LeetCode 5、647、214等基础题目

### 中级阶段（应用扩展）
1. **应用场景识别**：能够识别适合使用这两种算法的问题场景
2. **复杂度分析**：掌握算法的时间和空间复杂度分析方法
3. **题目变种**：解决Codeforces、SPOJ等平台的进阶题目

### 高级阶段（工程化）
1. **优化能力**：能够根据具体场景优化算法实现
2. **跨语言实践**：在多种编程语言中实现算法，理解语言特性影响
3. **工程应用**：将算法应用到实际项目中，处理大规模数据

### 专家阶段（创新应用）
1. **算法变种**：理解并实现算法的各种变种和扩展
2. **组合应用**：将Manacher和Z函数与其他算法结合解决复杂问题
3. **性能调优**：针对特定硬件和场景进行深度优化

## 常见问题与解决方案

### 内存溢出问题
- **问题**：处理长字符串时可能出现内存溢出
- **解决**：使用动态数组分配，根据实际需求调整数组大小

### 性能瓶颈
- **问题**：大数据量下性能下降
- **解决**：启用性能监控，分析瓶颈；确保关闭调试模式

### 算法正确性
- **问题**：某些边缘情况下结果不正确
- **解决**：运行单元测试；检查输入参数是否有效

## 资源推荐

### 在线评测平台
1. **LeetCode**：提供大量Manacher和Z函数相关题目
2. **Codeforces**：包含更多挑战性的字符串算法题目
3. **AtCoder**：日本算法竞赛平台，有质量很高的题目
4. **SPOJ**：包含经典的字符串处理问题
5. **洛谷**：中文算法学习平台，有丰富的题目资源

### 学习资料
1. **算法导论**：深入理解算法理论基础
2. **算法竞赛入门经典**：包含字符串算法详解
3. **编程珠玑**：提供算法设计的思路和技巧
4. **OI Wiki**：详细的算法讲解和实现
5. **CP-Algorithms**：高质量的算法教程网站

## 实战技巧

### 笔试技巧
1. **模板准备**：提前准备好Manacher和Z函数的模板代码
2. **边界处理**：特别注意空字符串、单字符等边界情况
3. **性能优化**：在笔试中注意时间复杂度的优化

### 面试技巧
1. **算法解释**：能够清晰解释算法的原理和复杂度
2. **代码实现**：写出清晰、可读的代码
3. **问题分析**：分析问题的适用算法和优化空间