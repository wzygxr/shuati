# 基数排序专题题目汇总与解答

## 目录
1. [核心算法题目](#核心算法题目)
2. [LeetCode系列题目](#leetcode系列题目)
3. [USACO竞赛题目](#usaco竞赛题目)
4. [在线评测平台题目](#在线评测平台题目)
5. [扩展应用题目](#扩展应用题目)

## 核心算法题目

### 1. 基数排序基本实现
**题目描述**: 实现LSD（Least Significant Digit First）基数排序算法

**解题思路**:
1. 从最低位开始，对每一位进行计数排序
2. 使用计数排序保证稳定性
3. 重复此过程直到最高位

**时间复杂度**: O(d*(n+k))，其中d是位数，n是元素个数，k是基数
**空间复杂度**: O(n+k)

**Java实现**: Code01_RadixSort.java, Code02_RadixSort.java
**C++实现**: radix_sort_cpp.cpp
**Python实现**: radix_sort_python.py

### 2. 负数处理优化
**题目描述**: 处理包含负数的整数数组排序

**解题思路**:
1. 找到数组中的最小值
2. 将所有元素减去最小值转换为非负数
3. 执行基数排序
4. 还原数组元素（加上之前减去的最小值）

**时间复杂度**: O(d*(n+k))
**空间复杂度**: O(n+k)

### 3. 基数选择优化
**题目描述**: 选择合适的基数以优化性能

**解题思路**:
1. 基数越大，轮数越少，但每轮处理的桶越多
2. 基数越小，轮数越多，但每轮处理的桶较少
3. 通常选择10进制便于理解，但在实际应用中可以选择256等2的幂次以提高效率

## LeetCode系列题目

### 1. LeetCode 912. 排序数组
**题目链接**: https://leetcode.cn/problems/sort-an-array/

**题目描述**: 给你一个整数数组 nums，请你将该数组升序排列。

**解题思路**: 使用基数排序对整数数组进行高效排序。

**时间复杂度**: O(d*(n+k))
**空间复杂度**: O(n+k)

**为什么最优**: 对于大规模整数数组，基数排序效率高于基于比较的排序算法。

**Java实现**: Code01_RadixSort.java, Code02_RadixSort.java
**C++实现**: radix_sort_cpp.cpp
**Python实现**: radix_sort_python.py

### 2. LeetCode 164. 最大间距
**题目链接**: https://leetcode.cn/problems/maximum-gap/

**题目描述**: 给定一个无序的数组 nums，返回数组在排序之后，相邻元素之间最大的差值。要求必须编写一个在「线性时间」内运行并使用「线性额外空间」的算法。

**解题思路**: 使用基数排序在O(n)时间内完成排序，然后遍历找出最大间距。

**时间复杂度**: O(d*(n+k))
**空间复杂度**: O(n+k)

**为什么最优**: 基于比较的排序无法达到低于O(nlogn)的时间复杂度。

**Java实现**: Code01_RadixSort.java (maximumGap方法)
**C++实现**: radix_sort_cpp.cpp (maximumGap方法)
**Python实现**: radix_sort_python.py (maximumGap方法)

### 3. LeetCode 2343. 裁剪数字后查询第K小的数字
**题目链接**: https://leetcode.cn/problems/query-kth-smallest-trimmed-number/

**题目描述**: 给你一个下标从0开始的字符串数组nums，其中每个字符串长度相等且只包含数字。对于每个查询，你需要将nums中的每个数字裁剪到剩下最右边trimi个数位。在裁剪过后的数字中，找到nums中第ki小数字对应的下标。

**解题思路**: 使用基数排序对裁剪后的数字进行高效排序。

**时间复杂度**: O(q * (m * n))，其中q是查询次数，m是数字长度，n是数组长度
**空间复杂度**: O(n)

**为什么使用基数排序**: 数字长度固定，非常适合基数排序；基数排序的稳定性保证了在相等情况下保持原始顺序。

**Java实现**: LeetCode2343_Java.java
**C++实现**: LeetCode2343_CPP.cpp
**Python实现**: LeetCode2343_Python.py

## USACO竞赛题目

### 1. USACO 2018 December Platinum - Sort It Out
**题目链接**: https://usaco.org/index.php?page=viewproblem2&cpid=865

**题目类型**: 最长递增子序列问题结合基数排序优化

**解题思路**:
1. 理解题意：一头奶牛在被叫到时会进行"按顺序排好"操作
2. 关键观察：需要选择那些在最长递增子序列(LIS)之外的奶牛
3. 最小子集大小 = N - LIS长度
4. 使用动态规划和组合数学找出字典序第K小的子集

**时间复杂度**: O(N^2)
**空间复杂度**: O(N)

**Java实现**: USACO_SortItOut.java
**C++实现**: USACO_SortItOut_CPP.cpp
**Python实现**: USACO_SortItOut_Python.py

### 2. USACO 2018 Open Gold - Out of Sorts
**题目链接**: https://usaco.org/index.php?page=viewproblem2&cpid=837

**题目类型**: 模拟优化问题，涉及排序算法分析

**解题思路**:
1. 分析原始冒泡排序和修改后的冒泡排序的区别
2. 理解"moo"输出的条件：每次外层while循环开始时都会输出一次
3. 计算修改后的算法需要多少次完整的循环才能使数组有序

**时间复杂度**: O(N^2) 模拟算法
**空间复杂度**: O(1)

**Java实现**: USACO_OutOfSorts.java
**C++实现**: USACO_OutOfSorts_CPP.cpp
**Python实现**: USACO_OutOfSorts_Python.py

## 在线评测平台题目

### 1. 洛谷 P1177 【模板】排序
**题目链接**: https://www.luogu.com.cn/problem/P1177

**题目描述**: 将读入的N个数从小到大排序后输出。

**解题思路**: 基数排序是此题的高效解法之一，特别适合大规模整数数据。

**时间复杂度**: O(d*(n+k))
**空间复杂度**: O(n+k)

**Java实现**: Code01_RadixSort.java
**C++实现**: radix_sort_cpp.cpp
**Python实现**: radix_sort_python.py

### 2. 计蒜客 - 整数排序
**题目链接**: https://nanti.jisuanke.com/t/40256

**题目描述**: 给定一个包含N个整数的数组，将它们按升序排列后输出。

**解题思路**: 基数排序可以在O(d*(n+k))时间内完成排序，对于大规模数据效率高。

**时间复杂度**: O(d*(n+k))
**空间复杂度**: O(n+k)

### 3. HackerRank - Counting Sort 3
**题目链接**: https://www.hackerrank.com/challenges/countingsort3/problem

**题目描述**: 使用计数排序的变种解决统计排序问题。

**解题思路**: 基数排序的基础是计数排序，可以灵活应用于此类问题。

**时间复杂度**: O(n+k)
**空间复杂度**: O(k)

### 4. Codeforces - Sort the Array
**题目链接**: https://codeforces.com/problemset/problem/451/B

**题目描述**: 判断是否可以通过反转一个子数组使得整个数组有序。

**解题思路**: 使用基数排序进行排序，然后比较确定是否满足条件。

**时间复杂度**: O(d*(n+k))
**空间复杂度**: O(n+k)

### 5. 牛客 - 数组排序
**题目链接**: https://www.nowcoder.com/practice/2baf799ea0594abd974d37139de27896

**题目描述**: 对数组进行排序并输出。

**解题思路**: 基数排序是高效解法之一，特别适合整数数组。

**时间复杂度**: O(d*(n+k))
**空间复杂度**: O(n+k)

### 6. HDU 1051. Wooden Sticks
**题目链接**: http://acm.hdu.edu.cn/showproblem.php?pid=1051

**题目描述**: 贪心问题，需要先对木棍进行排序。

**解题思路**: 使用基数排序可以高效排序，然后应用贪心策略。

**时间复杂度**: O(d*(n+k))
**空间复杂度**: O(n+k)

### 7. POJ 3664. Election Time
**题目链接**: http://poj.org/problem?id=3664

**题目描述**: 选举问题，涉及对投票结果的排序。

**解题思路**: 基数排序可以高效处理大量整数排序，适用于统计类问题。

**时间复杂度**: O(d*(n+k))
**空间复杂度**: O(n+k)

### 8. UVa 11462. Age Sort
**题目链接**: https://onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=2457

**题目描述**: 对年龄进行排序，数据量很大。

**解题思路**: 基数排序非常适合处理大规模整数数据，时间复杂度接近线性。

**时间复杂度**: O(d*(n+k))
**空间复杂度**: O(n+k)

### 9. SPOJ - MSORT
**题目链接**: https://www.spoj.com/problems/MSORT/

**题目描述**: 高效排序大数据。

**解题思路**: 基数排序是处理大规模数据的理想选择。

**时间复杂度**: O(d*(n+k))
**空间复杂度**: O(n+k)

### 10. CodeChef - MAX_DIFF
**题目链接**: https://www.codechef.com/problems/MAX_DIFF

**题目描述**: 排序后计算最大差值。

**解题思路**: 使用基数排序高效排序，然后计算差值。

**时间复杂度**: O(d*(n+k))
**空间复杂度**: O(n+k)

## 扩展应用题目

### 1. 字符串排序
**应用场景**: 电话号码排序、身份证号排序等

**解题思路**: 将字符串分解为字符进行基数排序。对于变长字符串，可以使用MSD（最高位优先）的方法。

### 2. 浮点数排序
**应用场景**: 科学计算中的数据排序

**解题思路**: 将浮点数的整数部分和小数部分分开处理，需要注意精度问题。

### 3. 分布式排序
**应用场景**: 大数据处理、云计算环境

**解题思路**: 基数排序可以很好地适应分布式计算环境，可以按位对数据进行分区和合并。

### 4. 大数据处理
**应用场景**: 无法一次性加载到内存的数据排序

**解题思路**: 对于无法一次性加载到内存的数据，可以采用外部基数排序，结合磁盘和内存进行排序。

### 5. 图像处理应用
**应用场景**: 图像像素值的排序和统计

**解题思路**: 可以用于图像像素值的排序和统计，是图像直方图均衡化等操作的基础。

### 6. 数据库索引
**应用场景**: 数据库索引的构建

**解题思路**: 基数排序可以用于数据库索引的构建，提高查询效率。

### 7. 机器学习应用
**应用场景**: 特征工程中的数据预处理

**解题思路**: 在特征工程中的数据预处理和大规模数据集的排序分析中应用。

## 算法优化技巧

### 1. 基数选择优化
- 选择合适的基数（如256或1024）可以减少排序轮数
- 对于大多数场景，BASE=10是平衡的选择
- 使用2的幂作为基数可以利用位运算提高效率（例如：(num >> 8) & 0xFF）
- 对于GPU并行处理，可以选择更大的基数以提高并行度

### 2. 内存使用优化
- 可以复用辅助数组以减少内存分配开销
- 对于特定场景，可以使用原地基数排序
- 使用缓冲区交换技术避免重复复制
- 对于大规模数据，可以采用外部排序思想，分批处理

### 3. 性能优化
- 对于已经排序的位，可以提前终止排序过程
- 使用并行计算处理不同的位（多线程或GPU加速）
- 预分配内存避免动态扩容
- 使用SIMD指令集优化数据并行处理
- 缓存优化：按照数据局部性原则重新组织数据访问模式

## 工程化考量

### 1. 异常处理与健壮性
- 处理空数组和单元素数组
- 验证输入数据的有效性
- 处理可能的溢出情况（Java中需要特别注意整数溢出问题）
- 添加适当的错误提示和日志记录

### 2. 线程安全性
- 当前实现不是线程安全的
- 在多线程环境中使用时需要添加同步机制
- 可以使用ThreadLocal变量避免线程安全问题
- 考虑使用Java 8的并行流进行并行优化

### 3. 可扩展性
- 设计灵活的接口，支持不同的基数和数据类型
- 提供参数配置选项，允许用户根据具体场景调整算法参数
- 支持自定义排序策略

### 4. 单元测试
- 编写全面的单元测试覆盖各种情况
- 测试边界条件和异常输入
- 实现性能测试，监控算法在不同数据规模下的表现

## 面试技巧与常见问题

### 1. 基数排序与比较排序的区别
- 基数排序是非比较型排序，可以突破O(nlogn)的时间复杂度下限
- 基数排序需要额外的空间，而有些比较排序可以原地进行
- 基数排序通常只适用于整数或可分解为整数的数据，而比较排序适用于任何可比较的数据

### 2. 为什么基数排序是稳定的
- 在每一轮计数排序中，从后向前处理元素，可以保证相等元素的相对顺序不变
- 稳定性对于多级排序（如先按日期排序，再按时间排序）非常重要

### 3. 基数排序的实际应用场景
- 电话号码排序
- 银行卡号排序
- 字符串排序（按字符分解）
- 日期时间排序（按年月日时分秒分解）

## 数学原理与底层逻辑

### 1. 稳定性证明
- 基数排序的稳定性基于每一轮计数排序的稳定性
- 在计数排序中，从后向前处理元素确保了相等元素的相对顺序不变
- 数学归纳法可以证明LSD基数排序的稳定性

### 2. 时间复杂度分析
- 每一轮计数排序的时间复杂度为O(n+k)
- 排序轮数等于最大数字的位数d
- 总时间复杂度为O(d*(n+k))
- 当k远小于n且d为常数时，时间复杂度接近O(n)

### 3. 空间复杂度分析
- 需要一个大小为n的辅助数组
- 需要一个大小为k的计数数组
- 总空间复杂度为O(n+k)

## 极端场景测试

### 测试用例设计
1. **空数组**: 直接返回原数组
2. **单元素数组**: 直接返回原数组
3. **包含相同元素的数组**: 验证稳定性
4. **完全有序数组**: 测试算法在已有序情况下的性能
5. **完全逆序数组**: 测试最坏情况下的性能
6. **包含极大值和极小值的数组**: 验证偏移量计算的正确性
7. **大规模数据**: 测试算法的可扩展性
8. **包含重复值的数组**: 验证算法的稳定性和正确性

## 总结

基数排序是一种高效的非比较型排序算法，特别适用于整数排序场景。通过本专题的学习，可以掌握：

1. **算法原理**: 理解LSD和MSD两种基数排序方法
2. **实现技巧**: 掌握负数处理、稳定性保证等关键技术
3. **应用场景**: 了解基数排序在各类问题中的应用
4. **工程化考量**: 学习算法在实际工程中的应用和优化
5. **跨语言实现**: 比较不同语言下算法的实现差异和优化策略

基数排序虽然在某些场景下不如基于比较的排序算法通用，但在特定问题（如大规模整数排序、需要稳定排序的场景）中具有不可替代的优势。掌握基数排序有助于拓宽算法视野，提高解决实际问题的能力。