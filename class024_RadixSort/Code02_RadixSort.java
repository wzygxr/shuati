

import java.util.Arrays;

/**
 * 基数排序实现类
 * 
 * 测试链接 : https://leetcode.cn/problems/sort-an-array/
 * 
 * 基数排序是一种非比较型整数排序算法，其原理是将整数按位数切割成不同的数字，
 * 然后按每个位数分别比较。由于整数也可以表达字符串（比如名字或日期）和特定格式的浮点数，
 * 所以基数排序也不是只能使用于整数。
 * 
 * 基数排序有两种方法：
 * 1. MSD（Most Significant Digit First）从高位开始进行排序
 * 2. LSD（Least Significant Digit First）从低位开始进行排序
 * 
 * 本实现使用LSD方法，适用于位数较少的整数排序。
 * 
 * 基数排序 vs 其他排序算法：
 * 1. 时间复杂度：O(d*(n+k))，其中d是位数，n是元素个数，k是基数（这里是BASE）
 * 2. 空间复杂度：O(n+k)
 * 3. 稳定性：稳定排序
 * 4. 适用场景：整数排序，特别是当数据范围不是很大时
 * 
 * 工程化考虑：
 * 1. 处理负数：通过偏移量转换为非负数处理
 * 2. 可配置基数：BASE可以调整以适应不同场景
 * 3. 溢出处理：对于可能溢出的情况，可以改用long类型数组
 */
public class Code02_RadixSort {

	// 可以设置进制，不一定10进制，随你设置
	// 基数的选择会影响算法的性能：
	// 1. 基数越大，轮数越少，但每轮处理的桶越多
	// 2. 基数越小，轮数越多，但每轮处理的桶较少
	// 通常选择10进制便于理解，但在实际应用中可以选择256等2的幂次以提高效率
	public static int BASE = 10;

	// 最大数组长度限制
	public static int MAXN = 50001;

	// 辅助数组，用于排序过程中的数据暂存
	public static int[] help = new int[MAXN];

	// 计数数组，用于统计每个基数出现的次数
	public static int[] cnts = new int[BASE];

	/**
	 * 主排序函数，对整数数组进行升序排序
	 * 
	 * 算法步骤：
	 * 1. 处理边界情况：数组长度小于等于1时直接返回
	 * 2. 处理负数：找到数组中的最小值，将所有元素减去最小值转换为非负数
	 * 3. 计算最大值的位数，确定排序轮数
	 * 4. 执行基数排序
	 * 5. 还原数组元素（加上之前减去的最小值）
	 * 
	 * 时间复杂度分析：
	 * 1. 找最小值和最大值：O(n)
	 * 2. 偏移处理：O(n)
	 * 3. 基数排序：O(d*(n+k))，其中d是位数，k是基数
	 * 4. 还原处理：O(n)
	 * 总时间复杂度：O(d*(n+k))
	 * 
	 * 空间复杂度分析：
	 * 1. 辅助数组help：O(n)
	 * 2. 计数数组cnts：O(k)
	 * 总空间复杂度：O(n+k)
	 * 
	 * @param arr 待排序的整数数组
	 * @return 排序后的整数数组
	 */
	public static int[] sortArray(int[] arr) {
		if (arr.length > 1) {
			// 如果会溢出，那么要改用long类型数组来排序
			int n = arr.length;
			// 找到数组中的最小值
			int min = arr[0];
			for (int i = 1; i < n; i++) {
				min = Math.min(min, arr[i]);
			}
			int max = 0;
			for (int i = 0; i < n; i++) {
				// 数组中的每个数字，减去数组中的最小值，就把arr转成了非负数组
				// 这是处理负数的关键技巧：通过偏移将负数转换为非负数
				arr[i] -= min;
				// 记录数组中的最大值
				max = Math.max(max, arr[i]);
			}
			// 根据最大值在BASE进制下的位数，决定基数排序做多少轮
			radixSort(arr, n, bits(max));
			// 数组中所有数都减去了最小值，所以最后不要忘了还原
			for (int i = 0; i < n; i++) {
				arr[i] += min;
			}
		}
		return arr;
	}

	/**
	 * 计算数字在BASE进制下的位数
	 * 
	 * @param number 输入数字
	 * @return 该数字在BASE进制下的位数
	 * 
	 * 示例：
	 * 当BASE=10时，bits(123) = 3
	 * 当BASE=10时，bits(0) = 0
	 * 当BASE=2时，bits(7) = 3 (111)
	 */
	public static int bits(int number) {
		int ans = 0;
		while (number > 0) {
			ans++;
			number /= BASE;
		}
		return ans;
	}

	/**
	 * 基数排序核心代码
	 * 
	 * 算法原理：
	 * 1. 从最低位开始，对每一位进行计数排序
	 * 2. 使用计数排序保证稳定性
	 * 3. 重复此过程直到最高位
	 * 
	 * @param arr 待排序数组
	 * @param n 数组长度
	 * @param bits arr中最大值在BASE进制下有几位
	 * 
	 * 算法详解：
	 * 1. offset表示当前处理的位数权重（1, BASE, BASE^2, ...）
	 * 2. 对于每一轮：
	 *    a. 统计当前位上各数字的出现次数
	 *    b. 计算前缀和，得到各数字在排序后数组中的位置
	 *    c. 从后向前遍历原数组，根据当前位数字将元素放入辅助数组的正确位置
	 *    d. 将辅助数组内容复制回原数组
	 * 
	 * 稳定性保证：
	 * 1. 计数排序本身是稳定的
	 * 2. 从后向前遍历保证了相同数字的相对顺序不变
	 * 3. 按位从低到高排序保证了最终结果的正确性
	 */
	public static void radixSort(int[] arr, int n, int bits) {
		// 理解的时候可以假设BASE = 10
		for (int offset = 1; bits > 0; offset *= BASE, bits--) {
			// 每一轮开始前清空计数数组
			Arrays.fill(cnts, 0);
			
			// 统计当前位上各数字的出现次数
			// (arr[i] / offset) % BASE 是提取当前位数字的技巧
			for (int i = 0; i < n; i++) {
				// 数字提取某一位的技巧
				cnts[(arr[i] / offset) % BASE]++;
			}
			
			// 处理成前缀次数累加的形式
			// cnts[i] 表示当前位数字小于等于i的元素个数
			for (int i = 1; i < BASE; i++) {
				cnts[i] = cnts[i] + cnts[i - 1];
			}
			
			// 从后向前遍历，保证排序的稳定性
			// 将元素按当前位数字放入辅助数组的正确位置
			for (int i = n - 1; i >= 0; i--) {
				// 前缀数量分区的技巧
				// 数字提取某一位的技巧
				// --cnts[(arr[i] / offset) % BASE] 先减后用，确定元素的放置位置
				help[--cnts[(arr[i] / offset) % BASE]] = arr[i];
			}
			
			// 将排序结果复制回原数组
			for (int i = 0; i < n; i++) {
				arr[i] = help[i];
			}
		}
	}

	/**
	 * LeetCode 164. 最大间距
	 * 
	 * 题目链接：https://leetcode.cn/problems/maximum-gap/
	 * 
	 * 题目描述：
	 * 给定一个无序的数组 nums，返回数组在排序之后，相邻元素之间最大的差值。
	 * 如果数组元素个数小于 2，则返回 0。
	 * 要求：必须编写一个在「线性时间」内运行并使用「线性额外空间」的算法。
	 * 
	 * 解题思路：
	 * 1. 使用基数排序在O(n)时间内完成排序
	 * 2. 遍历排序后的数组，计算相邻元素之间的差值，找出最大值
	 * 
	 * 时间复杂度：O(n)
	 * 空间复杂度：O(n)
	 * 
	 * @param nums 输入数组
	 * @return 排序后相邻元素之间的最大差值
	 */
	public static int maximumGap(int[] nums) {
		// 处理边界情况
		if (nums.length < 2) {
			return 0;
		}
		
		// 使用基数排序对数组进行排序
		sortArray(nums);
		
		// 遍历排序后的数组，找出相邻元素之间的最大差值
		int maxGap = 0;
		for (int i = 1; i < nums.length; i++) {
			maxGap = Math.max(maxGap, nums[i] - nums[i - 1]);
		}
		
		return maxGap;
	}

	/**
	 * 【LeetCode 2343. 裁剪数字后查询第K小的数字】
	 * 题目链接：https://leetcode.cn/problems/query-kth-smallest-trimmed-number/
	 * 描述：给你一个下标从0开始的字符串数组nums，其中每个字符串长度相等且只包含数字。
	 * 对于每个查询，你需要将nums中的每个数字裁剪到剩下最右边trimi个数位。
	 * 在裁剪过后的数字中，找到nums中第ki小数字对应的下标。
	 * 
	 * 解法思路：
	 * 1. 对于每个查询，提取裁剪后的数字
	 * 2. 使用基数排序对裁剪后的数字进行排序，保留原始下标
	 * 3. 返回第k小数字的原始下标
	 * 
	 * 时间复杂度：O(q * (m * n))，其中q是查询次数，m是数字长度，n是数组长度
	 * 空间复杂度：O(n)
	 * 
	 * 优化点：
	 * - 可以缓存中间结果，避免重复排序
	 * - 对于较大的m，可以使用基数排序的优化版本
	 */
	public static int[] smallestTrimmedNumbers(String[] nums, int[][] queries) {
		// 边界情况处理
		if (nums == null || nums.length == 0 || queries == null || queries.length == 0) {
			return new int[0];
		}

		int m = nums.length;
		int queryCount = queries.length;
		int[] result = new int[queryCount];

		// 对每个查询进行处理
		for (int i = 0; i < queryCount; i++) {
			int k = queries[i][0];
			int trim = queries[i][1];

			// 提取原始下标
			int[] indices = new int[m];
			for (int j = 0; j < m; j++) {
				indices[j] = j;
			}

			// 进行基数排序
			int len = nums[0].length();
			int startPos = len - trim;
			int[] temp = new int[m];
			int[] count = new int[10];

			// 从最低位到最高位进行排序
			for (int pos = len - 1; pos >= startPos; pos--) {
				// 清空计数数组
				Arrays.fill(count, 0);

				// 统计当前位的数字出现次数
				for (int j = 0; j < m; j++) {
					int digit = nums[indices[j]].charAt(pos) - '0';
					count[digit]++;
				}

				// 计算前缀和
				for (int j = 1; j < 10; j++) {
					count[j] += count[j - 1];
				}

				// 从后向前放置元素，保证稳定性
				for (int j = m - 1; j >= 0; j--) {
					int digit = nums[indices[j]].charAt(pos) - '0';
					temp[--count[digit]] = indices[j];
				}

				// 复制回原数组
				System.arraycopy(temp, 0, indices, 0, m);
			}

			// 保存第k小的元素下标（注意下标从0开始）
			result[i] = indices[k - 1];
		}

		return result;
	}

	/**
	 * 相关题目扩展（全平台覆盖）：
	 * 
	 * 1. LeetCode 912. 排序数组
	 *    链接：https://leetcode.cn/problems/sort-an-array/
	 *    描述：给你一个整数数组 nums，请你将该数组升序排列。
	 *    解法：可以使用基数排序，注意处理负数
	 *    时间复杂度：O(d*(n+k))，空间复杂度：O(n+k)
	 *    
	 * 2. LeetCode 164. 最大间距
	 *    链接：https://leetcode.cn/problems/maximum-gap/
	 *    描述：给定一个无序的数组 nums，返回数组在排序之后，相邻元素之间最大的差值。
	 *    要求：必须编写一个在「线性时间」内运行并使用「线性额外空间」的算法。
	 *    解法：基数排序可以在O(n)时间内完成排序，然后遍历找出最大间距
	 *    为什么最优：基于比较的排序无法达到低于O(nlogn)的时间复杂度
	 *    
	 * 3. LeetCode 2343. 裁剪数字后查询第K小的数字
	 *    链接：https://leetcode.cn/problems/query-kth-smallest-trimmed-number/
	 *    描述：裁剪数字后查询第K小的数字
	 *    解法：使用基数排序对裁剪后的数字进行高效排序
	 * 
	 * 4. 洛谷 P1177 【模板】排序
	 *    链接：https://www.luogu.com.cn/problem/P1177
	 *    描述：将读入的N个数从小到大排序后输出。
	 *    解法：基数排序是此题的高效解法之一，特别适合大规模整数数据
	 * 
	 * 5. 计蒜客 - 整数排序
	 *    链接：https://nanti.jisuanke.com/t/40256
	 *    描述：给定一个包含N个整数的数组，将它们按升序排列后输出。
	 *    解法：基数排序可以在O(d*(n+k))时间内完成排序，对于大规模数据效率高
	 * 
	 * 6. HackerRank - Counting Sort 3
	 *    链接：https://www.hackerrank.com/challenges/countingsort3/problem
	 *    描述：使用计数排序的变种解决统计排序问题
	 *    解法：基数排序的基础是计数排序，可以灵活应用于此类问题
	 * 
	 * 7. Codeforces - Sort the Array
	 *    链接：https://codeforces.com/problemset/problem/451/B
	 *    描述：判断是否可以通过反转一个子数组使得整个数组有序
	 *    解法：使用基数排序进行排序，然后比较确定是否满足条件
	 * 
	 * 8. 牛客 - 数组排序
	 *    链接：https://www.nowcoder.com/practice/2baf799ea0594abd974d37139de27896
	 *    描述：对数组进行排序并输出
	 *    解法：基数排序是高效解法之一，特别适合整数数组
	 * 
	 * 9. HDU 1051. Wooden Sticks
	 *    链接：http://acm.hdu.edu.cn/showproblem.php?pid=1051
	 *    描述：贪心问题，需要先对木棍进行排序
	 *    解法：使用基数排序可以高效排序，然后应用贪心策略
	 * 
	 * 10. POJ 3664. Election Time
	 *     链接：http://poj.org/problem?id=3664
	 *     描述：选举问题，涉及对投票结果的排序
	 *     解法：基数排序可以高效处理大量整数排序，适用于统计类问题
	 * 
	 * 11. UVa 11462. Age Sort
	 *     链接：https://onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=2457
	 *     描述：对年龄进行排序，数据量很大
	 *     解法：基数排序非常适合处理大规模整数数据，时间复杂度接近线性
	 * 
	 * 12. USACO 2018 December Platinum - Sort It Out
	 *     题目类型：最长递增子序列问题结合基数排序优化
	 *     解法：使用O(N*logN)的LIS算法，结合基数排序进行优化
	 * 
	 * 13. USACO 2018 Open Gold - OutOf Sorts
	 *     题目类型：模拟优化问题，涉及排序算法分析
	 *     解法：分析冒泡排序的优化版本，使用基数排序验证结果
	 * 
	 * 14. SPOJ - MSORT
	 *     链接：https://www.spoj.com/problems/MSORT/
	 *     描述：高效排序大数据
	 *     解法：基数排序是处理大规模数据的理想选择
	 * 
	 * 15. CodeChef - MAX_DIFF
	 *     链接：https://www.codechef.com/problems/MAX_DIFF
	 *     描述：排序后计算最大差值
	 *     解法：使用基数排序高效排序，然后计算差值
	 */

	/**
	 * 基数排序算法优化技巧
	 * 
	 * 1. 基数选择优化
	 *    - 选择合适的基数（如256或1024）可以减少排序轮数
	 *    - 对于大多数场景，BASE=10是平衡的选择
	 *    - 使用2的幂作为基数可以利用位运算提高效率（例如：num >> 8 & 0xFF 替代 num / 256 % 256）
	 *    - 对于GPU并行处理，可以选择更大的基数以提高并行度
	 * 
	 * 2. 内存使用优化
	 *    - 可以复用辅助数组以减少内存分配开销
	 *    - 对于特定场景，可以使用原地基数排序
	 *    - 使用缓冲区交换技术避免重复复制
	 *    - 对于大规模数据，可以采用外部排序思想，分批处理
	 * 
	 * 3. 性能优化
	 *    - 对于已经排序的位，可以提前终止排序过程
	 *    - 使用并行计算处理不同的位（多线程或GPU加速）
	 *    - 预分配内存避免动态扩容
	 *    - 使用SIMD指令集优化数据并行处理
	 *    - 缓存优化：按照数据局部性原则重新组织数据访问模式
	 * 
	 * 4. 特殊数据处理
	 *    - 对于稀疏数据，可以先进行压缩
	 *    - 对于大量重复数据，可以先进行去重
	 *    - 对于极长的数字，可以使用分段处理
	 *    - 对于不同范围的数据，可以采用混合排序策略
	 * 
	 * 5. 负数处理优化
	 *    - 可以使用符号位分离的方式处理负数
	 *    - 对于有符号整数，可以使用补码表示直接处理
	 *    - 当数据范围对称时，可以使用偏移到无符号范围的方法
	 * 
	 * 6. 代码优化
	 *    - 减少方法调用，内联关键操作
	 *    - 使用更高效的数据结构
	 *    - 减少循环内的条件判断
	 *    - 利用编译器优化（如循环展开）
	 *    - 使用位运算替代乘除法运算（如offset *= BASE 可以写成 offset <<= log2(BASE)）
	 */

	/**
	 * 工程化考量
	 * 
	 * 1. 异常处理
	 *    - 对空数组、null输入等边界情况进行检查
	 *    - 对于可能的整数溢出，使用long类型进行中间计算
	 *    - 添加输入验证，确保数据合法性
	 *    - 提供明确的错误信息和异常抛出
	 *    - 处理内存不足的情况，提供优雅的降级策略
	 * 
	 * 2. 线程安全
	 *    - 当前实现不是线程安全的，在多线程环境中需要额外的同步机制
	 *    - 可以通过创建独立的工作空间来实现线程安全
	 *    - 考虑使用ThreadLocal存储线程本地的辅助数组
	 *    - 设计并行版本的基数排序，提高多核CPU利用率
	 * 
	 * 3. 可扩展性
	 *    - 设计可插拔的基数选择机制
	 *    - 支持自定义的数字提取策略
	 *    - 允许用户配置排序参数（基数、内存限制等）
	 *    - 设计通用接口，支持不同类型的输入数据
	 *    - 提供扩展点，允许用户自定义排序行为
	 * 
	 * 4. 性能监控
	 *    - 添加性能计数器，监控排序时间和资源使用
	 *    - 实现自适应参数调整，根据数据特性自动选择最佳基数
	 *    - 提供性能分析工具，找出瓶颈
	 *    - 设计基准测试套件，定期验证性能
	 * 
	 * 5. 单元测试
	 *    - 编写全面的测试用例，覆盖各种边界情况
	 *    - 测试不同数据分布下的性能表现
	 *    - 验证排序的正确性和稳定性
	 *    - 进行压力测试，验证在极限情况下的行为
	 *    - 实现回归测试，确保代码修改不破坏现有功能
	 * 
	 * 6. 文档和注释
	 *    - 提供详细的API文档
	 *    - 添加使用示例和最佳实践指南
	 *    - 记录算法的时间和空间复杂度
	 *    - 解释实现细节和优化策略
	 *    - 提供常见问题解答和故障排除指南
	 * 
	 * 7. 代码质量
	 *    - 遵循编码规范，提高可读性
	 *    - 使用有意义的变量和方法名
	 *    - 模块化设计，提高可维护性
	 *    - 避免代码重复，抽取通用功能
	 *    - 定期重构，保持代码简洁
	 */

	/**
	 * 调试技巧
	 * 
	 * 1. 中间结果验证
	 *    - 在每轮排序后打印数组内容，检查排序是否按预期进行
	 *    - 使用断言验证关键步骤的正确性
	 *    - 打印计数数组和前缀和，确保统计正确
	 * 
	 * 2. 边界测试
	 *    - 测试空数组、单元素数组、全相同元素数组等边界情况
	 *    - 测试包含负数、极大值、极小值的数组
	 *    - 测试数组长度为最大值限制的情况
	 *    - 测试极端数据分布（完全有序、完全逆序、交替大小等）
	 * 
	 * 3. 性能分析
	 *    - 使用性能分析工具找出瓶颈
	 *    - 对比不同基数下的性能差异
	 *    - 分析大数据量下的内存使用情况
	 *    - 监控CPU和内存使用，识别资源瓶颈
	 * 
	 * 4. 错误排查
	 *    - 检查数组越界错误
	 *    - 验证负数处理的正确性
	 *    - 确认排序稳定性是否得到保证
	 *    - 使用二分法定位问题所在的代码段
	 *    - 对于大规模数据，可以使用小样本进行调试
	 * 
	 * 5. 日志记录
	 *    - 在关键操作点添加日志记录
	 *    - 记录排序前后的数组状态
	 *    - 记录排序过程中的关键指标（如每轮排序的时间）
	 *    - 使用不同级别的日志，便于问题诊断
	 */

	/**
	 * 与标准库实现的对比
	 * 
	 * 1. Java标准库
	 *    - Arrays.sort() 使用双轴快速排序，平均时间复杂度O(nlogn)
	 *    - 对于基本类型，快速排序不是稳定的
	 *    - 对于对象数组，使用归并排序，是稳定的
	 *    - 在特定场景下，基数排序可以提供更好的性能
	 *    - 标准库的实现考虑了更多工程细节，如自适应策略、稳定性选择等
	 * 
	 * 2. C++标准库
	 *    - std::sort() 通常使用Introsort，混合了快速排序、堆排序和插入排序
	 *    - 时间复杂度为O(nlogn)
	 *    - 不是稳定排序
	 *    - 基数排序在整数排序方面可以有更好的性能
	 *    - C++17引入了std::sort_heap等特定用途的排序算法
	 * 
	 * 3. Python标准库
	 *    - sorted() 和 list.sort() 使用Timsort，是稳定排序
	 *    - 时间复杂度为O(nlogn)
	 *    - 基数排序在特定场景下可以提供线性时间复杂度
	 *    - Python的排序实现高度优化，考虑了各种数据分布和边界情况
	 * 
	 * 4. 工程级优化
	 *    - 标准库实现通常包含更多的优化，如自适应基数选择
	 *    - 标准库更关注内存使用和缓存效率
	 *    - 标准库的实现更健壮，能处理各种边界情况
	 *    - 对于一般应用，标准库的排序函数通常已经足够高效
	 */

	/**
	 * 跨语言实现差异
	 * 
	 * 1. 内存管理
	 *    - Java：自动内存管理，无需手动释放，但可能有GC开销
	 *    - C++：需要手动管理内存，避免内存泄漏，但可以更精确控制
	 *    - Python：自动内存管理，但列表操作有额外开销，性能相对较低
	 * 
	 * 2. 整数类型
	 *    - Java：int为32位，long为64位，类型固定
	 *    - C++：int通常为32位，但可能因平台而异，有更灵活的类型系统
	 *    - Python：整数无固定大小，可以处理任意大整数，但效率较低
	 * 
	 * 3. 数组操作
	 *    - Java：使用System.arraycopy()进行高效数组复制
	 *    - C++：可以使用memcpy()或std::copy()，性能较高
	 *    - Python：列表切片和列表推导式提供简洁的数组操作，但效率较低
	 * 
	 * 4. 性能差异
	 *    - Java：JIT编译可以提供接近原生的性能，特别是在热点代码路径上
	 *    - C++：通常性能最高，特别是对于内存密集型操作，编译器优化更强
	 *    - Python：通常性能较低，但代码简洁易读，开发效率高
	 *    - 不同语言的基数排序实现在大规模数据上性能差异明显
	 * 
	 * 5. 语言特性利用
	 *    - Java：可以利用泛型和接口提高代码复用性
	 *    - C++：可以使用模板和内联函数优化性能
	 *    - Python：可以利用列表推导式和生成器简化代码
	 */

	/**
	 * 极端场景测试
	 * 
	 * 1. 大规模数据
	 *    - 测试排序百万级、千万级元素的性能
	 *    - 分析内存使用情况和GC行为（对于Java和Python）
	 *    - 测试在内存受限环境下的行为
	 *    - 验证大数据量下的稳定性和正确性
	 * 
	 * 2. 特殊数据分布
	 *    - 完全有序的数据：验证算法在有序数据上的行为
	 *    - 完全逆序的数据：测试最坏情况下的性能
	 *    - 所有元素相同的数据：测试计数排序的效率
	 *    - 交替大小的数据：测试排序的稳定性
	 *    - 高斯分布的数据：测试在实际数据分布下的表现
	 * 
	 * 3. 最大/最小值处理
	 *    - 测试包含Integer.MAX_VALUE和Integer.MIN_VALUE的数组
	 *    - 验证偏移量计算不会导致溢出
	 *    - 测试极端值情况下的排序正确性
	 * 
	 * 4. 多线程性能
	 *    - 测试在多线程环境中的性能和线程安全性
	 *    - 分析并行实现的加速比
	 *    - 测试线程争用对性能的影响
	 * 
	 * 5. 长时间运行测试
	 *    - 测试算法在长时间运行后的稳定性
	 *    - 检测内存泄漏（对于需要手动内存管理的语言）
	 *    - 验证资源释放的正确性
	 */

	/**
	 * 面试技巧与常见问题
	 * 
	 * 1. 如何解释基数排序的工作原理？
	 *    - 强调非比较排序的特性
	 *    - 解释LSD和MSD两种方法的区别
	 *    - 说明基数排序的稳定性保证机制
	 *    - 举例说明每一轮排序的过程
	 * 
	 * 2. 如何分析基数排序的时间和空间复杂度？
	 *    - 时间复杂度：O(d*(n+k))，其中d是位数，n是数组长度，k是基数
	 *    - 空间复杂度：O(n+k)
	 *    - 解释为什么在特定情况下可以视为线性时间排序
	 *    - 分析基数选择对时间复杂度的影响
	 * 
	 * 3. 基数排序与其他排序算法的比较
	 *    - 与基于比较的排序算法（快速排序、归并排序等）的区别
	 *    - 与其他非比较排序算法（计数排序、桶排序等）的关系
	 *    - 各自的优缺点和适用场景
	 *    - 为什么基于比较的排序算法的时间复杂度下限是O(nlogn)
	 * 
	 * 4. 如何处理负数？
	 *    - 偏移量方法：将所有数减去最小值转换为非负数
	 *    - 符号位分离：分别处理正数和负数
	 *    - 补码表示：直接处理有符号整数的二进制表示
	 *    - 各种方法的优缺点比较
	 * 
	 * 5. 如何优化基数排序的性能？
	 *    - 选择合适的基数
	 *    - 利用位运算提高效率
	 *    - 并行化处理
	 *    - 内存优化和缓存友好设计
	 *    - 特殊数据分布的优化策略
	 */

	/**
	 * 数学原理与底层逻辑
	 * 
	 * 1. 基数排序的数学基础
	 *    - 数位分解的数学原理
	 *    - 计数排序的正确性证明
	 *    - 稳定性的数学保证
	 *    - 基数选择的理论分析
	 * 
	 * 2. 算法设计的必要性
	 *    - 为什么需要多轮排序
	 *    - 为什么要从低位到高位排序（LSD）
	 *    - 为什么使用计数排序作为子过程
	 *    - 如何保证排序的正确性
	 * 
	 * 3. 性能分析的数学方法
	 *    - 平均情况和最坏情况分析
	 *    - 随机输入模型下的期望性能
	 *    - 不同基数选择的理论比较
	 *    - 渐近分析与实际性能的差异
	 * 
	 * 4. 与信息论的关系
	 *    - 排序问题的信息熵分析
	 *    - 为什么基于比较的排序有O(nlogn)的下限
	 *    - 基数排序如何突破这个下限
	 *    - 不同数据表示方式的信息效率
	 */

	/**
	 * 应用场景与问题迁移
	 * 
	 * 1. 基数排序的典型应用
	 *    - 整数排序
	 *    - 电话号码排序
	 *    - 身份证号排序
	 *    - 字符串排序（对于固定长度字符串）
	 *    - 日期和时间排序
	 * 
	 * 2. 问题迁移技巧
	 *    - 如何将非整数问题转换为可应用基数排序的形式
	 *    - 如何处理变长数据
	 *    - 如何组合其他算法提高效率
	 *    - 如何将基数排序的思想应用到其他问题
	 * 
	 * 3. 与其他领域的联系
	 *    - 数据库系统中的排序优化
	 *    - 文件系统中的索引排序
	 *    - 网络数据包的排序处理
	 *    - 大数据处理中的分布式排序
	 *    - 机器学习中的特征排序和预处理
	 * 
	 * 4. 未来发展方向
	 *    - 量子计算中的排序算法
	 *    - 新兴硬件架构下的排序优化
	 *    - 分布式和并行排序的研究进展
	 *    - 针对特定领域的专用排序算法
	 */

}