#!/usr/bin/env python3
#
# 左偏树（Leftist Tree）模板题1 - Python实现
# 
# 【题目来源】
# 洛谷 P3377 【模板】左偏树（可并堆）
# 题目链接: https://www.luogu.com.cn/problem/P3377
# 
# 【题目大意】
# 依次给定n个非负数字，表示有n个小根堆，每个堆只有一个数
# 实现如下两种操作，操作一共调用m次
# 1 x y : 第x个数字所在的堆和第y个数字所在的堆合并
#         如果两个数字已经在一个堆或者某个数字已经删除，不进行合并
# 2 x   : 打印第x个数字所在堆的最小值，并且在堆里删掉这个最小值
#         如果第x个数字已经被删除，也就是找不到所在的堆，打印-1
#         若有多个最小值，优先删除编号小的
# 
# 【数据范围】
# 1 <= n, m <= 10^5
# 
# 【算法思路】
# 使用左偏树维护多个小根堆，支持快速合并和删除最小值操作
# 结合并查集快速判断两个节点是否在同一个堆中
# 
# 【核心操作】
# 1. 合并操作(merge): O(log n)时间复杂度
# 2. 删除堆顶(pop): O(log n)时间复杂度
# 3. 查找操作(find): 近似O(1)时间复杂度（路径压缩优化）

import sys

class LeftistTree:
    """
    左偏树（可并堆）的Python实现类
    
    【核心功能】
    - 合并两个左偏树：O(log n) 时间复杂度
    - 删除堆顶元素：O(log n) 时间复杂度
    - 查找堆顶元素：O(α(n)) 时间复杂度（近似O(1)）
    - 使用并查集维护多个可合并堆的集合关系
    
    【数据结构特性】
    1. 堆性质：父节点的键值不大于子节点的键值（小根堆）
    2. 左偏性质：任意节点的左子节点的距离不小于右子节点的距离
    3. 距离定义：节点到其子树中最近的外节点的边数
    4. 并查集优化：路径压缩加速查找操作
    
    【类属性说明】
    - num: 存储节点的值
    - left: 存储每个节点的左子节点
    - right: 存储每个节点的右子节点
    - dist: 存储每个节点的距离（到最近外节点的边数）
    - father: 并查集父节点数组，用于快速查找节点所在堆的根
    - MAXN: 最大节点数量
    
    【应用场景】
    - 需要频繁合并多个优先队列的场景
    - 动态维护多个集合的最值
    - 贪心算法中的堆合并优化
    - 树形DP中的子树信息合并
    """
    
    def __init__(self, n):
        """
        初始化左偏树的数据结构
        
        参数：
        - n: 最大节点数，用于预分配数组空间
        
        时间复杂度：O(n)
        空间复杂度：O(n)
        """
        self.MAXN = n + 1
        
        # 预分配数组空间，提高访问效率
        # num[i]: 节点i的值，用于维护堆性质
        self.num = [0] * self.MAXN
        # left[i]: 节点i的左子节点编号，0表示空节点
        self.left = [0] * self.MAXN
        # right[i]: 节点i的右子节点编号，0表示空节点
        self.right = [0] * self.MAXN
        # dist[i]: 节点i到最近外节点的距离，空节点距离为-1
        self.dist = [0] * self.MAXN
        # father[i]: 并查集中节点i的父节点，用于快速查找
        self.father = [0] * self.MAXN
    
    def prepare(self, n):
        """
        初始化每个节点的状态，准备左偏树和并查集
        
        参数：
        - n: 节点数量
        
        时间复杂度：O(n)
        空间复杂度：O(n)
        
        实现细节：
        1. 设置空节点（索引为0）的距离为-1，这是左偏树算法的基本约定
        2. 每个节点初始化为独立的单节点树
        3. 初始化并查集，每个节点的父节点指向自己
        4. 设置初始距离为0（叶子节点的距离）
        """
        # 空节点的距离定义为-1，这是左偏树算法的基础约定
        # 空节点是没有左右子树的节点，即外节点
        self.dist[0] = -1
        
        # 初始化每个节点为独立的单节点树
        for i in range(1, n + 1):
            # 初始时没有左右子节点，设为0（空节点）
            self.left[i] = self.right[i] = 0
            # 叶子节点的距离为0（到自身的距离）
            self.dist[i] = 0
            # 并查集初始化：每个节点的父节点指向自己
            self.father[i] = i
    
    def find(self, i):
        """
        并查集查找函数，带路径压缩优化
        
        参数：
        - i: 要查找的节点编号
        
        返回：
        - 节点i所在堆的根节点编号
        
        时间复杂度：均摊O(α(n))，其中α是阿克曼函数的反函数，实际应用中近似O(1)
        空间复杂度：O(α(n))，递归调用栈的深度
        
        实现原理：
        路径压缩是并查集的关键优化，将查找路径上的每个节点都直接指向根节点，
        使得后续的查找操作几乎变为常数时间。这是一种均摊分析的优化技术。
        """
        # 基础情况：如果节点i的父节点是它自己，说明i是根节点
        if self.father[i] == i:
            return i
        
        # 路径压缩：递归查找根节点，并将当前节点的父节点直接指向根节点
        # 这使得后续对该节点的查找可以一步到位
        self.father[i] = self.find(self.father[i])
        
        # 返回找到的根节点
        return self.father[i]
    
    def merge(self, i, j):
        """
        合并两棵左偏树，这是左偏树最核心的操作
        
        参数：
        - i: 第一棵左偏树的根节点编号
        - j: 第二棵左偏树的根节点编号
        
        返回：
        - 合并后新树的根节点编号
        
        时间复杂度：O(log n)
        空间复杂度：O(log n)，递归调用栈的深度
        
        算法原理：
        1. 递归终止条件：如果其中一棵树为空，直接返回另一棵树
        2. 维护堆性质：确保较小值节点作为根
        3. 递归合并：将另一棵树合并到根节点的右子树
        4. 维护左偏性质：确保左子树距离不小于右子树
        5. 更新距离：根节点的距离等于右子节点距离加1
        6. 更新父指针：确保并查集的正确性
        
        左偏树合并的核心思想是：
        - 始终维护小根堆性质
        - 通过左偏性质保证树高为O(log n)
        - 合并过程中的交换操作保证左偏性质
        """
        # 递归终止条件：如果其中一个树为空，返回另一棵树
        if i == 0 or j == 0:
            return i + j  # 巧妙处理空树情况
        
        # 维护小根堆性质：确保值较小的节点作为根
        # 特别处理相等情况：题目要求值相等时选择编号较小的
        if self.num[i] > self.num[j] or (self.num[i] == self.num[j] and i > j):
            # 交换i和j，保证i的值较小或编号较小
            i, j = j, i
        
        # 核心合并操作：将另一棵树递归合并到当前根的右子树
        # 这是左偏树合并的关键步骤，保证合并后树的平衡性
        self.right[i] = self.merge(self.right[i], j)
        
        # 维护左偏性质：确保左子树的距离不小于右子树
        # 这一步是左偏树能保持O(log n)高度的关键
        if self.dist[self.left[i]] < self.dist[self.right[i]]:
            # 交换左右子节点，维持左偏性质
            self.left[i], self.right[i] = self.right[i], self.left[i]
        
        # 更新当前节点的距离
        # 节点的距离定义为到最近外节点的距离，等于右子节点距离加1
        self.dist[i] = self.dist[self.right[i]] + 1
        
        # 更新子节点的父指针，确保并查集正确维护
        # 这一步对于后续的find操作正确性至关重要
        if self.left[i] != 0:
            self.father[self.left[i]] = i
        if self.right[i] != 0:
            self.father[self.right[i]] = i
        
        # 返回合并后的根节点
        return i
    
    def pop(self, i):
        """
        删除堆顶元素（最小值），并维护左偏树的性质
        
        参数：
        - i: 堆顶节点编号（即当前堆的最小值节点）
        
        返回：
        - 删除堆顶后新树的根节点编号
        
        时间复杂度：O(log n)
        空间复杂度：O(log n)，递归调用栈的深度
        
        实现步骤：
        1. 断开父指针：将左右子节点的父指针设为自身
        2. 合并子树：将左右子树合并成新的树
        3. 更新父指针：将删除节点的父指针指向新的根
        4. 清空节点信息：重置节点的子节点和距离
        
        关键技术点：
        - 并查集路径压缩带来的挑战：需要确保所有可能指向被删除节点的指针都能找到新根
        - 通过让被删除节点的父指针指向新根，解决路径压缩的问题
        """
        # 步骤1：断开左右子节点与父节点的关系
        # 将子节点的父指针设置为自身，使它们成为独立的树
        if self.left[i] != 0:
            self.father[self.left[i]] = self.left[i]
        if self.right[i] != 0:
            self.father[self.right[i]] = self.right[i]
        
        # 步骤2：合并左右子树，形成新的树
        # 步骤3：更新被删除节点的父指针，指向新树的根
        # 这一步非常重要，可以解决并查集路径压缩带来的问题
        # 即使有其他节点通过路径压缩直接指向i，也能找到正确的根
        self.father[i] = self.merge(self.left[i], self.right[i])
        
        # 步骤4：清空被删除节点的信息，防止后续操作错误
        self.left[i] = self.right[i] = self.dist[i] = 0
        
        # 返回新树的根节点
        return self.father[i]

def main():
    """
    主函数：处理输入输出，执行左偏树操作
    
    【功能说明】
    1. 读取输入数据：节点数n和操作数m
    2. 初始化左偏树数据结构
    3. 读取每个节点的初始值
    4. 处理m个操作，包括合并堆和删除堆顶元素
    
    【操作类型】
    - 操作1 x y: 合并节点x和y所在的堆
    - 操作2 x: 删除并输出节点x所在堆的最小值
    
    【性能优化】
    - 递归深度优化：设置较大的递归深度限制，避免Python默认限制导致的栈溢出
    - 输入效率优化：一次性读取所有输入，减少IO次数，提高处理大规模数据的效率
    - 输出效率优化：直接使用print函数输出结果
    
    【边界条件处理】
    - 处理已删除节点的情况
    - 处理合并相同堆的情况
    - 处理空树的情况
    
    时间复杂度：O(n + m * log n)
    空间复杂度：O(n)
    """
    # 优化1：设置较大的递归深度限制
    # Python默认的递归深度限制（约1000）对于大规模数据可能不足
    import sys
    sys.setrecursionlimit(1000000)  # 设置为足够大的值，避免左偏树合并时栈溢出
    
    # 优化2：一次性读取所有输入，减少IO次数
    # 对于大规模数据，这种方式比逐行读取要高效得多
    input = sys.stdin.read
    data = input().split()
    idx = 0  # 指针，用于遍历输入数据
    
    # 步骤1：读取节点数n和操作数m
    n = int(data[idx])
    idx += 1
    m = int(data[idx])
    idx += 1
    
    # 步骤2：创建并初始化左偏树
    # 初始化大小为n的左偏树数据结构
    tree = LeftistTree(n)
    tree.prepare(n)
    
    # 步骤3：读取每个节点的初始值
    for i in range(1, n + 1):
        tree.num[i] = int(data[idx])
        idx += 1
    
    # 步骤4：处理m个操作
    for _ in range(m):
        op = int(data[idx])
        idx += 1
        
        # 操作1：合并两个堆
        if op == 1:
            x = int(data[idx])
            idx += 1
            y = int(data[idx])
            idx += 1
            
            # 边界条件1：检查节点x和y是否有效（未被删除）
            # 如果节点已被删除（值为-1），则不进行合并
            if tree.num[x] != -1 and tree.num[y] != -1:
                # 步骤1.1：找到x和y所在堆的根节点
                l = tree.find(x)
                r = tree.find(y)
                
                # 边界条件2：如果两个节点已经在同一个堆中，不进行合并
                if l != r:
                    # 步骤1.2：合并两个堆，并更新并查集
                    merged_root = tree.merge(l, r)
                    # 确保合并后的根节点的父节点指向自己
                    tree.father[l] = tree.father[r] = merged_root
        
        # 操作2：删除堆顶元素并输出
        elif op == 2:
            x = int(data[idx])
            idx += 1
            
            # 边界条件3：检查节点x是否已被删除
            if tree.num[x] == -1:
                # 如果x已被删除，输出-1
                print(-1)
            else:
                # 步骤2.1：找到x所在堆的根节点（即最小值节点）
                ans = tree.find(x)
                # 步骤2.2：输出根节点的值
                print(tree.num[ans])
                # 步骤2.3：删除根节点（弹出堆顶元素）
                tree.pop(ans)
                # 步骤2.4：标记该节点已被删除
                tree.num[ans] = -1

if __name__ == "__main__":
    main()

'''
算法分析：

时间复杂度：
1. 初始化：O(n)
2. 合并操作：O(log n)
3. 删除堆顶：O(log n)
4. 查找操作：近似O(1)（由于路径压缩）
5. 总体：O(n + m * log n)

空间复杂度：O(n)

算法思路：
1. 使用左偏树维护多个小根堆，支持快速合并和删除最小值
2. 使用并查集快速判断两个节点是否在同一个堆中
3. 对于操作1，先检查节点是否有效，然后通过并查集判断是否在同一堆中，最后合并
4. 对于操作2，先检查节点是否被删除，然后找到堆顶元素并删除

工程化考虑：
1. 输入输出优化：一次性读取所有输入避免多次IO操作
2. 内存管理：使用数组而非动态分配
3. 异常处理：检查节点是否已被删除
4. 代码可读性：添加详细注释，清晰的变量命名

与标准库对比：
1. Python标准库中的heapq不支持高效合并操作
2. 左偏树在合并操作上有明显优势
3. 但在单次操作性能上可能不如优化的二叉堆

调试技巧：
1. 可以添加打印函数验证左偏树结构
2. 注意检查并查集的路径压缩是否正确
3. 特别关注删除操作后节点状态的更新

极端情况：
1. 所有节点值相同
2. 所有操作都是合并操作
3. 所有操作都是删除操作
4. 合并相同堆

语言特性差异：
1. Python中使用//进行整数除法（向下取整）
2. Python中使用list(map(int, line.split()))进行字符串到整数列表的转换
3. Python中使用sys.stdin.read()一次性读取所有输入以提高效率
'''