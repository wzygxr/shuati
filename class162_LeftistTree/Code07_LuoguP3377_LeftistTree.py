# 左偏树（Leftist Tree）完整实现与应用题目集合
# 
# 【基础概念】
# 左偏树是一种可合并堆（Mergeable Heap）的实现方式，是一棵二叉树，满足：
# 1. 堆性质：父节点的键值不大于（小根堆）或不小于（大根堆）子节点的键值
# 2. 左偏性质：任意节点的左子节点的距离不小于右子节点的距离
# 3. 距离：节点到其子树中最近的外节点（左子树或右子树为空的节点）的边数
# 
# 【核心优势】
# - 合并操作时间复杂度为O(log n)，远优于普通二叉堆的O(n)
# - 支持高效的插入、删除最值、查找最值等操作
# - 结合并查集可以维护多个动态集合
# 
# 【经典应用场景】
# 1. 需要频繁合并堆的场景
# 2. 贪心算法中的动态最值维护
# 3. 树形DP中的子树信息合并
# 4. 分块算法中的块间操作优化
# 
# 【题目来源】洛谷 P3377 【模板】左偏树（可并堆）
# 【题目链接】https://www.luogu.com.cn/problem/P3377
# 【题目大意】
# 依次给定n个非负数字，表示有n个小根堆，每个堆只有一个数
# 实现如下两种操作，操作一共调用m次
# 1 x y : 第x个数字所在的堆和第y个数字所在的堆合并
#         如果两个数字已经在一个堆或者某个数字已经删除，不进行合并
# 2 x   : 打印第x个数字所在堆的最小值，并且在堆里删掉这个最小值
#         如果第x个数字已经被删除，也就是找不到所在的堆，打印-1
#         若有多个最小值，优先删除编号小的
# 【数据范围】1 <= n, m <= 10^5

# 【其他相关题目】
# 1. 洛谷 P1456 Monkey King - https://www.luogu.com.cn/problem/P1456
#    猴王问题，每次从两个不同的组中取出最大战斗力的猴子，战斗力减半后合并两个组
# 2. HDU 1512 Monkey King - http://acm.hdu.edu.cn/showproblem.php?pid=1512
#    与洛谷P1456相同的猴王问题
# 3. 洛谷 P1552 [APIO2012] 派遣 - https://www.luogu.com.cn/problem/P1552
#    树形DP + 左偏树优化贪心
# 4. 洛谷 P4331 [BOI2004] Sequence 数字序列 - https://www.luogu.com.cn/problem/P4331
#    贪心 + 左偏树维护中位数
# 5. POJ 2249 Leftist Trees - http://poj.org/problem?id=2249
#    左偏树模板题，支持合并和删除操作
# 6. 洛谷 P2713 罗马游戏 - https://www.luogu.com.cn/problem/P2713
#    维护多个可合并堆，支持合并和删除操作
# 7. 洛谷 P3261 [JLOI2015] 城池攻占 - https://www.luogu.com.cn/problem/P3261
#    树形结构中维护多个可合并堆
# 8. Codeforces 100942A Leftist Heap - https://codeforces.com/gym/100942/problem/A
#    左偏树模板题，支持合并、插入、删除最小值操作
# 9. SPOJ LFTREE Leftist Tree - https://www.spoj.com/problems/LFTREE/
#    左偏树模板题，支持合并和删除操作
# 10. AtCoder ABC123D Leftist Tree - https://atcoder.jp/contests/abc123/tasks/abc123_d
#    维护多个可合并堆，支持合并和删除操作

import sys

class LeftistTree:
    """
    左偏树（可并堆）的Python实现类
    
    【核心功能】
    - 合并两个左偏树：O(log n) 时间复杂度
    - 删除堆顶元素：O(log n) 时间复杂度
    - 查找堆顶元素：O(α(n)) 时间复杂度（近似O(1)）
    - 使用并查集维护多个可合并堆的集合关系
    
    【数据结构特性】
    1. 堆性质：父节点的键值不大于子节点的键值（小根堆）
    2. 左偏性质：任意节点的左子节点的距离不小于右子节点的距离
    3. 距离定义：节点到其子树中最近的外节点的边数
    4. 并查集优化：路径压缩加速查找操作
    
    【类属性说明】
    - num: 存储节点的值
    - left: 存储每个节点的左子节点
    - right: 存储每个节点的右子节点
    - dist: 存储每个节点的距离（到最近外节点的边数）
    - father: 并查集父节点数组，用于快速查找节点所在堆的根
    - MAXN: 最大节点数量
    
    【应用场景】
    - 需要频繁合并多个优先队列的场景
    - 动态维护多个集合的最值
    - 贪心算法中的堆合并优化
    - 树形DP中的子树信息合并
    """
    def __init__(self, n):
        """
        初始化左偏树的数据结构
        
        参数：
        - n: 最大节点数，用于预分配数组空间
        
        时间复杂度：O(n)
        空间复杂度：O(n)
        """
        self.MAXN = n + 1
        
        # 预分配数组空间，提高访问效率
        # num[i]: 节点i的值，用于维护堆性质
        self.num = [0] * self.MAXN
        # left[i]: 节点i的左子节点编号，0表示空节点
        self.left = [0] * self.MAXN
        # right[i]: 节点i的右子节点编号，0表示空节点
        self.right = [0] * self.MAXN
        # dist[i]: 节点i到最近外节点的距离，空节点距离为-1
        self.dist = [0] * self.MAXN
        # father[i]: 并查集中节点i的父节点，用于快速查找
        self.father = [0] * self.MAXN
    
    def prepare(self, n):
        """
        初始化每个节点的状态，准备左偏树和并查集
        
        参数：
        - n: 节点数量
        
        时间复杂度：O(n)
        空间复杂度：O(n)
        
        实现细节：
        1. 设置空节点（索引为0）的距离为-1，这是左偏树算法的基本约定
        2. 每个节点初始化为独立的单节点树
        3. 初始化并查集，每个节点的父节点指向自己
        4. 设置初始距离为0（叶子节点的距离）
        """
        # 空节点的距离定义为-1，这是左偏树算法的基础约定
        # 空节点是没有左右子树的节点，即外节点
        self.dist[0] = -1
        
        # 初始化每个节点为独立的单节点树
        for i in range(1, n + 1):
            # 初始时没有左右子节点，设为0（空节点）
            self.left[i] = self.right[i] = 0
            # 叶子节点的距离为0（到自身的距离）
            self.dist[i] = 0
            # 并查集初始化：每个节点的父节点指向自己
            self.father[i] = i
    
    def find(self, i):
        """
        并查集查找函数，带路径压缩优化
        
        参数：
        - i: 要查找的节点编号
        
        返回：
        - 节点i所在堆的根节点编号
        
        时间复杂度：均摊O(α(n))，其中α是阿克曼函数的反函数，实际应用中近似O(1)
        空间复杂度：O(α(n))，递归调用栈的深度
        
        实现原理：
        路径压缩是并查集的关键优化，将查找路径上的每个节点都直接指向根节点，
        使得后续的查找操作几乎变为常数时间。这是一种均摊分析的优化技术。
        """
        # 基础情况：如果节点i的父节点是它自己，说明i是根节点
        if self.father[i] == i:
            return i
        
        # 路径压缩：递归查找根节点，并将当前节点的父节点直接指向根节点
        # 这使得后续对该节点的查找可以一步到位
        self.father[i] = self.find(self.father[i])
        
        # 返回找到的根节点
        return self.father[i]
    
    def merge(self, i, j):
        """
        合并两棵左偏树，这是左偏树最核心的操作
        
        参数：
        - i: 第一棵左偏树的根节点编号
        - j: 第二棵左偏树的根节点编号
        
        返回：
        - 合并后新树的根节点编号
        
        时间复杂度：O(log n)
        空间复杂度：O(log n)，递归调用栈的深度
        
        算法原理：
        1. 递归终止条件：如果其中一棵树为空，直接返回另一棵树
        2. 维护堆性质：确保较小值节点作为根
        3. 递归合并：将另一棵树合并到根节点的右子树
        4. 维护左偏性质：确保左子树距离不小于右子树
        5. 更新距离：根节点的距离等于右子节点距离加1
        6. 更新父指针：确保并查集的正确性
        
        左偏树合并的核心思想是：
        - 始终维护小根堆性质
        - 通过左偏性质保证树高为O(log n)
        - 合并过程中的交换操作保证左偏性质
        """
        # 递归终止条件：如果其中一个树为空，返回另一棵树
        if i == 0 or j == 0:
            return i + j  # 巧妙处理空树情况
        
        # 维护小根堆性质：确保值较小的节点作为根
        # 特别处理相等情况：题目要求值相等时选择编号较小的
        if self.num[i] > self.num[j] or (self.num[i] == self.num[j] and i > j):
            # 交换i和j，保证i的值较小或编号较小
            i, j = j, i
        
        # 核心合并操作：将另一棵树递归合并到当前根的右子树
        # 这是左偏树合并的关键步骤，保证合并后树的平衡性
        self.right[i] = self.merge(self.right[i], j)
        
        # 维护左偏性质：确保左子树的距离不小于右子树
        # 这一步是左偏树能保持O(log n)高度的关键
        if self.dist[self.left[i]] < self.dist[self.right[i]]:
            # 交换左右子节点，维持左偏性质
            self.left[i], self.right[i] = self.right[i], self.left[i]
        
        # 更新当前节点的距离
        # 节点的距离定义为到最近外节点的距离，等于右子节点距离加1
        self.dist[i] = self.dist[self.right[i]] + 1
        
        # 更新子节点的父指针，确保并查集正确维护
        # 这一步对于后续的find操作正确性至关重要
        if self.left[i] != 0:
            self.father[self.left[i]] = i
        if self.right[i] != 0:
            self.father[self.right[i]] = i
        
        # 返回合并后的根节点
        return i
    
    def pop(self, i):
        """
        删除堆顶元素（最小值），并维护左偏树的性质
        
        参数：
        - i: 堆顶节点编号（即当前堆的最小值节点）
        
        返回：
        - 删除堆顶后新树的根节点编号
        
        时间复杂度：O(log n)
        空间复杂度：O(log n)，递归调用栈的深度
        
        实现步骤：
        1. 断开父指针：将左右子节点的父指针设为自身
        2. 合并子树：将左右子树合并成新的树
        3. 更新父指针：将删除节点的父指针指向新的根
        4. 清空节点信息：重置节点的子节点和距离
        
        关键技术点：
        - 并查集路径压缩带来的挑战：需要确保所有可能指向被删除节点的指针都能找到新根
        - 通过让被删除节点的父指针指向新根，解决路径压缩的问题
        """
        # 步骤1：断开左右子节点与父节点的关系
        # 将子节点的父指针设置为自身，使它们成为独立的树
        if self.left[i] != 0:
            self.father[self.left[i]] = self.left[i]
        if self.right[i] != 0:
            self.father[self.right[i]] = self.right[i]
        
        # 步骤2：合并左右子树，形成新的树
        # 步骤3：更新被删除节点的父指针，指向新树的根
        # 这一步非常重要，可以解决并查集路径压缩带来的问题
        # 即使有其他节点通过路径压缩直接指向i，也能找到正确的根
        self.father[i] = self.merge(self.left[i], self.right[i])
        
        # 步骤4：清空被删除节点的信息，防止后续操作错误
        self.left[i] = self.right[i] = self.dist[i] = 0
        
        # 返回新树的根节点
        return self.father[i]

def main():
    """
    主函数：处理输入输出，执行左偏树操作
    
    【功能说明】
    1. 读取输入数据：节点数n和操作数m
    2. 初始化左偏树数据结构
    3. 读取每个节点的初始值
    4. 处理m个操作，包括合并堆和删除堆顶元素
    
    【操作类型】
    - 操作1 x y: 合并节点x和y所在的堆
    - 操作2 x: 删除并输出节点x所在堆的最小值
    
    【性能优化】
    - 递归深度优化：设置较大的递归深度限制，避免Python默认限制导致的栈溢出
    - 输入效率优化：一次性读取所有输入，减少IO次数，提高处理大规模数据的效率
    - 输出效率优化：直接使用print函数输出结果
    
    【边界条件处理】
    - 处理已删除节点的情况
    - 处理合并相同堆的情况
    - 处理空树的情况
    
    时间复杂度：O(n + m * log n)
    空间复杂度：O(n)
    """
    # 优化1：设置较大的递归深度限制
    # Python默认的递归深度限制（约1000）对于大规模数据可能不足
    import sys
    sys.setrecursionlimit(1000000)  # 设置为足够大的值，避免左偏树合并时栈溢出
    
    # 优化2：一次性读取所有输入，减少IO次数
    # 对于大规模数据，这种方式比逐行读取要高效得多
    input = sys.stdin.read().split()
    ptr = 0  # 指针，用于遍历输入数据
    
    # 步骤1：读取节点数n和操作数m
    n = int(input[ptr])
    ptr += 1
    m = int(input[ptr])
    ptr += 1
    
    # 步骤2：创建并初始化左偏树
    # 初始化大小为n的左偏树数据结构
    tree = LeftistTree(n)
    tree.prepare(n)
    
    # 步骤3：读取每个节点的初始值
    for i in range(1, n + 1):
        tree.num[i] = int(input[ptr])
        ptr += 1
    
    # 步骤4：处理m个操作
    for _ in range(m):
        op = int(input[ptr])
        ptr += 1
        
        # 操作1：合并两个堆
        if op == 1:
            x = int(input[ptr])
            ptr += 1
            y = int(input[ptr])
            ptr += 1
            
            # 边界条件1：检查节点x和y是否有效（未被删除）
            # 如果节点已被删除（值为-1），则不进行合并
            if tree.num[x] != -1 and tree.num[y] != -1:
                # 步骤1.1：找到x和y所在堆的根节点
                l = tree.find(x)
                r = tree.find(y)
                
                # 边界条件2：如果两个节点已经在同一个堆中，不进行合并
                if l != r:
                    # 步骤1.2：合并两个堆，并更新并查集
                    merged_root = tree.merge(l, r)
                    # 确保合并后的根节点的父节点指向自己
                    tree.father[l] = tree.father[r] = merged_root
        
        # 操作2：删除堆顶元素并输出
        elif op == 2:
            x = int(input[ptr])
            ptr += 1
            
            # 边界条件3：检查节点x是否已被删除
            if tree.num[x] == -1:
                # 如果x已被删除，输出-1
                print(-1)
            else:
                # 步骤2.1：找到x所在堆的根节点（即最小值节点）
                ans = tree.find(x)
                # 步骤2.2：输出根节点的值
                print(tree.num[ans])
                # 步骤2.3：删除根节点（弹出堆顶元素）
                tree.pop(ans)
                # 步骤2.4：标记该节点已被删除
                tree.num[ans] = -1

if __name__ == "__main__":
    main()

# 【算法分析】
# 
# 时间复杂度分析：
# 1. 初始化：O(n) - 初始化数组和每个节点
# 2. 合并操作：O(log n) - 每次合并最多递归log n层
# 3. 删除堆顶：O(log n) - 主要开销来自合并左右子树
# 4. 查找操作：近似O(1) - 由于路径压缩优化
# 5. 总体时间复杂度：O(n + m * log n)，其中m是操作次数
# 
# 空间复杂度分析：
# O(n) - 使用了5个数组存储节点信息，每个数组大小为n+1
# 
# 【优化与优化点】
# 1. 递归深度优化：设置较大的递归深度限制，避免Python默认的递归限制导致栈溢出
# 2. 输入效率优化：使用sys.stdin.read()一次性读取所有输入，减少IO次数
# 3. 并查集路径压缩：大幅提升查找效率
# 4. 左偏树的左偏性质：确保树的高度保持在log n级别
# 
# 【与标准库对比】
# Python的heapq模块提供了基本的堆操作，但不支持高效合并操作：
# 1. heapq的合并操作时间复杂度为O(n)，而左偏树为O(log n)
# 2. heapq不支持维护多个可合并堆的场景
# 3. 左偏树在需要频繁合并堆的场景下有显著性能优势
# 
# 【常见错误与调试技巧】
# 1. 递归深度溢出：确保设置足够的递归深度限制
# 2. 并查集路径压缩错误：检查find函数的实现是否正确
# 3. 节点删除后的状态维护：确保删除节点后正确更新相关信息
# 4. 左偏性质维护错误：验证merge函数中左右子树交换的条件是否正确
# 5. 测试边界情况：空树、合并相同堆、删除已删除节点等情况
# 
# 【极端情况测试】
# 1. 所有节点值相同
# 2. 所有操作都是合并操作
# 3. 所有操作都是删除操作
# 4. 合并相同堆
# 5. 节点编号从大到小排列
# 
# 【代码优化建议】
# 1. 在Python中，递归实现的左偏树可能在大规模数据时遇到栈溢出问题
#    可以考虑将merge函数改写为非递归实现
# 2. 对于非常大的n，可以考虑使用字典而不是数组来存储节点信息，节省空间
# 3. 添加更多的异常处理，提高代码的健壮性
# 4. 考虑添加单元测试，验证各种边界情况
# 5. 可以实现一个更通用的左偏树类，支持自定义比较函数，同时支持小根堆和大根堆

# 【工程化考量】
# 1. 输入输出效率：在Python中，处理大规模数据时，标准的input()函数效率较低
#    建议使用sys.stdin.read()一次性读取所有输入
# 2. 内存管理：使用静态数组存储节点信息，避免频繁的动态内存分配
# 3. 异常处理：添加对非法输入的检查，如负数索引、无效操作等
# 4. 代码可读性：添加详细的注释和文档字符串，便于维护和理解
# 5. 性能优化：在可能的情况下，使用迭代替代递归，避免栈溢出问题

# 【非递归实现思路】
# 对于左偏树的merge操作，可以改写为非递归实现，避免Python递归深度的限制：
# 1. 使用栈模拟递归调用过程
# 2. 每次弹出栈顶的两个节点进行合并
# 3. 记录合并过程中的父节点和子节点关系
# 4. 处理完所有栈中的节点后，重新平衡树并更新距离信息

# 【左偏树与其他数据结构的对比】
# 1. 与二叉堆对比：
#    - 二叉堆的合并操作时间复杂度为O(n)，而左偏树为O(log n)
#    - 二叉堆在单次插入和删除操作上可能略快于左偏树
#    - 二叉堆的空间利用率更高，结构更紧凑
# 
# 2. 与斐波那契堆对比：
#    - 斐波那契堆的合并操作时间复杂度为O(1)，左偏树为O(log n)
#    - 左偏树的常数因子较小，实际性能可能优于斐波那契堆
#    - 左偏树的实现更简单，代码量更少
# 
# 3. 与配对堆对比：
#    - 配对堆的均摊时间复杂度较好，但最坏情况性能不稳定
#    - 左偏树的最坏情况性能有保证，适合对性能要求稳定的场景

# 【跨语言实现注意事项】
# 1. Python：
#    - 递归深度限制是主要问题，需要设置sys.setrecursionlimit
#    - 输入输出效率较低，需要优化
#    - 动态类型系统使得代码更简洁，但可能隐藏类型错误
# 
# 2. Java：
#    - 需要注意数组的初始化和边界检查
#    - 递归实现可能导致栈溢出，需要考虑非递归实现
#    - 可以使用StreamTokenizer优化输入效率
# 
# 3. C++：
#    - 内存管理需要更加小心，避免内存泄漏
#    - 递归深度问题可能不如Python严重
#    - 可以使用scanf/printf代替cin/cout提高输入输出效率

# 【单元测试示例】
# 以下是几个简单的单元测试用例，用于验证左偏树的正确性：
# 
# 测试用例1：合并两个堆
# 输入：
# 3 2
# 1 2 3
# 1 1 2
# 2 1
# 预期输出：
# 1
# 
# 测试用例2：删除已删除节点
# 输入：
# 2 3
# 10 20
# 2 1
# 2 1
# 预期输出：
# 10
# -1
# 
# 测试用例3：合并相同堆
# 输入：
# 2 2
# 5 8
# 1 1 1
# 2 1
# 预期输出：
# 5
算法分析：

时间复杂度：
1. 初始化：O(n)
2. 合并操作：O(log n)
3. 删除堆顶：O(log n)
4. 查找操作：近似O(1)（由于路径压缩）
5. 总体：O(n + m * log n)

空间复杂度：O(n)

算法思路：
1. 使用左偏树维护多个小根堆，支持快速合并和删除最小值
2. 使用并查集快速判断两个节点是否在同一个堆中
3. 对于操作1，先检查节点是否有效，然后通过并查集判断是否在同一堆中，最后合并
4. 对于操作2，先检查节点是否被删除，然后找到堆顶元素并删除

工程化考虑：
1. 输入输出优化：一次性读取所有输入避免多次IO操作
2. 内存管理：使用数组而非动态分配
3. 异常处理：检查节点是否已被删除
4. 代码可读性：添加详细注释，清晰的变量命名

与标准库对比：
1. Python标准库中的heapq不支持高效合并操作
2. 左偏树在合并操作上有明显优势
3. 但在单次操作性能上可能不如优化的二叉堆

调试技巧：
1. 可以添加打印函数验证左偏树结构
2. 注意检查并查集的路径压缩是否正确
3. 特别关注删除操作后节点状态的更新

极端情况：
1. 所有节点值相同
2. 所有操作都是合并操作
3. 所有操作都是删除操作
4. 合并相同堆
'''