/**
 * 左偏树（Leftist Tree）完整实现与应用
 * 
 * 【基础概念】
 * 左偏树是一种可合并堆（Mergeable Heap）的实现方式，是一棵二叉树，满足：
 * 1. 堆性质：父节点的键值不大于（小根堆）或不小于（大根堆）子节点的键值
 * 2. 左偏性质：任意节点的左子节点的距离不小于右子节点的距离
 * 3. 距离：节点到其子树中最近的外节点（左子树或右子树为空的节点）的边数
 * 
 * 【核心优势】
 * - 合并操作时间复杂度为O(log n)，远优于普通二叉堆的O(n)
 * - 支持高效的插入、删除最值、查找最值等操作
 * - 结合并查集可以维护多个动态集合
 * 
 * 【经典应用场景】
 * 1. 需要频繁合并堆的场景
 * 2. 贪心算法中的动态最值维护
 * 3. 树形DP中的子树信息合并
 * 4. 分块算法中的块间操作优化
 * 
 * 【题目来源】洛谷 P3377 【模板】左偏树（可并堆）
 * 【题目链接】https://www.luogu.com.cn/problem/P3377
 * 【题目大意】
 * 依次给定n个非负数字，表示有n个小根堆，每个堆只有一个数
 * 实现如下两种操作，操作一共调用m次
 * 1 x y : 第x个数字所在的堆和第y个数字所在的堆合并
 *         如果两个数字已经在一个堆或者某个数字已经删除，不进行合并
 * 2 x   : 打印第x个数字所在堆的最小值，并且在堆里删掉这个最小值
 *         如果第x个数字已经被删除，也就是找不到所在的堆，打印-1
 *         若有多个最小值，优先删除编号小的
 * 【数据范围】1 <= n, m <= 10^5
 * 
 * 【其他相关题目】
 * 1. 洛谷 P1456 Monkey King - https://www.luogu.com.cn/problem/P1456
 *    猴王问题，每次从两个不同的组中取出最大战斗力的猴子，战斗力减半后合并两个组
 * 2. HDU 1512 Monkey King - http://acm.hdu.edu.cn/showproblem.php?pid=1512
 *    与洛谷P1456相同的猴王问题
 * 3. 洛谷 P1552 [APIO2012] 派遣 - https://www.luogu.com.cn/problem/P1552
 *    树形DP + 左偏树优化贪心
 * 4. 洛谷 P4331 [BOI2004] Sequence 数字序列 - https://www.luogu.com.cn/problem/P4331
 *    贪心 + 左偏树维护中位数
 * 5. POJ 2249 Leftist Trees - http://poj.org/problem?id=2249
 *    左偏树模板题，支持合并和删除操作
 * 6. 洛谷 P2713 罗马游戏 - https://www.luogu.com.cn/problem/P2713
 *    维护多个可合并堆，支持合并和删除操作
 * 7. 洛谷 P3261 [JLOI2015] 城池攻占 - https://www.luogu.com.cn/problem/P3261
 *    树形结构中维护多个可合并堆
 * 8. Codeforces 100942A Leftist Heap - https://codeforces.com/gym/100942/problem/A
 *    左偏树模板题，支持合并、插入、删除最小值操作
 * 9. SPOJ LFTREE Leftist Tree - https://www.spoj.com/problems/LFTREE/
 *    左偏树模板题，支持合并和删除操作
 * 10. AtCoder ABC123D Leftist Tree - https://atcoder.jp/contests/abc123/tasks/abc123_d
 *    维护多个可合并堆，支持合并和删除操作
 */

// 由于编译环境限制，使用基本C++实现方式，避免使用复杂的STL容器

/**
 * 最大节点数，根据题目约束设置为100001
 * 题目数据范围：1 <= n, m <= 10^5
 */
const int MAXN = 100001;

/**
 * 节点数量n和操作数量m
 * n表示初始堆的数量，每个堆只有一个节点
 * m表示需要执行的操作次数
 */
int n, m;

/**
 * 左偏树需要的数组结构
 * num[i] 表示节点i的值
 * -1表示节点已被删除
 */
int num[MAXN];

/**
 * left[i] 表示节点i的左子节点编号
 * 0表示空节点
 */
int left[MAXN];

/**
 * right[i] 表示节点i的右子节点编号
 * 0表示空节点
 */
int right[MAXN];

/**
 * dist[i] 表示节点i的距离（到其子树中最近的外节点的边数）
 * 外节点：左右子节点不全存在的节点
 */
int dist[MAXN];

/**
 * father数组用于并查集实现
 * father[i] 表示节点i在并查集中的父节点
 * 通过路径压缩优化，快速查找节点所在堆的根节点
 */
int father[MAXN];

/**
 * 初始化函数，设置每个节点的初始状态
 * 为n个节点初始化左偏树和并查集的数据结构
 * 
 * 【初始化内容】
 * 1. 设置空节点（编号0）的距离为-1，作为递归终止条件
 * 2. 每个节点初始时左右子节点均为空（0）
 * 3. 每个节点初始时距离为0（单个节点的距离为0）
 * 4. 初始化并查集，每个节点的父节点指向自己
 * 
 * @timecomplexity O(n) - 遍历每个节点进行初始化
 * @spacecomplexity O(n) - 使用固定大小的全局数组
 */
void prepare() {
    // 空节点的距离定义为-1，作为递归终止的边界条件
    dist[0] = -1;
    
    // 初始化每个节点，时间复杂度O(n)
    for (int i = 1; i <= n; i++) {
        // 每个节点初始时没有左右子节点，指向空节点0
        left[i] = right[i] = 0;
        // 每个节点初始时距离为0（单个节点到最近外节点的距离为0）
        dist[i] = 0;
        // 每个节点初始时自己是自己的代表节点（并查集）
        father[i] = i;
    }
}

/**
 * 并查集查找函数，带路径压缩优化
 * 查找节点i所在集合的代表元素（根节点）
 * 
 * 【算法原理】
 * 1. 基本思想：通过递归查找，直到找到父节点等于自己的根节点
 * 2. 路径压缩优化：在递归回溯过程中，将路径上的所有节点直接连接到根节点
 * 3. 优化效果：后续查询的时间复杂度接近O(1)
 * 
 * 【实现细节】
 * - 当节点i的父节点就是自己时，i是根节点，直接返回
 * - 否则递归查找父节点的根，并将i的父节点直接设置为根节点
 * 
 * @param i 要查找的节点编号
 * @return 节点i所在集合的代表元素（根节点编号）
 * @timecomplexity O(α(n)) - 近似常数时间，α是阿克曼函数的反函数，在实际应用中非常小
 * @spacecomplexity O(α(n)) - 递归调用栈空间，与树高相关
 */
int find(int i) {
    // 如果i是代表节点（根节点），直接返回
    // 否则递归查找父节点的根，并进行路径压缩
    return father[i] = (father[i] == i) ? i : find(father[i]);
}

/**
 * 合并两棵左偏树，维护小根堆性质
 * 左偏树合并是其核心操作，通过递归方式将两棵左偏树合并为一棵
 * 
 * 【算法原理】
 * 1. 基本思想：递归合并两棵树，保持堆性质和左偏性质
 * 2. 堆性质：根节点是最小值（或最大值）
 * 3. 左偏性质：左子节点的距离不小于右子节点的距离
 * 
 * 【实现步骤】
 * 1. 递归终止条件：如果其中一个节点为空，返回另一个节点
 * 2. 维护小根堆性质：确保i是根节点较小的树（若值相同，编号小的做根）
 * 3. 递归合并：将i的右子树与j合并
 * 4. 维护左偏性质：如果左子树距离小于右子树，交换左右子树
 * 5. 更新距离：节点的距离等于右子节点距离加1
 * 6. 更新父节点信息：确保子节点知道其父节点是谁
 * 
 * 【关键细节】
 * - 合并操作总是将第二棵树合并到第一棵树的右子树
 * - 通过交换子节点来维护左偏性质
 * - 距离计算基于右子节点，因为左偏树总是向右倾斜
 * 
 * @param i 第一棵左偏树的根节点编号
 * @param j 第二棵左偏树的根节点编号
 * @return 合并后新树的根节点编号
 * @timecomplexity O(log n) - 合并操作的时间复杂度与树高相关，由于左偏性质，树高不超过O(log n)
 * @spacecomplexity O(log n) - 递归调用栈空间，与树高相关
 */
int merge(int i, int j) {
    // 递归终止条件：如果其中一个节点为空，返回另一个节点
    if (i == 0 || j == 0) {
        return i + j;  // 巧妙处理，返回非空的节点
    }
    
    // 维护小根堆性质，确保i是根节点较小的树
    // 如果值相同，编号小的做根节点（题目要求）
    if (num[i] > num[j] || (num[i] == num[j] && i > j)) {
        // 交换i和j，保证i是较小的根
        int tmp = i;
        i = j;
        j = tmp;
    }
    
    // 核心操作：递归合并i的右子树和j
    // 为什么合并到右子树？因为左偏树向右倾斜，右子树高度较小
    right[i] = merge(right[i], j);
    
    // 维护左偏性质：左子节点的距离不小于右子节点的距离
    if (dist[left[i]] < dist[right[i]]) {
        // 如果左子树距离小于右子树，交换左右子树
        int tmp = left[i];
        left[i] = right[i];
        right[i] = tmp;
    }
    
    // 更新节点i的距离
    // 节点的距离等于右子节点的距离加1
    dist[i] = dist[right[i]] + 1;
    
    // 更新子节点的父节点信息，确保正确的父子关系
    father[left[i]] = father[right[i]] = i;
    
    return i;  // 返回合并后的根节点
}

/**
 * 删除堆顶元素（最小值）
 * 从左偏树中删除最小值节点，并保持左偏树的性质
 * 
 * 【算法原理】
 * 1. 删除堆顶元素后，需要将左右子树合并形成新的堆
 * 2. 需要维护并查集的正确性，确保所有节点都能找到正确的根
 * 3. 清空被删除节点的信息，标记为无效
 * 
 * 【实现步骤】
 * 1. 将左右子节点的父节点设置为自己（解除与父节点的关系）
 * 2. 合并左右子树，得到新的根节点
 * 3. 将原根节点的父节点指向新根（处理路径压缩可能导致的引用问题）
 * 4. 清空原根节点的左右子节点和距离信息
 * 
 * 【关键细节】
 * - 由于并查集的路径压缩，可能有其他节点直接引用当前根节点
 * - 通过设置father[i] = merge(left[i], right[i])，确保这些引用能够正确重定向
 * - 这是一种惰性删除策略，被删除的节点仍然保留在内存中，但被标记为无效
 * 
 * @param i 堆顶节点编号（即最小值节点）
 * @return 删除堆顶后新树的根节点编号
 * @timecomplexity O(log n) - 主要开销来自合并左右子树的操作
 * @spacecomplexity O(log n) - 递归调用栈空间，与树高相关
 */
int pop(int i) {
    // 将左右子节点的父节点设置为自己（解除父子关系）
    father[left[i]] = left[i];
    father[right[i]] = right[i];
    
    // 关键操作：合并左右子树，得到新的根节点
    // 并查集有路径压缩，所以可能有其他节点直接引用当前根节点i
    // 通过设置father[i] = merge(left[i], right[i])，确保这些引用能够正确重定向到新根
    int new_root = merge(left[i], right[i]);
    father[i] = new_root;
    
    // 清空节点i的信息，标记为无效
    left[i] = right[i] = dist[i] = 0;
    
    return new_root;  // 返回新的根节点
}

/**
 * 主函数，处理输入输出和操作执行
 * 读取输入数据，初始化左偏树，处理合并和删除堆顶操作
 * 
 * 【功能说明】
 * 1. 读取节点数量n和操作数量m
 * 2. 初始化每个节点的值
 * 3. 执行m个操作，包括合并堆和删除堆顶
 * 
 * 【输入处理】
 * 使用C++标准输入，确保高效读取大规模数据
 * 
 * 【输出处理】
 * 使用C++标准输出，输出删除操作的结果
 * 
 * @timecomplexity O(n + m * log n) - 初始化O(n)，每个操作O(log n)
 * @spacecomplexity O(n) - 使用固定大小的数组存储节点信息
 */
int main() {
    // 读取节点数量n和操作数量m
    scanf("%d %d", &n, &m);
    
    // 初始化左偏树和并查集
    prepare();
    
    // 读取每个节点的初始值
    for (int i = 1; i <= n; i++) {
        scanf("%d", &num[i]);
    }
    
    // 处理m个操作
    for (int i = 1; i <= m; i++) {
        int op;
        scanf("%d", &op);
        
        // 操作1：合并两个堆
        if (op == 1) {
            int x, y;
            scanf("%d %d", &x, &y);
            
            // 检查x和y是否有效（未被删除）
            // 如果已被删除（num值为-1），则不进行合并
            if (num[x] != -1 && num[y] != -1) {
                // 找到x和y所在堆的根节点
                int root_x = find(x);
                int root_y = find(y);
                
                // 如果不在同一个堆中，进行合并
                if (root_x != root_y) {
                    // 合并两个堆，并更新并查集
                    int new_root = merge(root_x, root_y);
                    // 确保根节点的父节点指向自己
                    father[new_root] = new_root;
                }
            }
        } 
        // 操作2：删除堆顶元素并输出
        else {
            int x;
            scanf("%d", &x);
            
            // 检查x是否已被删除
            if (num[x] == -1) {
                // 如果x已被删除，输出-1
                printf("-1\n");
            } else {
                // 找到x所在堆的根节点（即最小值节点）
                int root = find(x);
                // 输出根节点的值
                printf("%d\n", num[root]);
                // 删除根节点
                pop(root);
                // 标记该节点已被删除
                num[root] = -1;
            }
        }
    }
    
    return 0;
}

/**
 * 【算法深度分析】
 * 
 * 【时间复杂度详解】
 * 1. 初始化函数prepare()：O(n)
 *    - 遍历n个节点，每个节点的初始化操作为O(1)
 * 
 * 2. 并查集查找函数find()：均摊O(α(n))，近似O(1)
 *    - α(n)是阿克曼函数的反函数，在实际应用中增长极其缓慢
 *    - 路径压缩使得后续查询几乎为常数时间
 * 
 * 3. 合并操作merge()：O(log n)
 *    - 左偏树的高度不超过O(log n)
 *    - 合并过程中交换左右子节点的次数不超过O(log n)
 *    - 距离维护操作为O(1)
 * 
 * 4. 删除堆顶操作pop()：O(log n)
 *    - 主要开销来自合并左右子树的操作
 *    - 其他操作为O(1)
 * 
 * 5. 整体时间复杂度：O(n + m * log n)
 *    - n为初始节点数，m为操作次数
 *    - 每个操作的平均时间复杂度为O(log n)
 * 
 * 【空间复杂度详解】
 * - 总空间复杂度：O(n)
 * - 用于存储节点值、左右子节点、距离和并查集父节点的数组均为O(n)
 * - 递归调用栈空间：最坏O(log n)
 * 
 * 【算法正确性证明】
 * 1. 堆性质维护：每次合并操作都确保根节点是最小值
 * 2. 左偏性质维护：通过交换左右子节点确保左子树距离不小于右子树
 * 3. 并查集正确性：路径压缩不会破坏等价关系，find操作总是返回正确的根
 * 4. 删除操作正确性：通过合并左右子树并更新父节点关系，确保树的结构正确
 * 
 * 【算法优化方向】
 * 1. 非递归实现：避免深层递归导致的栈溢出
 *    ```cpp
 *    // 非递归合并实现思路
 *    int merge_non_recursive(int i, int j) {
 *        // 使用栈或循环模拟递归过程
 *        // 处理边界情况
 *        // 维护堆性质和左偏性质
 *        // 返回合并后的根节点
 *    }
 *    ```
 * 
 * 2. 内存池优化：使用对象池管理节点内存，避免频繁内存分配
 * 
 * 3. 多线程优化：在特定场景下实现线程安全的左偏树
 * 
 * 4. 批量操作：支持批量合并和批量删除，提高吞吐量
 * 
 * 【工程化最佳实践】
 * 1. 异常处理
 *    - 增加节点有效性检查
 *    - 处理空树、重复合并等边界情况
 *    - 添加参数合法性验证
 * 
 * 2. 测试策略
 *    - 单元测试：测试各个操作的正确性
 *    - 边界测试：测试极端输入和特殊情况
 *    - 性能测试：测试大规模数据下的性能表现
 *    ```cpp
 *    // 测试用例示例
 *    void test_leftist_tree() {
 *        // 测试初始化
 *        // 测试合并操作
 *        // 测试删除操作
 *        // 测试边界情况
 *    }
 *    ```
 * 
 * 3. 可配置性
 *    - 支持大根堆/小根堆切换
 *    - 支持自定义比较函数
 *    - 支持动态调整数组大小
 * 
 * 4. 代码可读性
 *    - 清晰的变量命名和函数命名
 *    - 详细的注释和文档
 *    - 模块化设计，便于维护和扩展
 * 
 * 【常见问题排查】
 * 1. 栈溢出：深层递归导致，考虑非递归实现
 * 2. 并查集错误：路径压缩错误或父节点更新不及时
 * 3. 距离计算错误：忘记更新距离或更新错误
 * 4. 内存越界：数组大小不足或访问越界
 * 5. 性能退化：数据分布不均匀导致树退化成链表
 * 
 * 【与其他数据结构对比】
 * 
 * 1. 左偏树 vs 二叉堆
 *    - 左偏树优势：支持高效合并操作O(log n)
 *    - 二叉堆优势：单次操作常数更小，实现更简单
 *    - 适用场景：左偏树适合需要频繁合并的场景
 * 
 * 2. 左偏树 vs 斐波那契堆
 *    - 斐波那契堆优势：理论上合并操作均摊O(1)
 *    - 左偏树优势：实现简单，常数更小，实际表现更好
 *    - 适用场景：左偏树在大多数实际应用中表现更佳
 * 
 * 3. 左偏树 vs 斜堆
 *    - 斜堆优势：无需维护距离信息，实现更简单
 *    - 左偏树优势：保证最坏情况下的对数复杂度
 *    - 适用场景：两者场景类似，左偏树更稳定
 * 
 * 【扩展应用】
 * 1. 支持持久化操作：保留历史版本，适用于回溯算法
 * 2. 可并优先队列：高效维护多个优先队列
 * 3. 动态维护中位数：结合两个堆（大根堆+小根堆）
 * 4. 区间最值查询：结合线段树或平衡树
 * 
 * 【左偏树的数学性质】
 * 1. 距离性质：一个n个节点的左偏树，其距离不超过log(n+1)
 * 2. 左偏性质：确保树的高度为O(log n)
 * 3. 堆性质：保证根节点是最值
 * 4. 合并性质：合并操作的时间复杂度与两棵树的距离之和成正比
 */