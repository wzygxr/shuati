#!/usr/bin/env python3
#
# HDU 1512 Monkey King - Python实现
# 
# 【题目来源】
# HDU 1512 Monkey King
# 题目链接: http://acm.hdu.edu.cn/showproblem.php?pid=1512
# 
# 【题目大意】
# 有n只猴子，每只猴子有一个武力值，开始时每只猴子都是一个独立的群体
# 每次有两只猴子要打架，它们会从各自群体中找出武力值最大的猴子进行战斗
# 战斗结束后，两只猴子的武力值各自减半（向下取整），然后两个群体合并
# 如果两只猴子已经在同一个群体中，则输出-1
# 
# 【数据范围】
# 1 <= n <= 10^5
# 0 <= 武力值 <= 10^9
# 
# 【算法思路】
# 使用左偏树维护每个群体，支持快速合并和删除最大值操作
# 结合并查集快速判断两只猴子是否在同一个群体
# 每次战斗时，从两个群体中删除最大武力值的猴子，武力值减半后重新加入
# 然后合并两个群体
# 
# 【核心操作】
# 1. 合并操作(merge): O(log n)时间复杂度
# 2. 删除堆顶(pop): O(log n)时间复杂度
# 3. 查找操作(find): 近似O(1)时间复杂度（路径压缩优化）

import sys

class LeftistTree:
    """
    左偏树（可并堆）的Python实现类，用于解决猴王问题
    
    【核心功能】
    - 合并两个左偏树：O(log n) 时间复杂度
    - 删除堆顶元素：O(log n) 时间复杂度
    - 查找堆顶元素：O(α(n)) 时间复杂度（近似O(1)）
    - 使用并查集维护多个可合并堆的集合关系
    
    【数据结构特性】
    1. 堆性质：父节点的键值不小于子节点的键值（大根堆）
    2. 左偏性质：任意节点的左子节点的距离不小于右子节点的距离
    3. 距离定义：节点到其子树中最近的外节点的边数
    4. 并查集优化：路径压缩加速查找操作
    
    【类属性说明】
    - power: 存储每只猴子的武力值
    - left: 存储每个节点的左子节点
    - right: 存储每个节点的右子节点
    - dist: 存储每个节点的距离（到最近外节点的边数）
    - father: 并查集父节点数组，用于快速查找节点所在群体的根
    - MAXN: 最大节点数量
    
    【应用场景】
    - 需要频繁合并多个优先队列的场景
    - 动态维护多个集合的最大值
    - 猴王问题中的群体合并
    """
    
    def __init__(self, n):
        """
        初始化左偏树的数据结构
        
        参数：
        - n: 最大节点数，用于预分配数组空间
        
        时间复杂度：O(n)
        空间复杂度：O(n)
        """
        self.MAXN = n + 1
        
        # 预分配数组空间，提高访问效率
        # power[i]: 猴子i的武力值
        self.power = [0] * self.MAXN
        
        # 左偏树相关数组
        # left[i]: 节点i的左子节点编号，0表示空节点
        self.left = [0] * self.MAXN
        # right[i]: 节点i的右子节点编号，0表示空节点
        self.right = [0] * self.MAXN
        # dist[i]: 节点i到最近外节点的距离，空节点距离为-1
        self.dist = [0] * self.MAXN
        
        # 并查集相关数组
        # father[i]: 并查集中节点i的父节点，用于快速查找
        self.father = [0] * self.MAXN
    
    def prepare(self, n):
        """
        初始化每个节点的状态，准备左偏树和并查集
        
        参数：
        - n: 节点数量
        
        时间复杂度：O(n)
        空间复杂度：O(n)
        
        实现细节：
        1. 设置空节点（索引为0）的距离为-1，这是左偏树算法的基本约定
        2. 每个节点初始化为独立的单节点树
        3. 初始化并查集，每个节点的父节点指向自己
        4. 设置初始距离为0（叶子节点的距离）
        """
        # 空节点的距离定义为-1，这是左偏树算法的基础约定
        # 空节点是没有左右子树的节点，即外节点
        self.dist[0] = -1
        
        # 初始化每个节点为独立的单节点树
        for i in range(1, n + 1):
            # 初始时没有左右子节点，设为0（空节点）
            self.left[i] = self.right[i] = self.dist[i] = 0
            # 并查集初始化：每个节点的父节点指向自己
            self.father[i] = i
    
    def find(self, i):
        """
        并查集查找函数，带路径压缩优化
        
        参数：
        - i: 要查找的节点编号
        
        返回：
        - 节点i所在群体的根节点编号
        
        时间复杂度：均摊O(α(n))，其中α是阿克曼函数的反函数，实际应用中近似O(1)
        空间复杂度：O(α(n))，递归调用栈的深度
        
        实现原理：
        路径压缩是并查集的关键优化，将查找路径上的每个节点都直接指向根节点，
        使得后续的查找操作几乎变为常数时间。这是一种均摊分析的优化技术。
        """
        # 基础情况：如果节点i的父节点是它自己，说明i是根节点
        if self.father[i] == i:
            return i
        
        # 路径压缩：递归查找根节点，并将当前节点的父节点直接指向根节点
        # 这使得后续对该节点的查找可以一步到位
        self.father[i] = self.find(self.father[i])
        
        # 返回找到的根节点
        return self.father[i]
    
    def merge(self, i, j):
        """
        合并两棵左偏树，这是左偏树最核心的操作
        
        参数：
        - i: 第一棵左偏树的根节点编号
        - j: 第二棵左偏树的根节点编号
        
        返回：
        - 合并后新树的根节点编号
        
        时间复杂度：O(log n)
        空间复杂度：O(log n)，递归调用栈的深度
        
        算法原理：
        1. 递归终止条件：如果其中一棵树为空，直接返回另一棵树
        2. 维护堆性质：确保较大值节点作为根
        3. 递归合并：将另一棵树合并到根节点的右子树
        4. 维护左偏性质：确保左子树距离不小于右子树
        5. 更新距离：根节点的距离等于右子节点距离加1
        6. 更新父指针：确保并查集的正确性
        
        左偏树合并的核心思想是：
        - 始终维护大根堆性质
        - 通过左偏性质保证树高为O(log n)
        - 合并过程中的交换操作保证左偏性质
        """
        # 递归终止条件：如果其中一个树为空，返回另一棵树
        if i == 0 or j == 0:
            return i + j  # 巧妙处理空树情况
        
        # 维护大根堆性质：确保值较大的节点作为根
        if self.power[i] < self.power[j]:
            # 交换i和j，保证i的值较大
            i, j = j, i
        
        # 核心合并操作：将另一棵树递归合并到当前根的右子树
        # 这是左偏树合并的关键步骤，保证合并后树的平衡性
        self.right[i] = self.merge(self.right[i], j)
        
        # 维护左偏性质：确保左子树的距离不小于右子树
        # 这一步是左偏树能保持O(log n)高度的关键
        if self.dist[self.left[i]] < self.dist[self.right[i]]:
            # 交换左右子节点，维持左偏性质
            self.left[i], self.right[i] = self.right[i], self.left[i]
        
        # 更新当前节点的距离
        # 节点的距离定义为到最近外节点的距离，等于右子节点距离加1
        self.dist[i] = self.dist[self.right[i]] + 1
        
        # 更新子节点的父指针，确保并查集正确维护
        # 这一步对于后续的find操作正确性至关重要
        if self.left[i] != 0:
            self.father[self.left[i]] = i
        if self.right[i] != 0:
            self.father[self.right[i]] = i
        
        # 返回合并后的根节点
        return i
    
    def pop(self, i):
        """
        删除堆顶元素（最大武力值的猴子），并维护左偏树的性质
        
        参数：
        - i: 堆顶节点编号（即当前群体的最大武力值猴子）
        
        返回：
        - 删除堆顶后新树的根节点编号
        
        时间复杂度：O(log n)
        空间复杂度：O(log n)，递归调用栈的深度
        
        实现步骤：
        1. 断开父指针：将左右子节点的父指针设为自身
        2. 合并子树：将左右子树合并成新的树
        3. 更新父指针：将删除节点的父指针指向新的根
        4. 清空节点信息：重置节点的子节点和距离
        
        关键技术点：
        - 并查集路径压缩带来的挑战：需要确保所有可能指向被删除节点的指针都能找到新根
        - 通过让被删除节点的父指针指向新根，解决路径压缩的问题
        """
        # 步骤1：断开左右子节点与父节点的关系
        # 将子节点的父指针设置为自身，使它们成为独立的树
        if self.left[i] != 0:
            self.father[self.left[i]] = self.left[i]
        if self.right[i] != 0:
            self.father[self.right[i]] = self.right[i]
        
        # 步骤2：合并左右子树，形成新的树
        # 步骤3：更新被删除节点的父指针，指向新树的根
        # 这一步非常重要，可以解决并查集路径压缩带来的问题
        # 即使有其他节点通过路径压缩直接指向i，也能找到正确的根
        self.father[i] = self.merge(self.left[i], self.right[i])
        
        # 步骤4：清空被删除节点的信息，防止后续操作错误
        self.left[i] = self.right[i] = self.dist[i] = 0
        
        # 返回新树的根节点
        return self.father[i]
    
    def fight(self, x, y):
        """
        模拟一次猴王战斗
        
        参数：
        - x: 第一只猴子的编号
        - y: 第二只猴子的编号
        
        返回：
        - 战斗结果：-1表示在同一群体，否则返回合并后群体的最大战斗力
        
        时间复杂度：O(log n)
        空间复杂度：O(log n)
        
        实现步骤：
        1. 检查两只猴子是否在同一个群体
        2. 从两个群体中取出战斗力最大的猴子
        3. 战斗后武力值减半
        4. 重新合并到左偏树中
        5. 返回合并后群体的最大战斗力
        """
        # 找到x和y所在的群体代表节点
        a = self.find(x)
        b = self.find(y)
        
        # 如果在同一个群体，无法战斗
        if a == b:
            return -1
        
        # 从两个群体中取出战斗力最大的猴子
        l = self.pop(a)
        r = self.pop(b)
        
        # 战斗后武力值减半（向下取整）
        self.power[a] //= 2
        self.power[b] //= 2
        
        # 重新合并到左偏树中
        self.father[a] = self.father[b] = self.father[l] = self.father[r] = \
            self.merge(self.merge(l, a), self.merge(r, b))
        
        # 返回合并后群体的最大战斗力
        return self.power[self.father[a]]

def main():
    """
    主函数：处理输入输出，执行猴王战斗模拟
    
    【功能说明】
    1. 读取多组测试数据
    2. 初始化左偏树数据结构
    3. 读取每只猴子的武力值
    4. 处理每次战斗，输出战斗结果
    
    【性能优化】
    - 输入效率优化：一次性读取所有输入，减少IO次数
    - 输出效率优化：直接使用print函数输出结果
    
    【边界条件处理】
    - 处理多组测试数据
    - 处理空行
    - 处理战斗结果为-1的情况
    
    时间复杂度：O(m * log n)
    空间复杂度：O(n)
    """
    # 优化：一次性读取所有输入，减少IO次数
    lines = []
    for line in sys.stdin:
        lines.append(line.strip())
    
    i = 0
    while i < len(lines):
        # 跳过空行
        if not lines[i]:
            i += 1
            continue
            
        # 读取猴子数量n
        n = int(lines[i])
        i += 1
        
        # 创建并初始化左偏树
        tree = LeftistTree(n)
        tree.prepare(n)
        
        # 读入每只猴子的武力值
        power_values = list(map(int, lines[i].split()))
        i += 1
        
        for j in range(1, n + 1):
            tree.power[j] = power_values[j - 1]
        
        # 读取战斗次数m
        m = int(lines[i])
        i += 1
        
        # 处理每次战斗
        for _ in range(m):
            # 读取战斗的两只猴子编号
            x, y = map(int, lines[i].split())
            i += 1
            # 输出战斗结果
            print(tree.fight(x, y))

if __name__ == "__main__":
    main()

'''
算法分析：

时间复杂度：
1. 初始化：O(n)
2. 合并操作：O(log n)
3. 删除堆顶：O(log n)
4. 查找操作：近似O(1)（由于路径压缩）
5. 总体：O(m * log n)

空间复杂度：O(n)

算法思路：
1. 使用左偏树维护每个群体，支持快速合并和删除最大值
2. 使用并查集快速判断两只猴子是否在同一个群体
3. 每次战斗：
   - 通过并查集判断是否在同一群体
   - 从两个群体中删除最大武力值的猴子
   - 两个猴子武力值减半后重新加入对应群体
   - 合并两个群体

工程化考虑：
1. 输入输出优化：一次性读取所有输入避免多次IO操作
2. 内存管理：合理使用数组，避免动态内存分配
3. 代码可读性：添加详细注释，清晰的变量命名

与标准库对比：
1. Python标准库中的heapq不支持高效合并操作
2. 左偏树在合并操作上有明显优势
3. 但在单次操作性能上可能不如优化的二叉堆

调试技巧：
1. 可以添加打印函数验证左偏树结构
2. 注意检查并查集的路径压缩是否正确
3. 特别关注武力值减半后的处理

极端情况：
1. 所有猴子武力值相同
2. 只有一个猴子
3. 所有战斗都在相同群体内（都输出-1）
'''