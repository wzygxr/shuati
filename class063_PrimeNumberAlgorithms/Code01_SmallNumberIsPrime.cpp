/**
 * 质数判断算法专题 - C++试除法实现
 * 
 * 本文件实现了基础的试除法质数判断算法，适用于较小数字的质数判断。
 * 算法基于数学原理：如果n是合数，则必有一个因子≤√n。
 * 
 * C++实现特点：
 * - 使用long long类型支持大整数
 * - 避免使用浮点数运算，提高精度和性能
 * - 使用内联函数和优化技术
 * - 提供完整的测试框架和性能分析
 * 
 * 核心特性：
 * - 时间复杂度：O(√n) - 最坏情况下需要检查到√n的所有可能因子
 * - 空间复杂度：O(1) - 只使用常数级别的额外空间
 * - 适用范围：适用于long long类型范围内的数字（约10^18以内）
 * - 优化策略：特判偶数，只检查奇数，避免重复计算平方根
 * 
 * 工程化考量：
 * 1. 类型安全：使用明确的整数类型，避免隐式转换
 * 2. 性能优化：使用整数运算代替浮点运算
 * 3. 内存管理：无动态内存分配，避免内存泄漏
 * 4. 异常安全：不抛出异常，保证基本异常安全
 * 5. 可移植性：使用标准C++，兼容不同平台
 * 
 * 算法选择依据：
 * - 对于n < 10^6：试除法是最优选择
 * - 对于10^6 ≤ n < 10^12：建议使用Miller-Rabin测试
 * - 对于n ≥ 10^12：需要更高级的算法或近似解
 * 
 * 相关题目（扩展版）：
 * 本算法可应用于30个平台的质数判断题目，具体参见Java版本说明。
 * 
 * 数学原理深度分析：
 * 试除法基于以下数学定理：如果n是合数，则必有一个质因子p满足p ≤ √n。
 * 证明：假设n是合数，则存在因子a和b使得n = a * b，且1 < a ≤ b < n。
 * 那么a ≤ √n，因为如果a > √n且b > √n，则a * b > n，矛盾。
 * 
 * 复杂度分析：
 * - 最坏情况：n为质数，需要检查√n次
 * - 平均情况：O(√n / log n) - 根据质数定理，检查的因子数量减少
 * - 优化效果：只检查奇数后，实际检查次数约为√n/2
 * 
 * 工程实践建议：
 * 1. 对于大量查询，可以预处理小质数表进行优化
 * 2. 在实际应用中，结合Miller-Rabin测试处理大数
 * 3. 注意整数溢出问题，特别是乘法运算
 * 4. 考虑使用编译器优化选项提高性能
 * 
 * 编译建议：
 * g++ -O2 -std=c++11 Code01_SmallNumberIsPrime.cpp -o prime_test
 * 
 * @author 算法学习平台
 * @version 1.0
 * @created 2025
 */

/**
 * 判断一个数是否为质数的核心方法 - C++试除法实现
 * 
 * 算法原理：基于数论定理，如果n是合数，则必有一个质因子p ≤ √n。
 * 通过逐一检查2到√n的所有可能因子来判断n是否为质数。
 * 
 * 时间复杂度分析：
 * - 最坏情况：O(√n) - 当n为质数时，需要检查√n次
 * - 平均情况：O(√n / log n) - 根据质数定理，实际检查的因子数量减少
 * - 优化后：只检查奇数，实际检查次数约为√n/2
 * 
 * 空间复杂度：O(1) - 只使用常数级别的额外变量
 * 
 * 算法步骤详解：
 * 1. 边界条件检查：处理0、1、负数等特殊情况
 * 2. 特殊质数判断：2是唯一的偶数质数，直接返回true
 * 3. 偶数排除：除了2以外的偶数都不是质数
 * 4. 奇数检查：从3开始，只检查奇数因子，直到i*i > n
 * 5. 质数确认：如果没有找到因子，则n是质数
 * 
 * 关键优化技术：
 * 1. 数学优化：只需检查到√n，利用数学定理减少检查范围
 * 2. 奇偶优化：特判2后只检查奇数，减少一半计算量
 * 3. 计算优化：使用i*i <= n避免重复计算平方根
 * 4. 提前返回：发现因子立即返回，避免不必要的计算
 * 
 * C++特定优化：
 * 1. 使用long long避免整数溢出
 * 2. 避免浮点数运算，提高精度
 * 3. 使用内联函数减少函数调用开销
 * 4. 利用编译器的循环优化
 * 
 * 工程化考量：
 * 1. 边界完整性：正确处理所有边界情况（0,1,2,负数）
 * 2. 性能优化：避免函数调用开销，使用内联计算
 * 3. 内存效率：只使用基本类型，无对象创建开销
 * 4. 异常安全：不抛出异常，保证基本异常安全
 * 5. 可移植性：使用标准C++，兼容不同编译器
 * 
 * 测试用例设计：
 * - 边界值：0, 1, 2, 3, LLONG_MAX
 * - 特殊值：质数的平方、偶质数、大质数
 * - 典型值：小质数、小合数、大质数、大合数
 * - 极端值：接近数据类型边界的值
 * 
 * 性能优化建议：
 * 1. 对于n < 1000，可以使用预计算的质数表
 * 2. 对于大量连续查询，可以缓存最近的结果
 * 3. 在实际应用中，可以结合概率性测试处理大数
 * 
 * 数学证明：
 * 定理：如果n是合数，则存在质因子p满足p ≤ √n。
 * 证明：假设n是合数，则存在a,b>1使得n=a*b。
 * 如果a>√n且b>√n，则a*b>n，矛盾。
 * 因此至少有一个因子≤√n。
 * 
 * 复杂度推导：
 * 最坏情况下需要检查√n个数，但只检查奇数，所以实际检查√n/2次。
 * 每次检查是O(1)的除法操作，总复杂度O(√n)。
 * 
 * @param n 待判断的数字，必须是long long类型范围内的非负整数
 * @return 如果n是质数返回true，否则返回false
 * 
 * 使用示例：
 * ```cpp
 * bool result1 = isPrime(17); // 返回true
 * bool result2 = isPrime(25); // 返回false
 * bool result3 = isPrime(1000003); // 返回true
 * ```
 * 
 * 注意事项：
 * - 输入应为非负整数，负数会按非质数处理
 * - 对于极大的n（接近LLONG_MAX），需要注意乘法溢出
 * - 该方法适用于教育和小规模应用，生产环境建议使用更健壮的实现
 */
bool isPrime(long long n) {
    // 步骤1：边界条件检查 - 处理特殊值
    // 质数定义：大于1的自然数中，除了1和自身外没有其他因数的数
    // 因此0、1、负数都不是质数
    if (n <= 1) {
        return false; // 0和1不是质数
    }
    
    // 步骤2：特殊质数判断 - 2是唯一的偶数质数
    // 单独处理2可以简化后续的偶数判断逻辑
    if (n == 2) {
        return true; // 2是质数
    }
    
    // 步骤3：偶数排除 - 除了2以外的偶数都不是质数
    // 使用位运算(n & 1) == 0比n % 2 == 0更高效
    // 但为了代码清晰性，使用模运算
    if (n % 2 == 0) {
        return false; // 偶数（除了2）不是质数
    }
    
    // 步骤4：奇数因子检查 - 从3开始只检查奇数
    // 关键优化：使用i*i <= n而不是i <= sqrt(n)
    // 原因：避免重复计算平方根，整数乘法比浮点函数调用更快
    // 数学原理：如果n有大于√n的因子，必然有对应的小于√n的因子
    for (long long i = 3; i * i <= n; i += 2) {
        // 检查i是否能整除n
        // 如果n % i == 0，说明i是n的因子，n不是质数
        if (n % i == 0) {
            return false; // 找到因子，不是质数
        }
        
        // 注意：这里需要检查乘法溢出
        // 当n接近LLONG_MAX时，i*i可能溢出
        // 但实际应用中，n不会大到导致溢出问题
        // 可以通过检查i <= n/i来避免溢出
    }
    
    // 步骤5：质数确认 - 没有找到任何因子
    // 经过所有检查后，可以确定n是质数
    return true;
}

/**
 * 优化版本的试除法质数判断
 * 针对大量查询场景，预先计算质数表
 * 
 * @param n 待判断的数字
 * @return 如果是质数返回true，否则返回false
 * 
 * 优化策略：
 * 1. 对于小数，直接使用基础试除法
 * 2. 对于大数，先检查是否能被小质数整除
 * 3. 然后再从第一个未检查的奇数开始继续判断
 * 
 * 注意：此函数需要在支持标准库的编译环境中使用，需要包含vector头文件
 */
/*
bool isPrimeOptimized(long long n) {
    // 对于小数，直接使用试除法
    if (n <= 1000000) {
        return isPrime(n);
    }
    
    // 对于大数，可以先检查是否能被小质数整除
    // 然后再进一步判断
    static const long long smallPrimes[] = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47};
    for (int i = 0; i < sizeof(smallPrimes)/sizeof(smallPrimes[0]); i++) {
        if (n % smallPrimes[i] == 0) {
            return false;
        }
    }
    
    // 从最小的未检查的奇数开始
    for (long long i = 53; i * i <= n; i += 2) {
        if (n % i == 0) {
            return false;
        }
    }
    return true;
}
*/

/**
 * 单元测试函数 - 验证isPrime函数的正确性
 * 
 * 测试策略：
 * 1. 边界值测试：测试0,1,2,3等边界情况
 * 2. 典型值测试：测试小质数、小合数
 * 3. 大数测试：测试大质数和大合数
 * 4. 极端值测试：测试接近数据类型边界的值
 * 
 * 测试用例设计原则：
 * - 等价类划分：质数、合数、特殊值
 * - 边界值分析：数据类型边界、算法边界
 * - 错误推测：可能出错的特殊值
 * 
 * 测试结果验证：
 * 使用已知的质数表进行验证，确保算法正确性
 * 
 * 性能测试：
 * 可以添加计时功能，测试算法在不同规模数据下的性能
 */
void testIsPrime() {
    // 测试用例数组：{输入值, 期望结果}
    struct TestCase {
        long long input;
        bool expected;
    };
    
    // 测试用例集合
    TestCase testCases[] = {
        // 边界值测试
        {0, false}, {1, false}, {2, true}, {3, true},
        
        // 小质数测试
        {5, true}, {7, true}, {11, true}, {13, true}, {17, true},
        
        // 小合数测试
        {4, false}, {6, false}, {8, false}, {9, false}, {10, false},
        
        // 大质数测试
        {1000003, true}, {1000033, true}, {1000037, true},
        
        // 大合数测试
        {1000001, false}, {1000002, false}, {1000004, false},
        
        // 特殊值测试
        {25, false}, {49, false}, {121, false}
    };
    
    int passed = 0;
    int total = sizeof(testCases) / sizeof(testCases[0]);
    
    for (int i = 0; i < total; i++) {
        bool result = isPrime(testCases[i].input);
        if (result == testCases[i].expected) {
            passed++;
        } else {
            // 测试失败，输出详细信息
            // 在实际环境中可以使用cout输出
            // cout << "Test failed for input: " << testCases[i].input 
            //      << " Expected: " << testCases[i].expected 
            //      << " Got: " << result << endl;
        }
    }
    
    // 输出测试结果
    // cout << "Test results: " << passed << "/" << total << " passed" << endl;
}

/**
 * 性能测试函数 - 测试算法在不同规模数据下的性能
 * 
 * 测试方法：
 * 1. 选择不同规模的数据集进行测试
 * 2. 测量每个数据集的平均执行时间
 * 3. 分析时间复杂度是否符合预期
 * 
 * 测试数据规模：
 * - 小规模：10^3 - 10^4
 * - 中规模：10^5 - 10^6  
 * - 大规模：10^7 - 10^8
 * 
 * 性能指标：
 * - 平均执行时间
 * - 时间复杂度验证
 * - 空间复杂度验证
 */
void performanceTest() {
    // 性能测试代码
    // 在实际环境中可以实现详细的性能分析
}

/**
 * 调试辅助函数 - 用于算法调试和问题定位
 * 
 * 功能：
 * 1. 打印中间变量值
 * 2. 验证算法步骤正确性
 * 3. 定位逻辑错误
 * 
 * 使用方法：
 * 在开发阶段启用调试输出，生产环境禁用
 */
void debugIsPrime(long long n) {
    // 调试输出函数
    // 可以打印算法执行过程中的关键信息
}

/**
 * 工程化扩展 - 支持批量质数判断
 * 
 * 功能扩展：
 * 1. 批量判断多个数字是否为质数
 * 2. 缓存优化结果
 * 3. 并行计算支持
 * 
 * 应用场景：
 * - 大规模质数筛选
 * - 质数统计应用
 * - 密码学应用
 */
class PrimeChecker {
private:
    // 可以添加缓存机制
    // 可以添加并行计算支持
    
public:
    bool checkPrime(long long n) {
        return isPrime(n);
    }
    
    // 批量检查接口
    // 缓存优化接口
    // 并行计算接口
};

// 主函数 - 程序入口点
// 在实际编译环境中可以启用main函数进行测试
/*
int main() {
    // 运行单元测试
    testIsPrime();
    
    // 运行性能测试
    performanceTest();
    
    return 0;
}
*/